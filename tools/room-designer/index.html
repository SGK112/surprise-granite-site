<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Room Designer Pro | Powered by Remodely.ai | Surprise Granite</title>
  <link rel="icon" href="https://cdn.prod.website-files.com/6456ce4476abb25581fbad0c/6456ce4476abb269c6fbb176_Surprise-Granite-favicon-32x32px.png">
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">

  <!-- Three.js for 3D -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

  <!-- Supabase -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

  <!-- Auth System -->
  <script>
    // Initialize global Supabase client for sg-auth.js
    window._sgSupabaseClient = null;
    document.addEventListener('DOMContentLoaded', function() {
      if (window.supabase && window.supabase.createClient) {
        window._sgSupabaseClient = window.supabase.createClient(
          'https://ypeypgwsycxcagncgdur.supabase.co',
          'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InlwZXlwZ3dzeWN4Y2FnbmNnZHVyIiwicm9sZSI6ImFub24iLCJpYXQiOjE3Njc3NTQ4MjMsImV4cCI6MjA4MzMzMDgyM30.R13pNv2FDtGhfeu7gUcttYNrQAbNYitqR4FIq3O2-ME'
        );
      }
    });
  </script>
  <script src="/js/sg-auth.js"></script>

  <!-- PDF Export -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

  <!-- SheetJS for Excel/CSV parsing -->
  <script src="https://cdn.sheetjs.com/xlsx-0.20.1/package/dist/xlsx.full.min.js"></script>

  <style>
    :root {
      --primary: #6366f1;
      --primary-dark: #4f46e5;
      --gold: #f9cb00;
      --gold-dark: #d4ab00;
      --dark: #0f0f1a;
      --dark-surface: #1a1a2e;
      --dark-elevated: #252540;
      --dark-hover: #2d2d4a;
      --text: #ffffff;
      --text-secondary: rgba(255,255,255,0.7);
      --text-muted: rgba(255,255,255,0.5);
      --border: rgba(255,255,255,0.1);
      --success: #10b981;
      --warning: #f59e0b;
      --error: #ef4444;
      --remodely-gradient: linear-gradient(135deg, #4285F4 0%, #34A853 33%, #FBBC05 66%, #EA4335 100%);
    }

    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      font-family: 'Inter', -apple-system, sans-serif;
      background: var(--dark);
      color: var(--text);
      min-height: 100vh;
      overflow: hidden;
    }

    .app {
      height: 100vh;
      display: flex;
      flex-direction: column;
    }

    /* Header */
    .header {
      background: var(--dark-surface);
      border-bottom: 1px solid var(--border);
      padding: 0 20px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      height: 56px;
      flex-shrink: 0;
    }

    .header-left {
      display: flex;
      align-items: center;
      gap: 20px;
    }

    .logo-group {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .logo {
      display: flex;
      align-items: center;
      gap: 8px;
      text-decoration: none;
    }

    .logo img {
      height: 28px;
    }

    .logo-divider {
      width: 1px;
      height: 24px;
      background: var(--border);
    }

    .powered-by {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 11px;
      color: var(--text-muted);
    }

    .powered-by .remodely-badge {
      background: var(--remodely-gradient);
      padding: 3px 8px;
      border-radius: 4px;
      font-weight: 600;
      font-size: 10px;
      color: white;
    }

    .project-input {
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 6px 12px;
      color: var(--text);
      font-size: 14px;
      font-weight: 500;
      min-width: 200px;
    }

    .project-input:focus {
      outline: none;
      border-color: var(--primary);
    }

    .header-center {
      display: flex;
      gap: 4px;
      background: var(--dark-elevated);
      padding: 4px;
      border-radius: 8px;
    }

    .view-btn {
      padding: 8px 16px;
      background: transparent;
      border: none;
      color: var(--text-muted);
      font-size: 13px;
      font-weight: 500;
      cursor: pointer;
      border-radius: 6px;
      transition: all 0.2s;
    }

    .view-btn:hover {
      color: var(--text);
    }

    .view-btn.active {
      background: var(--primary);
      color: white;
    }

    .header-right {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .btn {
      padding: 8px 16px;
      border-radius: 6px;
      font-size: 13px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      gap: 6px;
      border: none;
    }

    .btn-secondary {
      background: var(--dark-elevated);
      color: var(--text);
      border: 1px solid var(--border);
    }

    .btn-secondary:hover {
      background: var(--dark-hover);
    }

    .btn-primary {
      background: var(--gold);
      color: #000;
    }

    .btn-primary:hover {
      background: var(--gold-dark);
    }

    .btn-sm {
      padding: 6px 10px;
      font-size: 11px;
    }

    /* Export Dropdown */
    .export-dropdown {
      position: relative;
    }

    .export-menu {
      position: absolute;
      top: 100%;
      right: 0;
      margin-top: 4px;
      background: var(--dark-surface);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 8px 0;
      min-width: 180px;
      box-shadow: 0 10px 40px rgba(0,0,0,0.4);
      z-index: 1000;
      display: none;
    }

    .export-menu.show {
      display: block;
    }

    .export-menu button {
      width: 100%;
      padding: 10px 16px;
      background: none;
      border: none;
      color: var(--text);
      font-size: 13px;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 10px;
      text-align: left;
    }

    .export-menu button:hover {
      background: var(--dark-hover);
    }

    .export-menu button svg {
      flex-shrink: 0;
      color: var(--text-muted);
    }

    .export-divider {
      height: 1px;
      background: var(--border);
      margin: 8px 0;
    }

    /* Main Layout */
    .main {
      flex: 1;
      display: flex;
      overflow: hidden;
    }

    /* Sidebar */
    .sidebar {
      width: 220px;
      background: var(--dark-surface);
      border-right: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      flex-shrink: 0;
      overflow-y: auto;
    }

    .sidebar-section {
      border-bottom: 1px solid var(--border);
    }

    .sidebar-header {
      padding: 12px 16px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      cursor: pointer;
    }

    .sidebar-header:hover {
      background: var(--dark-hover);
    }

    .sidebar-title {
      font-size: 11px;
      font-weight: 600;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .sidebar-toggle {
      color: var(--text-muted);
      font-size: 10px;
    }

    .sidebar-content {
      padding: 0 12px 12px;
    }

    .sidebar-content.collapsed {
      display: none;
    }

    /* Floor Plans Grid */
    .floorplan-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 8px;
    }

    .floorplan-item {
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 10px;
      cursor: pointer;
      transition: all 0.2s;
      text-align: center;
    }

    .floorplan-item:hover {
      background: var(--dark-hover);
      border-color: var(--primary);
    }

    .floorplan-item.active {
      border-color: var(--primary);
      background: rgba(99, 102, 241, 0.15);
    }

    .floorplan-preview {
      width: 100%;
      height: 40px;
      margin-bottom: 6px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .floorplan-preview svg {
      width: 100%;
      height: 100%;
    }

    .floorplan-name {
      font-size: 10px;
      color: var(--text-secondary);
    }

    /* Tool Grid */
    .tool-grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 4px;
    }

    .tool-btn {
      aspect-ratio: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: var(--dark-elevated);
      border: 1px solid transparent;
      border-radius: 6px;
      color: var(--text-muted);
      cursor: pointer;
      transition: all 0.2s;
      padding: 6px;
    }

    .tool-btn:hover {
      background: var(--dark-hover);
      color: var(--text);
    }

    .tool-btn.active {
      background: var(--primary);
      color: white;
      border-color: var(--primary);
    }

    .tool-btn svg {
      width: 18px;
      height: 18px;
      margin-bottom: 2px;
    }

    .tool-btn span {
      font-size: 8px;
      font-weight: 500;
    }

    /* Element Grid */
    .element-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 6px;
    }

    .element-item {
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 8px;
      cursor: grab;
      transition: all 0.2s;
      text-align: center;
      position: relative;
    }

    .element-item:hover {
      background: var(--dark-hover);
      border-color: var(--primary);
    }

    .element-item:active {
      cursor: grabbing;
    }

    .element-item.has-texture {
      border-color: var(--success);
    }

    .element-icon {
      width: 44px;
      height: 44px;
      margin: 0 auto 6px;
      border-radius: 6px;
      background-size: cover;
      background-position: center;
      box-shadow: 0 2px 4px rgba(0,0,0,0.3);
      border: 1px solid rgba(255,255,255,0.1);
      overflow: hidden;
    }

    .element-icon.element-svg {
      background: var(--dark-hover);
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 4px;
    }

    .element-icon.element-svg svg {
      width: 100%;
      height: 100%;
    }

    .element-name {
      font-size: 9px;
      font-weight: 500;
      color: var(--text-secondary);
    }

    .element-upload-btn {
      position: absolute;
      top: 4px;
      right: 4px;
      width: 16px;
      height: 16px;
      background: var(--dark-surface);
      border: 1px solid var(--border);
      border-radius: 3px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      opacity: 0;
      transition: all 0.2s;
    }

    .element-item:hover .element-upload-btn {
      opacity: 1;
    }

    .element-upload-btn:hover {
      background: var(--primary);
      border-color: var(--primary);
    }

    .element-upload-btn svg {
      width: 10px;
      height: 10px;
      color: var(--text);
    }

    /* Materials Library */
    .materials-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 6px;
    }

    .material-item {
      aspect-ratio: 1;
      border-radius: 6px;
      cursor: pointer;
      border: 2px solid transparent;
      transition: all 0.2s;
      background-size: cover;
      background-position: center;
      position: relative;
    }

    .material-item:hover {
      border-color: var(--primary);
      transform: scale(1.05);
    }

    .material-item.selected {
      border-color: var(--gold);
    }

    .material-item::after {
      content: attr(data-name);
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      padding: 2px 4px;
      font-size: 8px;
      text-align: center;
      border-radius: 0 0 4px 4px;
    }

    .materials-tabs {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
      margin-bottom: 10px;
    }

    .material-tab {
      padding: 4px 8px;
      font-size: 10px;
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      border-radius: 4px;
      color: var(--text-muted);
      cursor: pointer;
      transition: all 0.2s;
    }

    .material-tab:hover {
      color: var(--text);
      border-color: var(--primary);
    }

    .material-tab.active {
      background: var(--primary);
      color: white;
      border-color: var(--primary);
    }

    .material-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 8px;
    }

    .material-swatch {
      aspect-ratio: 1;
      border-radius: 8px;
      cursor: pointer;
      border: 2px solid transparent;
      transition: all 0.2s;
      background-size: cover;
      background-position: center;
      position: relative;
      overflow: hidden;
    }

    .material-swatch:hover {
      border-color: var(--primary);
      transform: scale(1.03);
    }

    .material-swatch.selected {
      border-color: var(--gold);
      box-shadow: 0 0 10px rgba(249, 203, 0, 0.4);
    }

    .material-swatch-label {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: linear-gradient(transparent, rgba(0,0,0,0.85));
      padding: 20px 6px 6px;
      font-size: 9px;
      text-align: center;
      font-weight: 500;
    }

    .material-price-badge {
      position: absolute;
      top: 4px;
      right: 4px;
      background: var(--gold);
      color: #000;
      padding: 2px 5px;
      border-radius: 4px;
      font-size: 8px;
      font-weight: 600;
      z-index: 2;
    }

    .material-brand-badge {
      position: absolute;
      top: 4px;
      left: 4px;
      background: rgba(0,0,0,0.7);
      color: #fff;
      padding: 2px 5px;
      border-radius: 4px;
      font-size: 7px;
      font-weight: 500;
      z-index: 2;
      text-transform: uppercase;
      letter-spacing: 0.3px;
    }

    .material-hint {
      font-size: 10px;
      color: var(--text-muted);
      text-align: center;
      margin-top: 10px;
      padding: 8px;
      background: var(--dark-elevated);
      border-radius: 6px;
      border: 1px dashed var(--border);
    }

    /* Cabinet Catalog */
    .catalog-brand select,
    .catalog-series select {
      width: 100%;
      padding: 6px 10px;
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      border-radius: 6px;
      color: var(--text);
      font-size: 12px;
      margin-bottom: 8px;
      cursor: pointer;
    }

    .catalog-brand select:focus,
    .catalog-series select:focus {
      outline: none;
      border-color: var(--primary);
    }

    .cabinet-catalog-list {
      max-height: 200px;
      overflow-y: auto;
      border: 1px solid var(--border);
      border-radius: 6px;
      background: var(--dark);
    }

    .cabinet-catalog-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 8px 10px;
      border-bottom: 1px solid var(--border);
      cursor: pointer;
      transition: background 0.15s;
    }

    .cabinet-catalog-item:last-child {
      border-bottom: none;
    }

    .cabinet-catalog-item:hover {
      background: var(--dark-elevated);
    }

    .cabinet-catalog-item.dragging {
      opacity: 0.5;
    }

    .cabinet-item-info {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .cabinet-item-sku {
      font-size: 10px;
      color: var(--text-muted);
      font-family: monospace;
    }

    .cabinet-item-name {
      font-size: 11px;
      color: var(--text);
      font-weight: 500;
    }

    .cabinet-item-size {
      font-size: 10px;
      color: var(--primary);
    }

    .cabinet-item-add {
      width: 24px;
      height: 24px;
      border-radius: 4px;
      background: var(--primary);
      border: none;
      color: white;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      font-weight: bold;
      transition: background 0.15s;
    }

    .cabinet-item-add:hover {
      background: var(--primary-dark);
    }

    .catalog-actions {
      margin-top: 10px;
      display: flex;
      gap: 6px;
    }

    .catalog-actions .btn {
      flex: 1;
      justify-content: center;
    }

    /* Canvas Area */
    .canvas-area {
      flex: 1;
      display: flex;
      flex-direction: column;
      background: #12121f;
      position: relative;
      overflow: hidden;
    }

    .canvas-toolbar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 16px;
      background: var(--dark-surface);
      border-bottom: 1px solid var(--border);
      flex-shrink: 0;
    }

    .toolbar-group {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .toolbar-divider {
      width: 1px;
      height: 20px;
      background: var(--border);
      margin: 0 8px;
    }

    .zoom-controls {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .zoom-btn {
      width: 28px;
      height: 28px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      border-radius: 4px;
      color: var(--text);
      cursor: pointer;
      font-size: 14px;
    }

    .zoom-btn:hover {
      background: var(--dark-hover);
    }

    .zoom-level {
      font-size: 12px;
      color: var(--text-secondary);
      min-width: 40px;
      text-align: center;
    }

    .canvas-info {
      display: flex;
      gap: 16px;
      font-size: 11px;
      color: var(--text-muted);
    }

    .canvas-wrapper {
      flex: 1;
      position: relative;
      overflow: hidden;
      cursor: crosshair;
    }

    #canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }

    /* 3D View */
    #three-container {
      position: absolute;
      inset: 0;
      display: none;
    }

    #three-container.active {
      display: block;
    }

    /* Right Panel */
    .right-panel {
      width: 260px;
      background: var(--dark-surface);
      border-left: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      flex-shrink: 0;
      overflow-y: auto;
    }

    .panel-section {
      padding: 12px 16px;
      border-bottom: 1px solid var(--border);
    }

    .panel-title {
      font-size: 11px;
      font-weight: 600;
      color: var(--text-muted);
      text-transform: uppercase;
      margin-bottom: 10px;
    }

    .room-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 8px;
    }

    .input-group {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .input-label {
      font-size: 10px;
      color: var(--text-muted);
    }

    .input-field {
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      border-radius: 4px;
      padding: 6px 8px;
      color: var(--text);
      font-size: 12px;
    }

    .input-field:focus {
      outline: none;
      border-color: var(--primary);
    }

    select.input-field {
      cursor: pointer;
    }

    /* Properties Panel */
    .properties-empty {
      text-align: center;
      padding: 20px;
      color: var(--text-muted);
      font-size: 12px;
    }

    .property-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }

    .property-label {
      font-size: 11px;
      color: var(--text-secondary);
    }

    .property-input {
      width: 70px;
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      border-radius: 4px;
      padding: 5px 6px;
      color: var(--text);
      font-size: 11px;
      text-align: right;
    }

    .property-input:focus {
      outline: none;
      border-color: var(--primary);
    }

    .property-select {
      width: 100px;
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      border-radius: 4px;
      padding: 4px 6px;
      color: var(--text);
      font-size: 10px;
      cursor: pointer;
    }

    .property-select:hover {
      border-color: var(--primary);
    }

    .property-select:focus {
      outline: none;
      border-color: var(--primary);
    }

    .dimension-display {
      font-size: 10px;
      color: var(--gold);
      margin-left: 6px;
      white-space: nowrap;
      min-width: 50px;
    }

    .color-picker {
      width: 70px;
      height: 26px;
      border: 1px solid var(--border);
      border-radius: 4px;
      cursor: pointer;
      padding: 0;
    }

    .texture-preview {
      width: 70px;
      height: 40px;
      border-radius: 4px;
      background-size: cover;
      background-position: center;
      border: 1px solid var(--border);
      cursor: pointer;
    }

    .texture-preview:hover {
      border-color: var(--primary);
    }

    .texture-controls {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .texture-upload-btn,
    .texture-clear-btn {
      width: 28px;
      height: 28px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      border-radius: 4px;
      cursor: pointer;
      color: var(--text-secondary);
      font-size: 12px;
      padding: 0;
    }

    .texture-upload-btn:hover {
      background: var(--primary);
      border-color: var(--primary);
      color: white;
    }

    .texture-clear-btn:hover {
      background: var(--error);
      border-color: var(--error);
      color: white;
    }

    .texture-upload-btn svg {
      width: 14px;
      height: 14px;
    }

    /* Validation Panel */
    .validation-section {
      border-bottom: 1px solid var(--border);
      padding-bottom: 8px;
      margin-bottom: 8px;
    }

    .validation-section .panel-title {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .validation-toggle,
    .validation-refresh {
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      border-radius: 4px;
      color: var(--text-secondary);
      cursor: pointer;
      font-size: 12px;
      padding: 2px 6px;
      margin-left: auto;
    }

    .validation-toggle:hover,
    .validation-refresh:hover {
      background: var(--primary);
      color: white;
      border-color: var(--primary);
    }

    .validation-toggle.active {
      background: var(--success);
      color: white;
      border-color: var(--success);
    }

    .validation-content {
      padding: 8px 16px;
      font-size: 11px;
      max-height: 180px;
      overflow-y: auto;
    }

    .validation-hint {
      color: var(--text-muted);
      font-style: italic;
    }

    .validation-ok {
      color: var(--success);
      font-weight: 500;
    }

    .validation-category {
      margin-bottom: 10px;
    }

    .validation-category-title {
      font-weight: 600;
      color: var(--text-secondary);
      margin-bottom: 4px;
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .validation-issue {
      display: flex;
      align-items: flex-start;
      gap: 6px;
      padding: 4px 0;
      border-bottom: 1px solid var(--border);
    }

    .validation-issue:last-child {
      border-bottom: none;
    }

    .validation-icon {
      flex-shrink: 0;
      font-size: 12px;
    }

    .validation-error .validation-icon {
      color: var(--error);
    }

    .validation-warning .validation-icon {
      color: var(--gold);
    }

    .validation-info .validation-icon {
      color: var(--primary);
    }

    .validation-message {
      color: var(--text-secondary);
      line-height: 1.3;
    }

    /* Quote Panel */
    .quote-section {
      flex: 1;
      display: flex;
      flex-direction: column;
      min-height: 0;
    }

    .quote-items {
      flex: 1;
      overflow-y: auto;
      padding: 0 16px;
    }

    .quote-item {
      display: flex;
      justify-content: space-between;
      padding: 8px 0;
      border-bottom: 1px solid var(--border);
      font-size: 11px;
    }

    .quote-item-name {
      color: var(--text-secondary);
    }

    .quote-item-value {
      color: var(--text);
      font-weight: 500;
    }

    .quote-total {
      padding: 12px 16px;
      background: var(--dark-elevated);
      border-top: 1px solid var(--border);
    }

    .quote-total-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .quote-total-label {
      font-size: 12px;
      font-weight: 600;
      color: var(--text);
    }

    .quote-total-value {
      font-size: 18px;
      font-weight: 700;
      color: var(--gold);
    }

    /* Context Menu */
    .context-menu {
      position: fixed;
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 6px 0;
      min-width: 160px;
      z-index: 1000;
      box-shadow: 0 8px 32px rgba(0,0,0,0.4);
    }

    .context-menu-item {
      padding: 8px 14px;
      font-size: 12px;
      color: var(--text-secondary);
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .context-menu-item:hover {
      background: var(--dark-hover);
      color: var(--text);
    }

    .context-menu-item.danger {
      color: var(--error);
    }

    .context-menu-item svg {
      width: 14px;
      height: 14px;
    }

    .context-menu-divider {
      height: 1px;
      background: var(--border);
      margin: 4px 0;
    }

    .context-menu-label {
      padding: 6px 14px;
      font-size: 10px;
      color: var(--text-muted);
      text-transform: uppercase;
      font-weight: 600;
    }

    /* Modals */
    .modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.7);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1001;
    }

    .modal-overlay.active {
      display: flex;
    }

    .modal {
      background: var(--dark-surface);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 20px;
      width: 100%;
      max-width: 500px;
      max-height: 80vh;
      overflow-y: auto;
    }

    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 16px;
    }

    .modal-title {
      font-size: 16px;
      font-weight: 600;
    }

    .modal-close {
      width: 28px;
      height: 28px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: var(--dark-elevated);
      border: none;
      border-radius: 4px;
      color: var(--text-muted);
      cursor: pointer;
      font-size: 18px;
    }

    .modal-close:hover {
      background: var(--dark-hover);
      color: var(--text);
    }

    /* Hide close button on required modals */
    .modal-overlay[data-required="true"] .modal-close {
      display: none;
    }

    /* Login Modal Styles */
    .login-modal {
      max-width: 440px !important;
      padding: 32px !important;
    }

    .google-signin-btn {
      width: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 12px;
      padding: 14px 20px;
      background: #fff;
      border: 1px solid #dadce0;
      border-radius: 8px;
      font-size: 15px;
      font-weight: 500;
      color: #3c4043;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .google-signin-btn:hover {
      background: #f8f9fa;
      border-color: #c6c6c6;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    }

    .login-divider {
      display: flex;
      align-items: center;
      margin: 24px 0;
      color: var(--text-muted);
      font-size: 13px;
    }

    .login-divider::before,
    .login-divider::after {
      content: '';
      flex: 1;
      height: 1px;
      background: var(--border);
    }

    .login-divider span {
      padding: 0 16px;
    }

    /* Material Picker Modal */
    .material-categories {
      display: flex;
      gap: 8px;
      margin-bottom: 16px;
      flex-wrap: wrap;
    }

    .material-category-btn {
      padding: 6px 12px;
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      border-radius: 4px;
      color: var(--text-secondary);
      font-size: 11px;
      cursor: pointer;
    }

    .material-category-btn:hover {
      border-color: var(--primary);
    }

    .material-category-btn.active {
      background: var(--primary);
      border-color: var(--primary);
      color: white;
    }

    .materials-modal-grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 10px;
    }

    .material-modal-item {
      aspect-ratio: 1;
      border-radius: 8px;
      cursor: pointer;
      border: 2px solid transparent;
      background-size: cover;
      background-position: center;
      position: relative;
      overflow: hidden;
    }

    .material-modal-item:hover {
      border-color: var(--primary);
    }

    .material-modal-item.selected {
      border-color: var(--gold);
    }

    .material-modal-item .material-name {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.8);
      padding: 4px 6px;
      font-size: 9px;
      text-align: center;
    }

    .material-modal-item .material-price {
      position: absolute;
      top: 4px;
      right: 4px;
      padding: 2px 6px;
      border-radius: 4px;
      font-size: 8px;
      font-weight: 600;
      color: white;
      text-shadow: 0 1px 2px rgba(0,0,0,0.3);
    }

    .material-modal-item .material-brand {
      position: absolute;
      top: 4px;
      left: 4px;
      padding: 2px 5px;
      border-radius: 3px;
      font-size: 7px;
      font-weight: 500;
      background: rgba(0,0,0,0.7);
      color: white;
    }

    .material-modal-item.daltile-material {
      border: 1px solid rgba(99, 102, 241, 0.3);
    }

    .material-modal-item.daltile-material:hover {
      border-color: var(--primary);
      box-shadow: 0 0 0 2px rgba(99, 102, 241, 0.2);
    }

    .upload-material-btn {
      aspect-ratio: 1;
      border-radius: 8px;
      border: 2px dashed var(--border);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      color: var(--text-muted);
      gap: 4px;
    }

    .upload-material-btn:hover {
      border-color: var(--primary);
      color: var(--primary);
    }

    .upload-material-btn svg {
      width: 24px;
      height: 24px;
    }

    .upload-material-btn span {
      font-size: 9px;
    }

    /* Share Modal */
    .share-link-box {
      display: flex;
      gap: 8px;
      margin-bottom: 16px;
    }

    .share-link-input {
      flex: 1;
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 10px 12px;
      color: var(--text);
      font-size: 12px;
    }

    .permission-options {
      display: flex;
      gap: 8px;
      margin-bottom: 16px;
    }

    .permission-btn {
      flex: 1;
      padding: 10px;
      background: var(--dark-elevated);
      border: 2px solid var(--border);
      border-radius: 6px;
      color: var(--text-secondary);
      cursor: pointer;
      text-align: center;
    }

    .permission-btn:hover {
      border-color: var(--primary);
    }

    .permission-btn.active {
      border-color: var(--primary);
      background: rgba(99, 102, 241, 0.1);
      color: var(--text);
    }

    .permission-btn-title {
      font-size: 12px;
      font-weight: 600;
      margin-bottom: 2px;
    }

    .permission-btn-desc {
      font-size: 10px;
      color: var(--text-muted);
    }

    /* Enhanced Share Modal */
    .share-status {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 12px;
      font-size: 12px;
      color: var(--text-secondary);
    }

    .share-status .status-indicator {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--text-muted);
    }

    .permission-section h4 {
      font-size: 12px;
      margin-bottom: 12px;
      color: var(--text-secondary);
    }

    #shareModal .permission-options {
      flex-direction: column;
    }

    #shareModal .permission-btn {
      display: flex;
      align-items: center;
      gap: 12px;
      text-align: left;
    }

    .permission-icon {
      width: 36px;
      height: 36px;
      min-width: 36px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: var(--dark-hover);
      border-radius: 8px;
    }

    .permission-icon svg {
      width: 18px;
      height: 18px;
      stroke: var(--text-secondary);
    }

    .permission-info {
      flex: 1;
    }

    .share-actions {
      margin-top: 16px;
    }

    .active-shares {
      margin-top: 20px;
      padding-top: 16px;
      border-top: 1px solid var(--border);
    }

    .active-shares h4,
    .recent-activity h4 {
      font-size: 12px;
      margin-bottom: 12px;
      color: var(--text-secondary);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .recent-activity {
      margin-top: 16px;
      padding-top: 16px;
      border-top: 1px solid var(--border);
    }

    .activity-list {
      max-height: 200px;
      overflow-y: auto;
    }

    .activity-item {
      display: flex;
      align-items: flex-start;
      gap: 10px;
      padding: 10px;
      background: var(--dark-elevated);
      border-radius: 6px;
      margin-bottom: 6px;
      font-size: 12px;
    }

    .activity-icon {
      width: 28px;
      height: 28px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      flex-shrink: 0;
    }

    .activity-icon.view { background: rgba(99, 102, 241, 0.2); }
    .activity-icon.comment { background: rgba(249, 203, 0, 0.2); }
    .activity-icon.approve { background: rgba(16, 185, 129, 0.2); }
    .activity-icon.reject { background: rgba(239, 68, 68, 0.2); }

    .activity-content {
      flex: 1;
    }

    .activity-text {
      color: var(--text-primary);
      line-height: 1.4;
    }

    .activity-time {
      color: var(--text-muted);
      font-size: 10px;
      margin-top: 2px;
    }

    .share-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px;
      background: var(--dark-elevated);
      border-radius: 6px;
      margin-bottom: 8px;
    }

    .share-info {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .share-permission {
      font-size: 11px;
      font-weight: 500;
    }

    .share-stats {
      font-size: 10px;
      color: var(--text-muted);
    }

    .share-item .share-actions {
      display: flex;
      gap: 8px;
      margin-top: 0;
    }

    .share-item .share-actions button {
      margin-left: 0;
      padding: 6px 12px;
      font-size: 11px;
    }

    /* Pricing Section in Properties */
    .pricing-section {
      margin-top: 16px;
      padding-top: 12px;
      border-top: 1px solid var(--border);
    }

    .property-section-title {
      font-size: 10px;
      font-weight: 600;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 10px;
    }

    .price-override-group {
      display: flex;
      gap: 4px;
    }

    .price-input {
      width: 70px !important;
    }

    .margin-input {
      width: 60px !important;
    }

    .property-select-sm {
      width: 50px;
      padding: 5px 4px;
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      border-radius: 4px;
      color: var(--text);
      font-size: 10px;
    }

    .price-result {
      margin-top: 8px;
      padding-top: 8px;
      border-top: 1px dashed var(--border);
    }

    .price-highlight {
      color: var(--gold);
      font-weight: 600;
    }

    /* Enhanced Quote Panel */
    .quote-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .quote-view-toggle {
      display: flex;
      background: var(--dark-elevated);
      border-radius: 4px;
      padding: 2px;
    }

    .toggle-btn {
      padding: 4px 8px;
      font-size: 10px;
      background: transparent;
      border: none;
      color: var(--text-muted);
      cursor: pointer;
      border-radius: 3px;
      transition: all 0.2s;
    }

    .toggle-btn:hover {
      color: var(--text-secondary);
    }

    .toggle-btn.active {
      background: var(--primary);
      color: white;
    }

    .quote-actions {
      display: flex;
      gap: 6px;
      margin: 10px 0;
    }

    .quote-actions .btn {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 10px;
      padding: 6px 8px;
    }

    .quote-summary {
      margin-top: 10px;
    }

    .quote-row {
      display: flex;
      justify-content: space-between;
      padding: 4px 0;
      font-size: 11px;
      color: var(--text-secondary);
    }

    .margin-badge {
      display: inline-block;
      font-size: 9px;
      background: var(--dark-hover);
      padding: 2px 5px;
      border-radius: 3px;
      margin-left: 6px;
      color: var(--text-muted);
    }

    /* Price List Modal */
    .price-list-tabs {
      display: flex;
      gap: 4px;
      margin-bottom: 16px;
      border-bottom: 1px solid var(--border);
      padding-bottom: 8px;
    }

    .tab-btn {
      padding: 8px 16px;
      background: transparent;
      border: none;
      color: var(--text-muted);
      cursor: pointer;
      font-size: 12px;
      border-radius: 4px;
      transition: all 0.2s;
    }

    .tab-btn:hover {
      color: var(--text-secondary);
      background: var(--dark-elevated);
    }

    .tab-btn.active {
      background: var(--dark-elevated);
      color: var(--text);
    }

    .price-tab {
      min-height: 200px;
    }

    .upload-dropzone {
      border: 2px dashed var(--border);
      border-radius: 8px;
      padding: 40px 20px;
      text-align: center;
      cursor: pointer;
      transition: all 0.2s;
    }

    .upload-dropzone:hover {
      border-color: var(--primary);
      background: rgba(99, 102, 241, 0.05);
    }

    .column-mapping {
      padding: 16px 0;
    }

    .mapping-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
    }

    .mapping-row label {
      font-size: 12px;
      color: var(--text-secondary);
    }

    .mapping-row select {
      width: 200px;
    }

    .mapping-preview {
      margin: 16px 0;
      padding: 12px;
      background: var(--dark-elevated);
      border-radius: 6px;
    }

    .preview-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 11px;
    }

    .preview-table th,
    .preview-table td {
      padding: 8px 6px;
      text-align: left;
      border-bottom: 1px solid var(--border);
    }

    .preview-table th {
      background: var(--dark-hover);
      font-weight: 600;
      font-size: 10px;
      text-transform: uppercase;
    }

    .mapping-actions {
      display: flex;
      justify-content: flex-end;
      gap: 8px;
      margin-top: 16px;
    }

    .saved-lists {
      min-height: 100px;
    }

    .price-list-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: var(--dark-elevated);
      border-radius: 6px;
      margin-bottom: 8px;
    }

    .price-list-name {
      font-weight: 500;
      font-size: 13px;
    }

    .price-list-date {
      font-size: 11px;
      color: var(--text-muted);
    }

    .current-prices-header {
      margin-bottom: 12px;
    }

    .search-input {
      width: 100%;
      padding: 10px 12px;
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      border-radius: 6px;
      color: var(--text);
      font-size: 12px;
    }

    .current-prices-list {
      max-height: 300px;
      overflow-y: auto;
    }

    .price-category-header {
      font-size: 11px;
      font-weight: 600;
      color: var(--text-muted);
      text-transform: uppercase;
      padding: 8px 0 4px;
      margin-top: 8px;
      border-bottom: 1px solid var(--border);
    }

    .current-price-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 4px;
      font-size: 11px;
      border-bottom: 1px solid var(--dark-elevated);
    }

    .price-item-name {
      flex: 1;
    }

    .price-item-sku {
      width: 80px;
      color: var(--text-muted);
      font-size: 10px;
    }

    .price-item-value {
      font-weight: 500;
      color: var(--gold);
    }

    .empty-state {
      text-align: center;
      color: var(--text-muted);
      padding: 20px;
      font-size: 12px;
    }

    /* Margin Modal */
    .margin-section {
      padding: 8px 0;
    }

    .margin-global {
      margin-bottom: 16px;
    }

    .margin-global label {
      display: block;
      font-size: 12px;
      margin-bottom: 6px;
      color: var(--text-secondary);
    }

    .margin-input-group {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .margin-input-group input {
      width: 80px;
    }

    .margin-symbol {
      font-size: 12px;
      color: var(--text-muted);
    }

    .margin-categories h4 {
      font-size: 12px;
      margin-bottom: 12px;
      color: var(--text-secondary);
    }

    .category-margin-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 0;
      border-bottom: 1px solid var(--dark-elevated);
    }

    .category-margin-row span {
      font-size: 12px;
    }

    .modal-footer {
      display: flex;
      justify-content: flex-end;
      gap: 8px;
      margin-top: 20px;
      padding-top: 16px;
      border-top: 1px solid var(--border);
    }

    /* Permission Notice */
    .permission-notice {
      position: fixed;
      top: 60px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 1002;
      animation: slideDown 0.3s ease;
    }

    .notice-content {
      display: flex;
      align-items: center;
      gap: 10px;
      background: var(--dark-surface);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 12px 16px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.3);
      font-size: 12px;
    }

    @keyframes slideDown {
      from { opacity: 0; transform: translateX(-50%) translateY(-10px); }
      to { opacity: 1; transform: translateX(-50%) translateY(0); }
    }

    /* Presentation Mode */
    body.presentation-mode .sidebar,
    body.presentation-mode .right-panel {
      display: none;
    }

    body.presentation-mode .canvas-container {
      width: 100%;
    }

    /* Button danger variant */
    .btn-danger {
      background: var(--error);
      color: white;
    }

    .btn-danger:hover {
      background: #dc2626;
    }

    /* ============================================= */
    /* Minimal Professional Loading Screen */
    /* ============================================= */
    .cloud-preloader {
      position: fixed;
      inset: 0;
      background: #0a0a0a;
      z-index: 99999;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      transition: opacity 0.6s ease, visibility 0.6s ease;
    }

    .cloud-preloader.loaded {
      opacity: 0;
      visibility: hidden;
      pointer-events: none;
    }

    /* Main Content */
    .preloader-content {
      text-align: center;
      opacity: 0;
      animation: contentFadeIn 0.8s ease-out 0.2s forwards;
    }

    @keyframes contentFadeIn {
      0% { opacity: 0; transform: translateY(10px); }
      100% { opacity: 1; transform: translateY(0); }
    }

    /* Company Name */
    .preloader-company {
      font-family: 'Inter', -apple-system, sans-serif;
      font-size: 2.5rem;
      font-weight: 700;
      color: #ffffff;
      margin-bottom: 8px;
      letter-spacing: -0.02em;
    }

    .preloader-tagline {
      font-size: 1rem;
      color: rgba(255,255,255,0.4);
      margin-bottom: 48px;
    }

    /* Loading Bar */
    .preloader-loading {
      width: 200px;
      margin: 0 auto;
    }

    .preloader-bar {
      height: 2px;
      background: rgba(255,255,255,0.1);
      border-radius: 2px;
      overflow: hidden;
    }

    .preloader-bar-fill {
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, #4285F4, #EA4335, #FBBC05, #34A853);
      border-radius: 2px;
      transition: width 0.3s ease;
    }

    /* Powered By Badge */
    .preloader-powered {
      position: absolute;
      bottom: 40px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      align-items: center;
      gap: 8px;
      opacity: 0;
      animation: poweredFadeIn 0.6s ease-out 0.8s forwards;
    }

    @keyframes poweredFadeIn {
      0% { opacity: 0; }
      100% { opacity: 1; }
    }

    .preloader-powered-icon {
      width: 20px;
      height: 20px;
    }

    .preloader-powered-icon svg {
      width: 20px;
      height: 20px;
    }

    .preloader-powered-text {
      font-size: 12px;
      color: rgba(255,255,255,0.3);
    }

    .preloader-powered-brand {
      color: rgba(255,255,255,0.5);
      font-weight: 600;
    }

    /* Hide old elements */
    .blueprint-grid,
    .blueprint-corners,
    .preloader-main,
    .room-wireframe,
    .steps-flow,
    .progress-section,
    .designer-section,
    .powered-by-section { display: none !important; }

    .cad-element.countertop {
      display: none;
      width: 240px;
      height: 40px;
      bottom: 60px;
      left: 80px;
      border-color: rgba(249, 203, 0, 0.7);
      animation: elementPlace 0.6s ease-out 2s forwards;
    }

    .cad-element.countertop::before { border-color: rgba(249, 203, 0, 0.5); }

    .cad-element.cabinet {
      width: 80px;
      height: 100px;
      bottom: 60px;
      left: 80px;
      border-color: rgba(139, 92, 246, 0.7);
      animation: elementPlace 0.6s ease-out 2.3s forwards;
    }

    .cad-element.cabinet::before { border-color: rgba(139, 92, 246, 0.5); }

    .cad-element.cabinet-2 {
      width: 80px;
      height: 100px;
      bottom: 60px;
      left: 180px;
      border-color: rgba(139, 92, 246, 0.7);
      animation: elementPlace 0.6s ease-out 2.5s forwards;
    }

    .cad-element.island {
      width: 120px;
      height: 80px;
      bottom: 120px;
      left: 180px;
      border-color: rgba(34, 197, 94, 0.7);
      animation: elementPlace 0.6s ease-out 2.7s forwards;
    }

    .cad-element.island::before { border-color: rgba(34, 197, 94, 0.5); }

    .cad-element.appliance {
      width: 50px;
      height: 50px;
      bottom: 60px;
      right: 80px;
      border-color: rgba(239, 68, 68, 0.7);
      animation: elementPlace 0.6s ease-out 2.9s forwards;
    }

    .cad-element.appliance::before { border-color: rgba(239, 68, 68, 0.5); }

    @keyframes elementPlace {
      0% {
        opacity: 0;
        transform: scale(0.8);
        filter: blur(4px);
      }
      50% {
        opacity: 1;
        border-color: inherit;
        box-shadow: 0 0 20px currentColor;
      }
      100% {
        opacity: 1;
        transform: scale(1);
        filter: blur(0);
        box-shadow: 0 0 10px currentColor;
      }
    }

    /* Node Connection Lines - ReactFlow Style */
    .node-connections {
      position: absolute;
      inset: 0;
      pointer-events: none;
      opacity: 0;
      animation: connectionsFadeIn 0.8s ease-out 3.2s forwards;
    }

    @keyframes connectionsFadeIn {
      0% { opacity: 0; }
      100% { opacity: 1; }
    }

    .connection-line {
      position: absolute;
      background: linear-gradient(90deg, rgba(59, 130, 246, 0.6), rgba(139, 92, 246, 0.6));
      height: 2px;
      transform-origin: left center;
      animation: lineGrow 0.5s ease-out forwards;
    }

    .connection-line::after {
      content: '';
      position: absolute;
      right: -4px;
      top: -3px;
      width: 8px;
      height: 8px;
      background: rgba(139, 92, 246, 0.8);
      border-radius: 50%;
      box-shadow: 0 0 10px rgba(139, 92, 246, 0.6);
    }

    @keyframes lineGrow {
      0% { width: 0; }
      100% { width: 100%; }
    }

    /* Right Side Panel */
    .preloader-panel {
      width: 320px;
      display: flex;
      flex-direction: column;
      gap: 24px;
    }

    /* Brand Section */
    /* Designer/Company Section - Main Focus */
    .designer-section {
      text-align: center;
      opacity: 0;
      animation: designerFadeIn 0.8s ease-out 0.8s forwards;
      margin-bottom: 32px;
    }

    @keyframes designerFadeIn {
      0% { opacity: 0; transform: translateY(-20px); }
      100% { opacity: 1; transform: translateY(0); }
    }

    .designer-label {
      font-size: 11px;
      color: rgba(255,255,255,0.5);
      letter-spacing: 3px;
      text-transform: uppercase;
      margin-bottom: 12px;
    }

    .designer-company {
      font-family: 'Inter', -apple-system, sans-serif;
      font-size: 1.8rem;
      font-weight: 800;
      color: #ffffff;
      margin-bottom: 6px;
      line-height: 1.2;
    }

    .designer-tagline {
      font-size: 13px;
      color: rgba(255,255,255,0.5);
    }

    /* Steps Node Flow */
    .steps-flow {
      display: flex;
      flex-direction: column;
      gap: 0;
      position: relative;
    }

    .step-node {
      display: flex;
      align-items: center;
      gap: 16px;
      padding: 12px 16px;
      background: rgba(255,255,255,0.03);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 12px;
      position: relative;
      opacity: 0;
      transform: translateX(-20px);
      transition: all 0.4s ease;
    }

    .step-node.visible {
      opacity: 1;
      transform: translateX(0);
    }

    .step-node.active {
      background: rgba(66, 133, 244, 0.1);
      border-color: rgba(66, 133, 244, 0.4);
      box-shadow: 0 0 30px rgba(66, 133, 244, 0.2);
    }

    .step-node.completed {
      background: rgba(34, 197, 94, 0.08);
      border-color: rgba(34, 197, 94, 0.2);
    }

    .step-node-icon {
      width: 40px;
      height: 40px;
      border-radius: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      background: rgba(255,255,255,0.05);
      border: 1px solid rgba(255,255,255,0.1);
      transition: all 0.3s ease;
    }

    .step-node.active .step-node-icon {
      background: linear-gradient(135deg, rgba(66, 133, 244, 0.3), rgba(52, 168, 83, 0.3));
      border-color: rgba(66, 133, 244, 0.5);
      box-shadow: 0 0 20px rgba(66, 133, 244, 0.4);
    }

    .step-node.completed .step-node-icon {
      background: rgba(34, 197, 94, 0.2);
      border-color: rgba(34, 197, 94, 0.4);
    }

    .step-node-content {
      flex: 1;
    }

    .step-node-title {
      font-size: 13px;
      font-weight: 600;
      color: rgba(255,255,255,0.9);
      margin-bottom: 2px;
    }

    .step-node-desc {
      font-size: 11px;
      color: rgba(255,255,255,0.4);
    }

    .step-node.active .step-node-title {
      color: #4285F4;
    }

    .step-node.completed .step-node-title {
      color: rgba(34, 197, 94, 0.9);
    }

    /* Connection between nodes */
    .step-connector {
      width: 2px;
      height: 16px;
      background: rgba(255,255,255,0.1);
      margin-left: 35px;
      position: relative;
      overflow: hidden;
    }

    .step-connector::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 0%;
      background: linear-gradient(180deg, rgba(66, 133, 244, 0.6), rgba(52, 168, 83, 0.6));
      transition: height 0.3s ease;
    }

    .step-connector.filled::after {
      height: 100%;
    }

    /* Progress Section */
    .progress-section {
      background: rgba(255,255,255,0.03);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 16px;
      padding: 20px;
      opacity: 0;
      animation: progressFadeIn 0.6s ease-out 1.2s forwards;
    }

    @keyframes progressFadeIn {
      0% { opacity: 0; transform: scale(0.95); }
      100% { opacity: 1; transform: scale(1); }
    }

    .progress-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
    }

    .progress-label {
      font-size: 12px;
      font-weight: 600;
      color: rgba(255,255,255,0.7);
      text-transform: uppercase;
      letter-spacing: 2px;
    }

    .progress-percent {
      font-size: 14px;
      font-weight: 700;
      color: #818cf8;
    }

    .progress-bar-container {
      height: 8px;
      background: rgba(255,255,255,0.1);
      border-radius: 8px;
      overflow: hidden;
    }

    .progress-bar-fill {
      height: 100%;
      background: linear-gradient(90deg, #4285F4, #34A853, #FBBC05, #EA4335);
      border-radius: 8px;
      width: 0%;
      transition: width 0.5s cubic-bezier(0.4, 0, 0.2, 1);
      position: relative;
    }

    .progress-bar-fill::after {
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
      animation: shimmer 1.5s infinite;
    }

    @keyframes shimmer {
      0% { transform: translateX(-100%); }
      100% { transform: translateX(100%); }
    }

    /* Powered By Remodely Badge */
    .powered-by-section {
      position: absolute;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      opacity: 0;
      animation: poweredByFadeIn 0.6s ease-out 1.5s forwards;
    }

    @keyframes poweredByFadeIn {
      0% { opacity: 0; transform: translateX(-50%) translateY(10px); }
      100% { opacity: 1; transform: translateX(-50%) translateY(0); }
    }

    .powered-by-badge {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px 20px;
      background: rgba(255,255,255,0.05);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 50px;
      backdrop-filter: blur(10px);
    }

    .powered-by-icon {
      width: 22px;
      height: 22px;
    }

    .powered-by-icon svg {
      width: 22px;
      height: 22px;
    }

    .powered-by-text {
      display: flex;
      align-items: center;
      gap: 5px;
    }

    .powered-by-label {
      font-size: 11px;
      color: rgba(255,255,255,0.4);
    }

    .powered-by-brand {
      font-size: 12px;
      font-weight: 700;
      color: #ffffff;
    }

    /* Scan Line */
    .scan-line {
      position: absolute;
      left: 0;
      right: 0;
      height: 2px;
      background: linear-gradient(90deg, transparent, rgba(66, 133, 244, 0.6), rgba(52, 168, 83, 0.6), rgba(251, 188, 5, 0.6), transparent);
      box-shadow: 0 0 20px rgba(66, 133, 244, 0.4);
      animation: scanDown 4s ease-in-out infinite;
      pointer-events: none;
    }

    @keyframes scanDown {
      0% { top: -2px; opacity: 0; }
      10% { opacity: 1; }
      90% { opacity: 1; }
      100% { top: 100%; opacity: 0; }
    }

    /* Mobile Responsive */
    @media (max-width: 900px) {
      .preloader-main {
        flex-direction: column;
        gap: 30px;
      }

      .room-wireframe {
        width: 300px;
        height: 220px;
      }

      .preloader-panel {
        width: 100%;
        max-width: 350px;
      }

      .cad-element.countertop { width: 180px; height: 30px; left: 60px; }
      .cad-element.cabinet { width: 60px; height: 75px; left: 60px; }
      .cad-element.cabinet-2 { width: 60px; height: 75px; left: 130px; }
      .cad-element.island { width: 90px; height: 60px; left: 130px; }
    }

    /* Review Room */
    .loading-shared {
      pointer-events: none;
    }

    .loading-shared::after {
      display: none; /* Hide old loading, use cloud preloader instead */
      background: rgba(0,0,0,0.9);
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-size: 18px;
      z-index: 9999;
    }

    .review-room {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      z-index: 1000;
    }

    .review-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 20px;
      background: linear-gradient(135deg, var(--dark-surface) 0%, #1a1a35 100%);
      border-bottom: 1px solid var(--border);
    }

    .review-header-left {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .review-title {
      font-size: 18px;
      font-weight: 600;
      color: var(--gold);
    }

    .review-permission-badge {
      padding: 4px 10px;
      background: var(--primary);
      border-radius: 12px;
      font-size: 11px;
      font-weight: 500;
    }

    .review-header-right {
      display: flex;
      gap: 8px;
    }

    .review-panel {
      position: fixed;
      top: 56px;
      right: -380px;
      width: 380px;
      height: calc(100vh - 56px);
      background: var(--dark-surface);
      border-left: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      transition: right 0.3s ease;
      z-index: 999;
    }

    .review-panel.open {
      right: 0;
    }

    .review-panel-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 16px;
      border-bottom: 1px solid var(--border);
    }

    .review-panel-header h3 {
      font-size: 14px;
      font-weight: 600;
    }

    .review-panel-close {
      width: 28px;
      height: 28px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: var(--dark-elevated);
      border: none;
      border-radius: 4px;
      color: var(--text-muted);
      cursor: pointer;
      font-size: 18px;
    }

    .review-summary {
      display: flex;
      padding: 16px;
      gap: 16px;
      background: var(--dark-elevated);
      border-bottom: 1px solid var(--border);
    }

    .review-stat {
      flex: 1;
      text-align: center;
    }

    .stat-value {
      display: block;
      font-size: 20px;
      font-weight: 700;
      color: var(--gold);
    }

    .stat-value.approved {
      color: var(--success);
    }

    .stat-label {
      font-size: 10px;
      color: var(--text-muted);
      text-transform: uppercase;
    }

    .review-elements {
      flex: 1;
      overflow-y: auto;
      padding: 12px;
    }

    .review-element {
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 12px;
      margin-bottom: 8px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .review-element:hover {
      border-color: var(--primary);
    }

    .review-element.approved {
      border-color: var(--success);
      background: rgba(16, 185, 129, 0.1);
    }

    .review-element.rejected {
      border-color: var(--error);
      background: rgba(239, 68, 68, 0.1);
    }

    .review-element-header {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 6px;
    }

    .review-element-status {
      width: 20px;
      height: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 50%;
      font-size: 12px;
      background: var(--dark-hover);
    }

    .review-element-status.approved {
      background: var(--success);
      color: white;
    }

    .review-element-status.rejected {
      background: var(--error);
      color: white;
    }

    .review-element-name {
      flex: 1;
      font-weight: 500;
      font-size: 13px;
    }

    .review-element-price {
      font-weight: 600;
      color: var(--gold);
      font-size: 13px;
    }

    .review-element-details {
      display: flex;
      gap: 12px;
      font-size: 11px;
      color: var(--text-muted);
      margin-bottom: 8px;
    }

    .review-element-material {
      color: var(--text-secondary);
    }

    .review-element-actions {
      display: flex;
      gap: 6px;
      padding-top: 8px;
      border-top: 1px solid var(--border);
    }

    .btn-approve, .btn-reject, .btn-comment {
      flex: 1;
      padding: 6px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      transition: all 0.2s;
    }

    .btn-approve {
      background: rgba(16, 185, 129, 0.2);
      color: var(--success);
    }

    .btn-approve:hover {
      background: var(--success);
      color: white;
    }

    .btn-reject {
      background: rgba(239, 68, 68, 0.2);
      color: var(--error);
    }

    .btn-reject:hover {
      background: var(--error);
      color: white;
    }

    .btn-comment {
      background: var(--dark-hover);
      color: var(--text-secondary);
    }

    .btn-comment:hover {
      background: var(--primary);
      color: white;
    }

    .review-comments-section {
      border-top: 1px solid var(--border);
      padding: 12px;
    }

    .review-comments-section h4 {
      font-size: 12px;
      margin-bottom: 8px;
      color: var(--text-secondary);
    }

    .review-comments {
      max-height: 150px;
      overflow-y: auto;
      margin-bottom: 8px;
    }

    .review-comment {
      background: var(--dark-elevated);
      border-radius: 6px;
      padding: 8px;
      margin-bottom: 6px;
      font-size: 12px;
    }

    .comment-header {
      display: flex;
      gap: 8px;
      margin-bottom: 4px;
      font-size: 10px;
      color: var(--text-muted);
    }

    .comment-author {
      font-weight: 600;
      color: var(--text-secondary);
    }

    .comment-element {
      color: var(--primary);
    }

    .comment-text {
      color: var(--text);
    }

    .review-comment-input {
      display: flex;
      gap: 6px;
    }

    .review-comment-input input {
      flex: 1;
      padding: 8px 10px;
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      border-radius: 6px;
      color: var(--text);
      font-size: 12px;
    }

    .review-actions {
      padding: 12px;
      border-top: 1px solid var(--border);
      display: flex;
      gap: 8px;
    }

    .review-actions .btn {
      flex: 1;
    }

    .btn-success {
      background: var(--success);
      color: white;
    }

    .btn-success:hover {
      background: #059669;
    }

    /* Adjust main content when review room is active */
    body:has(.review-room) .header {
      display: none;
    }

    body:has(.review-room) .main-content {
      padding-top: 56px;
    }

    body:has(.review-room) .sidebar {
      margin-top: 56px;
      height: calc(100vh - 56px);
    }

    body:has(.review-room) .right-panel {
      margin-top: 56px;
      height: calc(100vh - 56px);
    }

    body:has(.review-room) .canvas-container {
      height: calc(100vh - 56px);
    }

    body:has(.review-room) .shortcuts-hint {
      display: none;
    }

    /* Hide editing UI in review mode for non-editors */
    body.review-readonly .sidebar {
      display: none;
    }

    body.review-readonly .right-panel .panel-section:not(#quotePanel) {
      display: none;
    }

    /* Keyboard Shortcuts */
    .shortcuts-hint {
      position: fixed;
      bottom: 12px;
      right: 12px;
      background: var(--dark-surface);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 8px 12px;
      font-size: 9px;
      color: var(--text-muted);
      display: flex;
      gap: 12px;
    }

    .shortcut {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .shortcut kbd {
      background: var(--dark-elevated);
      padding: 2px 4px;
      border-radius: 3px;
      font-family: inherit;
      font-size: 9px;
    }

    /* Responsive */
    @media (max-width: 1200px) {
      .sidebar { width: 180px; }
      .right-panel { width: 220px; }
    }

    @media (max-width: 900px) {
      .sidebar, .right-panel { display: none; }
    }
  </style>
</head>
<body>
  <!-- Minimal Loading Screen -->
  <div class="cloud-preloader loaded" id="cloudPreloader">
    <!-- Main Content -->
    <div class="preloader-content">
      <div class="preloader-company" id="preloaderCompanyMain">Your Company</div>
      <div class="preloader-tagline">Design Quote</div>
      <div class="preloader-loading">
        <div class="preloader-bar">
          <div class="preloader-bar-fill" id="preloaderProgressBar"></div>
        </div>
      </div>
    </div>

    <!-- Powered By -->
    <div class="preloader-powered">
      <div class="preloader-powered-icon">
        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" fill="none">
          <defs>
            <linearGradient id="googleGradientBadge" x1="0%" y1="0%" x2="100%" y2="100%">
              <stop offset="0%" style="stop-color:#4285F4"/>
              <stop offset="25%" style="stop-color:#EA4335"/>
              <stop offset="50%" style="stop-color:#FBBC05"/>
              <stop offset="100%" style="stop-color:#34A853"/>
            </linearGradient>
          </defs>
          <path d="M3 21V10l9-7 9 7v11" stroke="url(#googleGradientBadge)" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"/>
          <path d="M21 21h-7" stroke="#34A853" stroke-width="2.5" stroke-linecap="round"/>
        </svg>
      </div>
      <div class="preloader-powered-text">Powered by <span class="preloader-powered-brand">Remodely.ai</span></div>
    </div>
  </div>
  <div class="app">
    <!-- Header -->
    <header class="header">
      <div class="header-left">
        <div class="logo-group">
          <a href="/" class="logo">
            <img src="https://cdn.prod.website-files.com/6456ce4476abb25581fbad0c/6456ce4476abb269c6fbb176_Surprise-Granite-favicon-32x32px.png" alt="Surprise Granite">
          </a>
          <div class="logo-divider"></div>
          <div class="powered-by">
            <span>Powered by</span>
            <span class="remodely-badge">Remodely.ai</span>
          </div>
        </div>
        <input type="text" class="project-input" id="projectName" value="Untitled Project" placeholder="Project name">
      </div>

      <div class="header-center">
        <button class="view-btn active" id="view2D" onclick="setView('2d')">2D Plan</button>
        <button class="view-btn" id="view3D" onclick="setView('3d')">3D View</button>
      </div>

      <div class="header-right">
        <button class="btn btn-secondary" onclick="openShareModal()">
          <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M4 12v8a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-8"/>
            <polyline points="16,6 12,2 8,6"/>
            <line x1="12" y1="2" x2="12" y2="15"/>
          </svg>
          Share
        </button>

        <div class="export-dropdown">
          <button class="btn btn-secondary" onclick="toggleExportMenu()">
            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
              <polyline points="7 10 12 15 17 10"/>
              <line x1="12" y1="15" x2="12" y2="3"/>
            </svg>
            Export
            <svg width="10" height="10" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="margin-left: 4px;">
              <polyline points="6 9 12 15 18 9"/>
            </svg>
          </button>
          <div class="export-menu" id="exportMenu">
            <button onclick="exportToPDF()">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
                <polyline points="14,2 14,8 20,8"/>
                <line x1="16" y1="13" x2="8" y2="13"/>
                <line x1="16" y1="17" x2="8" y2="17"/>
              </svg>
              PDF Proposal
            </button>
            <button onclick="exportToJSON()">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
                <polyline points="14,2 14,8 20,8"/>
                <line x1="9" y1="15" x2="15" y2="15"/>
              </svg>
              Save Design (JSON)
            </button>
            <button onclick="exportToPNG()">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>
                <circle cx="8.5" cy="8.5" r="1.5"/>
                <polyline points="21,15 16,10 5,21"/>
              </svg>
              Export Image (PNG)
            </button>
            <button onclick="exportToCSV()">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
                <polyline points="14,2 14,8 20,8"/>
                <line x1="8" y1="13" x2="16" y2="13"/>
                <line x1="8" y1="17" x2="16" y2="17"/>
                <line x1="12" y1="9" x2="12" y2="21"/>
              </svg>
              Parts List (CSV)
            </button>
            <div class="export-divider"></div>
            <button onclick="importFromJSON()">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                <polyline points="17 8 12 3 7 8"/>
                <line x1="12" y1="3" x2="12" y2="15"/>
              </svg>
              Load Design (JSON)
            </button>
          </div>
        </div>

        <button class="btn btn-primary" onclick="generateQuote()">
          <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
            <polyline points="14,2 14,8 20,8"/>
          </svg>
          Get Quote
        </button>
      </div>
    </header>

    <!-- Main Content -->
    <main class="main">
      <!-- Left Sidebar -->
      <aside class="sidebar">
        <!-- Floor Plans -->
        <div class="sidebar-section">
          <div class="sidebar-header" onclick="toggleSection(this)">
            <span class="sidebar-title">Floor Plans</span>
            <span class="sidebar-toggle"></span>
          </div>
          <div class="sidebar-content">
            <div class="floorplan-grid" id="floorplanGrid">
              <!-- Floor plans will be rendered here -->
            </div>
          </div>
        </div>

        <!-- Tools -->
        <div class="sidebar-section">
          <div class="sidebar-header" onclick="toggleSection(this)">
            <span class="sidebar-title">Tools</span>
            <span class="sidebar-toggle"></span>
          </div>
          <div class="sidebar-content">
            <div class="tool-grid">
              <button class="tool-btn active" id="toolSelect" onclick="setTool('select')" title="Select (V)">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M3 3l7.07 16.97 2.51-7.39 7.39-2.51L3 3z"/>
                </svg>
                <span>Select</span>
              </button>
              <button class="tool-btn" id="toolWall" onclick="setTool('wall')" title="Draw Wall (W)">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <rect x="3" y="3" width="18" height="18" rx="2"/>
                </svg>
                <span>Wall</span>
              </button>
              <button class="tool-btn" id="toolCountertop" onclick="setTool('countertop')" title="Draw Countertop (C)">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <rect x="2" y="8" width="20" height="4" rx="1"/>
                  <rect x="4" y="12" width="16" height="8" fill="none"/>
                </svg>
                <span>Counter</span>
              </button>
              <button class="tool-btn" id="toolPan" onclick="setTool('pan')" title="Pan (H)">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M18 11V6a2 2 0 0 0-2-2a2 2 0 0 0-2 2"/>
                  <path d="M14 10V4a2 2 0 0 0-2-2a2 2 0 0 0-2 2v2"/>
                  <path d="M10 10.5V6a2 2 0 0 0-2-2a2 2 0 0 0-2 2v8"/>
                  <path d="M18 8a2 2 0 1 1 4 0v6a8 8 0 0 1-8 8h-2c-2.8 0-4.5-.86-5.99-2.34l-3.6-3.6a2 2 0 0 1 2.83-2.82L7 15"/>
                </svg>
                <span>Pan</span>
              </button>
              <button class="tool-btn" id="toolMeasure" onclick="setTool('measure')" title="Measure (M)">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M21.3 8.7 8.7 21.3c-1 1-2.5 1-3.4 0l-2.6-2.6c-1-1-1-2.5 0-3.4L15.3 2.7c1-1 2.5-1 3.4 0l2.6 2.6c1 1 1 2.5 0 3.4Z"/>
                </svg>
                <span>Measure</span>
              </button>
            </div>
          </div>
        </div>

        <!-- Cabinets -->
        <div class="sidebar-section">
          <div class="sidebar-header" onclick="toggleSection(this)">
            <span class="sidebar-title">Cabinets</span>
            <span class="sidebar-toggle"></span>
          </div>
          <div class="sidebar-content">
            <div class="element-grid" id="cabinetsGrid">
              <!-- Elements rendered by JS -->
            </div>
          </div>
        </div>

        <!-- Surfaces -->
        <div class="sidebar-section">
          <div class="sidebar-header" onclick="toggleSection(this)">
            <span class="sidebar-title">Surfaces</span>
            <span class="sidebar-toggle"></span>
          </div>
          <div class="sidebar-content">
            <div class="element-grid" id="surfacesGrid">
              <!-- Elements rendered by JS -->
            </div>
          </div>
        </div>

        <!-- Appliances -->
        <div class="sidebar-section">
          <div class="sidebar-header" onclick="toggleSection(this)">
            <span class="sidebar-title">Appliances</span>
            <span class="sidebar-toggle"></span>
          </div>
          <div class="sidebar-content">
            <div class="element-grid" id="appliancesGrid">
              <!-- Elements rendered by JS -->
            </div>
          </div>
        </div>

        <!-- Structure -->
        <div class="sidebar-section">
          <div class="sidebar-header" onclick="toggleSection(this)">
            <span class="sidebar-title">Structure</span>
            <span class="sidebar-toggle"></span>
          </div>
          <div class="sidebar-content">
            <div class="element-grid" id="structureGrid">
              <!-- Elements rendered by JS -->
            </div>
          </div>
        </div>

        <!-- Materials Library -->
        <div class="sidebar-section">
          <div class="sidebar-header" onclick="toggleSection(this)">
            <span class="sidebar-title">Materials</span>
            <span class="sidebar-toggle"></span>
          </div>
          <div class="sidebar-content">
            <div class="materials-tabs">
              <button class="material-tab active" onclick="showMaterialCategory('granite', this)">Granite</button>
              <button class="material-tab" onclick="showMaterialCategory('quartz', this)">Quartz</button>
              <button class="material-tab" onclick="showMaterialCategory('marble', this)">Marble</button>
              <button class="material-tab" onclick="showMaterialCategory('quartzite', this)">Quartzite</button>
              <button class="material-tab" onclick="showMaterialCategory('cabinets', this)">Cabinets</button>
              <button class="material-tab" onclick="showMaterialCategory('vanities', this)">Vanities</button>
              <button class="material-tab" onclick="showMaterialCategory('tile', this)">Tile</button>
              <button class="material-tab" onclick="showMaterialCategory('flooring', this)">LVT</button>
              <button class="material-tab" onclick="showMaterialCategory('flooringTrims', this)">Trims</button>
              <button class="material-tab" onclick="showMaterialCategory('showerPanels', this)">Shower</button>
              <button class="material-tab" onclick="showMaterialCategory('hardscape', this)">Hardscape</button>
            </div>
            <div class="material-grid" id="materialGrid">
              <!-- Materials rendered by JS -->
            </div>
            <div class="material-hint">Click material, then click element to apply</div>
          </div>
        </div>

        <!-- Cabinet Catalog -->
        <div class="sidebar-section">
          <div class="sidebar-header" onclick="toggleSection(this)">
            <span class="sidebar-title">Cabinet Catalog</span>
            <span class="sidebar-toggle"></span>
          </div>
          <div class="sidebar-content">
            <div class="catalog-brand">
              <select id="catalogSelect" onchange="changeCatalog(this.value)">
                <option value="procraft">ProCraft Cabinetry</option>
                <option value="custom">Custom / Import</option>
              </select>
            </div>
            <div class="catalog-series" id="catalogSeries">
              <select id="seriesSelect" onchange="changeSeries(this.value)">
                <option value="shaker-white">Shaker White</option>
                <option value="shaker-grey">Shaker Grey</option>
                <option value="shaker-espresso">Shaker Espresso</option>
              </select>
            </div>
            <div class="materials-tabs" id="cabinetCategoryTabs">
              <button class="material-tab active" onclick="showCabinetCategory('base', this)">Base</button>
              <button class="material-tab" onclick="showCabinetCategory('wall', this)">Wall</button>
              <button class="material-tab" onclick="showCabinetCategory('tall', this)">Tall</button>
              <button class="material-tab" onclick="showCabinetCategory('corner', this)">Corner</button>
              <button class="material-tab" onclick="showCabinetCategory('sink', this)">Sink</button>
              <button class="material-tab" onclick="showCabinetCategory('drawer', this)">Drawer</button>
            </div>
            <div class="cabinet-catalog-list" id="cabinetCatalogList">
              <!-- Cabinets rendered by JS -->
            </div>
            <div class="catalog-actions">
              <button class="btn btn-sm btn-secondary" onclick="importCabinetList()" title="Import cabinet list from CSV or JSON">
                <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                  <polyline points="17 8 12 3 7 8"/>
                  <line x1="12" y1="3" x2="12" y2="15"/>
                </svg>
                Import List
              </button>
            </div>
          </div>
        </div>
      </aside>

      <!-- Canvas Area -->
      <div class="canvas-area">
        <div class="canvas-toolbar">
          <div class="toolbar-group">
            <button class="btn btn-sm btn-secondary" id="undoBtn" onclick="undo()" title="Undo (Ctrl+Z)">
              <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M3 10h10a5 5 0 0 1 5 5v2"/>
                <polyline points="3 10 8 5 8 15 3 10"/>
              </svg>
            </button>
            <button class="btn btn-sm btn-secondary" id="redoBtn" onclick="redo()" title="Redo (Ctrl+Y)">
              <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M21 10H11a5 5 0 0 0-5 5v2"/>
                <polyline points="21 10 16 5 16 15 21 10"/>
              </svg>
            </button>
            <div class="toolbar-divider"></div>
            <div class="zoom-controls">
              <button class="zoom-btn" onclick="zoomOut()"></button>
              <span class="zoom-level" id="zoomLevel">100%</span>
              <button class="zoom-btn" onclick="zoomIn()">+</button>
              <button class="zoom-btn" onclick="fitToScreen()" title="Fit to screen"></button>
            </div>
            <div class="toolbar-divider"></div>
            <button class="btn btn-sm btn-secondary" onclick="clearCanvas()">Clear</button>
            <button class="btn btn-sm btn-secondary" onclick="resetCanvas()" style="color: #ef4444;" title="Reset everything">Reset</button>
          </div>
          <div class="canvas-info">
            <span id="canvasSize">12'  10'</span>
            <span id="elementCount">0 elements</span>
          </div>
        </div>
        <div class="canvas-wrapper" id="canvasWrapper">
          <canvas id="canvas"></canvas>
        </div>
        <div id="three-container"></div>
      </div>

      <!-- Right Panel -->
      <aside class="right-panel">
        <div class="panel-section">
          <div class="panel-title">Room Settings</div>
          <div class="room-grid">
            <div class="input-group">
              <label class="input-label">Room Type</label>
              <select class="input-field" id="roomType" onchange="updateRoom()">
                <option value="kitchen">Kitchen</option>
                <option value="bathroom">Bathroom</option>
                <option value="laundry">Laundry</option>
                <option value="bedroom">Bedroom</option>
                <option value="living">Living Room</option>
                <option value="office">Office</option>
                <option value="commercial">Commercial</option>
              </select>
            </div>
            <div class="input-group">
              <label class="input-label">Width (ft)</label>
              <input type="number" class="input-field" id="roomWidth" value="20" min="8" max="100" onchange="updateRoom()">
            </div>
            <div class="input-group">
              <label class="input-label">Depth (ft)</label>
              <input type="number" class="input-field" id="roomDepth" value="16" min="8" max="100" onchange="updateRoom()">
            </div>
            <div class="input-group">
              <label class="input-label">Scale</label>
              <select class="input-field" id="scaleMode" onchange="updateScale()">
                <option value="fit">Fit to Screen</option>
                <option value="40">40 px/ft</option>
                <option value="50">50 px/ft</option>
                <option value="60">60 px/ft</option>
              </select>
            </div>
          </div>
        </div>

        <!-- Cabinet Settings -->
        <div class="panel-section">
          <div class="panel-title">Cabinet Settings</div>
          <div class="room-grid">
            <div class="input-group">
              <label class="input-label">Construction</label>
              <select class="input-field" id="cabinetConstruction" onchange="updateCabinetSettings()">
                <option value="frameless">Frameless (Euro)</option>
                <option value="framed">Framed (Face Frame)</option>
              </select>
            </div>
            <div class="input-group">
              <label class="input-label">Door Style</label>
              <select class="input-field" id="doorStyle" onchange="updateCabinetSettings()">
                <option value="shaker">Shaker</option>
                <option value="flat">Flat Panel</option>
                <option value="raised">Raised Panel</option>
                <option value="slab">Slab (No Detail)</option>
              </select>
            </div>
            <div class="input-group">
              <label class="input-label">Door Overlay</label>
              <select class="input-field" id="doorOverlay" onchange="updateCabinetSettings()">
                <option value="full">Full Overlay</option>
                <option value="partial">Partial Overlay</option>
                <option value="inset">Inset</option>
              </select>
            </div>
            <div class="input-group">
              <label class="input-label">Floor Level</label>
              <select class="input-field" id="floorLevel" onchange="updateFloorLevel()">
                <option value="1">Floor 1</option>
                <option value="2">Floor 2</option>
                <option value="3">Floor 3</option>
                <option value="add">+ Add Floor</option>
              </select>
            </div>
          </div>
        </div>

        <!-- Scene Settings -->
        <div class="panel-section">
          <div class="panel-title">Scene Settings</div>
          <div class="room-grid">
            <div class="input-group">
              <label class="input-label">Time of Day</label>
              <select class="input-field" id="timeOfDay" onchange="updateTimeOfDay()">
                <option value="morning">Morning (Sunrise)</option>
                <option value="noon" selected>Noon (Daylight)</option>
                <option value="evening">Evening (Sunset)</option>
                <option value="night">Night</option>
              </select>
            </div>
          </div>
        </div>

        <div class="panel-section" id="propertiesPanel">
          <div class="panel-title">Properties</div>
          <div class="properties-empty" id="propertiesEmpty">
            Select an element to edit
          </div>
          <div id="propertiesContent" style="display: none;">
            <div class="property-row">
              <span class="property-label">Type</span>
              <span class="property-value" id="propType">-</span>
            </div>
            <div class="property-row">
              <span class="property-label">Width</span>
              <input type="text" class="property-input" id="propWidth" placeholder="e.g. 3'-6&quot; or 2.5" onchange="updateSelectedElement()" title="Enter feet-inches (3'-6&quot;) or decimal feet (2.5)">
              <span class="dimension-display" id="propWidthDisplay"></span>
            </div>
            <div class="property-row">
              <span class="property-label">Depth</span>
              <input type="text" class="property-input" id="propHeight" placeholder="e.g. 2'-0&quot; or 2" onchange="updateSelectedElement()" title="Enter feet-inches (2'-0&quot;) or decimal feet (2)">
              <span class="dimension-display" id="propHeightDisplay"></span>
            </div>
            <div class="property-row" id="standardSizeRow" style="display: none;">
              <span class="property-label">Standard</span>
              <select class="property-select" id="propStandardSize" onchange="applyStandardSize()">
                <option value="">Custom</option>
              </select>
            </div>
            <div class="property-row">
              <span class="property-label">Color</span>
              <input type="color" class="color-picker" id="propColor" onchange="updateSelectedElement()">
            </div>
            <div class="property-row">
              <span class="property-label">Texture</span>
              <div class="texture-controls">
                <div class="texture-preview" id="propTexture" onclick="openMaterialPicker()" title="Click to browse materials"></div>
                <button class="texture-upload-btn" onclick="quickUploadTexture()" title="Upload custom image">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                    <polyline points="17 8 12 3 7 8"/>
                    <line x1="12" y1="3" x2="12" y2="15"/>
                  </svg>
                </button>
                <button class="texture-clear-btn" onclick="clearTexture()" title="Clear texture"></button>
              </div>
            </div>
            <div class="property-row">
              <span class="property-label">Rotation</span>
              <span class="property-value" id="propRotation">0</span>
            </div>

            <!-- Pricing Section -->
            <div class="pricing-section" id="pricingSection">
              <div class="property-section-title">Pricing</div>
              <div class="property-row">
                <span class="property-label">Base Price</span>
                <span class="property-value" id="propBasePrice">$0.00</span>
              </div>
              <div class="property-row">
                <span class="property-label">Override</span>
                <div class="price-override-group">
                  <input type="number" class="property-input price-input" id="propPriceOverride" placeholder="Auto" step="0.01" min="0" onchange="updateElementPrice()">
                  <select class="property-select-sm" id="propPriceUnit" onchange="updateElementPrice()">
                    <option value="sqft">/sqft</option>
                    <option value="linear_ft">/lf</option>
                    <option value="unit">each</option>
                  </select>
                </div>
              </div>
              <div class="property-row">
                <span class="property-label">Margin %</span>
                <input type="number" class="property-input margin-input" id="propMargin" placeholder="Default" step="1" min="0" max="200" onchange="updateElementPrice()">
              </div>
              <div class="property-row price-result">
                <span class="property-label">Item Total</span>
                <span class="property-value price-highlight" id="propItemTotal">$0.00</span>
              </div>
            </div>
          </div>
        </div>

        <!-- Building Code Validation -->
        <div class="validation-section" id="validationPanel">
          <div class="panel-section">
            <div class="panel-title">
              Building Standards
              <button class="validation-toggle" onclick="toggleWorkTriangle()" title="Toggle work triangle"></button>
              <button class="validation-refresh" onclick="runValidation()" title="Check design"></button>
            </div>
          </div>
          <div class="validation-content" id="validationContent">
            <div class="validation-hint">Click  to validate your design</div>
          </div>
        </div>

        <div class="quote-section" id="quotePanel">
          <div class="panel-section">
            <div class="quote-header">
              <div class="panel-title">Quote Summary</div>
              <div class="quote-view-toggle">
                <button class="toggle-btn active" id="retailViewBtn" onclick="setQuoteView('retail')" title="Show retail prices">Retail</button>
                <button class="toggle-btn" id="costViewBtn" onclick="setQuoteView('cost')" title="Show cost prices">Cost</button>
              </div>
            </div>
          </div>
          <div class="quote-actions">
            <button class="btn btn-sm btn-secondary" onclick="openPriceListModal()" title="Upload or manage price lists">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:14px;height:14px;margin-right:4px;">
                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                <polyline points="17 8 12 3 7 8"/>
                <line x1="12" y1="3" x2="12" y2="15"/>
              </svg>
              Price List
            </button>
            <button class="btn btn-sm btn-secondary" onclick="openMarginModal()" title="Configure profit margins">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:14px;height:14px;margin-right:4px;">
                <line x1="19" y1="5" x2="5" y2="19"/>
                <circle cx="6.5" cy="6.5" r="2.5"/>
                <circle cx="17.5" cy="17.5" r="2.5"/>
              </svg>
              Margins
            </button>
          </div>
          <div class="quote-items" id="quoteItems">
            <div class="quote-item">
              <span class="quote-item-name">No items yet</span>
              <span class="quote-item-value">$0</span>
            </div>
          </div>
          <div class="quote-summary">
            <div class="quote-row" id="quoteCostRow" style="display: none;">
              <span>Material Cost</span>
              <span id="quoteCost">$0.00</span>
            </div>
            <div class="quote-row" id="quoteMarginRow" style="display: none;">
              <span>Markup</span>
              <span id="quoteMargin">$0.00</span>
            </div>
            <div class="quote-total">
              <div class="quote-total-row">
                <span class="quote-total-label">Estimated Total</span>
                <span class="quote-total-value" id="quoteTotal">$0</span>
              </div>
            </div>
          </div>
        </div>
      </aside>
    </main>
  </div>

  <!-- Context Menu -->
  <div class="context-menu" id="contextMenu" style="display: none;">
    <div class="context-menu-label" id="contextMenuLabel">Element</div>
    <div class="context-menu-item" onclick="contextAction('rotate')">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <path d="M21 2v6h-6"/><path d="M3 12a9 9 0 0 1 15-6.7L21 8"/>
      </svg>
      Rotate 90
    </div>
    <div class="context-menu-item" onclick="contextAction('duplicate')">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <rect x="9" y="9" width="13" height="13" rx="2"/><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/>
      </svg>
      Duplicate
    </div>
    <div class="context-menu-item" onclick="contextAction('texture')">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <rect x="3" y="3" width="18" height="18" rx="2"/><circle cx="8.5" cy="8.5" r="1.5"/><path d="M21 15l-5-5L5 21"/>
      </svg>
      Change Texture
    </div>
    <div class="context-menu-item" onclick="contextAction('lock')">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <rect x="3" y="11" width="18" height="11" rx="2"/><path d="M7 11V7a5 5 0 0 1 10 0v4"/>
      </svg>
      <span id="lockText">Lock</span>
    </div>
    <div class="context-menu-divider"></div>
    <div class="context-menu-item" onclick="contextAction('front')">Bring to Front</div>
    <div class="context-menu-item" onclick="contextAction('back')">Send to Back</div>
    <div class="context-menu-divider"></div>
    <div class="context-menu-item danger" onclick="contextAction('delete')">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/>
      </svg>
      Delete
    </div>
  </div>

  <!-- Share Modal - Enhanced -->
  <div class="modal-overlay" id="shareModal">
    <div class="modal" style="max-width: 500px;">
      <div class="modal-header">
        <h3 class="modal-title">Share Project</h3>
        <button class="modal-close" onclick="closeModal('shareModal')"></button>
      </div>

      <div class="share-status" id="shareStatus">
        <span class="status-indicator"></span>
        <span id="shareStatusText">Not shared yet</span>
      </div>

      <div class="share-link-box">
        <input type="text" class="share-link-input" id="shareLink" readonly placeholder="Generate a share link...">
        <button class="btn btn-secondary" id="copyShareBtn" onclick="copyShareLink()" disabled>Copy</button>
      </div>

      <div class="permission-section">
        <h4>Permission Level</h4>
        <div class="permission-options">
          <div class="permission-btn" data-permission="full_collab" onclick="setSharePermission('full_collab', this)">
            <div class="permission-icon">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/>
                <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/>
              </svg>
            </div>
            <div class="permission-info">
              <div class="permission-btn-title">Full Collaboration</div>
              <div class="permission-btn-desc">Can edit everything including prices</div>
            </div>
          </div>

          <div class="permission-btn active" data-permission="quote_view" onclick="setSharePermission('quote_view', this)">
            <div class="permission-icon">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="12" cy="12" r="3"/>
                <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/>
              </svg>
            </div>
            <div class="permission-info">
              <div class="permission-btn-title">Quote View</div>
              <div class="permission-btn-desc">See prices, cannot edit</div>
            </div>
          </div>

          <div class="permission-btn" data-permission="material_view" onclick="setSharePermission('material_view', this)">
            <div class="permission-icon">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <rect x="3" y="3" width="7" height="7"/>
                <rect x="14" y="3" width="7" height="7"/>
                <rect x="14" y="14" width="7" height="7"/>
                <rect x="3" y="14" width="7" height="7"/>
              </svg>
            </div>
            <div class="permission-info">
              <div class="permission-btn-title">Material View</div>
              <div class="permission-btn-desc">See materials only, no prices</div>
            </div>
          </div>

          <div class="permission-btn" data-permission="presentation" onclick="setSharePermission('presentation', this)">
            <div class="permission-icon">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <rect x="2" y="3" width="20" height="14" rx="2"/>
                <line x1="8" y1="21" x2="16" y2="21"/>
                <line x1="12" y1="17" x2="12" y2="21"/>
              </svg>
            </div>
            <div class="permission-info">
              <div class="permission-btn-title">Presentation</div>
              <div class="permission-btn-desc">Client-pretty, no costs shown</div>
            </div>
          </div>
        </div>
      </div>

      <div class="share-actions">
        <button class="btn btn-primary" onclick="generateShareLink()">Generate Share Link</button>
      </div>

      <div class="active-shares" id="activeShares" style="display:none;">
        <h4>Active Share Links</h4>
        <div class="shares-list" id="sharesList"></div>
      </div>

      <div class="recent-activity" id="recentActivity" style="display:none;">
        <h4>Recent Activity</h4>
        <div class="activity-list" id="activityList"></div>
      </div>
    </div>
  </div>

  <!-- Login Modal -->
  <div class="modal-overlay" id="loginModal">
    <div class="modal login-modal">
      <div class="modal-header">
        <h3 class="modal-title" style="font-size: 22px;">Sign In</h3>
        <button class="modal-close login-modal-close" onclick="closeModal('loginModal')"></button>
      </div>

      <p id="loginPromptMessage" style="color: var(--text-secondary); margin-bottom: 24px; text-align: center; font-size: 15px; line-height: 1.5;">
        Sign in to save and share your designs.
      </p>

      <div id="loginFormContainer">
        <!-- Google OAuth Button -->
        <button class="google-signin-btn" onclick="handleGoogleLogin()">
          <svg viewBox="0 0 24 24" width="20" height="20">
            <path fill="#4285F4" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"/>
            <path fill="#34A853" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/>
            <path fill="#FBBC05" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/>
            <path fill="#EA4335" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/>
          </svg>
          Continue with Google
        </button>

        <div class="login-divider">
          <span>or</span>
        </div>

        <!-- Email/Password Form -->
        <div class="form-group" style="margin-bottom: 18px;">
          <label style="font-size: 13px; margin-bottom: 8px; display: block; font-weight: 500;">Email</label>
          <input type="email" id="loginEmail" class="input" placeholder="your@email.com" style="width: 100%; padding: 14px; font-size: 15px;">
        </div>
        <div class="form-group" style="margin-bottom: 18px;">
          <label style="font-size: 13px; margin-bottom: 8px; display: block; font-weight: 500;">Password</label>
          <input type="password" id="loginPassword" class="input" placeholder="" style="width: 100%; padding: 14px; font-size: 15px;">
        </div>
        <div id="loginError" style="color: var(--error); font-size: 13px; margin-bottom: 14px; display: none;"></div>
        <button class="btn btn-primary" style="width: 100%; margin-bottom: 16px; padding: 14px; font-size: 15px;" onclick="handleLogin()">Sign In</button>
        <div style="text-align: center; font-size: 14px; color: var(--text-muted);">
          Don't have an account? <a href="/sign-up/" target="_blank" style="color: var(--gold); font-weight: 500;">Sign up free</a>
        </div>
      </div>

      <div id="loginSuccessContainer" style="display: none; text-align: center; padding: 20px 0;">
        <div style="width: 70px; height: 70px; background: var(--success); border-radius: 50%; display: flex; align-items: center; justify-content: center; margin: 0 auto 20px;">
          <svg viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="3" style="width: 35px; height: 35px;">
            <polyline points="20 6 9 17 4 12"/>
          </svg>
        </div>
        <h4 style="margin-bottom: 10px; font-size: 20px;">Signed In!</h4>
        <p id="loginWelcome" style="color: var(--text-secondary); margin-bottom: 20px; font-size: 15px;">Welcome back</p>
        <button class="btn btn-primary" style="padding: 14px 32px; font-size: 15px;" onclick="closeModal('loginModal')">Continue</button>
      </div>
    </div>
  </div>

  <!-- Price List Modal -->
  <div class="modal-overlay" id="priceListModal">
    <div class="modal" style="max-width: 700px;">
      <div class="modal-header">
        <h3 class="modal-title">Price List Manager</h3>
        <button class="modal-close" onclick="closeModal('priceListModal')"></button>
      </div>

      <div class="price-list-tabs">
        <button class="tab-btn active" onclick="showPriceTab('upload')">Upload</button>
        <button class="tab-btn" onclick="showPriceTab('saved')">Saved Lists</button>
        <button class="tab-btn" onclick="showPriceTab('current')">Current Prices</button>
      </div>

      <!-- Upload Tab -->
      <div class="price-tab" id="priceTabUpload">
        <div class="upload-dropzone" id="priceListDropzone" onclick="document.getElementById('priceListFile').click()">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:48px;height:48px;margin-bottom:12px;opacity:0.5;">
            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
            <polyline points="17 8 12 3 7 8"/>
            <line x1="12" y1="3" x2="12" y2="15"/>
          </svg>
          <p style="margin-bottom:4px;">Drop Excel or CSV file here</p>
          <p class="hint" style="font-size:12px;color:var(--text-muted);">Supports .xlsx, .xls, .csv</p>
          <input type="file" id="priceListFile" accept=".xlsx,.xls,.csv" onchange="handlePriceListUpload(event)" style="display:none">
        </div>

        <div class="column-mapping" id="columnMapping" style="display:none;">
          <h4 style="margin-bottom:12px;">Map Columns</h4>
          <div class="mapping-row">
            <label>Material ID/SKU</label>
            <select id="mapMaterialId" class="property-select" onchange="updateMappingPreview()"></select>
          </div>
          <div class="mapping-row">
            <label>Material Name</label>
            <select id="mapMaterialName" class="property-select" onchange="updateMappingPreview()"></select>
          </div>
          <div class="mapping-row">
            <label>Price</label>
            <select id="mapPrice" class="property-select" onchange="updateMappingPreview()"></select>
          </div>
          <div class="mapping-row">
            <label>Unit (optional)</label>
            <select id="mapUnit" class="property-select" onchange="updateMappingPreview()"></select>
          </div>
          <div class="mapping-preview" id="mappingPreview"></div>
          <div class="mapping-actions">
            <button class="btn btn-secondary" onclick="cancelPriceUpload()">Cancel</button>
            <button class="btn btn-primary" onclick="applyPriceList()">Apply Prices</button>
          </div>
        </div>
      </div>

      <!-- Saved Lists Tab -->
      <div class="price-tab" id="priceTabSaved" style="display:none;">
        <div class="saved-lists" id="savedPriceLists">
          <p class="empty-state">No saved price lists</p>
        </div>
        <button class="btn btn-primary" onclick="savePriceList()" style="margin-top:16px;">Save Current Prices</button>
      </div>

      <!-- Current Prices Tab -->
      <div class="price-tab" id="priceTabCurrent" style="display:none;">
        <div class="current-prices-header">
          <input type="text" class="search-input" id="priceSearchInput" placeholder="Search materials..." oninput="filterCurrentPrices()">
        </div>
        <div class="current-prices-list" id="currentPricesList"></div>
      </div>
    </div>
  </div>

  <!-- Margin Settings Modal -->
  <div class="modal-overlay" id="marginModal">
    <div class="modal" style="max-width: 450px;">
      <div class="modal-header">
        <h3 class="modal-title">Margin Settings</h3>
        <button class="modal-close" onclick="closeModal('marginModal')"></button>
      </div>

      <div class="margin-section">
        <div class="margin-global">
          <label>Default Margin</label>
          <div class="margin-input-group">
            <input type="number" class="property-input" id="globalMarginInput" value="30" min="0" max="200">
            <span class="margin-symbol">%</span>
          </div>
          <p class="hint" style="font-size:11px;color:var(--text-muted);margin-top:4px;">Applied to all items without custom margin</p>
        </div>

        <div class="margin-categories">
          <h4 style="margin:16px 0 12px;">Category Margins</h4>
          <div class="category-margin-row">
            <span>Countertops</span>
            <div class="margin-input-group">
              <input type="number" class="property-input" data-category="countertop" value="35" min="0" max="200">
              <span class="margin-symbol">%</span>
            </div>
          </div>
          <div class="category-margin-row">
            <span>Cabinets</span>
            <div class="margin-input-group">
              <input type="number" class="property-input" data-category="cabinet" value="25" min="0" max="200">
              <span class="margin-symbol">%</span>
            </div>
          </div>
          <div class="category-margin-row">
            <span>Appliances</span>
            <div class="margin-input-group">
              <input type="number" class="property-input" data-category="appliance" value="15" min="0" max="200">
              <span class="margin-symbol">%</span>
            </div>
          </div>
          <div class="category-margin-row">
            <span>Flooring/Tile</span>
            <div class="margin-input-group">
              <input type="number" class="property-input" data-category="flooring" value="30" min="0" max="200">
              <span class="margin-symbol">%</span>
            </div>
          </div>
        </div>
      </div>

      <div class="modal-footer">
        <button class="btn btn-secondary" onclick="closeModal('marginModal')">Cancel</button>
        <button class="btn btn-primary" onclick="applyMargins()">Apply</button>
      </div>
    </div>
  </div>

  <!-- Material Picker Modal -->
  <div class="modal-overlay" id="materialModal">
    <div class="modal" style="max-width: 600px;">
      <div class="modal-header">
        <h3 class="modal-title">Choose Material</h3>
        <button class="modal-close" onclick="closeModal('materialModal')"></button>
      </div>
      <div class="material-categories" id="materialCategories">
        <!-- Categories rendered by JS -->
      </div>
      <div class="materials-modal-grid" id="materialsGrid">
        <!-- Materials rendered by JS -->
      </div>
    </div>
  </div>

  <!-- Hidden file input -->
  <input type="file" id="materialUpload" accept="image/*" style="display: none" onchange="handleMaterialUpload(event)">

  <!-- Keyboard Shortcuts (hidden in review mode) -->
  <div class="shortcuts-hint" id="shortcutsHint">
    <div class="shortcut"><kbd>V</kbd> Select</div>
    <div class="shortcut"><kbd>W</kbd> Wall</div>
    <div class="shortcut"><kbd>C</kbd> Counter</div>
    <div class="shortcut"><kbd>Del</kbd> Delete</div>
    <div class="shortcut"><kbd>R</kbd> Rotate</div>
    <div class="shortcut"><kbd>Ctrl+D</kbd> Duplicate</div>
  </div>

  <script>
    // ===== CONFIGURATION =====
    const CONFIG = {
      MIN_PIXELS_PER_FOOT: 20,
      DEFAULT_PIXELS_PER_FOOT: 40,
      GRID_SUBDIVISIONS: 12, // 12 subdivisions = 1 inch grid (12" per foot)
      MEASUREMENT_PRECISION: 16, // 1/16" precision
      WALL_THICKNESS: 6,
      PRICING: {
        'base-cabinet': 150,
        'wall-cabinet': 120,
        'tall-cabinet': 300,
        'corner-cabinet': 200,
        'island': 400,
        'countertop': 65,
        'backsplash': 25,
        'flooring': 8,
        'tile': 15,
        'sink': 350,
        'stove': 800,
        'refrigerator': 1200,
        'dishwasher': 600,
        'microwave': 250,
        'range-hood': 450,
        'oven': 1500,
        'door': 200,
        'window': 300,
        'wall': 0
      }
    };

    // ===== PRICING & SHARING STATE =====
    const PRICING_STATE = {
      globalMargin: 30,           // Default 30% markup
      categoryMargins: {
        countertop: 35,
        cabinet: 25,
        appliance: 15,
        flooring: 30,
        other: 30
      },
      showCostView: false,        // Toggle between cost/retail view
      priceLists: [],             // Saved price list configurations
      activePriceList: null,      // Currently active price list name
      customPrices: {}            // Temporary price overrides from Excel import
    };

    const SHARE_STATE = {
      designId: null,             // Supabase design ID
      designToken: null,          // Current design's share token
      permission: 'full_collab',  // Current user's permission level
      isSharedView: false,        // Whether viewing a shared design
      allowedActions: null        // Actions permitted by current permission
    };

    const PERMISSION_LEVELS = {
      full_collab: {
        name: 'Full Collaboration',
        description: 'Can edit everything including prices',
        canEdit: true,
        canViewPrices: true,
        canViewCosts: true,
        canViewMaterials: true,
        canExport: true
      },
      quote_view: {
        name: 'Quote View',
        description: 'Can see prices but cannot edit',
        canEdit: false,
        canViewPrices: true,
        canViewCosts: false,
        canViewMaterials: true,
        canExport: true
      },
      material_view: {
        name: 'Material View',
        description: 'See materials only, no pricing',
        canEdit: false,
        canViewPrices: false,
        canViewCosts: false,
        canViewMaterials: true,
        canExport: false
      },
      presentation: {
        name: 'Presentation',
        description: 'Client-pretty view, no costs shown',
        canEdit: false,
        canViewPrices: false,
        canViewCosts: false,
        canViewMaterials: false,
        canExport: false
      }
    };

    // ===== BUILDING STANDARDS =====
    const BUILDING_STANDARDS = {
      // Standard element dimensions (in feet)
      DOORS: {
        interior: { width: 2.667, height: 6.667, label: "2'-8\"  6'-8\"" },    // 32"  80"
        interiorWide: { width: 3, height: 6.667, label: "3'-0\"  6'-8\"" },    // 36"  80"
        exterior: { width: 3, height: 6.667, label: "3'-0\"  6'-8\"" },        // 36"  80"
        exteriorTall: { width: 3, height: 7, label: "3'-0\"  7'-0\"" },        // 36"  84"
        double: { width: 5, height: 6.667, label: "5'-0\"  6'-8\"" },          // 60"  80"
        sliding: { width: 6, height: 6.667, label: "6'-0\"  6'-8\"" },         // 72"  80"
        garage1car: { width: 8, height: 7, label: "8'-0\"  7'-0\"" },          // 96"  84"
        garage2car: { width: 16, height: 7, label: "16'-0\"  7'-0\"" }         // 192"  84"
      },
      WINDOWS: {
        small: { width: 2, height: 3, label: "2'-0\"  3'-0\"" },               // 24"  36"
        standard: { width: 3, height: 4, label: "3'-0\"  4'-0\"" },            // 36"  48"
        large: { width: 4, height: 5, label: "4'-0\"  5'-0\"" },               // 48"  60"
        picture: { width: 6, height: 4, label: "6'-0\"  4'-0\"" }              // 72"  48"
      },
      CABINETS: {
        // Base cabinets (height is depth in floor plan)
        base12: { width: 1, depth: 2, label: "12\" wide" },
        base15: { width: 1.25, depth: 2, label: "15\" wide" },
        base18: { width: 1.5, depth: 2, label: "18\" wide" },
        base21: { width: 1.75, depth: 2, label: "21\" wide" },
        base24: { width: 2, depth: 2, label: "24\" wide" },
        base27: { width: 2.25, depth: 2, label: "27\" wide" },
        base30: { width: 2.5, depth: 2, label: "30\" wide" },
        base33: { width: 2.75, depth: 2, label: "33\" wide" },
        base36: { width: 3, depth: 2, label: "36\" wide" },
        base42: { width: 3.5, depth: 2, label: "42\" wide" },
        base48: { width: 4, depth: 2, label: "48\" wide" },
        // Wall cabinets (shallower depth)
        wall12: { width: 1, depth: 1, label: "12\" wide" },
        wall15: { width: 1.25, depth: 1, label: "15\" wide" },
        wall18: { width: 1.5, depth: 1, label: "18\" wide" },
        wall24: { width: 2, depth: 1, label: "24\" wide" },
        wall30: { width: 2.5, depth: 1, label: "30\" wide" },
        wall36: { width: 3, depth: 1, label: "36\" wide" },
        // Tall/Pantry
        tall24: { width: 2, depth: 2, label: "24\" wide pantry" },
        tall36: { width: 3, depth: 2, label: "36\" wide pantry" }
      },
      COUNTERTOPS: {
        standardDepth: 2.083,  // 25" including overhang
        barHeight: 3.5,       // 42" bar height
        islandMinWidth: 2,    // 24" minimum
        islandMinDepth: 4     // 48" minimum for seating
      },
      // Clearance requirements (in feet)
      CLEARANCES: {
        walkway: 3,           // 36" minimum walkway
        twoCoook: 4,          // 48" for two cooks
        applianceOpen: 3.5,   // 42" in front of open appliance
        islandWalkway: 3.5,   // 42" around island
        adaTurning: 5,        // 60" ADA turning radius
        doorSwing: 1.5,       // 18" beside door latch
        doorFront: 5          // 60" in front of door
      },
      // Work triangle limits (in feet)
      WORK_TRIANGLE: {
        legMin: 4,            // Minimum leg length
        legMax: 9,            // Maximum leg length
        perimeterMin: 13,     // Minimum total perimeter
        perimeterMax: 26      // Maximum total perimeter
      },
      // Standard heights (for 3D and reference)
      HEIGHTS: {
        ceiling: 8,           // 8' standard ceiling
        ceilingTall: 9,       // 9' ceiling
        ceilingLuxury: 10,    // 10' ceiling
        baseCounter: 3,       // 36" counter height
        barCounter: 3.5,      // 42" bar height
        wallCabBottom: 4.5,   // 54" to bottom of wall cabinet
        wallCabTop: 7,        // 84" to top of wall cabinet
        rangeHood: 5.5,       // 66" to bottom of hood
        windowSill: 3         // 36" typical window sill
      }
    };

    // Standard snap dimensions (in feet) for smart snapping
    const SNAP_DIMENSIONS = {
      widths: [1, 1.25, 1.5, 1.75, 2, 2.25, 2.5, 2.75, 3, 3.5, 4, 4.5, 5, 6, 8],
      depths: [1, 1.5, 2, 2.5, 3, 4],
      tolerance: 0.0833  // 1" snap tolerance
    };

    // ===== MEASUREMENT FORMATTING =====
    // Format feet (decimal) to feet-inches-fractions string
    // Supports 1/16" precision
    function formatDimension(feet, showFractions = true) {
      const totalInches = feet * 12;
      const wholeInches = Math.floor(totalInches);
      const wholeFeet = Math.floor(wholeInches / 12);
      const remainingInches = wholeInches % 12;
      const fractionalInches = totalInches - wholeInches;

      // Convert to 16ths for fraction display
      const sixteenths = Math.round(fractionalInches * 16);

      // Simplify fraction
      let fractionStr = '';
      if (sixteenths > 0 && showFractions) {
        if (sixteenths === 16) {
          // Round up to next inch
          return formatDimension(feet + (1/192), showFractions);
        } else if (sixteenths === 8) {
          fractionStr = '';
        } else if (sixteenths === 4) {
          fractionStr = '';
        } else if (sixteenths === 12) {
          fractionStr = '';
        } else if (sixteenths % 2 === 0) {
          // Can simplify to eighths
          fractionStr = `${sixteenths/2}/8`;
        } else {
          fractionStr = `${sixteenths}/16`;
        }
      }

      // Build output string
      if (wholeFeet > 0 && remainingInches > 0) {
        return `${wholeFeet}'-${remainingInches}${fractionStr}"`;
      } else if (wholeFeet > 0 && fractionStr) {
        return `${wholeFeet}'-0${fractionStr}"`;
      } else if (wholeFeet > 0) {
        return `${wholeFeet}'-0"`;
      } else if (remainingInches > 0 || fractionStr) {
        return `${remainingInches}${fractionStr}"`;
      } else {
        return '0"';
      }
    }

    // Format dimensions as W  H
    function formatSize(widthFt, heightFt) {
      return `${formatDimension(widthFt)}  ${formatDimension(heightFt)}`;
    }

    // Parse dimension string back to feet (for input)
    // Accepts: "3'-6"", "3.5", "42"", "3' 6"", etc.
    function parseDimension(str) {
      if (typeof str === 'number') return str;
      str = str.toString().trim();

      // Already decimal feet
      if (/^[\d.]+$/.test(str)) {
        return parseFloat(str);
      }

      // Feet and inches: 3'-6" or 3' 6" or 3'6"
      const feetInchMatch = str.match(/(\d+)[''][\s-]*(\d+)?(?:\s*(\d+)\/(\d+))?[""]?/);
      if (feetInchMatch) {
        const feet = parseInt(feetInchMatch[1]) || 0;
        const inches = parseInt(feetInchMatch[2]) || 0;
        const fracNum = parseInt(feetInchMatch[3]) || 0;
        const fracDen = parseInt(feetInchMatch[4]) || 1;
        return feet + (inches + fracNum/fracDen) / 12;
      }

      // Just inches: 42" or 36"
      const inchMatch = str.match(/^(\d+)(?:\s*(\d+)\/(\d+))?[""]$/);
      if (inchMatch) {
        const inches = parseInt(inchMatch[1]) || 0;
        const fracNum = parseInt(inchMatch[2]) || 0;
        const fracDen = parseInt(inchMatch[3]) || 1;
        return (inches + fracNum/fracDen) / 12;
      }

      // Fallback
      return parseFloat(str) || 0;
    }

    // Round to nearest 1/16"
    function roundToSixteenth(feet) {
      const sixteenthsPerFoot = 12 * 16; // 192 sixteenths per foot
      return Math.round(feet * sixteenthsPerFoot) / sixteenthsPerFoot;
    }

    // ===== BUILDING CODE VALIDATION =====
    let validationIssues = [];
    let showWorkTriangle = false;

    // Find elements by type
    function findElementsByType(types) {
      if (!Array.isArray(types)) types = [types];
      return elements.filter(el => types.includes(el.type));
    }

    // Get element center point
    function getElementCenter(el) {
      return {
        x: el.x + (el.width * pixelsPerFoot) / 2,
        y: el.y + (el.height * pixelsPerFoot) / 2
      };
    }

    // Calculate distance between two elements (center to center)
    function getDistance(el1, el2) {
      const c1 = getElementCenter(el1);
      const c2 = getElementCenter(el2);
      const dx = (c2.x - c1.x) / pixelsPerFoot;
      const dy = (c2.y - c1.y) / pixelsPerFoot;
      return Math.sqrt(dx * dx + dy * dy);
    }

    // Get gap between two elements (edge to edge)
    function getGapBetween(el1, el2) {
      const r1 = {
        left: el1.x / pixelsPerFoot,
        right: (el1.x + el1.width * pixelsPerFoot) / pixelsPerFoot,
        top: el1.y / pixelsPerFoot,
        bottom: (el1.y + el1.height * pixelsPerFoot) / pixelsPerFoot
      };
      const r2 = {
        left: el2.x / pixelsPerFoot,
        right: (el2.x + el2.width * pixelsPerFoot) / pixelsPerFoot,
        top: el2.y / pixelsPerFoot,
        bottom: (el2.y + el2.height * pixelsPerFoot) / pixelsPerFoot
      };

      // Calculate gaps in each direction
      const gapX = Math.max(r1.left - r2.right, r2.left - r1.right, 0);
      const gapY = Math.max(r1.top - r2.bottom, r2.top - r1.bottom, 0);

      return Math.sqrt(gapX * gapX + gapY * gapY);
    }

    // Validate kitchen work triangle
    function validateWorkTriangle() {
      const issues = [];
      const sinks = findElementsByType('sink');
      const stoves = findElementsByType(['stove', 'range', 'cooktop']);
      const fridges = findElementsByType(['refrigerator', 'fridge']);

      if (sinks.length === 0 || stoves.length === 0 || fridges.length === 0) {
        return { valid: false, issues: [], triangle: null, message: 'Need sink, stove, and refrigerator for work triangle' };
      }

      const sink = sinks[0];
      const stove = stoves[0];
      const fridge = fridges[0];

      const leg1 = getDistance(sink, stove);
      const leg2 = getDistance(stove, fridge);
      const leg3 = getDistance(fridge, sink);
      const perimeter = leg1 + leg2 + leg3;

      const { legMin, legMax, perimeterMin, perimeterMax } = BUILDING_STANDARDS.WORK_TRIANGLE;

      // Check each leg
      if (leg1 < legMin) issues.push({ type: 'warning', message: `Sink-Stove: ${formatDimension(leg1)} (min ${formatDimension(legMin)})` });
      if (leg1 > legMax) issues.push({ type: 'warning', message: `Sink-Stove: ${formatDimension(leg1)} (max ${formatDimension(legMax)})` });
      if (leg2 < legMin) issues.push({ type: 'warning', message: `Stove-Fridge: ${formatDimension(leg2)} (min ${formatDimension(legMin)})` });
      if (leg2 > legMax) issues.push({ type: 'warning', message: `Stove-Fridge: ${formatDimension(leg2)} (max ${formatDimension(legMax)})` });
      if (leg3 < legMin) issues.push({ type: 'warning', message: `Fridge-Sink: ${formatDimension(leg3)} (min ${formatDimension(legMin)})` });
      if (leg3 > legMax) issues.push({ type: 'warning', message: `Fridge-Sink: ${formatDimension(leg3)} (max ${formatDimension(legMax)})` });

      // Check perimeter
      if (perimeter < perimeterMin) {
        issues.push({ type: 'error', message: `Triangle too small: ${formatDimension(perimeter)} (min ${formatDimension(perimeterMin)})` });
      }
      if (perimeter > perimeterMax) {
        issues.push({ type: 'error', message: `Triangle too large: ${formatDimension(perimeter)} (max ${formatDimension(perimeterMax)})` });
      }

      return {
        valid: issues.length === 0,
        issues,
        triangle: { sink, stove, fridge, leg1, leg2, leg3, perimeter },
        message: issues.length === 0 ? 'Work triangle OK' : `${issues.length} issue(s)`
      };
    }

    // Validate clearances between elements
    function validateClearances() {
      const issues = [];
      const { walkway, islandWalkway, applianceOpen } = BUILDING_STANDARDS.CLEARANCES;

      // Check island clearances
      const islands = findElementsByType('island');
      const counters = findElementsByType('countertop');
      const cabinets = findElementsByType(['base-cabinet', 'tall-cabinet']);

      islands.forEach(island => {
        // Check clearance to counters and cabinets
        [...counters, ...cabinets].forEach(other => {
          const gap = getGapBetween(island, other);
          if (gap > 0 && gap < islandWalkway) {
            issues.push({
              type: 'warning',
              message: `Island clearance: ${formatDimension(gap)} (min ${formatDimension(islandWalkway)})`,
              elements: [island, other]
            });
          }
        });
      });

      // Check walkway between parallel counters
      for (let i = 0; i < counters.length; i++) {
        for (let j = i + 1; j < counters.length; j++) {
          const gap = getGapBetween(counters[i], counters[j]);
          if (gap > 0 && gap < walkway) {
            issues.push({
              type: 'warning',
              message: `Counter gap: ${formatDimension(gap)} (min ${formatDimension(walkway)})`,
              elements: [counters[i], counters[j]]
            });
          }
        }
      }

      // Check appliance clearances
      const appliances = findElementsByType(['stove', 'refrigerator', 'dishwasher', 'oven']);
      appliances.forEach(app => {
        // Check for adequate space in front (simplified - check distance to facing elements)
        const facing = [...islands, ...counters].filter(other => {
          const gap = getGapBetween(app, other);
          return gap > 0 && gap < applianceOpen;
        });

        facing.forEach(other => {
          const gap = getGapBetween(app, other);
          issues.push({
            type: 'info',
            message: `${app.label} front clearance: ${formatDimension(gap)} (rec. ${formatDimension(applianceOpen)})`,
            elements: [app, other]
          });
        });
      });

      return issues;
    }

    // Validate door clearances
    function validateDoorClearances() {
      const issues = [];
      const doors = findElementsByType(['door', 'double-door', 'entry-archway']);
      const allElements = elements.filter(el => !['door', 'double-door', 'entry-archway', 'window'].includes(el.type));

      doors.forEach(door => {
        allElements.forEach(other => {
          const gap = getGapBetween(door, other);
          if (gap > 0 && gap < BUILDING_STANDARDS.CLEARANCES.doorSwing) {
            issues.push({
              type: 'warning',
              message: `Door swing blocked: ${formatDimension(gap)} to ${other.label}`,
              elements: [door, other]
            });
          }
        });
      });

      return issues;
    }

    // Run all validations
    function runValidation() {
      validationIssues = [];

      // Work triangle
      const triangleResult = validateWorkTriangle();
      if (triangleResult.issues.length > 0) {
        validationIssues.push(...triangleResult.issues.map(i => ({
          ...i,
          category: 'Work Triangle'
        })));
      }

      // Clearances
      const clearanceIssues = validateClearances();
      validationIssues.push(...clearanceIssues.map(i => ({
        ...i,
        category: 'Clearances'
      })));

      // Door clearances
      const doorIssues = validateDoorClearances();
      validationIssues.push(...doorIssues.map(i => ({
        ...i,
        category: 'Door Swing'
      })));

      updateValidationPanel();
      return validationIssues;
    }

    // Update the validation panel UI
    function updateValidationPanel() {
      const panel = document.getElementById('validationPanel');
      if (!panel) return;

      const content = document.getElementById('validationContent');
      if (!content) return;

      if (validationIssues.length === 0) {
        content.innerHTML = '<div class="validation-ok"> No issues found</div>';
        return;
      }

      // Group by category
      const grouped = {};
      validationIssues.forEach(issue => {
        if (!grouped[issue.category]) grouped[issue.category] = [];
        grouped[issue.category].push(issue);
      });

      content.innerHTML = Object.entries(grouped).map(([category, issues]) => `
        <div class="validation-category">
          <div class="validation-category-title">${category}</div>
          ${issues.map(issue => `
            <div class="validation-issue validation-${issue.type}">
              <span class="validation-icon">${issue.type === 'error' ? '' : issue.type === 'warning' ? '' : ''}</span>
              <span class="validation-message">${issue.message}</span>
            </div>
          `).join('')}
        </div>
      `).join('');
    }

    // Draw work triangle on canvas
    function drawWorkTriangle() {
      if (!showWorkTriangle) return;

      const result = validateWorkTriangle();
      if (!result.triangle) return;

      const { sink, stove, fridge, leg1, leg2, leg3 } = result.triangle;

      ctx.save();
      ctx.setLineDash([10, 5]);
      ctx.lineWidth = 2;
      ctx.strokeStyle = result.valid ? 'rgba(34, 197, 94, 0.7)' : 'rgba(239, 68, 68, 0.7)';
      ctx.fillStyle = result.valid ? 'rgba(34, 197, 94, 0.1)' : 'rgba(239, 68, 68, 0.1)';

      const c1 = getElementCenter(sink);
      const c2 = getElementCenter(stove);
      const c3 = getElementCenter(fridge);

      // Draw triangle
      ctx.beginPath();
      ctx.moveTo(c1.x, c1.y);
      ctx.lineTo(c2.x, c2.y);
      ctx.lineTo(c3.x, c3.y);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();

      // Draw leg labels
      ctx.setLineDash([]);
      ctx.font = 'bold 11px Inter';
      ctx.fillStyle = result.valid ? '#22c55e' : '#ef4444';
      ctx.textAlign = 'center';

      // Leg 1 (sink-stove)
      const mid1 = { x: (c1.x + c2.x) / 2, y: (c1.y + c2.y) / 2 };
      ctx.fillText(formatDimension(leg1), mid1.x, mid1.y - 8);

      // Leg 2 (stove-fridge)
      const mid2 = { x: (c2.x + c3.x) / 2, y: (c2.y + c3.y) / 2 };
      ctx.fillText(formatDimension(leg2), mid2.x, mid2.y - 8);

      // Leg 3 (fridge-sink)
      const mid3 = { x: (c3.x + c1.x) / 2, y: (c3.y + c1.y) / 2 };
      ctx.fillText(formatDimension(leg3), mid3.x, mid3.y - 8);

      ctx.restore();
    }

    // Snap to standard dimension
    function snapToStandard(value, type = 'width') {
      const standards = type === 'width' ? SNAP_DIMENSIONS.widths : SNAP_DIMENSIONS.depths;
      const tolerance = SNAP_DIMENSIONS.tolerance;

      for (const std of standards) {
        if (Math.abs(value - std) <= tolerance) {
          return std;
        }
      }
      return value;
    }

    // Get suggested standard size for element type
    function getSuggestedSize(elementType) {
      switch (elementType) {
        case 'door':
          return { width: 3, height: 0.5, note: "Standard 36\" door" };
        case 'double-door':
          return { width: 5, height: 0.5, note: "Standard 60\" double door" };
        case 'sliding-door':
          return { width: 6, height: 0.5, note: "Standard 72\" slider" };
        case 'window':
          return { width: 3, height: 0.5, note: "Standard 36\" window" };
        case 'base-cabinet':
          return { width: 2, height: 2, note: "Standard 24\" base cabinet" };
        case 'wall-cabinet':
          return { width: 2.5, height: 1, note: "Standard 30\" wall cabinet" };
        case 'tall-cabinet':
          return { width: 2, height: 2, note: "Standard 24\" pantry" };
        case 'island':
          return { width: 4, height: 2.5, note: "Minimum island size" };
        case 'countertop':
          return { width: 3, height: 2.083, note: "Standard 25\" depth" };
        default:
          return null;
      }
    }

    // SVG icons for element thumbnails (single-line for reliability)
    const ELEMENT_ICONS = {
      'base-cabinet': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="12" width="40" height="32" rx="2" fill="#8B5A2B"/><rect x="6" y="14" width="17" height="28" rx="1" fill="#A0522D"/><rect x="25" y="14" width="17" height="28" rx="1" fill="#A0522D"/><rect x="8" y="16" width="13" height="24" rx="1" fill="#CD853F"/><rect x="27" y="16" width="13" height="24" rx="1" fill="#CD853F"/><rect x="19" y="24" width="2" height="8" rx="1" fill="#FFD700"/><rect x="35" y="24" width="2" height="8" rx="1" fill="#FFD700"/><rect x="4" y="44" width="40" height="4" fill="#2a2a2a"/></svg>',
      'wall-cabinet': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="8" width="40" height="24" rx="2" fill="#8B5A2B"/><rect x="6" y="10" width="17" height="20" rx="1" fill="#A0522D"/><rect x="25" y="10" width="17" height="20" rx="1" fill="#A0522D"/><rect x="8" y="12" width="13" height="16" rx="1" fill="#CD853F"/><rect x="27" y="12" width="13" height="16" rx="1" fill="#CD853F"/><rect x="19" y="18" width="2" height="6" rx="1" fill="#FFD700"/><rect x="35" y="18" width="2" height="6" rx="1" fill="#FFD700"/></svg>',
      'tall-cabinet': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="10" y="2" width="28" height="44" rx="2" fill="#8B5A2B"/><rect x="12" y="4" width="24" height="18" rx="1" fill="#A0522D"/><rect x="12" y="24" width="24" height="20" rx="1" fill="#A0522D"/><rect x="14" y="6" width="20" height="14" rx="1" fill="#CD853F"/><rect x="14" y="26" width="20" height="16" rx="1" fill="#CD853F"/><rect x="32" y="11" width="2" height="6" rx="1" fill="#FFD700"/><rect x="32" y="32" width="2" height="6" rx="1" fill="#FFD700"/></svg>',
      'corner-cabinet': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><path d="M4 4 L4 44 L24 44 L24 24 L44 24 L44 4 Z" fill="#8B5A2B"/><path d="M6 6 L6 42 L22 42 L22 22 L42 22 L42 6 Z" fill="#A0522D"/><line x1="22" y1="22" x2="42" y2="42" stroke="#CD853F" stroke-width="2"/><circle cx="28" cy="28" r="8" fill="none" stroke="#CD853F" stroke-width="1.5"/><rect x="32" y="32" width="3" height="10" rx="1" fill="#FFD700" transform="rotate(45 33.5 37)"/><rect x="4" y="44" width="20" height="4" fill="#2a2a2a"/></svg>',
      'island': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="16" width="44" height="24" rx="2" fill="#8B5A2B"/><rect x="2" y="12" width="44" height="6" rx="1" fill="#708090"/><rect x="4" y="18" width="12" height="20" rx="1" fill="#CD853F"/><rect x="18" y="18" width="12" height="20" rx="1" fill="#CD853F"/><rect x="32" y="18" width="12" height="20" rx="1" fill="#CD853F"/><rect x="14" y="26" width="2" height="6" rx="1" fill="#FFD700"/><rect x="28" y="26" width="2" height="6" rx="1" fill="#FFD700"/><rect x="2" y="40" width="44" height="4" fill="#2a2a2a"/></svg>',
      'countertop': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="18" width="44" height="8" rx="1" fill="#708090"/><rect x="2" y="20" width="44" height="4" fill="#5a6a7a"/><circle cx="10" cy="22" r="2" fill="#8090a0"/><circle cx="24" cy="22" r="2" fill="#8090a0"/><circle cx="38" cy="22" r="2" fill="#8090a0"/><rect x="2" y="26" width="44" height="2" fill="#4a5a6a"/></svg>',
      'backsplash': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="8" width="40" height="32" fill="#D4AF37"/><rect x="4" y="8" width="10" height="10" fill="#E5C158" stroke="#B8860B"/><rect x="14" y="8" width="10" height="10" fill="#D4AF37" stroke="#B8860B"/><rect x="24" y="8" width="10" height="10" fill="#E5C158" stroke="#B8860B"/><rect x="34" y="8" width="10" height="10" fill="#D4AF37" stroke="#B8860B"/><rect x="4" y="18" width="10" height="10" fill="#D4AF37" stroke="#B8860B"/><rect x="14" y="18" width="10" height="10" fill="#E5C158" stroke="#B8860B"/><rect x="24" y="18" width="10" height="10" fill="#D4AF37" stroke="#B8860B"/><rect x="34" y="18" width="10" height="10" fill="#E5C158" stroke="#B8860B"/><rect x="4" y="28" width="10" height="10" fill="#E5C158" stroke="#B8860B"/><rect x="14" y="28" width="10" height="10" fill="#D4AF37" stroke="#B8860B"/><rect x="24" y="28" width="10" height="10" fill="#E5C158" stroke="#B8860B"/><rect x="34" y="28" width="10" height="10" fill="#D4AF37" stroke="#B8860B"/></svg>',
      'flooring': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="2" width="22" height="44" fill="#CD853F"/><rect x="24" y="2" width="22" height="44" fill="#DEB887"/><line x1="2" y1="13" x2="24" y2="13" stroke="#8B4513"/><line x1="2" y1="24" x2="24" y2="24" stroke="#8B4513"/><line x1="2" y1="35" x2="24" y2="35" stroke="#8B4513"/><line x1="24" y1="8" x2="46" y2="8" stroke="#8B4513"/><line x1="24" y1="19" x2="46" y2="19" stroke="#8B4513"/><line x1="24" y1="30" x2="46" y2="30" stroke="#8B4513"/><line x1="24" y1="41" x2="46" y2="41" stroke="#8B4513"/></svg>',
      'tile': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="2" width="14" height="14" fill="#E8E8E8" stroke="#CCC"/><rect x="17" y="2" width="14" height="14" fill="#F5F5F5" stroke="#CCC"/><rect x="32" y="2" width="14" height="14" fill="#E8E8E8" stroke="#CCC"/><rect x="2" y="17" width="14" height="14" fill="#F5F5F5" stroke="#CCC"/><rect x="17" y="17" width="14" height="14" fill="#E8E8E8" stroke="#CCC"/><rect x="32" y="17" width="14" height="14" fill="#F5F5F5" stroke="#CCC"/><rect x="2" y="32" width="14" height="14" fill="#E8E8E8" stroke="#CCC"/><rect x="17" y="32" width="14" height="14" fill="#F5F5F5" stroke="#CCC"/><rect x="32" y="32" width="14" height="14" fill="#E8E8E8" stroke="#CCC"/></svg>',
      'sink': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="16" width="40" height="24" rx="4" fill="#E0E0E0"/><rect x="8" y="20" width="32" height="16" rx="2" fill="#404040"/><ellipse cx="24" cy="28" rx="12" ry="6" fill="#505050"/><rect x="22" y="6" width="4" height="10" rx="2" fill="#C0C0C0"/><ellipse cx="24" cy="6" rx="3" ry="2" fill="#A0A0A0"/><circle cx="24" cy="28" r="2" fill="#303030"/></svg>',
      'stove': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="8" width="40" height="36" rx="2" fill="#2a2a2a"/><rect x="6" y="10" width="36" height="16" rx="1" fill="#1a1a1a"/><circle cx="14" cy="18" r="5" fill="#333" stroke="#444" stroke-width="2"/><circle cx="34" cy="18" r="5" fill="#333" stroke="#444" stroke-width="2"/><rect x="8" y="28" width="32" height="14" rx="1" fill="#1a1a1a"/><rect x="12" y="30" width="24" height="10" rx="1" fill="#111"/></svg>',
      'refrigerator': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="8" y="2" width="32" height="44" rx="2" fill="#D0D0D0"/><rect x="10" y="4" width="28" height="14" rx="1" fill="#E0E0E0"/><rect x="10" y="20" width="28" height="24" rx="1" fill="#E0E0E0"/><rect x="34" y="8" width="2" height="6" rx="1" fill="#888"/><rect x="34" y="28" width="2" height="10" rx="1" fill="#888"/><line x1="10" y1="18" x2="38" y2="18" stroke="#999" stroke-width="2"/></svg>',
      'dishwasher': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="6" y="8" width="36" height="36" rx="2" fill="#A0A0A0"/><rect x="8" y="10" width="32" height="6" rx="1" fill="#606060"/><rect x="8" y="18" width="32" height="24" rx="1" fill="#B8B8B8"/><rect x="12" y="12" width="4" height="2" rx="1" fill="#888"/><rect x="18" y="12" width="4" height="2" rx="1" fill="#888"/><rect x="14" y="32" width="20" height="2" rx="1" fill="#909090"/></svg>',
      'microwave': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="12" width="40" height="24" rx="2" fill="#3a3a3a"/><rect x="6" y="14" width="26" height="20" rx="1" fill="#1a1a1a"/><rect x="8" y="16" width="22" height="16" rx="1" fill="#222"/><rect x="34" y="16" width="8" height="16" rx="1" fill="#4a4a4a"/><circle cx="38" cy="20" r="2" fill="#666"/><circle cx="38" cy="28" r="2" fill="#666"/></svg>',
      'range-hood': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><path d="M8 32 L16 12 L32 12 L40 32 Z" fill="#808080"/><rect x="6" y="32" width="36" height="8" rx="1" fill="#909090"/><rect x="20" y="4" width="8" height="8" fill="#707070"/><rect x="10" y="36" width="6" height="2" rx="1" fill="#606060"/><rect x="21" y="36" width="6" height="2" rx="1" fill="#606060"/><rect x="32" y="36" width="6" height="2" rx="1" fill="#606060"/></svg>',
      'oven': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="6" y="4" width="36" height="40" rx="2" fill="#2a2a2a"/><rect x="8" y="6" width="32" height="8" rx="1" fill="#3a3a3a"/><rect x="8" y="16" width="32" height="26" rx="1" fill="#1a1a1a"/><rect x="12" y="20" width="24" height="18" rx="1" fill="#222"/><rect x="14" y="8" width="20" height="4" rx="1" fill="#444"/></svg>',
      'door': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="8" y="4" width="32" height="40" rx="1" fill="#DEB887"/><rect x="10" y="6" width="12" height="16" rx="1" fill="#D2B48C"/><rect x="26" y="6" width="12" height="16" rx="1" fill="#D2B48C"/><rect x="10" y="26" width="12" height="16" rx="1" fill="#D2B48C"/><rect x="26" y="26" width="12" height="16" rx="1" fill="#D2B48C"/><circle cx="36" cy="26" r="2" fill="#FFD700"/></svg>',
      'double-door': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="4" width="18" height="40" rx="1" fill="#DEB887"/><rect x="26" y="4" width="18" height="40" rx="1" fill="#DEB887"/><rect x="6" y="8" width="14" height="32" rx="1" fill="#D2B48C"/><rect x="28" y="8" width="14" height="32" rx="1" fill="#D2B48C"/><circle cx="18" cy="26" r="2" fill="#FFD700"/><circle cx="30" cy="26" r="2" fill="#FFD700"/></svg>',
      'sliding-door': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="4" width="44" height="40" rx="1" fill="#BC8F8F"/><rect x="4" y="6" width="20" height="36" fill="#ADD8E6" opacity="0.6"/><rect x="24" y="6" width="20" height="36" fill="#ADD8E6" opacity="0.4"/><line x1="24" y1="6" x2="24" y2="42" stroke="#888" stroke-width="2"/><rect x="4" y="42" width="40" height="2" fill="#666"/></svg>',
      'entry-archway': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><path d="M4 44 L4 16 Q4 4 24 4 Q44 4 44 16 L44 44" fill="none" stroke="#DAA520" stroke-width="4"/><path d="M8 44 L8 18 Q8 8 24 8 Q40 8 40 18 L40 44" fill="#F5DEB3" opacity="0.3"/></svg>',
      'garage-door': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="4" width="44" height="40" rx="1" fill="#A9A9A9"/><rect x="4" y="6" width="40" height="8" fill="#888"/><rect x="4" y="16" width="40" height="8" fill="#999"/><rect x="4" y="26" width="40" height="8" fill="#888"/><rect x="4" y="36" width="40" height="6" fill="#999"/><rect x="20" y="38" width="8" height="2" fill="#666"/></svg>',
      'window': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="8" width="40" height="32" rx="2" fill="#FFF"/><rect x="6" y="10" width="17" height="13" fill="#87CEEB"/><rect x="25" y="10" width="17" height="13" fill="#87CEEB"/><rect x="6" y="25" width="17" height="13" fill="#87CEEB"/><rect x="25" y="25" width="17" height="13" fill="#87CEEB"/><line x1="24" y1="10" x2="24" y2="38" stroke="#FFF" stroke-width="2"/><line x1="6" y1="24" x2="42" y2="24" stroke="#FFF" stroke-width="2"/></svg>',
      'wall': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="4" width="40" height="8" fill="#666"/><rect x="4" y="14" width="18" height="8" fill="#555"/><rect x="24" y="14" width="20" height="8" fill="#555"/><rect x="4" y="24" width="40" height="8" fill="#666"/><rect x="4" y="34" width="18" height="8" fill="#555"/><rect x="24" y="34" width="20" height="8" fill="#555"/></svg>',
      'wall-wood-2x4': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="8" y="2" width="6" height="44" fill="#DEB887"/><rect x="20" y="2" width="6" height="44" fill="#DEB887"/><rect x="32" y="2" width="6" height="44" fill="#DEB887"/><rect x="6" y="10" width="36" height="4" fill="#D2B48C"/><rect x="6" y="32" width="36" height="4" fill="#D2B48C"/></svg>',
      'wall-wood-2x6': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="6" y="2" width="8" height="44" fill="#CD853F"/><rect x="20" y="2" width="8" height="44" fill="#CD853F"/><rect x="34" y="2" width="8" height="44" fill="#CD853F"/><rect x="4" y="10" width="40" height="5" fill="#DEB887"/><rect x="4" y="32" width="40" height="5" fill="#DEB887"/></svg>',
      'wall-steel': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="10" y="2" width="4" height="44" fill="#708090"/><rect x="22" y="2" width="4" height="44" fill="#708090"/><rect x="34" y="2" width="4" height="44" fill="#708090"/><rect x="8" y="8" width="32" height="3" fill="#A9A9A9"/><rect x="8" y="36" width="32" height="3" fill="#A9A9A9"/><circle cx="12" cy="10" r="2" fill="#666"/><circle cx="24" cy="10" r="2" fill="#666"/><circle cx="36" cy="10" r="2" fill="#666"/></svg>',
      'wall-aluminum': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="10" y="2" width="3" height="44" fill="#C0C0C0"/><rect x="22" y="2" width="3" height="44" fill="#C0C0C0"/><rect x="34" y="2" width="3" height="44" fill="#C0C0C0"/><rect x="8" y="6" width="32" height="2" fill="#D3D3D3"/><rect x="8" y="22" width="32" height="2" fill="#D3D3D3"/><rect x="8" y="38" width="32" height="2" fill="#D3D3D3"/></svg>',
      'wall-concrete': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="4" width="40" height="40" fill="#808080"/><circle cx="12" cy="12" r="2" fill="#696969"/><circle cx="28" cy="18" r="3" fill="#696969"/><circle cx="18" cy="32" r="2" fill="#696969"/><circle cx="36" cy="28" r="2" fill="#696969"/><circle cx="24" cy="38" r="2" fill="#696969"/></svg>',
      'wall-brick': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="4" width="10" height="6" fill="#B22222"/><rect x="14" y="4" width="10" height="6" fill="#B22222"/><rect x="26" y="4" width="10" height="6" fill="#B22222"/><rect x="38" y="4" width="8" height="6" fill="#B22222"/><rect x="2" y="12" width="5" height="6" fill="#CD5C5C"/><rect x="9" y="12" width="10" height="6" fill="#CD5C5C"/><rect x="21" y="12" width="10" height="6" fill="#CD5C5C"/><rect x="33" y="12" width="10" height="6" fill="#CD5C5C"/><rect x="2" y="20" width="10" height="6" fill="#B22222"/><rect x="14" y="20" width="10" height="6" fill="#B22222"/><rect x="26" y="20" width="10" height="6" fill="#B22222"/><rect x="38" y="20" width="8" height="6" fill="#B22222"/><rect x="2" y="28" width="5" height="6" fill="#CD5C5C"/><rect x="9" y="28" width="10" height="6" fill="#CD5C5C"/><rect x="21" y="28" width="10" height="6" fill="#CD5C5C"/><rect x="33" y="28" width="10" height="6" fill="#CD5C5C"/><rect x="2" y="36" width="10" height="6" fill="#B22222"/><rect x="14" y="36" width="10" height="6" fill="#B22222"/><rect x="26" y="36" width="10" height="6" fill="#B22222"/><rect x="38" y="36" width="8" height="6" fill="#B22222"/></svg>',
      'wall-block': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="4" width="14" height="10" fill="#696969" stroke="#555"/><rect x="18" y="4" width="14" height="10" fill="#696969" stroke="#555"/><rect x="34" y="4" width="12" height="10" fill="#696969" stroke="#555"/><rect x="2" y="16" width="14" height="10" fill="#787878" stroke="#555"/><rect x="18" y="16" width="14" height="10" fill="#787878" stroke="#555"/><rect x="34" y="16" width="12" height="10" fill="#787878" stroke="#555"/><rect x="2" y="28" width="14" height="10" fill="#696969" stroke="#555"/><rect x="18" y="28" width="14" height="10" fill="#696969" stroke="#555"/><rect x="34" y="28" width="12" height="10" fill="#696969" stroke="#555"/></svg>'
    };

    const ELEMENT_TYPES = {
      cabinets: [
        { type: 'base-cabinet', width: 3, height: 2, color: '#8B4513', label: 'Base Cabinet' },
        { type: 'wall-cabinet', width: 3, height: 1.5, color: '#A0522D', label: 'Wall Cabinet' },
        { type: 'tall-cabinet', width: 2, height: 7, color: '#8B4513', label: 'Tall Cabinet' },
        { type: 'corner-cabinet', width: 3, height: 3, color: '#7B3F00', label: 'Corner Cabinet' },
        { type: 'island', width: 6, height: 3, color: '#654321', label: 'Island' }
      ],
      surfaces: [
        { type: 'countertop', width: 8, height: 2, color: '#708090', label: 'Countertop' },
        { type: 'backsplash', width: 6, height: 1.5, color: '#B8860B', label: 'Backsplash' },
        { type: 'flooring', width: 5, height: 5, color: '#D2691E', label: 'Flooring' },
        { type: 'tile', width: 4, height: 4, color: '#CCC', label: 'Tile Area' }
      ],
      appliances: [
        { type: 'sink', width: 2.5, height: 2, color: '#C0C0C0', label: 'Sink' },
        { type: 'stove', width: 2.5, height: 2.5, color: '#2F2F2F', label: 'Stove/Range' },
        { type: 'refrigerator', width: 3, height: 3, color: '#A9A9A9', label: 'Refrigerator' },
        { type: 'dishwasher', width: 2, height: 2, color: '#808080', label: 'Dishwasher' },
        { type: 'microwave', width: 2, height: 1.5, color: '#4a4a4a', label: 'Microwave' },
        { type: 'range-hood', width: 2.5, height: 1.5, color: '#696969', label: 'Range Hood' },
        { type: 'oven', width: 2.5, height: 2.5, color: '#3a3a3a', label: 'Wall Oven' }
      ],
      structure: [
        // Doors & Entryways
        { type: 'door', width: 3, height: 0.5, color: '#DEB887', label: 'Standard Door' },
        { type: 'double-door', width: 5, height: 0.5, color: '#D2B48C', label: 'Double Door' },
        { type: 'sliding-door', width: 6, height: 0.5, color: '#BC8F8F', label: 'Sliding Door' },
        { type: 'entry-archway', width: 4, height: 0.5, color: '#DAA520', label: 'Archway' },
        { type: 'garage-door', width: 8, height: 0.5, color: '#A9A9A9', label: 'Garage Door' },
        { type: 'window', width: 4, height: 0.5, color: '#87CEEB', label: 'Window' },
        // Walls - Residential
        { type: 'wall', width: 0.5, height: 8, color: '#555', label: 'Wall (Drywall)' },
        { type: 'wall-wood-2x4', width: 0.33, height: 8, color: '#8B7355', label: 'Wall (2x4 Wood)' },
        { type: 'wall-wood-2x6', width: 0.5, height: 8, color: '#8B6914', label: 'Wall (2x6 Wood)' },
        // Walls - Commercial
        { type: 'wall-steel', width: 0.33, height: 10, color: '#708090', label: 'Wall (Steel Frame)' },
        { type: 'wall-aluminum', width: 0.33, height: 10, color: '#C0C0C0', label: 'Wall (Aluminum)' },
        // Walls - Masonry
        { type: 'wall-concrete', width: 0.67, height: 8, color: '#808080', label: 'Wall (Concrete)' },
        { type: 'wall-brick', width: 0.67, height: 8, color: '#B22222', label: 'Wall (Brick)' },
        { type: 'wall-block', width: 0.67, height: 8, color: '#696969', label: 'Wall (CMU Block)' }
      ]
    };

    const FLOOR_PLANS = [
      { id: 'empty', name: 'Empty', walls: [] },
      { id: 'square', name: 'Square', walls: [
        { x: 0, y: 0, w: 1, h: 1, type: 'full' }
      ]},
      { id: 'l-shape', name: 'L-Shape', walls: [
        { x: 0, y: 0, w: 0.6, h: 1, type: 'rect' },
        { x: 0, y: 0, w: 1, h: 0.5, type: 'rect' }
      ]},
      { id: 'u-shape', name: 'U-Shape', walls: [
        { x: 0, y: 0, w: 0.3, h: 1, type: 'rect' },
        { x: 0.7, y: 0, w: 0.3, h: 1, type: 'rect' },
        { x: 0, y: 0.7, w: 1, h: 0.3, type: 'rect' }
      ]},
      { id: 'galley', name: 'Galley', walls: [
        { x: 0, y: 0, w: 0.2, h: 1, type: 'rect' },
        { x: 0.8, y: 0, w: 0.2, h: 1, type: 'rect' }
      ]},
      { id: 'open', name: 'Open Plan', walls: [
        { x: 0, y: 0.7, w: 0.4, h: 0.3, type: 'rect' }
      ]}
    ];

    // Materials library using actual Surprise Granite product images + Daltile CTF Price List
    const MATERIALS = {
      granite: [
        // Surprise Granite Collection
        { id: 'granite-blackwood', name: 'Blackwood', color: '#2a2a2a', url: '/images/6456ce4576abb28c02fbc1f8_cambria-surprise-granite-blackwood-quartz-close-up.webp', brand: 'Cambria' },
        { id: 'granite-hermitage', name: 'Hermitage', color: '#8b7355', url: '/images/6456ce4476abb20e81fbb85f_cambria-surprise-granite-hermitage-close-up.webp', brand: 'Cambria' },
        { id: 'granite-winterbourne', name: 'Winterbourne', color: '#e8e4dc', url: '/images/6456ce4476abb2082efbb815_cambria-surprise-granite-winterbourne-close-up.webp', brand: 'Cambria' },
        { id: 'granite-clovelly', name: 'Clovelly', color: '#c9bfb0', url: '/images/6456ce4476abb2275dfbb824_cambria-surprise-granite-clovelly-moment2.webp', brand: 'Cambria' },
        // Daltile Natural Stone - Granite (CTF Price List Jan 2026)
        { id: 'daltile-absolute-black', name: 'Absolute Black', color: '#0a0a0a', sku: 'L75712121L', price: 10.45, brand: 'Daltile' },
        { id: 'daltile-alaska-white', name: 'Alaska White', color: '#E8E4E0', sku: 'L77612121L', price: 23.40, brand: 'Daltile' },
        { id: 'daltile-bianco-antico', name: 'Bianco Antico', color: '#E0D8D0', sku: 'L79912121L', price: 25.90, brand: 'Daltile' },
        { id: 'daltile-black-galaxy', name: 'Black Galaxy', color: '#1a1a2e', sku: 'L76712121L', price: 10.45, brand: 'Daltile' },
        { id: 'daltile-blue-pearl', name: 'Blue Pearl', color: '#3d4f6b', sku: 'L75812121L', price: 16.05, brand: 'Daltile' },
        { id: 'daltile-colonial-white', name: 'Colonial White', color: '#F0EBE5', sku: 'L79512121L', price: 23.40, brand: 'Daltile' },
        { id: 'daltile-delicatus-white', name: 'Delicatus White', color: '#FAF8F5', sku: 'L80812121L', price: 31.45, brand: 'Daltile' },
        { id: 'daltile-fantasy-brown', name: 'Fantasy Brown', color: '#C4B7A6', sku: 'L81212121L', price: 25.90, brand: 'Daltile' },
        { id: 'daltile-giallo-ornamental', name: 'Giallo Ornamental', color: '#C9B896', sku: 'L76012121L', price: 10.45, brand: 'Daltile' },
        { id: 'daltile-new-venetian-gold', name: 'New Venetian Gold', color: '#D4B878', sku: 'L76112121L', price: 10.45, brand: 'Daltile' },
        { id: 'daltile-river-white', name: 'River White', color: '#F0EBE5', sku: 'L80712121L', price: 23.40, brand: 'Daltile' },
        { id: 'daltile-santa-cecilia', name: 'Santa Cecilia', color: '#C8A878', sku: 'L76212121L', price: 10.45, brand: 'Daltile' },
        { id: 'daltile-steel-grey', name: 'Steel Grey', color: '#6B6B6B', sku: 'L78512121L', price: 10.45, brand: 'Daltile' },
        { id: 'daltile-typhoon-bordeaux', name: 'Typhoon Bordeaux', color: '#8B4A4A', sku: 'L79812121L', price: 25.90, brand: 'Daltile' },
        { id: 'daltile-uba-tuba', name: 'Uba Tuba', color: '#2A3A2A', sku: 'L76312121L', price: 5.80, brand: 'Daltile' },
        { id: 'daltile-white-ice', name: 'White Ice', color: '#F8F8F8', sku: 'L81112121L', price: 23.40, brand: 'Daltile' }
      ],
      quartz: [
        // Surprise Granite Collection
        { id: 'quartz-stellar-white', name: 'Stellar White', color: '#f5f5f5', url: '/images/6456ce4576abb21af6fbc914_msi-surfaces-quartz-surprise-granite-stellar-white-moment.webp', brand: 'MSI' },
        { id: 'quartz-shell-white', name: 'Shell White', color: '#faf8f5', url: '/images/6456ce4576abb28a6bfbc8cb_msi-surfaces-quartz-surprise-granite-shell-white-close-up.webp', brand: 'MSI' },
        { id: 'quartz-perla-white', name: 'Perla White', color: '#f0ece5', url: '/images/6456ce4576abb20436fbc89c_msi-surfaces-quartz-surprise-granite-perla-white-moment.webp', brand: 'MSI' },
        { id: 'quartz-stellar-gray', name: 'Stellar Gray', color: '#8a8a8a', url: '/images/6456ce4576abb2590afbc90f_msi-surfaces-quartz-surprise-granite-sstellar-gray-moment.webp', brand: 'MSI' },
        { id: 'quartz-midnight', name: 'Midnight Majesty', color: '#1a1a2e', url: '/images/6456ce4576abb2eaa9fbc85a_msi-surfaces-quartz-surprise-granite-midnight-majesty-close-up.webp', brand: 'MSI' },
        { id: 'quartz-calacatta', name: 'Calacatta Laurent', color: '#f8f6f0', url: '/images/6456ce4576abb294bffbc2da_dekton-surprise-granite-laurent-quartz-close-up.webp', brand: 'Dekton' },
        // MSI Premium Natural Quartz (Jan 2025 Price List) - with CDN images
        { id: 'msi-aruca-white', name: 'Aruca White', color: '#F5F5F5', sku: 'QSL-ARUCAWHT', price: 8.40, brand: 'MSI Quartz', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/aruca-white-quartz.jpg' },
        { id: 'msi-frost-white', name: 'Frost White', color: '#FFFFFF', sku: 'QSL-FRSTWHT', price: 8.40, brand: 'MSI Quartz', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/frost-white-quartz.jpg' },
        { id: 'msi-sparkling-white', name: 'Sparkling White', color: '#FAFAFA', sku: 'QSL-SPRWHT', price: 8.40, brand: 'MSI Quartz', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/sparkling-white-quartz.jpg' },
        { id: 'msi-arctic-white', name: 'Arctic White', color: '#F0F0F0', sku: 'QSL-ARCWHT', price: 9.00, brand: 'MSI Quartz', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/arctic-white-quartz.jpg' },
        { id: 'msi-carrara-mist', name: 'Carrara Mist', color: '#E8E8E8', sku: 'QSL-CARRMIST', price: 10.75, brand: 'MSI Quartz', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/carrara-mist-quartz.jpg' },
        { id: 'msi-calacatta-alto', name: 'Calacatta Alto', color: '#FAF8F5', sku: 'QSL-CALAALTO', price: 10.75, brand: 'MSI Quartz', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/calacatta-alto-quartz.jpg' },
        { id: 'msi-midnight-majesty', name: 'Midnight Majesty', color: '#1A1A1A', sku: 'QSL-MIDMAJ', price: 10.75, brand: 'MSI Quartz', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/midnight-majesty-quartz.jpg' },
        { id: 'msi-alabaster-white', name: 'Alabaster White', color: '#FAF8F5', sku: 'QSL-ALABWHT', price: 13.15, brand: 'MSI Quartz', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/alabaster-white-quartz.jpg' },
        { id: 'msi-calacatta-vicenza', name: 'Calacatta Vicenza', color: '#F8F5F0', sku: 'QSL-CALVIC', price: 13.15, brand: 'MSI Quartz', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/calacatta-vicenza-quartz.jpg' },
        { id: 'msi-calacatta-laza', name: 'Calacatta Laza', color: '#FAFAFA', sku: 'QSL-CALALAZA', price: 15.00, brand: 'MSI Quartz', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/calacatta-laza-quartz.jpg' },
        { id: 'msi-babylon-gray', name: 'Babylon Gray', color: '#4A4A4A', sku: 'QSL-BABYLONGRY', price: 15.00, brand: 'MSI Quartz', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/babylon-gray-quartz.jpg' },
        { id: 'msi-soapstone-mist', name: 'Soapstone Mist', color: '#686868', sku: 'QSL-SPSTNMIST', price: 15.00, brand: 'MSI Quartz', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/soapstone-mist-quartz.jpg' },
        { id: 'msi-calacatta-miraggio', name: 'Calacatta Miraggio', color: '#FAF8F5', sku: 'QSL-CALAMIRAGGIO', price: 18.00, brand: 'MSI Quartz', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/calacatta-miraggio-quartz.jpg' },
        { id: 'msi-calacatta-versailles', name: 'Calacatta Versailles', color: '#FAFAFA', sku: 'QSL-CALAVERSA', price: 20.75, brand: 'MSI Quartz', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/calacatta-versailles-quartz.jpg' },
        { id: 'msi-lumataj', name: 'Lumataj', color: '#F5F0E8', sku: 'QSL-LUMATAJ', price: 21.80, brand: 'MSI Quartz', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/lumataj-quartz.jpg' },
        // MSI Premium Quartz - Additional Colors (Jan 2025) - with CDN images
        { id: 'msi-iced-white', name: 'Iced White', color: '#F8F8F8', sku: 'QSL-ICEDWHT', price: 8.40, brand: 'MSI Quartz', tier: 'Group 0', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/iced-white-quartz.jpg' },
        { id: 'msi-bayshore-sand', name: 'Bayshore Sand', color: '#D4C4A8', sku: 'QSL-BAYSHRSND', price: 8.40, brand: 'MSI Quartz', tier: 'Group 0', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/bayshore-sand-quartz.jpg' },
        { id: 'msi-snow-white', name: 'Snow White', color: '#FEFEFE', sku: 'QSL-SNOWHTE', price: 9.00, brand: 'MSI Quartz', tier: 'Group 1', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/snow-white-quartz.jpg' },
        { id: 'msi-carrara-marmi', name: 'Carrara Marmi', color: '#F5F5F5', sku: 'QSL-CARMARMI', price: 10.75, brand: 'MSI Quartz', tier: 'Group 2', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/carrara-marmi-quartz.jpg' },
        { id: 'msi-stellar-white-g2', name: 'Stellar White', color: '#F5F5F5', sku: 'QSL-STELLARWHT', price: 10.75, brand: 'MSI Quartz', tier: 'Group 2', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/stellar-white-quartz.jpg' },
        { id: 'msi-calacatta-classique', name: 'Calacatta Classique', color: '#FAFAFA', sku: 'QSL-CALACLSQUE', price: 13.15, brand: 'MSI Quartz', tier: 'Group 3', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/calacatta-classique-quartz.jpg' },
        { id: 'msi-fairy-white', name: 'Fairy White', color: '#F8F8F8', sku: 'QSL-FAIWHT', price: 13.15, brand: 'MSI Quartz', tier: 'Group 3', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/fairy-white-quartz.jpg' },
        { id: 'msi-calacatta-botanica', name: 'Calacatta Botanica', color: '#F5F2EE', sku: 'QSL-CALABOTNICA', price: 15.00, brand: 'MSI Quartz', tier: 'Group 4', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/calacatta-botanica-quartz.jpg' },
        { id: 'msi-perla-white-g4', name: 'Perla White', color: '#F0ECE5', sku: 'QSL-PERWHT', price: 15.00, brand: 'MSI Quartz', tier: 'Group 4', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/perla-white-quartz.jpg' },
        { id: 'msi-calacatta-monaco', name: 'Calacatta Monaco', color: '#F8F5F0', sku: 'QSL-CALAMONACO', price: 17.00, brand: 'MSI Quartz', tier: 'Group 5', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/calacatta-monaco-quartz.jpg' },
        { id: 'msi-glacier-white', name: 'Glacier White', color: '#F8F8F8', sku: 'QSL-GLACIERWHT', price: 17.00, brand: 'MSI Quartz', tier: 'Group 5', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/glacier-white-quartz.jpg' },
        { id: 'msi-statuary-classique', name: 'Statuary Classique', color: '#FAFAFA', sku: 'QSL-STACLSQUE', price: 17.00, brand: 'MSI Quartz', tier: 'Group 5', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/statuary-classique-quartz.jpg' },
        { id: 'msi-calacatta-clara', name: 'Calacatta Clara', color: '#FAFAFA', sku: 'QSL-CALACLARA', price: 18.00, brand: 'MSI Quartz', tier: 'Group 6', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/calacatta-clara-quartz.jpg' },
        { id: 'msi-calacatta-luccia', name: 'Calacatta Luccia', color: '#FAFAFA', sku: 'QSL-CALALUCCIA', price: 18.00, brand: 'MSI Quartz', tier: 'Group 6', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/calacatta-luccia-quartz.jpg' },
        { id: 'msi-calacatta-trevi', name: 'Calacatta Trevi', color: '#FAFAFA', sku: 'QSL-CALATREVI', price: 18.00, brand: 'MSI Quartz', tier: 'Group 6', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/calacatta-trevi-quartz.jpg' },
        { id: 'msi-calacatta-goa', name: 'Calacatta Goa', color: '#FAF8F5', sku: 'QSL-CALAGOA', price: 20.75, brand: 'MSI Quartz', tier: 'Group 7', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/calacatta-goa-quartz.jpg' },
        { id: 'msi-calacatta-miraggio-gold', name: 'Calacatta Miraggio Gold', color: '#FAF5E8', sku: 'QSL-CALAMIRGOLD', price: 20.75, brand: 'MSI Quartz', tier: 'Group 7', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/calacatta-miraggio-gold-quartz.jpg' },
        { id: 'msi-azurmatt', name: 'Azurmatt', color: '#4A6B8C', sku: 'QSL-AZURMATT', price: 21.80, brand: 'MSI Quartz', tier: 'Group 8', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/azurmatt-quartz.jpg' },
        { id: 'msi-calacatta-viraldi', name: 'Calacatta Viraldi', color: '#FAF8F5', sku: 'QSL-CALAVIRALDI', price: 21.80, brand: 'MSI Quartz', tier: 'Group 8', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/calacatta-viraldi-quartz.jpg' },
        // Daltile ONE Quartz Surfaces (CTF Price List Jan 2026)
        { id: 'daltile-quartz-alabaster', name: 'Alabaster White', color: '#FAF8F5', sku: 'NQ90', price: 7.90, brand: 'Daltile ONE Quartz' },
        { id: 'daltile-quartz-simply-white', name: 'Simply White', color: '#FEFEFE', sku: 'NQ51', price: 7.90, brand: 'Daltile ONE Quartz' },
        { id: 'daltile-quartz-frost-white', name: 'Frost White', color: '#FFFFFF', sku: 'NQ01', price: 12.60, brand: 'Daltile ONE Quartz' },
        { id: 'daltile-quartz-carrara-mist', name: 'Carrara Mist', color: '#F5F5F5', sku: 'NQ64', price: 21.15, brand: 'Daltile ONE Quartz' },
        { id: 'daltile-quartz-calacatta-laza', name: 'Calacatta Laza', color: '#FAFAFA', sku: 'NQ73', price: 34.60, brand: 'Daltile ONE Quartz' }
      ],
      marble: [
        // Daltile Natural Stone - Marble (CTF Price List Jan 2026)
        { id: 'daltile-carrara-honed', name: 'Carrara White (Honed)', color: '#F5F5F5', sku: 'M70112181U', price: 10.45, brand: 'Daltile' },
        { id: 'daltile-carrara-polished', name: 'Carrara White (Polished)', color: '#FAFAFA', sku: 'M70112181L', price: 12.25, brand: 'Daltile' },
        { id: 'daltile-first-snow', name: 'First Snow Elegance', color: '#FFFFFF', sku: 'M19012181L', price: 38.80, brand: 'Daltile' }
      ],
      quartzite: [
        // Daltile Natural Stone - Quartzite (CTF Price List Jan 2026)
        { id: 'daltile-super-white', name: 'Super White', color: '#FEFEFE', sku: 'L02212121L', price: 39.85, brand: 'Daltile' },
        { id: 'daltile-taj-mahal', name: 'Taj Mahal', color: '#F5F0E8', sku: 'L02112121L', price: 39.85, brand: 'Daltile' },
        { id: 'daltile-calacatta-macaubas', name: 'Calacatta Macaubas', color: '#FAF8F5', sku: 'L02612121L', price: 39.85, brand: 'Daltile' },
        { id: 'daltile-azul-macaubas', name: 'Azul Macaubas', color: '#4A6B8C', sku: 'L02512121L', price: 39.85, brand: 'Daltile' },
        { id: 'daltile-sea-pearl', name: 'Sea Pearl', color: '#D8E0E8', sku: 'L02312121L', price: 39.85, brand: 'Daltile' },
        { id: 'daltile-madre-perla', name: 'Madre Perla', color: '#F0E8E0', sku: 'L02812121L', price: 31.20, brand: 'Daltile' }
      ],
      cabinets: [
        { id: 'cabinet-white', name: 'Shaker White', color: '#f5f5f5', url: '/images/6456ce4476abb22994fbb0d6_Liberty%20Shaker%20White%20Cabinet.webp' },
        { id: 'cabinet-grey', name: 'Shaker Grey', color: '#7a7a7a', url: '/images/6456ce4476abb22121fbb0d7_Liberty%20Shaker%20Grey%20Cabinet.webp' },
        { id: 'cabinet-espresso', name: 'Shaker Espresso', color: '#3d2b1f', url: '/images/6456ce4476abb20cc6fbb0d5_Liberty%20Shaker%20Espresso.webp' },
        { id: 'cabinet-black', name: 'Onyx Black', color: '#1a1a1a', url: '/images/6456ce4476abb24601fbb0e8_Onyx%20Black%20Shaker.webp' },
        { id: 'cabinet-uptown', name: 'Uptown White', color: '#fefefe', url: '/images/6456ce4476abb232ddfbb0eb_Uptown%20White%20Shaker.webp' },
        // MSI Cabinet Collection - Base Cabinets (Jan 2025 Pricing)
        { id: 'msi-cab-b09', name: 'MSI Base 9"', color: '#f5f5f5', sku: 'B09', price: 119.13, brand: 'MSI', type: 'base', width: 9 },
        { id: 'msi-cab-b12', name: 'MSI Base 12"', color: '#f5f5f5', sku: 'B12', price: 127.63, brand: 'MSI', type: 'base', width: 12 },
        { id: 'msi-cab-b15', name: 'MSI Base 15"', color: '#f5f5f5', sku: 'B15', price: 137.25, brand: 'MSI', type: 'base', width: 15 },
        { id: 'msi-cab-b18', name: 'MSI Base 18"', color: '#f5f5f5', sku: 'B18', price: 146.30, brand: 'MSI', type: 'base', width: 18 },
        { id: 'msi-cab-b21', name: 'MSI Base 21"', color: '#f5f5f5', sku: 'B21', price: 155.00, brand: 'MSI', type: 'base', width: 21 },
        { id: 'msi-cab-b24', name: 'MSI Base 24"', color: '#f5f5f5', sku: 'B24', price: 175.71, brand: 'MSI', type: 'base', width: 24 },
        { id: 'msi-cab-b30', name: 'MSI Base 30"', color: '#f5f5f5', sku: 'B30', price: 196.45, brand: 'MSI', type: 'base', width: 30 },
        { id: 'msi-cab-b36', name: 'MSI Base 36"', color: '#f5f5f5', sku: 'B36', price: 245.41, brand: 'MSI', type: 'base', width: 36 },
        { id: 'msi-cab-sb30', name: 'MSI Sink Base 30"', color: '#f5f5f5', sku: 'SB30', price: 151.82, brand: 'MSI', type: 'sink', width: 30 },
        { id: 'msi-cab-sb36', name: 'MSI Sink Base 36"', color: '#f5f5f5', sku: 'SB36', price: 171.82, brand: 'MSI', type: 'sink', width: 36 },
        { id: 'msi-cab-3db15', name: 'MSI Drawer Base 15"', color: '#f5f5f5', sku: '3DB15', price: 206.32, brand: 'MSI', type: 'drawer', width: 15 },
        { id: 'msi-cab-3db18', name: 'MSI Drawer Base 18"', color: '#f5f5f5', sku: '3DB18', price: 219.00, brand: 'MSI', type: 'drawer', width: 18 },
        // MSI Cabinet Collection - Wall Cabinets
        { id: 'msi-cab-w1236', name: 'MSI Wall 12x36"', color: '#f5f5f5', sku: 'W1236', price: 82.15, brand: 'MSI', type: 'wall', width: 12, height: 36 },
        { id: 'msi-cab-w1536', name: 'MSI Wall 15x36"', color: '#f5f5f5', sku: 'W1536', price: 92.77, brand: 'MSI', type: 'wall', width: 15, height: 36 },
        { id: 'msi-cab-w1836', name: 'MSI Wall 18x36"', color: '#f5f5f5', sku: 'W1836', price: 103.55, brand: 'MSI', type: 'wall', width: 18, height: 36 },
        { id: 'msi-cab-w2436', name: 'MSI Wall 24x36"', color: '#f5f5f5', sku: 'W2436', price: 136.01, brand: 'MSI', type: 'wall', width: 24, height: 36 },
        { id: 'msi-cab-w3036', name: 'MSI Wall 30x36"', color: '#f5f5f5', sku: 'W3036', price: 154.95, brand: 'MSI', type: 'wall', width: 30, height: 36 },
        { id: 'msi-cab-w3630', name: 'MSI Wall 36x30"', color: '#f5f5f5', sku: 'W3630', price: 154.95, brand: 'MSI', type: 'wall', width: 36, height: 30 },
        { id: 'msi-cab-w1242', name: 'MSI Wall 12x42"', color: '#f5f5f5', sku: 'W1242', price: 95.99, brand: 'MSI', type: 'wall', width: 12, height: 42 },
        { id: 'msi-cab-w2442', name: 'MSI Wall 24x42"', color: '#f5f5f5', sku: 'W2442', price: 159.90, brand: 'MSI', type: 'wall', width: 24, height: 42 },
        { id: 'msi-cab-w3042', name: 'MSI Wall 30x42"', color: '#f5f5f5', sku: 'W3042', price: 184.23, brand: 'MSI', type: 'wall', width: 30, height: 42 },
        // MSI Cabinet Collection - Vanity Cabinets
        { id: 'msi-cab-v3021', name: 'MSI Vanity 30x21"', color: '#f5f5f5', sku: 'V3021', price: 152.48, brand: 'MSI', type: 'vanity', width: 30 },
        { id: 'msi-cab-v3621', name: 'MSI Vanity 36x21"', color: '#f5f5f5', sku: 'V3621', price: 172.00, brand: 'MSI', type: 'vanity', width: 36 },
        { id: 'msi-cab-vdb4221', name: 'MSI Vanity Combo 42x21"', color: '#f5f5f5', sku: 'VDB4221R', price: 328.93, brand: 'MSI', type: 'vanity', width: 42 },
        { id: 'msi-cab-vdb4821', name: 'MSI Vanity Combo 48x21"', color: '#f5f5f5', sku: 'VDB4821', price: 361.88, brand: 'MSI', type: 'vanity', width: 48 }
      ],
      tile: [
        // Existing tiles
        { id: 'tile-perla', name: 'Taja Perla', color: '#d4cfc5', url: '/images/6456ce4576abb2d4d0fbcc56_taja-perla-porcelain-close-up-thumbnail.jpg' },
        { id: 'tile-white', name: 'White Subway', color: '#ffffff', url: '' },
        { id: 'tile-marble', name: 'Carrara Look', color: '#e8e8e8', url: '' },
        { id: 'tile-slate', name: 'Slate Grey', color: '#708090', url: '' },
        // Daltile PANORAMIC Porcelain Surfaces (CTF Price List Jan 2026)
        { id: 'daltile-panoramic-calacatta', name: 'PANORAMIC Calacatta', color: '#FAFAFA', sku: 'PAN-CAL', price: 31.20, brand: 'Daltile', series: 'PANORAMIC' },
        { id: 'daltile-panoramic-statuario', name: 'PANORAMIC Statuario', color: '#F8F8F8', sku: 'PAN-STA', price: 31.20, brand: 'Daltile', series: 'PANORAMIC' },
        { id: 'daltile-panoramic-nero', name: 'PANORAMIC Nero Marquina', color: '#1A1A1A', sku: 'PAN-NER', price: 28.80, brand: 'Daltile', series: 'PANORAMIC' },
        { id: 'daltile-panoramic-cement', name: 'PANORAMIC Cement', color: '#9E9E9E', sku: 'PAN-CEM', price: 8.90, brand: 'Daltile', series: 'PANORAMIC' }
      ],
      flooring: [
        { id: 'floor-premium', name: 'Premium LVP', color: '#b8956c', url: '/images/6456ce4476abb2d85bfbb1d2_All%20Flooring%20Hero%20Background%20Image.webp' },
        { id: 'floor-oak', name: 'Natural Oak', color: '#c4a76c', url: '' },
        { id: 'floor-walnut', name: 'Dark Walnut', color: '#5d4037', url: '' },
        { id: 'floor-maple', name: 'Light Maple', color: '#deb887', url: '' },
        // MSI Everlife LVT Flooring - Ashton Series (Tier 4 Pricing Q1 2025) - with CDN images
        { id: 'msi-lvt-bergen-hills', name: 'Ashton Bergen Hills', color: '#C4A76C', sku: 'ASHTON-BERGENHILLS', price: 1.25, brand: 'MSI Everlife', series: 'Ashton', warranty: '25yr Res' },
        { id: 'msi-lvt-maracay-brown', name: 'Ashton Maracay Brown', color: '#8B7355', sku: 'ASHTON-MARACAYBROWN', price: 1.25, brand: 'MSI Everlife', series: 'Ashton', warranty: '25yr Res' },
        { id: 'msi-lvt-york-gray', name: 'Ashton York Gray', color: '#7A7A7A', sku: 'ASHTON-YORKGRAY', price: 1.25, brand: 'MSI Everlife', series: 'Ashton', warranty: '25yr Res' },
        // MSI Everlife LVT - Cyrus Series - with CDN images
        { id: 'msi-lvt-akadia', name: 'Cyrus Akadia', color: '#A08060', sku: 'CYRUS-AKADIA', price: 1.55, brand: 'MSI Everlife', series: 'Cyrus', warranty: 'Lifetime/10yr Comm' },
        { id: 'msi-lvt-barnstorm', name: 'Cyrus Barnstorm', color: '#5D4037', sku: 'CYRUS-BARNSTORM', price: 1.55, brand: 'MSI Everlife', series: 'Cyrus', warranty: 'Lifetime/10yr Comm' },
        { id: 'msi-lvt-braly', name: 'Cyrus Braly', color: '#6B5344', sku: 'CYRUS-BRALY', price: 1.55, brand: 'MSI Everlife', series: 'Cyrus', warranty: 'Lifetime/10yr Comm' },
        { id: 'msi-lvt-fauna', name: 'Cyrus Fauna', color: '#9E8B7D', sku: 'CYRUS-FAUNA', price: 1.55, brand: 'MSI Everlife', series: 'Cyrus', warranty: 'Lifetime/10yr Comm' },
        { id: 'msi-lvt-katella-ash', name: 'Cyrus Katella Ash', color: '#8A8A8A', sku: 'CYRUS-KATELLAASH', price: 1.55, brand: 'MSI Everlife', series: 'Cyrus', warranty: 'Lifetime/10yr Comm' },
        { id: 'msi-lvt-ludlow', name: 'Cyrus Ludlow', color: '#7D6B5D', sku: 'CYRUS-LUDLOW', price: 1.55, brand: 'MSI Everlife', series: 'Cyrus', warranty: 'Lifetime/10yr Comm' },
        { id: 'msi-lvt-sandino', name: 'Cyrus Sandino', color: '#C4A878', sku: 'CYRUS-SANDINO', price: 1.55, brand: 'MSI Everlife', series: 'Cyrus', warranty: 'Lifetime/10yr Comm' },
        // MSI Everlife LVT - Prescott Series (Premium Commercial) - with CDN images
        { id: 'msi-lvt-prescott-akadia', name: 'Prescott Akadia', color: '#A08060', sku: 'PRESCOTT-AKADIA', price: 1.79, brand: 'MSI Everlife', series: 'Prescott', warranty: 'Lifetime/20yr Comm' },
        { id: 'msi-lvt-prescott-braly', name: 'Prescott Braly', color: '#6B5344', sku: 'PRESCOTT-BRALY', price: 1.79, brand: 'MSI Everlife', series: 'Prescott', warranty: 'Lifetime/20yr Comm' },
        { id: 'msi-lvt-prescott-fauna', name: 'Prescott Fauna', color: '#9E8B7D', sku: 'PRESCOTT-FAUNA', price: 1.79, brand: 'MSI Everlife', series: 'Prescott', warranty: 'Lifetime/20yr Comm' },
        { id: 'msi-lvt-prescott-ludlow', name: 'Prescott Ludlow', color: '#7D6B5D', sku: 'PRESCOTT-LUDLOW', price: 1.79, brand: 'MSI Everlife', series: 'Prescott', warranty: 'Lifetime/20yr Comm' },
        // MSI Everlife LVT - Andover Series - with CDN images
        { id: 'msi-lvt-bayhill-blonde', name: 'Andover Bayhill Blonde', color: '#DEB887', sku: 'ANDOVER-BAYHILLBLONDE', price: 1.79, brand: 'MSI Everlife', series: 'Andover', warranty: 'Lifetime/15yr Comm' },
        { id: 'msi-lvt-hatfield', name: 'Andover Hatfield', color: '#8B7355', sku: 'ANDOVER-HATFIELD', price: 1.79, brand: 'MSI Everlife', series: 'Andover', warranty: 'Lifetime/15yr Comm' },
        { id: 'msi-lvt-kingsdown-gray', name: 'Andover Kingsdown Gray', color: '#6E6E6E', sku: 'ANDOVER-KINGSDOWNGRAY', price: 1.79, brand: 'MSI Everlife', series: 'Andover', warranty: 'Lifetime/15yr Comm' },
        { id: 'msi-lvt-whitby-white', name: 'Andover Whitby White', color: '#E8E4DC', sku: 'ANDOVER-WHITBYWHITE', price: 1.79, brand: 'MSI Everlife', series: 'Andover', warranty: 'Lifetime/15yr Comm' },
        // MSI Everlife LVT - Trecento Series (Stone Look 12x24) - with CDN images
        { id: 'msi-lvt-calacatta-legend', name: 'Trecento Calacatta Legend', color: '#F5F5F5', sku: 'TRECENTO-CALACATTALEGEND', price: 1.75, brand: 'MSI Everlife', series: 'Trecento', warranty: 'Lifetime/10yr Comm' },
        { id: 'msi-lvt-carrara-avell', name: 'Trecento Carrara Avell', color: '#E8E8E8', sku: 'TRECENTO-CARRARAAVELL', price: 1.75, brand: 'MSI Everlife', series: 'Trecento', warranty: 'Lifetime/10yr Comm' },
        { id: 'msi-lvt-mountains-gray', name: 'Trecento Mountains Gray', color: '#9E9E9E', sku: 'TRECENTO-MOUNTAINSGRAY', price: 1.75, brand: 'MSI Everlife', series: 'Trecento', warranty: 'Lifetime/10yr Comm' },
        // MSI Everlife LVT - Laurel Series - with CDN images
        { id: 'msi-lvt-coastal-cottage', name: 'Laurel Coastal Cottage', color: '#D4C8B8', sku: 'LAUREL-COASTALCOTTAGE', price: 1.69, brand: 'MSI Everlife', series: 'Laurel', warranty: 'Lifetime/15yr Comm' },
        { id: 'msi-lvt-honey-hollow', name: 'Laurel Honey Hollow', color: '#C4A76C', sku: 'LAUREL-HONEYHOLLOW', price: 1.69, brand: 'MSI Everlife', series: 'Laurel', warranty: 'Lifetime/15yr Comm' },
        { id: 'msi-lvt-scandi', name: 'Laurel Scandi', color: '#E8E0D8', sku: 'LAUREL-SCANDI', price: 1.69, brand: 'MSI Everlife', series: 'Laurel', warranty: 'Lifetime/15yr Comm' },
        // MSI Everlife LVT - Studio Collection (Ultra Premium) - with CDN images
        { id: 'msi-lvt-studio-bozeman', name: 'Studio Bozeman', color: '#6B5344', sku: 'STUDIO-BOZEMAN', price: 3.39, brand: 'MSI Everlife', series: 'Studio', warranty: 'Lifetime/30yr Comm' },
        { id: 'msi-lvt-studio-taos', name: 'Studio Taos', color: '#8B7355', sku: 'STUDIO-TAOS', price: 3.39, brand: 'MSI Everlife', series: 'Studio', warranty: 'Lifetime/30yr Comm' },
        { id: 'msi-lvt-studio-roswell', name: 'Studio Roswell', color: '#A08060', sku: 'STUDIO-ROSWELL', price: 3.39, brand: 'MSI Everlife', series: 'Studio', warranty: 'Lifetime/30yr Comm' },
        // MSI DryBack LVT - Katavia Series (Budget)
        { id: 'msi-dryback-katavia-bleached-elm', name: 'Katavia Bleached Elm', color: '#D4C8B8', sku: 'VTGBLEELM6X48-2MM-6MIL', price: 0.80, brand: 'MSI DryBack', series: 'Katavia', warranty: '15yr Res' },
        { id: 'msi-dryback-katavia-burnished-acacia', name: 'Katavia Burnished Acacia', color: '#8B7355', sku: 'VTGBURACA6X48-2MM-6MIL', price: 0.80, brand: 'MSI DryBack', series: 'Katavia', warranty: '15yr Res' },
        { id: 'msi-dryback-katavia-charcoal-oak', name: 'Katavia Charcoal Oak', color: '#4A4A4A', sku: 'VTGCHAOAK6X48-2MM-6MIL', price: 0.80, brand: 'MSI DryBack', series: 'Katavia', warranty: '15yr Res' },
        { id: 'msi-dryback-katavia-elmwood-ash', name: 'Katavia Elmwood Ash', color: '#9E8B7D', sku: 'VTGELMASH6X48-2MM-6MIL', price: 0.80, brand: 'MSI DryBack', series: 'Katavia', warranty: '15yr Res' },
        { id: 'msi-dryback-katavia-twilight-oak', name: 'Katavia Twilight Oak', color: '#5D4037', sku: 'VTGTWIOAK6X48-2MM-6MIL', price: 0.80, brand: 'MSI DryBack', series: 'Katavia', warranty: '15yr Res' },
        { id: 'msi-dryback-katavia-woodrift-gray', name: 'Katavia Woodrift Gray', color: '#6E6E6E', sku: 'VTGWOOGRA6X48-2MM-6MIL', price: 0.80, brand: 'MSI DryBack', series: 'Katavia', warranty: '15yr Res' },
        // MSI DryBack LVT - Glenridge Series
        { id: 'msi-dryback-glenridge-aged-hickory', name: 'Glenridge Aged Hickory', color: '#7D6B5D', sku: 'VTGAGEHIC6X48-2MM-12MIL', price: 0.89, brand: 'MSI DryBack', series: 'Glenridge', warranty: '25yr Res/6yr Comm' },
        { id: 'msi-dryback-glenridge-coastal-mix', name: 'Glenridge Coastal Mix', color: '#A8A090', sku: 'VTGCOAMIX6X48-2MM-12MIL', price: 0.89, brand: 'MSI DryBack', series: 'Glenridge', warranty: '25yr Res/6yr Comm' },
        { id: 'msi-dryback-glenridge-jatoba', name: 'Glenridge Jatoba', color: '#6B4A3A', sku: 'VTGJATOBA6X48-2MM-12MIL', price: 0.89, brand: 'MSI DryBack', series: 'Glenridge', warranty: '25yr Res/6yr Comm' },
        { id: 'msi-dryback-glenridge-midnight-maple', name: 'Glenridge Midnight Maple', color: '#3D2B1F', sku: 'VTGMIDMAP6X48-2MM-12MIL', price: 0.89, brand: 'MSI DryBack', series: 'Glenridge', warranty: '25yr Res/6yr Comm' },
        { id: 'msi-dryback-glenridge-saddle-oak', name: 'Glenridge Saddle Oak', color: '#8B7355', sku: 'VTGSADOAK6X48-2MM-12MIL', price: 0.89, brand: 'MSI DryBack', series: 'Glenridge', warranty: '25yr Res/6yr Comm' },
        { id: 'msi-dryback-glenridge-tawny-birch', name: 'Glenridge Tawny Birch', color: '#C4A878', sku: 'VTGTAWBIR6X48-2MM-12MIL', price: 0.89, brand: 'MSI DryBack', series: 'Glenridge', warranty: '25yr Res/6yr Comm' },
        // MSI DryBack LVT - Acclima Series
        { id: 'msi-dryback-acclima-ayla', name: 'Acclima Ayla', color: '#C4A76C', sku: 'VTGAYLA7X48-2MM-12MIL', price: 0.98, brand: 'MSI DryBack', series: 'Acclima', warranty: '25yr Res/6yr Comm' },
        { id: 'msi-dryback-acclima-louis-hill', name: 'Acclima Louis Hill', color: '#8B7355', sku: 'VTGLOUHIL7X48-2MM-12MIL', price: 0.98, brand: 'MSI DryBack', series: 'Acclima', warranty: '25yr Res/6yr Comm' },
        { id: 'msi-dryback-acclima-ludlow', name: 'Acclima Ludlow', color: '#7D6B5D', sku: 'VTGLUDLOW7X48-2MM-12MIL', price: 0.98, brand: 'MSI DryBack', series: 'Acclima', warranty: '25yr Res/6yr Comm' },
        { id: 'msi-dryback-acclima-waldorf', name: 'Acclima Waldorf', color: '#A08060', sku: 'VTGWALDOR7X48-2MM-12MIL', price: 0.98, brand: 'MSI DryBack', series: 'Acclima', warranty: '25yr Res/6yr Comm' },
        { id: 'msi-dryback-acclima-whitfield-gray', name: 'Acclima Whitfield Gray', color: '#8A8A8A', sku: 'VTGWHTGRA7X48-2MM-12MIL', price: 0.98, brand: 'MSI DryBack', series: 'Acclima', warranty: '25yr Res/6yr Comm' },
        // MSI DryBack LVT - Wilmont Series (20mil wear layer)
        { id: 'msi-dryback-wilmont-burnished-acacia', name: 'Wilmont Burnished Acacia', color: '#8B7355', sku: 'VTGBURACA7X48-2.5MM-20MIL', price: 1.19, brand: 'MSI DryBack', series: 'Wilmont', warranty: 'Lifetime/15yr Comm' },
        { id: 'msi-dryback-wilmont-charcoal-oak', name: 'Wilmont Charcoal Oak', color: '#4A4A4A', sku: 'VTGCHAOAK7X48-2.5MM-20MIL', price: 1.19, brand: 'MSI DryBack', series: 'Wilmont', warranty: 'Lifetime/15yr Comm' },
        { id: 'msi-dryback-wilmont-elmwood-ash', name: 'Wilmont Elmwood Ash', color: '#9E8B7D', sku: 'VTGELMASH7X48-2.5MM-20MIL', price: 1.19, brand: 'MSI DryBack', series: 'Wilmont', warranty: 'Lifetime/15yr Comm' },
        { id: 'msi-dryback-wilmont-lime-washed', name: 'Wilmont Lime Washed Oak', color: '#E8E0D8', sku: 'VTGLIMWAS7X48-2.5MM-20MIL', price: 1.19, brand: 'MSI DryBack', series: 'Wilmont', warranty: 'Lifetime/15yr Comm' },
        { id: 'msi-dryback-wilmont-twilight-oak', name: 'Wilmont Twilight Oak', color: '#5D4037', sku: 'VTGTWIOAK7X48-2.5MM-20MIL', price: 1.19, brand: 'MSI DryBack', series: 'Wilmont', warranty: 'Lifetime/15yr Comm' },
        // MSI DryBack LVT - Kallum Series (Looselay Premium)
        { id: 'msi-dryback-kallum-akadia', name: 'Kallum Akadia', color: '#A08060', sku: 'VTGAKADIA9X48-5MM-20MIL', price: 1.69, brand: 'MSI DryBack', series: 'Kallum', warranty: 'Lifetime/25yr Comm' },
        { id: 'msi-dryback-kallum-cranton', name: 'Kallum Cranton', color: '#8B7355', sku: 'VTGCRANTO9X48-5MM-20MIL', price: 1.69, brand: 'MSI DryBack', series: 'Kallum', warranty: 'Lifetime/25yr Comm' },
        { id: 'msi-dryback-kallum-fauna', name: 'Kallum Fauna', color: '#9E8B7D', sku: 'VTGFAUNA9X48-5MM-20MIL', price: 1.69, brand: 'MSI DryBack', series: 'Kallum', warranty: 'Lifetime/25yr Comm' },
        { id: 'msi-dryback-kallum-finely', name: 'Kallum Finely', color: '#6B5344', sku: 'VTGFINELY9X48-5MM-20MIL', price: 1.69, brand: 'MSI DryBack', series: 'Kallum', warranty: 'Lifetime/25yr Comm' },
        { id: 'msi-dryback-kallum-larkin', name: 'Kallum Larkin', color: '#C4A76C', sku: 'VTGLARKIN9X48-5MM-20MIL', price: 1.69, brand: 'MSI DryBack', series: 'Kallum', warranty: 'Lifetime/25yr Comm' },
        { id: 'msi-dryback-kallum-walnut-waves', name: 'Kallum Walnut Waves', color: '#5D4037', sku: 'VTGWALWAV9X48-5MM-20MIL', price: 1.69, brand: 'MSI DryBack', series: 'Kallum', warranty: 'Lifetime/25yr Comm' }
      ],
      showerPanels: [
        // Daltile LUXORA Shower Panels (CTF Price List Jan 2026)
        { id: 'luxora-calacatta-gold', name: 'LUXORA Calacatta Gold', color: '#FAF8F0', sku: 'LUX-CAL-G', price: 5.80, brand: 'Daltile' },
        { id: 'luxora-carrara', name: 'LUXORA Carrara', color: '#F5F5F5', sku: 'LUX-CAR', price: 5.20, brand: 'Daltile' },
        { id: 'luxora-bianco-statuario', name: 'LUXORA Bianco Statuario', color: '#FEFEFE', sku: 'LUX-BIA', price: 5.80, brand: 'Daltile' }
      ],
      // MSI Hardscape Products (Tier 3 Q1 2025 Pricing)
      hardscape: [
        // Travertine Pavers - with CDN images
        { id: 'msi-trav-tuscany-beige', name: 'Tuscany Beige Travertine Paver 16x24', color: '#D4C4A8', sku: 'LPATBEI1624TUMBLED', price: 4.07, brand: 'MSI', category: 'Travertine Pavers', size: '16x24' },
        { id: 'msi-trav-tuscany-beige-6x12', name: 'Tuscany Beige Travertine Paver 6x12', color: '#D4C4A8', sku: 'LPATBEI0612TUMBLED', price: 3.58, brand: 'MSI', category: 'Travertine Pavers', size: '6x12' },
        { id: 'msi-trav-tuscany-choc', name: 'Tuscany Chocolat Travertine Paver 16x24', color: '#6B5344', sku: 'LPATCHOC1624TUMBLED', price: 5.44, brand: 'MSI', category: 'Travertine Pavers', size: '16x24' },
        { id: 'msi-trav-tuscany-ivory', name: 'Tuscany Ivory Travertine Paver 16x24', color: '#F0E8E0', sku: 'LPATIVORY1624TUMBLED', price: 5.13, brand: 'MSI', category: 'Travertine Pavers', size: '16x24' },
        { id: 'msi-trav-tuscany-walnut', name: 'Tuscany Walnut Travertine Paver 16x24', color: '#8B7355', sku: 'LPATWALNUT1624TUMBLED', price: 4.91, brand: 'MSI', category: 'Travertine Pavers', size: '16x24' },
        // Pool Coping - with CDN images
        { id: 'msi-coping-tuscany-beige', name: 'Tuscany Beige Pool Coping 4x12', color: '#D4C4A8', sku: 'LCOPATBEI412TUMBLED', price: 9.45, brand: 'MSI', category: 'Pool Coping', size: '4x12' },
        { id: 'msi-coping-tuscany-ivory', name: 'Tuscany Ivory Pool Coping 4x12', color: '#F0E8E0', sku: 'LCOPATIVORY412TUMBLED', price: 9.81, brand: 'MSI', category: 'Pool Coping', size: '4x12' },
        { id: 'msi-coping-tuscany-walnut', name: 'Tuscany Walnut Pool Coping 4x12', color: '#8B7355', sku: 'LCOPATWALNUT412TUMBLED', price: 11.03, brand: 'MSI', category: 'Pool Coping', size: '4x12' },
        // Porcelain Pavers - Arterra Collection - with CDN images
        { id: 'msi-arterra-beton-gray', name: 'Arterra Beton Gray 24x24', color: '#9E9E9E', sku: 'LPARTBETGRY2424', price: 5.98, brand: 'MSI', category: 'Porcelain Pavers', size: '24x24' },
        { id: 'msi-arterra-legions-aspen', name: 'Arterra Legions Aspen Ash 24x24', color: '#A08060', sku: 'LPARTLEGASP2424', price: 6.98, brand: 'MSI', category: 'Porcelain Pavers', size: '24x24' },
        { id: 'msi-arterra-praia-grey', name: 'Arterra Praia Grey 24x24', color: '#7A7A7A', sku: 'LPARTPRAIAGRY2424', price: 5.98, brand: 'MSI', category: 'Porcelain Pavers', size: '24x24' },
        { id: 'msi-arterra-tierra-sol', name: 'Arterra Tierra Sol Beige 24x24', color: '#C4A878', sku: 'LPARTTIERBEI2424', price: 5.98, brand: 'MSI', category: 'Porcelain Pavers', size: '24x24' },
        // Stacked Stone - with CDN images
        { id: 'msi-stack-arctic-white', name: 'Arctic White Stacked Stone', color: '#F5F5F5', sku: 'LSLEDARCWHT', price: 10.98, brand: 'MSI', category: 'Stacked Stone', size: '6x24' },
        { id: 'msi-stack-charcoal', name: 'Charcoal Stacked Stone', color: '#4A4A4A', sku: 'LSLEDCHAR', price: 9.98, brand: 'MSI', category: 'Stacked Stone', size: '6x24' },
        { id: 'msi-stack-golden-honey', name: 'Golden Honey Stacked Stone', color: '#C4A76C', sku: 'LSLEDGLDHNY', price: 9.98, brand: 'MSI', category: 'Stacked Stone', size: '6x24' },
        { id: 'msi-stack-white-oak', name: 'White Oak Stacked Stone', color: '#E8E4DC', sku: 'LSLEDWHTOAK', price: 11.98, brand: 'MSI', category: 'Stacked Stone', size: '6x24' },
        // Decomposed Granite & Aggregates
        { id: 'msi-dg-pathway', name: 'Decomposed Granite Pathway', color: '#C4A878', sku: 'DG-PATHWAY', price: 89.00, brand: 'MSI', category: 'Aggregates', unit: 'per yard' },
        // Pebbles (40lb bags)
        { id: 'msi-pebble-amazon-multi', name: 'Amazon Multi Pebbles', color: '#8B7355', sku: 'LPEBQAMZMUL3NAT40', price: 14.50, brand: 'MSI', category: 'Pebbles', unit: 'per 40lb bag' },
        { id: 'msi-pebble-black', name: 'Black Polished Pebbles', color: '#1A1A1A', sku: 'LPEBQBLK3POL40', price: 14.50, brand: 'MSI', category: 'Pebbles', unit: 'per 40lb bag' },
        { id: 'msi-pebble-white', name: 'White Polished Pebbles', color: '#F5F5F5', sku: 'LPEBMWHI3POL40', price: 14.50, brand: 'MSI', category: 'Pebbles', unit: 'per 40lb bag' },
        { id: 'msi-pebble-mixed', name: 'Mixed Polished Pebbles', color: '#9E8B7D', sku: 'LPEBMMIX3POL40', price: 14.50, brand: 'MSI', category: 'Pebbles', unit: 'per 40lb bag' },
        { id: 'msi-pebble-nile-gray', name: 'Nile Gray Pebbles', color: '#7A7A7A', sku: 'LPEBQNILGRY3NAT40', price: 14.50, brand: 'MSI', category: 'Pebbles', unit: 'per 40lb bag' },
        { id: 'msi-pebble-himalaya-white', name: 'Himalaya White Pebbles', color: '#FAFAFA', sku: 'LPEBMHIMWHI3NAT40', price: 14.50, brand: 'MSI', category: 'Pebbles', unit: 'per 40lb bag' },
        // Fire Glass (20lb bags)
        { id: 'msi-fireglass-galaxy-black', name: 'Fire Glass Galaxy Black', color: '#0A0A0A', sku: 'LFIRGGALBLK0.5CRU20', price: 21.00, brand: 'MSI', category: 'Fire Glass', unit: 'per 20lb bag' },
        { id: 'msi-fireglass-aqua-blue', name: 'Fire Glass Aqua Blue', color: '#00CED1', sku: 'LFIRGAQUBLU0.25CRU20', price: 21.00, brand: 'MSI', category: 'Fire Glass', unit: 'per 20lb bag' },
        { id: 'msi-fireglass-sapphire-blue', name: 'Fire Glass Sapphire Blue', color: '#0F52BA', sku: 'LFIRGSAPBLU0.5CRU20', price: 21.00, brand: 'MSI', category: 'Fire Glass', unit: 'per 20lb bag' },
        { id: 'msi-fireglass-marine-blue', name: 'Fire Glass Marine Blue', color: '#4169E1', sku: 'LFIRGMARBLU0.5CRU20', price: 21.00, brand: 'MSI', category: 'Fire Glass', unit: 'per 20lb bag' },
        { id: 'msi-fireglass-copper-brown', name: 'Fire Glass Copper Brown', color: '#B87333', sku: 'LFIRGCOPBRO0.5CRU20', price: 21.00, brand: 'MSI', category: 'Fire Glass', unit: 'per 20lb bag' },
        { id: 'msi-fireglass-glacial-silver', name: 'Fire Glass Glacial Silver', color: '#C0C0C0', sku: 'LFIRGGLASIL0.5CRU20', price: 21.00, brand: 'MSI', category: 'Fire Glass', unit: 'per 20lb bag' }
      ],
      // MSI Vanity Collections (2024 Flyer)
      vanities: [
        // RTA Vanities - Ready-To-Assemble Collection
        { id: 'msi-rta-v2721-white', name: 'RTA Vanity 27x21 White', color: '#FFFFFF', sku: 'VANHDR-V2721-WHT', brand: 'MSI', collection: 'RTA', width: 27, features: 'Plywood, Soft-close doors' },
        { id: 'msi-rta-v3021-white', name: 'RTA Vanity 30x21 White', color: '#FFFFFF', sku: 'VANHDR-V3021-WHT', brand: 'MSI', collection: 'RTA', width: 30, features: 'Plywood, Soft-close doors' },
        { id: 'msi-rta-v3621-white', name: 'RTA Vanity 36x21 White', color: '#FFFFFF', sku: 'VANHDR-V3621-WHT', brand: 'MSI', collection: 'RTA', width: 36, features: 'Plywood, Soft-close doors' },
        { id: 'msi-rta-v4821-white', name: 'RTA Vanity 48x21 Single Bowl White', color: '#FFFFFF', sku: 'VANHDR-V4821SB-FLSW-2H', brand: 'MSI', collection: 'RTA', width: 48, features: '4 doors, 2 drawers, Plywood' },
        { id: 'msi-rta-v6021-white', name: 'RTA Vanity 60x21 Double Bowl White', color: '#FFFFFF', sku: 'VANHDR-V6021DB-FLSW-2H', brand: 'MSI', collection: 'RTA', width: 60, features: '4 doors, 2 tilted drawers, Plywood' },
        { id: 'msi-rta-vdb15-white', name: 'RTA Drawer Vanity 15" White', color: '#FFFFFF', sku: 'VDB15-3', brand: 'MSI', collection: 'RTA', width: 15, features: '3-Drawer, Plywood' },
        { id: 'msi-rta-vdb21-white', name: 'RTA Drawer Vanity 21" White', color: '#FFFFFF', sku: 'VDB21-3', brand: 'MSI', collection: 'RTA', width: 21, features: '3-Drawer, Plywood' },
        // RTA Vanities - Grey Color
        { id: 'msi-rta-v3021-grey', name: 'RTA Vanity 30x21 Grey', color: '#7A7A7A', sku: 'VANHDR-V3021-GRY', brand: 'MSI', collection: 'RTA', width: 30, features: 'Plywood, Soft-close doors' },
        { id: 'msi-rta-v3621-grey', name: 'RTA Vanity 36x21 Grey', color: '#7A7A7A', sku: 'VANHDR-V3621-GRY', brand: 'MSI', collection: 'RTA', width: 36, features: 'Plywood, Soft-close doors' },
        { id: 'msi-rta-v4821-grey', name: 'RTA Vanity 48x21 Grey', color: '#7A7A7A', sku: 'VANHDR-V4821SB-GRY', brand: 'MSI', collection: 'RTA', width: 48, features: '4 doors, 2 drawers, Plywood' },
        // RTA Vanities - Blue Color
        { id: 'msi-rta-v3021-blue', name: 'RTA Vanity 30x21 Blue', color: '#4A6B8C', sku: 'VANHDR-V3021-BLU', brand: 'MSI', collection: 'RTA', width: 30, features: 'Plywood, Soft-close doors' },
        { id: 'msi-rta-v3621-blue', name: 'RTA Vanity 36x21 Blue', color: '#4A6B8C', sku: 'VANHDR-V3621-BLU', brand: 'MSI', collection: 'RTA', width: 36, features: 'Plywood, Soft-close doors' },
        // RTA Vanities - Black Color
        { id: 'msi-rta-v3021-black', name: 'RTA Vanity 30x21 Black', color: '#1A1A1A', sku: 'VANHDR-V3021-BLK', brand: 'MSI', collection: 'RTA', width: 30, features: 'Plywood, Soft-close doors' },
        { id: 'msi-rta-v3621-black', name: 'RTA Vanity 36x21 Black', color: '#1A1A1A', sku: 'VANHDR-V3621-BLK', brand: 'MSI', collection: 'RTA', width: 36, features: 'Plywood, Soft-close doors' },
        // RTA Vanities - Natural Oak
        { id: 'msi-rta-v3021-oak', name: 'RTA Vanity 30x21 Natural Oak', color: '#C4A76C', sku: 'VANHDR-V3021-OAK', brand: 'MSI', collection: 'RTA', width: 30, features: 'Wood veneer, Soft-close doors' },
        { id: 'msi-rta-v3621-oak', name: 'RTA Vanity 36x21 Natural Oak', color: '#C4A76C', sku: 'VANHDR-V3621-OAK', brand: 'MSI', collection: 'RTA', width: 36, features: 'Wood veneer, Soft-close doors' },
        // Fluted Vanities - Pre-Assembled Collection
        { id: 'msi-fluted-v3021', name: 'Fluted Vanity 30x21', color: '#DEB887', sku: 'VANFLT-V3021', brand: 'MSI', collection: 'Fluted', width: 30, features: 'Solid wood, Wood veneer, Pre-assembled' },
        { id: 'msi-fluted-v3621', name: 'Fluted Vanity 36x21', color: '#DEB887', sku: 'VANFLT-V3621', brand: 'MSI', collection: 'Fluted', width: 36, features: 'Solid wood, 3 drawers, Pre-assembled' },
        { id: 'msi-fluted-v3021-tilt', name: 'Fluted Vanity 30x21 w/Tilt Drawer', color: '#DEB887', sku: 'VANFLT-V3021-TILT', brand: 'MSI', collection: 'Fluted', width: 30, features: 'Solid wood, Tilted drawer, Pre-assembled' },
        { id: 'msi-fluted-v3621-tilt', name: 'Fluted Vanity 36x21 w/Tilt Drawer', color: '#DEB887', sku: 'VANFLT-V3621-TILT', brand: 'MSI', collection: 'Fluted', width: 36, features: 'Solid wood, 2 tilted drawers, Pre-assembled' },
        // Folding Vanities - Easy Assembly Collection
        { id: 'msi-fold-v2421', name: 'Folding Vanity 24x21', color: '#FFFFFF', sku: 'VANFOLD-V2421', brand: 'MSI', collection: 'Folding', width: 24, features: 'Solid wood frame, Plywood box, Easy assembly' },
        { id: 'msi-fold-v3021', name: 'Folding Vanity 30x21', color: '#FFFFFF', sku: 'VANFOLD-V3021', brand: 'MSI', collection: 'Folding', width: 30, features: 'Solid wood frame, Plywood box, Easy assembly' },
        { id: 'msi-fold-v3621', name: 'Folding Vanity 36x21', color: '#FFFFFF', sku: 'VANFOLD-V3621', brand: 'MSI', collection: 'Folding', width: 36, features: 'Solid wood frame, Plywood box, Easy assembly' },
        { id: 'msi-fold-v4221', name: 'Folding Vanity 42x21', color: '#FFFFFF', sku: 'VANFOLD-V4221', brand: 'MSI', collection: 'Folding', width: 42, features: 'Solid wood frame, Plywood box, Easy assembly' },
        { id: 'msi-fold-v4821', name: 'Folding Vanity 48x21', color: '#FFFFFF', sku: 'VANFOLD-V4821', brand: 'MSI', collection: 'Folding', width: 48, features: 'Solid wood frame, Plywood box, Easy assembly' },
        { id: 'msi-fold-v6021', name: 'Folding Vanity 60x21', color: '#FFFFFF', sku: 'VANFOLD-V6021', brand: 'MSI', collection: 'Folding', width: 60, features: 'Solid wood frame, Plywood box, Easy assembly' }
      ],
      // MSI Flooring Trim & Accessories
      flooringTrims: [
        { id: 'msi-trim-stairtread', name: 'Stair Tread (Eased Edge)', color: '#8B7355', sku: 'STAIR-TREAD', price: 37.00, brand: 'MSI', size: '47.25" x 12"', unit: 'each' },
        { id: 'msi-trim-stairnose-flush', name: 'Stair Nose (Flush)', color: '#8B7355', sku: 'STAIRNOSE-FLUSH', price: 32.00, brand: 'MSI', size: '94"', unit: 'each' },
        { id: 'msi-trim-stairnose-overlap', name: 'Stair Nose (Overlapping)', color: '#8B7355', sku: 'STAIRNOSE-OVERLAP', price: 27.00, brand: 'MSI', size: '94"', unit: 'each' },
        { id: 'msi-trim-endcap', name: 'End Cap', color: '#8B7355', sku: 'ENDCAP', price: 27.00, brand: 'MSI', size: '94"', unit: 'each' },
        { id: 'msi-trim-reducer', name: 'Surface Reducer', color: '#8B7355', sku: 'REDUCER', price: 22.00, brand: 'MSI', size: '94"', unit: 'each' },
        { id: 'msi-trim-tmolding', name: 'T-Molding', color: '#8B7355', sku: 'TMOLDING', price: 27.00, brand: 'MSI', size: '94"', unit: 'each' },
        { id: 'msi-trim-quarterround', name: 'Quarter Round', color: '#8B7355', sku: 'QUARTERROUND', price: 20.00, brand: 'MSI', size: '94"', unit: 'each' }
      ],
      // Cabinet Accessories
      cabinetAccessories: [
        { id: 'msi-acc-basepanel', name: 'Base Panel 36x96', color: '#F5F5F5', sku: 'BP3696', price: 59.39, brand: 'MSI' },
        { id: 'msi-acc-dishwasher-return', name: 'Dishwasher Return Panel', color: '#F5F5F5', sku: 'DWR3', price: 26.35, brand: 'MSI' },
        { id: 'msi-acc-basefiller', name: 'Base Filler 3x30', color: '#F5F5F5', sku: 'F330', price: 12.73, brand: 'MSI' },
        { id: 'msi-acc-scribemolding', name: 'Scribe Molding 96"', color: '#F5F5F5', sku: 'SM8', price: 6.43, brand: 'MSI' },
        { id: 'msi-acc-tallendpanel', name: 'Tall End Panel 30x96', color: '#F5F5F5', sku: 'TEP3096', price: 170.32, brand: 'MSI' },
        { id: 'msi-acc-toekick', name: 'Toe Kick 96"', color: '#F5F5F5', sku: 'TK8', price: 8.88, brand: 'MSI' },
        { id: 'msi-acc-wallfiller36', name: 'Wall Filler 3x36', color: '#F5F5F5', sku: 'WF336', price: 27.19, brand: 'MSI' },
        { id: 'msi-acc-wallfiller42', name: 'Wall Filler 3x42', color: '#F5F5F5', sku: 'WF342', price: 31.58, brand: 'MSI' },
        { id: 'msi-acc-wallfiller96', name: 'Wall Filler 3x96', color: '#F5F5F5', sku: 'WF396', price: 41.64, brand: 'MSI' }
      ]
    };

    // Price tier helper for materials
    const PRICE_TIERS = {
      budget: { min: 0, max: 12.60, label: 'Budget-Friendly', color: '#10b981' },
      popular: { min: 12.60, max: 25.90, label: 'Popular Choice', color: '#f59e0b' },
      premium: { min: 25.90, max: 100, label: 'Premium', color: '#8b5cf6' }
    };

    function getMaterialPriceTier(price) {
      if (!price) return null;
      if (price <= PRICE_TIERS.budget.max) return 'budget';
      if (price <= PRICE_TIERS.popular.max) return 'popular';
      return 'premium';
    }

    // Helper to proxy external CDN URLs for CORS (using images.weserv.nl)
    function getProxiedUrl(url) {
      if (!url) return url;
      if (url.includes('cdn.msisurfaces.com')) {
        // Use images.weserv.nl as image proxy - it adds CORS headers
        return `https://images.weserv.nl/?url=${url.replace('https://', '')}`;
      }
      return url;
    }

    // Cabinet Catalogs from Manufacturers
    const CABINET_CATALOGS = {
      procraft: {
        name: 'ProCraft Cabinetry',
        logo: '/images/6456ce4476abb265e5fbb1f1_62708265be16bc2ec3e69111_procraft-cabinetry-p-500.png',
        series: {
          'shaker-white': { name: 'Shaker White', color: '#f5f5f5' },
          'shaker-grey': { name: 'Shaker Grey', color: '#7a7a7a' },
          'shaker-espresso': { name: 'Shaker Espresso', color: '#3d2b1f' }
        },
        cabinets: {
          base: [
            { sku: 'B09', name: 'Base 9"', width: 0.75, height: 2, depth: 2, type: 'base-cabinet' },
            { sku: 'B12', name: 'Base 12"', width: 1, height: 2, depth: 2, type: 'base-cabinet' },
            { sku: 'B15', name: 'Base 15"', width: 1.25, height: 2, depth: 2, type: 'base-cabinet' },
            { sku: 'B18', name: 'Base 18"', width: 1.5, height: 2, depth: 2, type: 'base-cabinet' },
            { sku: 'B21', name: 'Base 21"', width: 1.75, height: 2, depth: 2, type: 'base-cabinet' },
            { sku: 'B24', name: 'Base 24"', width: 2, height: 2, depth: 2, type: 'base-cabinet' },
            { sku: 'B27', name: 'Base 27"', width: 2.25, height: 2, depth: 2, type: 'base-cabinet' },
            { sku: 'B30', name: 'Base 30"', width: 2.5, height: 2, depth: 2, type: 'base-cabinet' },
            { sku: 'B33', name: 'Base 33"', width: 2.75, height: 2, depth: 2, type: 'base-cabinet' },
            { sku: 'B36', name: 'Base 36"', width: 3, height: 2, depth: 2, type: 'base-cabinet' },
            { sku: 'B42', name: 'Base 42"', width: 3.5, height: 2, depth: 2, type: 'base-cabinet' },
            { sku: 'B48', name: 'Base 48"', width: 4, height: 2, depth: 2, type: 'base-cabinet' }
          ],
          wall: [
            { sku: 'W0930', name: 'Wall 9"x30"', width: 0.75, height: 1.25, depth: 2.5, type: 'wall-cabinet' },
            { sku: 'W1230', name: 'Wall 12"x30"', width: 1, height: 1.25, depth: 2.5, type: 'wall-cabinet' },
            { sku: 'W1530', name: 'Wall 15"x30"', width: 1.25, height: 1.25, depth: 2.5, type: 'wall-cabinet' },
            { sku: 'W1830', name: 'Wall 18"x30"', width: 1.5, height: 1.25, depth: 2.5, type: 'wall-cabinet' },
            { sku: 'W2130', name: 'Wall 21"x30"', width: 1.75, height: 1.25, depth: 2.5, type: 'wall-cabinet' },
            { sku: 'W2430', name: 'Wall 24"x30"', width: 2, height: 1.25, depth: 2.5, type: 'wall-cabinet' },
            { sku: 'W3030', name: 'Wall 30"x30"', width: 2.5, height: 1.25, depth: 2.5, type: 'wall-cabinet' },
            { sku: 'W3630', name: 'Wall 36"x30"', width: 3, height: 1.25, depth: 2.5, type: 'wall-cabinet' },
            { sku: 'W0936', name: 'Wall 9"x36"', width: 0.75, height: 1.25, depth: 3, type: 'wall-cabinet' },
            { sku: 'W1236', name: 'Wall 12"x36"', width: 1, height: 1.25, depth: 3, type: 'wall-cabinet' },
            { sku: 'W1536', name: 'Wall 15"x36"', width: 1.25, height: 1.25, depth: 3, type: 'wall-cabinet' },
            { sku: 'W1836', name: 'Wall 18"x36"', width: 1.5, height: 1.25, depth: 3, type: 'wall-cabinet' },
            { sku: 'W2436', name: 'Wall 24"x36"', width: 2, height: 1.25, depth: 3, type: 'wall-cabinet' },
            { sku: 'W3036', name: 'Wall 30"x36"', width: 2.5, height: 1.25, depth: 3, type: 'wall-cabinet' },
            { sku: 'W3636', name: 'Wall 36"x36"', width: 3, height: 1.25, depth: 3, type: 'wall-cabinet' },
            { sku: 'W0942', name: 'Wall 9"x42"', width: 0.75, height: 1.25, depth: 3.5, type: 'wall-cabinet' },
            { sku: 'W1242', name: 'Wall 12"x42"', width: 1, height: 1.25, depth: 3.5, type: 'wall-cabinet' },
            { sku: 'W1842', name: 'Wall 18"x42"', width: 1.5, height: 1.25, depth: 3.5, type: 'wall-cabinet' },
            { sku: 'W2442', name: 'Wall 24"x42"', width: 2, height: 1.25, depth: 3.5, type: 'wall-cabinet' },
            { sku: 'W3042', name: 'Wall 30"x42"', width: 2.5, height: 1.25, depth: 3.5, type: 'wall-cabinet' },
            { sku: 'W3642', name: 'Wall 36"x42"', width: 3, height: 1.25, depth: 3.5, type: 'wall-cabinet' }
          ],
          tall: [
            { sku: 'T189024', name: 'Pantry 18"x90"', width: 1.5, height: 2, depth: 7.5, type: 'tall-cabinet' },
            { sku: 'T249024', name: 'Pantry 24"x90"', width: 2, height: 2, depth: 7.5, type: 'tall-cabinet' },
            { sku: 'T309024', name: 'Pantry 30"x90"', width: 2.5, height: 2, depth: 7.5, type: 'tall-cabinet' },
            { sku: 'T369024', name: 'Pantry 36"x90"', width: 3, height: 2, depth: 7.5, type: 'tall-cabinet' },
            { sku: 'OC3390', name: 'Oven Cabinet 33"x90"', width: 2.75, height: 2, depth: 7.5, type: 'tall-cabinet' },
            { sku: 'OC3396', name: 'Oven Cabinet 33"x96"', width: 2.75, height: 2, depth: 8, type: 'tall-cabinet' }
          ],
          corner: [
            { sku: 'BLS36', name: 'Lazy Susan Base 36"', width: 3, height: 3, depth: 2, type: 'corner-cabinet' },
            { sku: 'DERA36', name: 'Diagonal Corner 36"', width: 3, height: 3, depth: 2, type: 'corner-cabinet' },
            { sku: 'WDC2430', name: 'Diagonal Wall 24"x30"', width: 2, height: 2, depth: 2.5, type: 'corner-cabinet' },
            { sku: 'WDC2436', name: 'Diagonal Wall 24"x36"', width: 2, height: 2, depth: 3, type: 'corner-cabinet' },
            { sku: 'WDC2442', name: 'Diagonal Wall 24"x42"', width: 2, height: 2, depth: 3.5, type: 'corner-cabinet' }
          ],
          sink: [
            { sku: 'SB30', name: 'Sink Base 30"', width: 2.5, height: 2, depth: 2, type: 'base-cabinet' },
            { sku: 'SB33', name: 'Sink Base 33"', width: 2.75, height: 2, depth: 2, type: 'base-cabinet' },
            { sku: 'SB36', name: 'Sink Base 36"', width: 3, height: 2, depth: 2, type: 'base-cabinet' },
            { sku: 'SB42', name: 'Sink Base 42"', width: 3.5, height: 2, depth: 2, type: 'base-cabinet' }
          ],
          drawer: [
            { sku: 'DB12', name: 'Drawer Base 12"', width: 1, height: 2, depth: 2, type: 'base-cabinet' },
            { sku: 'DB15', name: 'Drawer Base 15"', width: 1.25, height: 2, depth: 2, type: 'base-cabinet' },
            { sku: 'DB18', name: 'Drawer Base 18"', width: 1.5, height: 2, depth: 2, type: 'base-cabinet' },
            { sku: 'DB24', name: 'Drawer Base 24"', width: 2, height: 2, depth: 2, type: 'base-cabinet' },
            { sku: 'DB30', name: 'Drawer Base 30"', width: 2.5, height: 2, depth: 2, type: 'base-cabinet' },
            { sku: 'DB36', name: 'Drawer Base 36"', width: 3, height: 2, depth: 2, type: 'base-cabinet' }
          ]
        }
      },
      custom: {
        name: 'Custom Cabinets',
        logo: null,
        series: {},
        cabinets: {
          imported: [] // User-uploaded cabinet list
        }
      }
    };

    let currentCatalog = 'procraft';
    let currentCabinetCategory = 'base';
    let currentCabinetSeries = 'shaker-white';

    // ===== STATE =====
    let canvas, ctx;
    let currentTool = 'select';
    let currentView = '2d';
    let zoom = 1;
    let pixelsPerFoot = 40;
    let elements = [];
    let walls = [];
    let selectedElement = null;
    let isDragging = false;
    let dragOffset = { x: 0, y: 0 };

    // Resize state
    let isResizing = false;
    let resizeHandle = null; // 'nw', 'n', 'ne', 'e', 'se', 's', 'sw', 'w'
    let resizeStart = { x: 0, y: 0, width: 0, height: 0, elX: 0, elY: 0 };
    const HANDLE_SIZE = 10;

    let roomWidth = 20;
    let roomDepth = 16;
    let currentFloorPlan = 'empty';
    let contextMenuElement = null;
    let elementTextures = {}; // Store custom textures for element types
    let customMaterials = []; // User uploaded materials

    // Pan offset (for infinite canvas navigation)
    let panX = 0;
    let panY = 0;
    let isPanning = false;
    let panStart = { x: 0, y: 0 };

    // Wall drawing
    let isDrawingWall = false;
    let wallStart = null;

    // Countertop drawing
    let isDrawingCountertop = false;
    let countertopStart = null;

    // Cabinet Settings State
    let cabinetSettings = {
      construction: 'frameless', // 'frameless' or 'framed'
      doorStyle: 'shaker',       // 'shaker', 'flat', 'raised', 'slab'
      doorOverlay: 'full',       // 'full', 'partial', 'inset'
      currentFloor: 1,
      floors: [{ id: 1, name: 'Floor 1', height: 0 }]
    };

    // Environment/Scene settings
    let sceneSettings = {
      timeOfDay: 'noon', // 'morning', 'noon', 'evening', 'night'
      showOutdoorView: true
    };

    // Outdoor view colors based on time of day
    const OUTDOOR_COLORS = {
      morning: { sky: 0xFDB813, horizon: 0xFFE4B5, ambient: 0xFFF8DC },
      noon: { sky: 0x87CEEB, horizon: 0xE0F7FA, ambient: 0xFFFFFF },
      evening: { sky: 0xFFA07A, horizon: 0xFFDAB9, ambient: 0xFFE4C4 },
      night: { sky: 0x191970, horizon: 0x2F4F4F, ambient: 0x404040 }
    };

    // Three.js
    let scene, camera, renderer, controls;
    let animationId = null; // Track animation frame to prevent duplicates

    // ===== INITIALIZATION =====
    document.addEventListener('DOMContentLoaded', init);

    // Undo/Redo state
    let undoStack = [];
    let redoStack = [];
    const MAX_UNDO_STATES = 50;

    // Track if we're waiting for login to continue
    let pendingAuthInit = false;
    let workspaceInitialized = false;

    async function init() {
      // Check if viewing a shared design (allow without login)
      const urlParams = new URLSearchParams(window.location.search);
      const shareToken = urlParams.get('share') || urlParams.get('p');

      // Check if this is an OAuth callback (has hash with access_token)
      const hashParams = new URLSearchParams(window.location.hash.substring(1));
      const isOAuthCallback = hashParams.has('access_token') || hashParams.has('error');

      const supabase = getSupabaseClient();

      if (isOAuthCallback) {
        // Wait for Supabase to process the OAuth callback
        // Clear the hash from URL for cleaner look
        history.replaceState(null, '', window.location.pathname + window.location.search);

        // Give Supabase a moment to process the tokens
        await new Promise(resolve => setTimeout(resolve, 500));

        // Check session after OAuth processing
        const { data: { session } } = await supabase.auth.getSession();
        if (session) {
          initializeWorkspace();
          return;
        }
      }

      // If NOT a shared design, check authentication
      if (!shareToken) {
        const { data: { session } } = await supabase.auth.getSession();

        if (!session) {
          // Not logged in - show login prompt instead of redirecting
          pendingAuthInit = true;
          hidePreloader();
          showLoginPromptRequired();

          // Listen for auth state changes (for when user logs in)
          supabase.auth.onAuthStateChange((event, session) => {
            if (event === 'SIGNED_IN' && session && !workspaceInitialized) {
              pendingAuthInit = false;
              // Force close login modal (remove required attribute first)
              const loginModal = document.getElementById('loginModal');
              loginModal.removeAttribute('data-required');
              loginModal.classList.remove('active');
              initializeWorkspace();
            }
          });
          return;
        }
      }

      // Continue with normal initialization
      initializeWorkspace();
    }

    // Initialize the workspace (called after auth check passes)
    function initializeWorkspace() {
      if (workspaceInitialized) return; // Prevent double initialization
      workspaceInitialized = true;

      canvas = document.getElementById('canvas');
      ctx = canvas.getContext('2d');

      renderSidebar();
      renderFloorPlans();
      renderMaterials('granite');
      renderCabinetCatalog();
      setupEventListeners();
      setupDragDrop();
      fitToScreen();

      // Check for shared design URL
      checkSharedDesignUrl();

      // Save initial state
      saveUndoState();

      // Keyboard shortcuts for undo/redo
      document.addEventListener('keydown', (e) => {
        if ((e.ctrlKey || e.metaKey) && e.key === 'z') {
          e.preventDefault();
          if (e.shiftKey) {
            redo();
          } else {
            undo();
          }
        }
        if ((e.ctrlKey || e.metaKey) && e.key === 'y') {
          e.preventDefault();
          redo();
        }
      });
    }

    // ===== UNDO/REDO =====
    function saveUndoState() {
      // Clone current state
      const state = {
        elements: JSON.parse(JSON.stringify(elements.map(el => ({
          ...el,
          textureImg: el.textureImg ? el.textureImg.src : null
        })))),
        walls: JSON.parse(JSON.stringify(walls)),
        roomWidth: roomWidth,
        roomDepth: roomDepth
      };

      undoStack.push(state);

      // Limit stack size
      if (undoStack.length > MAX_UNDO_STATES) {
        undoStack.shift();
      }

      // Clear redo stack on new action
      redoStack = [];

      updateUndoButtons();
    }

    function undo() {
      if (undoStack.length <= 1) return; // Keep at least one state

      // Save current to redo
      const currentState = undoStack.pop();
      redoStack.push(currentState);

      // Restore previous state
      const prevState = undoStack[undoStack.length - 1];
      restoreState(prevState);

      updateUndoButtons();
    }

    function redo() {
      if (redoStack.length === 0) return;

      const state = redoStack.pop();
      undoStack.push(state);
      restoreState(state);

      updateUndoButtons();
    }

    function restoreState(state) {
      elements = state.elements.map(el => {
        const restored = { ...el };
        // Reload texture if it had one
        if (el.textureImg) {
          const img = new Image();
          img.crossOrigin = 'anonymous';
          img.onload = () => {
            restored.textureImg = img;
            draw();
          };
          img.src = el.textureImg;
          restored.textureImg = null; // Will be set when loaded
        }
        return restored;
      });
      walls = state.walls;
      roomWidth = state.roomWidth;
      roomDepth = state.roomDepth;

      selectedElement = null;
      updateProperties();
      calculateQuote();
      draw();
    }

    function updateUndoButtons() {
      const undoBtn = document.getElementById('undoBtn');
      const redoBtn = document.getElementById('redoBtn');

      if (undoBtn) {
        undoBtn.disabled = undoStack.length <= 1;
        undoBtn.title = `Undo (${undoStack.length - 1} steps)`;
      }
      if (redoBtn) {
        redoBtn.disabled = redoStack.length === 0;
        redoBtn.title = `Redo (${redoStack.length} steps)`;
      }
    }

    function resetCanvas() {
      if (!confirm('Reset the entire design? This cannot be undone.')) return;

      elements = [];
      walls = [];
      selectedElement = null;
      undoStack = [];
      redoStack = [];

      updateProperties();
      calculateQuote();
      saveUndoState();
      draw();
    }

    function renderSidebar() {
      // Render element grids with SVG icons
      ['cabinets', 'surfaces', 'appliances', 'structure'].forEach(category => {
        const grid = document.getElementById(category + 'Grid');
        if (!grid) return;

        grid.innerHTML = ELEMENT_TYPES[category].map(el => {
          // Get the SVG icon for this element type
          const svgIcon = ELEMENT_ICONS[el.type];

          // Build icon content - prefer SVG, fallback to color
          let iconContent;
          if (elementTextures[el.type]) {
            // Custom uploaded texture
            iconContent = `<div class="element-icon" style="background-image: url(${elementTextures[el.type]}); background-size: cover; background-position: center;"></div>`;
          } else if (svgIcon) {
            // SVG icon from ELEMENT_ICONS
            iconContent = `<div class="element-icon element-svg">${svgIcon}</div>`;
          } else {
            // Color fallback
            iconContent = `<div class="element-icon" style="background: ${el.color};"></div>`;
          }

          return `
            <div class="element-item ${elementTextures[el.type] ? 'has-texture' : ''}"
                 draggable="true"
                 data-type="${el.type}"
                 data-category="${category}">
              ${iconContent}
              <div class="element-name">${el.label}</div>
              <div class="element-upload-btn" onclick="event.stopPropagation(); uploadElementTexture('${el.type}')" title="Upload custom texture">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                  <polyline points="17 8 12 3 7 8"/>
                  <line x1="12" y1="3" x2="12" y2="15"/>
                </svg>
              </div>
            </div>
          `;
        }).join('');
      });
    }

    function renderFloorPlans() {
      const grid = document.getElementById('floorplanGrid');
      grid.innerHTML = FLOOR_PLANS.map(fp => `
        <div class="floorplan-item ${currentFloorPlan === fp.id ? 'active' : ''}"
             onclick="selectFloorPlan('${fp.id}')">
          <div class="floorplan-preview">
            ${getFloorPlanSVG(fp)}
          </div>
          <div class="floorplan-name">${fp.name}</div>
        </div>
      `).join('');
    }

    function getFloorPlanSVG(fp) {
      if (fp.id === 'empty') {
        return `<svg viewBox="0 0 40 30"><rect x="2" y="2" width="36" height="26" fill="none" stroke="#666" stroke-width="1" stroke-dasharray="2"/></svg>`;
      }
      if (fp.id === 'square') {
        return `<svg viewBox="0 0 40 30"><rect x="2" y="2" width="36" height="26" fill="#333" stroke="#666" stroke-width="1"/></svg>`;
      }
      if (fp.id === 'l-shape') {
        return `<svg viewBox="0 0 40 30"><path d="M2 2 H26 V15 H15 V28 H2 Z" fill="#333" stroke="#666" stroke-width="1"/></svg>`;
      }
      if (fp.id === 'u-shape') {
        return `<svg viewBox="0 0 40 30"><path d="M2 2 H12 V20 H28 V2 H38 V28 H2 Z" fill="#333" stroke="#666" stroke-width="1"/></svg>`;
      }
      if (fp.id === 'galley') {
        return `<svg viewBox="0 0 40 30"><rect x="2" y="2" width="8" height="26" fill="#333" stroke="#666"/><rect x="30" y="2" width="8" height="26" fill="#333" stroke="#666"/></svg>`;
      }
      if (fp.id === 'open') {
        return `<svg viewBox="0 0 40 30"><rect x="2" y="2" width="36" height="26" fill="none" stroke="#666" stroke-dasharray="2"/><rect x="2" y="18" width="16" height="10" fill="#333" stroke="#666"/></svg>`;
      }
      return `<svg viewBox="0 0 40 30"><rect x="2" y="2" width="36" height="26" fill="none" stroke="#666"/></svg>`;
    }

    // ===== MATERIALS LIBRARY =====
    let selectedMaterial = null;
    let currentMaterialCategory = 'granite';

    function renderMaterials(category = 'granite') {
      currentMaterialCategory = category;
      const grid = document.getElementById('materialGrid');
      const materials = MATERIALS[category] || [];

      grid.innerHTML = materials.map(mat => {
        // Build tooltip with details
        let tooltip = mat.name;
        if (mat.brand) tooltip += ` | ${mat.brand}`;
        if (mat.price) tooltip += ` | $${mat.price}/sqft`;
        if (mat.sku) tooltip += ` | SKU: ${mat.sku}`;
        if (mat.series) tooltip += ` | ${mat.series}`;
        if (mat.warranty) tooltip += ` | ${mat.warranty}`;
        if (mat.features) tooltip += ` | ${mat.features}`;

        // Price badge
        const priceBadge = mat.price
          ? `<div class="material-price-badge">$${mat.price}${mat.unit ? '/' + mat.unit : '/sf'}</div>`
          : '';

        // Brand badge
        const brandBadge = mat.brand
          ? `<div class="material-brand-badge">${mat.brand.replace('MSI ', '').replace('Daltile ', '').substring(0, 10)}</div>`
          : '';

        return `
        <div class="material-swatch ${selectedMaterial?.id === mat.id ? 'selected' : ''}"
             style="background: ${mat.url ? `url('${mat.url}')` : mat.color}; background-size: cover; background-position: center;"
             onclick="selectMaterial('${mat.id}')"
             title="${tooltip}">
          ${priceBadge}
          ${brandBadge}
          <div class="material-swatch-label">${mat.name}</div>
        </div>
      `;
      }).join('');
    }

    function showMaterialCategory(category, btn) {
      // Update tab buttons
      document.querySelectorAll('.material-tab').forEach(t => t.classList.remove('active'));
      btn.classList.add('active');

      // Render materials for category
      renderMaterials(category);
    }

    function selectMaterial(materialId) {
      // Find material in all categories
      for (const [cat, materials] of Object.entries(MATERIALS)) {
        const mat = materials.find(m => m.id === materialId);
        if (mat) {
          selectedMaterial = { ...mat, category: cat };
          break;
        }
      }

      // Update UI
      renderMaterials(currentMaterialCategory);

      // Update hint
      const hint = document.querySelector('.material-hint');
      if (hint && selectedMaterial) {
        hint.innerHTML = `<strong>${selectedMaterial.name}</strong> selected. Click an element to apply.`;
        hint.style.borderColor = 'var(--gold)';
      }
    }

    function applyMaterialToElement(element) {
      if (!selectedMaterial) return false;

      // Apply the material
      element.color = selectedMaterial.color;
      element.materialId = selectedMaterial.id;
      element.materialName = selectedMaterial.name;
      element.materialPrice = selectedMaterial.price || null;
      element.materialBrand = selectedMaterial.brand || null;

      // Recalculate quote with new material pricing
      calculateQuote();

      // Load texture image if URL exists
      if (selectedMaterial.url) {
        const img = new Image();
        img.crossOrigin = 'anonymous';
        img.onload = () => {
          element.textureImg = img;
          draw();
        };
        img.onerror = () => {
          console.warn('Failed to load texture:', selectedMaterial.url);
        };
        img.src = selectedMaterial.url;
      } else {
        element.textureImg = null;
      }

      // Clear selection after applying
      const prevMaterial = selectedMaterial.name;
      selectedMaterial = null;
      renderMaterials(currentMaterialCategory);

      // Reset hint
      const hint = document.querySelector('.material-hint');
      if (hint) {
        hint.innerHTML = `Applied <strong>${prevMaterial}</strong>! Click material, then element to apply.`;
        hint.style.borderColor = 'var(--success)';
        setTimeout(() => {
          hint.innerHTML = 'Click material, then click element to apply';
          hint.style.borderColor = 'var(--border)';
        }, 2000);
      }

      return true;
    }

    // ===== CABINET CATALOG =====
    function renderCabinetCatalog() {
      const catalog = CABINET_CATALOGS[currentCatalog];
      if (!catalog) return;

      const list = document.getElementById('cabinetCatalogList');
      const cabinets = catalog.cabinets[currentCabinetCategory] || [];
      const series = catalog.series[currentCabinetSeries] || { color: '#8B4513' };

      if (cabinets.length === 0) {
        list.innerHTML = '<div style="padding: 20px; text-align: center; color: var(--text-muted); font-size: 11px;">No cabinets in this category</div>';
        return;
      }

      list.innerHTML = cabinets.map(cab => `
        <div class="cabinet-catalog-item"
             draggable="true"
             ondragstart="dragCatalogCabinet(event, '${cab.sku}')"
             onclick="addCatalogCabinet('${cab.sku}')">
          <div class="cabinet-item-info">
            <span class="cabinet-item-sku">${cab.sku}</span>
            <span class="cabinet-item-name">${cab.name}</span>
            <span class="cabinet-item-size">${cab.width}'  ${cab.height}'</span>
          </div>
          <button class="cabinet-item-add" onclick="event.stopPropagation(); addCatalogCabinet('${cab.sku}')" title="Add to canvas">+</button>
        </div>
      `).join('');
    }

    function changeCatalog(catalogId) {
      currentCatalog = catalogId;
      const catalog = CABINET_CATALOGS[catalogId];

      // Update series dropdown
      const seriesSelect = document.getElementById('seriesSelect');
      const seriesDiv = document.getElementById('catalogSeries');

      if (catalog && Object.keys(catalog.series).length > 0) {
        seriesDiv.style.display = 'block';
        seriesSelect.innerHTML = Object.entries(catalog.series).map(([id, s]) =>
          `<option value="${id}">${s.name}</option>`
        ).join('');
        currentCabinetSeries = Object.keys(catalog.series)[0];
      } else {
        seriesDiv.style.display = catalogId === 'custom' ? 'none' : 'block';
      }

      renderCabinetCatalog();
    }

    function changeSeries(seriesId) {
      currentCabinetSeries = seriesId;
      renderCabinetCatalog();
    }

    function showCabinetCategory(category, btn) {
      currentCabinetCategory = category;
      document.querySelectorAll('#cabinetCategoryTabs .material-tab').forEach(t => t.classList.remove('active'));
      btn.classList.add('active');
      renderCabinetCatalog();
    }

    function getCatalogCabinet(sku) {
      const catalog = CABINET_CATALOGS[currentCatalog];
      if (!catalog) return null;

      for (const category of Object.values(catalog.cabinets)) {
        const cab = category.find(c => c.sku === sku);
        if (cab) return cab;
      }
      return null;
    }

    function addCatalogCabinet(sku) {
      const cab = getCatalogCabinet(sku);
      if (!cab) return;

      const catalog = CABINET_CATALOGS[currentCatalog];
      const series = catalog.series[currentCabinetSeries] || { color: '#8B4513', name: 'Default' };

      // Calculate position (center of visible area)
      const centerX = (canvas.width / 2 - panX) / pixelsPerFoot;
      const centerY = (canvas.height / 2 - panY) / pixelsPerFoot;

      const element = {
        id: Date.now() + Math.random(),
        type: cab.type,
        x: centerX * pixelsPerFoot,
        y: centerY * pixelsPerFoot,
        width: cab.width,
        height: cab.height,
        rotation: 0,
        color: series.color,
        label: `${cab.name} (${series.name})`,
        sku: cab.sku,
        catalog: currentCatalog,
        series: currentCabinetSeries,
        // Cabinet settings
        construction: cabinetSettings.construction,
        doorStyle: cabinetSettings.doorStyle,
        doorOverlay: cabinetSettings.doorOverlay,
        floorLevel: cabinetSettings.currentFloor
      };

      elements.push(element);
      selectedElement = element;
      updateProperties();
      calculateQuote();
      saveUndoState();
      draw();
    }

    function dragCatalogCabinet(e, sku) {
      e.dataTransfer.setData('catalog-cabinet', sku);
      e.dataTransfer.effectAllowed = 'copy';
    }

    function importCabinetList() {
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = '.csv,.json,.txt';
      input.onchange = async (e) => {
        const file = e.target.files[0];
        if (!file) return;

        const text = await file.text();
        let cabinets = [];

        try {
          if (file.name.endsWith('.json')) {
            // JSON format: array of cabinet objects
            cabinets = JSON.parse(text);
          } else {
            // CSV format: sku,name,width,height,type
            const lines = text.split('\n').filter(l => l.trim());
            const hasHeader = lines[0].toLowerCase().includes('sku') || lines[0].toLowerCase().includes('name');

            (hasHeader ? lines.slice(1) : lines).forEach(line => {
              const parts = line.split(',').map(p => p.trim().replace(/"/g, ''));
              if (parts.length >= 4) {
                cabinets.push({
                  sku: parts[0] || `CUSTOM-${Date.now()}`,
                  name: parts[1] || 'Custom Cabinet',
                  width: parseFloat(parts[2]) || 2,
                  height: parseFloat(parts[3]) || 2,
                  depth: parseFloat(parts[4]) || 2,
                  type: parts[5] || 'base-cabinet'
                });
              }
            });
          }

          if (cabinets.length > 0) {
            CABINET_CATALOGS.custom.cabinets.imported = cabinets;
            currentCatalog = 'custom';
            currentCabinetCategory = 'imported';
            document.getElementById('catalogSelect').value = 'custom';

            // Add imported tab if not exists
            const tabs = document.getElementById('cabinetCategoryTabs');
            if (!tabs.innerHTML.includes('imported')) {
              tabs.innerHTML += '<button class="material-tab" onclick="showCabinetCategory(\'imported\', this)">Imported</button>';
            }

            renderCabinetCatalog();
            alert(`Imported ${cabinets.length} cabinets successfully!`);
          } else {
            alert('No valid cabinet data found in file.');
          }
        } catch (err) {
          console.error('Import error:', err);
          alert('Error importing file. Please check the format.\n\nExpected CSV format:\nsku,name,width,height,depth,type\nB24,Base 24",2,2,2,base-cabinet');
        }
      };
      input.click();
    }

    function selectFloorPlan(id) {
      currentFloorPlan = id;
      const plan = FLOOR_PLANS.find(p => p.id === id);

      // Clear existing walls
      walls = [];

      // Add walls based on floor plan
      if (plan && plan.walls) {
        plan.walls.forEach(w => {
          if (w.type === 'full') {
            // Full room walls
            addWall(0, 0, roomWidth * pixelsPerFoot, CONFIG.WALL_THICKNESS);
            addWall(0, 0, CONFIG.WALL_THICKNESS, roomDepth * pixelsPerFoot);
            addWall(0, roomDepth * pixelsPerFoot - CONFIG.WALL_THICKNESS, roomWidth * pixelsPerFoot, CONFIG.WALL_THICKNESS);
            addWall(roomWidth * pixelsPerFoot - CONFIG.WALL_THICKNESS, 0, CONFIG.WALL_THICKNESS, roomDepth * pixelsPerFoot);
          } else if (w.type === 'rect') {
            const x = w.x * roomWidth * pixelsPerFoot;
            const y = w.y * roomDepth * pixelsPerFoot;
            const width = w.w * roomWidth * pixelsPerFoot;
            const height = w.h * roomDepth * pixelsPerFoot;
            // Add as a filled area indicator
            walls.push({ x, y, width, height, type: 'area' });
          }
        });
      }

      renderFloorPlans();
      draw();
    }

    function addWall(x, y, width, height) {
      walls.push({
        id: Date.now() + Math.random(),
        x, y, width, height,
        type: 'wall',
        color: '#444'
      });
    }

    function fitToScreen() {
      const wrapper = document.getElementById('canvasWrapper');
      const padding = 80;
      const availableWidth = wrapper.clientWidth - padding;
      const availableHeight = wrapper.clientHeight - padding;

      const scaleX = availableWidth / roomWidth;
      const scaleY = availableHeight / roomDepth;

      pixelsPerFoot = Math.min(scaleX, scaleY, 80);
      pixelsPerFoot = Math.max(pixelsPerFoot, CONFIG.MIN_PIXELS_PER_FOOT);

      // Center the room in the canvas
      panX = (wrapper.clientWidth - roomWidth * pixelsPerFoot) / 2;
      panY = (wrapper.clientHeight - roomDepth * pixelsPerFoot) / 2;

      document.getElementById('scaleMode').value = 'fit';
      updateCanvasSize();
    }

    function updateScale() {
      const mode = document.getElementById('scaleMode').value;
      if (mode === 'fit') {
        fitToScreen();
      } else {
        pixelsPerFoot = parseInt(mode);
        // Re-center when changing scale
        const wrapper = document.getElementById('canvasWrapper');
        panX = (wrapper.clientWidth - roomWidth * pixelsPerFoot) / 2;
        panY = (wrapper.clientHeight - roomDepth * pixelsPerFoot) / 2;
        updateCanvasSize();
      }
    }

    function updateCanvasSize() {
      const wrapper = document.getElementById('canvasWrapper');

      // Canvas fills entire workspace
      canvas.width = wrapper.clientWidth;
      canvas.height = wrapper.clientHeight;

      document.getElementById('canvasSize').textContent = `${roomWidth}'  ${roomDepth}'`;

      draw();
    }

    function setupEventListeners() {
      canvas.addEventListener('mousedown', onMouseDown);
      canvas.addEventListener('mousemove', onMouseMove);
      canvas.addEventListener('mouseup', onMouseUp);
      canvas.addEventListener('mouseleave', onMouseUp);
      canvas.addEventListener('contextmenu', onContextMenu);
      canvas.addEventListener('dblclick', onDoubleClick);
      canvas.addEventListener('wheel', onWheel, { passive: false });

      document.addEventListener('keydown', onKeyDown);
      document.addEventListener('keyup', onKeyUp);

      document.addEventListener('click', (e) => {
        if (!e.target.closest('.context-menu')) {
          hideContextMenu();
        }
      });

      window.addEventListener('resize', () => {
        updateCanvasSize();
        if (document.getElementById('scaleMode').value === 'fit') {
          fitToScreen();
        }
      });
    }

    function setupDragDrop() {
      document.addEventListener('dragstart', (e) => {
        if (e.target.classList.contains('element-item')) {
          e.dataTransfer.setData('element-type', e.target.dataset.type);
          e.target.style.opacity = '0.5';
        }
      });

      document.addEventListener('dragend', (e) => {
        if (e.target.classList.contains('element-item')) {
          e.target.style.opacity = '1';
        }
      });

      canvas.addEventListener('dragover', (e) => e.preventDefault());
      canvas.addEventListener('drop', onDrop);
    }

    // ===== DRAWING =====
    function draw() {
      if (!ctx) return;

      // Clear entire canvas with dark background
      ctx.fillStyle = '#0d0d15';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Apply pan transformation
      ctx.save();
      ctx.translate(panX, panY);

      // Draw infinite grid
      drawGrid();

      // Draw room boundary (the actual room shape)
      drawRoomBoundary();

      // Draw floor plan areas
      drawFloorPlanAreas();

      // Draw walls
      drawWalls();

      // Draw elements
      drawElements();

      // Draw work triangle overlay if enabled
      drawWorkTriangle();

      ctx.restore();

      document.getElementById('elementCount').textContent = `${elements.length} element${elements.length !== 1 ? 's' : ''}`;
      calculateQuote();
    }

    // Toggle work triangle visualization
    function toggleWorkTriangle() {
      showWorkTriangle = !showWorkTriangle;
      const btn = document.querySelector('.validation-toggle');
      if (btn) {
        btn.classList.toggle('active', showWorkTriangle);
      }
      if (showWorkTriangle) {
        runValidation();
      }
      draw();
    }

    function drawGrid() {
      const gridSize = pixelsPerFoot / CONFIG.GRID_SUBDIVISIONS;
      const roomW = roomWidth * pixelsPerFoot;
      const roomH = roomDepth * pixelsPerFoot;

      // Calculate visible area for grid
      const startX = -panX - pixelsPerFoot;
      const startY = -panY - pixelsPerFoot;
      const endX = canvas.width - panX + pixelsPerFoot;
      const endY = canvas.height - panY + pixelsPerFoot;

      // Sub-grid (faint lines)
      ctx.strokeStyle = 'rgba(255,255,255,0.02)';
      ctx.lineWidth = 1;

      const gridStartX = Math.floor(startX / gridSize) * gridSize;
      const gridStartY = Math.floor(startY / gridSize) * gridSize;

      for (let x = gridStartX; x < endX; x += gridSize) {
        ctx.beginPath();
        ctx.moveTo(x, startY);
        ctx.lineTo(x, endY);
        ctx.stroke();
      }
      for (let y = gridStartY; y < endY; y += gridSize) {
        ctx.beginPath();
        ctx.moveTo(startX, y);
        ctx.lineTo(endX, y);
        ctx.stroke();
      }

      // Main grid (1ft lines)
      ctx.strokeStyle = 'rgba(255,255,255,0.06)';
      const mainStartX = Math.floor(startX / pixelsPerFoot) * pixelsPerFoot;
      const mainStartY = Math.floor(startY / pixelsPerFoot) * pixelsPerFoot;

      for (let x = mainStartX; x < endX; x += pixelsPerFoot) {
        ctx.beginPath();
        ctx.moveTo(x, startY);
        ctx.lineTo(x, endY);
        ctx.stroke();
      }
      for (let y = mainStartY; y < endY; y += pixelsPerFoot) {
        ctx.beginPath();
        ctx.moveTo(startX, y);
        ctx.lineTo(endX, y);
        ctx.stroke();
      }
    }

    function drawRoomBoundary() {
      const roomW = roomWidth * pixelsPerFoot;
      const roomH = roomDepth * pixelsPerFoot;

      // Room floor (lighter area)
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, roomW, roomH);

      // Room border with measurements
      ctx.strokeStyle = '#4a4a6a';
      ctx.lineWidth = 3;
      ctx.strokeRect(0, 0, roomW, roomH);

      // Corner markers
      const markerSize = 12;
      ctx.fillStyle = '#6366f1';
      ctx.fillRect(-markerSize/2, -markerSize/2, markerSize, markerSize);
      ctx.fillRect(roomW - markerSize/2, -markerSize/2, markerSize, markerSize);
      ctx.fillRect(-markerSize/2, roomH - markerSize/2, markerSize, markerSize);
      ctx.fillRect(roomW - markerSize/2, roomH - markerSize/2, markerSize, markerSize);

      // Dimension labels along edges
      ctx.fillStyle = 'rgba(255,255,255,0.6)';
      ctx.font = `bold ${Math.max(12, pixelsPerFoot / 3)}px Inter`;
      ctx.textAlign = 'center';

      // Top dimension
      ctx.fillText(`${roomWidth}'`, roomW / 2, -10);
      // Left dimension
      ctx.save();
      ctx.translate(-10, roomH / 2);
      ctx.rotate(-Math.PI / 2);
      ctx.fillText(`${roomDepth}'`, 0, 0);
      ctx.restore();

      // Foot markers along room edges
      ctx.fillStyle = 'rgba(255,255,255,0.4)';
      ctx.font = `${Math.max(9, pixelsPerFoot / 5)}px Inter`;
      for (let x = pixelsPerFoot; x < roomW; x += pixelsPerFoot) {
        ctx.fillText(`${Math.round(x / pixelsPerFoot)}'`, x, -25);
        // Tick mark
        ctx.strokeStyle = 'rgba(255,255,255,0.3)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, -6);
        ctx.stroke();
      }
      for (let y = pixelsPerFoot; y < roomH; y += pixelsPerFoot) {
        ctx.save();
        ctx.translate(-25, y);
        ctx.rotate(-Math.PI / 2);
        ctx.fillText(`${Math.round(y / pixelsPerFoot)}'`, 0, 0);
        ctx.restore();
        // Tick mark
        ctx.strokeStyle = 'rgba(255,255,255,0.3)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(-6, y);
        ctx.stroke();
      }
    }

    function drawFloorPlanAreas() {
      walls.filter(w => w.type === 'area').forEach(area => {
        ctx.fillStyle = 'rgba(60, 60, 80, 0.6)';
        ctx.fillRect(area.x, area.y, area.width, area.height);
        ctx.strokeStyle = '#666';
        ctx.lineWidth = 2;
        ctx.strokeRect(area.x, area.y, area.width, area.height);
      });
    }

    function drawWalls() {
      walls.filter(w => w.type === 'wall').forEach(wall => {
        ctx.fillStyle = wall.color;
        ctx.fillRect(wall.x, wall.y, wall.width, wall.height);
      });
    }

    // ===== RENDERING HELPER FUNCTIONS =====

    // Adjust a hex color by amount (-255 to 255)
    function adjustColor(color, amount) {
      if (!color || color.charAt(0) !== '#') return color;
      let r = parseInt(color.slice(1, 3), 16);
      let g = parseInt(color.slice(3, 5), 16);
      let b = parseInt(color.slice(5, 7), 16);
      r = Math.max(0, Math.min(255, r + amount));
      g = Math.max(0, Math.min(255, g + amount));
      b = Math.max(0, Math.min(255, b + amount));
      return `#${r.toString(16).padStart(2,'0')}${g.toString(16).padStart(2,'0')}${b.toString(16).padStart(2,'0')}`;
    }

    // Draw wood grain pattern
    function drawWoodGrain(ctx, x, y, w, h, baseColor, opacity = 1) {
      // Guard against invalid dimensions
      w = Math.abs(w);
      h = Math.abs(h);
      if (w < 1 || h < 1) return;

      const seed = Math.floor(x * 7 + y * 13) % 1000;
      const rand = (n) => ((seed + n * 31) % 100) / 100;

      ctx.save();
      ctx.globalAlpha = opacity;

      // Subtle wood grain lines
      ctx.strokeStyle = 'rgba(0,0,0,0.12)';
      ctx.lineWidth = 0.8;

      const grainCount = Math.floor(h / 6);
      for (let i = 0; i < grainCount; i++) {
        const gy = y + 4 + i * (h - 8) / grainCount;
        const waveAmp = 1 + rand(i) * 2;
        const waveFreq = 0.02 + rand(i + 50) * 0.03;

        ctx.beginPath();
        ctx.moveTo(x + 2, gy);

        for (let gx = x + 2; gx < x + w - 2; gx += 3) {
          const yOffset = Math.sin((gx - x) * waveFreq + rand(i + 100) * Math.PI) * waveAmp;
          ctx.lineTo(gx, gy + yOffset);
        }
        ctx.stroke();
      }

      // Occasional darker grain knots
      ctx.fillStyle = 'rgba(0,0,0,0.08)';
      const knotCount = Math.floor(w * h / 3000);
      for (let k = 0; k < knotCount; k++) {
        const kx = x + rand(k * 3) * w * 0.8 + w * 0.1;
        const ky = y + rand(k * 5) * h * 0.8 + h * 0.1;
        const kr = 2 + rand(k * 7) * 4;
        ctx.beginPath();
        ctx.ellipse(kx, ky, Math.abs(kr), Math.abs(kr * 0.6), rand(k * 11) * Math.PI, 0, Math.PI * 2);
        ctx.fill();
      }

      ctx.restore();
    }

    // Draw a single cabinet door with shaker style
    function drawCabinetDoor(ctx, x, y, w, h, color) {
      // Guard against invalid dimensions
      w = Math.abs(w);
      h = Math.abs(h);
      if (w < 1 || h < 1) return;

      // Door background
      ctx.fillStyle = color;
      ctx.fillRect(x, y, w, h);

      // Wood grain
      drawWoodGrain(ctx, x, y, w, h, color, 0.5);

      // Shaker panel inset
      const inset = Math.min(10, w * 0.1, h * 0.08);
      const px = x + inset;
      const py = y + inset;
      const pw = w - inset * 2;
      const ph = h - inset * 2;

      // Panel shadow (inset effect)
      ctx.fillStyle = 'rgba(0,0,0,0.15)';
      ctx.fillRect(px, py, pw, 2);
      ctx.fillRect(px, py, 2, ph);

      // Panel highlight
      ctx.fillStyle = 'rgba(255,255,255,0.1)';
      ctx.fillRect(px, py + ph - 2, pw, 2);
      ctx.fillRect(px + pw - 2, py, 2, ph);

      // Inner panel darker
      ctx.fillStyle = 'rgba(0,0,0,0.05)';
      ctx.fillRect(px + 2, py + 2, pw - 4, ph - 4);

      // Edge highlights
      ctx.fillStyle = 'rgba(255,255,255,0.1)';
      ctx.fillRect(x, y, w, 2);
      ctx.fillRect(x, y, 2, h);

      ctx.fillStyle = 'rgba(0,0,0,0.12)';
      ctx.fillRect(x, y + h - 2, w, 2);
      ctx.fillRect(x + w - 2, y, 2, h);

      // Handle
      const handleLen = Math.min(18, h * 0.3);
      const handleX = x + w - 8;
      const handleY = y + h / 2 - handleLen / 2;
      ctx.fillStyle = 'rgba(180,180,180,0.85)';
      ctx.fillRect(handleX, handleY, 3, handleLen);
      ctx.fillStyle = 'rgba(255,255,255,0.3)';
      ctx.fillRect(handleX, handleY, 1, handleLen);
    }

    // Draw countertop surface with material-specific patterns
    function drawCountertopSurface(ctx, x, y, w, h, color, materialName) {
      const name = (materialName || '').toLowerCase();
      const seed = Math.floor(x * 11 + y * 17) % 1000;
      const rand = (n) => ((seed + n * 23) % 100) / 100;

      // Determine material type from name
      let materialType = 'granite'; // default
      if (name.includes('marble') || name.includes('calacatta') || name.includes('carrara') || name.includes('statuario')) {
        materialType = 'marble';
      } else if (name.includes('quartz') || name.includes('silestone') || name.includes('caesarstone')) {
        materialType = 'quartz';
      } else if (name.includes('quartzite') || name.includes('taj') || name.includes('fantasy')) {
        materialType = 'quartzite';
      } else if (name.includes('concrete') || name.includes('cement')) {
        materialType = 'concrete';
      } else if (name.includes('butcher') || name.includes('wood') || name.includes('walnut') || name.includes('maple')) {
        materialType = 'wood';
      }

      ctx.save();

      switch (materialType) {
        case 'marble':
          // Marble: Dramatic veining on light background
          // Base with subtle variation
          const marbleGrad = ctx.createLinearGradient(x, y, x + w, y + h);
          marbleGrad.addColorStop(0, color);
          marbleGrad.addColorStop(0.5, adjustColor(color, 8));
          marbleGrad.addColorStop(1, adjustColor(color, -5));
          ctx.fillStyle = marbleGrad;
          ctx.fillRect(x, y, w, h);

          // Primary dramatic veins
          ctx.strokeStyle = 'rgba(80,80,90,0.35)';
          ctx.lineWidth = 2.5;
          for (let i = 0; i < 3; i++) {
            ctx.beginPath();
            const startX = x + rand(i) * w * 0.3;
            const startY = y + rand(i + 10) * h;
            ctx.moveTo(startX, startY);

            // Create flowing vein path
            const cp1x = x + w * (0.2 + rand(i + 20) * 0.3);
            const cp1y = y + h * rand(i + 30);
            const cp2x = x + w * (0.5 + rand(i + 40) * 0.3);
            const cp2y = y + h * rand(i + 50);
            const endX = x + w - rand(i + 60) * w * 0.2;
            const endY = y + rand(i + 70) * h;

            ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, endX, endY);
            ctx.stroke();

            // Feathered edges on main veins
            ctx.strokeStyle = 'rgba(80,80,90,0.15)';
            ctx.lineWidth = 5;
            ctx.stroke();
          }

          // Secondary thinner veins
          ctx.strokeStyle = 'rgba(100,100,110,0.2)';
          ctx.lineWidth = 1;
          for (let i = 0; i < 6; i++) {
            ctx.beginPath();
            ctx.moveTo(x + rand(i + 80) * w, y + rand(i + 90) * h);
            ctx.quadraticCurveTo(
              x + w * rand(i + 100),
              y + h * rand(i + 110),
              x + rand(i + 120) * w,
              y + rand(i + 130) * h
            );
            ctx.stroke();
          }
          break;

        case 'quartz':
          // Quartz: Uniform with subtle sparkle/flecks
          ctx.fillStyle = color;
          ctx.fillRect(x, y, w, h);

          // Fine uniform speckling
          const speckleCount = Math.floor(w * h / 40);
          for (let i = 0; i < speckleCount; i++) {
            const sx = x + rand(i) * w;
            const sy = y + rand(i + 500) * h;
            const brightness = rand(i + 1000) > 0.5 ? 'rgba(255,255,255,' : 'rgba(0,0,0,';
            const alpha = 0.05 + rand(i + 1500) * 0.1;
            ctx.fillStyle = brightness + alpha + ')';
            ctx.fillRect(sx, sy, 1.5, 1.5);
          }

          // Occasional larger sparkle spots
          ctx.fillStyle = 'rgba(255,255,255,0.25)';
          for (let i = 0; i < speckleCount / 20; i++) {
            const sx = x + rand(i + 2000) * w;
            const sy = y + rand(i + 2500) * h;
            ctx.beginPath();
            ctx.arc(sx, sy, 1, 0, Math.PI * 2);
            ctx.fill();
          }
          break;

        case 'quartzite':
          // Quartzite: Natural flowing patterns with crystalline look
          ctx.fillStyle = color;
          ctx.fillRect(x, y, w, h);

          // Flowing wave patterns
          ctx.strokeStyle = 'rgba(255,255,255,0.15)';
          ctx.lineWidth = 3;
          for (let i = 0; i < 5; i++) {
            ctx.beginPath();
            const startY = y + (i / 5) * h + rand(i) * h * 0.1;
            ctx.moveTo(x, startY);

            for (let px = 0; px <= w; px += 20) {
              const py = startY + Math.sin((px / w) * Math.PI * (2 + rand(i + 10))) * h * 0.1 * rand(i + 20);
              ctx.lineTo(x + px, py);
            }
            ctx.stroke();
          }

          // Crystalline shimmer
          ctx.fillStyle = 'rgba(255,255,255,0.08)';
          for (let i = 0; i < 30; i++) {
            const cx = x + rand(i + 300) * w;
            const cy = y + rand(i + 400) * h;
            ctx.beginPath();
            ctx.moveTo(cx, cy - 3);
            ctx.lineTo(cx + 2, cy);
            ctx.lineTo(cx, cy + 3);
            ctx.lineTo(cx - 2, cy);
            ctx.closePath();
            ctx.fill();
          }
          break;

        case 'concrete':
          // Concrete: Matte with subtle texture
          ctx.fillStyle = color;
          ctx.fillRect(x, y, w, h);

          // Subtle aggregate texture
          ctx.fillStyle = 'rgba(0,0,0,0.03)';
          for (let i = 0; i < w * h / 100; i++) {
            const cx = x + rand(i) * w;
            const cy = y + rand(i + 500) * h;
            ctx.beginPath();
            ctx.arc(cx, cy, 1 + rand(i + 1000) * 2, 0, Math.PI * 2);
            ctx.fill();
          }

          // Subtle variation patches
          for (let i = 0; i < 4; i++) {
            ctx.fillStyle = rand(i) > 0.5 ? 'rgba(0,0,0,0.02)' : 'rgba(255,255,255,0.02)';
            ctx.beginPath();
            ctx.ellipse(
              x + rand(i + 100) * Math.abs(w),
              y + rand(i + 200) * Math.abs(h),
              Math.abs(rand(i + 300) * w * 0.3) || 1,
              Math.abs(rand(i + 400) * h * 0.3) || 1,
              rand(i + 500) * Math.PI,
              0, Math.PI * 2
            );
            ctx.fill();
          }
          break;

        case 'wood':
          // Wood countertop: butcher block style
          drawWoodGrain(ctx, x, y, w, h, color);

          // Butcher block strips
          const stripWidth = pixelsPerFoot * 0.25;
          ctx.strokeStyle = 'rgba(0,0,0,0.1)';
          ctx.lineWidth = 1;
          for (let sx = x + stripWidth; sx < x + w; sx += stripWidth) {
            ctx.beginPath();
            ctx.moveTo(sx, y);
            ctx.lineTo(sx, y + h);
            ctx.stroke();
          }
          break;

        default: // granite
          // Granite: Speckled with various mineral colors
          ctx.fillStyle = color;
          ctx.fillRect(x, y, w, h);

          // Multi-colored speckles (mineral flecks)
          const mineralColors = [
            'rgba(0,0,0,0.3)',
            'rgba(255,255,255,0.25)',
            'rgba(150,150,150,0.2)',
            'rgba(100,80,60,0.15)',
            'rgba(60,60,70,0.2)'
          ];

          const graniteSpeckles = Math.floor(w * h / 25);
          for (let i = 0; i < graniteSpeckles; i++) {
            const gx = x + rand(i) * w;
            const gy = y + rand(i + 500) * h;
            const colorIdx = Math.floor(rand(i + 1000) * mineralColors.length);
            ctx.fillStyle = mineralColors[colorIdx];
            const size = 1 + rand(i + 1500) * 2;
            ctx.fillRect(gx, gy, size, size);
          }

          // Larger mineral clusters
          for (let i = 0; i < graniteSpeckles / 30; i++) {
            const cx = x + rand(i + 2000) * w;
            const cy = y + rand(i + 2500) * h;
            const ccolor = mineralColors[Math.floor(rand(i + 3000) * mineralColors.length)];
            ctx.fillStyle = ccolor;
            ctx.beginPath();
            ctx.arc(cx, cy, 2 + rand(i + 3500) * 3, 0, Math.PI * 2);
            ctx.fill();
          }
      }

      // Edge profile (bullnose/eased edge look)
      // Top edge highlight
      ctx.fillStyle = 'rgba(255,255,255,0.2)';
      ctx.fillRect(x, y, w, 3);
      ctx.fillRect(x, y, 3, h);

      // Bottom edge shadow
      ctx.fillStyle = 'rgba(0,0,0,0.25)';
      ctx.fillRect(x, y + h - 3, w, 3);
      ctx.fillRect(x + w - 3, y, 3, h);

      // Outer border
      ctx.strokeStyle = 'rgba(255,255,255,0.15)';
      ctx.lineWidth = 1;
      ctx.strokeRect(x + 1, y + 1, w - 2, h - 2);

      ctx.restore();
    }

    // Draw architectural details for each element type
    function drawElementDetails(el, x, y, w, h) {
      ctx.strokeStyle = 'rgba(255,255,255,0.4)';
      ctx.fillStyle = 'rgba(255,255,255,0.1)';
      ctx.lineWidth = 1;

      const type = el.type;
      const padding = Math.min(w, h) * 0.08;

      // Check if element has a loaded texture image
      const hasTexture = el.textureImg && el.textureImg.complete && el.textureImg.naturalWidth > 0;

      switch(type) {
        case 'base-cabinet':
        case 'wall-cabinet':
          // Determine cabinet style from material or default to shaker
          const cabinetStyle = el.materialName?.toLowerCase().includes('flat') ? 'flat' : 'shaker';
          const isWallCab = type === 'wall-cabinet';

          // Toe kick dimensions for base cabinets (4" tall, 3" recessed from front)
          const toeKickH = isWallCab ? 0 : Math.max(8, h * 0.15);
          const toeKickRecess = isWallCab ? 0 : Math.max(5, w * 0.06);

          // Cabinet body height (excluding toe kick)
          const cabinetBodyH = h - toeKickH;

          // Draw toe kick recess FIRST (at the front/bottom of cabinet)
          if (!isWallCab && toeKickH > 0) {
            // Dark recessed void under cabinet
            ctx.fillStyle = '#0d0d12';
            ctx.fillRect(x + toeKickRecess, y + cabinetBodyH, w - toeKickRecess * 2, toeKickH);

            // Shadow line at top of toe kick (under cabinet overhang)
            ctx.fillStyle = 'rgba(0,0,0,0.7)';
            ctx.fillRect(x + toeKickRecess, y + cabinetBodyH, w - toeKickRecess * 2, 3);

            // Cabinet overhang edge
            ctx.fillStyle = adjustColor(el.color, -40);
            ctx.fillRect(x, y + cabinetBodyH - 2, w, 2);
          }

          // Draw wood grain background on cabinet body (only if no texture)
          if (!hasTexture) {
            drawWoodGrain(ctx, x, y, w, cabinetBodyH, el.color);
          }

          // Calculate door layout (doors are on the cabinet body, not toe kick)
          const doorCount = Math.max(1, Math.floor(w / (pixelsPerFoot * 1.5)));
          const doorWidth = (w - padding * 2) / doorCount;

          for (let i = 0; i < doorCount; i++) {
            const dx = x + padding + i * doorWidth;
            const dy = y + padding;
            const dw = doorWidth - 4;
            const dh = cabinetBodyH - padding * 2; // Door height stops at toe kick

            // Door frame shadow
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.fillRect(dx + 3, dy + 3, dw, dh);

            // Door face
            ctx.fillStyle = el.color;
            ctx.fillRect(dx, dy, dw, dh);

            // Wood grain on door (only if no texture loaded)
            if (!hasTexture) {
              drawWoodGrain(ctx, dx + 2, dy + 2, dw - 4, dh - 4, el.color, 0.6);
            }

            if (cabinetStyle === 'shaker') {
              // Shaker style recessed panel
              const panelInset = Math.min(12, dw * 0.12);
              const px = dx + panelInset;
              const py = dy + panelInset;
              const pw = dw - panelInset * 2;
              const ph = dh - panelInset * 2;

              // Panel recess shadow (top-left inside)
              ctx.fillStyle = 'rgba(0,0,0,0.2)';
              ctx.fillRect(px, py, pw, 3);
              ctx.fillRect(px, py, 3, ph);

              // Panel recess highlight (bottom-right inside)
              ctx.fillStyle = 'rgba(255,255,255,0.15)';
              ctx.fillRect(px, py + ph - 3, pw, 3);
              ctx.fillRect(px + pw - 3, py, 3, ph);

              // Inner panel (slightly darker)
              ctx.fillStyle = 'rgba(0,0,0,0.08)';
              ctx.fillRect(px + 3, py + 3, pw - 6, ph - 6);

              // Panel outer frame highlight
              ctx.strokeStyle = 'rgba(255,255,255,0.12)';
              ctx.lineWidth = 1;
              ctx.strokeRect(dx + 2, dy + 2, dw - 4, dh - 4);
            } else {
              // Flat/slab style - just edge detail
              ctx.strokeStyle = 'rgba(255,255,255,0.1)';
              ctx.lineWidth = 1;
              ctx.strokeRect(dx + 2, dy + 2, dw - 4, dh - 4);
            }

            // Door edge highlights
            ctx.fillStyle = 'rgba(255,255,255,0.12)';
            ctx.fillRect(dx, dy, dw, 2); // top
            ctx.fillRect(dx, dy, 2, dh); // left

            ctx.fillStyle = 'rgba(0,0,0,0.15)';
            ctx.fillRect(dx, dy + dh - 2, dw, 2); // bottom
            ctx.fillRect(dx + dw - 2, dy, 2, dh); // right

            // Door handle - bar pull style
            const handleLen = Math.min(24, dh * 0.35);
            const handleX = dx + dw - 10;
            const handleY = dy + dh / 2 - handleLen / 2;

            // Handle shadow
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.fillRect(handleX + 2, handleY + 2, 4, handleLen);

            // Handle body (brushed nickel look)
            const handleGrad = ctx.createLinearGradient(handleX, 0, handleX + 4, 0);
            handleGrad.addColorStop(0, 'rgba(200,200,200,0.9)');
            handleGrad.addColorStop(0.5, 'rgba(240,240,240,0.95)');
            handleGrad.addColorStop(1, 'rgba(180,180,180,0.9)');
            ctx.fillStyle = handleGrad;
            ctx.fillRect(handleX, handleY, 4, handleLen);

            // Handle ends (rounded caps)
            ctx.fillStyle = 'rgba(160,160,160,0.9)';
            ctx.beginPath();
            ctx.arc(handleX + 2, handleY, 3, 0, Math.PI * 2);
            ctx.arc(handleX + 2, handleY + handleLen, 3, 0, Math.PI * 2);
            ctx.fill();
          }

          // Side panel edges visible
          if (!isWallCab) {
            ctx.fillStyle = adjustColor(el.color, -25);
            ctx.fillRect(x, y, 2, cabinetBodyH);
            ctx.fillRect(x + w - 2, y, 2, cabinetBodyH);
          }
          break;

        case 'tall-cabinet':
          // Toe kick for tall cabinet
          const tallToeH = Math.max(8, h * 0.08);
          const tallToeRecess = Math.max(5, w * 0.06);
          const tallBodyH = h - tallToeH;

          // Draw toe kick recess first
          ctx.fillStyle = '#0d0d12';
          ctx.fillRect(x + tallToeRecess, y + tallBodyH, w - tallToeRecess * 2, tallToeH);
          ctx.fillStyle = 'rgba(0,0,0,0.7)';
          ctx.fillRect(x + tallToeRecess, y + tallBodyH, w - tallToeRecess * 2, 3);
          ctx.fillStyle = adjustColor(el.color, -40);
          ctx.fillRect(x, y + tallBodyH - 2, w, 2);

          // Draw wood grain background on cabinet body
          drawWoodGrain(ctx, x, y, w, tallBodyH, el.color);

          // Two-section tall cabinet (upper 38%, lower 62% of body)
          const tallMidY = y + tallBodyH * 0.38;
          const sectionGap = 4;

          // Upper section (shorter - for wall cabinet style items)
          const upperH = tallMidY - y - padding - sectionGap/2;
          drawCabinetDoor(ctx, x + padding, y + padding, w - padding * 2, upperH, el.color);

          // Lower section (taller - for base items/pantry)
          const lowerY = tallMidY + sectionGap/2;
          const lowerH = tallBodyH - (tallMidY - y) - padding - sectionGap/2;
          drawCabinetDoor(ctx, x + padding, lowerY, w - padding * 2, lowerH, el.color);

          // Side panel edges
          ctx.fillStyle = adjustColor(el.color, -25);
          ctx.fillRect(x, y, 2, tallBodyH);
          ctx.fillRect(x + w - 2, y, 2, tallBodyH);
          break;

        case 'island':
          // Island with countertop overhang and cabinet base with toe kick
          const counterOverhang = 10; // Countertop overhangs the base
          const islandToeH = 6; // Toe kick height
          const islandToeRecess = 5; // Toe kick recessed from cabinet face

          // Cabinet base dimensions (inside the countertop overhang)
          const islandBaseX = x + counterOverhang;
          const islandBaseY = y + counterOverhang;
          const islandBaseW = w - counterOverhang * 2;
          const islandBaseH = h - counterOverhang * 2;

          // Cabinet body (above toe kick)
          const islandCabH = islandBaseH - islandToeH;

          // Draw toe kick recess FIRST (all 4 sides since island is accessible from all sides)
          ctx.fillStyle = '#0d0d12';
          // Front (bottom in Y)
          ctx.fillRect(islandBaseX + islandToeRecess, islandBaseY + islandCabH, islandBaseW - islandToeRecess * 2, islandToeH);
          // Back (top in Y)
          ctx.fillRect(islandBaseX + islandToeRecess, islandBaseY, islandBaseW - islandToeRecess * 2, islandToeH);
          // Left
          ctx.fillRect(islandBaseX, islandBaseY + islandToeRecess, islandToeH, islandBaseH - islandToeRecess * 2);
          // Right
          ctx.fillRect(islandBaseX + islandBaseW - islandToeH, islandBaseY + islandToeRecess, islandToeH, islandBaseH - islandToeRecess * 2);

          // Shadow lines at toe kick edges
          ctx.fillStyle = 'rgba(0,0,0,0.6)';
          ctx.fillRect(islandBaseX + islandToeRecess, islandBaseY + islandCabH, islandBaseW - islandToeRecess * 2, 2);
          ctx.fillRect(islandBaseX + islandToeRecess, islandBaseY + islandToeH - 2, islandBaseW - islandToeRecess * 2, 2);

          // Cabinet body (between toe kicks)
          const cabBodyX = islandBaseX + islandToeH;
          const cabBodyY = islandBaseY + islandToeH;
          const cabBodyW = islandBaseW - islandToeH * 2;
          const cabBodyH = islandCabH - islandToeH;

          // Cabinet base color
          ctx.fillStyle = adjustColor(el.color, -30);
          ctx.fillRect(cabBodyX, cabBodyY, cabBodyW, cabBodyH);

          // Draw cabinet doors on the cabinet body
          const islandDoorCount = Math.max(2, Math.floor(cabBodyW / (pixelsPerFoot * 1.2)));
          const islandDoorW = (cabBodyW - 8) / islandDoorCount;

          for (let i = 0; i < islandDoorCount; i++) {
            const idx = cabBodyX + 4 + i * islandDoorW;
            const idy = cabBodyY + 4;
            const idw = islandDoorW - 4;
            const idh = cabBodyH - 8;

            // Door panel
            ctx.fillStyle = adjustColor(el.color, -20);
            ctx.fillRect(idx, idy, idw, idh);

            // Shaker panel inset
            const inset = Math.min(8, idw * 0.1);
            ctx.strokeStyle = 'rgba(0,0,0,0.2)';
            ctx.lineWidth = 1;
            ctx.strokeRect(idx + inset, idy + inset, idw - inset * 2, idh - inset * 2);

            // Handle
            ctx.fillStyle = 'rgba(180,180,180,0.8)';
            ctx.fillRect(idx + idw - 8, idy + idh/2 - 8, 3, 16);
          }

          // Draw countertop surface LAST (on top, with overhang)
          if (!hasTexture) {
            drawCountertopSurface(ctx, x, y, w, h, el.color, el.materialName);
          } else {
            // Just edge highlights for textured countertop
            ctx.fillStyle = 'rgba(255,255,255,0.2)';
            ctx.fillRect(x, y, w, 3);
            ctx.fillRect(x, y, 3, h);
            ctx.fillStyle = 'rgba(0,0,0,0.25)';
            ctx.fillRect(x, y + h - 3, w, 3);
            ctx.fillRect(x + w - 3, y, 3, h);
          }

          break;

        case 'countertop':
          // Draw countertop with material-specific patterns (only if no texture)
          if (!hasTexture) {
            drawCountertopSurface(ctx, x, y, w, h, el.color, el.materialName);
          } else {
            // Just add edge profile for textured countertops
            ctx.fillStyle = 'rgba(255,255,255,0.15)';
            ctx.fillRect(x, y, w, 3);
            ctx.fillRect(x, y, 3, h);
            ctx.fillStyle = 'rgba(0,0,0,0.2)';
            ctx.fillRect(x, y + h - 3, w, 3);
            ctx.fillRect(x + w - 3, y, 3, h);
          }
          break;

        case 'backsplash':
          // If texture is loaded, just add subtle edge detail
          if (hasTexture) {
            ctx.strokeStyle = 'rgba(255,255,255,0.2)';
            ctx.lineWidth = 1;
            ctx.strokeRect(x + 1, y + 1, w - 2, h - 2);
            break;
          }

          // Draw backsplash with material-specific pattern
          const bsName = (el.materialName || '').toLowerCase();
          const bsSeed = Math.floor(x * 13 + y * 19) % 1000;
          const bsRand = (n) => ((bsSeed + n * 29) % 100) / 100;

          // Determine tile style from material name
          let tileStyle = 'subway'; // default
          if (bsName.includes('mosaic') || bsName.includes('penny')) {
            tileStyle = 'mosaic';
          } else if (bsName.includes('herringbone')) {
            tileStyle = 'herringbone';
          } else if (bsName.includes('hexagon') || bsName.includes('hex')) {
            tileStyle = 'hexagon';
          } else if (bsName.includes('arabesque') || bsName.includes('lantern')) {
            tileStyle = 'arabesque';
          } else if (bsName.includes('chevron')) {
            tileStyle = 'chevron';
          } else if (bsName.includes('marble') || bsName.includes('granite') || bsName.includes('quartz') || bsName.includes('slab')) {
            tileStyle = 'slab';
          }

          switch (tileStyle) {
            case 'subway':
              // Classic subway tile (3x6 ratio)
              const subwayH = Math.max(12, h / 4);
              const subwayW = subwayH * 2;
              let subwayRow = 0;

              for (let ty = y; ty < y + h; ty += subwayH) {
                const offset = (subwayRow % 2) * (subwayW / 2);
                for (let tx = x - offset; tx < x + w + subwayW; tx += subwayW) {
                  if (tx + subwayW > x && tx < x + w) {
                    const tileX = Math.max(tx, x);
                    const tileW = Math.min(tx + subwayW, x + w) - tileX;
                    const tileY = Math.max(ty, y);
                    const tileH = Math.min(ty + subwayH, y + h) - tileY;

                    // Tile face with subtle variation
                    const variation = (bsRand(tx + ty) - 0.5) * 10;
                    ctx.fillStyle = adjustColor(el.color, variation);
                    ctx.fillRect(tileX + 1, tileY + 1, tileW - 2, tileH - 2);

                    // Tile bevel highlight (top/left)
                    ctx.fillStyle = 'rgba(255,255,255,0.15)';
                    ctx.fillRect(tileX + 1, tileY + 1, tileW - 2, 2);
                    ctx.fillRect(tileX + 1, tileY + 1, 2, tileH - 2);

                    // Tile bevel shadow (bottom/right)
                    ctx.fillStyle = 'rgba(0,0,0,0.1)';
                    ctx.fillRect(tileX + 1, tileY + tileH - 3, tileW - 2, 2);
                    ctx.fillRect(tileX + tileW - 3, tileY + 1, 2, tileH - 2);
                  }
                }
                subwayRow++;
              }
              // Grout lines
              ctx.strokeStyle = 'rgba(100,100,100,0.4)';
              ctx.lineWidth = 1;
              ctx.strokeRect(x, y, w, h);
              break;

            case 'mosaic':
              // Small mosaic tiles
              const mosaicSize = Math.max(8, Math.min(w, h) / 8);
              for (let ty = y; ty < y + h; ty += mosaicSize) {
                for (let tx = x; tx < x + w; tx += mosaicSize) {
                  const variation = (bsRand(tx * 3 + ty * 7) - 0.5) * 20;
                  ctx.fillStyle = adjustColor(el.color, variation);
                  ctx.fillRect(tx + 0.5, ty + 0.5, mosaicSize - 1, mosaicSize - 1);

                  // Slight 3D effect
                  ctx.fillStyle = 'rgba(255,255,255,0.1)';
                  ctx.fillRect(tx + 0.5, ty + 0.5, mosaicSize - 1, 1);
                }
              }
              break;

            case 'herringbone':
              // Herringbone pattern
              const hbW = Math.max(8, w / 12);
              const hbH = hbW * 3;
              ctx.save();
              ctx.beginPath();
              ctx.rect(x, y, w, h);
              ctx.clip();

              for (let row = -2; row < h / (hbH/2) + 2; row++) {
                for (let col = -2; col < w / hbW + 2; col++) {
                  const isEven = (row + col) % 2 === 0;
                  const tx = x + col * hbW;
                  const ty = y + row * (hbH / 2);

                  ctx.save();
                  ctx.translate(tx + hbW/2, ty + hbH/4);
                  ctx.rotate(isEven ? Math.PI/4 : -Math.PI/4);

                  const variation = (bsRand(row * 5 + col * 11) - 0.5) * 15;
                  ctx.fillStyle = adjustColor(el.color, variation);
                  ctx.fillRect(-hbW/2 + 1, -hbH/4 + 1, hbW - 2, hbH/2 - 2);

                  ctx.restore();
                }
              }
              ctx.restore();
              break;

            case 'hexagon':
              // Hexagon tiles
              const hexR = Math.max(10, Math.min(w, h) / 6);
              const hexH = hexR * Math.sqrt(3);
              let hexRow = 0;

              for (let ty = y - hexH; ty < y + h + hexH; ty += hexH * 0.75) {
                const offset = (hexRow % 2) * (hexR * 1.5);
                for (let tx = x - hexR + offset; tx < x + w + hexR * 2; tx += hexR * 3) {
                  const variation = (bsRand(hexRow * 7 + tx) - 0.5) * 15;
                  ctx.fillStyle = adjustColor(el.color, variation);
                  ctx.beginPath();
                  for (let i = 0; i < 6; i++) {
                    const angle = (Math.PI / 3) * i - Math.PI / 6;
                    const hx = tx + hexR * Math.cos(angle);
                    const hy = ty + hexR * Math.sin(angle);
                    if (i === 0) ctx.moveTo(hx, hy);
                    else ctx.lineTo(hx, hy);
                  }
                  ctx.closePath();
                  ctx.fill();
                  ctx.strokeStyle = 'rgba(100,100,100,0.3)';
                  ctx.lineWidth = 1;
                  ctx.stroke();
                }
                hexRow++;
              }
              break;

            case 'slab':
              // Full slab (like matching countertop)
              drawCountertopSurface(ctx, x, y, w, h, el.color, el.materialName);
              break;

            default:
              // Default grid tiles
              const defTileSize = Math.max(15, Math.min(w, h) / 4);
              for (let ty = y; ty < y + h; ty += defTileSize) {
                for (let tx = x; tx < x + w; tx += defTileSize) {
                  const variation = (bsRand(tx + ty * 3) - 0.5) * 12;
                  ctx.fillStyle = adjustColor(el.color, variation);
                  ctx.fillRect(tx + 1, ty + 1, defTileSize - 2, defTileSize - 2);

                  ctx.fillStyle = 'rgba(255,255,255,0.1)';
                  ctx.fillRect(tx + 1, ty + 1, defTileSize - 2, 2);
                  ctx.fillRect(tx + 1, ty + 1, 2, defTileSize - 2);
                }
              }
          }
          break;

        case 'sink':
          // Draw sink basin
          const basinPadding = Math.min(w, h) * 0.15;
          ctx.strokeStyle = 'rgba(100,150,200,0.5)';
          ctx.lineWidth = 2;
          // Outer rim
          ctx.strokeRect(x + basinPadding, y + basinPadding, w - basinPadding * 2, h - basinPadding * 2);
          // Inner basin
          ctx.fillStyle = 'rgba(100,150,200,0.2)';
          ctx.fillRect(x + basinPadding + 4, y + basinPadding + 4, w - basinPadding * 2 - 8, h - basinPadding * 2 - 8);
          // Drain
          ctx.fillStyle = 'rgba(80,80,80,0.6)';
          ctx.beginPath();
          ctx.arc(x + w/2, y + h/2, Math.min(w, h) * 0.08, 0, Math.PI * 2);
          ctx.fill();
          // Faucet
          ctx.fillStyle = 'rgba(180,180,180,0.7)';
          ctx.fillRect(x + w/2 - 6, y + basinPadding - 8, 12, 10);
          ctx.beginPath();
          ctx.arc(x + w/2, y + basinPadding - 8, 6, Math.PI, 0);
          ctx.fill();
          break;

        case 'stove':
          // Draw stove burners
          ctx.strokeStyle = 'rgba(50,50,50,0.8)';
          ctx.lineWidth = 2;
          const burnerRadius = Math.min(w, h) * 0.15;
          const positions = [
            [x + w * 0.3, y + h * 0.35],
            [x + w * 0.7, y + h * 0.35],
            [x + w * 0.3, y + h * 0.7],
            [x + w * 0.7, y + h * 0.7]
          ];
          positions.forEach(([bx, by]) => {
            // Outer ring
            ctx.beginPath();
            ctx.arc(bx, by, burnerRadius, 0, Math.PI * 2);
            ctx.stroke();
            // Inner ring
            ctx.beginPath();
            ctx.arc(bx, by, burnerRadius * 0.6, 0, Math.PI * 2);
            ctx.stroke();
            // Grate lines
            ctx.beginPath();
            ctx.moveTo(bx - burnerRadius, by);
            ctx.lineTo(bx + burnerRadius, by);
            ctx.moveTo(bx, by - burnerRadius);
            ctx.lineTo(bx, by + burnerRadius);
            ctx.stroke();
          });
          // Control panel area
          ctx.fillStyle = 'rgba(40,40,40,0.5)';
          ctx.fillRect(x + padding, y + padding, w - padding * 2, h * 0.12);
          break;

        case 'refrigerator':
          // Draw refrigerator doors
          ctx.strokeStyle = 'rgba(150,150,150,0.5)';
          ctx.lineWidth = 2;
          const fridgeMid = y + h * 0.65;
          // Upper section (freezer)
          ctx.strokeRect(x + padding, y + padding, w - padding * 2, fridgeMid - y - padding * 1.5);
          // Lower section (fridge)
          ctx.strokeRect(x + padding, fridgeMid, w - padding * 2, y + h - fridgeMid - padding);
          // Handles
          ctx.fillStyle = 'rgba(200,200,200,0.6)';
          ctx.fillRect(x + w - padding - 6, y + (fridgeMid - y) / 2 - 12, 3, 24);
          ctx.fillRect(x + w - padding - 6, fridgeMid + (y + h - fridgeMid) / 2 - 15, 3, 30);
          // Ice dispenser
          ctx.fillStyle = 'rgba(60,60,60,0.4)';
          ctx.fillRect(x + w * 0.3, y + padding + 10, w * 0.4, 15);
          break;

        case 'dishwasher':
          // Draw dishwasher front
          ctx.strokeStyle = 'rgba(120,120,120,0.5)';
          ctx.lineWidth = 1.5;
          // Main door
          ctx.strokeRect(x + padding, y + padding, w - padding * 2, h - padding * 2);
          // Control panel
          ctx.fillStyle = 'rgba(60,60,60,0.4)';
          ctx.fillRect(x + padding + 4, y + padding + 4, w - padding * 2 - 8, h * 0.12);
          // Handle
          ctx.fillStyle = 'rgba(180,180,180,0.6)';
          ctx.fillRect(x + padding + 8, y + h * 0.18, w - padding * 2 - 16, 4);
          break;

        case 'flooring':
          // Draw realistic wood plank flooring with grain
          const plankHeight = pixelsPerFoot * 0.35;
          const plankWidth = pixelsPerFoot * 2;
          const floorSeed = (el.x * 11 + el.y * 13) % 50;

          // Draw planks with stagger pattern
          let rowNum = 0;
          for (let py = y; py < y + h; py += plankHeight) {
            // Row offset for stagger (1/3 offset alternating)
            const rowOffset = (rowNum % 3) * (plankWidth / 3);
            let plankNum = 0;

            for (let px = x - rowOffset; px < x + w; px += plankWidth) {
              if (px + plankWidth < x) continue; // Skip if completely off left
              if (px > x + w) break; // Stop if completely off right

              // Clamp plank to element bounds
              const drawX = Math.max(px, x);
              const drawW = Math.min(px + plankWidth, x + w) - drawX;
              const drawY = Math.max(py, y);
              const drawH = Math.min(py + plankHeight, y + h) - drawY;

              if (drawW > 0 && drawH > 0) {
                // Plank base with slight color variation
                const variation = ((floorSeed + rowNum * 7 + plankNum * 3) % 20 - 10) / 100;
                ctx.fillStyle = `rgba(${255 * variation > 0 ? 255 : 0},${255 * variation > 0 ? 255 : 0},${255 * variation > 0 ? 255 : 0},${Math.abs(variation)})`;
                ctx.fillRect(drawX, drawY, drawW, drawH);

                // Plank border (groove between planks)
                ctx.strokeStyle = 'rgba(0,0,0,0.2)';
                ctx.lineWidth = 1;
                ctx.strokeRect(drawX + 0.5, drawY + 0.5, drawW - 1, drawH - 1);

                // Wood grain lines
                ctx.strokeStyle = 'rgba(0,0,0,0.06)';
                ctx.lineWidth = 0.5;
                const grainCount = Math.floor(drawH / 4);
                for (let g = 0; g < grainCount; g++) {
                  const gy = drawY + 2 + g * (drawH - 4) / grainCount;
                  const wave = Math.sin((floorSeed + plankNum + g) * 0.5) * 2;
                  ctx.beginPath();
                  ctx.moveTo(drawX + 2, gy);
                  ctx.bezierCurveTo(
                    drawX + drawW * 0.3, gy + wave,
                    drawX + drawW * 0.7, gy - wave,
                    drawX + drawW - 2, gy + wave * 0.5
                  );
                  ctx.stroke();
                }

                // Subtle knot marks occasionally
                if ((floorSeed + rowNum + plankNum) % 7 === 0) {
                  ctx.fillStyle = 'rgba(0,0,0,0.08)';
                  ctx.beginPath();
                  ctx.ellipse(
                    drawX + Math.abs(drawW) * 0.6,
                    drawY + Math.abs(drawH) * 0.5,
                    3, 5, 0.3, 0, Math.PI * 2
                  );
                  ctx.fill();
                }
              }
              plankNum++;
            }
            rowNum++;
          }
          break;

        case 'tile':
          // Draw realistic tile pattern with grout lines and variation
          const tileSz = Math.min(pixelsPerFoot * 0.5, Math.min(w, h) / 3);
          const groutWidth = 2;
          const tileSeed = (el.x * 17 + el.y * 23) % 100;

          // Draw tiles
          let tileRow = 0;
          for (let ty = y; ty < y + h; ty += tileSz) {
            let tileCol = 0;
            for (let tx = x; tx < x + w; tx += tileSz) {
              const tileW = Math.min(tileSz - groutWidth, x + w - tx - groutWidth);
              const tileH = Math.min(tileSz - groutWidth, y + h - ty - groutWidth);

              if (tileW > 0 && tileH > 0) {
                // Subtle color variation per tile
                const variation = ((tileSeed + tileRow * 5 + tileCol * 3) % 15) / 100;
                ctx.fillStyle = `rgba(255,255,255,${0.02 + variation * 0.03})`;
                ctx.fillRect(tx + 1, ty + 1, tileW, tileH);

                // Tile surface texture (subtle speckling)
                ctx.fillStyle = 'rgba(255,255,255,0.03)';
                for (let s = 0; s < 3; s++) {
                  const sx = tx + 5 + ((tileSeed + tileCol + s * 7) % (tileW - 10));
                  const sy = ty + 5 + ((tileSeed + tileRow + s * 11) % (tileH - 10));
                  ctx.beginPath();
                  ctx.arc(sx, sy, 1, 0, Math.PI * 2);
                  ctx.fill();
                }

                // Light reflection on tile edge (top-left highlight)
                ctx.fillStyle = 'rgba(255,255,255,0.08)';
                ctx.fillRect(tx + 1, ty + 1, tileW, 1);
                ctx.fillRect(tx + 1, ty + 1, 1, tileH);
              }
              tileCol++;
            }
            tileRow++;
          }

          // Grout lines (darker)
          ctx.strokeStyle = 'rgba(100,100,100,0.4)';
          ctx.lineWidth = groutWidth;
          for (let tx = x; tx <= x + w; tx += tileSz) {
            ctx.beginPath();
            ctx.moveTo(tx, y);
            ctx.lineTo(tx, y + h);
            ctx.stroke();
          }
          for (let ty = y; ty <= y + h; ty += tileSz) {
            ctx.beginPath();
            ctx.moveTo(x, ty);
            ctx.lineTo(x + w, ty);
            ctx.stroke();
          }
          break;

        case 'door':
          // Draw door with swing arc
          ctx.strokeStyle = 'rgba(255,255,255,0.4)';
          ctx.lineWidth = 1.5;
          // Door panel
          ctx.fillStyle = 'rgba(180,140,100,0.3)';
          ctx.fillRect(x, y, w * 0.1, h);
          // Swing arc
          ctx.beginPath();
          ctx.arc(x, y + h, w * 0.9, -Math.PI/2, 0);
          ctx.stroke();
          // Door line
          ctx.beginPath();
          ctx.moveTo(x, y + h);
          ctx.lineTo(x + w * 0.9, y + h);
          ctx.stroke();
          break;

        case 'window':
          // Draw window with transparent glass effect showing "outside"
          // Outer frame (white)
          ctx.strokeStyle = 'rgba(255,255,255,0.9)';
          ctx.lineWidth = 4;
          ctx.strokeRect(x + 2, y + 2, w - 4, h - 4);

          // Sky gradient background (simulated outdoor view)
          const skyGradient = ctx.createLinearGradient(x, y, x, y + h);
          skyGradient.addColorStop(0, 'rgba(135,206,250,0.7)'); // Light sky blue
          skyGradient.addColorStop(0.6, 'rgba(176,224,230,0.6)'); // Powder blue
          skyGradient.addColorStop(1, 'rgba(144,238,144,0.5)'); // Light green (trees/ground)
          ctx.fillStyle = skyGradient;
          ctx.fillRect(x + 6, y + 6, w - 12, h - 12);

          // Glass reflection effect (diagonal shine)
          ctx.strokeStyle = 'rgba(255,255,255,0.3)';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(x + w * 0.2, y + 4);
          ctx.lineTo(x + 4, y + h * 0.3);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(x + w * 0.35, y + 4);
          ctx.lineTo(x + 4, y + h * 0.5);
          ctx.stroke();

          // Center divider (mullion)
          ctx.strokeStyle = 'rgba(255,255,255,0.8)';
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.moveTo(x + w/2, y + 4);
          ctx.lineTo(x + w/2, y + h - 4);
          ctx.stroke();

          // Horizontal divider for classic look
          ctx.beginPath();
          ctx.moveTo(x + 4, y + h/2);
          ctx.lineTo(x + w - 4, y + h/2);
          ctx.stroke();
          break;

        case 'wall':
        case 'wall-wood-2x4':
        case 'wall-wood-2x6':
          // Wall section with hatch pattern
          ctx.strokeStyle = 'rgba(255,255,255,0.2)';
          ctx.lineWidth = 1;
          const step = 8;
          for (let i = 0; i < Math.max(w, h) * 2; i += step) {
            ctx.beginPath();
            ctx.moveTo(x + i, y);
            ctx.lineTo(x, y + i);
            ctx.stroke();
          }
          // Wood grain for wood walls
          if (type.includes('wood')) {
            ctx.strokeStyle = 'rgba(139,69,19,0.3)';
            ctx.lineWidth = 0.5;
            for (let g = 0; g < 3; g++) {
              ctx.beginPath();
              ctx.moveTo(x + g * w/3, y);
              ctx.lineTo(x + g * w/3, y + h);
              ctx.stroke();
            }
          }
          break;

        case 'wall-steel':
        case 'wall-aluminum':
          // Metal stud pattern
          ctx.strokeStyle = type.includes('steel') ? 'rgba(112,128,144,0.6)' : 'rgba(192,192,192,0.6)';
          ctx.lineWidth = 2;
          const studSpacing = pixelsPerFoot * 1.33; // 16" on center
          for (let sx = x; sx <= x + w; sx += studSpacing) {
            ctx.beginPath();
            ctx.moveTo(sx, y);
            ctx.lineTo(sx, y + h);
            ctx.stroke();
          }
          // Track at top and bottom
          ctx.fillStyle = type.includes('steel') ? 'rgba(112,128,144,0.4)' : 'rgba(192,192,192,0.4)';
          ctx.fillRect(x, y, w, 4);
          ctx.fillRect(x, y + h - 4, w, 4);
          break;

        case 'wall-concrete':
          // Concrete texture
          ctx.fillStyle = 'rgba(128,128,128,0.3)';
          ctx.fillRect(x, y, w, h);
          // Aggregate speckles
          ctx.fillStyle = 'rgba(100,100,100,0.4)';
          for (let i = 0; i < 10; i++) {
            const cx = x + (Math.random() * w);
            const cy = y + (Math.random() * h);
            ctx.beginPath();
            ctx.arc(cx, cy, Math.random() * 3 + 1, 0, Math.PI * 2);
            ctx.fill();
          }
          break;

        case 'wall-brick':
          // Brick pattern
          const brickH = pixelsPerFoot * 0.25;
          const brickW = pixelsPerFoot * 0.67;
          ctx.strokeStyle = 'rgba(139,69,19,0.5)';
          ctx.lineWidth = 1;
          let brickRow = 0;
          for (let by = y; by < y + h; by += brickH) {
            const offset = (brickRow % 2) * (brickW / 2);
            for (let bx = x - offset; bx < x + w; bx += brickW) {
              if (bx + brickW > x && bx < x + w) {
                ctx.strokeRect(Math.max(bx, x), by, Math.min(brickW, x + w - bx), brickH);
              }
            }
            brickRow++;
          }
          break;

        case 'wall-block':
          // CMU block pattern
          const blockH = pixelsPerFoot * 0.67;
          const blockW = pixelsPerFoot * 1.33;
          ctx.strokeStyle = 'rgba(80,80,80,0.5)';
          ctx.lineWidth = 2;
          let blockRow = 0;
          for (let by = y; by < y + h; by += blockH) {
            const offset = (blockRow % 2) * (blockW / 2);
            for (let bx = x - offset; bx < x + w; bx += blockW) {
              if (bx + blockW > x && bx < x + w) {
                ctx.strokeRect(Math.max(bx, x), by, Math.min(blockW, x + w - bx), blockH);
              }
            }
            blockRow++;
          }
          break;

        case 'double-door':
          // Double door with two panels
          ctx.strokeStyle = 'rgba(255,255,255,0.4)';
          ctx.lineWidth = 1.5;
          ctx.fillStyle = 'rgba(180,140,100,0.3)';
          // Left door
          ctx.fillRect(x, y, w * 0.05, h);
          ctx.beginPath();
          ctx.arc(x, y + h, w * 0.45, -Math.PI/2, 0);
          ctx.stroke();
          // Right door
          ctx.fillRect(x + w * 0.95, y, w * 0.05, h);
          ctx.beginPath();
          ctx.arc(x + w, y + h, w * 0.45, Math.PI, -Math.PI/2);
          ctx.stroke();
          break;

        case 'sliding-door':
          // Sliding glass door
          ctx.fillStyle = 'rgba(173,216,230,0.3)';
          ctx.fillRect(x, y, w, h);
          ctx.strokeStyle = 'rgba(100,100,100,0.6)';
          ctx.lineWidth = 2;
          ctx.strokeRect(x, y, w, h);
          // Sliding panels
          ctx.strokeStyle = 'rgba(80,80,80,0.5)';
          ctx.beginPath();
          ctx.moveTo(x + w/2, y);
          ctx.lineTo(x + w/2, y + h);
          ctx.stroke();
          // Arrow indicating slide direction
          ctx.fillStyle = 'rgba(255,255,255,0.4)';
          ctx.beginPath();
          ctx.moveTo(x + w * 0.35, y + h/2);
          ctx.lineTo(x + w * 0.25, y + h/2 - 5);
          ctx.lineTo(x + w * 0.25, y + h/2 + 5);
          ctx.fill();
          break;

        case 'entry-archway':
          // Archway opening - shows as a transparent passthrough
          const archFrameWidth = Math.max(4, w * 0.08);

          // Draw "through" view - darker to simulate depth/another room
          ctx.fillStyle = 'rgba(60,60,70,0.4)';
          ctx.beginPath();
          ctx.moveTo(x + archFrameWidth, y + h);
          ctx.lineTo(x + archFrameWidth, y + h * 0.35);
          ctx.quadraticCurveTo(x + w/2, y + archFrameWidth, x + w - archFrameWidth, y + h * 0.35);
          ctx.lineTo(x + w - archFrameWidth, y + h);
          ctx.closePath();
          ctx.fill();

          // Inner shadow for depth
          ctx.fillStyle = 'rgba(40,40,50,0.3)';
          ctx.beginPath();
          ctx.moveTo(x + archFrameWidth, y + h);
          ctx.lineTo(x + archFrameWidth, y + h * 0.35);
          ctx.lineTo(x + archFrameWidth + 8, y + h * 0.38);
          ctx.lineTo(x + archFrameWidth + 8, y + h);
          ctx.closePath();
          ctx.fill();

          // Arch frame (outer edge - golden/wood color)
          ctx.strokeStyle = 'rgba(218,165,32,0.9)';
          ctx.lineWidth = archFrameWidth;
          ctx.beginPath();
          ctx.moveTo(x + archFrameWidth/2, y + h);
          ctx.lineTo(x + archFrameWidth/2, y + h * 0.3);
          ctx.quadraticCurveTo(x + w/2, y, x + w - archFrameWidth/2, y + h * 0.3);
          ctx.lineTo(x + w - archFrameWidth/2, y + h);
          ctx.stroke();

          // Inner edge highlight
          ctx.strokeStyle = 'rgba(255,235,180,0.5)';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(x + archFrameWidth, y + h);
          ctx.lineTo(x + archFrameWidth, y + h * 0.35);
          ctx.quadraticCurveTo(x + w/2, y + archFrameWidth, x + w - archFrameWidth, y + h * 0.35);
          ctx.lineTo(x + w - archFrameWidth, y + h);
          ctx.stroke();
          break;

        case 'garage-door':
          // Garage door with sections
          ctx.fillStyle = 'rgba(169,169,169,0.4)';
          ctx.fillRect(x, y, w, h);
          ctx.strokeStyle = 'rgba(100,100,100,0.6)';
          ctx.lineWidth = 2;
          ctx.strokeRect(x, y, w, h);
          // Panel sections
          const panelH = h / 4;
          for (let py = y + panelH; py < y + h; py += panelH) {
            ctx.beginPath();
            ctx.moveTo(x, py);
            ctx.lineTo(x + w, py);
            ctx.stroke();
          }
          // Handle
          ctx.fillStyle = 'rgba(80,80,80,0.6)';
          ctx.fillRect(x + w/2 - 10, y + h - panelH/2 - 3, 20, 6);
          break;

        case 'corner-cabinet':
          // Draw L-shaped corner cabinet with realistic cabinet details
          const ccArmW = w * 0.48;
          const ccArmH = h * 0.48;

          // L-shape shadow
          ctx.fillStyle = 'rgba(0,0,0,0.35)';
          ctx.beginPath();
          ctx.moveTo(x + padding + 4, y + padding + 4);
          ctx.lineTo(x + padding + 4, y + h - padding + 4);
          ctx.lineTo(x + ccArmW + 4, y + h - padding + 4);
          ctx.lineTo(x + ccArmW + 4, y + ccArmH + 4);
          ctx.lineTo(x + w - padding + 4, y + ccArmH + 4);
          ctx.lineTo(x + w - padding + 4, y + padding + 4);
          ctx.closePath();
          ctx.fill();

          // L-shape cabinet body
          ctx.fillStyle = el.color;
          ctx.beginPath();
          ctx.moveTo(x + padding, y + padding);
          ctx.lineTo(x + padding, y + h - padding);
          ctx.lineTo(x + ccArmW, y + h - padding);
          ctx.lineTo(x + ccArmW, y + ccArmH);
          ctx.lineTo(x + w - padding, y + ccArmH);
          ctx.lineTo(x + w - padding, y + padding);
          ctx.closePath();
          ctx.fill();

          // Wood grain on L-shape
          ctx.save();
          ctx.beginPath();
          ctx.moveTo(x + padding, y + padding);
          ctx.lineTo(x + padding, y + h - padding);
          ctx.lineTo(x + ccArmW, y + h - padding);
          ctx.lineTo(x + ccArmW, y + ccArmH);
          ctx.lineTo(x + w - padding, y + ccArmH);
          ctx.lineTo(x + w - padding, y + padding);
          ctx.closePath();
          ctx.clip();
          drawWoodGrain(ctx, x, y, w, h, el.color, 0.5);
          ctx.restore();

          // Diagonal door panel
          ctx.fillStyle = adjustColor(el.color, -10);
          ctx.beginPath();
          ctx.moveTo(x + ccArmW + 4, y + ccArmH + 4);
          ctx.lineTo(x + ccArmW + 4, y + h - padding - 4);
          ctx.lineTo(x + w - padding - 4, y + ccArmH + 4);
          ctx.closePath();
          ctx.fill();

          // Door panel shaker inset
          ctx.strokeStyle = 'rgba(0,0,0,0.2)';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(x + ccArmW + 14, y + ccArmH + 14);
          ctx.lineTo(x + ccArmW + 14, y + h - padding - 14);
          ctx.lineTo(x + w - padding - 14, y + ccArmH + 14);
          ctx.closePath();
          ctx.stroke();

          // Edge highlights on L-shape
          ctx.fillStyle = 'rgba(255,255,255,0.12)';
          ctx.fillRect(x + padding, y + padding, w - padding * 2, 2);
          ctx.fillRect(x + padding, y + padding, 2, h - padding * 2);

          ctx.fillStyle = 'rgba(0,0,0,0.15)';
          ctx.fillRect(x + padding, y + h - padding - 2, ccArmW - padding, 2);
          ctx.fillRect(x + w - padding - 2, y + padding, 2, ccArmH);

          // Lazy Susan circle indicator (inside cabinet)
          ctx.strokeStyle = 'rgba(255,255,255,0.2)';
          ctx.lineWidth = 1;
          const lsCenter = { x: x + w * 0.5, y: y + h * 0.5 };
          const lsRadius = Math.min(w, h) * 0.18;
          ctx.beginPath();
          ctx.arc(lsCenter.x, lsCenter.y, lsRadius, 0, Math.PI * 2);
          ctx.stroke();
          ctx.beginPath();
          ctx.arc(lsCenter.x, lsCenter.y, lsRadius * 0.5, 0, Math.PI * 2);
          ctx.stroke();

          // Handle on diagonal door
          const handleAngle = Math.PI / 4;
          const handleLen = 16;
          ctx.save();
          ctx.translate(x + ccArmW + (w - ccArmW) * 0.6, y + ccArmH + (h - ccArmH) * 0.4);
          ctx.rotate(handleAngle);
          // Handle shadow
          ctx.fillStyle = 'rgba(0,0,0,0.3)';
          ctx.fillRect(-1.5 + 2, -handleLen/2 + 2, 3, handleLen);
          // Handle body
          ctx.fillStyle = 'rgba(180,180,180,0.85)';
          ctx.fillRect(-1.5, -handleLen/2, 3, handleLen);
          ctx.fillStyle = 'rgba(255,255,255,0.3)';
          ctx.fillRect(-1.5, -handleLen/2, 1, handleLen);
          ctx.restore();

          // Toe kick
          ctx.fillStyle = 'rgba(0,0,0,0.5)';
          ctx.fillRect(x + padding + 2, y + h - padding - 3, ccArmW - padding - 4, 3);
          ctx.fillRect(x + ccArmW, y + ccArmH + 2, 3, h - ccArmH - padding - 4);
          break;

        case 'microwave':
          // Draw microwave front
          ctx.strokeStyle = 'rgba(100,100,100,0.6)';
          ctx.lineWidth = 1.5;
          // Door frame
          ctx.strokeRect(x + padding, y + padding, w * 0.75 - padding, h - padding * 2);
          // Glass window
          ctx.fillStyle = 'rgba(20,20,20,0.4)';
          ctx.fillRect(x + padding + 4, y + padding + 4, w * 0.75 - padding - 8, h - padding * 2 - 8);
          // Control panel
          ctx.fillStyle = 'rgba(60,60,60,0.5)';
          ctx.fillRect(x + w * 0.78, y + padding, w * 0.2 - padding, h - padding * 2);
          // Buttons
          ctx.fillStyle = 'rgba(100,100,100,0.6)';
          for (let i = 0; i < 3; i++) {
            ctx.fillRect(x + w * 0.82, y + padding + 8 + i * 12, 8, 8);
          }
          // Handle
          ctx.fillStyle = 'rgba(180,180,180,0.6)';
          ctx.fillRect(x + w * 0.72, y + h/2 - 10, 3, 20);
          break;

        case 'range-hood':
          // Draw range hood (trapezoidal shape from above)
          ctx.strokeStyle = 'rgba(120,120,120,0.6)';
          ctx.lineWidth = 2;
          // Outer shape
          ctx.beginPath();
          ctx.moveTo(x + padding, y + h - padding);
          ctx.lineTo(x + w * 0.2, y + padding);
          ctx.lineTo(x + w * 0.8, y + padding);
          ctx.lineTo(x + w - padding, y + h - padding);
          ctx.closePath();
          ctx.stroke();
          // Filter lines
          ctx.strokeStyle = 'rgba(150,150,150,0.4)';
          ctx.lineWidth = 1;
          const filterLines = 4;
          for (let i = 1; i < filterLines; i++) {
            const yPos = y + padding + (h - padding * 2) * (i / filterLines);
            ctx.beginPath();
            ctx.moveTo(x + w * 0.25, yPos);
            ctx.lineTo(x + w * 0.75, yPos);
            ctx.stroke();
          }
          // Vent duct indicator
          ctx.fillStyle = 'rgba(80,80,80,0.4)';
          ctx.beginPath();
          ctx.arc(x + w/2, y + h * 0.3, Math.min(w, h) * 0.12, 0, Math.PI * 2);
          ctx.fill();
          break;

        case 'oven':
          // Draw wall oven
          ctx.strokeStyle = 'rgba(100,100,100,0.5)';
          ctx.lineWidth = 1.5;
          // Outer frame
          ctx.strokeRect(x + padding, y + padding, w - padding * 2, h - padding * 2);
          // Glass window
          ctx.fillStyle = 'rgba(30,30,30,0.5)';
          ctx.fillRect(x + padding + 6, y + h * 0.25, w - padding * 2 - 12, h * 0.5);
          // Window reflection
          ctx.strokeStyle = 'rgba(255,255,255,0.15)';
          ctx.beginPath();
          ctx.moveTo(x + padding + 10, y + h * 0.3);
          ctx.lineTo(x + w - padding - 20, y + h * 0.3);
          ctx.stroke();
          // Control panel
          ctx.fillStyle = 'rgba(50,50,50,0.6)';
          ctx.fillRect(x + padding + 6, y + padding + 4, w - padding * 2 - 12, h * 0.12);
          // Control knobs
          ctx.fillStyle = 'rgba(120,120,120,0.7)';
          const knobCount = 4;
          for (let i = 0; i < knobCount; i++) {
            const kx = x + padding + 15 + i * (w - padding * 2 - 30) / (knobCount - 1);
            ctx.beginPath();
            ctx.arc(kx, y + padding + 10, 4, 0, Math.PI * 2);
            ctx.fill();
          }
          // Handle
          ctx.fillStyle = 'rgba(180,180,180,0.6)';
          ctx.fillRect(x + w * 0.3, y + h * 0.78, w * 0.4, 3);
          break;
      }

      ctx.lineWidth = 1;
    }

    function drawElements() {
      // Define z-order for element types (lower = drawn first = below)
      const zOrder = {
        'flooring': 0,
        'tile': 1,
        'island': 2,
        'base-cabinet': 3,
        'corner-cabinet': 3,
        'tall-cabinet': 4,
        'countertop': 5,  // Above cabinets
        'backsplash': 6,
        'wall-cabinet': 7,
        'range': 8,
        'cooktop': 8,
        'refrigerator': 8,
        'dishwasher': 8,
        'microwave': 8,
        'sink': 9,
        'wall': 10
      };

      // Sort elements by z-order, then draw selected element last
      const sortedElements = [...elements].sort((a, b) => {
        // Selected element always draws last (on top)
        if (a === selectedElement) return 1;
        if (b === selectedElement) return -1;
        return (zOrder[a.type] || 5) - (zOrder[b.type] || 5);
      });

      sortedElements.forEach(el => {
        drawElement(el, el === selectedElement);
      });
    }

    function drawElement(el, isSelected) {
      const x = el.x;
      const y = el.y;
      const w = el.width * pixelsPerFoot;
      const h = el.height * pixelsPerFoot;

      ctx.save();
      ctx.translate(x + w/2, y + h/2);
      ctx.rotate((el.rotation || 0) * Math.PI / 180);
      ctx.translate(-(x + w/2), -(y + h/2));

      // Background with slight shadow
      ctx.shadowColor = 'rgba(0,0,0,0.4)';
      ctx.shadowBlur = 10;
      ctx.shadowOffsetX = 3;
      ctx.shadowOffsetY = 3;

      // Draw base shape with texture or color
      if (el.textureImg) {
        ctx.drawImage(el.textureImg, x, y, w, h);
      } else {
        ctx.fillStyle = el.color;
        ctx.fillRect(x, y, w, h);
      }

      // Reset shadow
      ctx.shadowColor = 'transparent';
      ctx.shadowBlur = 0;
      ctx.shadowOffsetX = 0;
      ctx.shadowOffsetY = 0;

      // Draw architectural details based on element type
      drawElementDetails(el, x, y, w, h);

      // Border
      ctx.strokeStyle = isSelected ? '#6366f1' : 'rgba(255,255,255,0.3)';
      ctx.lineWidth = isSelected ? 3 : 1.5;
      ctx.strokeRect(x, y, w, h);

      // Only show label if element is large enough or selected
      const showLabel = w > 60 || h > 60 || isSelected;
      if (showLabel) {
        const labelFontSize = Math.max(9, Math.min(14, pixelsPerFoot / 3));
        ctx.font = `${labelFontSize}px Inter`;
        const labelWidth = ctx.measureText(el.label).width + 8;

        // Label background
        ctx.fillStyle = 'rgba(0,0,0,0.6)';
        ctx.fillRect(x + w/2 - labelWidth/2, y + h - labelFontSize - 8, labelWidth, labelFontSize + 4);

        // Label text
        ctx.fillStyle = 'rgba(255,255,255,0.95)';
        ctx.textAlign = 'center';
        ctx.fillText(el.label, x + w/2, y + h - 6);
      }

      // Dimensions (only when selected)
      if (isSelected) {
        ctx.fillStyle = '#6366f1';
        ctx.font = `bold ${Math.max(10, pixelsPerFoot / 4)}px Inter`;
        ctx.fillText(formatSize(el.width, el.height), x + w/2, y - 8);
      }

      // Lock icon (drawn in rotated context)
      if (isSelected && el.locked) {
        ctx.fillStyle = 'rgba(239, 68, 68, 0.9)';
        ctx.font = '14px Inter';
        ctx.fillText('', x + w - 12, y + 16);
      }

      // Restore context BEFORE drawing handles (handles use world coordinates)
      ctx.restore();

      // Selection handles (8 handles for resize) - drawn in world space
      if (isSelected && !el.locked) {
        const hs = HANDLE_SIZE;
        ctx.fillStyle = '#6366f1';
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;

        // Get all 8 handle positions (already in world coordinates with rotation applied)
        const handles = getResizeHandles(el);
        Object.values(handles).forEach(handle => {
          ctx.fillRect(handle.x - hs/2, handle.y - hs/2, hs, hs);
          ctx.strokeRect(handle.x - hs/2, handle.y - hs/2, hs, hs);
        });
      }

      // Locked element handles - drawn in world space
      if (isSelected && el.locked) {
        const hs = HANDLE_SIZE;
        ctx.fillStyle = '#ef4444';
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        // Use rotated handle positions for locked elements too
        const handles = getResizeHandles(el);
        [handles.nw, handles.ne, handles.sw, handles.se].forEach(handle => {
          ctx.fillRect(handle.x - hs/2, handle.y - hs/2, hs, hs);
          ctx.strokeRect(handle.x - hs/2, handle.y - hs/2, hs, hs);
        });
      }
    }

    // ===== RESIZE HANDLES =====
    function getResizeHandles(el) {
      const x = el.x;
      const y = el.y;
      const w = el.width * pixelsPerFoot;
      const h = el.height * pixelsPerFoot;
      const rotation = (el.rotation || 0) * Math.PI / 180;
      const cx = x + w / 2;
      const cy = y + h / 2;

      // Helper to rotate a point around the center
      function rotatePoint(px, py) {
        if (rotation === 0) return { x: px, y: py };
        const dx = px - cx;
        const dy = py - cy;
        const cosR = Math.cos(rotation);
        const sinR = Math.sin(rotation);
        return {
          x: cx + dx * cosR - dy * sinR,
          y: cy + dx * sinR + dy * cosR
        };
      }

      // Get rotated handle positions
      const nw = rotatePoint(x, y);
      const n = rotatePoint(x + w/2, y);
      const ne = rotatePoint(x + w, y);
      const e = rotatePoint(x + w, y + h/2);
      const se = rotatePoint(x + w, y + h);
      const s = rotatePoint(x + w/2, y + h);
      const sw = rotatePoint(x, y + h);
      const west = rotatePoint(x, y + h/2);

      return {
        nw: { ...nw, cursor: 'nwse-resize' },
        n:  { ...n, cursor: 'ns-resize' },
        ne: { ...ne, cursor: 'nesw-resize' },
        e:  { ...e, cursor: 'ew-resize' },
        se: { ...se, cursor: 'nwse-resize' },
        s:  { ...s, cursor: 'ns-resize' },
        sw: { ...sw, cursor: 'nesw-resize' },
        w:  { ...west, cursor: 'ew-resize' }
      };
    }

    function getHandleAtPosition(el, worldX, worldY) {
      if (!el || el.locked) return null;

      const handles = getResizeHandles(el);
      const hs = HANDLE_SIZE + 4; // Slightly larger hit area

      for (const [name, handle] of Object.entries(handles)) {
        if (worldX >= handle.x - hs/2 && worldX <= handle.x + hs/2 &&
            worldY >= handle.y - hs/2 && worldY <= handle.y + hs/2) {
          return { name, ...handle };
        }
      }
      return null;
    }

    function getCursorForHandle(handleName) {
      const cursors = {
        nw: 'nwse-resize',
        n: 'ns-resize',
        ne: 'nesw-resize',
        e: 'ew-resize',
        se: 'nwse-resize',
        s: 'ns-resize',
        sw: 'nesw-resize',
        w: 'ew-resize'
      };
      return cursors[handleName] || 'default';
    }

    function applyResize(el, handle, dx, dy) {
      // Transform world-space delta to local-space delta based on rotation
      const rotation = (el.rotation || 0) * Math.PI / 180;
      let localDx = dx;
      let localDy = dy;

      if (rotation !== 0) {
        const cosR = Math.cos(-rotation);
        const sinR = Math.sin(-rotation);
        localDx = dx * cosR - dy * sinR;
        localDy = dx * sinR + dy * cosR;
      }

      // Convert pixel delta to feet
      const dxFeet = localDx / pixelsPerFoot;
      const dyFeet = localDy / pixelsPerFoot;

      // Minimum size in feet
      const minSize = 0.5;

      // Apply resize based on which handle is being dragged
      switch(handle) {
        case 'nw':
          const newWidthNW = Math.max(minSize, resizeStart.width - dxFeet);
          const newHeightNW = Math.max(minSize, resizeStart.height - dyFeet);
          el.x = resizeStart.elX + (resizeStart.width - newWidthNW) * pixelsPerFoot;
          el.y = resizeStart.elY + (resizeStart.height - newHeightNW) * pixelsPerFoot;
          el.width = newWidthNW;
          el.height = newHeightNW;
          break;

        case 'n':
          const newHeightN = Math.max(minSize, resizeStart.height - dyFeet);
          el.y = resizeStart.elY + (resizeStart.height - newHeightN) * pixelsPerFoot;
          el.height = newHeightN;
          break;

        case 'ne':
          const newWidthNE = Math.max(minSize, resizeStart.width + dxFeet);
          const newHeightNE = Math.max(minSize, resizeStart.height - dyFeet);
          el.y = resizeStart.elY + (resizeStart.height - newHeightNE) * pixelsPerFoot;
          el.width = newWidthNE;
          el.height = newHeightNE;
          break;

        case 'e':
          el.width = Math.max(minSize, resizeStart.width + dxFeet);
          break;

        case 'se':
          el.width = Math.max(minSize, resizeStart.width + dxFeet);
          el.height = Math.max(minSize, resizeStart.height + dyFeet);
          break;

        case 's':
          el.height = Math.max(minSize, resizeStart.height + dyFeet);
          break;

        case 'sw':
          const newWidthSW = Math.max(minSize, resizeStart.width - dxFeet);
          el.x = resizeStart.elX + (resizeStart.width - newWidthSW) * pixelsPerFoot;
          el.width = newWidthSW;
          el.height = Math.max(minSize, resizeStart.height + dyFeet);
          break;

        case 'w':
          const newWidthW = Math.max(minSize, resizeStart.width - dxFeet);
          el.x = resizeStart.elX + (resizeStart.width - newWidthW) * pixelsPerFoot;
          el.width = newWidthW;
          break;
      }

      // Smart snap to standard dimensions if close, otherwise round to 1/16"
      el.width = snapToStandard(el.width, 'width');
      el.height = snapToStandard(el.height, 'depth');
      el.width = roundToSixteenth(el.width);
      el.height = roundToSixteenth(el.height);

      // Show snap indicator if snapped to standard
      const suggested = getSuggestedSize(el.type);
      if (suggested && Math.abs(el.width - suggested.width) < 0.01 && Math.abs(el.height - suggested.height) < 0.01) {
        showSnapFeedback(suggested.note);
      }
    }

    // Show brief feedback when snapping to standard
    function showSnapFeedback(message) {
      const hint = document.querySelector('.material-hint');
      if (hint) {
        const original = hint.innerHTML;
        hint.innerHTML = ` Snapped to: ${message}`;
        hint.style.borderColor = 'var(--success)';
        setTimeout(() => {
          hint.innerHTML = original;
          hint.style.borderColor = 'var(--border)';
        }, 1500);
      }
    }

    // ===== MOUSE EVENTS =====
    // Convert screen coordinates to world coordinates (accounting for pan)
    function screenToWorld(screenX, screenY) {
      return {
        x: screenX - panX,
        y: screenY - panY
      };
    }

    function onMouseDown(e) {
      const rect = canvas.getBoundingClientRect();
      const screenX = e.clientX - rect.left;
      const screenY = e.clientY - rect.top;
      const { x, y } = screenToWorld(screenX, screenY);

      // Pan tool or middle mouse button
      if (currentTool === 'pan' || e.button === 1) {
        isPanning = true;
        panStart = { x: screenX - panX, y: screenY - panY };
        canvas.style.cursor = 'grabbing';
        return;
      }

      // Space + drag to pan
      if (e.spaceKey) {
        isPanning = true;
        panStart = { x: screenX - panX, y: screenY - panY };
        return;
      }

      if (currentTool === 'wall') {
        isDrawingWall = true;
        wallStart = { x, y };
        return;
      }

      if (currentTool === 'countertop') {
        isDrawingCountertop = true;
        countertopStart = { x, y };
        return;
      }

      if (currentTool !== 'select') return;

      // Check if clicking on a resize handle of selected element
      if (selectedElement && !selectedElement.locked) {
        const handle = getHandleAtPosition(selectedElement, x, y);
        if (handle) {
          isResizing = true;
          resizeHandle = handle.name;
          resizeStart = {
            x: x,
            y: y,
            width: selectedElement.width,
            height: selectedElement.height,
            elX: selectedElement.x,
            elY: selectedElement.y
          };
          canvas.style.cursor = getCursorForHandle(handle.name);
          return;
        }
      }

      const clicked = [...elements].reverse().find(el => isPointInElement(x, y, el));

      if (clicked) {
        // If a material is selected, apply it to the clicked element
        if (selectedMaterial) {
          applyMaterialToElement(clicked);
          selectedElement = clicked;
          updateProperties();
          draw();
          return;
        }

        selectedElement = clicked;
        if (!clicked.locked) {
          isDragging = true;
          dragOffset = { x: x - clicked.x, y: y - clicked.y };
        }
        updateProperties();
      } else {
        selectedElement = null;
        updateProperties();
      }

      draw();
    }

    function onMouseMove(e) {
      const rect = canvas.getBoundingClientRect();
      const screenX = e.clientX - rect.left;
      const screenY = e.clientY - rect.top;
      const { x, y } = screenToWorld(screenX, screenY);

      // Handle panning
      if (isPanning) {
        panX = screenX - panStart.x;
        panY = screenY - panStart.y;
        draw();
        return;
      }

      // Handle resizing
      if (isResizing && selectedElement && resizeHandle) {
        const dx = x - resizeStart.x;
        const dy = y - resizeStart.y;
        applyResize(selectedElement, resizeHandle, dx, dy);
        updateProperties();
        draw();
        return;
      }

      if (isDrawingWall && wallStart) {
        // Preview wall while drawing
        draw();
        ctx.save();
        ctx.translate(panX, panY);
        ctx.fillStyle = 'rgba(100, 100, 100, 0.5)';
        const wx = Math.min(wallStart.x, x);
        const wy = Math.min(wallStart.y, y);
        const ww = Math.abs(x - wallStart.x) || CONFIG.WALL_THICKNESS;
        const wh = Math.abs(y - wallStart.y) || CONFIG.WALL_THICKNESS;
        ctx.fillRect(wx, wy, ww, wh);
        ctx.restore();
        return;
      }

      if (isDrawingCountertop && countertopStart) {
        // Preview countertop while drawing with measurements
        draw();
        ctx.save();
        ctx.translate(panX, panY);

        const cx = Math.min(countertopStart.x, x);
        const cy = Math.min(countertopStart.y, y);
        const cw = Math.abs(x - countertopStart.x) || pixelsPerFoot * 2;
        const ch = Math.abs(y - countertopStart.y) || pixelsPerFoot * 2;

        // Draw countertop preview
        ctx.fillStyle = 'rgba(112, 128, 144, 0.6)';
        ctx.fillRect(cx, cy, cw, ch);
        ctx.strokeStyle = '#708090';
        ctx.lineWidth = 2;
        ctx.strokeRect(cx, cy, cw, ch);

        // Show measurements
        const widthFt = (cw / pixelsPerFoot).toFixed(1);
        const depthFt = (ch / pixelsPerFoot).toFixed(1);
        const sqft = (widthFt * depthFt).toFixed(1);

        ctx.fillStyle = '#fff';
        ctx.font = 'bold 14px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(`${widthFt}'  ${depthFt}'`, cx + cw/2, cy + ch/2 - 10);
        ctx.font = '12px Arial';
        ctx.fillText(`${sqft} sq ft`, cx + cw/2, cy + ch/2 + 10);

        ctx.restore();
        return;
      }

      // Update cursor when hovering over resize handles
      if (selectedElement && !selectedElement.locked && !isDragging) {
        const handle = getHandleAtPosition(selectedElement, x, y);
        if (handle) {
          canvas.style.cursor = getCursorForHandle(handle.name);
        } else if (isPointInElement(x, y, selectedElement)) {
          canvas.style.cursor = 'move';
        } else {
          canvas.style.cursor = 'default';
        }
      }

      if (!isDragging || !selectedElement || selectedElement.locked) return;

      const gridSnap = pixelsPerFoot / CONFIG.GRID_SUBDIVISIONS;
      let snapX = Math.round((x - dragOffset.x) / gridSnap) * gridSnap;
      let snapY = Math.round((y - dragOffset.y) / gridSnap) * gridSnap;

      // Element-to-element snapping (for placing cabinets together)
      const snapDistance = pixelsPerFoot * 0.3; // Snap within 0.3 feet
      const elW = selectedElement.width * pixelsPerFoot;
      const elH = selectedElement.height * pixelsPerFoot;

      elements.forEach(other => {
        if (other.id === selectedElement.id) return;

        const otherX = other.x;
        const otherY = other.y;
        const otherW = other.width * pixelsPerFoot;
        const otherH = other.height * pixelsPerFoot;

        // Snap right edge of selected to left edge of other
        if (Math.abs((snapX + elW) - otherX) < snapDistance) {
          snapX = otherX - elW;
        }
        // Snap left edge of selected to right edge of other
        if (Math.abs(snapX - (otherX + otherW)) < snapDistance) {
          snapX = otherX + otherW;
        }
        // Snap bottom edge of selected to top edge of other
        if (Math.abs((snapY + elH) - otherY) < snapDistance) {
          snapY = otherY - elH;
        }
        // Snap top edge of selected to bottom edge of other
        if (Math.abs(snapY - (otherY + otherH)) < snapDistance) {
          snapY = otherY + otherH;
        }

        // Align tops when close
        if (Math.abs(snapY - otherY) < snapDistance) {
          snapY = otherY;
        }
        // Align lefts when close
        if (Math.abs(snapX - otherX) < snapDistance) {
          snapX = otherX;
        }
      });

      // Allow elements to be placed anywhere (no canvas boundary restriction)
      selectedElement.x = snapX;
      selectedElement.y = snapY;

      draw();
    }

    function onMouseUp(e) {
      // End resizing
      if (isResizing) {
        isResizing = false;
        resizeHandle = null;
        canvas.style.cursor = 'default';
        calculateQuote();
        saveUndoState();
        return;
      }

      if (isPanning) {
        isPanning = false;
        canvas.style.cursor = currentTool === 'pan' ? 'grab' : (currentTool === 'wall' ? 'crosshair' : 'default');
        return;
      }

      if (isDrawingWall && wallStart) {
        const rect = canvas.getBoundingClientRect();
        const screenX = e.clientX - rect.left;
        const screenY = e.clientY - rect.top;
        const { x, y } = screenToWorld(screenX, screenY);

        const wx = Math.min(wallStart.x, x);
        const wy = Math.min(wallStart.y, y);
        let ww = Math.abs(x - wallStart.x);
        let wh = Math.abs(y - wallStart.y);

        // Make it a proper wall (thin in one dimension)
        if (ww < wh) {
          ww = CONFIG.WALL_THICKNESS;
        } else {
          wh = CONFIG.WALL_THICKNESS;
        }

        if (ww > 10 || wh > 10) {
          addWall(wx, wy, ww, wh);
          saveUndoState();
        }

        isDrawingWall = false;
        wallStart = null;
        draw();
        return;
      }

      if (isDrawingCountertop && countertopStart) {
        const rect = canvas.getBoundingClientRect();
        const screenX = e.clientX - rect.left;
        const screenY = e.clientY - rect.top;
        const { x, y } = screenToWorld(screenX, screenY);

        const cx = Math.min(countertopStart.x, x);
        const cy = Math.min(countertopStart.y, y);
        let cw = Math.abs(x - countertopStart.x);
        let ch = Math.abs(y - countertopStart.y);

        // Minimum size of 1 foot
        if (cw < pixelsPerFoot) cw = pixelsPerFoot * 2;
        if (ch < pixelsPerFoot) ch = pixelsPerFoot * 2;

        // Create countertop element
        const countertop = {
          id: 'countertop-' + Date.now(),
          type: 'countertop',
          x: cx,
          y: cy,
          width: cw / pixelsPerFoot,
          height: ch / pixelsPerFoot,
          color: '#708090',
          label: 'Countertop',
          rotation: 0,
          locked: false
        };

        elements.push(countertop);
        selectedElement = countertop;
        calculateQuote();
        saveUndoState();

        isDrawingCountertop = false;
        countertopStart = null;
        draw();
        updateProperties();
        return;
      }

      // Save undo state if we were dragging an element
      if (isDragging && selectedElement) {
        saveUndoState();
      }

      isDragging = false;
    }

    function onContextMenu(e) {
      e.preventDefault();
      const rect = canvas.getBoundingClientRect();
      const screenX = e.clientX - rect.left;
      const screenY = e.clientY - rect.top;
      const { x, y } = screenToWorld(screenX, screenY);

      const clicked = [...elements].reverse().find(el => isPointInElement(x, y, el));

      if (clicked) {
        selectedElement = clicked;
        contextMenuElement = clicked;
        showContextMenu(e.clientX, e.clientY, clicked);
        draw();
      }
    }

    function onDoubleClick(e) {
      const rect = canvas.getBoundingClientRect();
      const screenX = e.clientX - rect.left;
      const screenY = e.clientY - rect.top;
      const { x, y } = screenToWorld(screenX, screenY);

      const clicked = [...elements].reverse().find(el => isPointInElement(x, y, el));

      if (clicked) {
        const newLabel = prompt('Enter label:', clicked.label);
        if (newLabel) {
          clicked.label = newLabel;
          draw();
        }
      }
    }

    function isPointInElement(px, py, el) {
      const w = el.width * pixelsPerFoot;
      const h = el.height * pixelsPerFoot;
      const rotation = (el.rotation || 0) * Math.PI / 180;

      // If no rotation, use simple bounds check
      if (rotation === 0) {
        return px >= el.x && px <= el.x + w && py >= el.y && py <= el.y + h;
      }

      // For rotated elements, transform the click point to element's local space
      const cx = el.x + w / 2;
      const cy = el.y + h / 2;

      // Translate point to origin (element center)
      const dx = px - cx;
      const dy = py - cy;

      // Rotate point in opposite direction to get local coordinates
      const cosR = Math.cos(-rotation);
      const sinR = Math.sin(-rotation);
      const localX = dx * cosR - dy * sinR;
      const localY = dx * sinR + dy * cosR;

      // Check if local point is within unrotated bounds (centered at origin)
      return localX >= -w/2 && localX <= w/2 && localY >= -h/2 && localY <= h/2;
    }

    // ===== KEYBOARD EVENTS =====
    let spacePressed = false;

    function onKeyDown(e) {
      if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') return;

      // Space to pan
      if (e.code === 'Space' && !spacePressed) {
        spacePressed = true;
        canvas.style.cursor = 'grab';
        e.preventDefault();
        return;
      }

      switch(e.key.toLowerCase()) {
        case 'v': setTool('select'); break;
        case 'w': setTool('wall'); break;
        case 'c': setTool('countertop'); break;
        case 'h': setTool('pan'); break;
        case 'f': fitToScreen(); break; // F to fit
        case 'delete':
        case 'backspace':
          if (selectedElement && !selectedElement.locked) {
            elements = elements.filter(el => el !== selectedElement);
            selectedElement = null;
            updateProperties();
            draw();
          }
          break;
        case 'r':
          if (selectedElement && !selectedElement.locked) {
            selectedElement.rotation = ((selectedElement.rotation || 0) + 90) % 360;
            updateProperties();
            draw();
          }
          break;
        case 'd':
          if ((e.ctrlKey || e.metaKey) && selectedElement) {
            e.preventDefault();
            duplicateElement(selectedElement);
          }
          break;
        case 'escape':
          selectedElement = null;
          hideContextMenu();
          updateProperties();
          draw();
          break;
        case '=':
        case '+':
          if (e.ctrlKey || e.metaKey) {
            e.preventDefault();
            zoomIn();
          }
          break;
        case '-':
          if (e.ctrlKey || e.metaKey) {
            e.preventDefault();
            zoomOut();
          }
          break;
        case '0':
          if (e.ctrlKey || e.metaKey) {
            e.preventDefault();
            fitToScreen();
          }
          break;
      }
    }

    function onKeyUp(e) {
      if (e.code === 'Space') {
        spacePressed = false;
        canvas.style.cursor = currentTool === 'pan' ? 'grab' : (currentTool === 'wall' ? 'crosshair' : 'default');
      }
    }

    // Mouse wheel zoom
    function onWheel(e) {
      e.preventDefault();

      const rect = canvas.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;

      // Get world position before zoom
      const worldX = (mouseX - panX) / pixelsPerFoot;
      const worldY = (mouseY - panY) / pixelsPerFoot;

      // Adjust pixels per foot
      const zoomFactor = e.deltaY < 0 ? 1.1 : 0.9;
      const newPixelsPerFoot = Math.max(15, Math.min(100, pixelsPerFoot * zoomFactor));

      // Adjust pan to zoom toward mouse position
      panX = mouseX - worldX * newPixelsPerFoot;
      panY = mouseY - worldY * newPixelsPerFoot;

      pixelsPerFoot = newPixelsPerFoot;

      document.getElementById('scaleMode').value = 'fit'; // Reset dropdown
      document.getElementById('zoomLevel').textContent = Math.round(pixelsPerFoot / 40 * 100) + '%';

      draw();
    }

    // ===== DRAG & DROP =====
    function onDrop(e) {
      e.preventDefault();
      const type = e.dataTransfer.getData('element-type');
      if (!type) return;

      const rect = canvas.getBoundingClientRect();
      const screenX = e.clientX - rect.left;
      const screenY = e.clientY - rect.top;
      const { x, y } = screenToWorld(screenX, screenY);

      createElement(type, x, y);
    }

    function createElement(type, x, y) {
      let defaults = null;
      Object.values(ELEMENT_TYPES).forEach(cat => {
        const found = cat.find(el => el.type === type);
        if (found) defaults = found;
      });

      if (!defaults) return;

      const gridSnap = pixelsPerFoot / CONFIG.GRID_SUBDIVISIONS;
      const isCabinet = type.includes('cabinet');
      const element = {
        id: Date.now() + Math.random(),
        type: type,
        x: Math.round(x / gridSnap) * gridSnap,
        y: Math.round(y / gridSnap) * gridSnap,
        width: defaults.width,
        height: defaults.height,
        color: defaults.color,
        label: defaults.label,
        rotation: 0,
        locked: false,
        texture: elementTextures[type] || null,
        textureImg: null,
        floorLevel: cabinetSettings.currentFloor,
        // Cabinet-specific settings
        construction: isCabinet ? cabinetSettings.construction : undefined,
        doorStyle: isCabinet ? cabinetSettings.doorStyle : undefined,
        doorOverlay: isCabinet ? cabinetSettings.doorOverlay : undefined,
        // Pricing fields
        priceOverride: null,
        priceUnit: 'sqft',
        marginPercent: null,
        costPrice: null,
        retailPrice: null
      };

      // Load texture if exists
      if (element.texture) {
        const img = new Image();
        img.onload = () => {
          element.textureImg = img;
          draw();
        };
        img.src = element.texture;
      }

      elements.push(element);
      selectedElement = element;
      updateProperties();
      calculateQuote();
      saveUndoState();
      draw();
    }

    function duplicateElement(el) {
      const gridSnap = pixelsPerFoot / CONFIG.GRID_SUBDIVISIONS;
      const newEl = {
        ...el,
        id: Date.now() + Math.random(),
        x: el.x + gridSnap * 2,
        y: el.y + gridSnap * 2,
        locked: false
      };
      elements.push(newEl);
      selectedElement = newEl;
      updateProperties();
      calculateQuote();
      saveUndoState();
      draw();
    }

    // ===== CONTEXT MENU =====
    function showContextMenu(x, y, element) {
      const menu = document.getElementById('contextMenu');
      menu.style.display = 'block';
      menu.style.left = x + 'px';
      menu.style.top = y + 'px';

      document.getElementById('contextMenuLabel').textContent = element.label;
      document.getElementById('lockText').textContent = element.locked ? 'Unlock' : 'Lock';
    }

    function hideContextMenu() {
      document.getElementById('contextMenu').style.display = 'none';
      contextMenuElement = null;
    }

    function contextAction(action) {
      if (!contextMenuElement) return;

      switch(action) {
        case 'rotate':
          if (!contextMenuElement.locked) {
            contextMenuElement.rotation = ((contextMenuElement.rotation || 0) + 90) % 360;
          }
          break;
        case 'duplicate':
          duplicateElement(contextMenuElement);
          break;
        case 'texture':
          selectedElement = contextMenuElement;
          openMaterialPicker();
          break;
        case 'lock':
          contextMenuElement.locked = !contextMenuElement.locked;
          break;
        case 'front':
          elements = elements.filter(el => el !== contextMenuElement);
          elements.push(contextMenuElement);
          break;
        case 'back':
          elements = elements.filter(el => el !== contextMenuElement);
          elements.unshift(contextMenuElement);
          break;
        case 'delete':
          if (!contextMenuElement.locked) {
            elements = elements.filter(el => el !== contextMenuElement);
            if (selectedElement === contextMenuElement) {
              selectedElement = null;
              updateProperties();
            }
          }
          break;
      }

      hideContextMenu();
      draw();
    }

    // ===== TOOLS =====
    function setTool(tool) {
      currentTool = tool;
      document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('active'));
      const btn = document.getElementById('tool' + tool.charAt(0).toUpperCase() + tool.slice(1));
      if (btn) btn.classList.add('active');

      canvas.style.cursor = (tool === 'wall' || tool === 'countertop') ? 'crosshair' : (tool === 'pan' ? 'grab' : 'default');
    }

    function toggleSection(header) {
      const content = header.nextElementSibling;
      const toggle = header.querySelector('.sidebar-toggle');
      content.classList.toggle('collapsed');
      toggle.textContent = content.classList.contains('collapsed') ? '' : '';
    }

    // ===== VIEW =====
    function setView(view) {
      currentView = view;
      document.getElementById('view2D').classList.toggle('active', view === '2d');
      document.getElementById('view3D').classList.toggle('active', view === '3d');

      const canvasWrapper = document.getElementById('canvasWrapper');
      const threeContainer = document.getElementById('three-container');

      // Cancel any existing animation when switching views
      if (animationId) {
        cancelAnimationFrame(animationId);
        animationId = null;
      }

      if (view === '3d') {
        canvasWrapper.style.display = 'none';
        threeContainer.classList.add('active');
        init3D();

        // Update renderer size in case container size changed
        if (renderer) {
          const w = threeContainer.clientWidth;
          const h = threeContainer.clientHeight;
          renderer.setSize(w, h);
          camera.aspect = w / h;
          camera.updateProjectionMatrix();
        }

        render3D();
      } else {
        // Cleanup 3D resources when switching to 2D
        cleanup3D();
        canvasWrapper.style.display = 'block';
        threeContainer.classList.remove('active');
      }
    }

    // Helper function to check if 3D mode is active
    function get3DMode() {
      return currentView === '3d';
    }

    // Expose is3DMode as a getter
    Object.defineProperty(window, 'is3DMode', {
      get: function() { return currentView === '3d'; }
    });

    // Toggle between 2D and 3D views
    function toggle3DView() {
      if (currentView === '3d') {
        setView('2d');
      } else {
        setView('3d');
      }
      // Update button text in review room if present
      const toggle3DBtn = document.getElementById('toggle3DBtn');
      if (toggle3DBtn) {
        toggle3DBtn.textContent = currentView === '3d' ? '2D View' : '3D View';
      }
    }

    // Alias for update3DScene - rebuilds the 3D scene with current elements
    function update3DScene() {
      if (currentView === '3d') {
        init3D();
        render3D();
      }
    }

    // ===== 3D VIEW =====
    function cleanup3D() {
      if (animationId) {
        cancelAnimationFrame(animationId);
        animationId = null;
      }

      if (scene) {
        // Dispose all objects in scene
        scene.traverse(obj => {
          if (obj.geometry) obj.geometry.dispose();
          if (obj.material) {
            if (Array.isArray(obj.material)) {
              obj.material.forEach(m => m.dispose());
            } else {
              obj.material.dispose();
            }
          }
        });
        scene.clear();
        scene = null;
      }

      if (renderer) {
        renderer.dispose();
        renderer = null;
      }

      if (controls) {
        controls.dispose();
        controls = null;
      }

      const container = document.getElementById('three-container');
      if (container) container.innerHTML = '';
    }

    function init3D() {
      // Clean up existing 3D resources first
      cleanup3D();


      const container = document.getElementById('three-container');
      const width = container.clientWidth;
      const height = container.clientHeight;

      scene = new THREE.Scene();
      scene.background = new THREE.Color(0xE8F4F8); // Light blue-gray

      // Camera
      camera = new THREE.PerspectiveCamera(50, width / height, 0.1, 200);
      camera.position.set(roomWidth * 1.3, 8, roomDepth * 1.3);
      camera.lookAt(roomWidth / 2, 2, roomDepth / 2);

      // Renderer with good quality
      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setSize(width, height);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 1.0;
      container.appendChild(renderer.domElement);

      // Orbit controls with smooth, controlled zoom
      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.08;
      controls.target.set(roomWidth / 2, 1.5, roomDepth / 2);
      controls.maxPolarAngle = Math.PI / 2.05;
      controls.minDistance = 5;
      controls.maxDistance = 40;

      // Reduce zoom sensitivity (default is 1.0)
      controls.zoomSpeed = 0.5;

      // Reduce pan sensitivity
      controls.panSpeed = 0.5;

      // Reduce rotation sensitivity
      controls.rotateSpeed = 0.5;

      // Disable right-click pan (use middle mouse or shift+left instead)
      controls.mouseButtons = {
        LEFT: THREE.MOUSE.ROTATE,
        MIDDLE: THREE.MOUSE.DOLLY,
        RIGHT: THREE.MOUSE.PAN
      };

      controls.update();

      // Prevent context menu on 3D view
      container.addEventListener('contextmenu', (e) => e.preventDefault());

      // === LIGHTING ===

      // Ambient (overall soft light)
      const ambient = new THREE.AmbientLight(0xffffff, 0.5);
      scene.add(ambient);

      // Hemisphere light (sky/ground)
      const hemi = new THREE.HemisphereLight(0xB1E1FF, 0xB97A20, 0.5);
      scene.add(hemi);

      // Main directional (sun) with shadows
      const sun = new THREE.DirectionalLight(0xFFFBF0, 1.2);
      sun.position.set(roomWidth, 15, roomDepth * 0.5);
      sun.castShadow = true;
      sun.shadow.mapSize.width = 2048;
      sun.shadow.mapSize.height = 2048;
      sun.shadow.camera.near = 1;
      sun.shadow.camera.far = 50;
      sun.shadow.camera.left = -20;
      sun.shadow.camera.right = 20;
      sun.shadow.camera.top = 20;
      sun.shadow.camera.bottom = -20;
      sun.shadow.bias = -0.0005;
      scene.add(sun);

      // Fill light from opposite side
      const fill = new THREE.DirectionalLight(0xFFFFFF, 0.4);
      fill.position.set(-roomWidth, 8, roomDepth);
      scene.add(fill);

      // Back light for rim
      const back = new THREE.DirectionalLight(0xE0F0FF, 0.3);
      back.position.set(roomWidth / 2, 5, -10);
      scene.add(back);

      // Resize handler
      window.addEventListener('resize', () => {
        const w = container.clientWidth;
        const h = container.clientHeight;
        camera.aspect = w / h;
        camera.updateProjectionMatrix();
        renderer.setSize(w, h);
      });
    }

    // Get proper 3D height for element types
    function get3DHeight(type) {
      const heights = {
        'base-cabinet': 2.9,      // 35 inches standard
        'wall-cabinet': 2.5,      // 30 inches
        'tall-cabinet': 7,        // 84 inches
        'corner-cabinet': 2.9,
        'island': 3,              // 36 inches with countertop
        'countertop': 0.12,       // 1.5 inch thick
        'backsplash': 1.5,        // 18 inches
        'flooring': 0.05,         // Very thin
        'tile': 0.05,
        'sink': 0.3,              // Recessed
        'stove': 3,               // Full range height
        'refrigerator': 5.8,      // 70 inches
        'dishwasher': 2.8,        // 34 inches
        'microwave': 1,           // 12 inches
        'range-hood': 0.5,        // Hood depth
        'oven': 2.4,              // 29 inches
        'door': 6.8,              // 82 inches
        'window': 3,              // 36 inches
        'wall': 8                 // 8 feet
      };
      return heights[type] || 1;
    }

    // Get Y position (elevation) for element types
    function get3DYPosition(type, height) {
      // Proper stacking heights for kitchen elements
      // All heights in feet, Y = center of object

      switch(type) {
        // Ground level surfaces (below everything)
        case 'flooring':
        case 'tile':
          return 0.025; // Just above floor plane

        // Base level (on floor)
        case 'base-cabinet':
        case 'corner-cabinet':
        case 'island':
          return height / 2; // Base sits on floor

        // Counter height items (on top of base cabinets at ~35")
        case 'countertop':
          return 2.92 + height / 2; // 35" = 2.92 ft, counter sits on base cabinets

        case 'sink':
          return 2.92 + 0.1; // Slightly recessed into counter

        case 'stove':
        case 'dishwasher':
        case 'oven':
          return height / 2; // These are floor-standing appliances

        case 'refrigerator':
          return height / 2; // Floor standing, tall

        // Wall mounted (54" from floor is typical bottom edge)
        case 'wall-cabinet':
          return 4.5 + height / 2; // Bottom at 54" (4.5 ft)

        case 'backsplash':
          return 3.1 + height / 2; // Above counter, below wall cabs

        case 'range-hood':
          return 5 + height / 2; // Above stove, centered

        case 'microwave':
          return 4.5 + height / 2; // Often above counter or in wall cab

        // Structural
        case 'window':
          return 3.5; // Window center typically at ~42" from floor

        case 'door':
          return height / 2; // Door sits on floor

        case 'wall':
          return height / 2; // Wall sits on floor

        case 'tall-cabinet':
          return height / 2; // Tall cabinets sit on floor

        default:
          return height / 2; // Default: bottom on floor
      }
    }

    // Cache for loaded 3D textures
    const textureCache3D = {};
    const textureLoader = new THREE.TextureLoader();

    function create3DElement(el) {
      const w = el.width;
      const d = el.height; // In 2D, height is depth in 3D
      const h = get3DHeight(el.type);

      // Parse color
      let color = el.color || '#808080';
      if (typeof color === 'string') {
        if (color.startsWith('#')) {
          color = parseInt(color.replace('#', ''), 16);
        } else if (color.startsWith('rgb')) {
          const match = color.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
          if (match) {
            color = (parseInt(match[1]) << 16) | (parseInt(match[2]) << 8) | parseInt(match[3]);
          } else {
            color = 0x808080;
          }
        } else {
          color = parseInt(color, 16) || 0x808080;
        }
      }

      const group = new THREE.Group();

      // Helper to create material with optional texture
      function createTexturedMaterial(baseColor, textureUrl, options = {}) {
        const matOptions = {
          color: textureUrl ? 0xFFFFFF : baseColor, // White if textured, otherwise use color
          roughness: options.roughness || 0.4,
          metalness: options.metalness || 0,
          ...options
        };

        const material = new THREE.MeshStandardMaterial(matOptions);

        // Load texture if available
        if (textureUrl) {
          // Resolve relative URLs to absolute
          let fullUrl = textureUrl;
          if (textureUrl.startsWith('/') && !textureUrl.startsWith('//')) {
            fullUrl = window.location.origin + textureUrl;
          } else if (!textureUrl.startsWith('http') && !textureUrl.startsWith('data:')) {
            fullUrl = window.location.origin + '/' + textureUrl;
          }

          if (textureCache3D[fullUrl]) {
            material.map = textureCache3D[fullUrl];
            material.needsUpdate = true;
          } else {
            textureLoader.load(fullUrl, (texture) => {
              texture.wrapS = THREE.RepeatWrapping;
              texture.wrapT = THREE.RepeatWrapping;
              texture.repeat.set(1, 1);
              texture.colorSpace = THREE.SRGBColorSpace; // Correct color handling
              textureCache3D[fullUrl] = texture;
              material.map = texture;
              material.needsUpdate = true;
              // Re-render to show texture
              if (renderer && scene && camera) {
                renderer.render(scene, camera);
              }
            }, undefined, (err) => {
              console.warn('Failed to load 3D texture:', fullUrl, err);
              // Fallback: use the base color if texture fails
              material.color.setHex(baseColor);
              material.needsUpdate = true;
            });
          }
        }

        return material;
      }

      // Get texture URL from element - check multiple sources
      let textureUrl = null;
      if (el.texture) {
        textureUrl = el.texture;
      } else if (el.textureImg && el.textureImg.src) {
        textureUrl = el.textureImg.src;
      } else if (elementTextures && elementTextures[el.type]) {
        textureUrl = elementTextures[el.type];
      }

      // Helper to create cabinet with doors
      function createCabinet(width, height, depth, cabinetColor, isWallCab, doorStyle, construction, overlay) {
        const cabGroup = new THREE.Group();

        // Construction affects door gaps
        // Frameless: minimal gaps, doors cover most of face (full overlay default)
        // Framed: visible face frame, doors reveal frame edges
        const isFramed = construction === 'framed';
        const overlayType = overlay || 'full';

        // Gap based on overlay type
        let gap;
        if (isFramed) {
          gap = overlayType === 'inset' ? 0.08 : (overlayType === 'partial' ? 0.06 : 0.04);
        } else {
          gap = overlayType === 'inset' ? 0.06 : 0.02; // Frameless has smaller gaps
        }

        // Cabinet body
        const bodyMat = new THREE.MeshStandardMaterial({ color: 0x2a2a2a, roughness: 0.8 });
        const body = new THREE.Mesh(new THREE.BoxGeometry(width - 0.1, height - 0.1, depth - 0.1), bodyMat);
        body.position.z = -0.02;
        cabGroup.add(body);

        // Face frame for framed cabinets
        if (isFramed) {
          const frameMat = new THREE.MeshStandardMaterial({ color: cabinetColor, roughness: 0.4 });
          const frameW = 0.06; // 1.5" face frame

          // Top rail
          const topFrame = new THREE.Mesh(new THREE.BoxGeometry(width, frameW, 0.04), frameMat);
          topFrame.position.set(0, height/2 - frameW/2 - 0.01, depth/2 - 0.01);
          cabGroup.add(topFrame);

          // Bottom rail
          const botFrame = new THREE.Mesh(new THREE.BoxGeometry(width, frameW, 0.04), frameMat);
          botFrame.position.set(0, -height/2 + frameW/2 + 0.01, depth/2 - 0.01);
          cabGroup.add(botFrame);

          // Left stile
          const leftFrame = new THREE.Mesh(new THREE.BoxGeometry(frameW, height - frameW*2, 0.04), frameMat);
          leftFrame.position.set(-width/2 + frameW/2 + 0.01, 0, depth/2 - 0.01);
          cabGroup.add(leftFrame);

          // Right stile
          const rightFrame = new THREE.Mesh(new THREE.BoxGeometry(frameW, height - frameW*2, 0.04), frameMat);
          rightFrame.position.set(width/2 - frameW/2 - 0.01, 0, depth/2 - 0.01);
          cabGroup.add(rightFrame);
        }

        // Face material
        const faceMat = new THREE.MeshStandardMaterial({ color: cabinetColor, roughness: 0.35, metalness: 0.02 });

        // Door(s)
        const numDoors = Math.max(1, Math.round(width / 1.5));
        const doorW = (width - gap * (numDoors + 1)) / numDoors;
        const doorH = height - gap * 2;

        const style = doorStyle || 'shaker';

        for (let i = 0; i < numDoors; i++) {
          const dx = -width/2 + gap + doorW/2 + i * (doorW + gap);

          // Main door panel
          const door = new THREE.Mesh(new THREE.BoxGeometry(doorW, doorH, 0.06), faceMat);
          door.position.set(dx, 0, depth/2);
          cabGroup.add(door);

          // Door style details
          if (style === 'shaker') {
            // Shaker: flat center panel with raised frame
            const frameMat = new THREE.MeshStandardMaterial({ color: cabinetColor, roughness: 0.3 });
            const fw = 0.08;

            // Top rail
            const top = new THREE.Mesh(new THREE.BoxGeometry(doorW - 0.02, fw, 0.02), frameMat);
            top.position.set(dx, doorH/2 - fw/2 - 0.01, depth/2 + 0.04);
            cabGroup.add(top);

            // Bottom rail
            const bot = new THREE.Mesh(new THREE.BoxGeometry(doorW - 0.02, fw, 0.02), frameMat);
            bot.position.set(dx, -doorH/2 + fw/2 + 0.01, depth/2 + 0.04);
            cabGroup.add(bot);

            // Left stile
            const left = new THREE.Mesh(new THREE.BoxGeometry(fw, doorH - fw*2, 0.02), frameMat);
            left.position.set(dx - doorW/2 + fw/2 + 0.01, 0, depth/2 + 0.04);
            cabGroup.add(left);

            // Right stile
            const right = new THREE.Mesh(new THREE.BoxGeometry(fw, doorH - fw*2, 0.02), frameMat);
            right.position.set(dx + doorW/2 - fw/2 - 0.01, 0, depth/2 + 0.04);
            cabGroup.add(right);
          } else if (style === 'raised') {
            // Raised panel: outer frame with raised center
            const frameMat = new THREE.MeshStandardMaterial({ color: cabinetColor, roughness: 0.3 });
            const fw = 0.1;

            // Frame pieces
            const top = new THREE.Mesh(new THREE.BoxGeometry(doorW - 0.02, fw, 0.02), frameMat);
            top.position.set(dx, doorH/2 - fw/2 - 0.01, depth/2 + 0.04);
            cabGroup.add(top);

            const bot = new THREE.Mesh(new THREE.BoxGeometry(doorW - 0.02, fw, 0.02), frameMat);
            bot.position.set(dx, -doorH/2 + fw/2 + 0.01, depth/2 + 0.04);
            cabGroup.add(bot);

            const left = new THREE.Mesh(new THREE.BoxGeometry(fw, doorH - fw*2, 0.02), frameMat);
            left.position.set(dx - doorW/2 + fw/2 + 0.01, 0, depth/2 + 0.04);
            cabGroup.add(left);

            const right = new THREE.Mesh(new THREE.BoxGeometry(fw, doorH - fw*2, 0.02), frameMat);
            right.position.set(dx + doorW/2 - fw/2 - 0.01, 0, depth/2 + 0.04);
            cabGroup.add(right);

            // Raised center panel
            const raisedW = doorW - fw * 2 - 0.06;
            const raisedH = doorH - fw * 2 - 0.06;
            const raisedMat = new THREE.MeshStandardMaterial({ color: cabinetColor, roughness: 0.25 });
            const raised = new THREE.Mesh(new THREE.BoxGeometry(raisedW, raisedH, 0.04), raisedMat);
            raised.position.set(dx, 0, depth/2 + 0.06);
            cabGroup.add(raised);
          } else if (style === 'flat') {
            // Flat panel: minimal detail, just thin border
            const borderMat = new THREE.MeshStandardMaterial({ color: cabinetColor, roughness: 0.35 });
            const borderW = 0.02;

            // Thin groove around door
            const grooveMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.9 });
            const groove = new THREE.Mesh(new THREE.BoxGeometry(doorW - 0.08, doorH - 0.08, 0.01), grooveMat);
            groove.position.set(dx, 0, depth/2 + 0.03);
            cabGroup.add(groove);
          }
          // 'slab' style = no detail, just plain door

          // Vertical Handle (bar pull)
          const handleMat = new THREE.MeshStandardMaterial({ color: 0xaaaaaa, metalness: 0.9, roughness: 0.15 });
          const handleY = isWallCab ? -doorH * 0.25 : doorH * 0.25;
          const handleX = i < numDoors/2 ? doorW/2 - 0.12 : -doorW/2 + 0.12;
          const handle = new THREE.Mesh(new THREE.CylinderGeometry(0.01, 0.01, 0.3, 8), handleMat);
          handle.position.set(dx + handleX, handleY, depth/2 + 0.09);
          cabGroup.add(handle);
        }

        return cabGroup;
      }

      // === CREATE DETAILED 3D MODELS ===
      switch(el.type) {
        case 'base-cabinet':
        case 'wall-cabinet': {
          const isBaseCab = el.type === 'base-cabinet';

          // Toe kick dimensions (4" tall, 3" recessed)
          const toeKickHeight = isBaseCab ? 0.33 : 0;
          const toeKickRecess = isBaseCab ? 0.25 : 0;

          // Cabinet body height (minus toe kick for base cabinets)
          const bodyHeight = h - toeKickHeight;

          // Create cabinet body at reduced height for base cabinets
          const cab = createCabinet(w, bodyHeight, d, color, !isBaseCab, el.doorStyle, el.construction, el.doorOverlay);

          // Position cabinet body above toe kick
          if (isBaseCab) {
            cab.position.y = toeKickHeight / 2;
          }
          group.add(cab);

          // Create toe kick for base cabinets - proper recessed void
          if (isBaseCab) {
            // Toe kick back panel (visible back of recess)
            const tkBackMat = new THREE.MeshStandardMaterial({ color: 0x0a0a0a, roughness: 0.95 });
            const tkBack = new THREE.Mesh(
              new THREE.BoxGeometry(w - 0.1, toeKickHeight - 0.02, 0.02),
              tkBackMat
            );
            tkBack.position.set(0, -h/2 + toeKickHeight/2, d/2 - toeKickRecess);
            group.add(tkBack);

            // Toe kick bottom (floor of recess)
            const tkBottom = new THREE.Mesh(
              new THREE.BoxGeometry(w - 0.1, 0.02, toeKickRecess - 0.02),
              tkBackMat
            );
            tkBottom.position.set(0, -h/2 + 0.01, d/2 - toeKickRecess/2);
            group.add(tkBottom);

            // Left side panel of toe kick recess
            const tkLeft = new THREE.Mesh(
              new THREE.BoxGeometry(0.02, toeKickHeight - 0.02, toeKickRecess),
              tkBackMat
            );
            tkLeft.position.set(-w/2 + 0.05, -h/2 + toeKickHeight/2, d/2 - toeKickRecess/2);
            group.add(tkLeft);

            // Right side panel of toe kick recess
            const tkRight = new THREE.Mesh(
              new THREE.BoxGeometry(0.02, toeKickHeight - 0.02, toeKickRecess),
              tkBackMat
            );
            tkRight.position.set(w/2 - 0.05, -h/2 + toeKickHeight/2, d/2 - toeKickRecess/2);
            group.add(tkRight);

            // Cabinet overhang lip (bottom edge of cabinet above toe kick)
            const lipMat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.4 });
            const lip = new THREE.Mesh(
              new THREE.BoxGeometry(w, 0.03, 0.04),
              lipMat
            );
            lip.position.set(0, -h/2 + toeKickHeight + 0.015, d/2 - 0.02);
            group.add(lip);
          }
          break;
        }

        case 'corner-cabinet': {
          // L-SHAPED CORNER CABINET (Lazy Susan / Diagonal style)
          const cabinetMat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.4 });
          const bodyMat = new THREE.MeshStandardMaterial({ color: 0x2a2a2a, roughness: 0.8 });
          const handleMat = new THREE.MeshStandardMaterial({ color: 0xaaaaaa, metalness: 0.9, roughness: 0.15 });

          // Create L-shape using two boxes
          const armLength = w * 0.6;
          const armDepth = d * 0.4;

          // Back arm (along Z axis)
          const backArm = new THREE.Mesh(
            new THREE.BoxGeometry(armDepth, h - 0.1, armLength),
            cabinetMat
          );
          backArm.position.set(-w/2 + armDepth/2, 0, -d/2 + armLength/2);
          group.add(backArm);

          // Side arm (along X axis)
          const sideArm = new THREE.Mesh(
            new THREE.BoxGeometry(armLength, h - 0.1, armDepth),
            cabinetMat
          );
          sideArm.position.set(-w/2 + armLength/2, 0, -d/2 + armDepth/2);
          group.add(sideArm);

          // Diagonal front face (door)
          const diagWidth = Math.sqrt(2) * Math.min(w, d) * 0.5;
          const doorMat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.35 });
          const diagDoor = new THREE.Mesh(
            new THREE.BoxGeometry(diagWidth, h - 0.2, 0.06),
            doorMat
          );
          diagDoor.rotation.y = Math.PI / 4; // 45 degrees
          diagDoor.position.set(0, 0, 0);
          group.add(diagDoor);

          // Door frame (shaker style)
          const frameMat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.3 });
          const frameW = 0.08;

          // Top rail
          const topRail = new THREE.Mesh(
            new THREE.BoxGeometry(diagWidth - 0.1, frameW, 0.02),
            frameMat
          );
          topRail.rotation.y = Math.PI / 4;
          topRail.position.set(0, h/2 - 0.15, 0.05);
          group.add(topRail);

          // Bottom rail
          const bottomRail = new THREE.Mesh(
            new THREE.BoxGeometry(diagWidth - 0.1, frameW, 0.02),
            frameMat
          );
          bottomRail.rotation.y = Math.PI / 4;
          bottomRail.position.set(0, -h/2 + 0.15, 0.05);
          group.add(bottomRail);

          // Vertical handle on diagonal door
          const handle = new THREE.Mesh(
            new THREE.CylinderGeometry(0.012, 0.012, 0.3, 8),
            handleMat
          );
          handle.position.set(diagWidth * 0.25, 0, diagWidth * 0.25 + 0.1);
          group.add(handle);

          // Toe kick (L-shaped) - proper recessed void
          const toeKickHeight = 0.33;
          const toeKickRecess = 0.25;
          const tkBackMat = new THREE.MeshStandardMaterial({ color: 0x0a0a0a, roughness: 0.95 });

          // Diagonal toe kick back (under the diagonal door)
          const diagTkWidth = Math.sqrt(2) * Math.min(w, d) * 0.4;
          const tkDiag = new THREE.Mesh(
            new THREE.BoxGeometry(diagTkWidth, toeKickHeight - 0.02, 0.02),
            tkBackMat
          );
          tkDiag.rotation.y = Math.PI / 4;
          tkDiag.position.set(toeKickRecess * 0.5, -h/2 + toeKickHeight/2, toeKickRecess * 0.5);
          group.add(tkDiag);

          // Toe kick floor (L-shaped approximation)
          const tkFloor1 = new THREE.Mesh(
            new THREE.BoxGeometry(armDepth - 0.15, 0.02, armLength - 0.15),
            tkBackMat
          );
          tkFloor1.position.set(-w/2 + armDepth/2, -h/2 + 0.01, -d/2 + armLength/2);
          group.add(tkFloor1);

          const tkFloor2 = new THREE.Mesh(
            new THREE.BoxGeometry(armLength - armDepth, 0.02, armDepth - 0.15),
            tkBackMat
          );
          tkFloor2.position.set(-w/2 + armDepth + (armLength - armDepth)/2, -h/2 + 0.01, -d/2 + armDepth/2);
          group.add(tkFloor2);

          // Cabinet overhang lip (diagonal)
          const lipMat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.4 });
          const lipDiag = new THREE.Mesh(
            new THREE.BoxGeometry(diagTkWidth + 0.2, 0.03, 0.04),
            lipMat
          );
          lipDiag.rotation.y = Math.PI / 4;
          lipDiag.position.set(0, -h/2 + toeKickHeight + 0.015, 0);
          group.add(lipDiag);

          break;
        }

        case 'tall-cabinet': {
          // Tall pantry cabinet with two door sections
          const tallMat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.4 });

          // Main cabinet body (dark interior)
          const bodyMat = new THREE.MeshStandardMaterial({
            color: 0x2a2a2a,
            roughness: 0.8
          });
          const body = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.08, h - 0.08, d - 0.1),
            bodyMat
          );
          body.position.z = -0.02;
          group.add(body);

          // Cabinet face material
          const faceMat = new THREE.MeshStandardMaterial({
            color: color,
            roughness: 0.35,
            metalness: 0.02
          });

          // Door calculation
          const numDoors = Math.max(1, Math.round(w / 1.5));
          const doorGap = 0.03;
          const totalGaps = doorGap * (numDoors + 1);
          const doorWidth = (w - totalGaps) / numDoors;
          const doorHeight = h - doorGap * 2;

          for (let i = 0; i < numDoors; i++) {
            // Door panel (main)
            const door = new THREE.Mesh(
              new THREE.BoxGeometry(doorWidth, doorHeight, 0.06),
              faceMat
            );
            const doorX = -w/2 + doorGap + doorWidth/2 + i * (doorWidth + doorGap);
            door.position.set(doorX, 0, d/2);
            group.add(door);

            // SHAKER FRAME DETAIL
            const frameW = 0.1;
            const frameD = 0.02;
            const frameMat = new THREE.MeshStandardMaterial({
              color: color,
              roughness: 0.3,
              metalness: 0.01
            });

            // Top rail
            const topRail = new THREE.Mesh(
              new THREE.BoxGeometry(doorWidth - 0.04, frameW, frameD),
              frameMat
            );
            topRail.position.set(doorX, doorHeight/2 - frameW/2 - 0.02, d/2 + 0.04);
            group.add(topRail);

            // Bottom rail
            const bottomRail = new THREE.Mesh(
              new THREE.BoxGeometry(doorWidth - 0.04, frameW, frameD),
              frameMat
            );
            bottomRail.position.set(doorX, -doorHeight/2 + frameW/2 + 0.02, d/2 + 0.04);
            group.add(bottomRail);

            // Left stile
            const leftStile = new THREE.Mesh(
              new THREE.BoxGeometry(frameW, doorHeight - frameW * 2 - 0.04, frameD),
              frameMat
            );
            leftStile.position.set(doorX - doorWidth/2 + frameW/2 + 0.02, 0, d/2 + 0.04);
            group.add(leftStile);

            // Right stile
            const rightStile = new THREE.Mesh(
              new THREE.BoxGeometry(frameW, doorHeight - frameW * 2 - 0.04, frameD),
              frameMat
            );
            rightStile.position.set(doorX + doorWidth/2 - frameW/2 - 0.02, 0, d/2 + 0.04);
            group.add(rightStile);

            // Recessed center panel
            const panelMat = new THREE.MeshStandardMaterial({
              color: color,
              roughness: 0.45
            });
            const panelWidth = doorWidth - frameW * 2 - 0.08;
            const panelHeight = doorHeight - frameW * 2 - 0.08;
            const centerPanel = new THREE.Mesh(
              new THREE.BoxGeometry(panelWidth, panelHeight, 0.015),
              panelMat
            );
            centerPanel.position.set(doorX, 0, d/2 + 0.02);
            group.add(centerPanel);

            // HANDLE/PULL
            const handleMat = new THREE.MeshStandardMaterial({
              color: 0xAAAAAA,
              roughness: 0.15,
              metalness: 0.9
            });

            const handleY = el.type === 'wall-cabinet' ? -doorHeight * 0.25 : doorHeight * 0.25;
            const handleSide = (i < numDoors / 2) ? 1 : -1;
            const handleX = doorX + handleSide * (doorWidth/2 - 0.15);

            // Vertical bar pull
            const pullLength = 0.35;
            const pull = new THREE.Mesh(
              new THREE.CylinderGeometry(0.012, 0.012, pullLength, 8),
              handleMat
            );
            // No rotation - vertical by default
            pull.position.set(handleX, handleY, d/2 + 0.1);
            group.add(pull);

            // Pull standoffs (top and bottom of vertical pull)
            const standoffMat = new THREE.MeshStandardMaterial({
              color: 0x888888,
              roughness: 0.2,
              metalness: 0.85
            });
            [-pullLength/2 + 0.04, pullLength/2 - 0.04].forEach(yOffset => {
              const standoff = new THREE.Mesh(
                new THREE.CylinderGeometry(0.015, 0.015, 0.035, 8),
                standoffMat
              );
              standoff.rotation.x = Math.PI / 2;
              standoff.position.set(handleX, handleY + yOffset, d/2 + 0.08);
              group.add(standoff);
            });
          }

          // Toe kick for tall cabinet - proper recessed void
          const toeKickHeight = 0.33;
          const toeKickRecess = 0.25;

          // Toe kick back panel (visible back of recess)
          const tkBackMat = new THREE.MeshStandardMaterial({ color: 0x0a0a0a, roughness: 0.95 });
          const tkBack = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.1, toeKickHeight - 0.02, 0.02),
            tkBackMat
          );
          tkBack.position.set(0, -h/2 + toeKickHeight/2, d/2 - toeKickRecess);
          group.add(tkBack);

          // Toe kick bottom (floor of recess)
          const tkBottom = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.1, 0.02, toeKickRecess - 0.02),
            tkBackMat
          );
          tkBottom.position.set(0, -h/2 + 0.01, d/2 - toeKickRecess/2);
          group.add(tkBottom);

          // Left side panel of toe kick recess
          const tkLeft = new THREE.Mesh(
            new THREE.BoxGeometry(0.02, toeKickHeight - 0.02, toeKickRecess),
            tkBackMat
          );
          tkLeft.position.set(-w/2 + 0.05, -h/2 + toeKickHeight/2, d/2 - toeKickRecess/2);
          group.add(tkLeft);

          // Right side panel of toe kick recess
          const tkRight = new THREE.Mesh(
            new THREE.BoxGeometry(0.02, toeKickHeight - 0.02, toeKickRecess),
            tkBackMat
          );
          tkRight.position.set(w/2 - 0.05, -h/2 + toeKickHeight/2, d/2 - toeKickRecess/2);
          group.add(tkRight);

          // Cabinet overhang lip (bottom edge of cabinet above toe kick)
          const lipMat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.4 });
          const lip = new THREE.Mesh(
            new THREE.BoxGeometry(w, 0.03, 0.04),
            lipMat
          );
          lip.position.set(0, -h/2 + toeKickHeight + 0.015, d/2 - 0.02);
          group.add(lip);
          break;
        }

        case 'island': {
          // Kitchen island with overhang and proper toe kick
          const baseMat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.4 });

          // Toe kick dimensions
          const toeKickHeight = 0.33;
          const toeKickRecess = 0.25;
          const bodyHeight = h - toeKickHeight - 0.12; // Minus toe kick and countertop

          // Base cabinet portion (raised above toe kick)
          const base = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.4, bodyHeight, d - 0.4),
            baseMat
          );
          base.position.y = -h/2 + toeKickHeight + bodyHeight/2;
          group.add(base);

          // Countertop with overhang
          const counterMat = new THREE.MeshStandardMaterial({
            color: 0x4a4a4a,
            roughness: 0.15,
            metalness: 0.1
          });
          const counter = new THREE.Mesh(
            new THREE.BoxGeometry(w, 0.12, d),
            counterMat
          );
          counter.position.y = h/2 - 0.06;
          group.add(counter);

          // Add door details on front (adjusted for toe kick)
          const doorMat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.35 });
          const numDoors = Math.round(w / 2);
          const doorW = (w - 0.5) / numDoors - 0.05;
          const doorH = bodyHeight - 0.1;
          for (let i = 0; i < numDoors; i++) {
            const door = new THREE.Mesh(
              new THREE.BoxGeometry(doorW, doorH, 0.05),
              doorMat
            );
            door.position.set(-w/2 + 0.25 + doorW/2 + i * (doorW + 0.05), -h/2 + toeKickHeight + bodyHeight/2, d/2 - 0.2);
            group.add(door);
          }

          // Toe kick void on all four sides (island is free-standing)
          const tkBackMat = new THREE.MeshStandardMaterial({ color: 0x0a0a0a, roughness: 0.95 });

          // Front toe kick
          const tkFront = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.5, toeKickHeight - 0.02, 0.02),
            tkBackMat
          );
          tkFront.position.set(0, -h/2 + toeKickHeight/2, d/2 - 0.2 - toeKickRecess);
          group.add(tkFront);

          // Back toe kick
          const tkBackPanel = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.5, toeKickHeight - 0.02, 0.02),
            tkBackMat
          );
          tkBackPanel.position.set(0, -h/2 + toeKickHeight/2, -d/2 + 0.2 + toeKickRecess);
          group.add(tkBackPanel);

          // Left toe kick
          const tkLeftPanel = new THREE.Mesh(
            new THREE.BoxGeometry(0.02, toeKickHeight - 0.02, d - 0.5),
            tkBackMat
          );
          tkLeftPanel.position.set(-w/2 + 0.2 + toeKickRecess, -h/2 + toeKickHeight/2, 0);
          group.add(tkLeftPanel);

          // Right toe kick
          const tkRightPanel = new THREE.Mesh(
            new THREE.BoxGeometry(0.02, toeKickHeight - 0.02, d - 0.5),
            tkBackMat
          );
          tkRightPanel.position.set(w/2 - 0.2 - toeKickRecess, -h/2 + toeKickHeight/2, 0);
          group.add(tkRightPanel);

          // Toe kick floor
          const tkFloor = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.5, 0.02, d - 0.5),
            tkBackMat
          );
          tkFloor.position.set(0, -h/2 + 0.01, 0);
          group.add(tkFloor);

          // Cabinet overhang lip (all around)
          const lipMat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.4 });

          // Front lip
          const lipFront = new THREE.Mesh(new THREE.BoxGeometry(w - 0.4, 0.03, 0.04), lipMat);
          lipFront.position.set(0, -h/2 + toeKickHeight + 0.015, d/2 - 0.2);
          group.add(lipFront);

          // Back lip
          const lipBack = new THREE.Mesh(new THREE.BoxGeometry(w - 0.4, 0.03, 0.04), lipMat);
          lipBack.position.set(0, -h/2 + toeKickHeight + 0.015, -d/2 + 0.2);
          group.add(lipBack);

          // Left lip
          const lipLeft = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.03, d - 0.4), lipMat);
          lipLeft.position.set(-w/2 + 0.2, -h/2 + toeKickHeight + 0.015, 0);
          group.add(lipLeft);

          // Right lip
          const lipRight = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.03, d - 0.4), lipMat);
          lipRight.position.set(w/2 - 0.2, -h/2 + toeKickHeight + 0.015, 0);
          group.add(lipRight);

          break;
        }

        case 'countertop': {
          // Realistic countertop with texture support
          const ctopMat = createTexturedMaterial(color, textureUrl, {
            roughness: 0.1,
            metalness: 0.08
          });

          // Main slab
          const slab = new THREE.Mesh(
            new THREE.BoxGeometry(w, h, d),
            ctopMat
          );
          group.add(slab);

          // Beveled edge (front) - use same texture
          const edgeMat = createTexturedMaterial(color, textureUrl, {
            roughness: 0.08,
            metalness: 0.1
          });
          const edge = new THREE.Mesh(
            new THREE.BoxGeometry(w, h * 0.3, 0.02),
            edgeMat
          );
          edge.position.set(0, -h * 0.35, d/2 + 0.01);
          group.add(edge);
          break;
        }

        case 'backsplash': {
          // Tile backsplash with texture support
          const bsMat = createTexturedMaterial(color, textureUrl, {
            roughness: 0.25,
            metalness: 0.02
          });
          const bs = new THREE.Mesh(
            new THREE.BoxGeometry(w, h, 0.08),
            bsMat
          );
          group.add(bs);

          // Subtle grout lines
          const groutMat = new THREE.MeshStandardMaterial({ color: 0xCCCCCC, roughness: 0.9 });
          const tileSize = 0.5;
          for (let x = -w/2 + tileSize; x < w/2; x += tileSize) {
            const vGrout = new THREE.Mesh(
              new THREE.BoxGeometry(0.01, h - 0.1, 0.01),
              groutMat
            );
            vGrout.position.set(x, 0, 0.05);
            group.add(vGrout);
          }
          break;
        }

        case 'flooring': {
          // Wood plank flooring with texture support
          const plankMat = createTexturedMaterial(color, textureUrl, {
            roughness: 0.6,
            metalness: 0.0
          });
          const floorBase = new THREE.Mesh(
            new THREE.BoxGeometry(w, h, d),
            plankMat
          );
          group.add(floorBase);

          // Plank grooves
          const grooveMat = new THREE.MeshStandardMaterial({ color: 0x3a2a1a, roughness: 0.9 });
          const plankW = 0.5;
          for (let px = -w/2 + plankW; px < w/2; px += plankW) {
            const groove = new THREE.Mesh(
              new THREE.BoxGeometry(0.008, h + 0.01, d + 0.01),
              grooveMat
            );
            groove.position.set(px, 0.002, 0);
            group.add(groove);
          }
          break;
        }

        case 'tile': {
          // Tile floor/surface with texture support
          const tileMat = createTexturedMaterial(color, textureUrl, {
            roughness: 0.3,
            metalness: 0.05
          });
          const tileBase = new THREE.Mesh(
            new THREE.BoxGeometry(w, h, d),
            tileMat
          );
          group.add(tileBase);

          // Grout lines
          const tileGroutMat = new THREE.MeshStandardMaterial({ color: 0x888888, roughness: 0.9 });
          const tileSz = 0.5;
          for (let tx = -w/2 + tileSz; tx < w/2; tx += tileSz) {
            const vLine = new THREE.Mesh(
              new THREE.BoxGeometry(0.015, h + 0.005, d + 0.005),
              tileGroutMat
            );
            vLine.position.set(tx, 0.003, 0);
            group.add(vLine);
          }
          for (let tz = -d/2 + tileSz; tz < d/2; tz += tileSz) {
            const hLine = new THREE.Mesh(
              new THREE.BoxGeometry(w + 0.005, h + 0.005, 0.015),
              tileGroutMat
            );
            hLine.position.set(0, 0.003, tz);
            group.add(hLine);
          }
          break;
        }

        case 'sink': {
          // Stainless steel sink
          const sinkMat = new THREE.MeshStandardMaterial({
            color: 0xD8D8D8,
            roughness: 0.25,
            metalness: 0.75
          });

          // Sink rim
          const rim = new THREE.Mesh(
            new THREE.BoxGeometry(w, 0.08, d),
            sinkMat
          );
          rim.position.y = h/2 - 0.04;
          group.add(rim);

          // Basin (hollow effect)
          const basinMat = new THREE.MeshStandardMaterial({
            color: 0x3a3a3a,
            roughness: 0.4,
            metalness: 0.6
          });
          const basin = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.15, h - 0.1, d - 0.15),
            basinMat
          );
          basin.position.y = -0.02;
          group.add(basin);

          // Faucet base
          const chromeMat = new THREE.MeshStandardMaterial({
            color: 0xE0E0E0,
            roughness: 0.05,
            metalness: 0.95
          });
          const faucetBase = new THREE.Mesh(
            new THREE.CylinderGeometry(0.04, 0.06, 0.15, 16),
            chromeMat
          );
          faucetBase.position.set(0, h/2 + 0.08, -d/2 + 0.15);
          group.add(faucetBase);

          // Faucet neck
          const neck = new THREE.Mesh(
            new THREE.CylinderGeometry(0.025, 0.025, 0.5, 12),
            chromeMat
          );
          neck.position.set(0, h/2 + 0.35, -d/2 + 0.15);
          group.add(neck);

          // Faucet spout (curved)
          const spout = new THREE.Mesh(
            new THREE.TorusGeometry(0.15, 0.02, 8, 12, Math.PI * 0.6),
            chromeMat
          );
          spout.rotation.x = Math.PI;
          spout.rotation.z = Math.PI / 2;
          spout.position.set(0, h/2 + 0.5, -d/2 + 0.25);
          group.add(spout);
          break;
        }

        case 'stove': {
          // Professional range/stove
          const stoveMat = new THREE.MeshStandardMaterial({
            color: 0x2a2a2a,
            roughness: 0.3,
            metalness: 0.5
          });

          // Main body
          const stoveBody = new THREE.Mesh(
            new THREE.BoxGeometry(w, h, d),
            stoveMat
          );
          group.add(stoveBody);

          // Cooktop surface (glass or steel)
          const cooktopMat = new THREE.MeshStandardMaterial({
            color: 0x1a1a1a,
            roughness: 0.1,
            metalness: 0.4
          });
          const cooktop = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.08, 0.04, d - 0.15),
            cooktopMat
          );
          cooktop.position.y = h/2 - 0.02;
          group.add(cooktop);

          // Burner grates
          const grateMat = new THREE.MeshStandardMaterial({
            color: 0x1a1a1a,
            roughness: 0.6,
            metalness: 0.3
          });

          const burnerLayout = [
            [-w * 0.25, -d * 0.2], [w * 0.25, -d * 0.2],
            [-w * 0.25, d * 0.2], [w * 0.25, d * 0.2]
          ];

          burnerLayout.forEach(([bx, bz]) => {
            // Grate
            const grate = new THREE.Mesh(
              new THREE.BoxGeometry(0.5, 0.04, 0.5),
              grateMat
            );
            grate.position.set(bx, h/2 + 0.02, bz);
            group.add(grate);

            // Burner ring
            const ringMat = new THREE.MeshStandardMaterial({
              color: 0x333333,
              roughness: 0.5,
              metalness: 0.4
            });
            const ring = new THREE.Mesh(
              new THREE.TorusGeometry(0.15, 0.02, 8, 24),
              ringMat
            );
            ring.rotation.x = Math.PI / 2;
            ring.position.set(bx, h/2, bz);
            group.add(ring);
          });

          // Control knobs
          const knobMat = new THREE.MeshStandardMaterial({
            color: 0x3a3a3a,
            roughness: 0.4,
            metalness: 0.3
          });
          for (let i = 0; i < 5; i++) {
            const knob = new THREE.Mesh(
              new THREE.CylinderGeometry(0.04, 0.04, 0.03, 16),
              knobMat
            );
            knob.rotation.x = Math.PI / 2;
            knob.position.set(-w/2 + 0.2 + i * 0.18, h/2 - 0.3, d/2 + 0.02);
            group.add(knob);
          }

          // Oven door
          const ovenDoorMat = new THREE.MeshStandardMaterial({
            color: 0x2a2a2a,
            roughness: 0.25,
            metalness: 0.45
          });
          const ovenDoor = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.15, h * 0.5, 0.05),
            ovenDoorMat
          );
          ovenDoor.position.set(0, -h * 0.15, d/2);
          group.add(ovenDoor);

          // Oven window
          const glassMat = new THREE.MeshStandardMaterial({
            color: 0x111111,
            roughness: 0.05,
            metalness: 0.1,
            transparent: true,
            opacity: 0.85
          });
          const ovenWindow = new THREE.Mesh(
            new THREE.BoxGeometry(w * 0.6, h * 0.35, 0.02),
            glassMat
          );
          ovenWindow.position.set(0, -h * 0.15, d/2 + 0.04);
          group.add(ovenWindow);

          // Oven handle
          const handleMat = new THREE.MeshStandardMaterial({
            color: 0xB0B0B0,
            roughness: 0.15,
            metalness: 0.85
          });
          const ovenHandle = new THREE.Mesh(
            new THREE.CylinderGeometry(0.02, 0.02, w * 0.7, 12),
            handleMat
          );
          ovenHandle.rotation.z = Math.PI / 2;
          ovenHandle.position.set(0, h * 0.12, d/2 + 0.08);
          group.add(ovenHandle);
          break;
        }

        case 'refrigerator': {
          // French door refrigerator
          const fridgeMat = new THREE.MeshStandardMaterial({
            color: 0xD5D5D5,
            roughness: 0.25,
            metalness: 0.55
          });

          // Main body
          const fridgeBody = new THREE.Mesh(
            new THREE.BoxGeometry(w, h, d),
            fridgeMat
          );
          group.add(fridgeBody);

          // Upper doors (French style - two doors)
          const doorMat = new THREE.MeshStandardMaterial({
            color: 0xE0E0E0,
            roughness: 0.2,
            metalness: 0.6
          });

          const upperDoorH = h * 0.65;
          const doorW = (w - 0.15) / 2;

          // Left upper door
          const leftDoor = new THREE.Mesh(
            new THREE.BoxGeometry(doorW, upperDoorH, 0.04),
            doorMat
          );
          leftDoor.position.set(-doorW/2 - 0.02, h * 0.15, d/2 + 0.02);
          group.add(leftDoor);

          // Right upper door
          const rightDoor = new THREE.Mesh(
            new THREE.BoxGeometry(doorW, upperDoorH, 0.04),
            doorMat
          );
          rightDoor.position.set(doorW/2 + 0.02, h * 0.15, d/2 + 0.02);
          group.add(rightDoor);

          // Freezer drawer
          const freezerDrawer = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.12, h * 0.28, 0.04),
            doorMat
          );
          freezerDrawer.position.set(0, -h * 0.33, d/2 + 0.02);
          group.add(freezerDrawer);

          // Handles
          const handleMat = new THREE.MeshStandardMaterial({
            color: 0xA0A0A0,
            roughness: 0.15,
            metalness: 0.9
          });

          // Left handle
          const leftHandle = new THREE.Mesh(
            new THREE.BoxGeometry(0.04, 0.7, 0.06),
            handleMat
          );
          leftHandle.position.set(-0.08, h * 0.15, d/2 + 0.08);
          group.add(leftHandle);

          // Right handle
          const rightHandle = new THREE.Mesh(
            new THREE.BoxGeometry(0.04, 0.7, 0.06),
            handleMat
          );
          rightHandle.position.set(0.08, h * 0.15, d/2 + 0.08);
          group.add(rightHandle);

          // Freezer handle
          const freezerHandle = new THREE.Mesh(
            new THREE.BoxGeometry(w * 0.6, 0.04, 0.06),
            handleMat
          );
          freezerHandle.position.set(0, -h * 0.2, d/2 + 0.08);
          group.add(freezerHandle);

          // Water/ice dispenser
          const dispenserMat = new THREE.MeshStandardMaterial({
            color: 0x2a2a2a,
            roughness: 0.3
          });
          const dispenser = new THREE.Mesh(
            new THREE.BoxGeometry(0.3, 0.25, 0.02),
            dispenserMat
          );
          dispenser.position.set(0, h * 0.25, d/2 + 0.05);
          group.add(dispenser);
          break;
        }

        case 'dishwasher': {
          // Built-in dishwasher
          const dwMat = new THREE.MeshStandardMaterial({
            color: 0xD0D0D0,
            roughness: 0.25,
            metalness: 0.55
          });

          const dwBody = new THREE.Mesh(
            new THREE.BoxGeometry(w, h, d),
            dwMat
          );
          group.add(dwBody);

          // Control panel
          const dwPanel = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.1, 0.25, 0.02),
            new THREE.MeshStandardMaterial({ color: 0x404040 })
          );
          dwPanel.position.set(0, h/2 - 0.2, d/2 + 0.02);
          group.add(dwPanel);

          // Handle
          const dwHandle = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.4, 0.05, 0.08),
            new THREE.MeshStandardMaterial({ color: 0x808080, metalness: 0.8 })
          );
          dwHandle.position.set(0, h/2 - 0.45, d/2 + 0.06);
          group.add(dwHandle);
          break;
        }

        case 'microwave':
          const mwMat = new THREE.MeshStandardMaterial({ color: 0x3a3a3a, roughness: 0.4, metalness: 0.3 });
          const mwBody = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), mwMat);
          group.add(mwBody);

          // Glass door
          const mwGlass = new THREE.Mesh(
            new THREE.BoxGeometry(w * 0.6, h - 0.15, 0.02),
            new THREE.MeshStandardMaterial({ color: 0x111111, transparent: true, opacity: 0.8 })
          );
          mwGlass.position.set(-w * 0.15, 0, d/2 + 0.02);
          group.add(mwGlass);
          break;

        case 'range-hood':
          // Trapezoidal range hood
          const hoodMat = new THREE.MeshStandardMaterial({ color: 0x808080, metalness: 0.6, roughness: 0.3 });
          const hoodShape = new THREE.Shape();
          hoodShape.moveTo(-w/2, 0);
          hoodShape.lineTo(-w/3, h);
          hoodShape.lineTo(w/3, h);
          hoodShape.lineTo(w/2, 0);
          hoodShape.closePath();

          const extrudeSettings = { depth: d, bevelEnabled: false };
          const hoodGeom = new THREE.ExtrudeGeometry(hoodShape, extrudeSettings);
          hoodGeom.rotateX(Math.PI / 2);
          hoodGeom.translate(0, h/2, -d/2);
          const hood = new THREE.Mesh(hoodGeom, hoodMat);
          group.add(hood);
          break;

        case 'oven':
          const ovenMat = new THREE.MeshStandardMaterial({ color: 0x2a2a2a, roughness: 0.3, metalness: 0.4 });
          const ovenBody = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), ovenMat);
          group.add(ovenBody);

          // Glass door
          const ovenGlass = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.2, h * 0.6, 0.02),
            new THREE.MeshStandardMaterial({ color: 0x1a1a1a, transparent: true, opacity: 0.7 })
          );
          ovenGlass.position.set(0, -h * 0.1, d/2 + 0.02);
          group.add(ovenGlass);

          // Handle
          const ovenHandle = new THREE.Mesh(
            new THREE.BoxGeometry(w * 0.6, 0.05, 0.1),
            new THREE.MeshStandardMaterial({ color: 0xA0A0A0, metalness: 0.7 })
          );
          ovenHandle.position.set(0, h * 0.3, d/2 + 0.08);
          group.add(ovenHandle);
          break;

        case 'door':
          // Door with frame
          const doorMat2 = new THREE.MeshStandardMaterial({ color: 0xDEB887, roughness: 0.6 });
          const doorPanel = new THREE.Mesh(new THREE.BoxGeometry(w, h, 0.15), doorMat2);
          group.add(doorPanel);

          // Door frame
          const frameMat = new THREE.MeshStandardMaterial({ color: 0xFFFFFF, roughness: 0.5 });
          const frameTop = new THREE.Mesh(new THREE.BoxGeometry(w + 0.2, 0.1, 0.2), frameMat);
          frameTop.position.y = h/2 + 0.05;
          group.add(frameTop);
          break;

        case 'window': {
          // Window with frame, glass, and outdoor view
          const windowFrameMat = new THREE.MeshStandardMaterial({ color: 0xFFFFFF, roughness: 0.5 });
          const windowFrame = new THREE.Mesh(new THREE.BoxGeometry(w, h, 0.15), windowFrameMat);
          group.add(windowFrame);

          // Get outdoor colors based on time of day
          const outdoorPalette = OUTDOOR_COLORS[sceneSettings.timeOfDay] || OUTDOOR_COLORS.noon;

          // Outdoor background (behind glass) - sky gradient effect
          const skyMat = new THREE.MeshBasicMaterial({ color: outdoorPalette.sky });
          const skyPane = new THREE.Mesh(new THREE.BoxGeometry(w - 0.25, h - 0.25, 0.01), skyMat);
          skyPane.position.z = -0.05;
          group.add(skyPane);

          // Horizon line (ground/trees suggestion)
          const horizonMat = new THREE.MeshBasicMaterial({ color: outdoorPalette.horizon });
          const horizonPane = new THREE.Mesh(new THREE.BoxGeometry(w - 0.25, h * 0.3, 0.01), horizonMat);
          horizonPane.position.set(0, -h * 0.35, -0.04);
          group.add(horizonPane);

          // Add simple tree silhouettes for morning/noon/evening
          if (sceneSettings.timeOfDay !== 'night') {
            const treeMat = new THREE.MeshBasicMaterial({ color: 0x228B22 });
            // Left tree
            const tree1 = new THREE.Mesh(new THREE.ConeGeometry(0.15, 0.4, 4), treeMat);
            tree1.position.set(-w * 0.3, -h * 0.15, -0.03);
            group.add(tree1);
            // Right tree
            const tree2 = new THREE.Mesh(new THREE.ConeGeometry(0.12, 0.35, 4), treeMat);
            tree2.position.set(w * 0.25, -h * 0.18, -0.03);
            group.add(tree2);
          } else {
            // Night - add stars
            const starMat = new THREE.MeshBasicMaterial({ color: 0xFFFFFF });
            for (let i = 0; i < 5; i++) {
              const star = new THREE.Mesh(new THREE.SphereGeometry(0.015, 4, 4), starMat);
              star.position.set(
                (Math.random() - 0.5) * (w - 0.4),
                (Math.random() - 0.3) * (h * 0.5),
                -0.03
              );
              group.add(star);
            }
            // Moon
            const moonMat = new THREE.MeshBasicMaterial({ color: 0xFFFACD });
            const moon = new THREE.Mesh(new THREE.CircleGeometry(0.1, 16), moonMat);
            moon.position.set(w * 0.25, h * 0.25, -0.03);
            group.add(moon);
          }

          // Glass pane (semi-transparent over the view)
          const glassColor = sceneSettings.timeOfDay === 'night' ? 0x1a1a3a : 0x87CEEB;
          const glassMat3 = new THREE.MeshStandardMaterial({
            color: glassColor,
            transparent: true,
            opacity: 0.2,
            roughness: 0.05,
            metalness: 0.1
          });
          const glass = new THREE.Mesh(new THREE.BoxGeometry(w - 0.2, h - 0.2, 0.02), glassMat3);
          glass.position.z = 0.05;
          group.add(glass);

          // Center divider
          const divider = new THREE.Mesh(new THREE.BoxGeometry(0.05, h - 0.1, 0.1), windowFrameMat);
          group.add(divider);
          break;
        }

        case 'wall':
          // Wall segment (drywall)
          const wallMat = new THREE.MeshStandardMaterial({ color: 0xF5F5DC, roughness: 0.8 });
          const wallMesh = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), wallMat);
          group.add(wallMesh);
          break;

        case 'wall-wood-2x4':
        case 'wall-wood-2x6': {
          // Wood framed wall
          const woodColor = el.type.includes('2x4') ? 0xDEB887 : 0xCD853F;
          const studWidth = el.type.includes('2x4') ? 0.1 : 0.15;
          const woodMat = new THREE.MeshStandardMaterial({ color: woodColor, roughness: 0.7 });

          // Studs (vertical)
          const studSpacing = 1.33; // 16" on center
          for (let sx = -w/2 + studSpacing/2; sx <= w/2; sx += studSpacing) {
            const stud = new THREE.Mesh(
              new THREE.BoxGeometry(studWidth, h - 0.2, d * 0.8),
              woodMat
            );
            stud.position.set(sx, 0, 0);
            group.add(stud);
          }

          // Top and bottom plates
          const plateMat = new THREE.MeshStandardMaterial({ color: woodColor, roughness: 0.6 });
          const topPlate = new THREE.Mesh(new THREE.BoxGeometry(w, 0.1, d * 0.8), plateMat);
          topPlate.position.y = h/2 - 0.05;
          group.add(topPlate);

          const botPlate = new THREE.Mesh(new THREE.BoxGeometry(w, 0.1, d * 0.8), plateMat);
          botPlate.position.y = -h/2 + 0.05;
          group.add(botPlate);
          break;
        }

        case 'wall-steel':
        case 'wall-aluminum': {
          // Metal stud wall
          const metalColor = el.type.includes('steel') ? 0x708090 : 0xC0C0C0;
          const metalMat = new THREE.MeshStandardMaterial({
            color: metalColor,
            roughness: 0.3,
            metalness: 0.7
          });

          // C-channel studs
          const studSpacing = 1.33;
          for (let sx = -w/2 + studSpacing/2; sx <= w/2; sx += studSpacing) {
            const stud = new THREE.Mesh(
              new THREE.BoxGeometry(0.05, h - 0.15, d * 0.7),
              metalMat
            );
            stud.position.set(sx, 0, 0);
            group.add(stud);
          }

          // Track (top and bottom)
          const trackMat = new THREE.MeshStandardMaterial({
            color: metalColor,
            roughness: 0.25,
            metalness: 0.8
          });
          const topTrack = new THREE.Mesh(new THREE.BoxGeometry(w, 0.08, d * 0.8), trackMat);
          topTrack.position.y = h/2 - 0.04;
          group.add(topTrack);

          const botTrack = new THREE.Mesh(new THREE.BoxGeometry(w, 0.08, d * 0.8), trackMat);
          botTrack.position.y = -h/2 + 0.04;
          group.add(botTrack);
          break;
        }

        case 'wall-concrete': {
          // Concrete wall
          const concreteMat = new THREE.MeshStandardMaterial({
            color: 0x808080,
            roughness: 0.9,
            metalness: 0
          });
          const concreteWall = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), concreteMat);
          group.add(concreteWall);
          break;
        }

        case 'wall-brick': {
          // Brick wall
          const brickMat = new THREE.MeshStandardMaterial({
            color: 0xB22222,
            roughness: 0.8
          });
          const brickWall = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), brickMat);
          group.add(brickWall);

          // Add mortar lines (grooves)
          const mortarMat = new THREE.MeshStandardMaterial({ color: 0xCCCCCC, roughness: 0.9 });
          const brickH = 0.25;
          for (let by = -h/2 + brickH; by < h/2; by += brickH) {
            const mortar = new THREE.Mesh(
              new THREE.BoxGeometry(w + 0.01, 0.02, d * 0.5),
              mortarMat
            );
            mortar.position.set(0, by, d/4);
            group.add(mortar);
          }
          break;
        }

        case 'wall-block': {
          // CMU block wall
          const blockMat = new THREE.MeshStandardMaterial({
            color: 0x696969,
            roughness: 0.85
          });
          const blockWall = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), blockMat);
          group.add(blockWall);
          break;
        }

        case 'double-door': {
          // Double door
          const doorMat = new THREE.MeshStandardMaterial({ color: 0xDEB887, roughness: 0.6 });
          const frameMat = new THREE.MeshStandardMaterial({ color: 0xFFFFFF, roughness: 0.5 });

          // Left door
          const leftDoor = new THREE.Mesh(new THREE.BoxGeometry(w/2 - 0.05, h, 0.1), doorMat);
          leftDoor.position.x = -w/4;
          group.add(leftDoor);

          // Right door
          const rightDoor = new THREE.Mesh(new THREE.BoxGeometry(w/2 - 0.05, h, 0.1), doorMat);
          rightDoor.position.x = w/4;
          group.add(rightDoor);

          // Frame
          const topFrame = new THREE.Mesh(new THREE.BoxGeometry(w + 0.2, 0.1, 0.2), frameMat);
          topFrame.position.y = h/2 + 0.05;
          group.add(topFrame);

          // Handles
          const handleMat = new THREE.MeshStandardMaterial({ color: 0xFFD700, metalness: 0.8 });
          const leftHandle = new THREE.Mesh(new THREE.SphereGeometry(0.04, 8, 8), handleMat);
          leftHandle.position.set(-0.1, 0, 0.08);
          group.add(leftHandle);
          const rightHandle = new THREE.Mesh(new THREE.SphereGeometry(0.04, 8, 8), handleMat);
          rightHandle.position.set(0.1, 0, 0.08);
          group.add(rightHandle);
          break;
        }

        case 'sliding-door': {
          // Sliding glass door
          const frameMat = new THREE.MeshStandardMaterial({ color: 0xA9A9A9, roughness: 0.4, metalness: 0.3 });
          const glassMat = new THREE.MeshStandardMaterial({
            color: 0xADD8E6,
            transparent: true,
            opacity: 0.4,
            roughness: 0.05
          });

          // Frame
          const frame = new THREE.Mesh(new THREE.BoxGeometry(w, h, 0.15), frameMat);
          group.add(frame);

          // Glass panels
          const leftGlass = new THREE.Mesh(new THREE.BoxGeometry(w/2 - 0.1, h - 0.2, 0.02), glassMat);
          leftGlass.position.set(-w/4, 0, 0.05);
          group.add(leftGlass);

          const rightGlass = new THREE.Mesh(new THREE.BoxGeometry(w/2 - 0.1, h - 0.2, 0.02), glassMat);
          rightGlass.position.set(w/4, 0, 0.07);
          group.add(rightGlass);

          // Track
          const trackMat = new THREE.MeshStandardMaterial({ color: 0x666666 });
          const track = new THREE.Mesh(new THREE.BoxGeometry(w, 0.05, 0.2), trackMat);
          track.position.y = -h/2 + 0.025;
          group.add(track);
          break;
        }

        case 'entry-archway': {
          // Archway
          const archMat = new THREE.MeshStandardMaterial({ color: 0xDAA520, roughness: 0.5 });

          // Create arch shape
          const archShape = new THREE.Shape();
          archShape.moveTo(-w/2, 0);
          archShape.lineTo(-w/2, h * 0.6);
          archShape.quadraticCurveTo(0, h * 1.1, w/2, h * 0.6);
          archShape.lineTo(w/2, 0);

          // Inner cutout
          const holePath = new THREE.Path();
          holePath.moveTo(-w/2 + 0.15, 0);
          holePath.lineTo(-w/2 + 0.15, h * 0.55);
          holePath.quadraticCurveTo(0, h * 1.0, w/2 - 0.15, h * 0.55);
          holePath.lineTo(w/2 - 0.15, 0);
          archShape.holes.push(holePath);

          const archGeom = new THREE.ExtrudeGeometry(archShape, { depth: d, bevelEnabled: false });
          archGeom.rotateX(Math.PI / 2);
          archGeom.translate(0, h/2, -d/2);
          const arch = new THREE.Mesh(archGeom, archMat);
          group.add(arch);
          break;
        }

        case 'garage-door': {
          // Garage door
          const garageMat = new THREE.MeshStandardMaterial({ color: 0xA9A9A9, roughness: 0.5 });
          const doorBody = new THREE.Mesh(new THREE.BoxGeometry(w, h, 0.1), garageMat);
          group.add(doorBody);

          // Panel sections
          const panelMat = new THREE.MeshStandardMaterial({ color: 0x888888, roughness: 0.4 });
          const sections = 4;
          for (let i = 0; i < sections; i++) {
            const panel = new THREE.Mesh(
              new THREE.BoxGeometry(w - 0.1, h/sections - 0.02, 0.02),
              panelMat
            );
            panel.position.set(0, h/2 - (h/sections)/2 - i * (h/sections), 0.06);
            group.add(panel);
          }

          // Handle
          const handleMat = new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.5 });
          const handle = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.08, 0.05), handleMat);
          handle.position.set(0, -h * 0.35, 0.1);
          group.add(handle);
          break;
        }

        default:
          // Default box
          const defaultMat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.5 });
          const defaultMesh = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), defaultMat);
          group.add(defaultMesh);
      }

      // Set shadows for all meshes in group
      group.traverse(child => {
        if (child.isMesh) {
          child.castShadow = true;
          child.receiveShadow = true;
        }
      });

      return { group, height: h };
    }

    function render3D() {
      if (!scene || currentView !== '3d') return;

      // Clear non-lights
      scene.children = scene.children.filter(c => c.type.includes('Light'));

      // Floor
      const floorMat = new THREE.MeshStandardMaterial({
        color: 0xD2B48C, // Tan floor color
        roughness: 0.8
      });
      const floor = new THREE.Mesh(
        new THREE.PlaneGeometry(roomWidth + 4, roomDepth + 4),
        floorMat
      );
      floor.rotation.x = -Math.PI / 2;
      floor.position.set(roomWidth / 2, 0, roomDepth / 2);
      floor.receiveShadow = true;
      scene.add(floor);

      // Room walls (3 walls, open front)
      const wallHeight = 8;
      const wallMat = new THREE.MeshStandardMaterial({
        color: 0xFFFAF0, // Ivory walls
        roughness: 0.9,
        side: THREE.DoubleSide
      });

      // Back wall
      const backWall = new THREE.Mesh(
        new THREE.PlaneGeometry(roomWidth, wallHeight),
        wallMat
      );
      backWall.position.set(roomWidth / 2, wallHeight / 2, 0);
      backWall.receiveShadow = true;
      scene.add(backWall);

      // Left wall
      const leftWall = new THREE.Mesh(
        new THREE.PlaneGeometry(roomDepth, wallHeight),
        wallMat
      );
      leftWall.rotation.y = Math.PI / 2;
      leftWall.position.set(0, wallHeight / 2, roomDepth / 2);
      leftWall.receiveShadow = true;
      scene.add(leftWall);

      // Right wall
      const rightWall = new THREE.Mesh(
        new THREE.PlaneGeometry(roomDepth, wallHeight),
        wallMat
      );
      rightWall.rotation.y = -Math.PI / 2;
      rightWall.position.set(roomWidth, wallHeight / 2, roomDepth / 2);
      rightWall.receiveShadow = true;
      scene.add(rightWall);

      // Elements
      elements.forEach(el => {
        const { group, height } = create3DElement(el);

        // Convert 2D position to 3D
        // In 2D: origin is top-left, Y goes down
        // In 3D: origin is corner, Z goes forward (into room)
        const xPos = (el.x / pixelsPerFoot) + el.width / 2;
        const zPos = (el.y / pixelsPerFoot) + el.height / 2;
        const yPos = get3DYPosition(el.type, height);

        group.position.set(xPos, yPos, zPos);
        group.rotation.y = -(el.rotation || 0) * Math.PI / 180;

        scene.add(group);
      });

      // Update camera target
      controls.target.set(roomWidth / 2, 1.5, roomDepth / 2);
      camera.position.set(roomWidth * 1.2, roomWidth * 0.6, roomDepth * 1.3);
      controls.update();

      // Animation loop with proper ID tracking
      function animate() {
        if (currentView !== '3d') {
          animationId = null;
          return;
        }
        animationId = requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
      }
      animate();
    }

    // ===== ZOOM =====
    function zoomIn() {
      const wrapper = document.getElementById('canvasWrapper');
      const centerX = wrapper.clientWidth / 2;
      const centerY = wrapper.clientHeight / 2;

      const worldX = (centerX - panX) / pixelsPerFoot;
      const worldY = (centerY - panY) / pixelsPerFoot;

      pixelsPerFoot = Math.min(pixelsPerFoot * 1.2, 100);

      panX = centerX - worldX * pixelsPerFoot;
      panY = centerY - worldY * pixelsPerFoot;

      updateZoomDisplay();
      draw();
    }

    function zoomOut() {
      const wrapper = document.getElementById('canvasWrapper');
      const centerX = wrapper.clientWidth / 2;
      const centerY = wrapper.clientHeight / 2;

      const worldX = (centerX - panX) / pixelsPerFoot;
      const worldY = (centerY - panY) / pixelsPerFoot;

      pixelsPerFoot = Math.max(pixelsPerFoot / 1.2, 15);

      panX = centerX - worldX * pixelsPerFoot;
      panY = centerY - worldY * pixelsPerFoot;

      updateZoomDisplay();
      draw();
    }

    function updateZoomDisplay() {
      const zoomPercent = Math.round(pixelsPerFoot / 40 * 100);
      document.getElementById('zoomLevel').textContent = zoomPercent + '%';
    }

    // ===== ROOM =====
    function updateRoom() {
      roomWidth = parseInt(document.getElementById('roomWidth').value) || 20;
      roomDepth = parseInt(document.getElementById('roomDepth').value) || 16;

      if (document.getElementById('scaleMode').value === 'fit') {
        fitToScreen();
      } else {
        updateCanvasSize();
      }

      if (currentView === '3d') {
        init3D();
        render3D();
      }
    }

    // ===== CABINET SETTINGS =====
    function updateCabinetSettings() {
      // Get values from dropdowns
      cabinetSettings.construction = document.getElementById('cabinetConstruction').value;
      cabinetSettings.doorStyle = document.getElementById('doorStyle').value;
      cabinetSettings.doorOverlay = document.getElementById('doorOverlay').value;

      // Update any selected cabinet element with new settings
      if (selectedElement && selectedElement.type.includes('cabinet')) {
        selectedElement.construction = cabinetSettings.construction;
        selectedElement.doorStyle = cabinetSettings.doorStyle;
        selectedElement.doorOverlay = cabinetSettings.doorOverlay;

        // Redraw
        if (currentView === '2d') {
          draw();
        } else {
          render3D();
        }
        saveUndoState();
      }

      // Show toast with current settings
      const constructionLabel = cabinetSettings.construction === 'frameless' ? 'Frameless (Euro)' : 'Framed (Face Frame)';
      showToast(`Cabinet settings: ${constructionLabel}, ${cabinetSettings.doorStyle} style`);
    }

    function updateFloorLevel() {
      const floorSelect = document.getElementById('floorLevel');
      const value = floorSelect.value;

      if (value === 'add') {
        // Add new floor
        const newFloorNum = cabinetSettings.floors.length + 1;
        const newFloor = {
          id: newFloorNum,
          name: `Floor ${newFloorNum}`,
          height: (newFloorNum - 1) * 10 // 10 feet per floor
        };
        cabinetSettings.floors.push(newFloor);

        // Add new option to dropdown
        const newOption = document.createElement('option');
        newOption.value = newFloorNum;
        newOption.textContent = `Floor ${newFloorNum}`;
        floorSelect.insertBefore(newOption, floorSelect.lastElementChild);

        // Select the new floor
        floorSelect.value = newFloorNum;
        cabinetSettings.currentFloor = newFloorNum;

        showToast(`Added Floor ${newFloorNum}`);
      } else {
        // Switch to selected floor
        cabinetSettings.currentFloor = parseInt(value);
        showToast(`Switched to Floor ${value}`);
      }

      // Filter elements to show only current floor
      updateFloorVisibility();

      if (currentView === '2d') {
        draw();
      } else {
        render3D();
      }
    }

    function updateTimeOfDay() {
      const timeSelect = document.getElementById('timeOfDay');
      sceneSettings.timeOfDay = timeSelect.value;

      // Update ambient lighting based on time of day
      if (scene) {
        const colors = OUTDOOR_COLORS[sceneSettings.timeOfDay];

        // Update ambient light
        scene.traverse(obj => {
          if (obj.isAmbientLight) {
            obj.color.setHex(colors.ambient);
            obj.intensity = sceneSettings.timeOfDay === 'night' ? 0.3 : 0.6;
          }
          if (obj.isDirectionalLight) {
            // Adjust sun position/color based on time
            if (sceneSettings.timeOfDay === 'morning') {
              obj.position.set(20, 15, 10);
              obj.color.setHex(0xFDB813);
              obj.intensity = 0.7;
            } else if (sceneSettings.timeOfDay === 'noon') {
              obj.position.set(15, 30, 15);
              obj.color.setHex(0xFFFFFF);
              obj.intensity = 0.9;
            } else if (sceneSettings.timeOfDay === 'evening') {
              obj.position.set(-20, 12, 10);
              obj.color.setHex(0xFFA07A);
              obj.intensity = 0.6;
            } else { // night
              obj.position.set(-15, 20, 10);
              obj.color.setHex(0x4169E1);
              obj.intensity = 0.2;
            }
          }
        });

        // Re-render to show changes
        render3D();
      }

      const timeLabels = {
        morning: 'Morning (Sunrise)',
        noon: 'Noon (Daylight)',
        evening: 'Evening (Sunset)',
        night: 'Night'
      };
      showToast(`Time of day: ${timeLabels[sceneSettings.timeOfDay]}`);
    }

    function updateFloorVisibility() {
      // Mark elements with their floor level if not set
      elements.forEach(el => {
        if (!el.floorLevel) {
          el.floorLevel = 1; // Default to floor 1
        }
      });
    }

    function getElementsForCurrentFloor() {
      return elements.filter(el => !el.floorLevel || el.floorLevel === cabinetSettings.currentFloor);
    }

    // ===== PROPERTIES =====
    function updateProperties() {
      const empty = document.getElementById('propertiesEmpty');
      const content = document.getElementById('propertiesContent');

      if (selectedElement) {
        empty.style.display = 'none';
        content.style.display = 'block';

        document.getElementById('propType').textContent = selectedElement.label;
        // Show decimal value in input, formatted display beside it
        document.getElementById('propWidth').value = selectedElement.width.toFixed(4).replace(/\.?0+$/, '');
        document.getElementById('propHeight').value = selectedElement.height.toFixed(4).replace(/\.?0+$/, '');
        // Show formatted feet-inches display
        const widthDisplay = document.getElementById('propWidthDisplay');
        const heightDisplay = document.getElementById('propHeightDisplay');
        if (widthDisplay) widthDisplay.textContent = formatDimension(selectedElement.width);
        if (heightDisplay) heightDisplay.textContent = formatDimension(selectedElement.height);

        document.getElementById('propColor').value = selectedElement.color;
        document.getElementById('propRotation').textContent = (selectedElement.rotation || 0) + '';

        const texturePreview = document.getElementById('propTexture');
        if (selectedElement.texture) {
          texturePreview.style.background = `url(${selectedElement.texture}) center/cover`;
        } else {
          texturePreview.style.background = selectedElement.color;
        }

        // Populate standard sizes dropdown
        const standardSizeRow = document.getElementById('standardSizeRow');
        const standardSizeSelect = document.getElementById('propStandardSize');
        const standardSizes = getStandardSizesForType(selectedElement.type);

        if (standardSizes.length > 0) {
          standardSizeRow.style.display = 'flex';
          standardSizeSelect.innerHTML = '<option value="">Custom</option>' +
            standardSizes.map(s => `<option value="${s.width}x${s.height}">${s.label}</option>`).join('');
        } else {
          standardSizeRow.style.display = 'none';
        }

        // Update pricing section
        const pricingSection = document.getElementById('pricingSection');
        if (pricingSection && checkPermission('canViewPrices')) {
          pricingSection.style.display = 'block';

          const priceInfo = getElementPrice(selectedElement);
          document.getElementById('propBasePrice').textContent = '$' + priceInfo.price.toFixed(2);
          document.getElementById('propPriceOverride').value = selectedElement.priceOverride || '';
          document.getElementById('propPriceUnit').value = selectedElement.priceUnit || 'sqft';
          document.getElementById('propMargin').value = selectedElement.marginPercent !== null ? selectedElement.marginPercent : '';

          // Calculate and show item total
          const margin = getElementMargin(selectedElement);
          let quantity = 1;
          if (['countertop', 'backsplash', 'flooring', 'tile'].includes(selectedElement.type)) {
            quantity = selectedElement.width * selectedElement.height;
          }
          const cost = priceInfo.price * quantity;
          const retail = cost * (1 + margin / 100);
          document.getElementById('propItemTotal').textContent = '$' + retail.toFixed(2);
        } else if (pricingSection) {
          pricingSection.style.display = 'none';
        }
      } else {
        empty.style.display = 'block';
        content.style.display = 'none';
      }
    }

    function updateSelectedElement() {
      if (!selectedElement || selectedElement.locked) return;

      // Parse dimension input (accepts feet-inches like 3'-6" or decimal 2.5)
      const widthInput = document.getElementById('propWidth').value;
      const heightInput = document.getElementById('propHeight').value;

      selectedElement.width = roundToSixteenth(parseDimension(widthInput)) || 1;
      selectedElement.height = roundToSixteenth(parseDimension(heightInput)) || 1;
      selectedElement.color = document.getElementById('propColor').value;

      // Update display with formatted dimensions
      updateProperties();
      draw();
    }

    // Apply a standard size from dropdown
    function applyStandardSize() {
      if (!selectedElement || selectedElement.locked) return;

      const select = document.getElementById('propStandardSize');
      const value = select.value;
      if (!value) return;

      const [width, height] = value.split('x').map(parseFloat);
      if (width && height) {
        selectedElement.width = width;
        selectedElement.height = height;
        updateProperties();
        draw();
        showSnapFeedback(`Applied standard size: ${formatDimension(width)}  ${formatDimension(height)}`);
      }
    }

    // Get standard sizes for element type
    function getStandardSizesForType(type) {
      const sizes = [];

      switch (type) {
        case 'door':
          sizes.push({ label: '2\'-8" (32")', width: 2.667, height: 0.5 });
          sizes.push({ label: '3\'-0" (36")', width: 3, height: 0.5 });
          sizes.push({ label: '2\'-6" (30")', width: 2.5, height: 0.5 });
          break;
        case 'double-door':
          sizes.push({ label: '5\'-0" (60")', width: 5, height: 0.5 });
          sizes.push({ label: '6\'-0" (72")', width: 6, height: 0.5 });
          break;
        case 'sliding-door':
          sizes.push({ label: '6\'-0" (72")', width: 6, height: 0.5 });
          sizes.push({ label: '8\'-0" (96")', width: 8, height: 0.5 });
          sizes.push({ label: '9\'-0" (108")', width: 9, height: 0.5 });
          break;
        case 'entry-archway':
          sizes.push({ label: '3\'-0" (36")', width: 3, height: 0.5 });
          sizes.push({ label: '4\'-0" (48")', width: 4, height: 0.5 });
          sizes.push({ label: '5\'-0" (60")', width: 5, height: 0.5 });
          break;
        case 'garage-door':
          sizes.push({ label: '8\' Single', width: 8, height: 0.5 });
          sizes.push({ label: '9\' Single', width: 9, height: 0.5 });
          sizes.push({ label: '16\' Double', width: 16, height: 0.5 });
          sizes.push({ label: '18\' Double', width: 18, height: 0.5 });
          break;
        case 'window':
          sizes.push({ label: '2\'-0"  3\'-0"', width: 2, height: 0.5 });
          sizes.push({ label: '3\'-0"  4\'-0"', width: 3, height: 0.5 });
          sizes.push({ label: '4\'-0"  5\'-0"', width: 4, height: 0.5 });
          sizes.push({ label: '6\'-0" Picture', width: 6, height: 0.5 });
          break;
        case 'base-cabinet':
          sizes.push({ label: '12" Base', width: 1, height: 2 });
          sizes.push({ label: '15" Base', width: 1.25, height: 2 });
          sizes.push({ label: '18" Base', width: 1.5, height: 2 });
          sizes.push({ label: '24" Base', width: 2, height: 2 });
          sizes.push({ label: '30" Base', width: 2.5, height: 2 });
          sizes.push({ label: '36" Base', width: 3, height: 2 });
          break;
        case 'wall-cabinet':
          sizes.push({ label: '12" Wall', width: 1, height: 1 });
          sizes.push({ label: '18" Wall', width: 1.5, height: 1 });
          sizes.push({ label: '24" Wall', width: 2, height: 1 });
          sizes.push({ label: '30" Wall', width: 2.5, height: 1 });
          sizes.push({ label: '36" Wall', width: 3, height: 1 });
          break;
        case 'tall-cabinet':
          sizes.push({ label: '18" Pantry', width: 1.5, height: 2 });
          sizes.push({ label: '24" Pantry', width: 2, height: 2 });
          sizes.push({ label: '36" Pantry', width: 3, height: 2 });
          break;
        case 'island':
          sizes.push({ label: '4\'  2\' Small', width: 4, height: 2 });
          sizes.push({ label: '5\'  3\' Medium', width: 5, height: 3 });
          sizes.push({ label: '6\'  3\' Large', width: 6, height: 3 });
          sizes.push({ label: '8\'  4\' XL', width: 8, height: 4 });
          break;
        case 'countertop':
          sizes.push({ label: '25" Depth Std', width: 3, height: 2.083 });
          sizes.push({ label: '30" Depth Deep', width: 3, height: 2.5 });
          break;
        case 'sink':
          sizes.push({ label: '33" Single', width: 2.75, height: 1.83 });
          sizes.push({ label: '36" Double', width: 3, height: 1.83 });
          sizes.push({ label: '30" Farmhouse', width: 2.5, height: 1.75 });
          break;
        case 'stove':
        case 'range':
          sizes.push({ label: '30" Range', width: 2.5, height: 2.25 });
          sizes.push({ label: '36" Pro Range', width: 3, height: 2.25 });
          sizes.push({ label: '48" Pro Range', width: 4, height: 2.5 });
          break;
        case 'refrigerator':
          sizes.push({ label: '30" Standard', width: 2.5, height: 2.5 });
          sizes.push({ label: '36" Wide', width: 3, height: 2.75 });
          sizes.push({ label: '42" Built-in', width: 3.5, height: 2 });
          break;
        case 'dishwasher':
          sizes.push({ label: '24" Standard', width: 2, height: 2 });
          sizes.push({ label: '18" Compact', width: 1.5, height: 2 });
          break;
      }

      return sizes;
    }

    // ===== MATERIALS =====
    function openMaterialPicker() {
      if (!selectedElement) return;

      document.getElementById('materialModal').classList.add('active');
      renderMaterialCategories();
      renderMaterials('granite');
    }

    function renderMaterialCategories() {
      const container = document.getElementById('materialCategories');
      container.innerHTML = Object.keys(MATERIALS).map(cat => `
        <button class="material-category-btn ${cat === 'granite' ? 'active' : ''}"
                onclick="renderMaterials('${cat}', this)">
          ${cat.charAt(0).toUpperCase() + cat.slice(1)}
        </button>
      `).join('') + `
        <button class="material-category-btn" onclick="renderMaterials('custom', this)">
          My Uploads
        </button>
      `;
    }

    function renderMaterials(category, btn) {
      document.querySelectorAll('.material-category-btn').forEach(b => b.classList.remove('active'));
      if (btn) btn.classList.add('active');

      const container = document.getElementById('materialsGrid');

      if (category === 'custom') {
        container.innerHTML = `
          <div class="upload-material-btn" onclick="document.getElementById('materialUpload').click()">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
              <polyline points="17 8 12 3 7 8"/>
              <line x1="12" y1="3" x2="12" y2="15"/>
            </svg>
            <span>Upload</span>
          </div>
          ${customMaterials.map(m => `
            <div class="material-modal-item"
                 style="background: url(${m.url}) center/cover"
                 onclick="applyMaterial('${m.url}')">
              <div class="material-name">${m.name}</div>
            </div>
          `).join('')}
        `;
      } else {
        const materials = MATERIALS[category] || [];
        container.innerHTML = `
          <div class="upload-material-btn" onclick="document.getElementById('materialUpload').click()">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
              <polyline points="17 8 12 3 7 8"/>
              <line x1="12" y1="3" x2="12" y2="15"/>
            </svg>
            <span>Upload</span>
          </div>
          ${materials.map(m => {
            const priceTier = getMaterialPriceTier(m.price);
            const tierInfo = priceTier ? PRICE_TIERS[priceTier] : null;
            const bgUrl = m.url ? getProxiedUrl(m.url) : null;
            return `
            <div class="material-modal-item ${m.brand === 'Daltile' || m.brand?.includes('Daltile') ? 'daltile-material' : ''}"
                 style="background: ${bgUrl ? `url(${bgUrl})` : m.color} center/cover"
                 onclick="applyMaterial('${m.url || m.color}', '${m.color}')"
                 data-sku="${m.sku || ''}"
                 data-price="${m.price || ''}">
              ${m.price ? `<div class="material-price" style="background: ${tierInfo?.color || '#666'}">$${m.price.toFixed(2)}/sf</div>` : ''}
              ${m.brand ? `<div class="material-brand">${m.brand}</div>` : ''}
              <div class="material-name">${m.name}</div>
            </div>
          `}).join('')}
        `;
      }
    }

    function applyMaterial(urlOrColor, fallbackColor) {
      if (!selectedElement) return;

      if (urlOrColor.startsWith('http') || urlOrColor.startsWith('data:')) {
        selectedElement.texture = urlOrColor;
        const img = new Image();
        img.crossOrigin = 'anonymous';

        // Use proxied URL for MSI images to handle CORS
        const finalUrl = getProxiedUrl(urlOrColor);

        img.onload = () => {
          selectedElement.textureImg = img;
          draw();
          updateProperties();
        };
        img.onerror = () => {
          // Fall back to color
          console.log('Image failed to load:', urlOrColor);
          selectedElement.texture = null;
          selectedElement.color = fallbackColor || '#888';
          draw();
        };
        img.src = finalUrl;
      } else {
        selectedElement.texture = null;
        selectedElement.textureImg = null;
        selectedElement.color = urlOrColor;
        draw();
        updateProperties();
      }

      closeModal('materialModal');
    }

    // Quick upload texture directly from properties panel
    function quickUploadTexture() {
      if (!selectedElement) {
        alert('Please select an element first');
        return;
      }

      const input = document.createElement('input');
      input.type = 'file';
      input.accept = 'image/*';
      input.onchange = (e) => {
        const file = e.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = (event) => {
          const url = event.target.result;

          // Save to custom materials
          customMaterials.push({
            id: Date.now(),
            name: file.name.split('.')[0],
            url: url
          });

          // Apply to selected element
          selectedElement.texture = url;
          selectedElement.materialName = file.name.split('.')[0];

          const img = new Image();
          img.onload = () => {
            selectedElement.textureImg = img;
            draw();
            updateProperties();
          };
          img.src = url;
        };
        reader.readAsDataURL(file);
      };
      input.click();
    }

    // Clear texture from selected element
    function clearTexture() {
      if (!selectedElement) return;

      selectedElement.texture = null;
      selectedElement.textureImg = null;
      selectedElement.materialName = null;
      selectedElement.materialId = null;
      draw();
      updateProperties();
    }

    function handleMaterialUpload(e) {
      const file = e.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = (event) => {
        const url = event.target.result;
        const name = file.name.split('.')[0];

        customMaterials.push({ id: Date.now(), name, url });

        if (selectedElement) {
          applyMaterial(url);
        }
      };
      reader.readAsDataURL(file);
      e.target.value = '';
    }

    function uploadElementTexture(type) {
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = 'image/*';
      input.onchange = (e) => {
        const file = e.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = (event) => {
          elementTextures[type] = event.target.result;
          renderSidebar();
        };
        reader.readAsDataURL(file);
      };
      input.click();
    }

    // ===== PRICING FUNCTIONS =====

    // Get effective price for an element (priority: override -> material -> custom -> default)
    function getElementPrice(element) {
      // 1) Manual override takes highest priority
      if (element.priceOverride !== null && element.priceOverride !== undefined) {
        return { price: element.priceOverride, source: 'override' };
      }

      // 2) Check for material-specific pricing
      if (element.materialId) {
        for (const category in MATERIALS) {
          const mat = MATERIALS[category].find(m => m.id === element.materialId);
          if (mat && mat.price) {
            return { price: mat.price, source: 'material' };
          }
        }
      }

      // 3) Check custom prices from Excel import
      if (element.materialId && PRICING_STATE.customPrices[element.materialId]) {
        return { price: PRICING_STATE.customPrices[element.materialId], source: 'pricelist' };
      }

      // 4) Fall back to default type pricing
      return { price: CONFIG.PRICING[element.type] || 0, source: 'default' };
    }

    // Get element category for margin lookup
    function getElementCategory(type) {
      if (type.includes('cabinet') || type === 'island') return 'cabinet';
      if (['countertop', 'backsplash'].includes(type)) return 'countertop';
      if (['flooring', 'tile'].includes(type)) return 'flooring';
      if (['stove', 'refrigerator', 'dishwasher', 'microwave', 'oven', 'range-hood', 'sink'].includes(type)) return 'appliance';
      return 'other';
    }

    // Get effective margin for an element (priority: item -> category -> global)
    function getElementMargin(element) {
      // 1) Per-item margin override
      if (element.marginPercent !== null && element.marginPercent !== undefined) {
        return element.marginPercent;
      }

      // 2) Category-specific margin
      const category = getElementCategory(element.type);
      if (PRICING_STATE.categoryMargins && PRICING_STATE.categoryMargins[category] !== undefined) {
        return PRICING_STATE.categoryMargins[category];
      }

      // 3) Global default margin
      return PRICING_STATE.globalMargin;
    }

    // Get material name from ID
    function getMaterialName(materialId) {
      if (!materialId) return null;
      for (const category in MATERIALS) {
        const mat = MATERIALS[category].find(m => m.id === materialId);
        if (mat) return mat.name;
      }
      return null;
    }

    // Update element price from properties panel
    function updateElementPrice() {
      if (!selectedElement) return;

      const overrideInput = document.getElementById('propPriceOverride');
      const unitSelect = document.getElementById('propPriceUnit');
      const marginInput = document.getElementById('propMargin');

      const override = overrideInput && overrideInput.value ? parseFloat(overrideInput.value) : null;
      const unit = unitSelect ? unitSelect.value : 'sqft';
      const margin = marginInput && marginInput.value ? parseFloat(marginInput.value) : null;

      selectedElement.priceOverride = override;
      selectedElement.priceUnit = unit;
      selectedElement.marginPercent = margin;

      calculateQuote();
      updatePricingDisplay();
    }

    // Update pricing display in properties panel
    function updatePricingDisplay() {
      if (!selectedElement) return;

      const priceInfo = getElementPrice(selectedElement);
      const margin = getElementMargin(selectedElement);

      document.getElementById('propBasePrice').textContent = '$' + priceInfo.price.toFixed(2);

      // Calculate item total
      let quantity = 1;
      if (['countertop', 'backsplash', 'flooring', 'tile'].includes(selectedElement.type)) {
        quantity = selectedElement.width * selectedElement.height;
      }

      const cost = priceInfo.price * quantity;
      const retail = cost * (1 + margin / 100);

      document.getElementById('propItemTotal').textContent = '$' + retail.toFixed(2);
    }

    // Check if action is allowed based on permissions
    function checkPermission(action) {
      if (!SHARE_STATE.isSharedView) return true;
      if (!SHARE_STATE.allowedActions) return true;
      return SHARE_STATE.allowedActions[action] !== false;
    }

    // Toggle between cost and retail view
    function setQuoteView(view) {
      PRICING_STATE.showCostView = (view === 'cost');
      document.getElementById('retailViewBtn').classList.toggle('active', view === 'retail');
      document.getElementById('costViewBtn').classList.toggle('active', view === 'cost');
      calculateQuote();
    }

    // ===== QUOTE (Enhanced with Margins) =====
    function calculateQuote() {
      const items = {};
      let totalCost = 0;
      let totalRetail = 0;

      elements.forEach(el => {
        const priceInfo = getElementPrice(el);
        const margin = getElementMargin(el);

        let baseCost = 0;
        let quantity = 1;
        let unit = el.priceUnit || 'unit';

        // Calculate based on element type
        if (['countertop', 'backsplash', 'flooring', 'tile'].includes(el.type)) {
          const sqft = el.width * el.height;
          baseCost = sqft * priceInfo.price;
          quantity = sqft;
          unit = 'sqft';
        } else {
          baseCost = priceInfo.price;
          quantity = 1;
          unit = 'unit';
        }

        const retailPrice = baseCost * (1 + margin / 100);

        // Store calculated prices on element for display
        el.costPrice = baseCost;
        el.retailPrice = retailPrice;

        // Group items by type and material
        const materialName = getMaterialName(el.materialId);
        const itemKey = el.materialId ? `${el.type}-${el.materialId}` : el.type;
        const itemLabel = materialName ? `${el.label} (${materialName})` : el.label;

        if (!items[itemKey]) {
          items[itemKey] = {
            count: 0,
            costTotal: 0,
            retailTotal: 0,
            label: itemLabel,
            sqft: 0,
            margin: margin,
            priceSource: priceInfo.source
          };
        }

        items[itemKey].count++;
        items[itemKey].costTotal += baseCost;
        items[itemKey].retailTotal += retailPrice;

        if (unit === 'sqft') {
          items[itemKey].sqft += quantity;
        }

        totalCost += baseCost;
        totalRetail += retailPrice;
      });

      renderQuoteItems(items, totalCost, totalRetail);
    }

    function renderQuoteItems(items, totalCost, totalRetail) {
      const quoteItems = document.getElementById('quoteItems');
      const showCost = PRICING_STATE.showCostView;
      const canViewPrices = checkPermission('canViewPrices');
      const canViewCosts = checkPermission('canViewCosts');

      if (Object.keys(items).length === 0) {
        quoteItems.innerHTML = `
          <div class="quote-item">
            <span class="quote-item-name">No items yet</span>
            <span class="quote-item-value">$0</span>
          </div>
        `;
      } else {
        quoteItems.innerHTML = Object.entries(items).map(([key, data]) => {
          const displayPrice = showCost && canViewCosts ? data.costTotal : data.retailTotal;
          const sqftInfo = data.sqft > 0 ? ` - ${data.sqft.toFixed(1)} sqft` : '';
          const marginBadge = canViewCosts ? `<span class="margin-badge">${data.margin}%</span>` : '';

          if (!canViewPrices) {
            return `
              <div class="quote-item">
                <span class="quote-item-name">${data.label} (${data.count})${sqftInfo}</span>
              </div>
            `;
          }

          return `
            <div class="quote-item">
              <span class="quote-item-name">
                ${data.label} (${data.count})${sqftInfo}
                ${marginBadge}
              </span>
              <span class="quote-item-value">
                $${displayPrice.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2})}
              </span>
            </div>
          `;
        }).join('');
      }

      // Update totals
      const displayTotal = showCost && canViewCosts ? totalCost : totalRetail;
      const quoteTotalEl = document.getElementById('quoteTotal');
      if (quoteTotalEl) {
        quoteTotalEl.textContent = canViewPrices
          ? '$' + displayTotal.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2})
          : '---';
      }

      // Show/hide cost breakdown
      const costRow = document.getElementById('quoteCostRow');
      const marginRow = document.getElementById('quoteMarginRow');

      if (costRow && marginRow) {
        if (canViewCosts) {
          costRow.style.display = 'flex';
          marginRow.style.display = 'flex';
          document.getElementById('quoteCost').textContent = '$' + totalCost.toLocaleString(undefined, {minimumFractionDigits: 2});
          document.getElementById('quoteMargin').textContent = '$' + (totalRetail - totalCost).toLocaleString(undefined, {minimumFractionDigits: 2});
        } else {
          costRow.style.display = 'none';
          marginRow.style.display = 'none';
        }
      }
    }

    function generateQuote() {
      const projectName = document.getElementById('projectName').value;
      const roomType = document.getElementById('roomType').value;

      let text = `QUOTE: ${projectName}\nRoom: ${roomType} (${roomWidth}'  ${roomDepth}')\n${'='.repeat(30)}\n\n`;
      elements.forEach(el => {
        text += `${el.label}: ${el.width}'  ${el.height}'\n`;
      });
      text += `\n${'='.repeat(30)}\nTotal: ${document.getElementById('quoteTotal').textContent}`;

      alert(text);
    }

    // ===== MODALS =====
    function openShareModal() {
      document.getElementById('shareModal').classList.add('active');
      // Load active shares if we have a design ID
      if (SHARE_STATE.designId) {
        loadActiveShares();
      }
    }

    function closeModal(id) {
      const modal = document.getElementById(id);
      // Don't allow closing if it's a required modal (for auth)
      if (modal.getAttribute('data-required') === 'true') {
        return;
      }
      modal.classList.remove('active');
    }

    function copyShareLink() {
      const input = document.getElementById('shareLink');
      if (input.value) {
        navigator.clipboard.writeText(input.value).then(() => {
          const btn = document.getElementById('copyShareBtn');
          const originalText = btn.textContent;
          btn.textContent = 'Copied!';
          setTimeout(() => btn.textContent = originalText, 2000);
        }).catch(() => {
          input.select();
          document.execCommand('copy');
          alert('Link copied!');
        });
      }
    }

    function setSharePermission(perm, btn) {
      document.querySelectorAll('#shareModal .permission-btn').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
    }

    // ===== PRICE LIST MODAL FUNCTIONS =====
    let pendingPriceData = null;

    function openPriceListModal() {
      document.getElementById('priceListModal').classList.add('active');
      showPriceTab('upload');
      renderCurrentPrices();
    }

    function showPriceTab(tab) {
      document.querySelectorAll('.price-tab').forEach(t => t.style.display = 'none');
      document.querySelectorAll('.price-list-tabs .tab-btn').forEach(b => b.classList.remove('active'));

      document.getElementById('priceTab' + tab.charAt(0).toUpperCase() + tab.slice(1)).style.display = 'block';
      event.target.classList.add('active');
    }

    // Handle price list file upload
    async function handlePriceListUpload(event) {
      const file = event.target.files[0];
      if (!file) return;

      const extension = file.name.split('.').pop().toLowerCase();

      try {
        let data;
        if (extension === 'csv') {
          data = await parseCSVFile(file);
        } else if (['xlsx', 'xls'].includes(extension)) {
          data = await parseExcelFile(file);
        } else {
          throw new Error('Unsupported file format. Please use .xlsx, .xls, or .csv');
        }

        showColumnMapping(data);
      } catch (error) {
        alert('Error parsing file: ' + error.message);
        console.error(error);
      }
    }

    // Parse Excel file using SheetJS
    async function parseExcelFile(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = (e) => {
          try {
            if (typeof XLSX === 'undefined') {
              throw new Error('Excel parser not loaded. Please refresh the page.');
            }
            const data = new Uint8Array(e.target.result);
            const workbook = XLSX.read(data, { type: 'array' });
            const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
            const jsonData = XLSX.utils.sheet_to_json(firstSheet, { header: 1 });

            resolve({
              headers: jsonData[0] || [],
              rows: jsonData.slice(1).filter(row => row.some(cell => cell !== null && cell !== '')),
              raw: jsonData
            });
          } catch (err) {
            reject(err);
          }
        };
        reader.onerror = () => reject(new Error('Failed to read file'));
        reader.readAsArrayBuffer(file);
      });
    }

    // Parse CSV file
    async function parseCSVFile(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = (e) => {
          try {
            const text = e.target.result;
            const lines = text.split(/\r?\n/).filter(line => line.trim());
            const rows = lines.map(line => {
              const matches = line.match(/("([^"]*)"|[^,]+)/g) || [];
              return matches.map(val => val.replace(/^"|"$/g, '').trim());
            });

            resolve({
              headers: rows[0] || [],
              rows: rows.slice(1),
              raw: rows
            });
          } catch (err) {
            reject(err);
          }
        };
        reader.onerror = () => reject(new Error('Failed to read file'));
        reader.readAsText(file);
      });
    }

    function showColumnMapping(data) {
      pendingPriceData = data;

      document.getElementById('priceListDropzone').style.display = 'none';
      document.getElementById('columnMapping').style.display = 'block';

      const headers = data.headers;
      const optionsHtml = '<option value="">-- Select --</option>' +
        headers.map((h, i) => `<option value="${i}">${h}</option>`).join('');

      document.getElementById('mapMaterialId').innerHTML = optionsHtml;
      document.getElementById('mapMaterialName').innerHTML = optionsHtml;
      document.getElementById('mapPrice').innerHTML = optionsHtml;
      document.getElementById('mapUnit').innerHTML = '<option value="">None</option>' +
        headers.map((h, i) => `<option value="${i}">${h}</option>`).join('');

      // Auto-detect columns by name
      headers.forEach((h, i) => {
        const lower = String(h).toLowerCase();
        if (lower.includes('sku') || lower.includes('id') || lower.includes('code') || lower.includes('item')) {
          document.getElementById('mapMaterialId').value = i;
        }
        if (lower.includes('name') || lower.includes('material') || lower.includes('product') || lower.includes('description')) {
          document.getElementById('mapMaterialName').value = i;
        }
        if (lower.includes('price') || lower.includes('cost') || lower.includes('rate') || lower.includes('amount')) {
          document.getElementById('mapPrice').value = i;
        }
        if (lower.includes('unit') || lower.includes('uom')) {
          document.getElementById('mapUnit').value = i;
        }
      });

      updateMappingPreview();
    }

    function updateMappingPreview() {
      if (!pendingPriceData) return;

      const idCol = parseInt(document.getElementById('mapMaterialId').value);
      const nameCol = parseInt(document.getElementById('mapMaterialName').value);
      const priceCol = parseInt(document.getElementById('mapPrice').value);

      const preview = document.getElementById('mappingPreview');
      const sampleRows = pendingPriceData.rows.slice(0, 5);

      preview.innerHTML = `
        <table class="preview-table">
          <thead>
            <tr>
              <th>SKU/ID</th>
              <th>Name</th>
              <th>Price</th>
            </tr>
          </thead>
          <tbody>
            ${sampleRows.map(row => `
              <tr>
                <td>${isNaN(idCol) ? '-' : (row[idCol] || '-')}</td>
                <td>${isNaN(nameCol) ? '-' : (row[nameCol] || '-')}</td>
                <td>${isNaN(priceCol) ? '-' : formatPriceValue(row[priceCol])}</td>
              </tr>
            `).join('')}
          </tbody>
        </table>
        <p class="preview-count" style="margin-top:8px;font-size:12px;color:var(--text-muted);">${pendingPriceData.rows.length} items found</p>
      `;
    }

    function formatPriceValue(value) {
      if (!value) return '-';
      const num = parseFloat(String(value).replace(/[$,]/g, ''));
      return isNaN(num) ? '-' : '$' + num.toFixed(2);
    }

    function applyPriceList() {
      if (!pendingPriceData) return;

      const idCol = parseInt(document.getElementById('mapMaterialId').value);
      const nameCol = parseInt(document.getElementById('mapMaterialName').value);
      const priceCol = parseInt(document.getElementById('mapPrice').value);

      if (isNaN(priceCol)) {
        alert('Please select the Price column');
        return;
      }

      let matched = 0;
      let updated = 0;

      pendingPriceData.rows.forEach(row => {
        const id = !isNaN(idCol) ? String(row[idCol] || '').trim() : null;
        const name = !isNaN(nameCol) ? String(row[nameCol] || '').trim() : null;
        const price = parseFloat(String(row[priceCol] || '').replace(/[$,]/g, ''));

        if (isNaN(price) || price <= 0) return;

        // Store by ID in custom prices
        if (id) {
          PRICING_STATE.customPrices[id] = price;
        }

        // Update MATERIALS object for SKU/name matches
        for (const category in MATERIALS) {
          MATERIALS[category].forEach(mat => {
            if ((mat.sku && mat.sku === id) ||
                (mat.id && mat.id === id) ||
                (mat.name && name && mat.name.toLowerCase() === name.toLowerCase())) {
              mat.price = price;
              matched++;
            }
          });
        }
        updated++;
      });

      PRICING_STATE.activePriceList = 'Custom Import (' + new Date().toLocaleDateString() + ')';

      alert(`Price list applied!\n${updated} prices imported\n${matched} materials updated`);

      closeModal('priceListModal');
      calculateQuote();
      resetPriceUpload();
    }

    function cancelPriceUpload() {
      resetPriceUpload();
    }

    function resetPriceUpload() {
      pendingPriceData = null;
      document.getElementById('priceListDropzone').style.display = 'block';
      document.getElementById('columnMapping').style.display = 'none';
      document.getElementById('priceListFile').value = '';
    }

    function renderCurrentPrices() {
      const list = document.getElementById('currentPricesList');
      if (!list) return;

      let html = '';
      for (const category in MATERIALS) {
        const materials = MATERIALS[category].filter(m => m.price);
        if (materials.length === 0) continue;

        html += `<div class="price-category-header">${category.charAt(0).toUpperCase() + category.slice(1)}</div>`;
        materials.forEach(m => {
          html += `
            <div class="current-price-item">
              <span class="price-item-name">${m.name}</span>
              <span class="price-item-sku">${m.sku || '-'}</span>
              <span class="price-item-value">$${m.price.toFixed(2)}</span>
            </div>
          `;
        });
      }

      list.innerHTML = html || '<p class="empty-state">No priced materials</p>';
    }

    function filterCurrentPrices() {
      const query = document.getElementById('priceSearchInput').value.toLowerCase();
      const items = document.querySelectorAll('.current-price-item');
      items.forEach(item => {
        const name = item.querySelector('.price-item-name').textContent.toLowerCase();
        item.style.display = name.includes(query) ? 'flex' : 'none';
      });
    }

    // ===== MARGIN MODAL FUNCTIONS =====
    function openMarginModal() {
      document.getElementById('globalMarginInput').value = PRICING_STATE.globalMargin;

      // Populate category margins
      document.querySelectorAll('.category-margin-row input').forEach(input => {
        const category = input.dataset.category;
        const value = PRICING_STATE.categoryMargins[category];
        input.value = value !== undefined ? value : PRICING_STATE.globalMargin;
      });

      document.getElementById('marginModal').classList.add('active');
    }

    function applyMargins() {
      PRICING_STATE.globalMargin = parseInt(document.getElementById('globalMarginInput').value) || 30;

      document.querySelectorAll('.category-margin-row input').forEach(input => {
        const category = input.dataset.category;
        const value = parseInt(input.value);
        if (!isNaN(value)) {
          PRICING_STATE.categoryMargins[category] = value;
        }
      });

      closeModal('marginModal');
      calculateQuote();
    }

    // ===== SHARING FUNCTIONS (Supabase) =====

    // ===== PRELOADER FUNCTIONS =====
    // Preloader Steps for Blueprint CAD Animation
    // Minimal preloader
    let preloaderMinTime = 2000;
    let preloaderStartTime = 0;
    let preloaderReady = false;
    let preloaderProgress = 0;
    let preloaderInterval = null;

    function showPreloader(message, companyName) {
      const preloader = document.getElementById('cloudPreloader');
      const companyEl = document.getElementById('preloaderCompanyMain');
      const progressBar = document.getElementById('preloaderProgressBar');

      if (preloader) {
        preloader.classList.remove('loaded');
        preloaderStartTime = Date.now();
        preloaderReady = false;
        preloaderProgress = 0;

        // Set company name
        if (companyEl) {
          companyEl.textContent = companyName || 'Surprise Granite';
        }

        // Reset progress
        if (progressBar) progressBar.style.width = '0%';

        // Clear any existing interval
        if (preloaderInterval) clearInterval(preloaderInterval);

        // Animate progress bar
        preloaderInterval = setInterval(() => {
          preloaderProgress += 2;
          if (progressBar) progressBar.style.width = Math.min(preloaderProgress, 90) + '%';

          if (preloaderProgress >= 90 && preloaderReady) {
            if (progressBar) progressBar.style.width = '100%';
            clearInterval(preloaderInterval);
            setTimeout(hidePreloaderNow, 300);
          }
        }, 40);
      }
    }

    function hidePreloader() {
      preloaderReady = true;
      const elapsed = Date.now() - preloaderStartTime;

      if (elapsed >= preloaderMinTime && preloaderProgress >= 90) {
        const progressBar = document.getElementById('preloaderProgressBar');
        if (progressBar) progressBar.style.width = '100%';
        setTimeout(hidePreloaderNow, 300);
      }
    }

    function hidePreloaderNow() {
      const preloader = document.getElementById('cloudPreloader');
      if (preloaderInterval) {
        clearInterval(preloaderInterval);
        preloaderInterval = null;
      }
      if (preloader) {
        preloader.classList.add('loaded');
      }
    }

    // Get or create Supabase client
    function getSupabaseClient() {
      if (window._roomDesignerSupabase) return window._roomDesignerSupabase;

      const SUPABASE_URL = 'https://ypeypgwsycxcagncgdur.supabase.co';
      const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InlwZXlwZ3dzeWN4Y2FnbmNnZHVyIiwicm9sZSI6ImFub24iLCJpYXQiOjE3Njc3NTQ4MjMsImV4cCI6MjA4MzMzMDgyM30.R13pNv2FDtGhfeu7gUcttYNrQAbNYitqR4FIq3O2-ME';

      if (window.supabase && window.supabase.createClient) {
        window._roomDesignerSupabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
        return window._roomDesignerSupabase;
      }
      return null;
    }

    // Generate unique share token
    function generateToken(length = 12) {
      const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZabcdefghjkmnpqrstuvwxyz23456789';
      let token = '';
      for (let i = 0; i < length; i++) {
        token += chars.charAt(Math.floor(Math.random() * chars.length));
      }
      return token;
    }

    // ===== AUTHENTICATION FUNCTIONS =====

    // Show login prompt modal
    function showLoginPrompt(message) {
      document.getElementById('loginPromptMessage').textContent = message || 'Sign in to continue.';
      document.getElementById('loginFormContainer').style.display = 'block';
      document.getElementById('loginSuccessContainer').style.display = 'none';
      document.getElementById('loginError').style.display = 'none';
      document.getElementById('loginEmail').value = '';
      document.getElementById('loginPassword').value = '';
      document.getElementById('loginModal').classList.add('active');
      document.getElementById('loginModal').removeAttribute('data-required');
    }

    // Show required login prompt (non-dismissible, for initial access)
    function showLoginPromptRequired() {
      document.getElementById('loginPromptMessage').innerHTML =
        'Sign in to access the Room Designer.<br><span style="font-size: 12px; opacity: 0.7;">Create professional kitchen & bath layouts with instant quotes.</span>';
      document.getElementById('loginFormContainer').style.display = 'block';
      document.getElementById('loginSuccessContainer').style.display = 'none';
      document.getElementById('loginError').style.display = 'none';
      document.getElementById('loginEmail').value = '';
      document.getElementById('loginPassword').value = '';
      const modal = document.getElementById('loginModal');
      modal.classList.add('active');
      modal.setAttribute('data-required', 'true');
    }

    // Hide the preloader
    function hidePreloader() {
      const preloader = document.getElementById('cloudPreloader');
      if (preloader) {
        preloader.classList.add('loaded');
        setTimeout(() => preloader.style.display = 'none', 600);
      }
    }

    // Handle Google OAuth login
    async function handleGoogleLogin() {
      try {
        const supabase = getSupabaseClient();
        if (!supabase) {
          throw new Error('Authentication not available');
        }

        const { data, error } = await supabase.auth.signInWithOAuth({
          provider: 'google',
          options: {
            redirectTo: window.location.origin + '/tools/room-designer/'
          }
        });

        if (error) {
          document.getElementById('loginError').textContent = error.message;
          document.getElementById('loginError').style.display = 'block';
        }
      } catch (err) {
        console.error('Google login error:', err);
        document.getElementById('loginError').textContent = 'Failed to connect with Google. Please try again.';
        document.getElementById('loginError').style.display = 'block';
      }
    }

    // Handle login form submission
    async function handleLogin() {
      const email = document.getElementById('loginEmail').value.trim();
      const password = document.getElementById('loginPassword').value;
      const errorEl = document.getElementById('loginError');

      if (!email || !password) {
        errorEl.textContent = 'Please enter email and password.';
        errorEl.style.display = 'block';
        return;
      }

      try {
        errorEl.style.display = 'none';

        if (!window.SgAuth) {
          throw new Error('Auth system not loaded. Please refresh the page.');
        }

        const result = await window.SgAuth.signIn(email, password);

        // Show success
        document.getElementById('loginFormContainer').style.display = 'none';
        document.getElementById('loginSuccessContainer').style.display = 'block';
        document.getElementById('loginWelcome').textContent = `Welcome back, ${result.profile?.full_name || email}!`;

        // Update header UI
        updateAuthUI();

        // If this was a required login to access the tool, continue initialization
        if (pendingAuthInit) {
          pendingAuthInit = false;
          setTimeout(() => {
            closeModal('loginModal');
            initializeWorkspace();
          }, 1000);
        }

      } catch (err) {
        console.error('Login error:', err);
        errorEl.textContent = err.message || 'Login failed. Please try again.';
        errorEl.style.display = 'block';
      }
    }

    // Update header to show logged-in state
    function updateAuthUI() {
      const user = window.SgAuth?.getUser();
      const profile = window.SgAuth?.getProfile();

      const accountBtn = document.getElementById('accountBtn');
      if (accountBtn) {
        if (user) {
          const name = profile?.full_name?.split(' ')[0] || user.email.split('@')[0];
          accountBtn.innerHTML = `
            <span style="width:28px;height:28px;background:var(--gold);border-radius:50%;display:flex;align-items:center;justify-content:center;font-weight:600;color:var(--dark);font-size:12px;">${name.charAt(0).toUpperCase()}</span>
            <span>${name}</span>
          `;
          accountBtn.onclick = () => window.location.href = '/account/';
        } else {
          accountBtn.innerHTML = `
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:20px;height:20px;">
              <path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"/>
              <circle cx="12" cy="7" r="4"/>
            </svg>
            <span>Sign In</span>
          `;
          accountBtn.onclick = () => showLoginPrompt();
        }
      }
    }

    // Initialize auth state on load
    function initAuth() {
      if (window.SgAuth) {
        window.SgAuth.onAuthChange((event, data) => {
          console.log('Auth state changed:', event);
          updateAuthUI();
        });
      }
      // Initial update
      setTimeout(updateAuthUI, 500);
    }

    // Generate share link and save to Supabase
    async function generateShareLink() {
      console.log('=== generateShareLink START ===');

      // Check if user is logged in
      const user = window.SgAuth?.getUser();
      if (!user) {
        showLoginPrompt('Please log in to save and share your designs.');
        return;
      }

      // Get user profile for company name
      let companyName = 'Surprise Granite Marble & Quartz'; // default
      try {
        const profile = await window.SgAuth?.getProfile();
        if (profile && profile.company_name) {
          companyName = profile.company_name;
        } else if (profile && profile.full_name) {
          companyName = profile.full_name;
        }
      } catch (e) {
        console.log('Could not fetch profile:', e);
      }

      const permissionBtn = document.querySelector('#shareModal .permission-btn.active');
      const permission = permissionBtn ? permissionBtn.dataset.permission : 'quote_view';
      console.log('Permission selected:', permission);

      const projectName = document.getElementById('projectName').value || 'Untitled Design';
      const roomType = document.getElementById('roomType').value;

      console.log('Project:', projectName, 'Room:', roomType);
      console.log('Elements count:', elements.length);
      console.log('User:', user.email);
      console.log('Company:', companyName);

      // Calculate quote total
      let quoteTotal = 0;
      elements.forEach(el => {
        const priceInfo = getElementPrice(el);
        const margin = getElementMargin(el) || 30;
        let cost = priceInfo?.price || 0;
        if (['countertop', 'backsplash', 'flooring', 'tile'].includes(el.type)) {
          cost = (el.width || 1) * (el.height || 1) * cost;
        }
        quoteTotal += cost * (1 + margin / 100);
      });

      const designData = {
        user_id: user.id,
        name: projectName,
        room_type: roomType,
        room_width: roomWidth,
        room_depth: roomDepth,
        elements: elements.map(el => ({
          ...el,
          textureImg: null
        })),
        settings: {
          walls: walls,
          pricing_config: {
            globalMargin: PRICING_STATE.globalMargin,
            categoryMargins: PRICING_STATE.categoryMargins,
            customPrices: PRICING_STATE.customPrices
          },
          company_name: companyName
        },
        quote_total: quoteTotal,
        share_mode: permission === 'full_collab' ? 'edit' : 'view',
        is_public: false
      };

      try {
        const supabase = getSupabaseClient();
        console.log('Supabase client:', supabase ? 'available' : 'NOT AVAILABLE');

        if (!supabase) {
          alert('Database connection unavailable. Please try again.');
          return;
        }

        let designId = SHARE_STATE.designId;
        let designToken = SHARE_STATE.designToken;
        console.log('Current state - designId:', designId, 'designToken:', designToken);

        // Create or update design in database
        if (!designId) {
          designToken = generateToken(16);
          console.log('Creating new design with token:', designToken);

          const { data, error } = await supabase
            .from('room_designs')
            .insert({
              share_token: designToken,
              ...designData
            })
            .select()
            .single();

          console.log('Insert result:', { data, error });

          if (error) throw error;
          designId = data.id;
          SHARE_STATE.designId = designId;
          SHARE_STATE.designToken = designToken;
          console.log('Design created with ID:', designId);
        } else {
          // Update existing design
          const { error } = await supabase
            .from('room_designs')
            .update({
              ...designData,
              updated_at: new Date().toISOString()
            })
            .eq('id', designId);

          if (error) throw error;
        }

        // Create share record with specific permission
        const shareToken = generateToken(12);
        const { data: shareData, error: shareError } = await supabase
          .from('room_design_shares')
          .insert({
            design_id: designId,
            share_token: shareToken,
            permission_level: permission
          })
          .select()
          .single();

        if (shareError) throw shareError;

        // Display share URL
        const shareUrl = `${window.location.origin}${window.location.pathname}?share=${shareToken}`;
        document.getElementById('shareLink').value = shareUrl;
        document.getElementById('copyShareBtn').disabled = false;
        document.getElementById('shareStatusText').textContent = 'Design shared!';

        loadActiveShares();

      } catch (err) {
        console.error('Share error:', err);
        // Fallback to simple link
        const token = generateToken(12);
        const shareUrl = `${window.location.origin}${window.location.pathname}?p=${token}`;
        document.getElementById('shareLink').value = shareUrl;
        document.getElementById('copyShareBtn').disabled = false;
        document.getElementById('shareStatusText').textContent = 'Link generated (offline mode)';
      }
    }

    // Helper function to load design data into the canvas
    function loadDesignData(design, permission, shareData = null) {
      console.log('=== loadDesignData START ===');
      console.log('Design:', design);
      console.log('Permission:', permission);

      try {
        // Update preloader with company name
        let companyName = 'Surprise Granite Marble & Quartz';
        if (design.settings && design.settings.company_name) {
          companyName = design.settings.company_name;
        } else if (design.created_by) {
          companyName = design.created_by;
        } else if (design.company_name) {
          companyName = design.company_name;
        }
        const companyEl = document.getElementById('preloaderCompanyMain');
        if (companyEl) {
          companyEl.textContent = companyName;
        }

        // Set share state
        SHARE_STATE.isSharedView = true;
        SHARE_STATE.permission = permission;
        SHARE_STATE.allowedActions = PERMISSION_LEVELS[permission] || PERMISSION_LEVELS.presentation;
        SHARE_STATE.designId = design.id;
        SHARE_STATE.designToken = design.share_token;

        if (shareData) {
          SHARE_STATE.shareId = shareData.id;
          SHARE_STATE.comments = shareData.comments || [];
        }

        // Load design data into form fields
        document.getElementById('projectName').value = design.project_name || 'Shared Design';
        document.getElementById('roomType').value = design.room_type || 'kitchen';
        roomWidth = parseFloat(design.room_width) || 12;
        roomDepth = parseFloat(design.room_depth) || 10;
        document.getElementById('roomWidth').value = roomWidth;
        document.getElementById('roomDepth').value = roomDepth;

        // Load elements and walls
        elements = design.elements || [];
        walls = design.walls || [];

        console.log('Loaded elements:', elements.length);
        console.log('Loaded walls:', walls.length);

        // Ensure elements have required properties
        elements = elements.map(el => ({
          ...el,
          textureImg: null,
          status: el.status || 'pending'
        }));

        // Load pricing config
        if (design.pricing_config) {
          PRICING_STATE.globalMargin = design.pricing_config.globalMargin || 30;
          PRICING_STATE.categoryMargins = design.pricing_config.categoryMargins || {};
          PRICING_STATE.customPrices = design.pricing_config.customPrices || {};
        }

        // Reload textures for elements
        elements.forEach(el => {
          if (el.materialId) {
            loadElementTexture(el);
          }
        });

        selectedElement = null;
        updateProperties();
        calculateQuote();
        draw();

        // Show Review Room UI first
        showReviewRoom(design.project_name, permission);

        // Wait for textures to load, then initialize 3D view
        setTimeout(() => {
          console.log('Initializing 3D view with', elements.length, 'elements');
          // Switch to 3D view first
          setView('3d');
          // Force re-init 3D scene after a short delay
          setTimeout(() => {
            init3D();
            render3D();
            console.log('3D scene initialized');
            // Hide preloader after 3D is ready
            hidePreloader();
            console.log('=== loadDesignData COMPLETE ===');
            // Log view activity
            logActivity('view');
          }, 300);
        }, 800);

      } catch (err) {
        console.error('loadDesignData error:', err);
        alert('Error loading design: ' + err.message);
        hidePreloader();
      }
    }

    // Load shared design from token
    async function loadSharedDesign(shareToken) {
      console.log('=== loadSharedDesign START ===');
      console.log('Token:', shareToken);

      // Show cloud preloader with Remodely AI branding
      showPreloader('Initializing 3D workspace');

      try {
        const supabase = getSupabaseClient();
        console.log('Supabase client:', supabase ? 'available' : 'NOT AVAILABLE');

        if (!supabase) {
          console.warn('Supabase not available for loading shared design');
          hidePreloader();
          alert('Cannot load shared design - database connection unavailable');
          return;
        }

        // First try to get the share record by share_token
        console.log('Querying room_design_shares for token:', shareToken);
        let { data: shareData, error: shareError } = await supabase
          .from('room_design_shares')
          .select('*')
          .eq('share_token', shareToken)
          .single();

        console.log('Share query result:', { data: shareData, error: shareError });

        // If not found by share_token, try to find by design token directly
        if (shareError || !shareData) {
          console.log('Not found in shares, trying room_designs directly...');
          const { data: directDesign, error: directError } = await supabase
            .from('room_designs')
            .select('*')
            .eq('share_token', shareToken)
            .single();

          console.log('Direct design query result:', { data: directDesign, error: directError });

          if (directDesign) {
            // Found as a direct design link - load it directly
            loadDesignData(directDesign, 'full_collab');
            return;
          }

          console.error('Share error:', shareError);
          alert('Share link not found or expired. Please ask for a new link.');
          hidePreloader();
          return;
        }

        // Then get the associated design
        const { data: design, error: designError } = await supabase
          .from('room_designs')
          .select('*')
          .eq('id', shareData.design_id)
          .single();

        if (designError || !design) {
          console.error('Design error:', designError);
          alert('Design not found');
          hidePreloader();
          return;
        }

        // Update access count
        await supabase
          .from('room_design_shares')
          .update({
            access_count: (shareData.access_count || 0) + 1,
            last_accessed_at: new Date().toISOString()
          })
          .eq('id', shareData.id);

        const permission = shareData.permission_level;

        // Use the helper function to load the design
        loadDesignData(design, permission, shareData);

      } catch (err) {
        console.error('Load shared design error:', err);
        alert('Error loading shared design: ' + err.message);
        hidePreloader();
      }
    }

    // Show the Review Room overlay UI
    function showReviewRoom(projectName, permission) {
      const permInfo = PERMISSION_LEVELS[permission];

      // Create review room overlay
      const reviewRoom = document.createElement('div');
      reviewRoom.id = 'reviewRoom';
      reviewRoom.className = 'review-room';
      reviewRoom.innerHTML = `
        <div class="review-header">
          <div class="review-header-left">
            <h2 class="review-title">${projectName || 'Design Review'}</h2>
            <span class="review-permission-badge">${permInfo?.name || permission}</span>
          </div>
          <div class="review-header-right">
            <button class="btn btn-secondary" onclick="toggleReviewPanel()">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:16px;height:16px;">
                <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"/>
              </svg>
              Review Panel
            </button>
            <button class="btn btn-secondary" id="toggle3DBtn" onclick="toggle3DView()">
              2D View
            </button>
            ${permission === 'full_collab' ? `
            <button class="btn btn-secondary" onclick="exitReviewMode()" title="Exit to Editor">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:16px;height:16px;">
                <path d="M18 6L6 18M6 6l12 12"/>
              </svg>
            </button>
            ` : ''}
          </div>
        </div>

        <div class="review-panel" id="reviewPanel">
          <div class="review-panel-header">
            <h3>Design Elements</h3>
            <button class="review-panel-close" onclick="toggleReviewPanel()"></button>
          </div>

          <div class="review-summary">
            <div class="review-stat">
              <span class="stat-value" id="reviewTotal">$0</span>
              <span class="stat-label">Total Quote</span>
            </div>
            <div class="review-stat">
              <span class="stat-value" id="reviewItemCount">0</span>
              <span class="stat-label">Items</span>
            </div>
            <div class="review-stat">
              <span class="stat-value approved" id="reviewApproved">0</span>
              <span class="stat-label">Approved</span>
            </div>
          </div>

          <div class="review-elements" id="reviewElements">
            <!-- Populated by JS -->
          </div>

          <div class="review-comments-section">
            <h4>Comments</h4>
            <div class="review-comments" id="reviewComments">
              <!-- Populated by JS -->
            </div>
            <div class="review-comment-input">
              <input type="text" id="newCommentInput" placeholder="Add a comment..." onkeypress="if(event.key==='Enter')addReviewComment()">
              <button class="btn btn-primary btn-sm" onclick="addReviewComment()">Send</button>
            </div>
          </div>

          ${permission === 'full_collab' || permission === 'quote_view' ? `
          <div class="review-actions">
            <button class="btn btn-success" onclick="approveAllElements()">Approve All</button>
            <button class="btn btn-primary" onclick="submitReview()">Submit Review</button>
          </div>
          ` : ''}
        </div>
      `;

      document.body.appendChild(reviewRoom);

      // Apply permission-based UI adjustments
      applyPermissionRestrictions();

      // Populate review elements list
      console.log('Populating review with elements:', elements.length);
      updateReviewElements();
      updateReviewComments();
      updateReviewStats();

      // Auto-open the review panel for quote_view and full_collab
      if (permission === 'quote_view' || permission === 'full_collab') {
        const panel = document.getElementById('reviewPanel');
        if (panel) {
          panel.classList.add('open');
          console.log('Auto-opened review panel for permission:', permission);
        }
      }
    }

    // Toggle review panel visibility
    function toggleReviewPanel() {
      const panel = document.getElementById('reviewPanel');
      if (panel) {
        panel.classList.toggle('open');
      }
    }

    // Exit review mode and return to normal editor
    function exitReviewMode() {
      const reviewRoom = document.getElementById('reviewRoom');
      if (reviewRoom) {
        reviewRoom.remove();
      }

      // Reset share state
      SHARE_STATE.isSharedView = false;
      SHARE_STATE.permission = 'full_collab';
      SHARE_STATE.allowedActions = PERMISSION_LEVELS.full_collab;

      // Switch back to 2D view
      setView('2d');

      // Re-enable all UI elements
      document.querySelectorAll('[data-permission-hidden]').forEach(el => {
        el.style.display = '';
        el.removeAttribute('data-permission-hidden');
      });

      draw();
    }

    // Update review elements list
    function updateReviewElements() {
      console.log('updateReviewElements called');
      const container = document.getElementById('reviewElements');
      if (!container) {
        console.log('Review elements container not found');
        return;
      }

      const canApprove = SHARE_STATE.permission === 'full_collab' || SHARE_STATE.permission === 'quote_view';
      const canViewPrices = checkPermission('canViewPrices');
      console.log('canApprove:', canApprove, 'canViewPrices:', canViewPrices);

      if (elements.length === 0) {
        container.innerHTML = '<p class="empty-state">No elements in this design</p>';
        return;
      }

      container.innerHTML = elements.map((el, index) => {
        const priceInfo = getElementPrice(el);
        const margin = getElementMargin(el) || 30;
        let cost = priceInfo?.price || 0;
        if (['countertop', 'backsplash', 'flooring', 'tile'].includes(el.type)) {
          cost = (el.width || 1) * (el.height || 1) * cost;
        }
        const retail = cost * (1 + margin / 100);
        const status = el.status || 'pending';
        const statusIcon = status === 'approved' ? '' : status === 'rejected' ? '' : '';
        const statusClass = status;

        return `
          <div class="review-element ${statusClass}" data-index="${index}" onclick="selectReviewElement(${index})">
            <div class="review-element-header">
              <span class="review-element-status ${statusClass}">${statusIcon}</span>
              <span class="review-element-name">${el.label}</span>
              ${canViewPrices ? `<span class="review-element-price">$${(retail || 0).toFixed(2)}</span>` : ''}
            </div>
            <div class="review-element-details">
              <span>${formatDimension(el.width)}  ${formatDimension(el.height)}</span>
              ${el.material ? `<span class="review-element-material">${el.material}</span>` : ''}
            </div>
            ${canApprove ? `
            <div class="review-element-actions">
              <button class="btn-approve" onclick="event.stopPropagation(); setElementStatus(${index}, 'approved')" title="Approve"></button>
              <button class="btn-reject" onclick="event.stopPropagation(); setElementStatus(${index}, 'rejected')" title="Reject"></button>
              <button class="btn-comment" onclick="event.stopPropagation(); commentOnElement(${index})" title="Comment"></button>
            </div>
            ` : ''}
          </div>
        `;
      }).join('');
    }

    // Select an element from the review panel
    function selectReviewElement(index) {
      if (elements[index]) {
        selectedElement = elements[index];
        updateProperties();
        draw();

        // Highlight in 3D if available
        if (is3DMode) {
          // Could add 3D highlighting here
        }
      }
    }

    // Set element approval status
    async function setElementStatus(index, status) {
      if (elements[index]) {
        elements[index].status = status;
        updateReviewElements();
        updateReviewStats();
        draw();

        // Log activity
        const activityType = status === 'approved' ? 'approve' : 'reject';
        logActivity(activityType, index, elements[index].label);

        // Save status to database
        await saveReviewState();
      }
    }

    // Approve all elements
    async function approveAllElements() {
      elements.forEach(el => el.status = 'approved');
      updateReviewElements();
      updateReviewStats();
      draw();
      await saveReviewState();
    }

    // Comment on specific element
    function commentOnElement(index) {
      const comment = prompt(`Add comment for "${elements[index]?.label}":`);
      if (comment && comment.trim()) {
        const newComment = {
          elementIndex: index,
          elementLabel: elements[index]?.label,
          text: comment.trim(),
          timestamp: new Date().toISOString(),
          author: 'Reviewer'
        };
        SHARE_STATE.comments = SHARE_STATE.comments || [];
        SHARE_STATE.comments.push(newComment);
        updateReviewComments();
        saveReviewState();
      }
    }

    // Add general review comment
    async function addReviewComment() {
      const input = document.getElementById('newCommentInput');
      const text = input?.value?.trim();
      if (!text) return;

      const newComment = {
        text: text,
        timestamp: new Date().toISOString(),
        author: 'Reviewer'
      };

      SHARE_STATE.comments = SHARE_STATE.comments || [];
      SHARE_STATE.comments.push(newComment);
      input.value = '';
      updateReviewComments();

      // Log comment activity
      logActivity('comment', null, null, text);

      await saveReviewState();
    }

    // Update comments display
    function updateReviewComments() {
      const container = document.getElementById('reviewComments');
      if (!container) return;

      const comments = SHARE_STATE.comments || [];

      if (comments.length === 0) {
        container.innerHTML = '<p class="empty-state">No comments yet</p>';
        return;
      }

      container.innerHTML = comments.map(c => `
        <div class="review-comment">
          <div class="comment-header">
            <span class="comment-author">${c.author || 'Anonymous'}</span>
            ${c.elementLabel ? `<span class="comment-element">on ${c.elementLabel}</span>` : ''}
            <span class="comment-time">${new Date(c.timestamp).toLocaleString()}</span>
          </div>
          <div class="comment-text">${c.text}</div>
        </div>
      `).join('');

      container.scrollTop = container.scrollHeight;
    }

    // Update review stats
    function updateReviewStats() {
      console.log('updateReviewStats called, elements:', elements.length);
      console.log('Can view prices:', checkPermission('canViewPrices'));

      const totalEl = document.getElementById('reviewTotal');
      const countEl = document.getElementById('reviewItemCount');
      const approvedEl = document.getElementById('reviewApproved');

      if (totalEl && checkPermission('canViewPrices')) {
        let total = 0;
        elements.forEach(el => {
          if (el.retailPrice) {
            total += el.retailPrice;
          } else {
            const priceInfo = getElementPrice(el);
            const margin = getElementMargin(el);
            let cost = priceInfo?.price || 0;
            if (['countertop', 'backsplash', 'flooring', 'tile'].includes(el.type)) {
              cost = (el.width || 1) * (el.height || 1) * cost;
            }
            total += cost * (1 + (margin || 30) / 100);
          }
        });
        console.log('Calculated total:', total);
        totalEl.textContent = '$' + total.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2});
      } else if (totalEl) {
        totalEl.textContent = 'Hidden';
      }

      if (countEl) countEl.textContent = elements.length;

      if (approvedEl) {
        const approved = elements.filter(el => el.status === 'approved').length;
        approvedEl.textContent = approved;
      }
    }

    // Save review state to database
    async function saveReviewState() {
      if (!SHARE_STATE.shareId) return;

      try {
        const supabase = getSupabaseClient();
        if (!supabase) return;

        // Save element statuses to the design
        await supabase
          .from('room_designs')
          .update({
            elements: elements.map(el => ({
              ...el,
              textureImg: null
            }))
          })
          .eq('id', SHARE_STATE.designId);

        // Save comments to the share record
        await supabase
          .from('room_design_shares')
          .update({
            comments: SHARE_STATE.comments
          })
          .eq('id', SHARE_STATE.shareId);

      } catch (err) {
        console.error('Error saving review state:', err);
      }
    }

    // Submit final review
    async function submitReview() {
      const approved = elements.filter(el => el.status === 'approved').length;
      const rejected = elements.filter(el => el.status === 'rejected').length;
      const pending = elements.filter(el => el.status === 'pending').length;

      const summary = `Review Summary:\n\n Approved: ${approved}\n Rejected: ${rejected}\n Pending: ${pending}\n\nSubmit this review?`;

      if (confirm(summary)) {
        await saveReviewState();
        alert('Review submitted! The design owner will be notified.');
      }
    }

    // Reload texture for an element
    function loadElementTexture(el) {
      if (!el.materialId) return;

      for (const category in MATERIALS) {
        const mat = MATERIALS[category].find(m => m.id === el.materialId);
        if (mat && mat.url) {
          const img = new Image();
          img.crossOrigin = 'anonymous';
          img.onload = () => {
            el.textureImg = img;
            draw();
          };
          img.src = mat.url;
          break;
        }
      }
    }

    // Apply UI restrictions based on permission level
    function applyPermissionRestrictions() {
      const perms = SHARE_STATE.allowedActions;
      if (!perms) return;

      // Hide/disable editing controls
      if (!perms.canEdit) {
        document.body.classList.add('review-readonly');

        document.querySelectorAll('.element-btn, .toolbar-btn').forEach(btn => {
          btn.disabled = true;
          btn.style.opacity = '0.5';
          btn.style.pointerEvents = 'none';
        });

        const propsContent = document.getElementById('propertiesContent');
        if (propsContent) {
          propsContent.querySelectorAll('input, select, button').forEach(el => {
            el.disabled = true;
          });
        }
      }

      // Hide pricing elements in main panel (shown in review panel instead)
      if (!perms.canViewPrices) {
        const quotePanel = document.getElementById('quotePanel');
        if (quotePanel) quotePanel.style.display = 'none';
      }

      // Hide cost view toggle
      if (!perms.canViewCosts) {
        const costBtn = document.getElementById('costViewBtn');
        if (costBtn) costBtn.style.display = 'none';
      }

      // Show presentation mode for presentation permission
      if (SHARE_STATE.permission === 'presentation') {
        document.body.classList.add('presentation-mode');
      }

      // Material view hides most UI
      if (SHARE_STATE.permission === 'material_view') {
        document.body.classList.add('material-view-mode');
      }

      // Auto-open review panel after a delay
      setTimeout(() => {
        const panel = document.getElementById('reviewPanel');
        if (panel) panel.classList.add('open');
      }, 1000);
    }

    function showPermissionNotice(permission) {
      const permInfo = PERMISSION_LEVELS[permission];
      if (!permInfo) return;

      const notice = document.createElement('div');
      notice.className = 'permission-notice';
      notice.innerHTML = `
        <div class="notice-content">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:18px;height:18px;">
            <circle cx="12" cy="12" r="10"/>
            <path d="M12 16v-4"/>
            <path d="M12 8h.01"/>
          </svg>
          <span>Viewing as: <strong>${permInfo.name}</strong></span>
          <button onclick="this.parentElement.parentElement.remove()" style="background:none;border:none;color:inherit;cursor:pointer;font-size:16px;"></button>
        </div>
      `;
      document.body.appendChild(notice);

      setTimeout(() => notice.remove(), 8000);
    }

    // Load active shares for current design
    async function loadActiveShares() {
      if (!SHARE_STATE.designId) return;

      try {
        const supabase = getSupabaseClient();
        if (!supabase) return;

        const { data, error } = await supabase
          .from('room_design_shares')
          .select('*')
          .eq('design_id', SHARE_STATE.designId)
          .order('created_at', { ascending: false });

        if (error) throw error;

        renderActiveShares(data || []);

        // Also load recent activity
        loadRecentActivity();
      } catch (err) {
        console.error('Load shares error:', err);
      }
    }

    function renderActiveShares(shares) {
      const container = document.getElementById('activeShares');
      const list = document.getElementById('sharesList');
      if (!container || !list) return;

      if (shares.length === 0) {
        container.style.display = 'none';
        return;
      }

      container.style.display = 'block';
      list.innerHTML = shares.map(share => `
        <div class="share-item">
          <div class="share-info">
            <span class="share-permission">${PERMISSION_LEVELS[share.permission_level]?.name || share.permission_level}</span>
            <span class="share-stats">${share.access_count || 0} views</span>
          </div>
          <div class="share-actions">
            <button class="btn btn-sm" onclick="copyToClipboard('${window.location.origin}${window.location.pathname}?share=${share.share_token}')">Copy</button>
            <button class="btn btn-sm btn-danger" onclick="revokeShare('${share.id}')">Revoke</button>
          </div>
        </div>
      `).join('');
    }

    function copyToClipboard(text) {
      navigator.clipboard.writeText(text).then(() => {
        alert('Copied to clipboard!');
      }).catch(() => {
        const temp = document.createElement('textarea');
        temp.value = text;
        document.body.appendChild(temp);
        temp.select();
        document.execCommand('copy');
        document.body.removeChild(temp);
        alert('Copied to clipboard!');
      });
    }

    async function revokeShare(shareId) {
      if (!confirm('Revoke this share link? Anyone with this link will no longer be able to access.')) return;

      try {
        const supabase = getSupabaseClient();
        if (!supabase) return;

        const { error } = await supabase
          .from('room_design_shares')
          .delete()
          .eq('id', shareId);

        if (error) throw error;

        loadActiveShares();
      } catch (err) {
        alert('Error revoking share: ' + err.message);
      }
    }

    // Log activity for notifications
    async function logActivity(type, elementIndex = null, elementName = null, commentText = null) {
      if (!SHARE_STATE.designId) return;

      try {
        const supabase = getSupabaseClient();
        if (!supabase) return;

        await supabase.from('design_activity').insert({
          design_id: SHARE_STATE.designId,
          share_id: SHARE_STATE.shareId,
          activity_type: type,
          element_index: elementIndex,
          element_name: elementName,
          comment_text: commentText
        });
      } catch (err) {
        console.error('Error logging activity:', err);
      }
    }

    // Load recent activity for a design
    async function loadRecentActivity() {
      if (!SHARE_STATE.designId) return;

      try {
        const supabase = getSupabaseClient();
        if (!supabase) return;

        const { data, error } = await supabase
          .from('design_activity')
          .select('*')
          .eq('design_id', SHARE_STATE.designId)
          .order('created_at', { ascending: false })
          .limit(20);

        if (error) throw error;

        renderActivityList(data || []);
      } catch (err) {
        console.error('Error loading activity:', err);
      }
    }

    // Render the activity list
    function renderActivityList(activities) {
      const container = document.getElementById('recentActivity');
      const list = document.getElementById('activityList');
      if (!container || !list) return;

      if (activities.length === 0) {
        container.style.display = 'none';
        return;
      }

      container.style.display = 'block';

      const icons = {
        view: '',
        comment: '',
        approve: '',
        reject: ''
      };

      const formatTime = (timestamp) => {
        const date = new Date(timestamp);
        const now = new Date();
        const diffMs = now - date;
        const diffMins = Math.floor(diffMs / 60000);
        const diffHours = Math.floor(diffMs / 3600000);
        const diffDays = Math.floor(diffMs / 86400000);

        if (diffMins < 1) return 'Just now';
        if (diffMins < 60) return `${diffMins}m ago`;
        if (diffHours < 24) return `${diffHours}h ago`;
        if (diffDays < 7) return `${diffDays}d ago`;
        return date.toLocaleDateString();
      };

      const getActivityText = (activity) => {
        switch (activity.activity_type) {
          case 'view':
            return 'Someone viewed the design';
          case 'comment':
            return `Comment: "${activity.comment_text?.substring(0, 50)}${activity.comment_text?.length > 50 ? '...' : ''}"`;
          case 'approve':
            return `Approved: ${activity.element_name || 'an element'}`;
          case 'reject':
            return `Rejected: ${activity.element_name || 'an element'}`;
          default:
            return 'Activity';
        }
      };

      list.innerHTML = activities.map(activity => `
        <div class="activity-item">
          <div class="activity-icon ${activity.activity_type}">${icons[activity.activity_type] || ''}</div>
          <div class="activity-content">
            <div class="activity-text">${getActivityText(activity)}</div>
            <div class="activity-time">${formatTime(activity.created_at)}</div>
          </div>
        </div>
      `).join('');
    }

    // Check URL for shared design token on page load
    function checkSharedDesignUrl() {
      const urlParams = new URLSearchParams(window.location.search);
      // Check for both 'share' and 'p' parameters
      const shareToken = urlParams.get('share') || urlParams.get('p');

      console.log('Checking shared design URL:', window.location.search);
      console.log('Share token found:', shareToken);

      if (shareToken) {
        console.log('Loading shared design with token:', shareToken);
        loadSharedDesign(shareToken);
      }
    }

    function clearCanvas() {
      if (confirm('Clear all elements?')) {
        elements = [];
        walls = walls.filter(w => w.type === 'area');
        selectedElement = null;
        updateProperties();
        calculateQuote();
        saveUndoState();
        draw();
      }
    }

    // ===== EXPORT FUNCTIONALITY =====
    function toggleExportMenu() {
      const menu = document.getElementById('exportMenu');
      menu.classList.toggle('show');

      // Close when clicking outside
      const closeHandler = (e) => {
        if (!e.target.closest('.export-dropdown')) {
          menu.classList.remove('show');
          document.removeEventListener('click', closeHandler);
        }
      };

      setTimeout(() => {
        document.addEventListener('click', closeHandler);
      }, 0);
    }

    function exportToPDF() {
      document.getElementById('exportMenu').classList.remove('show');

      const { jsPDF } = window.jspdf;
      const doc = new jsPDF('p', 'mm', 'letter');

      const projectName = document.getElementById('projectName').value || 'Room Design';
      const roomType = document.getElementById('roomType').value;
      const quoteTotal = document.getElementById('quoteTotal').textContent;

      // Header
      doc.setFillColor(184, 154, 91); // Gold color
      doc.rect(0, 0, 216, 35, 'F');

      doc.setTextColor(0, 0, 0);
      doc.setFontSize(24);
      doc.setFont('helvetica', 'bold');
      doc.text('Surprise Granite', 15, 20);

      doc.setFontSize(10);
      doc.setFont('helvetica', 'normal');
      doc.text('Room Design Proposal', 15, 28);

      // Project info
      doc.setTextColor(51, 51, 51);
      doc.setFontSize(16);
      doc.setFont('helvetica', 'bold');
      doc.text(projectName, 15, 50);

      doc.setFontSize(11);
      doc.setFont('helvetica', 'normal');
      doc.setTextColor(102, 102, 102);
      doc.text(`Room Type: ${roomType.charAt(0).toUpperCase() + roomType.slice(1)}`, 15, 58);
      doc.text(`Dimensions: ${roomWidth}'  ${roomDepth}'`, 15, 65);
      doc.text(`Date: ${new Date().toLocaleDateString()}`, 15, 72);

      // Canvas image - 2D floor plan
      const canvas2D = document.getElementById('canvas2d');
      const imgData2D = canvas2D.toDataURL('image/png');
      doc.text('2D Floor Plan', 15, 85);
      doc.addImage(imgData2D, 'PNG', 15, 88, 85, 65);

      // 3D view if available
      if (renderer) {
        renderer.render(scene, camera);
        const imgData3D = renderer.domElement.toDataURL('image/png');
        doc.text('3D Visualization', 110, 85);
        doc.addImage(imgData3D, 'PNG', 110, 88, 85, 65);
      }

      // Elements list
      let yPos = 165;
      doc.setFontSize(14);
      doc.setFont('helvetica', 'bold');
      doc.setTextColor(51, 51, 51);
      doc.text('Design Elements', 15, yPos);
      yPos += 8;

      doc.setFontSize(10);
      doc.setFont('helvetica', 'normal');

      // Table header
      doc.setFillColor(240, 240, 240);
      doc.rect(15, yPos, 180, 8, 'F');
      doc.setTextColor(51, 51, 51);
      doc.text('Item', 18, yPos + 5.5);
      doc.text('Type', 75, yPos + 5.5);
      doc.text('Dimensions', 120, yPos + 5.5);
      doc.text('Material', 155, yPos + 5.5);
      yPos += 10;

      elements.forEach((el, index) => {
        if (yPos > 250) {
          doc.addPage();
          yPos = 20;
        }

        const bgColor = index % 2 === 0 ? [255, 255, 255] : [248, 248, 248];
        doc.setFillColor(...bgColor);
        doc.rect(15, yPos - 4, 180, 8, 'F');

        doc.setTextColor(51, 51, 51);
        doc.text(el.label || 'Element', 18, yPos + 1);
        doc.text(el.type.replace(/-/g, ' '), 75, yPos + 1);
        doc.text(`${el.width}'  ${el.height}'`, 120, yPos + 1);
        doc.text(el.material || '-', 155, yPos + 1);
        yPos += 8;
      });

      // Quote total
      yPos += 10;
      doc.setFillColor(184, 154, 91);
      doc.rect(15, yPos, 180, 15, 'F');
      doc.setTextColor(0, 0, 0);
      doc.setFontSize(14);
      doc.setFont('helvetica', 'bold');
      doc.text('Estimated Total:', 20, yPos + 10);
      doc.text(quoteTotal, 155, yPos + 10);

      // Footer
      doc.setFontSize(8);
      doc.setTextColor(128, 128, 128);
      doc.text('This is an estimate only. Final pricing may vary based on material selection and installation requirements.', 15, 270);
      doc.text('Surprise Granite  surprisegranite.com  (623) 466-4177', 15, 276);

      doc.save(`${projectName.replace(/\s+/g, '-')}-proposal.pdf`);
    }

    function exportToJSON() {
      document.getElementById('exportMenu').classList.remove('show');

      const projectName = document.getElementById('projectName').value || 'Room Design';

      const designData = {
        version: '1.0',
        projectName: projectName,
        roomType: document.getElementById('roomType').value,
        roomWidth: roomWidth,
        roomDepth: roomDepth,
        elements: elements.map(el => ({
          id: el.id,
          type: el.type,
          label: el.label,
          x: el.x,
          y: el.y,
          width: el.width,
          height: el.height,
          rotation: el.rotation,
          color: el.color,
          material: el.material,
          materialId: el.materialId,
          category: el.category,
          catalogSku: el.catalogSku
        })),
        walls: walls,
        createdAt: new Date().toISOString()
      };

      const jsonStr = JSON.stringify(designData, null, 2);
      const blob = new Blob([jsonStr], { type: 'application/json' });
      const url = URL.createObjectURL(blob);

      const a = document.createElement('a');
      a.href = url;
      a.download = `${projectName.replace(/\s+/g, '-')}-design.json`;
      a.click();

      URL.revokeObjectURL(url);
    }

    function importFromJSON() {
      document.getElementById('exportMenu').classList.remove('show');

      const input = document.createElement('input');
      input.type = 'file';
      input.accept = '.json';

      input.onchange = (e) => {
        const file = e.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = (event) => {
          try {
            const data = JSON.parse(event.target.result);

            if (!data.version || !data.elements) {
              throw new Error('Invalid design file format');
            }

            // Restore design
            document.getElementById('projectName').value = data.projectName || 'Imported Design';
            document.getElementById('roomType').value = data.roomType || 'kitchen';
            roomWidth = data.roomWidth || 12;
            roomDepth = data.roomDepth || 10;
            document.getElementById('roomWidth').value = roomWidth;
            document.getElementById('roomDepth').value = roomDepth;

            // Restore elements
            elements = data.elements.map(el => ({
              ...el,
              textureImg: null // Will reload texture if needed
            }));

            // Reload textures for elements
            elements.forEach(el => {
              if (el.materialId) {
                const category = Object.keys(MATERIALS).find(cat =>
                  MATERIALS[cat].some(m => m.id === el.materialId)
                );
                if (category) {
                  const material = MATERIALS[category].find(m => m.id === el.materialId);
                  if (material && material.url) {
                    const img = new Image();
                    img.crossOrigin = 'anonymous';
                    img.onload = () => {
                      el.textureImg = img;
                      draw();
                    };
                    img.src = material.url;
                  }
                }
              }
            });

            walls = data.walls || walls;

            selectedElement = null;
            updateProperties();
            calculateQuote();
            saveUndoState();
            draw();
            update3DScene();

            alert('Design loaded successfully!');
          } catch (err) {
            alert('Error loading design: ' + err.message);
          }
        };
        reader.readAsText(file);
      };

      input.click();
    }

    function exportToPNG() {
      document.getElementById('exportMenu').classList.remove('show');

      const projectName = document.getElementById('projectName').value || 'Room Design';
      const currentView = document.querySelector('.view-btn.active').id;

      let canvas;
      if (currentView === 'view3D' && renderer) {
        renderer.render(scene, camera);
        canvas = renderer.domElement;
      } else {
        canvas = document.getElementById('canvas2d');
      }

      const link = document.createElement('a');
      link.download = `${projectName.replace(/\s+/g, '-')}-${currentView === 'view3D' ? '3d' : '2d'}.png`;
      link.href = canvas.toDataURL('image/png');
      link.click();
    }

    function exportToCSV() {
      document.getElementById('exportMenu').classList.remove('show');

      const projectName = document.getElementById('projectName').value || 'Room Design';

      let csv = 'Item,Type,Category,Width (ft),Height (ft),Material,SKU,Notes\n';

      elements.forEach(el => {
        const row = [
          `"${el.label || 'Element'}"`,
          `"${el.type.replace(/-/g, ' ')}"`,
          `"${el.category || ''}"`,
          el.width,
          el.height,
          `"${el.material || ''}"`,
          `"${el.catalogSku || ''}"`,
          `""`
        ];
        csv += row.join(',') + '\n';
      });

      // Summary section
      csv += '\n';
      csv += 'Summary\n';
      csv += `Project,${projectName}\n`;
      csv += `Room Type,${document.getElementById('roomType').value}\n`;
      csv += `Room Dimensions,${roomWidth}' x ${roomDepth}'\n`;
      csv += `Total Elements,${elements.length}\n`;
      csv += `Estimated Total,${document.getElementById('quoteTotal').textContent}\n`;
      csv += `Generated,${new Date().toLocaleString()}\n`;

      const blob = new Blob([csv], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);

      const a = document.createElement('a');
      a.href = url;
      a.download = `${projectName.replace(/\s+/g, '-')}-parts-list.csv`;
      a.click();

      URL.revokeObjectURL(url);
    }
  </script>
</body>
</html>
