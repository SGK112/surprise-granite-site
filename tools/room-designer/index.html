<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Room Designer Pro | Remodely.ai | Surprise Granite</title>
  <link rel="icon" href="https://cdn.prod.website-files.com/6456ce4476abb25581fbad0c/6456ce4476abb269c6fbb176_Surprise-Granite-favicon-32x32px.png">
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">

  <!-- Three.js for 3D -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>

  <!-- Post-processing for enhanced visuals -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/UnpackDepthRGBAShader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/SAOShader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/DepthLimitedBlurShader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/SAOPass.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/FXAAShader.js"></script>

  <!-- Centralized Configuration -->
  <script src="/js/config.js"></script>

  <!-- Supabase -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script src="/js/supabase-init.js"></script>

  <!-- Auth System -->
  <script src="/js/sg-auth.js"></script>
  <script src="/js/auth-state.js"></script>

  <!-- PDF Export -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

  <!-- SheetJS for Excel/CSV parsing -->
  <script src="https://cdn.sheetjs.com/xlsx-0.20.1/package/dist/xlsx.full.min.js"></script>

  <!-- Stripe.js for Payment Processing -->
  <script src="https://js.stripe.com/v3/"></script>

  <!-- Slab Layout Module -->
  <link rel="stylesheet" href="slab-layout.css">

  <style>
    :root {
      --primary: #6366f1;
      --primary-dark: #4f46e5;
      --gold: #f9cb00;
      --gold-dark: #d4ab00;
      --dark: #0f0f1a;
      --dark-surface: #1a1a2e;
      --dark-elevated: #252540;
      --dark-hover: #2d2d4a;
      --text: #ffffff;
      --text-secondary: rgba(255,255,255,0.7);
      --text-muted: rgba(255,255,255,0.5);
      --border: rgba(255,255,255,0.1);
      --border-color: rgba(255,255,255,0.1);
      --panel-bg: #1a1a2e;
      --hover-bg: #2d2d4a;
      --text-primary: #ffffff;
      --success: #10b981;
      --warning: #f59e0b;
      --error: #ef4444;
      --remodely-gradient: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
    }

    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      font-family: 'Inter', -apple-system, sans-serif;
      background: var(--dark);
      color: var(--text);
      min-height: 100vh;
      overflow: hidden;
    }

    .app {
      height: 100vh;
      display: flex;
      flex-direction: column;
    }

    /* Header */
    .header {
      background: linear-gradient(90deg, rgba(30, 30, 46, 0.98) 0%, rgba(26, 26, 38, 0.98) 100%);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      border-bottom: 1px solid var(--border);
      padding: 0 20px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      height: 56px;
      flex-shrink: 0;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
      position: relative;
      z-index: 100;
    }

    .header-left {
      display: flex;
      align-items: center;
      gap: 20px;
    }

    .logo-group {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .logo {
      display: flex;
      align-items: center;
      gap: 8px;
      text-decoration: none;
    }

    .logo img {
      height: 28px;
    }

    .logo-divider {
      width: 1px;
      height: 24px;
      background: var(--border);
    }

    .powered-by {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 11px;
      color: var(--text-muted);
    }

    .powered-by .remodely-badge {
      background: var(--remodely-gradient);
      padding: 3px 8px;
      border-radius: 4px;
      font-weight: 600;
      font-size: 10px;
      color: white;
    }

    .project-input {
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 6px 12px;
      color: var(--text);
      font-size: 14px;
      font-weight: 500;
      min-width: 200px;
    }

    .project-input:focus {
      outline: none;
      border-color: var(--primary);
    }

    .header-center {
      display: flex;
      gap: 4px;
      background: var(--dark-elevated);
      padding: 4px;
      border-radius: 8px;
    }

    .view-btn {
      padding: 8px 16px;
      background: transparent;
      border: none;
      color: var(--text-muted);
      font-size: 13px;
      font-weight: 500;
      cursor: pointer;
      border-radius: 6px;
      transition: all 0.2s;
    }

    .view-btn:hover {
      color: var(--text);
    }

    .view-btn.active {
      background: var(--primary);
      color: white;
    }

    .header-zoom-controls {
      display: flex;
      align-items: center;
      gap: 2px;
      margin-left: 12px;
      padding-left: 12px;
      border-left: 1px solid var(--border);
    }

    .header-zoom-btn {
      width: 28px;
      height: 28px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: transparent;
      border: none;
      border-radius: 4px;
      color: var(--text-muted);
      cursor: pointer;
      font-size: 16px;
      font-weight: 500;
      transition: all 0.15s ease;
    }

    .header-zoom-btn:hover {
      background: rgba(255, 255, 255, 0.1);
      color: var(--text);
    }

    .header-zoom-level {
      font-size: 11px;
      font-weight: 600;
      color: var(--gold);
      min-width: 40px;
      text-align: center;
      padding: 4px 6px;
      background: rgba(249, 203, 0, 0.1);
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.15s ease;
    }

    .header-zoom-level:hover {
      background: rgba(249, 203, 0, 0.2);
    }

    .header-right {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    /* User Account Menu */
    .user-account-menu {
      position: relative;
    }

    .user-menu-btn {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 12px;
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      border-radius: 8px;
      color: var(--text-primary);
      cursor: pointer;
      font-size: 13px;
      font-weight: 500;
      transition: all 0.2s;
    }

    .user-menu-btn:hover {
      background: var(--hover-bg);
      border-color: var(--gold);
    }

    .user-avatar-small {
      width: 28px;
      height: 28px;
      border-radius: 50%;
      background: linear-gradient(135deg, var(--gold), #cca600);
      color: #1a1a2e;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 700;
      font-size: 12px;
    }

    .user-name-display {
      max-width: 100px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .user-dropdown {
      position: absolute;
      top: 100%;
      right: 0;
      margin-top: 8px;
      background: var(--dark-surface);
      border: 1px solid var(--border);
      border-radius: 10px;
      min-width: 200px;
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
      opacity: 0;
      visibility: hidden;
      transform: translateY(-10px);
      transition: all 0.2s;
      z-index: 9999;
      pointer-events: none;
    }

    .user-dropdown.show {
      opacity: 1;
      visibility: visible;
      transform: translateY(0);
      pointer-events: auto;
    }

    .dropdown-item {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 12px 16px;
      color: var(--text-secondary);
      text-decoration: none;
      font-size: 14px;
      cursor: pointer;
      transition: all 0.2s;
      border: none;
      background: none;
      width: 100%;
      text-align: left;
    }

    .dropdown-item:first-child {
      border-radius: 10px 10px 0 0;
    }

    .dropdown-item:last-child {
      border-radius: 0 0 10px 10px;
    }

    .dropdown-item:hover {
      background: var(--hover-bg);
      color: var(--text-primary);
    }

    .dropdown-item svg {
      opacity: 0.7;
    }

    .dropdown-item:hover svg {
      opacity: 1;
    }

    .dropdown-divider {
      height: 1px;
      background: var(--border-color);
      margin: 4px 0;
    }

    .dropdown-item.logout-item {
      color: #ff6b6b;
    }

    .dropdown-item.logout-item:hover {
      background: rgba(255, 107, 107, 0.1);
      color: #ff6b6b;
    }

    .dropdown-item.google-signin {
      background: #fff;
      color: #3c4043;
      font-weight: 500;
      border-bottom: 1px solid var(--border);
    }

    .dropdown-item.google-signin:hover {
      background: #f8f9fa;
    }

    .dropdown-item.google-signin svg {
      opacity: 1;
    }

    .btn {
      padding: 8px 16px;
      border-radius: 6px;
      font-size: 13px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      gap: 6px;
      border: none;
    }

    .btn-secondary {
      background: var(--dark-elevated);
      color: var(--text);
      border: 1px solid var(--border);
    }

    .btn-secondary:hover {
      background: var(--dark-hover);
    }

    .btn-primary {
      background: var(--gold);
      color: #000;
    }

    .btn-primary:hover {
      background: var(--gold-dark);
    }

    .btn-sm {
      padding: 6px 10px;
      font-size: 11px;
    }

    /* Export Dropdown */
    .export-dropdown {
      position: relative;
    }

    .export-menu {
      position: absolute;
      top: 100%;
      right: 0;
      margin-top: 4px;
      background: var(--dark-surface);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 8px 0;
      min-width: 180px;
      box-shadow: 0 10px 40px rgba(0,0,0,0.4);
      z-index: 1000;
      display: none;
    }

    .export-menu.show {
      display: block;
    }

    .export-menu button {
      width: 100%;
      padding: 10px 16px;
      background: none;
      border: none;
      color: var(--text);
      font-size: 13px;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 10px;
      text-align: left;
    }

    .export-menu button:hover {
      background: var(--dark-hover);
    }

    .export-menu button svg {
      flex-shrink: 0;
      color: var(--text-muted);
    }

    .export-divider {
      height: 1px;
      background: var(--border);
      margin: 8px 0;
    }

    /* Main Layout */
    .main {
      flex: 1;
      display: flex;
      overflow: hidden;
    }

    /* Sidebar */
    .sidebar {
      width: 220px;
      background: linear-gradient(180deg, rgba(30, 30, 46, 0.98) 0%, rgba(26, 26, 38, 0.98) 100%);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      border-right: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      flex-shrink: 0;
      overflow-y: auto;
      box-shadow: 2px 0 8px rgba(0, 0, 0, 0.15);
    }

    /* =============================================
       UPGRADED SIDEBAR SECTIONS - Enhanced UX
       ============================================= */
    .sidebar-section {
      border-bottom: 1px solid rgba(255, 255, 255, 0.05);
      transition: background 0.2s ease;
    }

    .sidebar-section:hover {
      background: rgba(255, 255, 255, 0.01);
    }

    .sidebar-header {
      padding: 10px 12px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      cursor: pointer;
      user-select: none;
      transition: all 0.2s ease;
      position: relative;
    }

    .sidebar-header::before {
      content: '';
      position: absolute;
      left: 0;
      top: 50%;
      transform: translateY(-50%);
      width: 3px;
      height: 0;
      background: var(--gold);
      border-radius: 0 2px 2px 0;
      transition: height 0.2s ease;
    }

    .sidebar-header:hover {
      background: rgba(255, 255, 255, 0.03);
    }

    .sidebar-header:hover::before {
      height: 60%;
    }

    .sidebar-section.expanded .sidebar-header::before {
      height: 80%;
    }

    .sidebar-title {
      font-size: 11px;
      font-weight: 600;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      transition: color 0.2s ease;
    }

    .sidebar-header:hover .sidebar-title {
      color: var(--text);
    }

    .sidebar-section.expanded .sidebar-title {
      color: var(--gold);
    }

    .sidebar-toggle {
      color: var(--text-muted);
      font-size: 10px;
      transition: transform 0.25s ease, color 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      width: 20px;
      height: 20px;
    }

    .sidebar-content.collapsed + .sidebar-header .sidebar-toggle,
    .sidebar-header:has(+ .sidebar-content.collapsed) .sidebar-toggle {
      transform: rotate(-90deg);
    }

    .sidebar-header:hover .sidebar-toggle {
      color: var(--text);
    }

    .sidebar-content {
      padding: 0 10px 10px;
      max-height: 1000px;
      overflow: hidden;
      transition: max-height 0.3s ease, padding 0.3s ease, opacity 0.2s ease;
      opacity: 1;
    }

    .sidebar-content.collapsed {
      max-height: 0;
      padding: 0 10px;
      opacity: 0;
    }

    /* Room List */
    .room-list {
      display: flex;
      flex-direction: column;
      gap: 4px;
      max-height: 200px;
      overflow-y: auto;
    }

    .room-item {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 10px;
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .room-item:hover {
      background: var(--dark-surface);
      border-color: var(--primary);
    }

    .room-item.active {
      background: rgba(249, 203, 0, 0.1);
      border-color: var(--gold);
    }

    .room-icon {
      font-size: 16px;
    }

    .room-name {
      flex: 1;
      font-size: 12px;
      font-weight: 500;
      color: var(--text-primary);
    }

    .room-size {
      font-size: 10px;
      color: var(--text-secondary);
      background: var(--dark);
      padding: 2px 6px;
      border-radius: 4px;
    }

    .room-delete-btn {
      width: 18px;
      height: 18px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: transparent;
      border: none;
      color: var(--text-secondary);
      font-size: 14px;
      cursor: pointer;
      border-radius: 4px;
      opacity: 0;
      transition: all 0.2s;
    }

    .room-item:hover .room-delete-btn {
      opacity: 1;
    }

    .room-delete-btn:hover {
      background: var(--error);
      color: white;
    }

    .room-edit-btn {
      width: 18px;
      height: 18px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: transparent;
      border: none;
      color: var(--text-secondary);
      font-size: 11px;
      cursor: pointer;
      border-radius: 4px;
      opacity: 0;
      transition: all 0.2s;
      margin-right: 4px;
    }

    .room-item:hover .room-edit-btn {
      opacity: 1;
    }

    .room-edit-btn:hover {
      background: var(--primary);
      color: white;
    }

    /* Floor Plans Grid */
    .floorplan-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 8px;
    }

    .floorplan-item {
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 10px;
      cursor: pointer;
      transition: all 0.2s;
      text-align: center;
    }

    .floorplan-item:hover {
      background: var(--dark-hover);
      border-color: var(--primary);
    }

    .floorplan-item.active {
      border-color: var(--primary);
      background: rgba(99, 102, 241, 0.15);
    }

    .floorplan-preview {
      width: 100%;
      height: 40px;
      margin-bottom: 6px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .floorplan-preview svg {
      width: 100%;
      height: 100%;
    }

    .floorplan-name {
      font-size: 10px;
      color: var(--text-secondary);
    }

    /* =============================================
       UPGRADED TOOL GRID - Enhanced UX
       ============================================= */
    .tool-grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 6px;
      padding: 4px;
      background: rgba(0, 0, 0, 0.15);
      border-radius: 10px;
    }

    .tool-btn {
      aspect-ratio: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: rgba(255, 255, 255, 0.03);
      border: 1px solid rgba(255, 255, 255, 0.05);
      border-radius: 8px;
      color: var(--text-muted);
      cursor: pointer;
      transition: all 0.2s ease;
      padding: 8px 4px;
      position: relative;
      overflow: hidden;
    }

    .tool-btn::before {
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(135deg, transparent 0%, rgba(255, 255, 255, 0.03) 100%);
      opacity: 0;
      transition: opacity 0.2s ease;
    }

    .tool-btn:hover {
      background: rgba(255, 255, 255, 0.06);
      border-color: rgba(255, 255, 255, 0.1);
      color: var(--text);
      transform: translateY(-1px);
    }

    .tool-btn:hover::before {
      opacity: 1;
    }

    .tool-btn:active {
      transform: translateY(0) scale(0.98);
    }

    .tool-btn.active {
      background: linear-gradient(135deg, var(--primary) 0%, #8b5cf6 100%);
      color: white;
      border-color: transparent;
      box-shadow: 0 4px 12px rgba(99, 102, 241, 0.35);
    }

    .tool-btn.active::after {
      content: '';
      position: absolute;
      bottom: 0;
      left: 50%;
      transform: translateX(-50%);
      width: 20px;
      height: 3px;
      background: white;
      border-radius: 3px 3px 0 0;
      opacity: 0.5;
    }

    .tool-btn svg {
      width: 20px;
      height: 20px;
      margin-bottom: 3px;
      transition: transform 0.2s ease;
    }

    .tool-btn:hover svg {
      transform: scale(1.1);
    }

    .tool-btn span {
      font-size: 9px;
      font-weight: 600;
      letter-spacing: 0.3px;
      text-transform: uppercase;
    }

    /* Tool keyboard shortcut badge */
    .tool-btn[data-shortcut]::after {
      content: attr(data-shortcut);
      position: absolute;
      top: 3px;
      right: 3px;
      font-size: 8px;
      font-weight: 700;
      font-family: monospace;
      color: var(--gold);
      opacity: 0;
      transition: opacity 0.2s ease;
    }

    .tool-btn:hover[data-shortcut]::after {
      opacity: 0.7;
    }

    .tool-btn.active[data-shortcut]::after {
      color: white;
      opacity: 0.6;
    }

    /* Layout Options Panel */
    .layout-options-panel {
      background: var(--dark-elevated);
      border: 1px solid var(--gold);
      border-radius: 8px;
      margin: 8px;
      overflow: hidden;
    }

    .layout-options-header {
      background: linear-gradient(135deg, var(--gold) 0%, #d4a84b 100%);
      color: var(--dark-bg);
      padding: 8px 12px;
      font-weight: 600;
      font-size: 12px;
    }

    .layout-options-content {
      padding: 10px;
    }

    .layout-option-row {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 8px;
    }

    .layout-option-row label {
      font-size: 11px;
      color: var(--text-secondary);
      min-width: 75px;
    }

    .layout-option-row select {
      flex: 1;
      background: var(--dark-bg);
      border: 1px solid var(--border);
      border-radius: 4px;
      color: var(--text);
      padding: 4px 6px;
      font-size: 11px;
    }

    .layout-option-row select:focus {
      border-color: var(--gold);
      outline: none;
    }

    .layout-option-row input[type="checkbox"] {
      accent-color: var(--gold);
    }

    .layout-option-hint {
      font-size: 10px;
      color: var(--text-muted);
      text-align: center;
      padding-top: 4px;
      border-top: 1px solid var(--border);
      margin-top: 4px;
    }

    /* Element Grid */
    .element-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 6px;
    }

    .element-item {
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 8px;
      cursor: grab;
      transition: all 0.2s;
      text-align: center;
      position: relative;
    }

    .element-item:hover {
      background: var(--dark-hover);
      border-color: var(--primary);
    }

    .element-item:active {
      cursor: grabbing;
    }

    .element-item.has-texture {
      border-color: var(--success);
    }

    .element-icon {
      width: 44px;
      height: 44px;
      margin: 0 auto 6px;
      border-radius: 6px;
      background-size: cover;
      background-position: center;
      box-shadow: 0 2px 4px rgba(0,0,0,0.3);
      border: 1px solid rgba(255,255,255,0.1);
      overflow: hidden;
    }

    .element-icon.element-svg {
      background: var(--dark-hover);
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 4px;
    }

    .element-icon.element-svg svg {
      width: 100%;
      height: 100%;
    }

    .element-name {
      font-size: 9px;
      font-weight: 500;
      color: var(--text-secondary);
      line-height: 1.2;
      word-wrap: break-word;
      overflow-wrap: break-word;
      max-width: 100%;
    }

    .element-upload-btn {
      position: absolute;
      top: 4px;
      right: 4px;
      width: 16px;
      height: 16px;
      background: var(--dark-surface);
      border: 1px solid var(--border);
      border-radius: 3px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      opacity: 0;
      transition: all 0.2s;
    }

    .element-item:hover .element-upload-btn {
      opacity: 1;
    }

    .element-upload-btn:hover {
      background: var(--primary);
      border-color: var(--primary);
    }

    .element-upload-btn svg {
      width: 10px;
      height: 10px;
      color: var(--text);
    }

    /* Materials Library */
    .materials-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 6px;
    }

    .material-item {
      aspect-ratio: 1;
      border-radius: 6px;
      cursor: pointer;
      border: 2px solid transparent;
      transition: all 0.2s;
      background-size: cover;
      background-position: center;
      position: relative;
    }

    .material-item:hover {
      border-color: var(--primary);
      transform: scale(1.05);
    }

    .material-item.selected {
      border-color: var(--gold);
    }

    .material-item::after {
      content: attr(data-name);
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      padding: 2px 4px;
      font-size: 8px;
      text-align: center;
      border-radius: 0 0 4px 4px;
    }

    .materials-tabs {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
      margin-bottom: 10px;
    }

    .material-tab {
      padding: 4px 8px;
      font-size: 10px;
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      border-radius: 4px;
      color: var(--text-muted);
      cursor: pointer;
      transition: all 0.2s;
    }

    .material-tab:hover {
      color: var(--text);
      border-color: var(--primary);
    }

    .material-tab.active {
      background: var(--primary);
      color: white;
      border-color: var(--primary);
    }

    .material-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 8px;
      max-height: 500px;
      overflow-y: auto;
    }

    .material-swatch {
      aspect-ratio: 1;
      min-height: 80px;
      border-radius: 8px;
      cursor: pointer;
      border: 2px solid transparent;
      transition: all 0.2s;
      background-size: cover;
      background-position: center;
      position: relative;
      overflow: hidden;
    }

    .material-swatch img {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      z-index: 1;
    }

    .material-swatch:hover {
      border-color: var(--primary);
      transform: scale(1.03);
    }

    .material-swatch.selected {
      border-color: var(--gold);
      box-shadow: 0 0 10px rgba(249, 203, 0, 0.4);
    }

    .material-swatch-label {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: linear-gradient(transparent, rgba(0,0,0,0.9));
      padding: 22px 5px 5px;
      font-size: 11px;
      line-height: 1.2;
      text-align: center;
      font-weight: 600;
      z-index: 2;
      color: #fff;
      text-shadow: 0 1px 2px rgba(0,0,0,0.8);
    }

    .material-price-badge {
      position: absolute;
      bottom: 24px;
      right: 4px;
      background: var(--gold);
      color: #000;
      padding: 2px 5px;
      border-radius: 4px;
      font-size: 9px;
      font-weight: 700;
      z-index: 3;
    }

    .material-brand-badge {
      position: absolute;
      top: 4px;
      left: 4px;
      background: rgba(0,0,0,0.8);
      color: #fff;
      padding: 2px 6px;
      border-radius: 4px;
      font-size: 8px;
      font-weight: 600;
      z-index: 3;
      text-transform: uppercase;
      letter-spacing: 0.3px;
    }

    .material-distributor-badge {
      position: absolute;
      top: 2px;
      right: 2px;
      background: rgba(16, 185, 129, 0.9);
      color: #fff;
      font-size: 7px;
      padding: 1px 4px;
      border-radius: 3px;
      z-index: 3;
      font-weight: 600;
      letter-spacing: 0.3px;
      text-transform: uppercase;
    }

    .material-trade-label {
      color: #10b981;
      font-weight: 600;
    }

    .material-distributor-badge img {
      height: 12px;
      margin-right: 3px;
      vertical-align: middle;
    }

    .finish-picker {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
      padding: 4px 0;
    }
    .finish-option {
      padding: 3px 8px;
      font-size: 10px;
      border-radius: 10px;
      background: rgba(255,255,255,0.08);
      color: rgba(255,255,255,0.7);
      border: 1px solid rgba(255,255,255,0.15);
      cursor: pointer;
      transition: all 0.2s;
      text-transform: capitalize;
    }
    .finish-option:hover {
      background: rgba(255,255,255,0.15);
      color: #fff;
    }
    .finish-option.active {
      background: var(--gold);
      color: #1a1a2e;
      border-color: var(--gold);
      font-weight: 600;
    }

    #distributor-loading-indicator {
      grid-column: 1 / -1;
      text-align: center;
      padding: 16px 8px;
      color: var(--gold);
      font-style: italic;
      opacity: 0.7;
      font-size: 12px;
    }

    .material-brand-header {
      grid-column: 1 / -1;
      background: var(--primary);
      color: #fff;
      padding: 6px 10px;
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      border-radius: 4px;
      margin-top: 8px;
    }

    .material-brand-header:first-child {
      margin-top: 0;
    }

    .material-no-texture-badge {
      position: absolute;
      bottom: 22px;
      right: 4px;
      color: rgba(255,255,255,0.5);
      font-size: 8px;
      z-index: 2;
    }

    .material-hint {
      font-size: 10px;
      color: var(--text-muted);
      text-align: center;
      margin-top: 10px;
      padding: 8px;
      background: var(--dark-elevated);
      border-radius: 6px;
      border: 1px dashed var(--border);
    }

    /* Cabinet Catalog */
    .catalog-brand select,
    .catalog-series select {
      width: 100%;
      padding: 8px 12px;
      background: rgba(255, 255, 255, 0.05);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 8px;
      color: var(--text);
      font-size: 12px;
      margin-bottom: 8px;
      cursor: pointer;
      transition: all 0.2s ease;
      appearance: none;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 24 24' fill='none' stroke='%23888' stroke-width='2'%3E%3Cpath d='M6 9l6 6 6-6'/%3E%3C/svg%3E");
      background-repeat: no-repeat;
      background-position: right 10px center;
      padding-right: 30px;
    }

    .catalog-brand select:hover,
    .catalog-series select:hover {
      background: rgba(255, 255, 255, 0.08);
      border-color: rgba(255, 255, 255, 0.2);
    }

    .catalog-brand select:focus,
    .catalog-series select:focus {
      outline: none;
      border-color: var(--primary);
      box-shadow: 0 0 0 3px rgba(249, 203, 0, 0.15);
    }

    .cabinet-catalog-list {
      max-height: 200px;
      overflow-y: auto;
      border: 1px solid var(--border);
      border-radius: 6px;
      background: var(--dark);
    }

    .cabinet-catalog-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 8px 10px;
      border-bottom: 1px solid var(--border);
      cursor: pointer;
      transition: background 0.15s;
    }

    .cabinet-catalog-item:last-child {
      border-bottom: none;
    }

    .cabinet-catalog-item:hover {
      background: var(--dark-elevated);
    }

    .cabinet-catalog-item.dragging {
      opacity: 0.5;
    }

    .cabinet-item-info {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .cabinet-item-sku {
      font-size: 10px;
      color: var(--text-muted);
      font-family: monospace;
    }

    .cabinet-item-name {
      font-size: 11px;
      color: var(--text);
      font-weight: 500;
    }

    .cabinet-item-size {
      font-size: 10px;
      color: var(--primary);
    }

    .cabinet-item-price {
      font-size: 11px;
      font-weight: 600;
      color: var(--success, #22c55e);
      margin-left: auto;
      padding: 2px 6px;
      background: rgba(34, 197, 94, 0.1);
      border-radius: 4px;
    }

    .cabinet-item-add {
      width: 24px;
      height: 24px;
      border-radius: 4px;
      background: var(--primary);
      border: none;
      color: white;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      font-weight: bold;
      transition: background 0.15s;
    }

    .cabinet-item-add:hover {
      background: var(--primary-dark);
    }

    .catalog-actions {
      margin-top: 10px;
      display: flex;
      gap: 6px;
    }

    .catalog-actions .btn {
      flex: 1;
      justify-content: center;
    }

    /* Product Catalog */
    .product-search-bar {
      display: flex;
      gap: 6px;
      margin-bottom: 10px;
    }

    .product-search-bar input {
      flex: 1;
      padding: 6px 10px;
      border: 1px solid var(--border);
      border-radius: 4px;
      background: var(--dark);
      color: var(--text);
      font-size: 12px;
    }

    .product-search-bar .search-icon {
      width: 28px;
      height: 28px;
      border: 1px solid var(--border);
      border-radius: 4px;
      background: var(--dark);
      color: var(--text-muted);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .product-filters {
      display: flex;
      gap: 6px;
      margin-bottom: 10px;
    }

    .product-filters select {
      flex: 1;
      padding: 6px 8px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 6px;
      background: rgba(255, 255, 255, 0.05);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      color: var(--text);
      font-size: 10px;
      cursor: pointer;
      transition: all 0.2s ease;
      appearance: none;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='10' height='10' viewBox='0 0 24 24' fill='none' stroke='%23888' stroke-width='2'%3E%3Cpath d='M6 9l6 6 6-6'/%3E%3C/svg%3E");
      background-repeat: no-repeat;
      background-position: right 6px center;
      padding-right: 22px;
    }

    .product-filters select:hover {
      background: rgba(255, 255, 255, 0.08);
      border-color: rgba(255, 255, 255, 0.2);
    }

    .product-filters select:focus {
      outline: none;
      border-color: var(--primary);
    }

    .product-catalog-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 8px;
      max-height: 240px;
      overflow-y: auto;
      padding: 4px;
      background: var(--dark);
      border-radius: 6px;
      border: 1px solid var(--border);
    }

    .product-card {
      background: var(--dark-elevated);
      border-radius: 6px;
      padding: 6px;
      cursor: pointer;
      transition: all 0.2s;
      border: 2px solid transparent;
    }

    .product-card:hover {
      border-color: var(--primary);
      transform: translateY(-2px);
    }

    .product-card.selected {
      border-color: var(--primary);
      background: rgba(59, 130, 246, 0.1);
    }

    .product-card-image {
      width: 100%;
      aspect-ratio: 1;
      border-radius: 4px;
      object-fit: cover;
      background: var(--dark);
      margin-bottom: 4px;
    }

    .product-card-name {
      font-size: 10px;
      font-weight: 500;
      color: var(--text);
      line-height: 1.2;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .product-card-meta {
      font-size: 9px;
      color: var(--text-muted);
      margin-top: 2px;
    }

    .product-hint {
      text-align: center;
      font-size: 10px;
      color: var(--text-muted);
      margin-top: 8px;
    }

    .loading-products {
      grid-column: 1 / -1;
      text-align: center;
      padding: 20px;
      color: var(--text-muted);
      font-size: 11px;
    }

    /* Canvas Area */
    .canvas-area {
      flex: 1;
      display: flex;
      flex-direction: column;
      background: #12121f;
      position: relative;
      overflow: hidden;
    }

    /* =============================================
       UPGRADED CANVAS TOOLBAR - Glassmorphic Design
       ============================================= */
    .canvas-toolbar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px 16px;
      background: linear-gradient(180deg,
        rgba(20, 20, 30, 0.92) 0%,
        rgba(15, 15, 25, 0.95) 100%);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      flex-shrink: 0;
      box-shadow: 0 2px 12px rgba(0, 0, 0, 0.3);
      position: relative;
    }

    .canvas-toolbar::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 50%;
      background: linear-gradient(180deg,
        rgba(255, 255, 255, 0.04) 0%,
        transparent 100%);
      pointer-events: none;
    }

    .toolbar-group {
      display: flex;
      align-items: center;
      gap: 8px;
      position: relative;
      z-index: 1;
    }

    .toolbar-btn-group {
      display: flex;
      align-items: center;
      background: linear-gradient(135deg,
        rgba(40, 40, 55, 0.7) 0%,
        rgba(30, 30, 45, 0.6) 100%);
      border: 1px solid rgba(255, 255, 255, 0.12);
      border-top-color: rgba(255, 255, 255, 0.18);
      border-radius: 10px;
      padding: 4px;
      gap: 3px;
      box-shadow:
        inset 0 1px 1px rgba(255, 255, 255, 0.06),
        0 2px 8px rgba(0, 0, 0, 0.15);
    }

    .toolbar-btn-group .btn {
      border-radius: 7px;
      border: none;
      background: transparent;
    }

    .toolbar-btn-group .btn:hover {
      background: rgba(255, 255, 255, 0.12);
    }

    .toolbar-divider {
      width: 1px;
      height: 28px;
      background: linear-gradient(180deg,
        transparent 0%,
        rgba(255, 255, 255, 0.2) 20%,
        rgba(255, 255, 255, 0.2) 80%,
        transparent 100%);
      margin: 0 12px;
    }

    .zoom-controls {
      display: flex;
      align-items: center;
      gap: 3px;
      background: linear-gradient(135deg,
        rgba(40, 40, 55, 0.7) 0%,
        rgba(30, 30, 45, 0.6) 100%);
      border: 1px solid rgba(255, 255, 255, 0.12);
      border-top-color: rgba(255, 255, 255, 0.18);
      border-radius: 10px;
      padding: 4px;
      box-shadow:
        inset 0 1px 1px rgba(255, 255, 255, 0.06),
        0 2px 8px rgba(0, 0, 0, 0.15);
    }

    .zoom-btn {
      width: 30px;
      height: 30px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: transparent;
      border: none;
      border-radius: 6px;
      color: var(--text-secondary);
      cursor: pointer;
      font-size: 16px;
      font-weight: 500;
      transition: all 0.15s ease;
    }

    .zoom-btn:hover {
      background: rgba(255, 255, 255, 0.08);
      color: var(--text);
    }

    .zoom-btn:active {
      background: rgba(249, 203, 0, 0.15);
      color: var(--gold);
      transform: scale(0.95);
    }

    .zoom-level {
      font-size: 12px;
      font-weight: 600;
      color: var(--gold);
      min-width: 52px;
      text-align: center;
      padding: 6px 10px;
      background: linear-gradient(135deg,
        rgba(249, 203, 0, 0.15) 0%,
        rgba(249, 203, 0, 0.08) 100%);
      border: 1px solid rgba(249, 203, 0, 0.2);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s ease;
      box-shadow: inset 0 1px 1px rgba(255, 255, 255, 0.1);
    }

    .zoom-level:hover {
      background: linear-gradient(135deg,
        rgba(249, 203, 0, 0.25) 0%,
        rgba(249, 203, 0, 0.15) 100%);
      border-color: rgba(249, 203, 0, 0.35);
      box-shadow: 0 2px 8px rgba(249, 203, 0, 0.2);
    }

    .canvas-info {
      display: flex;
      gap: 12px;
      font-size: 11px;
      color: var(--text-muted);
    }

    .canvas-info span {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 5px 12px;
      background: linear-gradient(135deg,
        rgba(255, 255, 255, 0.08) 0%,
        rgba(255, 255, 255, 0.03) 100%);
      border-radius: 8px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      box-shadow: inset 0 1px 1px rgba(255, 255, 255, 0.05);
    }

    .canvas-info span::before {
      content: '';
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: linear-gradient(135deg, var(--gold) 0%, #e6b800 100%);
      box-shadow: 0 0 6px rgba(249, 203, 0, 0.4);
    }

    /* Tooltip Enhancement */
    [data-tooltip] {
      position: relative;
    }

    [data-tooltip]::after {
      content: attr(data-tooltip);
      position: absolute;
      bottom: calc(100% + 8px);
      left: 50%;
      transform: translateX(-50%);
      padding: 6px 10px;
      background: rgba(15, 15, 26, 0.95);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 6px;
      font-size: 11px;
      font-weight: 500;
      color: var(--text);
      white-space: nowrap;
      opacity: 0;
      visibility: hidden;
      transition: all 0.15s ease;
      z-index: 1000;
      pointer-events: none;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    }

    [data-tooltip]::before {
      content: '';
      position: absolute;
      bottom: calc(100% + 4px);
      left: 50%;
      transform: translateX(-50%);
      border: 5px solid transparent;
      border-top-color: rgba(15, 15, 26, 0.95);
      opacity: 0;
      visibility: hidden;
      transition: all 0.15s ease;
      z-index: 1001;
    }

    [data-tooltip]:hover::after,
    [data-tooltip]:hover::before {
      opacity: 1;
      visibility: visible;
    }

    .shortcut-key {
      display: inline-block;
      padding: 2px 5px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 3px;
      font-size: 10px;
      font-family: monospace;
      margin-left: 6px;
      color: var(--gold);
    }

    .canvas-wrapper {
      flex: 1;
      position: relative;
      overflow: hidden;
      cursor: crosshair;
    }

    #canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }

    /* 3D View */
    #three-container {
      position: absolute;
      inset: 0;
      display: none;
    }

    #three-container.active {
      display: block;
    }

    /* =============================================
       UPGRADED 3D VIEW CONTROLS - Modern Design
       ============================================= */
    .three-controls {
      position: absolute;
      bottom: 20px;
      left: 20px;
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
      z-index: 100;
      max-width: calc(100% - 250px);
      background: rgba(15, 15, 26, 0.75);
      backdrop-filter: blur(16px);
      -webkit-backdrop-filter: blur(16px);
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 12px;
      padding: 6px;
    }

    .three-controls button {
      padding: 8px 12px;
      background: transparent;
      border: 1px solid transparent;
      border-radius: 8px;
      color: var(--text-secondary);
      font-size: 11px;
      font-weight: 500;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 6px;
      transition: all 0.15s ease;
      white-space: nowrap;
    }

    .three-controls button:hover {
      background: rgba(255, 255, 255, 0.08);
      color: var(--text);
    }

    .three-controls button:active {
      transform: scale(0.97);
    }

    .three-controls button.active {
      background: linear-gradient(135deg, var(--primary) 0%, #8b5cf6 100%);
      color: white;
      border-color: transparent;
      box-shadow: 0 2px 8px rgba(99, 102, 241, 0.3);
    }

    .three-controls button svg {
      width: 16px;
      height: 16px;
      flex-shrink: 0;
      transition: transform 0.15s ease;
    }

    .three-controls button:hover svg {
      transform: scale(1.1);
    }

    /* 3D Control Groups */
    .three-controls-group {
      display: flex;
      gap: 2px;
      padding: 3px;
      background: rgba(255, 255, 255, 0.03);
      border-radius: 8px;
      margin-right: 4px;
    }

    .three-controls-divider {
      width: 1px;
      height: 28px;
      background: rgba(255, 255, 255, 0.1);
      margin: 0 4px;
      align-self: center;
    }

    .three-hint {
      position: absolute;
      bottom: 20px;
      right: 20px;
      padding: 10px 14px;
      background: rgba(15, 15, 26, 0.8);
      backdrop-filter: blur(16px);
      -webkit-backdrop-filter: blur(16px);
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 10px;
      font-size: 11px;
      color: var(--text-secondary);
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .three-hint span {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .three-hint .hint-key {
      display: inline-block;
      padding: 2px 6px;
      background: rgba(255, 255, 255, 0.08);
      border-radius: 4px;
      font-family: monospace;
      font-size: 10px;
      color: var(--gold);
    }

    .three-hint.walkthrough-hint {
      background: linear-gradient(135deg, rgba(139, 92, 246, 0.95), rgba(59, 130, 246, 0.95));
      color: white;
      font-size: 12px;
      padding: 12px 18px;
      border: 1px solid rgba(255, 255, 255, 0.15);
      box-shadow: 0 8px 24px rgba(99, 102, 241, 0.35);
      animation: walkthroughPulse 2s ease-in-out infinite;
    }

    @keyframes walkthroughPulse {
      0%, 100% { box-shadow: 0 8px 24px rgba(99, 102, 241, 0.35); }
      50% { box-shadow: 0 8px 32px rgba(139, 92, 246, 0.5); }
    }

    /* Lighting Control Panel */
    .lighting-panel {
      position: absolute;
      top: 60px;
      right: 20px;
      width: 280px;
      background: rgba(15, 15, 26, 0.95);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      box-shadow: 0 12px 40px rgba(0, 0, 0, 0.5);
      z-index: 100;
      overflow: hidden;
    }

    .lighting-panel-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 16px;
      background: rgba(99, 102, 241, 0.15);
      border-bottom: 1px solid rgba(255, 255, 255, 0.08);
      font-weight: 600;
      font-size: 13px;
      color: var(--text);
    }

    .lighting-panel-header .close-btn {
      background: none;
      border: none;
      color: var(--text-secondary);
      font-size: 20px;
      cursor: pointer;
      padding: 0 4px;
      line-height: 1;
    }

    .lighting-panel-header .close-btn:hover {
      color: var(--text);
    }

    .lighting-panel-content {
      padding: 16px;
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    .lighting-presets label,
    .lighting-slider label {
      display: block;
      font-size: 11px;
      font-weight: 500;
      color: var(--text-secondary);
      margin-bottom: 8px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .preset-buttons {
      display: flex;
      gap: 8px;
    }

    .preset-btn {
      flex: 1;
      padding: 10px 8px;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 8px;
      font-size: 18px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .preset-btn:hover {
      background: rgba(255, 255, 255, 0.1);
      transform: translateY(-2px);
    }

    .preset-btn.active {
      background: linear-gradient(135deg, var(--primary), #8b5cf6);
      border-color: transparent;
      box-shadow: 0 4px 12px rgba(99, 102, 241, 0.4);
    }

    .lighting-slider {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .lighting-slider input[type="range"] {
      -webkit-appearance: none;
      appearance: none;
      width: 100%;
      height: 6px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 3px;
      outline: none;
    }

    .lighting-slider input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 16px;
      height: 16px;
      background: linear-gradient(135deg, var(--primary), #8b5cf6);
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 0 2px 8px rgba(99, 102, 241, 0.5);
    }

    .lighting-slider span {
      font-size: 11px;
      color: var(--gold);
      text-align: right;
    }

    .lighting-toggle {
      padding-top: 8px;
      border-top: 1px solid rgba(255, 255, 255, 0.08);
    }

    .lighting-toggle label {
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 12px;
      color: var(--text-secondary);
      cursor: pointer;
    }

    .lighting-toggle input[type="checkbox"] {
      width: 16px;
      height: 16px;
      accent-color: var(--primary);
    }

    .hd-badge {
      background: linear-gradient(135deg, #FFD700, #FFA500);
      color: #000;
      padding: 2px 6px;
      border-radius: 4px;
      font-size: 9px;
      font-weight: 600;
      margin-left: 4px;
    }

    .hd-toggle label {
      justify-content: space-between;
    }

    .three-hint.walkthrough-hint strong {
      display: block;
      margin-bottom: 6px;
      font-size: 13px;
      letter-spacing: 0.3px;
    }

    .three-hint.walkthrough-hint .hint-key {
      background: rgba(255, 255, 255, 0.2);
      color: white;
    }

    /* =============================================
       FLOATING QUICK-ACTION TOOLBAR - Glassmorphic
       ============================================= */
    .floating-toolbar {
      position: fixed;
      bottom: 24px;
      left: 50%;
      transform: translateX(-50%) translateY(100px);
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 10px 16px;
      background: linear-gradient(135deg,
        rgba(20, 20, 30, 0.92) 0%,
        rgba(15, 15, 25, 0.95) 50%,
        rgba(25, 25, 35, 0.93) 100%);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      border: 1px solid rgba(255, 255, 255, 0.15);
      border-top-color: rgba(255, 255, 255, 0.25);
      border-left-color: rgba(255, 255, 255, 0.2);
      border-radius: 20px;
      box-shadow:
        0 12px 40px rgba(0, 0, 0, 0.35),
        0 4px 12px rgba(0, 0, 0, 0.2),
        inset 0 1px 2px rgba(255, 255, 255, 0.1),
        inset 0 -1px 2px rgba(0, 0, 0, 0.1);
      z-index: 500;
      opacity: 0;
      visibility: hidden;
      transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
    }

    .floating-toolbar::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 50%;
      background: linear-gradient(180deg,
        rgba(255, 255, 255, 0.06) 0%,
        transparent 100%);
      pointer-events: none;
      border-radius: 20px 20px 0 0;
    }

    .floating-toolbar.visible {
      opacity: 1;
      visibility: visible;
      transform: translateX(-50%) translateY(0);
    }

    .floating-toolbar-group {
      display: flex;
      align-items: center;
      gap: 3px;
      padding: 5px 6px;
      background: linear-gradient(135deg,
        rgba(40, 40, 55, 0.6) 0%,
        rgba(30, 30, 45, 0.5) 100%);
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      box-shadow: inset 0 1px 1px rgba(255, 255, 255, 0.05);
    }

    .floating-toolbar-divider {
      width: 1px;
      height: 32px;
      background: linear-gradient(180deg,
        transparent 0%,
        rgba(255, 255, 255, 0.2) 20%,
        rgba(255, 255, 255, 0.2) 80%,
        transparent 100%);
      margin: 0 8px;
    }

    .float-btn {
      width: 40px;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: linear-gradient(135deg,
        rgba(50, 50, 65, 0.7) 0%,
        rgba(40, 40, 55, 0.6) 100%);
      border: 1px solid rgba(255, 255, 255, 0.12);
      border-radius: 10px;
      color: var(--text-secondary);
      cursor: pointer;
      transition: all 0.2s ease;
      position: relative;
    }

    .float-btn:hover {
      background: linear-gradient(135deg,
        rgba(255, 255, 255, 0.15) 0%,
        rgba(255, 255, 255, 0.08) 100%);
      border-color: rgba(255, 255, 255, 0.2);
      color: var(--text);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
    }

    .float-btn:hover svg {
      transform: scale(1.1);
    }

    .float-btn:active {
      transform: scale(0.95);
      background: rgba(255, 255, 255, 0.2);
    }

    .float-btn.primary {
      background: linear-gradient(135deg, var(--gold) 0%, #e6b800 100%);
      border-color: rgba(255, 255, 255, 0.3);
      color: #000;
      box-shadow: 0 4px 16px rgba(249, 203, 0, 0.3);
    }

    .float-btn.primary:hover {
      background: linear-gradient(135deg, #ffe033 0%, var(--gold) 100%);
      box-shadow: 0 4px 12px rgba(249, 203, 0, 0.35);
    }

    .float-btn.danger:hover {
      background: rgba(239, 68, 68, 0.2);
      color: #ef4444;
    }

    .float-btn svg {
      width: 18px;
      height: 18px;
      transition: transform 0.15s ease;
    }

    .float-btn .shortcut {
      position: absolute;
      bottom: -2px;
      right: 2px;
      font-size: 8px;
      font-weight: 700;
      font-family: monospace;
      color: var(--gold);
      opacity: 0.6;
    }

    .float-btn:hover .shortcut {
      opacity: 1;
    }

    /* Selection info badge */
    .selection-badge {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 6px 12px;
      background: rgba(249, 203, 0, 0.1);
      border: 1px solid rgba(249, 203, 0, 0.2);
      border-radius: 8px;
      font-size: 11px;
      font-weight: 600;
      color: var(--gold);
      margin-right: 4px;
    }

    .selection-badge .count {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      min-width: 18px;
      height: 18px;
      background: var(--gold);
      color: #000;
      border-radius: 9px;
      font-size: 10px;
      font-weight: 700;
    }

    /* Right Panel */
    .right-panel {
      width: 260px;
      background: linear-gradient(180deg, rgba(30, 30, 46, 0.98) 0%, rgba(26, 26, 38, 0.98) 100%);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      border-left: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      flex-shrink: 0;
      overflow-y: auto;
      box-shadow: -2px 0 8px rgba(0, 0, 0, 0.15);
    }

    .panel-section {
      padding: 8px 12px;
      border-bottom: 1px solid var(--border);
    }

    .panel-section.collapsed .panel-content {
      display: none;
    }

    .panel-section.collapsed .panel-title .toggle-icon {
      transform: rotate(-90deg);
    }

    .panel-title {
      font-size: 10px;
      font-weight: 600;
      color: var(--text-muted);
      text-transform: uppercase;
      margin-bottom: 8px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      cursor: pointer;
      user-select: none;
    }

    .panel-title .toggle-icon {
      font-size: 8px;
      transition: transform 0.2s;
      opacity: 0.5;
    }

    .panel-title:hover .toggle-icon {
      opacity: 1;
    }

    /* Element Selector Styles */
    #elementSelectorSection .panel-title {
      display: flex;
      align-items: center;
    }

    .element-total-count {
      background: var(--accent);
      color: white;
      font-size: 10px;
      padding: 2px 6px;
      border-radius: 10px;
      margin-left: auto;
      font-weight: 600;
    }

    .element-type-selector {
      display: flex;
      flex-direction: column;
      gap: 4px;
      max-height: 200px;
      overflow-y: auto;
    }

    .element-type-row {
      display: flex;
      align-items: center;
      padding: 6px 8px;
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.15s ease;
      gap: 8px;
    }

    .element-type-row:hover {
      background: var(--dark-surface);
      border-color: var(--accent);
    }

    .element-type-row.active {
      background: rgba(99, 102, 241, 0.15);
      border-color: var(--accent);
    }

    .element-type-row.has-selection {
      border-left: 3px solid var(--accent);
    }

    .element-type-checkbox {
      width: 16px;
      height: 16px;
      border-radius: 4px;
      border: 2px solid var(--border);
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
    }

    .element-type-row.active .element-type-checkbox {
      background: var(--accent);
      border-color: var(--accent);
    }

    .element-type-row.active .element-type-checkbox::after {
      content: '';
      color: white;
      font-size: 10px;
      font-weight: bold;
    }

    .element-type-label {
      flex: 1;
      font-size: 12px;
      color: var(--text);
      text-transform: capitalize;
    }

    .element-type-count {
      background: var(--dark-surface);
      color: var(--text-muted);
      font-size: 10px;
      padding: 2px 6px;
      border-radius: 8px;
      font-weight: 500;
    }

    .element-type-row.active .element-type-count {
      background: var(--accent);
      color: white;
    }

    .element-instance-list {
      margin-top: 8px;
      padding-top: 8px;
      border-top: 1px solid var(--border);
      max-height: 150px;
      overflow-y: auto;
    }

    .element-instance-item {
      display: flex;
      align-items: center;
      padding: 5px 8px;
      margin-bottom: 3px;
      background: var(--dark-surface);
      border-radius: 4px;
      cursor: pointer;
      font-size: 11px;
      color: var(--text-secondary);
      transition: all 0.1s ease;
    }

    .element-instance-item:hover {
      background: var(--dark-elevated);
      color: var(--text);
    }

    .element-instance-item.selected {
      background: rgba(99, 102, 241, 0.2);
      color: var(--accent);
      font-weight: 500;
    }

    .element-instance-dims {
      margin-left: auto;
      font-size: 10px;
      color: var(--text-muted);
    }

    .element-selector-actions {
      display: flex;
      gap: 6px;
      margin-top: 8px;
      padding-top: 8px;
      border-top: 1px solid var(--border);
    }

    .btn-small {
      padding: 4px 8px;
      font-size: 11px;
      border-radius: 4px;
      border: none;
      cursor: pointer;
      transition: all 0.15s ease;
    }

    .btn-small.btn-primary {
      background: var(--accent);
      color: white;
    }

    .btn-small.btn-secondary {
      background: var(--dark-elevated);
      color: var(--text-secondary);
      border: 1px solid var(--border);
    }

    .btn-small.btn-danger {
      background: var(--error);
      color: white;
    }

    .btn-small:hover {
      opacity: 0.85;
      transform: translateY(-1px);
    }

    .no-elements-msg {
      color: var(--text-muted);
      font-size: 11px;
      text-align: center;
      padding: 12px;
    }

    /* Flat Element List Styles */
    .element-flat-list {
      border: 1px solid var(--border);
      border-radius: 6px;
      background: var(--dark-bg);
    }

    .element-list-item {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 10px;
      cursor: pointer;
      border-bottom: 1px solid var(--border);
      transition: all 0.15s ease;
    }

    .element-list-item:last-child {
      border-bottom: none;
    }

    .element-list-item:hover {
      background: var(--dark-elevated);
    }

    .element-list-item.selected {
      background: rgba(99, 102, 241, 0.2);
      border-left: 3px solid var(--accent);
    }

    .element-list-icon {
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: var(--dark-elevated);
      border-radius: 4px;
      font-size: 12px;
      flex-shrink: 0;
    }

    .element-list-info {
      flex: 1;
      min-width: 0;
      overflow: hidden;
    }

    .element-list-name {
      font-size: 12px;
      font-weight: 500;
      color: var(--text);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .element-list-meta {
      font-size: 10px;
      color: var(--text-muted);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    /* Item Picker / Quote List Styles */
    .item-picker-total {
      background: linear-gradient(135deg, #22c55e, #16a34a);
      color: white;
      font-size: 11px;
      padding: 3px 8px;
      border-radius: 4px;
      font-weight: 600;
    }

    .item-picker-controls {
      margin-bottom: 8px;
    }

    .item-filter {
      width: 100%;
      padding: 6px 8px;
      font-size: 11px;
    }

    .item-picker-list {
      max-height: 280px;
      overflow-y: auto;
      border: 1px solid var(--border);
      border-radius: 6px;
      background: var(--dark-surface);
    }

    .item-picker-item {
      display: flex;
      flex-direction: column;
      padding: 8px 10px;
      border-bottom: 1px solid var(--border);
      cursor: pointer;
      transition: all 0.15s ease;
    }

    .item-picker-item:last-child {
      border-bottom: none;
    }

    .item-picker-item:hover {
      background: var(--dark-elevated);
    }

    .item-picker-item.selected {
      background: rgba(99, 102, 241, 0.15);
      border-left: 3px solid var(--accent);
    }

    .item-row-main {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .item-checkbox {
      width: 18px;
      height: 18px;
      cursor: pointer;
      accent-color: var(--accent);
      flex-shrink: 0;
      margin: 0;
      border-radius: 4px;
    }

    .item-checkbox:checked {
      background: var(--accent);
    }

    .item-icon {
      width: 24px;
      height: 24px;
      background: var(--dark-elevated);
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      flex-shrink: 0;
    }

    .item-details {
      flex: 1;
      min-width: 0;
    }

    .item-name {
      font-size: 12px;
      font-weight: 500;
      color: var(--text);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .item-meta {
      font-size: 10px;
      color: var(--text-muted);
      display: flex;
      gap: 8px;
    }

    .item-price {
      font-size: 11px;
      font-weight: 600;
      color: #22c55e;
      white-space: nowrap;
    }

    .item-row-secondary {
      display: flex;
      justify-content: space-between;
      margin-top: 4px;
      padding-left: 46px;
    }

    .item-material {
      font-size: 10px;
      color: var(--accent);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 120px;
    }

    .item-dims {
      font-size: 10px;
      color: var(--text-muted);
    }

    .item-detail-line {
      font-size: 10px;
      margin-top: 2px;
      color: var(--text-muted);
    }

    .item-sku {
      background: rgba(99, 102, 241, 0.2);
      color: var(--accent);
      padding: 1px 4px;
      border-radius: 3px;
      font-family: monospace;
      font-size: 9px;
    }

    .item-catalog {
      color: var(--text-muted);
      font-size: 9px;
    }

    .item-sqft {
      color: #22c55e;
      font-weight: 500;
    }

    .item-rate {
      color: var(--text-muted);
      font-style: italic;
    }

    .item-picker-summary {
      margin-top: 8px;
      padding: 8px;
      background: var(--dark-elevated);
      border-radius: 6px;
    }

    .summary-row {
      display: flex;
      justify-content: space-between;
      font-size: 11px;
      color: var(--text-secondary);
      margin-bottom: 4px;
    }

    .summary-row:last-child {
      margin-bottom: 0;
      font-weight: 600;
      color: var(--text);
    }

    .item-picker-actions {
      display: flex;
      gap: 6px;
      margin-top: 8px;
    }

    .item-picker-empty {
      padding: 20px;
      text-align: center;
      color: var(--text-muted);
      font-size: 12px;
    }

    /* Room Templates Styles */
    .room-templates-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 4px;
    }

    .template-btn {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 6px 4px;
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.15s ease;
      color: var(--text);
    }

    .template-btn:hover {
      background: var(--dark-surface);
      border-color: var(--accent);
      transform: translateY(-1px);
    }

    .template-btn:active {
      transform: translateY(0);
    }

    .template-icon {
      font-size: 16px;
      margin-bottom: 2px;
    }

    .template-name {
      font-size: 9px;
      font-weight: 500;
      color: var(--text-secondary);
    }

    .template-btn:hover .template-name {
      color: var(--accent);
    }

    .template-hint {
      font-size: 8px;
      color: var(--text-muted);
      text-align: center;
      margin-top: 6px;
      margin-bottom: 0;
      opacity: 0.7;
    }

    .room-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 6px;
    }

    .input-group {
      display: flex;
      flex-direction: column;
      gap: 3px;
    }

    .input-label {
      font-size: 9px;
      color: var(--text-muted);
    }

    .input-field {
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      border-radius: 4px;
      padding: 5px 7px;
      color: var(--text);
      font-size: 11px;
    }

    .input-field:focus {
      outline: none;
      border-color: var(--primary);
    }

    select.input-field {
      cursor: pointer;
    }

    /* Properties Panel */
    .properties-empty {
      text-align: center;
      padding: 12px;
      color: var(--text-muted);
      font-size: 11px;
    }

    .quick-actions {
      display: flex;
      gap: 4px;
    }

    .quick-btn {
      padding: 6px;
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      border-radius: 6px;
      cursor: pointer;
      color: var(--text-secondary);
      transition: all 0.15s;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .quick-btn:hover {
      background: var(--gold);
      color: var(--dark-bg);
      border-color: var(--gold);
    }

    .quick-btn.danger:hover {
      background: #e74c3c;
      border-color: #e74c3c;
      color: white;
    }

    /* Visibility toggle styles */
    .visibility-toggle {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 4px 6px;
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      border-radius: 4px;
      cursor: pointer;
      font-size: 10px;
      color: var(--text-secondary);
      transition: all 0.15s;
    }

    .visibility-toggle:hover {
      background: rgba(200, 169, 106, 0.1);
      border-color: var(--gold);
    }

    .visibility-toggle input[type="checkbox"] {
      width: 14px;
      height: 14px;
      margin: 0;
      cursor: pointer;
      accent-color: var(--gold);
    }

    .visibility-toggle input[type="checkbox"]:not(:checked) + span {
      text-decoration: line-through;
      opacity: 0.5;
    }

    /* Collapsible panel styles */
    .collapsible-header {
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .collapsible-header:hover {
      color: var(--gold);
    }

    .panel-toggle {
      font-size: 10px;
      transition: transform 0.2s;
    }

    .collapsible-panel .panel-content {
      overflow: hidden;
      transition: max-height 0.3s ease, padding 0.3s ease;
      max-height: 500px;
    }

    .collapsible-panel .panel-content.collapsed {
      max-height: 0;
      padding-top: 0;
      padding-bottom: 0;
    }

    .property-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }

    .property-label {
      font-size: 11px;
      color: var(--text-secondary);
    }

    .property-input {
      width: 70px;
      background: rgba(255, 255, 255, 0.05);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 6px;
      padding: 6px 8px;
      color: var(--text);
      font-size: 11px;
      text-align: right;
      transition: all 0.2s ease;
    }

    .property-input:hover {
      background: rgba(255, 255, 255, 0.08);
      border-color: rgba(255, 255, 255, 0.2);
    }

    .property-input:focus {
      outline: none;
      border-color: var(--primary);
      box-shadow: 0 0 0 3px rgba(249, 203, 0, 0.15);
    }

    .property-select {
      width: 100px;
      background: rgba(255, 255, 255, 0.05);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 6px;
      padding: 6px 8px;
      color: var(--text);
      font-size: 10px;
      cursor: pointer;
      transition: all 0.2s ease;
      appearance: none;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='10' height='10' viewBox='0 0 24 24' fill='none' stroke='%23888' stroke-width='2'%3E%3Cpath d='M6 9l6 6 6-6'/%3E%3C/svg%3E");
      background-repeat: no-repeat;
      background-position: right 6px center;
      padding-right: 22px;
    }

    .property-select:hover {
      background: rgba(255, 255, 255, 0.08);
      border-color: rgba(255, 255, 255, 0.2);
    }

    .property-select:focus {
      outline: none;
      border-color: var(--primary);
    }

    .checkbox-group {
      display: flex;
      gap: 10px;
      font-size: 10px;
    }

    .checkbox-group label {
      display: flex;
      align-items: center;
      gap: 4px;
      cursor: pointer;
    }

    .checkbox-group input[type="checkbox"] {
      width: 12px;
      height: 12px;
      accent-color: var(--primary);
    }

    .seam-controls {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .seam-btn {
      padding: 3px 8px;
      font-size: 10px;
      background: var(--primary);
      color: white;
      border: none;
      border-radius: 3px;
      cursor: pointer;
    }

    .seam-btn:hover {
      background: var(--accent);
    }

    .seam-btn.seam-clear {
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      color: var(--text-muted);
    }

    .seam-btn.seam-clear:hover {
      border-color: #dc3545;
      color: #dc3545;
    }

    .seam-count {
      font-size: 10px;
      color: var(--text-muted);
    }

    .dimension-display {
      font-size: 10px;
      color: var(--gold);
      margin-left: 6px;
      white-space: nowrap;
      min-width: 50px;
    }

    .color-picker {
      width: 70px;
      height: 26px;
      border: 1px solid var(--border);
      border-radius: 4px;
      cursor: pointer;
      padding: 0;
    }

    .texture-preview {
      width: 70px;
      height: 40px;
      border-radius: 4px;
      background-size: cover;
      background-position: center;
      border: 1px solid var(--border);
      cursor: pointer;
    }

    .texture-preview:hover {
      border-color: var(--primary);
    }

    .texture-controls {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .texture-upload-btn,
    .texture-clear-btn {
      width: 28px;
      height: 28px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      border-radius: 4px;
      cursor: pointer;
      color: var(--text-secondary);
      font-size: 12px;
      padding: 0;
    }

    .texture-upload-btn:hover {
      background: var(--primary);
      border-color: var(--primary);
      color: white;
    }

    .texture-clear-btn:hover {
      background: var(--error);
      border-color: var(--error);
      color: white;
    }

    .texture-upload-btn svg {
      width: 14px;
      height: 14px;
    }

    /* Grain Direction Controls */
    .grain-direction-controls {
      display: flex;
      gap: 4px;
    }

    .grain-btn {
      width: 28px;
      height: 28px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      border-radius: 4px;
      cursor: pointer;
      color: var(--text-secondary);
      font-size: 14px;
      font-weight: bold;
      padding: 0;
      transition: all 0.2s;
    }

    .grain-btn:hover {
      background: var(--primary);
      border-color: var(--primary);
      color: white;
    }

    .grain-btn.active {
      background: var(--gold);
      border-color: var(--gold);
      color: var(--dark-bg);
    }

    /* Validation Panel */
    .validation-section {
      border-bottom: 1px solid var(--border);
      padding-bottom: 8px;
      margin-bottom: 8px;
    }

    .validation-section .panel-title {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .validation-toggle,
    .validation-refresh {
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      border-radius: 4px;
      color: var(--text-secondary);
      cursor: pointer;
      font-size: 12px;
      padding: 2px 6px;
      margin-left: auto;
    }

    .validation-toggle:hover,
    .validation-refresh:hover {
      background: var(--primary);
      color: white;
      border-color: var(--primary);
    }

    .validation-toggle.active {
      background: var(--success);
      color: white;
      border-color: var(--success);
    }

    .validation-content {
      padding: 8px 16px;
      font-size: 11px;
      max-height: 180px;
      overflow-y: auto;
    }

    .validation-hint {
      color: var(--text-muted);
      font-style: italic;
    }

    .validation-ok {
      color: var(--success);
      font-weight: 500;
    }

    .validation-category {
      margin-bottom: 10px;
    }

    .validation-category-title {
      font-weight: 600;
      color: var(--text-secondary);
      margin-bottom: 4px;
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .validation-issue {
      display: flex;
      align-items: flex-start;
      gap: 6px;
      padding: 4px 0;
      border-bottom: 1px solid var(--border);
    }

    .validation-issue:last-child {
      border-bottom: none;
    }

    .validation-icon {
      flex-shrink: 0;
      font-size: 12px;
    }

    .validation-error .validation-icon {
      color: var(--error);
    }

    .validation-warning .validation-icon {
      color: var(--gold);
    }

    .validation-info .validation-icon {
      color: var(--primary);
    }

    .validation-message {
      color: var(--text-secondary);
      line-height: 1.3;
    }

    /* Quote Panel */
    .quote-section {
      flex: 1;
      display: flex;
      flex-direction: column;
      min-height: 0;
    }

    .quote-items {
      flex: 1;
      overflow-y: auto;
      padding: 0 16px;
    }

    .quote-item {
      display: flex;
      justify-content: space-between;
      padding: 8px 0;
      border-bottom: 1px solid var(--border);
      font-size: 11px;
    }

    .quote-item-name {
      color: var(--text-secondary);
    }

    .quote-item-value {
      color: var(--text);
      font-weight: 500;
    }

    .quote-total {
      padding: 12px 16px;
      background: var(--dark-elevated);
      border-top: 1px solid var(--border);
    }

    .quote-total-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .quote-total-label {
      font-size: 12px;
      font-weight: 600;
      color: var(--text);
    }

    .quote-total-value {
      font-size: 18px;
      font-weight: 700;
      color: var(--gold);
    }

    .quote-actions {
      padding-top: 12px;
      border-top: 1px solid var(--border);
    }

    .btn-checkout {
      width: 100%;
      padding: 12px 16px;
      background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%);
      color: white;
      border: none;
      border-radius: 8px;
      font-size: 13px;
      font-weight: 600;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
      box-shadow: 0 2px 8px rgba(34, 197, 94, 0.3);
    }

    .btn-checkout:hover {
      background: linear-gradient(135deg, #16a34a 0%, #15803d 100%);
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(34, 197, 94, 0.4);
    }

    .btn-checkout:disabled {
      background: #4a4a5a;
      cursor: not-allowed;
      box-shadow: none;
      transform: none;
    }

    .quote-disclaimer {
      font-size: 10px;
      color: var(--text-secondary);
      text-align: center;
      margin: 8px 0 0;
      line-height: 1.4;
    }

    /* Payment Modal */
    .payment-modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.7);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10000;
      backdrop-filter: blur(4px);
    }

    .payment-modal {
      background: var(--dark-elevated);
      border-radius: 16px;
      width: 90%;
      max-width: 480px;
      max-height: 90vh;
      overflow-y: auto;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
      border: 1px solid var(--border);
    }

    .payment-modal-header {
      padding: 20px 24px;
      border-bottom: 1px solid var(--border);
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .payment-modal-header h2 {
      font-size: 18px;
      font-weight: 600;
      margin: 0;
      color: var(--text);
    }

    .payment-modal-close {
      background: none;
      border: none;
      color: var(--text-secondary);
      cursor: pointer;
      padding: 4px;
      border-radius: 4px;
      transition: all 0.2s;
    }

    .payment-modal-close:hover {
      color: var(--text);
      background: var(--border);
    }

    .payment-modal-body {
      padding: 24px;
    }

    .payment-summary {
      background: rgba(255, 255, 255, 0.03);
      border-radius: 12px;
      padding: 16px;
      margin-bottom: 20px;
    }

    .payment-summary-row {
      display: flex;
      justify-content: space-between;
      padding: 8px 0;
      font-size: 13px;
    }

    .payment-summary-row.total {
      border-top: 1px solid var(--border);
      margin-top: 8px;
      padding-top: 12px;
      font-weight: 600;
      font-size: 15px;
    }

    .payment-summary-row .label {
      color: var(--text-secondary);
    }

    .payment-summary-row .value {
      color: var(--text);
    }

    .payment-summary-row.total .value {
      color: var(--gold);
    }

    .payment-options {
      margin-bottom: 20px;
    }

    .payment-option {
      background: rgba(255, 255, 255, 0.03);
      border: 2px solid var(--border);
      border-radius: 12px;
      padding: 16px;
      margin-bottom: 12px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .payment-option:hover {
      border-color: var(--accent-color);
      background: rgba(139, 92, 246, 0.05);
    }

    .payment-option.selected {
      border-color: var(--gold);
      background: rgba(212, 175, 55, 0.1);
    }

    .payment-option-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 6px;
    }

    .payment-option-title {
      font-weight: 600;
      font-size: 14px;
      color: var(--text);
    }

    .payment-option-amount {
      font-weight: 700;
      font-size: 16px;
      color: var(--gold);
    }

    .payment-option-desc {
      font-size: 12px;
      color: var(--text-secondary);
      line-height: 1.4;
    }

    .payment-form-group {
      margin-bottom: 16px;
    }

    .payment-form-group label {
      display: block;
      font-size: 12px;
      font-weight: 500;
      color: var(--text-secondary);
      margin-bottom: 6px;
    }

    .payment-form-group input {
      width: 100%;
      padding: 10px 12px;
      background: var(--dark);
      border: 1px solid var(--border);
      border-radius: 8px;
      color: var(--text);
      font-size: 14px;
    }

    .payment-form-group input:focus {
      outline: none;
      border-color: var(--accent-color);
    }

    .payment-submit {
      width: 100%;
      padding: 14px 20px;
      background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%);
      color: white;
      border: none;
      border-radius: 10px;
      font-size: 15px;
      font-weight: 600;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      transition: all 0.2s;
    }

    .payment-submit:hover {
      background: linear-gradient(135deg, #16a34a 0%, #15803d 100%);
    }

    .payment-submit:disabled {
      background: #4a4a5a;
      cursor: not-allowed;
    }

    .payment-secure {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      margin-top: 16px;
      font-size: 11px;
      color: var(--text-secondary);
    }

    .payment-secure svg {
      width: 14px;
      height: 14px;
    }

    /* Context Menu */
    .context-menu {
      position: fixed;
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 6px 0;
      min-width: 160px;
      z-index: 1000;
      box-shadow: 0 8px 32px rgba(0,0,0,0.4);
    }

    .context-menu-item {
      padding: 8px 14px;
      font-size: 12px;
      color: var(--text-secondary);
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .context-menu-item:hover {
      background: var(--dark-hover);
      color: var(--text);
    }

    .context-menu-item.danger {
      color: var(--error);
    }

    .context-menu-item svg {
      width: 14px;
      height: 14px;
    }

    .context-menu-divider {
      height: 1px;
      background: var(--border);
      margin: 4px 0;
    }

    .context-menu-label {
      padding: 6px 14px;
      font-size: 10px;
      color: var(--text-muted);
      text-transform: uppercase;
      font-weight: 600;
    }

    /* Modals */
    .modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.7);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1001;
    }

    .modal-overlay.active {
      display: flex;
    }

    .modal {
      background: var(--dark-surface);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 20px;
      width: 100%;
      max-width: 500px;
      max-height: 80vh;
      overflow-y: auto;
    }

    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 16px;
    }

    .modal-title {
      font-size: 16px;
      font-weight: 600;
    }

    .modal-close {
      width: 28px;
      height: 28px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: var(--dark-elevated);
      border: none;
      border-radius: 4px;
      color: var(--text-muted);
      cursor: pointer;
      font-size: 18px;
    }

    .modal-close:hover {
      background: var(--dark-hover);
      color: var(--text);
    }

    /* Hide close button on required modals */
    .modal-overlay[data-required="true"] .modal-close {
      display: none;
    }

    /* Login Modal Styles */
    .login-modal {
      max-width: 440px !important;
      padding: 32px !important;
    }

    .google-signin-btn {
      width: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 12px;
      padding: 14px 20px;
      background: #fff;
      border: 1px solid #dadce0;
      border-radius: 8px;
      font-size: 15px;
      font-weight: 500;
      color: #3c4043;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .google-signin-btn:hover {
      background: #f8f9fa;
      border-color: #c6c6c6;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    }

    .login-divider {
      display: flex;
      align-items: center;
      margin: 24px 0;
      color: var(--text-muted);
      font-size: 13px;
    }

    .login-divider::before,
    .login-divider::after {
      content: '';
      flex: 1;
      height: 1px;
      background: var(--border);
    }

    .login-divider span {
      padding: 0 16px;
    }

    /* Sign In Button - Clean & Modern */
    .btn-signin {
      position: relative;
      width: 100%;
      height: 50px;
      background: linear-gradient(135deg, var(--gold) 0%, #c9a227 100%);
      border: none;
      border-radius: 8px;
      color: #000;
      font-size: 15px;
      font-weight: 600;
      cursor: pointer;
      overflow: hidden;
      margin-bottom: 16px;
      transition: all 0.2s ease;
    }

    .btn-signin:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(212, 175, 55, 0.4);
    }

    .btn-signin:active {
      transform: translateY(0);
    }

    .btn-signin:disabled {
      opacity: 0.7;
      cursor: not-allowed;
      transform: none;
    }

    .btn-signin-text {
      transition: opacity 0.2s ease;
    }

    .btn-signin.loading .btn-signin-text {
      opacity: 0;
    }

    .btn-signin-loader {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 20px;
      height: 20px;
      margin: -10px 0 0 -10px;
      border: 2px solid rgba(0, 0, 0, 0.2);
      border-top-color: #000;
      border-radius: 50%;
      opacity: 0;
      transition: opacity 0.2s ease;
    }

    .btn-signin.loading .btn-signin-loader {
      opacity: 1;
      animation: spinBtn 0.6s linear infinite;
    }

    @keyframes spinBtn {
      to { transform: rotate(360deg); }
    }

    /* Material Picker Modal */
    .material-categories {
      display: flex;
      gap: 8px;
      margin-bottom: 16px;
      flex-wrap: wrap;
    }

    .material-category-btn {
      padding: 6px 12px;
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      border-radius: 4px;
      color: var(--text-secondary);
      font-size: 11px;
      cursor: pointer;
    }

    .material-category-btn:hover {
      border-color: var(--primary);
    }

    .material-category-btn.active {
      background: var(--primary);
      border-color: var(--primary);
      color: white;
    }

    .materials-modal-grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 10px;
    }

    .material-modal-item {
      aspect-ratio: 1;
      border-radius: 8px;
      cursor: pointer;
      border: 2px solid transparent;
      background-size: cover;
      background-position: center;
      position: relative;
      overflow: hidden;
    }

    .material-modal-item:hover {
      border-color: var(--primary);
    }

    .material-modal-item.selected {
      border-color: var(--gold);
    }

    .material-modal-item .material-name {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.8);
      padding: 4px 6px;
      font-size: 9px;
      text-align: center;
    }

    .material-modal-item .material-price {
      position: absolute;
      top: 4px;
      right: 4px;
      padding: 2px 6px;
      border-radius: 4px;
      font-size: 8px;
      font-weight: 600;
      color: white;
      text-shadow: 0 1px 2px rgba(0,0,0,0.3);
    }

    .material-modal-item .material-brand {
      position: absolute;
      top: 4px;
      left: 4px;
      padding: 2px 5px;
      border-radius: 3px;
      font-size: 7px;
      font-weight: 500;
      background: rgba(0,0,0,0.7);
      color: white;
    }

    .material-modal-item.daltile-material {
      border: 1px solid rgba(99, 102, 241, 0.3);
    }

    .material-modal-item.daltile-material:hover {
      border-color: var(--primary);
      box-shadow: 0 0 0 2px rgba(99, 102, 241, 0.2);
    }

    .upload-material-btn {
      aspect-ratio: 1;
      border-radius: 8px;
      border: 2px dashed var(--border);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      color: var(--text-muted);
      gap: 4px;
    }

    .upload-material-btn:hover {
      border-color: var(--primary);
      color: var(--primary);
    }

    .upload-material-btn svg {
      width: 24px;
      height: 24px;
    }

    .upload-material-btn span {
      font-size: 9px;
    }

    /* Share Modal */
    .share-link-box {
      display: flex;
      gap: 8px;
      margin-bottom: 16px;
    }

    .share-link-input {
      flex: 1;
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 10px 12px;
      color: var(--text);
      font-size: 12px;
    }

    .permission-options {
      display: flex;
      gap: 8px;
      margin-bottom: 16px;
    }

    .permission-btn {
      flex: 1;
      padding: 10px;
      background: var(--dark-elevated);
      border: 2px solid var(--border);
      border-radius: 6px;
      color: var(--text-secondary);
      cursor: pointer;
      text-align: center;
    }

    .permission-btn:hover {
      border-color: var(--primary);
    }

    .permission-btn.active {
      border-color: var(--primary);
      background: rgba(99, 102, 241, 0.1);
      color: var(--text);
    }

    .permission-btn-title {
      font-size: 12px;
      font-weight: 600;
      margin-bottom: 2px;
    }

    .permission-btn-desc {
      font-size: 10px;
      color: var(--text-muted);
    }

    /* Enhanced Share Modal */
    .share-status {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 12px;
      font-size: 12px;
      color: var(--text-secondary);
    }

    .share-status .status-indicator {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--text-muted);
    }

    .permission-section h4 {
      font-size: 12px;
      margin-bottom: 12px;
      color: var(--text-secondary);
    }

    #shareModal .permission-options {
      flex-direction: column;
    }

    #shareModal .permission-btn {
      display: flex;
      align-items: center;
      gap: 12px;
      text-align: left;
    }

    .permission-icon {
      width: 36px;
      height: 36px;
      min-width: 36px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: var(--dark-hover);
      border-radius: 8px;
    }

    .permission-icon svg {
      width: 18px;
      height: 18px;
      stroke: var(--text-secondary);
    }

    .permission-info {
      flex: 1;
    }

    .share-actions {
      margin-top: 16px;
    }

    .active-shares {
      margin-top: 20px;
      padding-top: 16px;
      border-top: 1px solid var(--border);
    }

    .active-shares h4,
    .recent-activity h4 {
      font-size: 12px;
      margin-bottom: 12px;
      color: var(--text-secondary);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .recent-activity {
      margin-top: 16px;
      padding-top: 16px;
      border-top: 1px solid var(--border);
    }

    .activity-list {
      max-height: 200px;
      overflow-y: auto;
    }

    .activity-item {
      display: flex;
      align-items: flex-start;
      gap: 10px;
      padding: 10px;
      background: var(--dark-elevated);
      border-radius: 6px;
      margin-bottom: 6px;
      font-size: 12px;
    }

    .activity-icon {
      width: 28px;
      height: 28px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      flex-shrink: 0;
    }

    .activity-icon.view { background: rgba(99, 102, 241, 0.2); }
    .activity-icon.comment { background: rgba(249, 203, 0, 0.2); }
    .activity-icon.approve { background: rgba(16, 185, 129, 0.2); }
    .activity-icon.reject { background: rgba(239, 68, 68, 0.2); }

    .activity-content {
      flex: 1;
    }

    .activity-text {
      color: var(--text-primary);
      line-height: 1.4;
    }

    .activity-time {
      color: var(--text-muted);
      font-size: 10px;
      margin-top: 2px;
    }

    .share-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px;
      background: var(--dark-elevated);
      border-radius: 6px;
      margin-bottom: 8px;
    }

    .share-info {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .share-permission {
      font-size: 11px;
      font-weight: 500;
    }

    .share-stats {
      font-size: 10px;
      color: var(--text-muted);
    }

    .share-item .share-actions {
      display: flex;
      gap: 8px;
      margin-top: 0;
    }

    .share-item .share-actions button {
      margin-left: 0;
      padding: 6px 12px;
      font-size: 11px;
    }

    /* Pricing Section in Properties */
    .pricing-section {
      margin-top: 16px;
      padding-top: 12px;
      border-top: 1px solid var(--border);
    }

    /* Pricing Locked State */
    .pricing-locked {
      position: relative;
      pointer-events: none;
      opacity: 0.3;
      filter: blur(3px);
    }

    .pricing-locked-overlay {
      background: linear-gradient(135deg, rgba(26,26,46,0.95), rgba(22,33,62,0.95));
      border-radius: 12px;
      padding: 24px;
      margin: 12px;
      text-align: center;
    }

    .pricing-locked-content {
      color: var(--text);
    }

    .pricing-locked-content h4 {
      color: #fff;
      font-size: 16px;
      margin-bottom: 8px;
    }

    .pricing-locked-content p {
      color: var(--text-muted);
      font-size: 13px;
      margin-bottom: 16px;
      line-height: 1.5;
    }

    .pricing-locked-content .btn {
      background: linear-gradient(135deg, #f9cb00 0%, #e6b800 100%);
      color: #1a1a2e;
      border: none;
      padding: 12px 24px;
      font-weight: 600;
    }

    .upgrade-plan-btn {
      position: relative;
      width: 100%;
      padding: 14px 16px;
      border: 1px solid rgba(99, 102, 241, 0.3);
      border-radius: 10px;
      background: rgba(99, 102, 241, 0.1);
      color: #fff;
      cursor: pointer;
      transition: all 0.2s ease;
      text-align: left;
    }

    .upgrade-plan-btn:hover {
      background: rgba(99, 102, 241, 0.2);
      border-color: rgba(99, 102, 241, 0.5);
      transform: translateY(-1px);
    }

    .upgrade-plan-btn:disabled {
      opacity: 0.7;
      cursor: not-allowed;
      transform: none;
    }

    .upgrade-plan-featured {
      border-color: #6366f1;
      background: linear-gradient(135deg, rgba(99, 102, 241, 0.2), rgba(79, 70, 229, 0.25));
    }

    .upgrade-plan-featured:hover {
      background: linear-gradient(135deg, rgba(99, 102, 241, 0.3), rgba(79, 70, 229, 0.35));
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    .property-section-title {
      font-size: 10px;
      font-weight: 600;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 10px;
    }

    .price-override-group {
      display: flex;
      gap: 4px;
    }

    .price-input {
      width: 70px !important;
    }

    .margin-input {
      width: 60px !important;
    }

    .property-select-sm {
      width: 50px;
      padding: 5px 4px;
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      border-radius: 4px;
      color: var(--text);
      font-size: 10px;
    }

    .price-result {
      margin-top: 8px;
      padding-top: 8px;
      border-top: 1px dashed var(--border);
    }

    .price-highlight {
      color: var(--gold);
      font-weight: 600;
    }

    /* Enhanced Quote Panel */
    .quote-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .quote-view-toggle {
      display: flex;
      background: var(--dark-elevated);
      border-radius: 4px;
      padding: 2px;
    }

    .toggle-btn {
      padding: 4px 8px;
      font-size: 10px;
      background: transparent;
      border: none;
      color: var(--text-muted);
      cursor: pointer;
      border-radius: 3px;
      transition: all 0.2s;
    }

    .toggle-btn:hover {
      color: var(--text-secondary);
    }

    .toggle-btn.active {
      background: var(--primary);
      color: white;
    }

    .quote-actions {
      display: flex;
      gap: 6px;
      margin: 10px 0;
    }

    .quote-actions .btn {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 10px;
      padding: 6px 8px;
    }

    .quote-summary {
      margin-top: 10px;
    }

    .quote-row {
      display: flex;
      justify-content: space-between;
      padding: 4px 0;
      font-size: 11px;
      color: var(--text-secondary);
    }

    .margin-badge {
      display: inline-block;
      font-size: 9px;
      background: var(--dark-hover);
      padding: 2px 5px;
      border-radius: 3px;
      margin-left: 6px;
      color: var(--text-muted);
    }

    /* Price List Modal */
    .price-list-tabs {
      display: flex;
      gap: 4px;
      margin-bottom: 16px;
      border-bottom: 1px solid var(--border);
      padding-bottom: 8px;
    }

    .tab-btn {
      padding: 8px 16px;
      background: transparent;
      border: none;
      color: var(--text-muted);
      cursor: pointer;
      font-size: 12px;
      border-radius: 4px;
      transition: all 0.2s;
    }

    .tab-btn:hover {
      color: var(--text-secondary);
      background: var(--dark-elevated);
    }

    .tab-btn.active {
      background: var(--dark-elevated);
      color: var(--text);
    }

    .price-tab {
      min-height: 200px;
    }

    .upload-dropzone {
      border: 2px dashed var(--border);
      border-radius: 8px;
      padding: 40px 20px;
      text-align: center;
      cursor: pointer;
      transition: all 0.2s;
    }

    .upload-dropzone:hover {
      border-color: var(--primary);
      background: rgba(99, 102, 241, 0.05);
    }

    .column-mapping {
      padding: 16px 0;
    }

    .mapping-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
    }

    .mapping-row label {
      font-size: 12px;
      color: var(--text-secondary);
    }

    .mapping-row select {
      width: 200px;
    }

    .mapping-preview {
      margin: 16px 0;
      padding: 12px;
      background: var(--dark-elevated);
      border-radius: 6px;
    }

    .preview-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 11px;
    }

    .preview-table th,
    .preview-table td {
      padding: 8px 6px;
      text-align: left;
      border-bottom: 1px solid var(--border);
    }

    .preview-table th {
      background: var(--dark-hover);
      font-weight: 600;
      font-size: 10px;
      text-transform: uppercase;
    }

    .mapping-actions {
      display: flex;
      justify-content: flex-end;
      gap: 8px;
      margin-top: 16px;
    }

    .saved-lists {
      min-height: 100px;
    }

    .price-list-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: var(--dark-elevated);
      border-radius: 6px;
      margin-bottom: 8px;
    }

    .price-list-name {
      font-weight: 500;
      font-size: 13px;
    }

    .price-list-date {
      font-size: 11px;
      color: var(--text-muted);
    }

    .current-prices-header {
      margin-bottom: 12px;
    }

    .search-input {
      width: 100%;
      padding: 10px 12px;
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      border-radius: 6px;
      color: var(--text);
      font-size: 12px;
    }

    .current-prices-list {
      max-height: 300px;
      overflow-y: auto;
    }

    .price-category-header {
      font-size: 11px;
      font-weight: 600;
      color: var(--text-muted);
      text-transform: uppercase;
      padding: 8px 0 4px;
      margin-top: 8px;
      border-bottom: 1px solid var(--border);
    }

    .current-price-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 4px;
      font-size: 11px;
      border-bottom: 1px solid var(--dark-elevated);
    }

    .price-item-name {
      flex: 1;
    }

    .price-item-sku {
      width: 80px;
      color: var(--text-muted);
      font-size: 10px;
    }

    .price-item-value {
      font-weight: 500;
      color: var(--gold);
    }

    .empty-state {
      text-align: center;
      color: var(--text-muted);
      padding: 20px;
      font-size: 12px;
    }

    /* Labor Category Accordion */
    .labor-categories {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .labor-category {
      background: var(--dark-elevated);
      border-radius: 8px;
      overflow: hidden;
      border: 1px solid var(--border);
    }

    .labor-category-header {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 14px 16px;
      cursor: pointer;
      transition: background 0.2s;
      user-select: none;
    }

    .labor-category-header:hover {
      background: var(--dark-hover);
    }

    .labor-category.expanded .labor-category-header {
      border-bottom: 1px solid var(--border);
      background: var(--dark-hover);
    }

    .category-icon {
      font-size: 16px;
      color: var(--gold);
      width: 24px;
      text-align: center;
    }

    .category-title {
      flex: 1;
      font-weight: 600;
      font-size: 14px;
      color: var(--text);
    }

    .category-toggle {
      font-size: 10px;
      color: var(--text-muted);
      transition: transform 0.2s;
    }

    .labor-category.expanded .category-toggle {
      transform: rotate(180deg);
    }

    .labor-category-items {
      display: none;
      padding: 12px 16px;
      background: rgba(0,0,0,0.2);
    }

    .labor-category.expanded .labor-category-items {
      display: block;
    }

    .labor-item {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 10px 0;
      border-bottom: 1px solid var(--border);
    }

    .labor-item:last-child {
      border-bottom: none;
    }

    .labor-item-label {
      flex: 1;
      font-size: 13px;
      color: var(--text-secondary);
    }

    .labor-item-rate {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .labor-item-rate input {
      width: 80px;
      padding: 6px 8px;
      background: var(--dark-surface);
      border: 1px solid var(--border);
      border-radius: 4px;
      color: var(--text);
      font-size: 13px;
      text-align: right;
    }

    .labor-item-rate input:focus {
      outline: none;
      border-color: var(--gold);
    }

    .labor-item-unit {
      font-size: 11px;
      color: var(--text-muted);
      min-width: 50px;
    }

    /* Material Pricing Section */
    .material-pricing-section {
      background: var(--dark-elevated);
      border-radius: 8px;
      padding: 16px;
      border: 1px solid var(--border);
    }

    .material-price-row {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 10px 0;
      border-bottom: 1px solid var(--border);
    }

    .material-price-row:last-child {
      border-bottom: none;
    }

    .material-price-label {
      flex: 1;
      font-size: 13px;
      color: var(--text-secondary);
    }

    .material-price-inputs {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .material-price-inputs input {
      width: 90px;
      padding: 6px 8px;
      background: var(--dark-surface);
      border: 1px solid var(--border);
      border-radius: 4px;
      color: var(--text);
      font-size: 13px;
      text-align: right;
    }

    .material-price-inputs input:focus {
      outline: none;
      border-color: var(--gold);
    }

    .material-price-inputs span {
      font-size: 11px;
      color: var(--text-muted);
    }

    /* Quote Preview Table */
    .quote-preview-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 13px;
    }

    .quote-preview-table thead {
      position: sticky;
      top: 0;
      background: var(--dark-surface);
      z-index: 1;
    }

    .quote-preview-table th {
      text-align: left;
      padding: 12px 10px;
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
      color: var(--text-muted);
      border-bottom: 2px solid var(--border);
    }

    .quote-preview-table td {
      padding: 10px;
      border-bottom: 1px solid var(--border);
      vertical-align: middle;
    }

    .quote-preview-table tbody tr:hover {
      background: rgba(255, 255, 255, 0.03);
    }

    .quote-preview-table .room-header {
      background: linear-gradient(90deg, rgba(99, 102, 241, 0.1) 0%, transparent 100%);
      font-weight: 600;
      color: var(--primary);
    }

    .quote-preview-table .room-header td {
      padding: 8px 10px;
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      border-bottom: 1px solid rgba(99, 102, 241, 0.3);
    }

    .quote-preview-table .room-subtotal {
      background: rgba(255, 255, 255, 0.02);
    }

    .quote-preview-table .room-subtotal td {
      font-weight: 600;
      font-size: 12px;
      color: var(--text-secondary);
    }

    .quote-item-type-icon {
      width: 24px;
      height: 24px;
      border-radius: 6px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
    }

    .quote-item-type-icon.countertop {
      background: rgba(249, 203, 0, 0.15);
      color: var(--gold);
    }

    .quote-item-type-icon.cabinet {
      background: rgba(16, 185, 129, 0.15);
      color: #34d399;
    }

    .quote-item-type-icon.labor {
      background: rgba(99, 102, 241, 0.15);
      color: #818cf8;
    }

    .quote-item-type-icon.other {
      background: rgba(255, 255, 255, 0.1);
      color: var(--text-muted);
    }

    .quote-editable-input {
      width: 100%;
      padding: 6px 8px;
      background: var(--dark-surface);
      border: 1px solid var(--border);
      border-radius: 4px;
      color: var(--text);
      font-size: 13px;
      text-align: right;
    }

    .quote-editable-input:focus {
      outline: none;
      border-color: var(--gold);
      background: var(--dark-elevated);
    }

    .quote-editable-input.modified {
      border-color: var(--warning);
      background: rgba(245, 158, 11, 0.1);
    }

    .quote-margin-badge {
      display: inline-block;
      padding: 2px 6px;
      background: rgba(16, 185, 129, 0.15);
      color: #34d399;
      border-radius: 4px;
      font-size: 11px;
      font-weight: 600;
    }

    .quote-margin-badge.low {
      background: rgba(239, 68, 68, 0.15);
      color: #ef4444;
    }

    .quote-margin-badge.high {
      background: rgba(16, 185, 129, 0.15);
      color: #34d399;
    }

    /* Room Management */
    .room-list {
      max-height: 300px;
      overflow-y: auto;
    }

    .room-list-item {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px;
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      border-radius: 8px;
      margin-bottom: 8px;
    }

    .room-list-item .room-color {
      width: 16px;
      height: 16px;
      border-radius: 4px;
      flex-shrink: 0;
    }

    .room-list-item .room-name {
      flex: 1;
      font-weight: 500;
    }

    .room-list-item .room-count {
      font-size: 12px;
      color: var(--text-muted);
      padding: 2px 8px;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 10px;
    }

    .room-list-item .room-actions {
      display: flex;
      gap: 4px;
    }

    .room-list-item .room-actions button {
      width: 28px;
      height: 28px;
      padding: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: transparent;
      border: 1px solid var(--border);
      border-radius: 6px;
      color: var(--text-muted);
      cursor: pointer;
      transition: all 0.15s;
    }

    .room-list-item .room-actions button:hover {
      background: var(--dark-hover);
      color: var(--text);
    }

    .room-list-item .room-actions button.delete:hover {
      background: rgba(239, 68, 68, 0.15);
      border-color: rgba(239, 68, 68, 0.3);
      color: #ef4444;
    }

    /* Room color options */
    .room-colors {
      display: flex;
      gap: 6px;
      padding: 8px 0;
    }

    .room-color-option {
      width: 24px;
      height: 24px;
      border-radius: 6px;
      cursor: pointer;
      border: 2px solid transparent;
      transition: transform 0.15s, border-color 0.15s;
    }

    .room-color-option:hover {
      transform: scale(1.1);
    }

    .room-color-option.selected {
      border-color: white;
    }

    /* Margin Modal */
    .margin-section {
      padding: 8px 0;
    }

    .margin-global {
      margin-bottom: 16px;
    }

    .margin-global label {
      display: block;
      font-size: 12px;
      margin-bottom: 6px;
      color: var(--text-secondary);
    }

    .margin-input-group {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .margin-input-group input {
      width: 80px;
    }

    .margin-symbol {
      font-size: 12px;
      color: var(--text-muted);
    }

    .margin-categories h4 {
      font-size: 12px;
      margin-bottom: 12px;
      color: var(--text-secondary);
    }

    .category-margin-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 0;
      border-bottom: 1px solid var(--dark-elevated);
    }

    .category-margin-row span {
      font-size: 12px;
    }

    .modal-footer {
      display: flex;
      justify-content: flex-end;
      gap: 8px;
      margin-top: 20px;
      padding-top: 16px;
      border-top: 1px solid var(--border);
    }

    /* Permission Notice */
    .permission-notice {
      position: fixed;
      top: 60px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 1002;
      animation: slideDown 0.3s ease;
    }

    .notice-content {
      display: flex;
      align-items: center;
      gap: 10px;
      background: var(--dark-surface);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 12px 16px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.3);
      font-size: 12px;
    }

    @keyframes slideDown {
      from { opacity: 0; transform: translateX(-50%) translateY(-10px); }
      to { opacity: 1; transform: translateX(-50%) translateY(0); }
    }

    /* Presentation Mode */
    body.presentation-mode .sidebar,
    body.presentation-mode .right-panel {
      display: none;
    }

    body.presentation-mode .canvas-container {
      width: 100%;
    }

    /* 3D Axis Indicator (Orientation Key) - Glassmorphic */
    .axis-indicator-container {
      position: absolute;
      bottom: 20px;
      left: 20px;
      width: 100px;
      height: 100px;
      z-index: 100;
      pointer-events: none;
      border-radius: 16px;
      background: linear-gradient(135deg,
        rgba(20, 20, 30, 0.92) 0%,
        rgba(15, 15, 25, 0.95) 50%,
        rgba(25, 25, 35, 0.93) 100%);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      border: 1px solid rgba(255, 255, 255, 0.15);
      border-top-color: rgba(255, 255, 255, 0.25);
      border-left-color: rgba(255, 255, 255, 0.2);
      box-shadow:
        0 8px 32px rgba(0, 0, 0, 0.3),
        0 2px 8px rgba(0, 0, 0, 0.2),
        inset 0 1px 1px rgba(255, 255, 255, 0.08),
        inset 0 -1px 1px rgba(0, 0, 0, 0.1);
      overflow: hidden;
    }

    .axis-indicator-container::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 50%;
      background: linear-gradient(180deg,
        rgba(255, 255, 255, 0.04) 0%,
        transparent 100%);
      pointer-events: none;
      border-radius: 16px 16px 0 0;
    }

    .axis-indicator-container canvas {
      width: 100% !important;
      height: 100% !important;
    }

    .axis-label {
      position: absolute;
      font-size: 11px;
      font-weight: 600;
      text-shadow: 0 1px 2px rgba(0,0,0,0.8);
      pointer-events: none;
    }

    .axis-label-x { color: #ff4444; }
    .axis-label-y { color: #44ff44; }
    .axis-label-z { color: #4488ff; }

    @media (max-width: 600px) {
      .axis-indicator-container {
        width: 70px;
        height: 70px;
        bottom: 80px;
        left: 10px;
      }
      .axis-label { font-size: 9px; }
    }

    /* Button danger variant */
    .btn-danger {
      background: var(--error);
      color: white;
    }

    .btn-danger:hover {
      background: #dc2626;
    }

    /* ============================================= */
    /* Minimal Professional Loading Screen */
    /* ============================================= */
    .cloud-preloader {
      position: fixed;
      inset: 0;
      background: #0a0a0a;
      z-index: 99999;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      transition: opacity 0.6s ease, visibility 0.6s ease;
    }

    .cloud-preloader.loaded {
      opacity: 0;
      visibility: hidden;
      pointer-events: none;
    }

    /* Main Content */
    .preloader-content {
      text-align: center;
      opacity: 0;
      animation: contentFadeIn 0.8s ease-out 0.2s forwards;
    }

    @keyframes contentFadeIn {
      0% { opacity: 0; transform: translateY(10px); }
      100% { opacity: 1; transform: translateY(0); }
    }

    /* Company Name */
    .preloader-company {
      font-family: 'Inter', -apple-system, sans-serif;
      font-size: 2.5rem;
      font-weight: 700;
      color: #ffffff;
      margin-bottom: 8px;
      letter-spacing: -0.02em;
    }

    .preloader-tagline {
      font-size: 1rem;
      color: rgba(255,255,255,0.4);
      margin-bottom: 48px;
    }

    /* Loading Bar */
    .preloader-loading {
      width: 200px;
      margin: 0 auto;
    }

    .preloader-bar {
      height: 2px;
      background: rgba(255,255,255,0.1);
      border-radius: 2px;
      overflow: hidden;
    }

    .preloader-bar-fill {
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, #6366f1, #8b5cf6);
      border-radius: 2px;
      transition: width 0.3s ease;
    }

    /* Powered By Badge */
    .preloader-powered {
      position: absolute;
      bottom: 40px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      align-items: center;
      gap: 8px;
      opacity: 0;
      animation: poweredFadeIn 0.6s ease-out 0.8s forwards;
    }

    @keyframes poweredFadeIn {
      0% { opacity: 0; }
      100% { opacity: 1; }
    }

    .preloader-powered-icon {
      width: 20px;
      height: 20px;
    }

    .preloader-powered-icon svg {
      width: 20px;
      height: 20px;
    }

    .preloader-powered-text {
      font-size: 12px;
      color: rgba(255,255,255,0.3);
    }

    .preloader-powered-brand {
      color: rgba(255,255,255,0.5);
      font-weight: 600;
    }

    /* Hide old elements */
    .blueprint-grid,
    .blueprint-corners,
    .preloader-main,
    .room-wireframe,
    .steps-flow,
    .progress-section,
    .designer-section,
    .powered-by-section { display: none !important; }

    .cad-element.countertop {
      display: none;
      width: 240px;
      height: 40px;
      bottom: 60px;
      left: 80px;
      border-color: rgba(249, 203, 0, 0.7);
      animation: elementPlace 0.6s ease-out 2s forwards;
    }

    .cad-element.countertop::before { border-color: rgba(249, 203, 0, 0.5); }

    .cad-element.cabinet {
      width: 80px;
      height: 100px;
      bottom: 60px;
      left: 80px;
      border-color: rgba(139, 92, 246, 0.7);
      animation: elementPlace 0.6s ease-out 2.3s forwards;
    }

    .cad-element.cabinet::before { border-color: rgba(139, 92, 246, 0.5); }

    .cad-element.cabinet-2 {
      width: 80px;
      height: 100px;
      bottom: 60px;
      left: 180px;
      border-color: rgba(139, 92, 246, 0.7);
      animation: elementPlace 0.6s ease-out 2.5s forwards;
    }

    .cad-element.island {
      width: 120px;
      height: 80px;
      bottom: 120px;
      left: 180px;
      border-color: rgba(34, 197, 94, 0.7);
      animation: elementPlace 0.6s ease-out 2.7s forwards;
    }

    .cad-element.island::before { border-color: rgba(34, 197, 94, 0.5); }

    .cad-element.appliance {
      width: 50px;
      height: 50px;
      bottom: 60px;
      right: 80px;
      border-color: rgba(239, 68, 68, 0.7);
      animation: elementPlace 0.6s ease-out 2.9s forwards;
    }

    .cad-element.appliance::before { border-color: rgba(239, 68, 68, 0.5); }

    @keyframes elementPlace {
      0% {
        opacity: 0;
        transform: scale(0.8);
        filter: blur(4px);
      }
      50% {
        opacity: 1;
        border-color: inherit;
        box-shadow: 0 0 20px currentColor;
      }
      100% {
        opacity: 1;
        transform: scale(1);
        filter: blur(0);
        box-shadow: 0 0 10px currentColor;
      }
    }

    /* Node Connection Lines - ReactFlow Style */
    .node-connections {
      position: absolute;
      inset: 0;
      pointer-events: none;
      opacity: 0;
      animation: connectionsFadeIn 0.8s ease-out 3.2s forwards;
    }

    @keyframes connectionsFadeIn {
      0% { opacity: 0; }
      100% { opacity: 1; }
    }

    .connection-line {
      position: absolute;
      background: linear-gradient(90deg, rgba(59, 130, 246, 0.6), rgba(139, 92, 246, 0.6));
      height: 2px;
      transform-origin: left center;
      animation: lineGrow 0.5s ease-out forwards;
    }

    .connection-line::after {
      content: '';
      position: absolute;
      right: -4px;
      top: -3px;
      width: 8px;
      height: 8px;
      background: rgba(139, 92, 246, 0.8);
      border-radius: 50%;
      box-shadow: 0 0 10px rgba(139, 92, 246, 0.6);
    }

    @keyframes lineGrow {
      0% { width: 0; }
      100% { width: 100%; }
    }

    /* Right Side Panel */
    .preloader-panel {
      width: 320px;
      display: flex;
      flex-direction: column;
      gap: 24px;
    }

    /* Brand Section */
    /* Designer/Company Section - Main Focus */
    .designer-section {
      text-align: center;
      opacity: 0;
      animation: designerFadeIn 0.8s ease-out 0.8s forwards;
      margin-bottom: 32px;
    }

    @keyframes designerFadeIn {
      0% { opacity: 0; transform: translateY(-20px); }
      100% { opacity: 1; transform: translateY(0); }
    }

    .designer-label {
      font-size: 11px;
      color: rgba(255,255,255,0.5);
      letter-spacing: 3px;
      text-transform: uppercase;
      margin-bottom: 12px;
    }

    .designer-company {
      font-family: 'Inter', -apple-system, sans-serif;
      font-size: 1.8rem;
      font-weight: 800;
      color: #ffffff;
      margin-bottom: 6px;
      line-height: 1.2;
    }

    .designer-tagline {
      font-size: 13px;
      color: rgba(255,255,255,0.5);
    }

    /* Steps Node Flow */
    .steps-flow {
      display: flex;
      flex-direction: column;
      gap: 0;
      position: relative;
    }

    .step-node {
      display: flex;
      align-items: center;
      gap: 16px;
      padding: 12px 16px;
      background: rgba(255,255,255,0.03);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 12px;
      position: relative;
      opacity: 0;
      transform: translateX(-20px);
      transition: all 0.4s ease;
    }

    .step-node.visible {
      opacity: 1;
      transform: translateX(0);
    }

    .step-node.active {
      background: rgba(66, 133, 244, 0.1);
      border-color: rgba(66, 133, 244, 0.4);
      box-shadow: 0 0 30px rgba(66, 133, 244, 0.2);
    }

    .step-node.completed {
      background: rgba(34, 197, 94, 0.08);
      border-color: rgba(34, 197, 94, 0.2);
    }

    .step-node-icon {
      width: 40px;
      height: 40px;
      border-radius: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      background: rgba(255,255,255,0.05);
      border: 1px solid rgba(255,255,255,0.1);
      transition: all 0.3s ease;
    }

    .step-node.active .step-node-icon {
      background: linear-gradient(135deg, rgba(66, 133, 244, 0.3), rgba(52, 168, 83, 0.3));
      border-color: rgba(66, 133, 244, 0.5);
      box-shadow: 0 0 20px rgba(66, 133, 244, 0.4);
    }

    .step-node.completed .step-node-icon {
      background: rgba(34, 197, 94, 0.2);
      border-color: rgba(34, 197, 94, 0.4);
    }

    .step-node-content {
      flex: 1;
    }

    .step-node-title {
      font-size: 13px;
      font-weight: 600;
      color: rgba(255,255,255,0.9);
      margin-bottom: 2px;
    }

    .step-node-desc {
      font-size: 11px;
      color: rgba(255,255,255,0.4);
    }

    .step-node.active .step-node-title {
      color: #4285F4;
    }

    .step-node.completed .step-node-title {
      color: rgba(34, 197, 94, 0.9);
    }

    /* Connection between nodes */
    .step-connector {
      width: 2px;
      height: 16px;
      background: rgba(255,255,255,0.1);
      margin-left: 35px;
      position: relative;
      overflow: hidden;
    }

    .step-connector::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 0%;
      background: linear-gradient(180deg, rgba(66, 133, 244, 0.6), rgba(52, 168, 83, 0.6));
      transition: height 0.3s ease;
    }

    .step-connector.filled::after {
      height: 100%;
    }

    /* Progress Section */
    .progress-section {
      background: rgba(255,255,255,0.03);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 16px;
      padding: 20px;
      opacity: 0;
      animation: progressFadeIn 0.6s ease-out 1.2s forwards;
    }

    @keyframes progressFadeIn {
      0% { opacity: 0; transform: scale(0.95); }
      100% { opacity: 1; transform: scale(1); }
    }

    .progress-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
    }

    .progress-label {
      font-size: 12px;
      font-weight: 600;
      color: rgba(255,255,255,0.7);
      text-transform: uppercase;
      letter-spacing: 2px;
    }

    .progress-percent {
      font-size: 14px;
      font-weight: 700;
      color: #818cf8;
    }

    .progress-bar-container {
      height: 8px;
      background: rgba(255,255,255,0.1);
      border-radius: 8px;
      overflow: hidden;
    }

    .progress-bar-fill {
      height: 100%;
      background: linear-gradient(90deg, #4285F4, #34A853, #FBBC05, #EA4335);
      border-radius: 8px;
      width: 0%;
      transition: width 0.5s cubic-bezier(0.4, 0, 0.2, 1);
      position: relative;
    }

    .progress-bar-fill::after {
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
      animation: shimmer 1.5s infinite;
    }

    @keyframes shimmer {
      0% { transform: translateX(-100%); }
      100% { transform: translateX(100%); }
    }

    /* Powered By Remodely Badge */
    .powered-by-section {
      position: absolute;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      opacity: 0;
      animation: poweredByFadeIn 0.6s ease-out 1.5s forwards;
    }

    @keyframes poweredByFadeIn {
      0% { opacity: 0; transform: translateX(-50%) translateY(10px); }
      100% { opacity: 1; transform: translateX(-50%) translateY(0); }
    }

    .powered-by-badge {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px 20px;
      background: rgba(255,255,255,0.05);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 50px;
      backdrop-filter: blur(10px);
    }

    .powered-by-icon {
      width: 22px;
      height: 22px;
    }

    .powered-by-icon svg {
      width: 22px;
      height: 22px;
    }

    .powered-by-text {
      display: flex;
      align-items: center;
      gap: 5px;
    }

    .powered-by-label {
      font-size: 11px;
      color: rgba(255,255,255,0.4);
    }

    .powered-by-brand {
      font-size: 12px;
      font-weight: 700;
      color: #ffffff;
    }

    /* Scan Line */
    .scan-line {
      position: absolute;
      left: 0;
      right: 0;
      height: 2px;
      background: linear-gradient(90deg, transparent, rgba(66, 133, 244, 0.6), rgba(52, 168, 83, 0.6), rgba(251, 188, 5, 0.6), transparent);
      box-shadow: 0 0 20px rgba(66, 133, 244, 0.4);
      animation: scanDown 4s ease-in-out infinite;
      pointer-events: none;
    }

    @keyframes scanDown {
      0% { top: -2px; opacity: 0; }
      10% { opacity: 1; }
      90% { opacity: 1; }
      100% { top: 100%; opacity: 0; }
    }

    /* Mobile Responsive */
    @media (max-width: 900px) {
      .preloader-main {
        flex-direction: column;
        gap: 30px;
      }

      .room-wireframe {
        width: 300px;
        height: 220px;
      }

      .preloader-panel {
        width: 100%;
        max-width: 350px;
      }

      .cad-element.countertop { width: 180px; height: 30px; left: 60px; }
      .cad-element.cabinet { width: 60px; height: 75px; left: 60px; }
      .cad-element.cabinet-2 { width: 60px; height: 75px; left: 130px; }
      .cad-element.island { width: 90px; height: 60px; left: 130px; }
    }

    /* Review Room */
    .loading-shared {
      pointer-events: none;
    }

    .loading-shared::after {
      display: none; /* Hide old loading, use cloud preloader instead */
      background: rgba(0,0,0,0.9);
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-size: 18px;
      z-index: 9999;
    }

    .review-room {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      z-index: 1000;
    }

    .review-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 20px;
      background: linear-gradient(135deg, var(--dark-surface) 0%, #1a1a35 100%);
      border-bottom: 1px solid var(--border);
    }

    .review-header-left {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .review-title {
      font-size: 18px;
      font-weight: 600;
      color: var(--gold);
    }

    .review-permission-badge {
      padding: 4px 10px;
      background: var(--primary);
      border-radius: 12px;
      font-size: 11px;
      font-weight: 500;
    }

    /* Live Sync Indicator */
    .live-indicator {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 10px;
      border-radius: 12px;
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      transition: all 0.3s ease;
    }

    .live-indicator.connected {
      background: rgba(34, 197, 94, 0.15);
      color: #22c55e;
      border: 1px solid rgba(34, 197, 94, 0.3);
    }

    .live-indicator.disconnected {
      background: rgba(239, 68, 68, 0.15);
      color: #ef4444;
      border: 1px solid rgba(239, 68, 68, 0.3);
    }

    .live-indicator .live-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      animation: livePulse 2s ease-in-out infinite;
    }

    .live-indicator.connected .live-dot {
      background: #22c55e;
    }

    .live-indicator.disconnected .live-dot {
      background: #ef4444;
      animation: none;
    }

    .live-indicator.flash {
      animation: liveFlash 0.5s ease;
    }

    @keyframes livePulse {
      0%, 100% { opacity: 1; transform: scale(1); }
      50% { opacity: 0.5; transform: scale(0.8); }
    }

    @keyframes liveFlash {
      0% { background: rgba(34, 197, 94, 0.15); }
      50% { background: rgba(34, 197, 94, 0.4); }
      100% { background: rgba(34, 197, 94, 0.15); }
    }

    .review-header-right {
      display: flex;
      gap: 8px;
    }

    .review-panel {
      position: fixed;
      top: 56px;
      right: -380px;
      width: 380px;
      height: calc(100vh - 56px);
      background: var(--dark-surface);
      border-left: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      transition: right 0.3s ease;
      z-index: 999;
    }

    .review-panel.open {
      right: 0;
    }

    .review-panel-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 16px;
      border-bottom: 1px solid var(--border);
    }

    .review-panel-header h3 {
      font-size: 14px;
      font-weight: 600;
    }

    .review-panel-close {
      width: 28px;
      height: 28px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: var(--dark-elevated);
      border: none;
      border-radius: 4px;
      color: var(--text-muted);
      cursor: pointer;
      font-size: 18px;
    }

    .review-summary {
      display: flex;
      padding: 16px;
      gap: 16px;
      background: var(--dark-elevated);
      border-bottom: 1px solid var(--border);
    }

    .review-stat {
      flex: 1;
      text-align: center;
    }

    .stat-value {
      display: block;
      font-size: 20px;
      font-weight: 700;
      color: var(--gold);
    }

    .stat-value.approved {
      color: var(--success);
    }

    .stat-label {
      font-size: 10px;
      color: var(--text-muted);
      text-transform: uppercase;
    }

    .review-elements {
      flex: 1;
      overflow-y: auto;
      padding: 12px;
    }

    .review-element {
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 12px;
      margin-bottom: 8px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .review-element:hover {
      border-color: var(--primary);
    }

    .review-element.approved {
      border-color: var(--success);
      background: rgba(16, 185, 129, 0.1);
    }

    .review-element.rejected {
      border-color: var(--error);
      background: rgba(239, 68, 68, 0.1);
    }

    .review-element-header {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 6px;
    }

    .review-element-status {
      width: 20px;
      height: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 50%;
      font-size: 12px;
      background: var(--dark-hover);
    }

    .review-element-status.approved {
      background: var(--success);
      color: white;
    }

    .review-element-status.rejected {
      background: var(--error);
      color: white;
    }

    .review-element-name {
      flex: 1;
      font-weight: 500;
      font-size: 13px;
    }

    .review-element-price {
      font-weight: 600;
      color: var(--gold);
      font-size: 13px;
    }

    .review-element-details {
      display: flex;
      gap: 12px;
      font-size: 11px;
      color: var(--text-muted);
      margin-bottom: 8px;
    }

    .review-element-material {
      color: var(--text-secondary);
    }

    .review-element-actions {
      display: flex;
      gap: 6px;
      padding-top: 8px;
      border-top: 1px solid var(--border);
    }

    .btn-approve, .btn-reject, .btn-comment {
      flex: 1;
      padding: 6px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      transition: all 0.2s;
    }

    .btn-approve {
      background: rgba(16, 185, 129, 0.2);
      color: var(--success);
    }

    .btn-approve:hover {
      background: var(--success);
      color: white;
    }

    .btn-reject {
      background: rgba(239, 68, 68, 0.2);
      color: var(--error);
    }

    .btn-reject:hover {
      background: var(--error);
      color: white;
    }

    .btn-comment {
      background: var(--dark-hover);
      color: var(--text-secondary);
    }

    .btn-comment:hover {
      background: var(--primary);
      color: white;
    }

    .review-comments-section {
      border-top: 1px solid var(--border);
      padding: 12px;
    }

    .review-comments-section h4 {
      font-size: 12px;
      margin-bottom: 8px;
      color: var(--text-secondary);
    }

    .review-comments {
      max-height: 150px;
      overflow-y: auto;
      margin-bottom: 8px;
    }

    .review-comment {
      background: var(--dark-elevated);
      border-radius: 6px;
      padding: 8px;
      margin-bottom: 6px;
      font-size: 12px;
    }

    .comment-header {
      display: flex;
      gap: 8px;
      margin-bottom: 4px;
      font-size: 10px;
      color: var(--text-muted);
    }

    .comment-author {
      font-weight: 600;
      color: var(--text-secondary);
    }

    .comment-element {
      color: var(--primary);
    }

    .comment-text {
      color: var(--text);
    }

    .review-comment-input {
      display: flex;
      gap: 6px;
    }

    .review-comment-input input {
      flex: 1;
      padding: 8px 10px;
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      border-radius: 6px;
      color: var(--text);
      font-size: 12px;
    }

    .review-actions {
      padding: 12px;
      border-top: 1px solid var(--border);
      display: flex;
      gap: 8px;
    }

    .review-actions .btn {
      flex: 1;
    }

    .btn-success {
      background: var(--success);
      color: white;
    }

    .btn-success:hover {
      background: #059669;
    }

    /* Quote Approval Actions */
    .quote-approval-actions {
      flex-direction: column;
      text-align: center;
      padding: 16px;
    }

    .approval-summary {
      margin-bottom: 12px;
    }

    .approval-note {
      color: var(--text-secondary);
      font-size: 13px;
      margin: 0;
    }

    .approve-pay-btn {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 100%;
      padding: 14px 24px;
      font-size: 16px;
      font-weight: 600;
      background: linear-gradient(135deg, #22c55e, #16a34a);
      border: none;
      border-radius: 8px;
      color: white;
      cursor: pointer;
      transition: all 0.2s;
      box-shadow: 0 4px 12px rgba(34, 197, 94, 0.3);
    }

    .approve-pay-btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 6px 16px rgba(34, 197, 94, 0.4);
      background: linear-gradient(135deg, #16a34a, #15803d);
    }

    .approve-pay-btn:active {
      transform: translateY(0);
    }

    .approve-pay-btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      transform: none;
    }

    .approval-terms {
      color: var(--text-secondary);
      font-size: 11px;
      margin: 12px 0 0 0;
      opacity: 0.8;
    }

    .btn-lg {
      padding: 14px 24px;
      font-size: 16px;
    }

    /* Adjust main content when review room is active */
    body:has(.review-room) .header {
      display: none;
    }

    body:has(.review-room) .main-content {
      padding-top: 56px;
    }

    body:has(.review-room) .sidebar {
      margin-top: 56px;
      height: calc(100vh - 56px);
    }

    body:has(.review-room) .right-panel {
      margin-top: 56px;
      height: calc(100vh - 56px);
    }

    body:has(.review-room) .canvas-container {
      height: calc(100vh - 56px);
    }

    body:has(.review-room) .shortcuts-hint {
      display: none;
    }

    /* Hide editing UI in review mode for non-editors */
    body.review-readonly .sidebar {
      display: none;
    }

    body.review-readonly .right-panel .panel-section:not(#quotePanel) {
      display: none;
    }

    /* View-Only Mode - hide all editing UI */
    body.view-only-mode .sidebar {
      display: none !important;
    }

    body.view-only-mode .main-content {
      margin-left: 0 !important;
    }

    body.view-only-mode .toolbar-btn:not([data-tool="pan"]):not([data-tool="zoom-in"]):not([data-tool="zoom-out"]) {
      display: none !important;
    }

    body.view-only-mode .element-selector,
    body.view-only-mode .item-picker,
    body.view-only-mode #saveDesignBtn,
    body.view-only-mode #shareDesignBtn,
    body.view-only-mode .add-room-btn,
    body.view-only-mode .edit-actions {
      display: none !important;
    }

    body.view-only-mode .right-panel .panel-section:not(#quotePanel) {
      display: none !important;
    }

    /* Viewer Mode Badge */
    .viewer-mode-badge {
      position: fixed;
      top: 12px;
      left: 50%;
      transform: translateX(-50%);
      background: linear-gradient(135deg, #2d3748 0%, #1a202c 100%);
      border: 1px solid var(--accent);
      border-radius: 20px;
      padding: 8px 16px;
      display: flex;
      align-items: center;
      gap: 8px;
      z-index: 10000;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      font-size: 13px;
      color: var(--text-light);
    }

    .viewer-mode-badge .badge-icon {
      font-size: 16px;
    }

    .viewer-mode-badge .badge-text {
      font-weight: 500;
      color: var(--accent);
    }

    .viewer-mode-badge .badge-action {
      background: var(--accent);
      color: #000;
      padding: 4px 10px;
      border-radius: 12px;
      font-size: 11px;
      font-weight: 600;
      margin-left: 4px;
    }

    /* Keyboard Shortcuts - auto-hide after delay */
    .shortcuts-hint {
      position: fixed;
      bottom: 12px;
      right: 12px;
      background: var(--dark-surface);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 8px 12px;
      font-size: 9px;
      color: var(--text-muted);
      display: flex;
      gap: 12px;
      opacity: 1;
      transition: opacity 0.5s ease-out;
      z-index: 100;
    }

    .shortcuts-hint.hidden {
      opacity: 0;
      pointer-events: none;
    }

    .shortcuts-hint:hover {
      opacity: 1 !important;
      pointer-events: auto !important;
    }

    .shortcut {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .shortcut kbd {
      background: var(--dark-elevated);
      padding: 2px 4px;
      border-radius: 3px;
      font-family: inherit;
      font-size: 9px;
    }

    /* Responsive */
    @media (max-width: 1200px) {
      .sidebar { width: 180px; }
      .right-panel { width: 220px; }
    }

    @media (max-width: 900px) {
      .sidebar, .right-panel { display: none; }
      .header { padding: 8px 12px; }
      .header-left { gap: 8px; }
      .logo { height: 28px; }
      .view-toggle { display: none; }
      .canvas-area { margin: 0; }
      .toolbar { padding: 8px; gap: 4px; }
      .tool-btn { width: 36px; height: 36px; }

      /* Mobile bottom toolbar */
      .mobile-toolbar {
        display: flex !important;
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        background: var(--dark-elevated);
        border-top: 1px solid var(--border);
        padding: 8px 16px;
        justify-content: space-around;
        z-index: 1000;
      }

      .canvas-wrapper {
        padding-bottom: 70px; /* Space for mobile toolbar */
      }
    }

    @media (max-width: 600px) {
      .header { height: 48px; }
      .project-name-input { max-width: 120px; font-size: 13px; }
      .btn { padding: 6px 10px; font-size: 12px; }
      .modal { margin: 10px; max-height: calc(100vh - 20px); }
      .modal-header h3 { font-size: 16px; }
      .shortcuts-hint { display: none; }

      /* Stack header actions */
      .header-actions { gap: 4px; }
      .header-actions .btn span { display: none; }
    }

    @media (max-width: 400px) {
      .logo { display: none; }
      .project-name-input { max-width: 100px; }
    }

    /* Mobile toolbar - hidden by default */
    .mobile-toolbar {
      display: none;
    }

    /* Touch-friendly adjustments */
    @media (pointer: coarse) {
      .tool-btn { min-width: 44px; min-height: 44px; }
      .btn { min-height: 44px; }
      .element-item { min-height: 60px; }
      .property-row input, .property-row select { min-height: 40px; }
    }

    /* Loading overlay */
    .loading-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.7);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10001;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.2s, visibility 0.2s;
    }

    .loading-overlay.active {
      opacity: 1;
      visibility: visible;
    }

    .loading-spinner {
      width: 48px;
      height: 48px;
      border: 4px solid var(--border);
      border-top-color: var(--gold);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    .loading-text {
      color: var(--text);
      margin-top: 16px;
      font-size: 14px;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    /* Auto-save Indicator */
    .autosave-indicator {
      position: fixed;
      top: 70px;
      right: 20px;
      background: rgba(40, 167, 69, 0.9);
      color: white;
      padding: 8px 14px;
      border-radius: 6px;
      font-size: 12px;
      font-weight: 500;
      display: flex;
      align-items: center;
      gap: 6px;
      z-index: 9999;
      opacity: 0;
      transform: translateX(20px);
      transition: opacity 0.3s, transform 0.3s;
      pointer-events: none;
    }

    .autosave-indicator.show {
      opacity: 1;
      transform: translateX(0);
    }

    .autosave-indicator svg {
      width: 14px;
      height: 14px;
    }

    @media (max-width: 600px) {
      .autosave-indicator {
        top: 56px;
        right: 10px;
        padding: 6px 10px;
        font-size: 11px;
      }
    }

    /* Toast Notifications */
    .toast-container {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 10000;
      display: flex;
      flex-direction: column;
      gap: 10px;
      pointer-events: none;
    }

    .toast {
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 12px 20px;
      color: var(--text-primary);
      font-size: 14px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
      animation: toastIn 0.3s ease, toastOut 0.3s ease 2.7s forwards;
      pointer-events: auto;
    }

    .toast.success {
      border-color: #34A853;
      background: linear-gradient(135deg, rgba(52, 168, 83, 0.15), var(--dark-elevated));
    }

    .toast.error {
      border-color: #EA4335;
      background: linear-gradient(135deg, rgba(234, 67, 53, 0.15), var(--dark-elevated));
    }

    .toast.warning {
      border-color: #FBBC05;
      background: linear-gradient(135deg, rgba(251, 188, 5, 0.15), var(--dark-elevated));
    }

    .toast.info {
      border-color: #4285F4;
      background: linear-gradient(135deg, rgba(66, 133, 244, 0.15), var(--dark-elevated));
    }

    @keyframes toastIn {
      from { opacity: 0; transform: translateY(20px); }
      to { opacity: 1; transform: translateY(0); }
    }

    @keyframes toastOut {
      from { opacity: 1; transform: translateY(0); }
      to { opacity: 0; transform: translateY(-20px); }
    }

    /* ===== MY DESIGNS MODAL ===== */
    .designs-tabs {
      display: flex;
      gap: 4px;
      padding: 0 0 16px 0;
      border-bottom: 1px solid var(--border-color);
      margin-bottom: 16px;
    }

    .designs-tab {
      padding: 10px 20px;
      background: transparent;
      border: none;
      color: var(--text-secondary);
      font-size: 14px;
      cursor: pointer;
      border-radius: 8px;
      transition: all 0.2s;
    }

    .designs-tab:hover {
      background: var(--dark-hover);
      color: var(--text-primary);
    }

    .designs-tab.active {
      background: var(--accent-color);
      color: white;
    }

    .designs-search {
      position: relative;
      margin-bottom: 16px;
    }

    .designs-search input {
      width: 100%;
      padding: 12px 16px 12px 44px;
      background: var(--dark-hover);
      border: 1px solid var(--border-color);
      border-radius: 10px;
      color: var(--text-primary);
      font-size: 14px;
    }

    .designs-search svg {
      position: absolute;
      left: 14px;
      top: 50%;
      transform: translateY(-50%);
      width: 18px;
      height: 18px;
      stroke: var(--text-muted);
    }

    .designs-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
      gap: 16px;
      max-height: 50vh;
      overflow-y: auto;
      padding: 4px 8px 8px 4px; /* Top/left for hover, right for scrollbar, bottom for shadow */
    }

    .design-card {
      background: var(--dark-hover);
      border: 1px solid var(--border-color);
      border-radius: 12px;
      overflow: hidden;
      cursor: pointer;
      transition: all 0.2s;
    }

    .design-card:hover {
      border-color: var(--accent-color);
      transform: scale(1.02);
      box-shadow: 0 8px 24px rgba(0,0,0,0.3);
      z-index: 10;
      position: relative;
    }

    .design-card-preview {
      height: 140px;
      background: var(--panel-bg);
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      overflow: hidden;
    }

    .design-card-preview img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .design-card-preview svg {
      width: 48px;
      height: 48px;
      stroke: var(--text-muted);
    }

    .design-card-badge {
      position: absolute;
      top: 8px;
      right: 8px;
      padding: 4px 8px;
      background: rgba(0,0,0,0.6);
      backdrop-filter: blur(4px);
      border-radius: 4px;
      font-size: 10px;
      color: white;
      text-transform: uppercase;
    }

    .design-card-info {
      padding: 12px;
    }

    .design-card-name {
      font-weight: 600;
      color: var(--text-primary);
      margin-bottom: 4px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .design-card-meta {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 12px;
      color: var(--text-muted);
    }

    .design-card-date {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .design-card-comments {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .design-card-delete {
      position: absolute;
      top: 8px;
      right: 8px;
      width: 32px;
      height: 32px;
      border-radius: 50%;
      background: rgba(239, 68, 68, 0.9);
      border: none;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0;
      transition: opacity 0.2s, transform 0.2s;
      z-index: 10;
    }

    .design-card-delete svg {
      stroke: white;
    }

    .design-card:hover .design-card-delete {
      opacity: 1;
    }

    .design-card-delete:hover {
      background: rgba(220, 38, 38, 1);
      transform: scale(1.1);
    }

    .design-card-badge.local {
      background: #6B7280;
    }

    .design-card-badge.cloud {
      background: #3B82F6;
    }

    .design-card-badge.shared {
      background: #10B981;
    }

    .design-card-details {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      font-size: 11px;
      color: var(--text-muted);
      margin-bottom: 4px;
    }

    .design-card-details span {
      display: flex;
      align-items: center;
      gap: 3px;
    }

    .design-card-room-type svg {
      width: 12px;
      height: 12px;
    }

    .design-card-dims {
      background: var(--panel-bg);
      padding: 2px 6px;
      border-radius: 4px;
    }

    .design-card-elements {
      color: var(--accent-gold);
    }

    .design-card-name {
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 100%;
    }

    .designs-loading, .designs-empty {
      text-align: center;
      padding: 40px;
      color: var(--text-muted);
    }

    .designs-empty svg {
      width: 64px;
      height: 64px;
      margin-bottom: 16px;
      stroke: var(--text-muted);
    }

    .designs-empty p {
      margin-bottom: 16px;
      font-size: 16px;
    }

    /* Notification Toast */
    .notification-toast {
      position: fixed;
      top: 20px;
      right: 20px;
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 16px 20px;
      background: rgba(30, 30, 40, 0.95);
      backdrop-filter: blur(20px);
      border: 1px solid var(--border-color);
      border-radius: 12px;
      box-shadow: 0 8px 32px rgba(0,0,0,0.4);
      z-index: 10000;
      transform: translateX(calc(100% + 40px));
      transition: transform 0.3s ease;
      max-width: 360px;
    }

    .notification-toast.show {
      transform: translateX(0);
    }

    .notification-icon {
      width: 40px;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: var(--accent-color);
      border-radius: 10px;
      flex-shrink: 0;
    }

    .notification-icon svg {
      width: 20px;
      height: 20px;
      stroke: white;
    }

    .notification-content {
      flex: 1;
      min-width: 0;
    }

    .notification-title {
      font-weight: 600;
      color: var(--text-primary);
      font-size: 14px;
      margin-bottom: 2px;
    }

    .notification-body {
      font-size: 13px;
      color: var(--text-secondary);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .notification-close {
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: transparent;
      border: none;
      color: var(--text-muted);
      cursor: pointer;
      font-size: 18px;
      border-radius: 4px;
    }

    .notification-close:hover {
      background: var(--dark-hover);
      color: var(--text-primary);
    }

    /* Comment Notification Toast - appears when customer comments */
    .comment-notification-toast {
      position: fixed !important;
      top: 80px !important;
      right: 20px !important;
      display: flex !important;
      align-items: center;
      gap: 12px;
      padding: 14px 18px;
      background: #2a2040;
      background: linear-gradient(135deg, rgba(139, 92, 246, 0.3), rgba(59, 130, 246, 0.2));
      backdrop-filter: blur(20px);
      border: 2px solid rgba(139, 92, 246, 0.6);
      border-radius: 12px;
      box-shadow: 0 8px 32px rgba(139, 92, 246, 0.4), 0 0 0 1px rgba(255,255,255,0.1);
      z-index: 999999 !important;
      cursor: pointer;
      max-width: 380px;
      min-width: 280px;
      animation: commentSlideIn 0.4s ease-out;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
      color: white;
    }

    .comment-notification-toast:hover {
      transform: translateX(-4px) scale(1.02);
      box-shadow: 0 12px 40px rgba(139, 92, 246, 0.35), 0 0 0 1px rgba(255,255,255,0.1);
    }

    .comment-notification-toast.fade-out {
      animation: commentSlideOut 0.3s ease-in forwards;
    }

    @keyframes commentSlideIn {
      from {
        opacity: 0;
        transform: translateX(100px);
      }
      to {
        opacity: 1;
        transform: translateX(0);
      }
    }

    @keyframes commentSlideOut {
      from {
        opacity: 1;
        transform: translateX(0);
      }
      to {
        opacity: 0;
        transform: translateX(100px);
      }
    }

    .comment-notification-icon {
      font-size: 24px;
      animation: commentBounce 0.6s ease-out;
    }

    @keyframes commentBounce {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.2); }
    }

    .comment-notification-content {
      flex: 1;
      min-width: 0;
    }

    .comment-notification-title {
      font-weight: 600;
      font-size: 13px;
      color: var(--primary-color);
      margin-bottom: 4px;
    }

    .comment-notification-message {
      font-size: 12px;
      color: var(--text-secondary);
      line-height: 1.4;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .comment-notification-action {
      font-size: 12px;
      font-weight: 600;
      color: var(--accent-color);
      padding: 4px 8px;
      background: rgba(249, 203, 0, 0.15);
      border-radius: 6px;
      white-space: nowrap;
    }

    /* Messages Section Styles */
    #messagesSection {
      background: rgba(139, 92, 246, 0.08);
      border: 1px solid rgba(139, 92, 246, 0.3);
      border-radius: 8px;
      margin: 8px;
    }

    #messagesSection .panel-title {
      color: #a78bfa;
      margin-bottom: 0;
      padding: 10px 12px;
      border-bottom: 1px solid rgba(139, 92, 246, 0.2);
    }

    .messages-panel-content {
      padding: 10px 12px;
    }

    .message-badge.has-messages {
      display: inline-block !important;
      animation: badgePulse 2s infinite;
    }

    @keyframes badgePulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.1); }
    }

    .customer-message {
      padding: 8px 10px;
      margin: 6px 0;
      border-radius: 6px;
      font-size: 11px;
      line-height: 1.4;
    }

    .customer-message.inbound {
      background: rgba(139, 92, 246, 0.15);
      border-left: 3px solid #8b5cf6;
      margin-right: 15px;
    }

    .customer-message.outbound {
      background: rgba(16, 185, 129, 0.15);
      border-left: 3px solid #10b981;
      margin-left: 15px;
    }

    .customer-message-header {
      display: flex;
      justify-content: space-between;
      margin-bottom: 4px;
      font-size: 9px;
      color: var(--text-muted);
    }

    .customer-message-author {
      font-weight: 600;
      color: #a78bfa;
    }

    .customer-message-text {
      color: var(--text-primary);
    }

    .customer-message-input {
      display: flex;
      gap: 8px;
      margin-top: 8px;
    }

    .customer-message-input input {
      flex: 1;
      padding: 8px 12px;
      border: 1px solid rgba(139, 92, 246, 0.3);
      border-radius: 6px;
      background: var(--dark-elevated);
      color: var(--text);
      font-size: 11px;
    }

    .customer-message-input input:focus {
      outline: none;
      border-color: #8b5cf6;
    }

    .customer-message-input .btn {
      padding: 8px 14px;
      font-size: 9px;
    }
  </style>
</head>
<body>
  <!-- Minimal Loading Screen -->
  <div class="cloud-preloader" id="cloudPreloader">
    <!-- Main Content -->
    <div class="preloader-content">
      <div class="preloader-company" id="preloaderCompanyMain">Surprise Granite</div>
      <div class="preloader-tagline">Room Designer</div>
      <div class="preloader-loading">
        <div class="preloader-bar">
          <div class="preloader-bar-fill" id="preloaderProgressBar"></div>
        </div>
      </div>
    </div>

    <!-- Powered By -->
    <div class="preloader-powered">
      <div class="preloader-powered-icon">
        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" fill="none">
          <defs>
            <linearGradient id="remodelyGradient" x1="0%" y1="0%" x2="100%" y2="100%">
              <stop offset="0%" style="stop-color:#6366f1"/>
              <stop offset="100%" style="stop-color:#8b5cf6"/>
            </linearGradient>
          </defs>
          <path d="M3 21V10l9-7 9 7v11" stroke="url(#remodelyGradient)" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"/>
          <path d="M21 21h-7" stroke="#8b5cf6" stroke-width="2.5" stroke-linecap="round"/>
        </svg>
      </div>
      <div class="preloader-powered-text">Powered by <span class="preloader-powered-brand">Remodely.ai</span></div>
    </div>
  </div>
  <div class="app">
    <!-- Header -->
    <header class="header">
      <div class="header-left">
        <div class="logo-group">
          <a href="/" class="logo">
            <img src="https://cdn.prod.website-files.com/6456ce4476abb25581fbad0c/6456ce4476abb269c6fbb176_Surprise-Granite-favicon-32x32px.png" alt="Surprise Granite">
          </a>
        </div>
        <input type="text" class="project-input" id="projectName" value="Untitled Project" placeholder="Project name">
      </div>

      <div class="header-center">
        <button class="view-btn active" id="view2D" onclick="setView('2d')">2D Plan</button>
        <button class="view-btn" id="view3D" onclick="setView('3d')">3D View</button>
        <div class="header-zoom-controls">
          <button class="header-zoom-btn" onclick="zoomOut()" title="Zoom Out (-)"></button>
          <span class="header-zoom-level" id="zoomLevel" onclick="resetZoom()" title="Click to reset to 100%">100%</span>
          <button class="header-zoom-btn" onclick="zoomIn()" title="Zoom In (+)">+</button>
        </div>
      </div>

      <div class="header-right">
        <!-- User Account Menu -->
        <div class="user-account-menu" id="userAccountMenu">
          <button class="user-menu-btn" id="userMenuBtn" onclick="toggleUserMenu()">
            <div class="user-avatar-small" id="userAvatarSmall">?</div>
            <span class="user-name-display" id="userNameDisplay">Sign In</span>
            <svg width="10" height="10" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <polyline points="6 9 12 15 18 9"/>
            </svg>
          </button>
          <div class="user-dropdown" id="userDropdown">
            <!-- Logged out state -->
            <div id="loggedOutMenu">
              <button class="dropdown-item google-signin" onclick="handleGoogleSignIn()">
                <svg width="16" height="16" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                  <path fill="#4285F4" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"/>
                  <path fill="#34A853" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/>
                  <path fill="#FBBC05" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/>
                  <path fill="#EA4335" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/>
                </svg>
                Sign in with Google
              </button>
              <button class="dropdown-item" onclick="showLoginPrompt('Sign in to save and share your designs')">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M15 3h4a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2h-4"/>
                  <polyline points="10 17 15 12 10 7"/>
                  <line x1="15" y1="12" x2="3" y2="12"/>
                </svg>
                Sign In with Email
              </button>
              <button class="dropdown-item" onclick="continueAsGuest(); closeUserMenu();">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"/>
                  <circle cx="12" cy="7" r="4"/>
                </svg>
                Continue as Guest
              </button>
            </div>
            <!-- Logged in state -->
            <div id="loggedInMenu" style="display: none;">
              <a href="/account/" class="dropdown-item">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"/>
                  <circle cx="12" cy="7" r="4"/>
                </svg>
                My Account
              </a>
              <a href="/account/?page=my-designs" class="dropdown-item">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>
                  <line x1="3" y1="9" x2="21" y2="9"/>
                  <line x1="9" y1="21" x2="9" y2="9"/>
                </svg>
                My Designs
              </a>
              <a href="/account/?page=tools" class="dropdown-item">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M14.7 6.3a1 1 0 0 0 0 1.4l1.6 1.6a1 1 0 0 0 1.4 0l3.77-3.77a6 6 0 0 1-7.94 7.94l-6.91 6.91a2.12 2.12 0 0 1-3-3l6.91-6.91a6 6 0 0 1 7.94-7.94l-3.76 3.76z"/>
                </svg>
                All Tools
              </a>
              <button id="manageSubscriptionBtn" class="dropdown-item" onclick="openBillingPortal()" style="display: none;">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <rect x="1" y="4" width="22" height="16" rx="2" ry="2"/>
                  <line x1="1" y1="10" x2="23" y2="10"/>
                </svg>
                Manage Subscription
              </button>
              <div class="dropdown-divider"></div>
              <button class="dropdown-item logout-item" onclick="handleLogout()">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4"/>
                  <polyline points="16 17 21 12 16 7"/>
                  <line x1="21" y1="12" x2="9" y2="12"/>
                </svg>
                Sign Out
              </button>
            </div>
          </div>
        </div>

        <!-- Save Design Button -->
        <button class="btn btn-primary" id="saveDesignBtn" onclick="saveDesignToCloud()" style="background: #10B981; border-color: #10B981;">
          <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M19 21H5a2 2 0 01-2-2V5a2 2 0 012-2h11l5 5v11a2 2 0 01-2 2z"/>
            <polyline points="17 21 17 13 7 13 7 21"/>
            <polyline points="7 3 7 8 15 8"/>
          </svg>
          <span id="saveDesignText">Save</span>
        </button>

        <button class="btn btn-secondary" onclick="openMyDesignsModal()">
          <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M3 7v10a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-6l-2-2H5a2 2 0 00-2 2z"/>
          </svg>
          My Designs
        </button>

        <button class="btn btn-secondary" onclick="openShareModal()">
          <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M4 12v8a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-8"/>
            <polyline points="16,6 12,2 8,6"/>
            <line x1="12" y1="2" x2="12" y2="15"/>
          </svg>
          Share
        </button>

        <div class="export-dropdown">
          <button class="btn btn-secondary" onclick="toggleExportMenu()">
            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
              <polyline points="7 10 12 15 17 10"/>
              <line x1="12" y1="15" x2="12" y2="3"/>
            </svg>
            Export
            <svg width="10" height="10" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="margin-left: 4px;">
              <polyline points="6 9 12 15 18 9"/>
            </svg>
          </button>
          <div class="export-menu" id="exportMenu">
            <button onclick="exportToPDF()">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
                <polyline points="14,2 14,8 20,8"/>
                <line x1="16" y1="13" x2="8" y2="13"/>
                <line x1="16" y1="17" x2="8" y2="17"/>
              </svg>
              PDF Proposal
            </button>
            <button onclick="exportToJSON()">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
                <polyline points="14,2 14,8 20,8"/>
                <line x1="9" y1="15" x2="15" y2="15"/>
              </svg>
              Save Design (JSON)
            </button>
            <button onclick="exportToPNG()">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>
                <circle cx="8.5" cy="8.5" r="1.5"/>
                <polyline points="21,15 16,10 5,21"/>
              </svg>
              Export Image (PNG)
            </button>
            <button onclick="exportToCSV()">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
                <polyline points="14,2 14,8 20,8"/>
                <line x1="8" y1="13" x2="16" y2="13"/>
                <line x1="8" y1="17" x2="16" y2="17"/>
                <line x1="12" y1="9" x2="12" y2="21"/>
              </svg>
              Parts List (CSV)
            </button>
            <div class="export-divider"></div>
            <button onclick="importFromJSON()">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                <polyline points="17 8 12 3 7 8"/>
                <line x1="12" y1="3" x2="12" y2="15"/>
              </svg>
              Load Design (JSON)
            </button>
          </div>
        </div>

        <button class="btn btn-primary" onclick="generateTakeoffReport()">
          <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2"/>
            <rect x="9" y="3" width="6" height="4" rx="1"/>
            <path d="M9 12h6M9 16h6"/>
          </svg>
          Get Takeoffs
        </button>
      </div>
    </header>

    <!-- Main Content -->
    <main class="main">
      <!-- Left Sidebar -->
      <aside class="sidebar">
        <!-- Multi-Room Manager -->
        <div class="sidebar-section" data-tutorial="rooms">
          <div class="sidebar-header" onclick="toggleSection(this)">
            <span class="sidebar-title">Rooms</span>
            <span class="sidebar-toggle"></span>
          </div>
          <div class="sidebar-content">
            <div id="roomList" class="room-list">
              <!-- Room list will be rendered here -->
            </div>
            <button class="btn btn-primary btn-sm" onclick="showAddRoomModal()" style="width: 100%; margin-top: 8px;">
              + Add Room
            </button>
            <div style="margin-top: 8px; display: flex; gap: 4px;">
              <button class="btn btn-secondary btn-sm" onclick="viewAllRooms3D()" style="flex: 1; font-size: 10px;" title="View all rooms in 3D">
                 View All
              </button>
              <button class="btn btn-secondary btn-sm" onclick="exportMultiRoomLayout()" style="flex: 1; font-size: 10px;" title="Export layout">
                 Export
              </button>
            </div>
          </div>
        </div>

        <!-- Floor Plans -->
        <div class="sidebar-section">
          <div class="sidebar-header" onclick="toggleSection(this)" title="Choose a room layout">
            <span class="sidebar-title">Floor Plans</span>
            <span class="sidebar-toggle"></span>
          </div>
          <div class="sidebar-content">
            <div class="floorplan-grid" id="floorplanGrid">
              <!-- Floor plans will be rendered here -->
            </div>
          </div>
        </div>

        <!-- Tools -->
        <div class="sidebar-section">
          <div class="sidebar-header" onclick="toggleSection(this)" title="Draw & edit tools">
            <span class="sidebar-title">Tools</span>
            <span class="sidebar-toggle"></span>
          </div>
          <div class="sidebar-content">
            <div class="tool-grid" role="toolbar" aria-label="Design tools">
              <button class="tool-btn active" id="toolSelect" onclick="setTool('select')" title="Select (V)" data-shortcut="V" aria-label="Select tool, keyboard shortcut V" aria-pressed="true">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
                  <path d="M3 3l7.07 16.97 2.51-7.39 7.39-2.51L3 3z"/>
                </svg>
                <span>Select</span>
              </button>
              <button class="tool-btn" id="toolWall" onclick="setTool('wall')" title="Draw Wall (W)" data-shortcut="W" aria-label="Draw wall tool, keyboard shortcut W" aria-pressed="false">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
                  <rect x="3" y="3" width="18" height="18" rx="2"/>
                </svg>
                <span>Wall</span>
              </button>
              <button class="tool-btn" id="toolCountertop" onclick="setTool('countertop')" title="Draw Countertop (C)" data-shortcut="C" aria-label="Draw countertop tool, keyboard shortcut C" aria-pressed="false">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
                  <rect x="2" y="8" width="20" height="4" rx="1"/>
                  <rect x="4" y="12" width="16" height="8" fill="none"/>
                </svg>
                <span>Counter</span>
              </button>
              <button class="tool-btn" id="toolPan" onclick="setTool('pan')" title="Pan (H)" data-shortcut="H" aria-label="Pan and scroll tool, keyboard shortcut H" aria-pressed="false">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
                  <path d="M18 11V6a2 2 0 0 0-2-2a2 2 0 0 0-2 2"/>
                  <path d="M14 10V4a2 2 0 0 0-2-2a2 2 0 0 0-2 2v2"/>
                  <path d="M10 10.5V6a2 2 0 0 0-2-2a2 2 0 0 0-2 2v8"/>
                  <path d="M18 8a2 2 0 1 1 4 0v6a8 8 0 0 1-8 8h-2c-2.8 0-4.5-.86-5.99-2.34l-3.6-3.6a2 2 0 0 1 2.83-2.82L7 15"/>
                </svg>
                <span>Pan</span>
              </button>
              <button class="tool-btn" id="toolMeasure" onclick="setTool('measure')" title="Measure (M)" data-shortcut="M" aria-label="Measure distance tool, keyboard shortcut M" aria-pressed="false">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
                  <path d="M21.3 8.7 8.7 21.3c-1 1-2.5 1-3.4 0l-2.6-2.6c-1-1-1-2.5 0-3.4L15.3 2.7c1-1 2.5-1 3.4 0l2.6 2.6c1 1 1 2.5 0 3.4Z"/>
                </svg>
                <span>Measure</span>
              </button>
              <button class="tool-btn" id="toolAutoCounter" onclick="generateCountertopsOverCabinets()" title="Auto-generate countertops over base cabinets" data-shortcut="T" aria-label="Auto-generate countertops over cabinets, keyboard shortcut T">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
                  <rect x="2" y="6" width="20" height="3" rx="1" fill="currentColor" opacity="0.3"/>
                  <rect x="4" y="9" width="16" height="10" rx="1"/>
                  <path d="M12 2v4M8 4l4-2 4 2"/>
                </svg>
                <span>Auto Top</span>
              </button>
              <button class="tool-btn" id="toolAlign" onclick="showAlignMenu()" title="Align selected elements" data-shortcut="A" aria-label="Align selected elements, keyboard shortcut A" aria-haspopup="true">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
                  <line x1="4" y1="6" x2="20" y2="6"/>
                  <line x1="4" y1="12" x2="20" y2="12"/>
                  <line x1="4" y1="18" x2="20" y2="18"/>
                  <rect x="8" y="4" width="8" height="4" fill="currentColor" opacity="0.3"/>
                  <rect x="6" y="10" width="12" height="4" fill="currentColor" opacity="0.3"/>
                </svg>
                <span>Align</span>
              </button>
              <button class="tool-btn" id="toolLayout" onclick="setTool('layout')" title="Cabinet Layout (L) - Click and drag to create cabinet runs" data-shortcut="L" aria-label="Cabinet layout tool, keyboard shortcut L" aria-pressed="false">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <rect x="2" y="14" width="6" height="8" rx="1"/>
                  <rect x="9" y="14" width="6" height="8" rx="1"/>
                  <rect x="16" y="14" width="6" height="8" rx="1"/>
                  <rect x="2" y="12" width="20" height="2" fill="currentColor" opacity="0.4"/>
                  <path d="M4 10 L12 4 L20 10" stroke-width="1.5"/>
                </svg>
                <span>Layout</span>
              </button>
              <button class="tool-btn" id="toolSlabLayout" onclick="window.SlabLayout && window.SlabLayout.toggle()" title="Slab Layout (S) - Optimize stone slab cutting" data-shortcut="S" aria-label="Slab layout and optimization tool, keyboard shortcut S" aria-pressed="false" style="background: linear-gradient(135deg, #00d4aa 0%, #00b894 100%);">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <rect x="2" y="3" width="20" height="14" rx="1"/>
                  <line x1="8" y1="3" x2="8" y2="17"/>
                  <line x1="14" y1="3" x2="14" y2="17"/>
                  <line x1="2" y1="10" x2="14" y2="10"/>
                  <path d="M16 20h4M18 18v4" stroke-width="1.5" opacity="0.7"/>
                </svg>
                <span>Slab</span>
              </button>
            </div>
          </div>
        </div>

        <!-- Layout Tool Options (shown when layout tool is active) -->
        <div class="layout-options-panel" id="layoutOptionsPanel" style="display: none;">
          <div class="layout-options-header">
            <span> Layout Brush Options</span>
          </div>
          <div class="layout-options-content">
            <div class="layout-option-row">
              <label>Element Type:</label>
              <select id="layoutElementType" onchange="updateLayoutElementType()">
                <optgroup label="Base Cabinets (34.5&quot;H  24&quot;D)">
                  <option value="base-cabinet" selected>Base Cabinet</option>
                  <option value="drawer-base">Drawer Base (4 drawers)</option>
                  <option value="sink-base">Sink Base (false front)</option>
                  <option value="corner-cabinet">Corner Base (36&quot; sq)</option>
                  <option value="lazy-susan">Lazy Susan Corner</option>
                  <option value="blind-corner">Blind Corner Base</option>
                </optgroup>
                <optgroup label="Wall Cabinets (30&quot;H  12&quot;D)">
                  <option value="wall-cabinet">Wall Cabinet</option>
                  <option value="wall-corner">Corner Wall (diagonal)</option>
                </optgroup>
                <optgroup label="Tall Cabinets (84-96&quot;H  24&quot;D)">
                  <option value="tall-cabinet">Tall Pantry</option>
                  <option value="tall-oven">Tall Oven Cabinet</option>
                  <option value="fridge-cabinet">Refrigerator Surround</option>
                </optgroup>
                <optgroup label="Islands &amp; Peninsulas">
                  <option value="island">Kitchen Island</option>
                </optgroup>
                <optgroup label="Walls">
                  <option value="pony-wall">Pony Wall (42&quot;)</option>
                  <option value="pony-wall-bar">Bar Height Wall (42&quot;)</option>
                  <option value="knee-wall">Knee Wall (30&quot;)</option>
                  <option value="wall">Full Wall</option>
                </optgroup>
                <optgroup label="Surfaces">
                  <option value="countertop">Countertop Run</option>
                  <option value="countertop-corner">Corner Countertop</option>
                  <option value="backsplash">Backsplash</option>
                </optgroup>
              </select>
            </div>
            <div class="layout-option-row">
              <label>Depth:</label>
              <select id="layoutDepth" onchange="updateLayoutDepth()">
                <option value="1">12" (Wall Cab)</option>
                <option value="1.5">18"</option>
                <option value="2" selected>24" (Base Cab)</option>
                <option value="2.5">30"</option>
                <option value="3">36" (Island)</option>
              </select>
            </div>
            <div class="layout-option-row">
              <label>Corner Treatment:</label>
              <select id="layoutCornerType" onchange="updateLayoutCornerType()">
                <option value="corner-cabinet" selected>Corner Cabinet (36")</option>
                <option value="lazy-susan">Lazy Susan (36")</option>
                <option value="blind-corner">Blind Corner</option>
                <option value="filler">Filler Space</option>
                <option value="none">No Corner (overlap)</option>
              </select>
            </div>
            <div class="layout-option-row">
              <label>
                <input type="checkbox" id="layoutAddCountertop" onchange="updateLayoutCountertop()">
                Auto-add countertop
              </label>
            </div>
            <div class="layout-option-row">
              <label>
                <input type="checkbox" id="layoutSnapToWalls" checked onchange="updateLayoutWallSnap()">
                Snap to walls
              </label>
            </div>
            <div class="layout-option-row">
              <label>
                <input type="checkbox" id="layoutBothLevels" checked onchange="updateLayoutBothLevels()">
                Draw Upper + Lower Together
              </label>
            </div>
            <div class="layout-option-hint">
              Click & drag to draw runs  Turn creates corners
            </div>
          </div>
        </div>

        <!-- Cabinets -->
        <div class="sidebar-section">
          <div class="sidebar-header" onclick="toggleSection(this)" title="Add cabinets">
            <span class="sidebar-title">Cabinets</span>
            <span class="sidebar-toggle"></span>
          </div>
          <div class="sidebar-content">
            <div class="element-grid" id="cabinetsGrid">
              <!-- Elements rendered by JS -->
            </div>
          </div>
        </div>

        <!-- Surfaces -->
        <div class="sidebar-section">
          <div class="sidebar-header" onclick="toggleSection(this)" title="Countertops & flooring">
            <span class="sidebar-title">Surfaces</span>
            <span class="sidebar-toggle"></span>
          </div>
          <div class="sidebar-content">
            <div style="display: flex; gap: 4px; margin-bottom: 8px;">
              <button class="quick-btn" style="flex: 1; font-size: 10px; padding: 4px 6px;" onclick="fillRoomWithFlooring()" title="Fill entire room with flooring">
                Fill Floor
              </button>
              <button class="quick-btn" style="flex: 1; font-size: 10px; padding: 4px 6px;" onclick="generateCountertopsOverCabinets()" title="Auto-generate countertops over base cabinets">
                Auto Counter
              </button>
            </div>
            <div class="element-grid" id="surfacesGrid">
              <!-- Elements rendered by JS -->
            </div>
          </div>
        </div>

        <!-- Appliances -->
        <div class="sidebar-section">
          <div class="sidebar-header" onclick="toggleSection(this)" title="Sinks, stoves & more">
            <span class="sidebar-title">Appliances</span>
            <span class="sidebar-toggle"></span>
          </div>
          <div class="sidebar-content">
            <div class="element-grid" id="appliancesGrid">
              <!-- Elements rendered by JS -->
            </div>
          </div>
        </div>

        <!-- Structure -->
        <div class="sidebar-section">
          <div class="sidebar-header" onclick="toggleSection(this)" title="Doors, windows & walls">
            <span class="sidebar-title">Structure</span>
            <span class="sidebar-toggle"></span>
          </div>
          <div class="sidebar-content">
            <div class="element-grid" id="structureGrid">
              <!-- Elements rendered by JS -->
            </div>
          </div>
        </div>

        <!-- Bathroom Fixtures (collapsed by default) -->
        <div class="sidebar-section">
          <div class="sidebar-header" onclick="toggleSection(this)" title="Toilets, tubs, vanities & showers">
            <span class="sidebar-title">Bathroom</span>
            <span class="sidebar-toggle"></span>
          </div>
          <div class="sidebar-content collapsed">
            <div class="element-grid" id="bathroomGrid">
              <!-- Elements rendered by JS -->
            </div>
          </div>
        </div>

        <!-- Laundry (collapsed by default) -->
        <div class="sidebar-section">
          <div class="sidebar-header" onclick="toggleSection(this)" title="Washer, dryer & laundry items">
            <span class="sidebar-title">Laundry</span>
            <span class="sidebar-toggle"></span>
          </div>
          <div class="sidebar-content collapsed">
            <div class="element-grid" id="laundryGrid">
              <!-- Elements rendered by JS -->
            </div>
          </div>
        </div>

        <!-- Closet (collapsed by default) -->
        <div class="sidebar-section">
          <div class="sidebar-header" onclick="toggleSection(this)" title="Closet organization & storage">
            <span class="sidebar-title">Closet</span>
            <span class="sidebar-toggle"></span>
          </div>
          <div class="sidebar-content collapsed">
            <div class="element-grid" id="closetGrid">
              <!-- Elements rendered by JS -->
            </div>
          </div>
        </div>

        <!-- Materials Library -->
        <div class="sidebar-section">
          <div class="sidebar-header" onclick="toggleSection(this)" title="Apply materials">
            <span class="sidebar-title">Materials</span>
            <span class="sidebar-toggle"></span>
          </div>
          <div class="sidebar-content">
            <div class="materials-tabs">
              <!-- Countertop Stones -->
              <button class="material-tab active" onclick="showMaterialCategory('granite', this)">Granite</button>
              <button class="material-tab" onclick="showMaterialCategory('quartz', this)">Quartz</button>
              <button class="material-tab" onclick="showMaterialCategory('marble', this)">Marble</button>
              <button class="material-tab" onclick="showMaterialCategory('quartzite', this)">Quartzite</button>
              <button class="material-tab" onclick="showMaterialCategory('porcelain', this)">Porcelain</button>
              <!-- Flooring -->
              <button class="material-tab" onclick="showMaterialCategory('tile', this)">Tile</button>
              <button class="material-tab" onclick="showMaterialCategory('flooring', this)">LVT</button>
              <button class="material-tab" onclick="showMaterialCategory('hardscape', this)">Hardscape</button>
              <!-- Cabinet Finishes -->
              <button class="material-tab" onclick="showMaterialCategory('cabinets', this)">Cabinets</button>
              <button class="material-tab" onclick="showMaterialCategory('vanities', this)">Vanities</button>
              <!-- Specialty -->
              <button class="material-tab" onclick="showMaterialCategory('showerPanels', this)">Shower</button>
              <button class="material-tab" onclick="showMaterialCategory('flooringTrims', this)">Trims</button>
            </div>
            <!-- Material Filters -->
            <div class="material-filter" style="padding: 6px 8px; display: flex; flex-wrap: wrap; gap: 4px; align-items: center;">
              <select id="brandFilter" onchange="applyMaterialFilters()" style="flex: 1; min-width: 80px; padding: 4px 6px; border-radius: 4px; border: 1px solid #333; background: #1a1a2e; color: #fff; font-size: 10px;">
                <option value="">All Vendors</option>
              </select>
              <select id="priceFilter" onchange="applyMaterialFilters()" style="flex: 1; min-width: 80px; padding: 4px 6px; border-radius: 4px; border: 1px solid #333; background: #1a1a2e; color: #fff; font-size: 10px;">
                <option value="">All Prices</option>
                <option value="has">Has Price</option>
                <option value="0-5">Under $5/sf</option>
                <option value="5-15">$5$15/sf</option>
                <option value="15-30">$15$30/sf</option>
                <option value="30-50">$30$50/sf</option>
                <option value="50-100">$50$100/sf</option>
                <option value="100+">$100+/sf</option>
              </select>
              <select id="finishFilter" onchange="applyMaterialFilters()" style="flex: 1; min-width: 80px; padding: 4px 6px; border-radius: 4px; border: 1px solid #333; background: #1a1a2e; color: #fff; font-size: 10px;">
                <option value="">All Finishes</option>
              </select>
              <button onclick="clearAllMaterialFilters()" style="padding: 4px 6px; border-radius: 4px; border: none; background: #333; color: #fff; font-size: 9px; cursor: pointer;" title="Clear all filters"></button>
            </div>
            <div class="material-grid" id="materialGrid">
              <!-- Materials rendered by JS -->
            </div>
            <div class="material-hint">Click material, then click element to apply</div>
          </div>
        </div>

        <!-- Cabinet Catalog (collapsed by default) -->
        <div class="sidebar-section">
          <div class="sidebar-header" onclick="toggleSection(this)" title="Browse cabinet SKUs">
            <span class="sidebar-title">Cabinet Catalog</span>
            <span class="sidebar-toggle"></span>
          </div>
          <div class="sidebar-content collapsed">
            <div class="catalog-brand">
              <select id="catalogSelect" onchange="changeCatalog(this.value)">
                <option value="procraft">ProCraft Cabinetry</option>
                <option value="msi">MSI Cabinetry</option>
                <option value="custom">Custom / Import</option>
              </select>
            </div>
            <div class="catalog-series" id="catalogSeries">
              <select id="seriesSelect" onchange="changeSeries(this.value)">
                <option value="shaker-white">Shaker White</option>
                <option value="shaker-grey">Shaker Grey</option>
                <option value="shaker-espresso">Shaker Espresso</option>
              </select>
            </div>
            <div class="materials-tabs" id="cabinetCategoryTabs">
              <button class="material-tab active" onclick="showCabinetCategory('base', this)">Base</button>
              <button class="material-tab" onclick="showCabinetCategory('drawer', this)">Drawer</button>
              <button class="material-tab" onclick="showCabinetCategory('sink', this)">Sink</button>
              <button class="material-tab" onclick="showCabinetCategory('wall', this)">Wall</button>
              <button class="material-tab" onclick="showCabinetCategory('tall', this)">Tall</button>
              <button class="material-tab" onclick="showCabinetCategory('corner', this)">Corner</button>
              <button class="material-tab" onclick="showCabinetCategory('lazySusan', this)">L.Susan</button>
            </div>
            <div class="cabinet-catalog-list" id="cabinetCatalogList">
              <!-- Cabinets rendered by JS -->
            </div>
            <div class="catalog-actions">
              <button class="btn btn-sm btn-secondary" onclick="importCabinetList()" title="Import cabinet list from CSV or JSON">
                <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                  <polyline points="17 8 12 3 7 8"/>
                  <line x1="12" y1="3" x2="12" y2="15"/>
                </svg>
                Import List
              </button>
            </div>
          </div>
        </div>

        <!-- Product Catalog from Website (collapsed by default) -->
        <div class="sidebar-section">
          <div class="sidebar-header" onclick="toggleSection(this)" title="Shop online products">
            <span class="sidebar-title">Store Products</span>
            <span class="sidebar-toggle"></span>
          </div>
          <div class="sidebar-content collapsed">
            <div class="product-search-bar">
              <input type="text" id="productSearchInput" placeholder="Search products..." oninput="filterStoreProducts()">
              <button class="search-icon" onclick="filterStoreProducts()">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <circle cx="11" cy="11" r="8"/>
                  <line x1="21" y1="21" x2="16.65" y2="16.65"/>
                </svg>
              </button>
            </div>
            <div class="materials-tabs" id="productCategoryTabs">
              <button class="material-tab active" onclick="showProductCategory('countertops', this)">Countertops</button>
              <button class="material-tab" onclick="showProductCategory('tile', this)">Tile</button>
              <button class="material-tab" onclick="showProductCategory('flooring', this)">Flooring</button>
              <button class="material-tab" onclick="showProductCategory('sinks', this)">Sinks</button>
            </div>
            <div class="product-filters">
              <select id="productBrandFilter" onchange="filterStoreProducts()">
                <option value="">All Brands</option>
              </select>
              <select id="productTypeFilter" onchange="filterStoreProducts()">
                <option value="">All Types</option>
              </select>
            </div>
            <div class="product-catalog-grid" id="productCatalogGrid">
              <div class="loading-products">Loading products...</div>
            </div>
            <div class="product-hint">Click product to apply as material</div>
          </div>
        </div>
      </aside>

      <!-- Canvas Area -->
      <div class="canvas-area">
        <div class="canvas-toolbar">
          <div class="toolbar-group">
            <!-- History Controls -->
            <div class="toolbar-btn-group">
              <button class="btn btn-sm btn-secondary" id="undoBtn" onclick="undo()" title="Undo (Ctrl+Z)" data-tooltip="Undo">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M3 10h10a5 5 0 0 1 5 5v2"/>
                  <polyline points="3 10 8 5 8 15 3 10"/>
                </svg>
              </button>
              <button class="btn btn-sm btn-secondary" id="redoBtn" onclick="redo()" title="Redo (Ctrl+Y)" data-tooltip="Redo">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M21 10H11a5 5 0 0 0-5 5v2"/>
                  <polyline points="21 10 16 5 16 15 21 10"/>
                </svg>
              </button>
            </div>
            <div class="toolbar-divider"></div>
            <!-- View Controls -->
            <div class="toolbar-btn-group">
              <button class="btn btn-sm btn-secondary" onclick="fitToScreen()" title="Fit design to screen (F)">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"/>
                </svg>
                Fit
              </button>
              <button class="btn btn-sm btn-secondary" id="lockViewBtn" onclick="toggleViewLock()" title="Lock view (prevent pan/zoom)">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" id="lockIcon">
                  <rect x="3" y="11" width="18" height="11" rx="2" ry="2"/>
                  <path d="M7 11V7a5 5 0 0 1 10 0v4"/>
                </svg>
              </button>
            </div>
            <div class="toolbar-divider"></div>
            <!-- Canvas Actions -->
            <div class="toolbar-btn-group">
              <button class="btn btn-sm btn-secondary" onclick="clearCanvas()" title="Clear all elements (keeps room settings)">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <rect x="3" y="3" width="18" height="18" rx="2"/>
                  <line x1="9" y1="9" x2="15" y2="15"/>
                  <line x1="15" y1="9" x2="9" y2="15"/>
                </svg>
                Clear
              </button>
              <button class="btn btn-sm btn-secondary" onclick="resetCanvas()" style="color: #ef4444;" title="Reset entire project including saved progress">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/>
                  <path d="M3 3v5h5"/>
                </svg>
                Reset
              </button>
            </div>
          </div>
          <div class="canvas-info">
            <span id="canvasSize">12'  10'</span>
            <span id="elementCount">0 elements</span>
          </div>
        </div>
        <div class="canvas-wrapper" id="canvasWrapper">
          <canvas id="canvas"></canvas>
        </div>
        <div id="three-container">
          <div class="three-controls">
            <button onclick="reset3DView()" title="Reset camera to default position">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/>
                <path d="M3 3v5h5"/>
              </svg>
              Reset View
            </button>
            <button onclick="set3DViewAngle('top')" title="Top-down view">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="12" cy="12" r="3"/>
                <path d="M12 2v4M12 18v4M2 12h4M18 12h4"/>
              </svg>
              Top
            </button>
            <button onclick="set3DViewAngle('front')" title="Front view">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <rect x="3" y="3" width="18" height="18" rx="2"/>
              </svg>
              Front
            </button>
            <button onclick="set3DViewAngle('counter')" title="Counter-level view (eye height at countertop)">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M2 17h20M2 12h20M7 17v-5M17 17v-5"/>
              </svg>
              Counter
            </button>
            <button onclick="set3DViewAngle('corner')" title="Corner view (diagonal across room)">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M3 21L21 3M3 21h6M3 21v-6"/>
              </svg>
              Corner
            </button>
            <button onclick="toggleCabinetFocus()" title="Hide walls/windows to focus on cabinets" id="focusCabinetsBtn">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <rect x="4" y="10" width="6" height="10" rx="1"/>
                <rect x="14" y="10" width="6" height="10" rx="1"/>
                <path d="M4 8h16"/>
              </svg>
              Focus
            </button>
            <button onclick="toggleWalkthroughMode()" title="First-person walkthrough mode (WASD + mouse)" id="walkthroughBtn">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="12" cy="8" r="4"/>
                <path d="M12 12v8M8 16l4 4 4-4"/>
              </svg>
              Walk
            </button>
            <button onclick="togglePostProcessing()" title="Toggle enhanced graphics (bloom, ambient occlusion)" id="postProcessingBtn" class="active">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="12" cy="12" r="4"/>
                <path d="M12 2v2M12 20v2M4.93 4.93l1.41 1.41M17.66 17.66l1.41 1.41M2 12h2M20 12h2M4.93 19.07l1.41-1.41M17.66 6.34l1.41-1.41"/>
              </svg>
              FX
            </button>
            <button onclick="toggleMeasurementMode()" title="Measure distance between two points" id="measureBtn">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M2 12h4M18 12h4"/>
                <path d="M6 8v8M18 8v8"/>
                <line x1="6" y1="12" x2="18" y2="12" stroke-dasharray="2 2"/>
                <circle cx="6" cy="12" r="2"/>
                <circle cx="18" cy="12" r="2"/>
              </svg>
              Measure
            </button>
            <button onclick="toggleRoomDimensions()" title="Show/hide room dimensions" id="roomDimsBtn">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <rect x="3" y="3" width="18" height="18" rx="1"/>
                <path d="M3 9h18M9 3v18"/>
                <text x="6" y="7" font-size="4" fill="currentColor">W</text>
                <text x="11" y="16" font-size="4" fill="currentColor">D</text>
              </svg>
              Dims
            </button>
            <button onclick="toggleLightingPanel()" title="Adjust lighting settings" id="lightingBtn">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="12" cy="12" r="5"/>
                <line x1="12" y1="1" x2="12" y2="3"/>
                <line x1="12" y1="21" x2="12" y2="23"/>
                <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/>
                <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/>
                <line x1="1" y1="12" x2="3" y2="12"/>
                <line x1="21" y1="12" x2="23" y2="12"/>
                <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/>
                <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/>
              </svg>
              Light
            </button>
            <button onclick="captureHighResScreenshot()" title="Capture high-resolution screenshot" id="screenshotBtn">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <rect x="3" y="3" width="18" height="18" rx="2"/>
                <circle cx="8.5" cy="8.5" r="1.5"/>
                <path d="M21 15l-5-5L5 21"/>
              </svg>
              Photo
            </button>
          </div>
          <!-- Lighting Control Panel -->
          <div class="lighting-panel" id="lightingPanel" style="display: none;">
            <div class="lighting-panel-header">
              <span>Lighting Controls</span>
              <button onclick="toggleLightingPanel()" class="close-btn">&times;</button>
            </div>
            <div class="lighting-panel-content">
              <div class="lighting-presets">
                <label>Presets</label>
                <div class="preset-buttons">
                  <button onclick="setLightingPreset('morning', this)" class="preset-btn" title="Morning"></button>
                  <button onclick="setLightingPreset('noon', this)" class="preset-btn active" title="Noon"></button>
                  <button onclick="setLightingPreset('evening', this)" class="preset-btn" title="Evening"></button>
                  <button onclick="setLightingPreset('night', this)" class="preset-btn" title="Night"></button>
                  <button onclick="setLightingPreset('showroom', this)" class="preset-btn" title="Showroom"></button>
                </div>
              </div>
              <div class="lighting-slider">
                <label>Brightness</label>
                <input type="range" id="brightnessSlider" min="0" max="200" value="100" oninput="adjustBrightness(this.value)">
                <span id="brightnessValue">100%</span>
              </div>
              <div class="lighting-slider">
                <label>Ambient</label>
                <input type="range" id="ambientSlider" min="0" max="150" value="50" oninput="adjustAmbient(this.value)">
                <span id="ambientValue">50%</span>
              </div>
              <div class="lighting-slider">
                <label>Shadows</label>
                <input type="range" id="shadowSlider" min="0" max="100" value="80" oninput="adjustShadows(this.value)">
                <span id="shadowValue">80%</span>
              </div>
              <div class="lighting-toggle">
                <label>
                  <input type="checkbox" id="shadowsEnabled" checked onchange="toggleShadows(this.checked)">
                  Enable Shadows
                </label>
              </div>
              <div class="lighting-toggle hd-toggle">
                <label>
                  <input type="checkbox" id="hdModeEnabled" onchange="toggleHDMode(this.checked)">
                  HD Mode <span class="hd-badge"> Enhanced</span>
                </label>
              </div>
            </div>
          </div>
          <div class="three-hint" id="threeHint">
            Left-drag: Rotate  Scroll: Zoom  Middle-drag: Pan  Double-click: Open doors
          </div>
          <div class="three-hint walkthrough-hint" id="walkthroughHint" style="display: none;">
            <strong>Walkthrough Mode:</strong> WASD to move  Mouse to look  Q/E for up/down  ESC to exit
          </div>
        </div>
      </div>

      <!-- Floating Quick-Action Toolbar -->
      <div class="floating-toolbar" id="floatingToolbar">
        <div class="selection-badge" id="selectionBadge">
          <span class="count" id="selectionCount">1</span>
          <span id="selectionType">Selected</span>
        </div>
        <div class="floating-toolbar-group">
          <button class="float-btn" onclick="duplicateSelectedElement()" title="Duplicate">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <rect x="9" y="9" width="13" height="13" rx="2"/>
              <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/>
            </svg>
            <span class="shortcut">D</span>
          </button>
          <button class="float-btn" onclick="rotateSelectedElement(90)" title="Rotate 90">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M21 12a9 9 0 1 1-9-9c2.52 0 4.93 1 6.74 2.74L21 8"/>
              <path d="M21 3v5h-5"/>
            </svg>
            <span class="shortcut">R</span>
          </button>
          <button class="float-btn" onclick="flipSelectedElement('h')" title="Flip Horizontal">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M8 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h3"/>
              <path d="M16 3h3a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2h-3"/>
              <line x1="12" y1="3" x2="12" y2="21"/>
            </svg>
            <span class="shortcut">H</span>
          </button>
        </div>
        <div class="floating-toolbar-divider"></div>
        <div class="floating-toolbar-group">
          <button class="float-btn" onclick="bringToFront()" title="Bring to Front">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <rect x="8" y="8" width="12" height="12" rx="2" fill="currentColor" opacity="0.3"/>
              <rect x="4" y="4" width="12" height="12" rx="2"/>
            </svg>
          </button>
          <button class="float-btn" onclick="sendToBack()" title="Send to Back">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <rect x="4" y="4" width="12" height="12" rx="2" fill="currentColor" opacity="0.3"/>
              <rect x="8" y="8" width="12" height="12" rx="2"/>
            </svg>
          </button>
        </div>
        <div class="floating-toolbar-divider"></div>
        <div class="floating-toolbar-group">
          <button class="float-btn" id="lockTogetherBtn" onclick="lockElementsTogether()" title="Lock with another element" style="background: rgba(99, 102, 241, 0.3);">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"/>
              <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"/>
            </svg>
          </button>
          <button class="float-btn" id="unlockBtn" onclick="unlockElement()" title="Unlock from group" style="display: none;">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M18.36 6.64a9 9 0 1 1-12.73 0"/>
              <line x1="12" y1="2" x2="12" y2="12"/>
            </svg>
          </button>
        </div>
        <div class="floating-toolbar-divider"></div>
        <button class="float-btn danger" onclick="deleteSelectedElement()" title="Delete">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M3 6h18"/>
            <path d="M8 6V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/>
            <path d="M19 6l-1 14a2 2 0 0 1-2 2H8a2 2 0 0 1-2-2L5 6"/>
          </svg>
          <span class="shortcut"></span>
        </button>
      </div>

      <!-- Right Panel -->
      <aside class="right-panel">
        <div class="panel-section">
          <div class="panel-title">Room Settings</div>
          <div class="room-grid">
            <div class="input-group">
              <label class="input-label">Room Type</label>
              <select class="input-field" id="roomType" onchange="updateRoom()">
                <option value="kitchen">Kitchen</option>
                <option value="bathroom">Bathroom</option>
                <option value="shower">Shower Room</option>
                <option value="closet">Walk-in Closet</option>
                <option value="laundry">Laundry</option>
                <option value="bedroom">Bedroom</option>
                <option value="living">Living Room</option>
                <option value="office">Office</option>
                <option value="commercial">Commercial</option>
              </select>
            </div>
            <div class="input-group">
              <label class="input-label">Width (ft)</label>
              <input type="number" class="input-field" id="roomWidth" value="20" min="8" max="100" onchange="updateRoom()">
            </div>
            <div class="input-group">
              <label class="input-label">Depth (ft)</label>
              <input type="number" class="input-field" id="roomDepth" value="16" min="8" max="100" onchange="updateRoom()">
            </div>
            <div class="input-group">
              <label class="input-label">Ceiling (ft)</label>
              <select class="input-field" id="roomHeight" onchange="updateRoomHeight()">
                <option value="8" selected>8' Standard</option>
                <option value="9">9' Raised</option>
                <option value="10">10' High</option>
                <option value="12">12' Vaulted</option>
              </select>
            </div>
            <div class="input-group">
              <label class="input-label">Scale</label>
              <select class="input-field" id="scaleMode" onchange="updateScale()">
                <option value="fit">Fit to Screen</option>
                <option value="40">40 px/ft</option>
                <option value="50">50 px/ft</option>
                <option value="60">60 px/ft</option>
              </select>
            </div>
          </div>
        </div>

        <!-- Customer Messages Section -->
        <div class="panel-section" id="messagesSection">
          <div class="panel-title" onclick="toggleMessagesPanel()" style="cursor: pointer; display: flex; align-items: center; justify-content: space-between;">
            <span> Messages</span>
            <span class="message-badge" id="messageBadge" style="background: #ef4444; color: white; font-size: 10px; padding: 2px 6px; border-radius: 10px; display: none;">0</span>
          </div>
          <div class="messages-panel-content" id="messagesContent">
            <div class="customer-messages-list" id="customerMessagesList" style="background: rgba(0,0,0,0.2); border-radius: 6px; padding: 8px; margin-bottom: 8px; max-height: 120px; overflow-y: auto;">
              <div class="no-messages" id="noCustomerMessage" style="color: #a78bfa; font-size: 11px; text-align: center; padding: 10px;">
                No customer linked<br>
                <span style="font-size: 9px; opacity: 0.7;">Share design to enable messaging</span>
              </div>
            </div>
            <div class="customer-message-input" id="messageInputArea" style="display: none; gap: 6px;">
              <input type="text" id="designerReplyInput" placeholder="Type a reply..." style="flex: 1; padding: 8px; border: 1px solid var(--border); border-radius: 6px; background: var(--dark-elevated); color: var(--text); font-size: 11px;">
              <button class="btn btn-primary btn-sm" onclick="sendDesignerReply()">Send</button>
            </div>
          </div>
        </div>

        <!-- Room Templates (expanded by default for discoverability) -->
        <div class="panel-section" id="roomTemplatesSection">
          <div class="panel-title" onclick="togglePanelSection('roomTemplatesSection')">
            <span>Room Templates</span>
            <span class="toggle-icon"></span>
          </div>
          <div class="panel-content">
          <div class="room-templates-grid">
            <button class="template-btn" onclick="loadRoomTemplate('kitchen-l')" title="L-shaped kitchen with island">
              <span class="template-icon"></span>
              <span class="template-name">L-Kitchen</span>
            </button>
            <button class="template-btn" onclick="loadRoomTemplate('kitchen-galley')" title="Galley kitchen layout">
              <span class="template-icon"></span>
              <span class="template-name">Galley</span>
            </button>
            <button class="template-btn" onclick="loadRoomTemplate('kitchen-u')" title="U-shaped kitchen">
              <span class="template-icon"></span>
              <span class="template-name">U-Kitchen</span>
            </button>
            <button class="template-btn" onclick="loadRoomTemplate('kitchen-single')" title="Single wall kitchen layout">
              <span class="template-icon"></span>
              <span class="template-name">Single Wall</span>
            </button>
            <button class="template-btn" onclick="loadRoomTemplate('kitchen-peninsula')" title="Peninsula kitchen with breakfast bar">
              <span class="template-icon"></span>
              <span class="template-name">Peninsula</span>
            </button>
            <button class="template-btn" onclick="loadRoomTemplate('bathroom-master')" title="Master bathroom with tub and shower">
              <span class="template-icon"></span>
              <span class="template-name">Master Bath</span>
            </button>
            <button class="template-btn" onclick="loadRoomTemplate('bathroom-half')" title="Half bathroom (powder room)">
              <span class="template-icon"></span>
              <span class="template-name">Half Bath</span>
            </button>
            <button class="template-btn" onclick="loadRoomTemplate('shower-walkin')" title="Walk-in shower with bench">
              <span class="template-icon"></span>
              <span class="template-name">Walk-in Shower</span>
            </button>
            <button class="template-btn" onclick="loadRoomTemplate('closet-walkin')" title="Walk-in closet with shelving">
              <span class="template-icon"></span>
              <span class="template-name">Walk-in Closet</span>
            </button>
            <button class="template-btn" onclick="loadRoomTemplate('laundry-room')" title="Laundry room with cabinets">
              <span class="template-icon"></span>
              <span class="template-name">Laundry</span>
            </button>
          </div>
          <p class="template-hint">Click a template to load preset room layout</p>
          <!-- Hidden for now - admin feature -->
          <button onclick="exportAsTemplate()" style="display:none;width:100%;margin-top:8px;padding:8px;background:rgba(99,102,241,0.2);border:1px solid rgba(99,102,241,0.4);border-radius:6px;color:#a5b4fc;font-size:11px;cursor:pointer;" title="Export your current design as reusable template code">
             Export Current Design as Template
          </button>
          </div><!-- /panel-content -->
        </div>

        <!-- Cabinet Settings -->
        <div class="panel-section">
          <div class="panel-title">Cabinet Settings</div>
          <div class="room-grid">
            <div class="input-group">
              <label class="input-label">Construction</label>
              <select class="input-field" id="cabinetConstruction" onchange="updateCabinetSettings()">
                <option value="frameless">Frameless (Euro)</option>
                <option value="framed">Framed (Face Frame)</option>
              </select>
            </div>
            <div class="input-group">
              <label class="input-label">Door Style</label>
              <select class="input-field" id="doorStyle" onchange="updateCabinetSettings()">
                <option value="shaker">Shaker</option>
                <option value="shaker-beaded">Shaker Beaded</option>
                <option value="flat">Flat Panel</option>
                <option value="raised">Raised Panel</option>
                <option value="slab">Slab (No Detail)</option>
              </select>
            </div>
            <div class="input-group">
              <label class="input-label">Cabinet Finish</label>
              <select class="input-field" id="cabinetFinish" onchange="updateCabinetSettings()">
                <option value="wood-grain">Wood Grain</option>
                <option value="painted">Painted (No Grain)</option>
                <option value="matte">Matte Laminate</option>
                <option value="gloss">High Gloss</option>
              </select>
            </div>
            <div class="input-group">
              <label class="input-label">Door Overlay</label>
              <select class="input-field" id="doorOverlay" onchange="updateCabinetSettings()">
                <option value="full">Full Overlay</option>
                <option value="partial">Partial Overlay</option>
                <option value="inset">Inset</option>
              </select>
            </div>
            <div class="input-group" style="grid-column: span 2;">
              <button class="action-btn" onclick="applySettingsToAllCabinets()" style="width: 100%; padding: 8px 12px; font-size: 12px;">
                Apply Style to All Cabinets
              </button>
            </div>
            <div class="input-group">
              <label class="input-label">Floor Level</label>
              <select class="input-field" id="floorLevel" onchange="updateFloorLevel()">
                <option value="1">Floor 1</option>
                <option value="2">Floor 2</option>
                <option value="3">Floor 3</option>
                <option value="add">+ Add Floor</option>
              </select>
            </div>
          </div>
        </div>

        <!-- Scene Settings (collapsed by default) -->
        <div class="panel-section collapsed" id="sceneSettingsSection">
          <div class="panel-title" onclick="togglePanelSection('sceneSettingsSection')">
            <span>Scene Settings</span>
            <span class="toggle-icon"></span>
          </div>
          <div class="panel-content">
            <div class="room-grid">
              <div class="input-group">
                <label class="input-label">Time of Day</label>
                <select class="input-field" id="timeOfDay" onchange="updateTimeOfDay()">
                  <option value="morning">Morning (Sunrise)</option>
                  <option value="noon" selected>Noon (Daylight)</option>
                  <option value="evening">Evening (Sunset)</option>
                  <option value="night">Night</option>
                </select>
              </div>
            </div>
          </div>
        </div>

        <!-- Item Picker / Quote List -->
        <div class="panel-section" id="itemPickerSection">
          <div class="panel-title" style="display: flex; align-items: center; justify-content: space-between;">
            <span>Item List</span>
            <span class="item-picker-total" id="itemPickerTotal">$0.00</span>
          </div>
          <div class="item-picker-controls">
            <select class="input-field item-filter" id="itemFilterType" onchange="filterItemList()">
              <option value="all">All Items</option>
              <option value="cabinets">Cabinets</option>
              <option value="countertops">Countertops</option>
              <option value="appliances">Appliances</option>
              <option value="sinks">Sinks</option>
              <option value="flooring">Flooring</option>
              <option value="fixtures">Fixtures</option>
              <option value="other">Other</option>
            </select>
          </div>
          <div class="item-picker-list" id="itemPickerList">
            <!-- Populated by JavaScript -->
          </div>
          <div class="item-picker-summary" id="itemPickerSummary">
            <div id="itemCategorySummary">
              <!-- Category breakdown populated by JS -->
            </div>
            <div class="summary-row" style="margin-top: 8px; padding-top: 8px; border-top: 1px solid var(--border);">
              <span>Items:</span>
              <span id="itemCount">0</span>
            </div>
            <div class="summary-row" style="font-size: 13px;">
              <span><strong>Total:</strong></span>
              <span id="itemSubtotal" style="color: #22c55e; font-weight: 700;">$0.00</span>
            </div>
          </div>
          <div class="item-picker-actions">
            <button class="btn-small btn-secondary" onclick="selectAllItems()">Select All</button>
            <button class="btn-small btn-secondary" onclick="deselectAllItems()">Deselect</button>
            <button class="btn-small btn-danger" onclick="deleteSelectedItems()">Delete</button>
          </div>
        </div>

        <!-- Hidden element list for compatibility -->
        <div id="elementLayerList" style="display: none;"></div>
        <span id="elementCountDisplay" style="display: none;">0</span>

        <div class="panel-section" id="propertiesPanel">
          <div class="panel-title">Properties</div>
          <div class="properties-empty" id="propertiesEmpty">
            Select an element to edit
          </div>
          <div id="propertiesContent" style="display: none;">
            <!-- Quick Actions Toolbar -->
            <div class="quick-actions" style="display: flex; gap: 4px; margin-bottom: 12px; padding-bottom: 12px; border-bottom: 1px solid var(--border-color);">
              <button class="quick-btn" onclick="duplicateSelectedElement()" title="Duplicate (Ctrl+D)">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="16" height="16">
                  <rect x="9" y="9" width="13" height="13" rx="2"/>
                  <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/>
                </svg>
              </button>
              <button class="quick-btn" onclick="rotateSelectedElement(90)" title="Rotate 90 (R)">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="16" height="16">
                  <path d="M21 12a9 9 0 1 1-9-9c2.52 0 4.93 1 6.74 2.74L21 8"/>
                  <path d="M21 3v5h-5"/>
                </svg>
              </button>
              <button class="quick-btn" onclick="rotateSelectedElement(180)" title="Rotate 180">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="16" height="16">
                  <path d="M21 12a9 9 0 0 1-9 9 9 9 0 0 1-9-9"/>
                  <path d="M3 12a9 9 0 0 1 9-9 9 9 0 0 1 9 9"/>
                  <path d="M16 16l2 2 2-2"/>
                  <path d="M8 8l-2-2-2 2"/>
                </svg>
              </button>
              <button class="quick-btn" onclick="flipSelectedElement('h')" title="Flip Horizontal">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="16" height="16">
                  <path d="M8 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h3"/>
                  <path d="M16 3h3a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2h-3"/>
                  <line x1="12" y1="3" x2="12" y2="21"/>
                </svg>
              </button>
              <button class="quick-btn" onclick="bringToFront()" title="Bring to Front">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="16" height="16">
                  <rect x="8" y="8" width="12" height="12" rx="2" fill="currentColor" opacity="0.3"/>
                  <rect x="4" y="4" width="12" height="12" rx="2"/>
                </svg>
              </button>
              <button class="quick-btn" onclick="sendToBack()" title="Send to Back">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="16" height="16">
                  <rect x="4" y="4" width="12" height="12" rx="2" fill="currentColor" opacity="0.3"/>
                  <rect x="8" y="8" width="12" height="12" rx="2"/>
                </svg>
              </button>
              <button class="quick-btn danger" onclick="deleteSelectedElement()" title="Delete (Del)">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="16" height="16">
                  <path d="M3 6h18"/>
                  <path d="M8 6V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/>
                  <path d="M19 6l-1 14a2 2 0 0 1-2 2H8a2 2 0 0 1-2-2L5 6"/>
                </svg>
              </button>
            </div>
            <div class="property-row">
              <span class="property-label">Type</span>
              <span class="property-value" id="propType">-</span>
            </div>
            <div class="property-row">
              <span class="property-label">Width</span>
              <input type="text" class="property-input" id="propWidth" placeholder="e.g. 3'-6&quot; or 2.5" onchange="updateSelectedElement()" title="Enter feet-inches (3'-6&quot;) or decimal feet (2.5)">
              <span class="dimension-display" id="propWidthDisplay"></span>
            </div>
            <div class="property-row">
              <span class="property-label">Depth</span>
              <input type="text" class="property-input" id="propHeight" placeholder="e.g. 2'-0&quot; or 2" onchange="updateSelectedElement()" title="Enter feet-inches (2'-0&quot;) or decimal feet (2)">
              <span class="dimension-display" id="propHeightDisplay"></span>
            </div>
            <div class="property-row" id="standardSizeRow" style="display: none;">
              <span class="property-label">Standard</span>
              <select class="property-select" id="propStandardSize" onchange="applyStandardSize()">
                <option value="">Custom</option>
              </select>
            </div>
            <!-- Window/Door height from floor -->
            <div class="property-row" id="sillHeightRow" style="display: none;">
              <span class="property-label">Sill Height</span>
              <div style="display: flex; align-items: center; gap: 8px;">
                <select class="property-select" id="propSillHeight" onchange="updateSillHeight()" style="flex: 1;">
                  <option value="0">0" - Floor Level (Doors)</option>
                  <option value="1.5">18" - Low / Picture Window</option>
                  <option value="2">24" - Bedroom Window</option>
                  <option value="3">36" - Standard (IRC)</option>
                  <option value="3.5">42" - Above Counter (Kitchen)</option>
                  <option value="4">48" - High Window</option>
                  <option value="5">60" - Clerestory</option>
                  <option value="custom">Custom...</option>
                </select>
              </div>
            </div>
            <div class="property-row" id="customSillRow" style="display: none;">
              <span class="property-label">Custom (ft)</span>
              <input type="number" class="property-input" id="propCustomSill" step="0.0833" min="0" max="8" onchange="applyCustomSillHeight()">
            </div>
            <!-- Window Opening Height controls -->
            <div class="property-row" id="windowHeightRow" style="display: none;">
              <span class="property-label">Window Height</span>
              <div style="display: flex; align-items: center; gap: 8px;">
                <select class="property-select" id="propWindowHeight" onchange="updateWindowOpeningHeight()" style="flex: 1;">
                  <option value="2">24" - Small</option>
                  <option value="2.5">30" - Standard</option>
                  <option value="3">36" - Standard+</option>
                  <option value="3.5">42" - Large</option>
                  <option value="4">48" - Bay / Large</option>
                  <option value="5">60" - Picture</option>
                  <option value="6">72" - Floor-to-Ceil</option>
                  <option value="custom">Custom...</option>
                </select>
              </div>
            </div>
            <div class="property-row" id="customWindowHeightRow" style="display: none;">
              <span class="property-label">Height (ft)</span>
              <input type="number" class="property-input" id="propCustomWindowHeight" step="0.0833" min="1" max="10" onchange="applyCustomWindowOpeningHeight()">
              <span class="dimension-display" id="propWindowHeightDisplay"></span>
            </div>
            <!-- Door/Archway height controls -->
            <div class="property-row" id="doorHeightRow" style="display: none;">
              <span class="property-label">Opening Height</span>
              <div style="display: flex; align-items: center; gap: 8px;">
                <select class="property-select" id="propDoorHeight" onchange="updateDoorHeight()" style="flex: 1;">
                  <option value="6.67">80" - Standard Door</option>
                  <option value="6.83">82" - Standard+</option>
                  <option value="7">84" - 7 Foot</option>
                  <option value="8">96" - 8 Foot</option>
                  <option value="9">108" - 9 Foot</option>
                  <option value="10">120" - 10 Foot</option>
                  <option value="custom">Custom...</option>
                </select>
              </div>
            </div>
            <div class="property-row" id="customDoorHeightRow" style="display: none;">
              <span class="property-label">Height (ft)</span>
              <input type="number" class="property-input" id="propCustomDoorHeight" step="0.0833" min="5" max="12" onchange="applyCustomDoorHeight()">
              <span class="dimension-display" id="propDoorHeightDisplay"></span>
            </div>
            <!-- Archway style controls -->
            <div class="property-row" id="archwayStyleRow" style="display: none;">
              <span class="property-label">Arch Style</span>
              <select class="property-select" id="propArchwayStyle" onchange="updateArchwayStyle()">
                <option value="round">Round Arch</option>
                <option value="pointed">Pointed/Gothic</option>
                <option value="flat">Flat Top (Cased Opening)</option>
                <option value="elliptical">Elliptical</option>
              </select>
            </div>
            <!-- Window Style controls -->
            <div class="property-row" id="windowStyleRow" style="display: none;">
              <span class="property-label">Window Style</span>
              <select class="property-select" id="propWindowStyle" onchange="updateWindowStyle()">
                <option value="double-hung">Double-Hung</option>
                <option value="single-hung">Single-Hung</option>
                <option value="casement">Casement</option>
                <option value="sliding">Sliding</option>
                <option value="fixed">Fixed/Picture</option>
              </select>
            </div>
            <div class="property-row" id="mullionPatternRow" style="display: none;">
              <span class="property-label">Mullion Pattern</span>
              <select class="property-select" id="propMullionPattern" onchange="updateMullionPattern()">
                <option value="standard">Standard Cross</option>
                <option value="colonial">Colonial Grid</option>
                <option value="prairie">Prairie Style</option>
                <option value="none">No Grilles</option>
              </select>
            </div>
            <!-- Pony Wall / Half Wall height controls -->
            <div class="property-row" id="wallHeightRow" style="display: none;">
              <span class="property-label">Wall Height</span>
              <div style="display: flex; align-items: center; gap: 8px;">
                <select class="property-select" id="propWallHeight" onchange="updateWallHeight()" style="flex: 1;">
                  <option value="2">24" - Knee Wall</option>
                  <option value="2.5">30" - Low Pony</option>
                  <option value="3">36" - Counter Height</option>
                  <option value="3.5">42" - Standard Pony</option>
                  <option value="4">48" - Bar Height</option>
                  <option value="custom">Custom...</option>
                </select>
              </div>
            </div>
            <div class="property-row" id="customWallHeightRow" style="display: none;">
              <span class="property-label">Height (ft)</span>
              <input type="number" class="property-input" id="propCustomWallHeight" step="0.0833" min="1" max="8" onchange="applyCustomWallHeight()">
              <span class="dimension-display" id="propWallHeightDisplay"></span>
            </div>
            <!-- Full-height wall controls (masonry, concrete, etc.) -->
            <div class="property-row" id="fullWallHeightRow" style="display: none;">
              <span class="property-label">Wall Height</span>
              <div style="display: flex; align-items: center; gap: 8px;">
                <select class="property-select" id="propFullWallHeight" onchange="updateFullWallHeight()" style="flex: 1;">
                  <option value="ceiling">To Ceiling</option>
                  <option value="8">8' (96")</option>
                  <option value="9">9' (108")</option>
                  <option value="10">10' (120")</option>
                  <option value="12">12' (144")</option>
                  <option value="14">14' (168")</option>
                  <option value="16">16' (192")</option>
                  <option value="custom">Custom...</option>
                </select>
              </div>
            </div>
            <div class="property-row" id="customFullWallHeightRow" style="display: none;">
              <span class="property-label">Height (ft)</span>
              <div class="dimension-input-group">
                <input type="text" class="property-input dimension-input" id="propCustomFullWallHeight" placeholder="8" onchange="applyCustomFullWallHeight()">
                <span class="dimension-display" id="propFullWallHeightDisplay"></span>
              </div>
            </div>
            <div class="property-row" id="wallThicknessRow" style="display: none;">
              <span class="property-label">Wall Thickness</span>
              <div style="display: flex; align-items: center; gap: 8px;">
                <select class="property-select" id="propWallThickness" onchange="updateWallThickness()" style="flex: 1;">
                  <option value="0.33">4" (2x4 stud)</option>
                  <option value="0.5">6" (2x6 stud)</option>
                  <option value="0.67">8" (CMU block)</option>
                  <option value="0.83">10" (Double CMU)</option>
                  <option value="1">12" (Concrete)</option>
                  <option value="1.33">16" (Heavy)</option>
                  <option value="custom">Custom...</option>
                </select>
              </div>
            </div>
            <div class="property-row" id="customWallThicknessRow" style="display: none;">
              <span class="property-label">Thickness (ft)</span>
              <div class="dimension-input-group">
                <input type="text" class="property-input dimension-input" id="propCustomWallThickness" placeholder="0.5" onchange="applyCustomWallThickness()">
                <span class="dimension-display" id="propWallThicknessDisplay"></span>
              </div>
            </div>
            <!-- Niche depth controls -->
            <div class="property-row" id="nicheDepthRow" style="display: none;">
              <span class="property-label">Recess Depth</span>
              <div style="display: flex; align-items: center; gap: 8px;">
                <select class="property-select" id="propNicheDepth" onchange="updateNicheDepth()" style="flex: 1;">
                  <option value="0.25">3" - Shallow</option>
                  <option value="0.33">4" - Standard</option>
                  <option value="0.5">6" - Deep</option>
                  <option value="0.67">8" - TV Recess</option>
                  <option value="1">12" - Fireplace</option>
                  <option value="1.5">18" - Deep Fireplace</option>
                  <option value="custom">Custom...</option>
                </select>
              </div>
            </div>
            <div class="property-row" id="customNicheDepthRow" style="display: none;">
              <span class="property-label">Depth (ft)</span>
              <input type="number" class="property-input" id="propCustomNicheDepth" step="0.0833" min="0.1" max="3" onchange="applyCustomNicheDepth()">
              <span class="dimension-display" id="propNicheDepthDisplay"></span>
            </div>
            <!-- Stone surface thickness controls -->
            <div class="property-row" id="stoneThicknessRow" style="display: none;">
              <span class="property-label">Stone Thickness</span>
              <div style="display: flex; align-items: center; gap: 8px;">
                <select class="property-select" id="propStoneThickness" onchange="updateStoneThickness()" style="flex: 1;">
                  <option value="0.0625">3/4" (2cm)</option>
                  <option value="0.1">1.25" (3cm)</option>
                  <option value="0.125">1.5"</option>
                  <option value="0.17">2"</option>
                  <option value="0.25">3"</option>
                </select>
              </div>
            </div>
            <!-- Cap height control for wall caps/bar tops -->
            <div class="property-row" id="capHeightRow" style="display: none;">
              <span class="property-label">Cap Height</span>
              <div style="display: flex; align-items: center; gap: 8px;">
                <select class="property-select" id="propCapHeight" onchange="updateCapHeight()" style="flex: 1;">
                  <option value="2">2' (24") - Knee wall</option>
                  <option value="2.5">2.5' (30")</option>
                  <option value="3">3' (36") - Standard counter</option>
                  <option value="3.5">3.5' (42") - Pony wall</option>
                  <option value="4">4' (48") - Bar height</option>
                  <option value="custom">Custom...</option>
                </select>
              </div>
            </div>
            <div class="property-row" id="customCapHeightRow" style="display: none;">
              <span class="property-label">Height (ft)</span>
              <input type="number" class="property-input" id="propCustomCapHeight" step="0.0833" min="0.5" max="8" onchange="applyCustomCapHeight()">
              <span class="dimension-display" id="propCapHeightDisplay"></span>
            </div>
            <!-- Edge preview button -->
            <div class="property-row" id="edgePreviewBtnRow" style="display: none;">
              <button class="btn btn-secondary" style="width: 100%; padding: 8px;" onclick="showEdgePreviewModal(selectedElement)">
                View Edge Profile 3D
              </button>
            </div>
            <div class="property-row" id="edgeProfileRow" style="display: none;">
              <span class="property-label">Edge Profile</span>
              <select class="property-select" id="propEdgeProfile" onchange="updateSelectedEdgeProfile()">
                <optgroup label=" Most Durable">
                  <option value="full-bullnose">Full Bullnose - Fully rounded, nearly indestructible</option>
                  <option value="half-bullnose">Half Bullnose - Rounded top, flat bottom</option>
                </optgroup>
                <optgroup label=" Durable">
                  <option value="eased">Eased (Standard) - Slight round on top edge</option>
                  <option value="flat-polish">Flat Polish - Square edge, polished face</option>
                  <option value="pencil">Pencil Round - Very small radius</option>
                  <option value="quarter-round">Quarter Round - Quarter circle top</option>
                  <option value="quarter-bevel">Quarter Bevel - 45 chamfer top</option>
                </optgroup>
                <optgroup label=" Laminated (2cm buildup)">
                  <option value="mitered">Mitered Edge - 45 laminated, appears thicker</option>
                </optgroup>
                <optgroup label=" Decorative">
                  <option value="dupont">Dupont (+$30/LF) - Stepped with bullnose</option>
                  <option value="cove">Cove (+$20/LF) - Concave inward curve</option>
                  <option value="ogee">Ogee (+$25/LF) - Classic S-curve</option>
                  <option value="double-ogee">Double Ogee (+$35/LF) - Double S-curve</option>
                  <option value="chiseled">Chiseled (+$40/LF) - Rough textured</option>
                </optgroup>
                <optgroup label=" Waterfall">
                  <option value="waterfall">Waterfall - 90 turn with mitered corner</option>
                </optgroup>
              </select>
            </div>
            <!-- Edge profile info -->
            <div class="property-row" id="edgeProfileInfoRow" style="display: none;">
              <div id="edgeProfileInfo" style="font-size: 11px; color: rgba(255,255,255,0.6); padding: 6px 8px; background: rgba(0,0,0,0.2); border-radius: 4px; line-height: 1.4;"></div>
            </div>
            <div class="property-row" id="thicknessRow" style="display: none;">
              <span class="property-label">Slab Thickness</span>
              <select class="property-select" id="propThickness" onchange="updateCountertopThickness()">
                <option value="3cm">3cm (1.25") - Standard</option>
                <option value="2cm">2cm (0.75") - Requires Edge Buildup</option>
              </select>
            </div>
            <div class="property-row" id="edgeStyleRow" style="display: none;">
              <span class="property-label">Edge Buildup (2cm)</span>
              <select class="property-select" id="propEdgeStyle" onchange="updateCountertopThickness()">
                <option value="laminated">Laminated (4cm look)</option>
                <option value="mitered">Mitered (45 seam)</option>
                <option value="stacked">Stacked (vertical seam)</option>
              </select>
            </div>
            <!-- Waterfall Sides - Always visible prominent option for countertops -->
            <div class="property-row waterfall-section-header" id="waterfallSectionRow" style="display: none;">
              <div style="width: 100%; padding: 8px 0; border-top: 1px solid rgba(255,255,255,0.1); margin-top: 8px;">
                <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 10px;">
                  <span style="font-weight: 600; color: #f9cb00; font-size: 13px;">WATERFALL SIDES</span>
                  <span style="font-size: 11px; color: rgba(255,255,255,0.5);">Stone drops to floor</span>
                </div>
                <div class="checkbox-group" style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                  <label class="waterfall-checkbox-label" style="display: flex; align-items: center; gap: 6px; padding: 8px 12px; background: rgba(255,255,255,0.05); border-radius: 6px; cursor: pointer; transition: all 0.2s;">
                    <input type="checkbox" id="propWaterfallLeft" onchange="updateWaterfallSides()" style="width: 18px; height: 18px; accent-color: #f9cb00;">
                    <span style="font-size: 13px;">Left Side</span>
                  </label>
                  <label class="waterfall-checkbox-label" style="display: flex; align-items: center; gap: 6px; padding: 8px 12px; background: rgba(255,255,255,0.05); border-radius: 6px; cursor: pointer; transition: all 0.2s;">
                    <input type="checkbox" id="propWaterfallRight" onchange="updateWaterfallSides()" style="width: 18px; height: 18px; accent-color: #f9cb00;">
                    <span style="font-size: 13px;">Right Side</span>
                  </label>
                  <label class="waterfall-checkbox-label" style="display: flex; align-items: center; gap: 6px; padding: 8px 12px; background: rgba(255,255,255,0.05); border-radius: 6px; cursor: pointer; transition: all 0.2s;">
                    <input type="checkbox" id="propWaterfallFront" onchange="updateWaterfallSides()" style="width: 18px; height: 18px; accent-color: #f9cb00;">
                    <span style="font-size: 13px;">Front</span>
                  </label>
                  <label class="waterfall-checkbox-label" style="display: flex; align-items: center; gap: 6px; padding: 8px 12px; background: rgba(255,255,255,0.05); border-radius: 6px; cursor: pointer; transition: all 0.2s;">
                    <input type="checkbox" id="propWaterfallBack" onchange="updateWaterfallSides()" style="width: 18px; height: 18px; accent-color: #f9cb00;">
                    <span style="font-size: 13px;">Back</span>
                  </label>
                </div>
              </div>
            </div>
            <div class="property-row" id="waterfallHeightRow" style="display: none;">
              <span class="property-label">Waterfall Drop</span>
              <select class="property-select" id="propWaterfallHeight" onchange="updateWaterfallHeight()">
                <option value="2.5">2.5' (30") - Counter height</option>
                <option value="2.9" selected>2.9' (35") - Standard</option>
                <option value="3">3' (36") - Island height</option>
                <option value="floor">To Floor</option>
                <option value="custom">Custom...</option>
              </select>
            </div>
            <!-- Legacy waterfall row (hidden, kept for compatibility) -->
            <div class="property-row" id="waterfallRow" style="display: none;"></div>
            <!-- Overhang Controls for Islands, Bars, etc. -->
            <div class="property-row overhang-section" id="overhangSectionRow" style="display: none;">
              <div style="width: 100%; padding: 8px 0; border-top: 1px solid rgba(255,255,255,0.1); margin-top: 8px;">
                <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 10px;">
                  <span style="font-weight: 600; color: #4ade80; font-size: 13px;">OVERHANG</span>
                  <select class="property-select" id="propOverhangPreset" onchange="applyOverhangPreset()" style="width: auto; padding: 4px 8px; font-size: 11px;">
                    <option value="">Custom</option>
                    <option value="standard">Standard (2" front)</option>
                    <option value="island">Island (2" all)</option>
                    <option value="bar">Bar Seating (12")</option>
                    <option value="breakfast">Breakfast Bar (15")</option>
                    <option value="ada">ADA Accessible (19")</option>
                  </select>
                </div>
                <!-- Fabrication warning area -->
                <div id="overhangWarning" style="display: none; background: rgba(245, 158, 11, 0.15); border: 1px solid rgba(245, 158, 11, 0.3); border-radius: 6px; padding: 8px; margin-bottom: 10px; font-size: 11px;">
                  <div style="display: flex; align-items: flex-start; gap: 6px;">
                    <span style="color: #f59e0b;"></span>
                    <div id="overhangWarningText" style="color: #fbbf24; line-height: 1.4;"></div>
                  </div>
                </div>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                  <div style="display: flex; flex-direction: column; gap: 4px;">
                    <label style="font-size: 11px; color: rgba(255,255,255,0.6);">Front</label>
                    <div style="display: flex; align-items: center; gap: 4px;">
                      <input type="number" id="propOverhangFront" min="0" max="24" step="0.5" value="2"
                        onchange="updateOverhang()" style="width: 60px; padding: 6px; border-radius: 4px; border: 1px solid rgba(255,255,255,0.2); background: rgba(0,0,0,0.3); color: #fff; font-size: 12px;">
                      <span style="font-size: 11px; color: rgba(255,255,255,0.5);">in</span>
                    </div>
                  </div>
                  <div style="display: flex; flex-direction: column; gap: 4px;">
                    <label style="font-size: 11px; color: rgba(255,255,255,0.6);">Back</label>
                    <div style="display: flex; align-items: center; gap: 4px;">
                      <input type="number" id="propOverhangBack" min="0" max="24" step="0.5" value="0"
                        onchange="updateOverhang()" style="width: 60px; padding: 6px; border-radius: 4px; border: 1px solid rgba(255,255,255,0.2); background: rgba(0,0,0,0.3); color: #fff; font-size: 12px;">
                      <span style="font-size: 11px; color: rgba(255,255,255,0.5);">in</span>
                    </div>
                  </div>
                  <div style="display: flex; flex-direction: column; gap: 4px;">
                    <label style="font-size: 11px; color: rgba(255,255,255,0.6);">Left</label>
                    <div style="display: flex; align-items: center; gap: 4px;">
                      <input type="number" id="propOverhangLeft" min="0" max="24" step="0.5" value="1.5"
                        onchange="updateOverhang()" style="width: 60px; padding: 6px; border-radius: 4px; border: 1px solid rgba(255,255,255,0.2); background: rgba(0,0,0,0.3); color: #fff; font-size: 12px;">
                      <span style="font-size: 11px; color: rgba(255,255,255,0.5);">in</span>
                    </div>
                  </div>
                  <div style="display: flex; flex-direction: column; gap: 4px;">
                    <label style="font-size: 11px; color: rgba(255,255,255,0.6);">Right</label>
                    <div style="display: flex; align-items: center; gap: 4px;">
                      <input type="number" id="propOverhangRight" min="0" max="24" step="0.5" value="1.5"
                        onchange="updateOverhang()" style="width: 60px; padding: 6px; border-radius: 4px; border: 1px solid rgba(255,255,255,0.2); background: rgba(0,0,0,0.3); color: #fff; font-size: 12px;">
                      <span style="font-size: 11px; color: rgba(255,255,255,0.5);">in</span>
                    </div>
                  </div>
                </div>
              </div>
            </div>
            <div class="property-row" id="backsplashRow" style="display: none;">
              <span class="property-label">Backsplash</span>
              <select class="property-select" id="propBacksplash" onchange="updateBacksplash()">
                <option value="none">None</option>
                <option value="4">4" Standard</option>
                <option value="6">6" Raised</option>
                <option value="18">18" Mid-Height</option>
                <option value="full">Full Height</option>
              </select>
            </div>
            <div class="property-row" id="finishedEndsRow" style="display: none;">
              <span class="property-label">Finished Ends</span>
              <div class="checkbox-group">
                <label><input type="checkbox" id="propFinishedLeft" onchange="updateFinishedEnds()"> Left</label>
                <label><input type="checkbox" id="propFinishedRight" onchange="updateFinishedEnds()"> Right</label>
              </div>
            </div>
            <div class="property-row" id="seamsRow" style="display: none;">
              <span class="property-label">Seams & Slabs</span>
              <div style="display: flex; flex-direction: column; gap: 8px; width: 100%;">
                <!-- Slab Dimensions Info -->
                <div id="slabDimensionsInfo" style="font-size: 11px; padding: 8px; background: rgba(59, 130, 246, 0.1); border-radius: 4px; border-left: 3px solid #3b82f6;">
                  <div style="color: #93c5fd; margin-bottom: 4px; font-weight: 600;"> Slab Sizes</div>
                  <div style="color: #bfdbfe; line-height: 1.5;">
                    <div>Standard: <strong>120"  60"</strong> (10'  5')</div>
                    <div>Jumbo: <strong>130"  68"</strong> (10'10"  5'8")</div>
                  </div>
                </div>
                <!-- Countertop Dimensions -->
                <div id="countertopDimensionsInfo" style="font-size: 11px; padding: 8px; background: rgba(16, 185, 129, 0.1); border-radius: 4px; border-left: 3px solid #10b981;">
                  <div style="color: #6ee7b7; margin-bottom: 4px; font-weight: 600;"> This Countertop</div>
                  <div style="color: #a7f3d0; line-height: 1.5;">
                    <span id="ctopDimensions">--  --</span>
                    <span id="ctopSeamStatus" style="margin-left: 8px; padding: 2px 6px; border-radius: 3px; font-size: 10px;"></span>
                  </div>
                </div>
                <!-- Seam Controls -->
                <div class="seam-controls">
                  <button class="seam-btn" onclick="addSeamToCountertop()" title="Add seam at optimal position">+ Auto</button>
                  <button class="seam-btn" id="seamPlaceModeBtn" onclick="toggleSeamPlacementMode()"
                    style="background: rgba(139, 92, 246, 0.3);" title="Click on countertop to place seam"> Click to Place</button>
                  <span class="seam-count" id="seamCount">0 seams</span>
                  <button class="seam-btn seam-clear" onclick="clearSeams()" title="Remove all seams">Clear</button>
                </div>
                <!-- Individual Seam List -->
                <div id="seamListContainer" style="display: none; max-height: 150px; overflow-y: auto;">
                  <div id="seamList" style="display: flex; flex-direction: column; gap: 4px;"></div>
                </div>
                <!-- Piece Dimensions After Seams -->
                <div id="pieceDimensionsInfo" style="display: none; font-size: 11px; padding: 8px; background: rgba(245, 158, 11, 0.1); border-radius: 4px; border-left: 3px solid #f59e0b;">
                  <div style="color: #fcd34d; margin-bottom: 4px; font-weight: 600;"> Resulting Pieces</div>
                  <div id="piecesList" style="color: #fde68a; line-height: 1.5;"></div>
                </div>
                <!-- Seam Requirement Warning -->
                <div id="seamRequirementInfo" style="display: none; font-size: 11px; padding: 6px 8px; background: rgba(239, 68, 68, 0.15); border-radius: 4px; border-left: 3px solid #ef4444;">
                  <span id="seamRequirementText" style="color: #fca5a5; line-height: 1.4;"></span>
                </div>
              </div>
            </div>
            <!-- Sink-specific properties -->
            <div class="property-row" id="sinkColorRow" style="display: none;">
              <span class="property-label">Sink Finish</span>
              <select class="property-select" id="propSinkColor" onchange="updateSinkProperties()">
                <option value="stainless">Stainless Steel</option>
                <option value="black">Matte Black</option>
                <option value="white">White</option>
                <option value="graphite">Graphite</option>
                <option value="bisque">Bisque</option>
                <option value="bronze">Oil-Rubbed Bronze</option>
              </select>
            </div>
            <div class="property-row" id="sinkMountRow" style="display: none;">
              <span class="property-label">Mount Type</span>
              <select class="property-select" id="propSinkMount" onchange="updateSinkProperties()">
                <option value="undermount">Undermount</option>
                <option value="topmount">Top Mount</option>
                <option value="farmhouse">Farmhouse/Apron</option>
              </select>
            </div>
            <div class="property-row">
              <span class="property-label">Color</span>
              <input type="color" class="color-picker" id="propColor" onchange="updateSelectedElement()">
            </div>
            <div class="property-row">
              <span class="property-label">Texture</span>
              <div class="texture-controls">
                <div class="texture-preview" id="propTexture" onclick="openMaterialPicker()" title="Click to browse materials"></div>
                <button class="texture-upload-btn" onclick="quickUploadTexture()" title="Upload custom image">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                    <polyline points="17 8 12 3 7 8"/>
                    <line x1="12" y1="3" x2="12" y2="15"/>
                  </svg>
                </button>
                <button class="texture-clear-btn" onclick="clearTexture()" title="Clear texture"></button>
              </div>
            </div>
            <div class="property-row" id="materialNameRow" style="display: none;">
              <span class="property-label">Material</span>
              <span class="property-value" id="propMaterialName" style="font-size: 12px; color: var(--primary-color);">-</span>
            </div>
            <div class="property-row">
              <span class="property-label">Rotation</span>
              <span class="property-value" id="propRotation">0</span>
            </div>
            <div class="property-row" id="areaMeasureRow">
              <span class="property-label">Area</span>
              <span class="property-value" id="propArea" style="font-size: 11px; color: rgba(255,255,255,0.7);">-</span>
            </div>
            <div class="property-row" id="perimeterMeasureRow">
              <span class="property-label">Perimeter</span>
              <span class="property-value" id="propPerimeter" style="font-size: 11px; color: rgba(255,255,255,0.7);">-</span>
            </div>
            <div class="property-row" id="grainDirectionRow" style="display: none;">
              <span class="property-label">Grain/Tile Dir</span>
              <div class="grain-direction-controls">
                <button class="grain-btn" data-dir="0" onclick="setGrainDirection(0)" title="Horizontal ()"></button>
                <button class="grain-btn" data-dir="90" onclick="setGrainDirection(90)" title="Vertical ()"></button>
                <button class="grain-btn" data-dir="45" onclick="setGrainDirection(45)" title="Diagonal ()"></button>
                <button class="grain-btn" data-dir="135" onclick="setGrainDirection(135)" title="Diagonal ()"></button>
              </div>
            </div>

            <!-- Structural Element Controls -->
            <div class="property-row" id="beamDepthRow" style="display: none;">
              <span class="property-label">Beam Depth</span>
              <select class="property-select" id="propBeamDepth" onchange="updateBeamDepth()">
                <option value="0.33">4" (Header)</option>
                <option value="0.5">6" (W6)</option>
                <option value="0.67">8" (W8)</option>
                <option value="0.83">10" (W10)</option>
                <option value="1">12" (W12)</option>
                <option value="1.17">14" (W14)</option>
                <option value="custom">Custom...</option>
              </select>
            </div>
            <div class="property-row" id="customBeamDepthRow" style="display: none;">
              <span class="property-label">Custom Depth</span>
              <div class="dimension-input-group">
                <input type="text" class="property-input dimension-input" id="propCustomBeamDepth" placeholder="0.67" onchange="applyCustomBeamDepth()">
                <span class="dimension-display" id="propBeamDepthDisplay"></span>
              </div>
            </div>
            <div class="property-row" id="beamElevationRow" style="display: none;">
              <span class="property-label">Elevation</span>
              <select class="property-select" id="propBeamElevation" onchange="updateBeamElevation()">
                <option value="ceiling">At Ceiling</option>
                <option value="7">7' (84")</option>
                <option value="7.5">7'-6" (90")</option>
                <option value="8">8' (96")</option>
                <option value="9">9' (108")</option>
                <option value="10">10' (120")</option>
                <option value="custom">Custom...</option>
              </select>
            </div>
            <div class="property-row" id="customBeamElevationRow" style="display: none;">
              <span class="property-label">Custom Elev</span>
              <div class="dimension-input-group">
                <input type="text" class="property-input dimension-input" id="propCustomBeamElevation" placeholder="8" onchange="applyCustomBeamElevation()">
                <span class="dimension-display" id="propBeamElevationDisplay"></span>
              </div>
            </div>
            <div class="property-row" id="columnHeightRow" style="display: none;">
              <span class="property-label">Column Height</span>
              <select class="property-select" id="propColumnHeight" onchange="updateColumnHeight()">
                <option value="ceiling">Floor to Ceiling</option>
                <option value="8">8' (96")</option>
                <option value="9">9' (108")</option>
                <option value="10">10' (120")</option>
                <option value="12">12' (144")</option>
                <option value="custom">Custom...</option>
              </select>
            </div>
            <div class="property-row" id="customColumnHeightRow" style="display: none;">
              <span class="property-label">Custom Height</span>
              <div class="dimension-input-group">
                <input type="text" class="property-input dimension-input" id="propCustomColumnHeight" placeholder="8" onchange="applyCustomColumnHeight()">
                <span class="dimension-display" id="propColumnHeightDisplay"></span>
              </div>
            </div>
            <div class="property-row" id="columnSizeRow" style="display: none;">
              <span class="property-label">Column Size</span>
              <select class="property-select" id="propColumnSize" onchange="updateColumnSize()">
                <option value="0.33">4"4" (Post)</option>
                <option value="0.5">6"6" (HSS 6)</option>
                <option value="0.67">8"8" (HSS 8)</option>
                <option value="1">12"12" (Concrete)</option>
                <option value="1.33">16"16" (Large)</option>
                <option value="custom">Custom...</option>
              </select>
            </div>

            <!-- Surface Finish Picker -->
            <div class="property-row" id="finishRow" style="display:none">
              <span class="property-label">Finish</span>
              <div id="finishPicker" class="finish-picker"></div>
            </div>
            <!-- Generic 3D Height Override -->
            <div class="property-row" id="generic3DHeightRow" style="display:none">
              <span class="property-label">3D Height</span>
              <div style="display: flex; align-items: center; gap: 8px;">
                <select class="property-select" id="propGeneric3DHeight" onchange="updateGeneric3DHeight()" style="flex: 1;">
                  <option value="default">Default</option>
                  <option value="0.5">6" (0.5')</option>
                  <option value="1">12" (1')</option>
                  <option value="1.5">18" (1.5')</option>
                  <option value="2">24" (2')</option>
                  <option value="2.5">30" (2.5')</option>
                  <option value="3">36" (3')</option>
                  <option value="3.5">42" (3.5')</option>
                  <option value="4">48" (4')</option>
                  <option value="5">60" (5')</option>
                  <option value="6">72" (6')</option>
                  <option value="7">84" (7')</option>
                  <option value="8">96" (8')</option>
                  <option value="custom">Custom...</option>
                </select>
              </div>
            </div>
            <div class="property-row" id="customGeneric3DHeightRow" style="display:none">
              <span class="property-label">Height (ft)</span>
              <input type="number" class="property-input" id="propCustomGeneric3DHeight" step="0.0833" min="0.1" max="20" onchange="applyCustomGeneric3DHeight()">
            </div>
            <!-- Pricing Section -->
            <div class="pricing-section" id="pricingSection">
              <div class="property-section-title">Pricing</div>
              <div class="property-row">
                <span class="property-label">Base Price</span>
                <span class="property-value" id="propBasePrice">$0.00</span>
              </div>
              <div class="property-row">
                <span class="property-label">Override</span>
                <div class="price-override-group">
                  <input type="number" class="property-input price-input" id="propPriceOverride" placeholder="Auto" step="0.01" min="0" onchange="updateElementPrice()">
                  <select class="property-select-sm" id="propPriceUnit" onchange="updateElementPrice()">
                    <option value="sqft">/sqft</option>
                    <option value="linear_ft">/lf</option>
                    <option value="unit">each</option>
                  </select>
                </div>
              </div>
              <div class="property-row">
                <span class="property-label">Margin %</span>
                <input type="number" class="property-input margin-input" id="propMargin" placeholder="Default" step="1" min="0" max="200" onchange="updateElementPrice()">
              </div>
              <div class="property-row price-result">
                <span class="property-label">Item Total</span>
                <span class="property-value price-highlight" id="propItemTotal">$0.00</span>
              </div>
            </div>
          </div>
        </div>

        <!-- Building Code Validation -->
        <div class="validation-section" id="validationPanel">
          <div class="panel-section">
            <div class="panel-title">
              Building Standards
              <button class="validation-toggle" onclick="toggleWorkTriangle()" title="Toggle work triangle"></button>
              <button class="validation-refresh" onclick="runValidation()" title="Check design"></button>
            </div>
          </div>
          <div class="validation-content" id="validationContent">
            <div class="validation-hint">Click  to validate your design</div>
          </div>
        </div>

        <div class="quote-section" id="quotePanel">
          <div class="panel-section">
            <div class="quote-header">
              <div class="panel-title">Takeoff Summary</div>
              <div class="quote-view-toggle">
                <button class="toggle-btn active" id="retailViewBtn" onclick="setQuoteView('retail')" title="Show retail prices">Retail</button>
                <button class="toggle-btn" id="costViewBtn" onclick="setQuoteView('cost')" title="Show cost prices">Cost</button>
              </div>
            </div>
          </div>
          <!-- Quick Takeoff Stats -->
          <div id="takeoffQuickStats" style="padding: 0 12px 12px; display: none;">
            <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px;">
              <div style="background: rgba(99, 102, 241, 0.15); border: 1px solid rgba(99, 102, 241, 0.3); border-radius: 8px; padding: 10px; text-align: center;">
                <div style="font-size: 20px; font-weight: 700; color: #818cf8;" id="quickSlabCount">0</div>
                <div style="font-size: 10px; color: rgba(255,255,255,0.6); text-transform: uppercase;">Slabs</div>
              </div>
              <div style="background: rgba(16, 185, 129, 0.15); border: 1px solid rgba(16, 185, 129, 0.3); border-radius: 8px; padding: 10px; text-align: center;">
                <div style="font-size: 20px; font-weight: 700; color: #34d399;" id="quickCabinetCount">0</div>
                <div style="font-size: 10px; color: rgba(255,255,255,0.6); text-transform: uppercase;">Cabinets</div>
              </div>
            </div>
            <button class="btn btn-sm btn-secondary" onclick="generateTakeoffReport()" style="width: 100%; margin-top: 8px; font-size: 11px;">
              View Full Takeoffs 
            </button>
          </div>
          <!-- Room Selector -->
          <div class="room-selector-bar" style="padding: 8px 12px; border-bottom: 1px solid var(--border);">
            <div style="display: flex; align-items: center; gap: 8px;">
              <select id="currentRoomSelect" class="property-select" style="flex: 1; font-size: 12px;" onchange="switchRoom(this.value)">
                <option value="default">Default Room</option>
              </select>
              <button class="btn btn-sm btn-icon" onclick="openRoomManager()" title="Manage Rooms">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:14px;height:14px;">
                  <rect x="3" y="3" width="7" height="7"/><rect x="14" y="3" width="7" height="7"/>
                  <rect x="3" y="14" width="7" height="7"/><rect x="14" y="14" width="7" height="7"/>
                </svg>
              </button>
            </div>
          </div>
          <div class="quote-actions">
            <button class="btn btn-sm btn-secondary" onclick="openPriceListModal()" title="Upload or manage price lists">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:14px;height:14px;margin-right:4px;">
                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                <polyline points="17 8 12 3 7 8"/>
                <line x1="12" y1="3" x2="12" y2="15"/>
              </svg>
              Price List
            </button>
            <button class="btn btn-sm btn-secondary" onclick="openMarginModal()" title="Configure profit margins">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:14px;height:14px;margin-right:4px;">
                <line x1="19" y1="5" x2="5" y2="19"/>
                <circle cx="6.5" cy="6.5" r="2.5"/>
                <circle cx="17.5" cy="17.5" r="2.5"/>
              </svg>
              Margins
            </button>
          </div>
          <div class="quote-items" id="quoteItems">
            <div class="quote-item">
              <span class="quote-item-name">No items yet</span>
              <span class="quote-item-value">$0</span>
            </div>
          </div>
          <div class="quote-summary">
            <div class="quote-row" id="quoteCostRow" style="display: none;">
              <span>Material Cost</span>
              <span id="quoteCost">$0.00</span>
            </div>
            <div class="quote-row" id="quoteMarginRow" style="display: none;">
              <span>Markup</span>
              <span id="quoteMargin">$0.00</span>
            </div>
            <div class="quote-total">
              <div class="quote-total-row">
                <span class="quote-total-label">Estimated Total</span>
                <span class="quote-total-value" id="quoteTotal">$0</span>
              </div>
            </div>
            <!-- Quote Actions -->
            <div class="quote-send-actions" id="quoteSendActions" style="margin-top: 12px; display: flex; gap: 8px;">
              <button class="btn btn-primary" onclick="openQuotePreview()" style="flex: 1; font-size: 12px; padding: 10px;">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:14px;height:14px;margin-right:6px;">
                  <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
                  <polyline points="14 2 14 8 20 8"/>
                  <line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/>
                </svg>
                Preview Quote
              </button>
              <button class="btn btn-secondary" onclick="shareQuoteLink()" style="padding: 10px;" title="Get shareable link">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:14px;height:14px;">
                  <circle cx="18" cy="5" r="3"/><circle cx="6" cy="12" r="3"/><circle cx="18" cy="19" r="3"/>
                  <line x1="8.59" y1="13.51" x2="15.42" y2="17.49"/>
                  <line x1="15.41" y1="6.51" x2="8.59" y2="10.49"/>
                </svg>
              </button>
            </div>
            <!-- Payment Actions -->
            <div class="quote-actions" id="quoteActions" style="margin-top: 8px; display: none;">
              <button class="btn-checkout" onclick="openPaymentModal()" id="checkoutBtn">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:16px;height:16px;margin-right:6px;">
                  <rect x="1" y="4" width="22" height="16" rx="2"/><line x1="1" y1="10" x2="23" y2="10"/>
                </svg>
                Pay Deposit & Schedule
              </button>
              <p class="quote-disclaimer">10% deposit required to schedule consultation</p>
            </div>
          </div>
        </div>
      </aside>
    </main>
  </div>

  <!-- Payment Modal -->
  <div class="payment-modal-overlay" id="paymentModal" style="display: none;">
    <div class="payment-modal">
      <div class="payment-modal-header">
        <h2>Complete Your Order</h2>
        <button class="payment-modal-close" onclick="closePaymentModal()">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="20" height="20">
            <line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/>
          </svg>
        </button>
      </div>
      <div class="payment-modal-body">
        <!-- Design Summary -->
        <div class="payment-summary">
          <div class="payment-summary-row">
            <span class="label">Design Name</span>
            <span class="value" id="paymentDesignName">Kitchen Design</span>
          </div>
          <div class="payment-summary-row">
            <span class="label">Countertop Material</span>
            <span class="value" id="paymentMaterial">-</span>
          </div>
          <div class="payment-summary-row">
            <span class="label">Square Footage</span>
            <span class="value" id="paymentSqft">0 sq ft</span>
          </div>
          <div class="payment-summary-row total">
            <span class="label">Project Estimate</span>
            <span class="value" id="paymentTotal">$0</span>
          </div>
        </div>

        <!-- Payment Options -->
        <div class="payment-options">
          <div class="payment-option selected" onclick="selectPaymentOption('deposit')" id="optionDeposit">
            <div class="payment-option-header">
              <span class="payment-option-title">10% Deposit</span>
              <span class="payment-option-amount" id="depositAmount">$0</span>
            </div>
            <p class="payment-option-desc">Reserve your consultation and lock in pricing. Remainder due at installation.</p>
          </div>
          <div class="payment-option" onclick="selectPaymentOption('consultation')" id="optionConsultation">
            <div class="payment-option-header">
              <span class="payment-option-title">Design Consultation</span>
              <span class="payment-option-amount">$99</span>
            </div>
            <p class="payment-option-desc">1-hour in-home or virtual consultation with our design expert. Applied to project if you proceed.</p>
          </div>
          <div class="payment-option" onclick="selectPaymentOption('full')" id="optionFull">
            <div class="payment-option-header">
              <span class="payment-option-title">Full Payment</span>
              <span class="payment-option-amount" id="fullAmount">$0</span>
            </div>
            <p class="payment-option-desc">Pay in full and receive 5% discount. Fastest scheduling priority.</p>
          </div>
        </div>

        <!-- Contact Info -->
        <div class="payment-form-group">
          <label>Email Address</label>
          <input type="email" id="paymentEmail" placeholder="you@example.com" required>
        </div>
        <div class="payment-form-group">
          <label>Phone Number</label>
          <input type="tel" id="paymentPhone" placeholder="(555) 123-4567">
        </div>

        <!-- Submit -->
        <button class="payment-submit" onclick="processPayment()" id="paymentSubmitBtn">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="18" height="18">
            <rect x="1" y="4" width="22" height="16" rx="2"/><line x1="1" y1="10" x2="23" y2="10"/>
          </svg>
          <span id="paymentBtnText">Pay Deposit & Continue</span>
        </button>

        <div class="payment-secure">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <rect x="3" y="11" width="18" height="11" rx="2"/><path d="M7 11V7a5 5 0 0 1 10 0v4"/>
          </svg>
          Secured by Stripe  256-bit encryption
        </div>
      </div>
    </div>
  </div>

  <!-- Context Menu -->
  <div class="context-menu" id="contextMenu" style="display: none;">
    <div class="context-menu-label" id="contextMenuLabel">Element</div>
    <div class="context-menu-item" onclick="contextAction('rotate')">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <path d="M21 2v6h-6"/><path d="M3 12a9 9 0 0 1 15-6.7L21 8"/>
      </svg>
      Rotate 90
    </div>
    <div class="context-menu-item" onclick="contextAction('duplicate')">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <rect x="9" y="9" width="13" height="13" rx="2"/><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/>
      </svg>
      Duplicate
    </div>
    <div class="context-menu-item" id="replaceMenuItem" onclick="contextAction('replace')" style="display: none;">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <path d="M21 12a9 9 0 0 0-9-9 9 9 0 0 0-6.7 3L3 8"/><path d="M3 3v5h5"/><path d="M3 12a9 9 0 0 0 9 9 9 9 0 0 0 6.7-3l2.3-2"/><path d="M16 21v-5h5"/>
      </svg>
      Replace Cabinet...
    </div>
    <div class="context-menu-item" id="resizeMenuItem" onclick="contextAction('resize')" style="display: none;">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <path d="M21 21l-6-6m6 6v-4.8m0 4.8h-4.8"/><path d="M3 16.2V21m0 0h4.8M3 21l6-6"/><path d="M21 7.8V3m0 0h-4.8M21 3l-6 6"/><path d="M3 7.8V3m0 0h4.8M3 3l6 6"/>
      </svg>
      Resize Cabinet...
    </div>
    <div class="context-menu-item" onclick="contextAction('texture')">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <rect x="3" y="3" width="18" height="18" rx="2"/><circle cx="8.5" cy="8.5" r="1.5"/><path d="M21 15l-5-5L5 21"/>
      </svg>
      Change Texture
    </div>
    <div class="context-menu-item" onclick="contextAction('lock')">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <rect x="3" y="11" width="18" height="11" rx="2"/><path d="M7 11V7a5 5 0 0 1 10 0v4"/>
      </svg>
      <span id="lockText">Lock</span>
    </div>
    <div class="context-menu-divider"></div>
    <div class="context-menu-item" onclick="contextAction('front')">Bring to Front</div>
    <div class="context-menu-item" onclick="contextAction('back')">Send to Back</div>
    <div class="context-menu-divider"></div>
    <div class="context-menu-item danger" onclick="contextAction('delete')">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/>
      </svg>
      Delete
    </div>
  </div>

  <!-- Add Room Modal -->
  <div class="modal-overlay" id="addRoomModal" style="display: none;">
    <div class="modal" style="max-width: 400px;">
      <div class="modal-header">
        <h3>Add New Room</h3>
        <button class="close-btn" onclick="closeModal('addRoomModal')">&times;</button>
      </div>
      <div class="modal-body" style="padding: 20px;">
        <div style="display: flex; flex-direction: column; gap: 12px;">
          <div class="input-group">
            <label class="input-label" style="color: rgba(255,255,255,0.7); font-size: 12px; margin-bottom: 4px;">Room Name</label>
            <input type="text" class="input-field" id="addRoomName" placeholder="e.g. Master Bathroom" style="width: 100%;">
          </div>
          <div class="input-group">
            <label class="input-label" style="color: rgba(255,255,255,0.7); font-size: 12px; margin-bottom: 4px;">Room Type</label>
            <select class="input-field" id="addRoomType" style="width: 100%;">
              <option value="kitchen">Kitchen</option>
              <option value="bathroom">Bathroom</option>
              <option value="shower">Shower Room</option>
              <option value="closet">Walk-in Closet</option>
              <option value="laundry">Laundry</option>
              <option value="bedroom">Bedroom</option>
              <option value="living">Living Room</option>
              <option value="office">Office</option>
              <option value="commercial">Commercial</option>
            </select>
          </div>
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
            <div class="input-group">
              <label class="input-label" style="color: rgba(255,255,255,0.7); font-size: 12px; margin-bottom: 4px;">Width (ft)</label>
              <input type="number" class="input-field" id="addRoomWidth" value="12" min="4" max="100" style="width: 100%;">
            </div>
            <div class="input-group">
              <label class="input-label" style="color: rgba(255,255,255,0.7); font-size: 12px; margin-bottom: 4px;">Depth (ft)</label>
              <input type="number" class="input-field" id="addRoomDepth" value="10" min="4" max="100" style="width: 100%;">
            </div>
          </div>
          <button class="btn btn-primary" onclick="submitAddRoom()" style="width: 100%; padding: 10px; margin-top: 8px;">Create Room</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Template Selection Modal (used by mobile menu) -->
  <div class="modal-overlay" id="templateModal" style="display: none;">
    <div class="modal" style="max-width: 480px;">
      <div class="modal-header">
        <h3>Room Templates</h3>
        <button class="close-btn" onclick="closeModal('templateModal')">&times;</button>
      </div>
      <div class="modal-body" style="padding: 20px;">
        <p style="color: rgba(255,255,255,0.6); font-size: 12px; margin-bottom: 16px;">Select a template to load a preset room layout</p>
        <div class="room-templates-grid" style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px;">
          <button class="template-btn" onclick="loadRoomTemplate('kitchen-l'); closeModal('templateModal');" title="L-shaped kitchen">
            <span class="template-icon"></span><span class="template-name">L-Kitchen</span>
          </button>
          <button class="template-btn" onclick="loadRoomTemplate('kitchen-galley'); closeModal('templateModal');" title="Galley kitchen">
            <span class="template-icon"></span><span class="template-name">Galley</span>
          </button>
          <button class="template-btn" onclick="loadRoomTemplate('kitchen-u'); closeModal('templateModal');" title="U-shaped kitchen">
            <span class="template-icon"></span><span class="template-name">U-Kitchen</span>
          </button>
          <button class="template-btn" onclick="loadRoomTemplate('kitchen-single'); closeModal('templateModal');" title="Single wall kitchen">
            <span class="template-icon"></span><span class="template-name">Single Wall</span>
          </button>
          <button class="template-btn" onclick="loadRoomTemplate('kitchen-peninsula'); closeModal('templateModal');" title="Peninsula kitchen">
            <span class="template-icon"></span><span class="template-name">Peninsula</span>
          </button>
          <button class="template-btn" onclick="loadRoomTemplate('bathroom-master'); closeModal('templateModal');" title="Master bathroom">
            <span class="template-icon"></span><span class="template-name">Master Bath</span>
          </button>
          <button class="template-btn" onclick="loadRoomTemplate('bathroom-half'); closeModal('templateModal');" title="Half bathroom">
            <span class="template-icon"></span><span class="template-name">Half Bath</span>
          </button>
          <button class="template-btn" onclick="loadRoomTemplate('shower-walkin'); closeModal('templateModal');" title="Walk-in shower">
            <span class="template-icon"></span><span class="template-name">Walk-in Shower</span>
          </button>
          <button class="template-btn" onclick="loadRoomTemplate('closet-walkin'); closeModal('templateModal');" title="Walk-in closet">
            <span class="template-icon"></span><span class="template-name">Walk-in Closet</span>
          </button>
          <button class="template-btn" onclick="loadRoomTemplate('laundry-room'); closeModal('templateModal');" title="Laundry room">
            <span class="template-icon"></span><span class="template-name">Laundry</span>
          </button>
        </div>
      </div>
    </div>
  </div>

  <!-- Cabinet Replace Modal -->
  <div class="modal-overlay" id="replaceCabinetModal" style="display: none;">
    <div class="modal" style="max-width: 400px;">
      <div class="modal-header">
        <h3>Replace Cabinet</h3>
        <button class="close-btn" onclick="closeReplaceCabinetModal()">&times;</button>
      </div>
      <div class="modal-body" style="padding: 20px;">
        <p style="margin-bottom: 16px; color: #666;">Select a new cabinet type to replace the selected cabinet:</p>
        <div style="margin-bottom: 16px;">
          <label style="display: block; margin-bottom: 8px; font-weight: 500;">Cabinet Type:</label>
          <select id="replaceCabinetType" style="width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 8px; font-size: 14px;">
            <optgroup label="Base Cabinets">
              <option value="base-cabinet">Base Cabinet</option>
              <option value="drawer-base">Drawer Base</option>
              <option value="sink-base">Sink Base</option>
              <option value="corner-cabinet">Corner Cabinet</option>
              <option value="lazy-susan">Lazy Susan</option>
              <option value="blind-corner">Blind Corner</option>
            </optgroup>
            <optgroup label="Wall Cabinets">
              <option value="wall-cabinet">Wall Cabinet</option>
            </optgroup>
            <optgroup label="Tall Cabinets">
              <option value="tall-cabinet">Tall Cabinet</option>
              <option value="fridge-cabinet">Refrigerator Cabinet</option>
              <option value="single-oven-cabinet">Single Oven Cabinet</option>
              <option value="double-oven-cabinet">Double Oven Cabinet</option>
            </optgroup>
            <optgroup label="Appliances">
              <option value="dishwasher">Dishwasher</option>
              <option value="range">Range/Stove</option>
              <option value="microwave-cabinet">Microwave Cabinet</option>
            </optgroup>
            <optgroup label="Fillers">
              <option value="filler-3">Filler 3"</option>
              <option value="filler-6">Filler 6"</option>
            </optgroup>
          </select>
        </div>
        <div id="replaceCabinetSize" style="margin-bottom: 16px;">
          <label style="display: block; margin-bottom: 8px; font-weight: 500;">Width:</label>
          <select id="replaceCabinetWidth" style="width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 8px; font-size: 14px;">
            <option value="0.75">9"</option>
            <option value="1">12"</option>
            <option value="1.25">15"</option>
            <option value="1.5">18"</option>
            <option value="1.75">21"</option>
            <option value="2" selected>24"</option>
            <option value="2.25">27"</option>
            <option value="2.5">30"</option>
            <option value="2.75">33"</option>
            <option value="3">36"</option>
            <option value="3.5">42"</option>
            <option value="4">48"</option>
          </select>
        </div>
        <button onclick="applyReplaceCabinet()" style="width: 100%; padding: 12px; background: #f9cb00; border: none; border-radius: 8px; font-weight: 600; cursor: pointer; font-size: 14px;">
          Replace Cabinet
        </button>
      </div>
    </div>
  </div>

  <!-- Cabinet Resize Modal -->
  <div class="modal-overlay" id="resizeCabinetModal" style="display: none;">
    <div class="modal" style="max-width: 400px;">
      <div class="modal-header">
        <h3>Resize Cabinet</h3>
        <button class="close-btn" onclick="closeResizeCabinetModal()">&times;</button>
      </div>
      <div class="modal-body" style="padding: 20px;">
        <p style="margin-bottom: 16px; color: #666;">Select a new size for the selected cabinet:</p>
        <div style="margin-bottom: 16px;">
          <label style="display: block; margin-bottom: 8px; font-weight: 500;">Width:</label>
          <select id="resizeCabinetWidth" style="width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 8px; font-size: 14px;">
            <option value="0.75">9"</option>
            <option value="1">12"</option>
            <option value="1.25">15"</option>
            <option value="1.5">18"</option>
            <option value="1.75">21"</option>
            <option value="2">24"</option>
            <option value="2.25">27"</option>
            <option value="2.5">30"</option>
            <option value="2.75">33"</option>
            <option value="3">36"</option>
            <option value="3.5">42"</option>
            <option value="4">48"</option>
          </select>
        </div>
        <button onclick="applyResizeCabinet()" style="width: 100%; padding: 12px; background: #f9cb00; border: none; border-radius: 8px; font-weight: 600; cursor: pointer; font-size: 14px;">
          Apply Size
        </button>
      </div>
    </div>
  </div>

  <!-- 3D Tooltip -->
  <div id="tooltip3D" style="display: none; position: fixed; background: rgba(0,0,0,0.85); color: white; padding: 8px 12px; border-radius: 6px; font-size: 12px; pointer-events: none; z-index: 10000; max-width: 200px; box-shadow: 0 2px 10px rgba(0,0,0,0.3);">
    <div id="tooltip3DLabel" style="font-weight: bold; margin-bottom: 4px;"></div>
    <div id="tooltip3DSize" style="color: #ccc; font-size: 11px;"></div>
  </div>

  <!-- Share Modal - Enhanced -->
  <div class="modal-overlay" id="shareModal">
    <div class="modal" style="max-width: 500px;">
      <div class="modal-header">
        <h3 class="modal-title">Share Project</h3>
        <button class="modal-close" onclick="closeModal('shareModal')"></button>
      </div>

      <div class="share-status" id="shareStatus">
        <span class="status-indicator"></span>
        <span id="shareStatusText">Not shared yet</span>
      </div>

      <div class="share-link-box">
        <input type="text" class="share-link-input" id="shareLink" readonly placeholder="Generate a share link...">
        <button class="btn btn-secondary" id="copyShareBtn" onclick="copyShareLink()" disabled>Copy</button>
      </div>

      <!-- Social Sharing Buttons -->
      <div class="social-share-section" id="socialShareSection" style="display: none; margin: 16px 0; padding: 12px; background: rgba(255,255,255,0.02); border-radius: 8px;">
        <div style="font-size: 12px; color: var(--text-muted); margin-bottom: 10px;">Share to:</div>
        <div style="display: flex; gap: 10px; flex-wrap: wrap;">
          <button class="social-share-btn" onclick="shareToSocial('email')" title="Share via Email" style="background: #6b7280; color: white; border: none; padding: 8px 14px; border-radius: 6px; cursor: pointer; display: flex; align-items: center; gap: 6px; font-size: 13px;">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"/>
              <polyline points="22,6 12,13 2,6"/>
            </svg>
            Email
          </button>
          <button class="social-share-btn" onclick="shareToSocial('pinterest')" title="Share to Pinterest" style="background: #E60023; color: white; border: none; padding: 8px 14px; border-radius: 6px; cursor: pointer; display: flex; align-items: center; gap: 6px; font-size: 13px;">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
              <path d="M12 0C5.37 0 0 5.37 0 12c0 4.79 2.81 8.92 6.87 10.83-.09-.79-.17-2.01.04-2.87.19-.78 1.22-5.16 1.22-5.16s-.31-.62-.31-1.54c0-1.44.84-2.52 1.88-2.52.89 0 1.31.66 1.31 1.46 0 .89-.57 2.22-.86 3.46-.25 1.03.52 1.87 1.53 1.87 1.84 0 3.25-1.94 3.25-4.73 0-2.47-1.78-4.2-4.32-4.2-2.94 0-4.67 2.21-4.67 4.49 0 .89.34 1.84.77 2.36.08.1.09.19.07.29l-.29 1.18c-.05.19-.15.23-.35.14-1.31-.61-2.13-2.53-2.13-4.07 0-3.32 2.41-6.36 6.95-6.36 3.65 0 6.49 2.6 6.49 6.08 0 3.62-2.28 6.54-5.46 6.54-1.07 0-2.07-.55-2.41-1.21l-.66 2.5c-.24.91-.89 2.05-1.32 2.75.99.31 2.04.47 3.13.47 6.63 0 12-5.37 12-12S18.63 0 12 0z"/>
            </svg>
            Pinterest
          </button>
          <button class="social-share-btn" onclick="shareToSocial('facebook')" title="Share to Facebook" style="background: #1877F2; color: white; border: none; padding: 8px 14px; border-radius: 6px; cursor: pointer; display: flex; align-items: center; gap: 6px; font-size: 13px;">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
              <path d="M24 12.073c0-6.627-5.373-12-12-12s-12 5.373-12 12c0 5.99 4.388 10.954 10.125 11.854v-8.385H7.078v-3.47h3.047V9.43c0-3.007 1.792-4.669 4.533-4.669 1.312 0 2.686.235 2.686.235v2.953H15.83c-1.491 0-1.956.925-1.956 1.874v2.25h3.328l-.532 3.47h-2.796v8.385C19.612 23.027 24 18.062 24 12.073z"/>
            </svg>
            Facebook
          </button>
          <button class="social-share-btn" onclick="shareToSocial('download')" title="Download as Image" style="background: linear-gradient(135deg, #b8860b, #d4a436); color: white; border: none; padding: 8px 14px; border-radius: 6px; cursor: pointer; display: flex; align-items: center; gap: 6px; font-size: 13px;">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
              <polyline points="7 10 12 15 17 10"/>
              <line x1="12" y1="15" x2="12" y2="3"/>
            </svg>
            Download
          </button>
        </div>
      </div>

      <div class="permission-section">
        <h4>Permission Level</h4>
        <div class="permission-options">
          <div class="permission-btn active" data-permission="quote_approval" onclick="setSharePermission('quote_approval', this)">
            <div class="permission-icon" style="background: linear-gradient(135deg, #22c55e, #16a34a);">
              <svg viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2">
                <path d="M9 12l2 2 4-4"/>
                <rect x="3" y="4" width="18" height="16" rx="2"/>
                <path d="M3 10h18"/>
              </svg>
            </div>
            <div class="permission-info">
              <div class="permission-btn-title">Send for Approval</div>
              <div class="permission-btn-desc">Customer reviews quote & pays to approve</div>
            </div>
          </div>

          <div class="permission-btn" data-permission="full_collab" onclick="setSharePermission('full_collab', this)">
            <div class="permission-icon">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/>
                <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/>
              </svg>
            </div>
            <div class="permission-info">
              <div class="permission-btn-title">Full Collaboration</div>
              <div class="permission-btn-desc">Can edit everything including prices</div>
            </div>
          </div>

          <div class="permission-btn" data-permission="quote_view" onclick="setSharePermission('quote_view', this)">
            <div class="permission-icon">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="12" cy="12" r="3"/>
                <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/>
              </svg>
            </div>
            <div class="permission-info">
              <div class="permission-btn-title">Quote View</div>
              <div class="permission-btn-desc">See prices, cannot edit</div>
            </div>
          </div>

          <div class="permission-btn" data-permission="material_view" onclick="setSharePermission('material_view', this)">
            <div class="permission-icon">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <rect x="3" y="3" width="7" height="7"/>
                <rect x="14" y="3" width="7" height="7"/>
                <rect x="14" y="14" width="7" height="7"/>
                <rect x="3" y="14" width="7" height="7"/>
              </svg>
            </div>
            <div class="permission-info">
              <div class="permission-btn-title">Material View</div>
              <div class="permission-btn-desc">See materials only, no prices</div>
            </div>
          </div>

          <div class="permission-btn" data-permission="presentation" onclick="setSharePermission('presentation', this)">
            <div class="permission-icon">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <rect x="2" y="3" width="20" height="14" rx="2"/>
                <line x1="8" y1="21" x2="16" y2="21"/>
                <line x1="12" y1="17" x2="12" y2="21"/>
              </svg>
            </div>
            <div class="permission-info">
              <div class="permission-btn-title">Presentation</div>
              <div class="permission-btn-desc">Client-pretty, no costs shown</div>
            </div>
          </div>
        </div>
      </div>

      <!-- Customer Email for Comment Notifications -->
      <div class="customer-email-section" style="margin: 20px 0; padding: 16px; background: rgba(249, 168, 37, 0.05); border-radius: 12px; border: 1px solid rgba(249, 168, 37, 0.2);">
        <div style="font-weight: 600; color: var(--text); margin-bottom: 8px; display: flex; align-items: center; gap: 8px;">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#f9a825" stroke-width="2">
            <path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"/>
            <circle cx="12" cy="7" r="4"/>
          </svg>
          Link to Customer (Optional)
        </div>
        <input type="email" id="shareCustomerEmail" placeholder="customer@email.com"
               style="width: 100%; padding: 10px 14px; background: var(--dark-bg); border: 1px solid var(--border); border-radius: 8px; color: var(--text); font-size: 14px;">
        <div style="font-size: 12px; color: var(--text-muted); margin-top: 8px;">
          Enter customer email to enable comment notifications. They'll be notified when you reply to their comments.
        </div>
      </div>

      <!-- Share to Gallery Option -->
      <div class="gallery-share-option" style="margin: 20px 0; padding: 16px; background: linear-gradient(135deg, rgba(99,102,241,0.05), rgba(79,70,229,0.08)); border-radius: 12px; border: 1px solid rgba(99,102,241,0.2);">
        <label style="display: flex; align-items: flex-start; gap: 12px; cursor: pointer;">
          <input type="checkbox" id="shareToGallery" style="width: 20px; height: 20px; margin-top: 2px; accent-color: #6366f1;">
          <div>
            <div style="font-weight: 600; color: var(--text); margin-bottom: 4px;">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#6366f1" stroke-width="2" style="vertical-align: middle; margin-right: 6px;">
                <rect x="3" y="3" width="18" height="18" rx="2"/>
                <circle cx="8.5" cy="8.5" r="1.5"/>
                <path d="M21 15l-5-5L5 21"/>
              </svg>
              Share to Public Gallery
            </div>
            <div style="font-size: 12px; color: var(--text-muted);">
              Inspire others by showcasing your design in our community gallery. Your company name will be displayed.
            </div>
          </div>
        </label>
      </div>

      <div class="share-actions">
        <button class="btn btn-primary" onclick="generateShareLink()">Generate Share Link</button>
      </div>

      <div class="active-shares" id="activeShares" style="display:none;">
        <h4>Active Share Links</h4>
        <div class="shares-list" id="sharesList"></div>
      </div>

      <div class="recent-activity" id="recentActivity" style="display:none;">
        <h4>Recent Activity</h4>
        <div class="activity-list" id="activityList"></div>
      </div>
    </div>
  </div>

  <!-- My Designs Modal -->
  <div class="modal-overlay" id="myDesignsModal">
    <div class="modal" style="max-width: 800px; max-height: 85vh;">
      <div class="modal-header">
        <h3 class="modal-title">My Designs</h3>
        <button class="modal-close" onclick="closeModal('myDesignsModal')"></button>
      </div>

      <div class="designs-tabs">
        <button class="designs-tab active" onclick="switchDesignsTab('my', this)">My Designs</button>
        <button class="designs-tab" onclick="switchDesignsTab('shared', this)">Shared With Me</button>
        <button class="designs-tab" onclick="switchDesignsTab('recent', this)">Recently Viewed</button>
      </div>

      <div class="designs-search">
        <input type="text" id="designsSearch" placeholder="Search designs..." oninput="filterDesigns(this.value)">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <circle cx="11" cy="11" r="8"/><path d="m21 21-4.35-4.35"/>
        </svg>
      </div>

      <div class="designs-grid" id="designsGrid">
        <div class="designs-loading">Loading designs...</div>
      </div>

      <div class="designs-empty" id="designsEmpty" style="display:none;">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
          <path d="M3 7v10a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-6l-2-2H5a2 2 0 00-2 2z"/>
        </svg>
        <p>No designs found</p>
        <button class="btn btn-primary" onclick="closeModal('myDesignsModal')">Create New Design</button>
      </div>

      <div style="margin-top: 16px; padding-top: 16px; border-top: 1px solid var(--border-color); display: flex; gap: 12px;">
        <button class="btn btn-primary" onclick="saveDesignLocally(); loadMyDesigns();">
          <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="margin-right: 6px;">
            <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/>
            <polyline points="17 21 17 13 7 13 7 21"/>
            <polyline points="7 3 7 8 15 8"/>
          </svg>
          Save Current Design
        </button>
        <button class="btn btn-secondary" onclick="closeModal('myDesignsModal')">Close</button>
      </div>
    </div>
  </div>

  <!-- Push Notification Toast -->
  <div class="notification-toast" id="notificationToast">
    <div class="notification-icon">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"/>
      </svg>
    </div>
    <div class="notification-content">
      <div class="notification-title" id="notificationTitle">New Message</div>
      <div class="notification-body" id="notificationBody">You have a new message</div>
    </div>
    <button class="notification-close" onclick="hideNotification()"></button>
  </div>

  <!-- Edge Preview Modal -->
  <div class="modal-overlay" id="edgePreviewModal">
    <div class="modal" style="max-width: 500px; background: var(--surface-secondary);">
      <div class="modal-header">
        <h3 class="modal-title">Edge Profile Preview</h3>
        <button class="modal-close" onclick="closeEdgePreview()"></button>
      </div>
      <div class="modal-body" style="padding: 0;">
        <!-- 3D Preview Container -->
        <div id="edgePreview3D" style="width: 100%; height: 280px; background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); border-radius: 8px 8px 0 0;"></div>

        <!-- Edge Info -->
        <div style="padding: 20px; background: rgba(26, 26, 46, 0.9); backdrop-filter: blur(16px); -webkit-backdrop-filter: blur(16px);">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
            <div>
              <div style="font-size: 11px; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.5px;">Current Edge Profile</div>
              <div id="edgeProfileName" style="font-size: 18px; font-weight: 600; color: var(--text-primary);">Eased</div>
            </div>
            <div style="text-align: right;">
              <div style="font-size: 11px; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 6px;">Thickness</div>
              <div style="display: flex; gap: 4px; background: rgba(30, 41, 59, 0.85); backdrop-filter: blur(12px); -webkit-backdrop-filter: blur(12px); border-radius: 8px; padding: 4px; border: 1px solid rgba(255, 255, 255, 0.1);">
                <button id="thickness2cmBtn" onclick="updateEdgeThickness('2cm')" style="padding: 6px 14px; border: none; border-radius: 6px; font-size: 14px; font-weight: 600; cursor: pointer; transition: all 0.2s; background: transparent; color: var(--text-muted);">2cm</button>
                <button id="thickness3cmBtn" onclick="updateEdgeThickness('3cm')" style="padding: 6px 14px; border: none; border-radius: 6px; font-size: 14px; font-weight: 600; cursor: pointer; transition: all 0.2s; background: var(--gold); color: #000;">3cm</button>
              </div>
            </div>
          </div>

          <!-- Edge Profile Selector -->
          <div style="margin-bottom: 16px;">
            <label style="font-size: 12px; color: var(--text-muted); display: block; margin-bottom: 8px;">Change Edge Profile</label>
            <select id="edgeProfileSelect" onchange="updateEdgeProfile(this.value)" style="width: 100%; padding: 12px; background: rgba(30, 41, 59, 0.85); backdrop-filter: blur(12px); -webkit-backdrop-filter: blur(12px); border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 8px; color: var(--text-primary); font-size: 14px;">
              <optgroup label=" Most Durable">
                <option value="full-bullnose">Full Bullnose - Fully rounded semicircle</option>
                <option value="half-bullnose">Half Bullnose - Rounded top, flat bottom</option>
              </optgroup>
              <optgroup label=" Durable">
                <option value="eased">Eased (Standard) - Slight round on top edge</option>
                <option value="flat-polish">Flat Polish - Square edge, polished face</option>
                <option value="pencil">Pencil Round - Small radius curve</option>
                <option value="quarter-round">Quarter Round - Medium rounded edge</option>
              </optgroup>
              <optgroup label=" Moderate Durability">
                <option value="bevel">Bevel - Angled cut (45)</option>
                <option value="ogee">Ogee - S-curve profile (Premium)</option>
                <option value="double-ogee">Double Ogee - Stacked S-curves</option>
              </optgroup>
              <optgroup label=" Decorative">
                <option value="cove">Cove - Concave curve</option>
                <option value="dupont">Dupont - Elaborate decorative</option>
                <option value="chiseled">Chiseled - Natural rough edge</option>
              </optgroup>
              <optgroup label=" Structural">
                <option value="mitered">Mitered - Laminated drop edge (2cm look on 3cm)</option>
                <option value="waterfall">Waterfall - 90 turn with mitered corner</option>
              </optgroup>
            </select>
          </div>

          <!-- Camera Controls -->
          <div style="display: flex; gap: 8px; justify-content: center; padding: 12px; background: rgba(30, 41, 59, 0.7); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); border-radius: 8px; border: 1px solid rgba(255, 255, 255, 0.08);">
            <button class="btn btn-secondary" style="padding: 8px 16px; font-size: 12px; background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.15);" onclick="rotateEdgePreview('left')"> Rotate</button>
            <button class="btn btn-secondary" style="padding: 8px 16px; font-size: 12px; background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.15);" onclick="rotateEdgePreview('reset')">Reset View</button>
            <button class="btn btn-secondary" style="padding: 8px 16px; font-size: 12px; background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.15);" onclick="rotateEdgePreview('right')">Rotate </button>
          </div>
        </div>
      </div>
      <div class="modal-footer">
        <button class="btn btn-secondary" onclick="closeEdgePreview()">Close</button>
        <button class="btn btn-primary" onclick="applyEdgeAndClose()">Apply & Close</button>
      </div>
    </div>
  </div>

  <!-- Login Modal -->
  <div class="modal-overlay" id="loginModal">
    <div class="modal login-modal">
      <div class="modal-header">
        <h3 class="modal-title" style="font-size: 22px;">Sign In</h3>
        <button class="modal-close login-modal-close" onclick="closeModal('loginModal')"></button>
      </div>

      <p id="loginPromptMessage" style="color: var(--text-secondary); margin-bottom: 24px; text-align: center; font-size: 15px; line-height: 1.5;">
        Sign in to save and share your designs.
      </p>

      <div id="loginFormContainer">
        <!-- Google OAuth Button -->
        <button class="google-signin-btn" onclick="handleGoogleLogin()">
          <svg viewBox="0 0 24 24" width="20" height="20">
            <path fill="#4285F4" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"/>
            <path fill="#34A853" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/>
            <path fill="#FBBC05" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/>
            <path fill="#EA4335" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/>
          </svg>
          Continue with Google
        </button>

        <div class="login-divider">
          <span>or</span>
        </div>

        <!-- Email/Password Form -->
        <div class="form-group" style="margin-bottom: 18px;">
          <label style="font-size: 13px; margin-bottom: 8px; display: block; font-weight: 500;">Email</label>
          <input type="email" id="loginEmail" class="input" placeholder="your@email.com" style="width: 100%; padding: 14px; font-size: 15px;" onkeydown="if(event.key==='Enter'){event.preventDefault();document.getElementById('loginPassword').focus();}">
        </div>
        <div class="form-group" style="margin-bottom: 18px;">
          <label style="font-size: 13px; margin-bottom: 8px; display: block; font-weight: 500;">Password</label>
          <input type="password" id="loginPassword" class="input" placeholder="" style="width: 100%; padding: 14px; font-size: 15px;" onkeydown="if(event.key==='Enter'){event.preventDefault();handleLogin();}">
        </div>
        <div id="loginError" style="color: var(--error); font-size: 13px; margin-bottom: 14px; display: none;"></div>

        <!-- Sign In Button -->
        <button class="btn-signin" id="signInBtn" onclick="handleLogin()">
          <span class="btn-signin-text">Sign In</span>
          <span class="btn-signin-loader"></span>
        </button>
        <div style="text-align: center; font-size: 14px; color: var(--text-muted); margin-bottom: 16px;">
          Don't have an account? <a href="/sign-up/" target="_blank" style="color: var(--gold); font-weight: 500;">Sign up free</a>
        </div>
        <div class="login-divider" style="margin-bottom: 16px;">
          <span>or</span>
        </div>
        <button class="btn" style="width: 100%; padding: 12px; font-size: 14px; background: transparent; border: 1px solid var(--border-color); color: var(--text-secondary);" onclick="continueAsGuest()">Continue as Guest</button>
        <p style="text-align: center; font-size: 11px; color: var(--text-muted); margin-top: 10px; opacity: 0.7;">Guest designs are saved locally only</p>
      </div>

      <div id="loginSuccessContainer" style="display: none; text-align: center; padding: 20px 0;">
        <div style="width: 70px; height: 70px; background: var(--success); border-radius: 50%; display: flex; align-items: center; justify-content: center; margin: 0 auto 20px;">
          <svg viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="3" style="width: 35px; height: 35px;">
            <polyline points="20 6 9 17 4 12"/>
          </svg>
        </div>
        <h4 style="margin-bottom: 10px; font-size: 20px;">Signed In!</h4>
        <p id="loginWelcome" style="color: var(--text-secondary); margin-bottom: 20px; font-size: 15px;">Welcome back</p>
        <button class="btn btn-primary" style="padding: 14px 32px; font-size: 15px;" onclick="closeModal('loginModal')">Continue</button>
      </div>
    </div>
  </div>

  <!-- Price List Modal -->
  <div class="modal-overlay" id="priceListModal">
    <div class="modal" style="max-width: 800px; max-height: 90vh; overflow: hidden; display: flex; flex-direction: column;">
      <div class="modal-header">
        <h3 class="modal-title">Price List Manager</h3>
        <button class="modal-close" onclick="closeModal('priceListModal')"></button>
      </div>

      <div class="price-list-tabs">
        <button class="tab-btn active" onclick="showPriceTab('labor')">Labor Rates</button>
        <button class="tab-btn" onclick="showPriceTab('materials')">Materials</button>
        <button class="tab-btn" onclick="showPriceTab('upload')">Upload</button>
        <button class="tab-btn" onclick="showPriceTab('saved')">Saved Lists</button>
      </div>

      <!-- Labor Rates Tab -->
      <div class="price-tab" id="priceTabLabor" style="overflow-y: auto; max-height: calc(90vh - 140px);">
        <div style="padding: 12px; background: rgba(249,203,0,0.1); border-radius: 8px; margin-bottom: 16px;">
          <p style="font-size: 13px; color: var(--text-muted); margin: 0;">
            <strong style="color: var(--gold-primary);">Labor Rates</strong> - Set your pricing for fabrication, installation, and services. These rates are used to calculate labor costs in quotes.
          </p>
        </div>

        <!-- Labor Category Accordion -->
        <div class="labor-categories" id="laborCategoriesContainer">
          <!-- Stone/Countertop Services -->
          <div class="labor-category">
            <div class="labor-category-header" onclick="toggleLaborCategory('stone')">
              <span class="category-icon"></span>
              <span class="category-title">Stone / Countertop Services</span>
              <span class="category-toggle" id="toggleStone"></span>
            </div>
            <div class="labor-category-items" id="laborItemsStone"></div>
          </div>

          <!-- Cabinet Services -->
          <div class="labor-category">
            <div class="labor-category-header" onclick="toggleLaborCategory('cabinet')">
              <span class="category-icon"></span>
              <span class="category-title">Cabinet Services</span>
              <span class="category-toggle" id="toggleCabinet"></span>
            </div>
            <div class="labor-category-items" id="laborItemsCabinet"></div>
          </div>

          <!-- Plumbing Services -->
          <div class="labor-category">
            <div class="labor-category-header" onclick="toggleLaborCategory('plumbing')">
              <span class="category-icon"></span>
              <span class="category-title">Plumbing Services</span>
              <span class="category-toggle" id="togglePlumbing"></span>
            </div>
            <div class="labor-category-items" id="laborItemsPlumbing"></div>
          </div>

          <!-- Electrical Services -->
          <div class="labor-category">
            <div class="labor-category-header" onclick="toggleLaborCategory('electrical')">
              <span class="category-icon"></span>
              <span class="category-title">Electrical Services</span>
              <span class="category-toggle" id="toggleElectrical"></span>
            </div>
            <div class="labor-category-items" id="laborItemsElectrical"></div>
          </div>

          <!-- Flooring Services -->
          <div class="labor-category">
            <div class="labor-category-header" onclick="toggleLaborCategory('flooring')">
              <span class="category-icon"></span>
              <span class="category-title">Flooring Services</span>
              <span class="category-toggle" id="toggleFlooring"></span>
            </div>
            <div class="labor-category-items" id="laborItemsFlooring"></div>
          </div>

          <!-- Demo & Prep Services -->
          <div class="labor-category">
            <div class="labor-category-header" onclick="toggleLaborCategory('demo')">
              <span class="category-icon"></span>
              <span class="category-title">Demo & Prep</span>
              <span class="category-toggle" id="toggleDemo"></span>
            </div>
            <div class="labor-category-items" id="laborItemsDemo"></div>
          </div>

          <!-- Finishing/Specialty -->
          <div class="labor-category">
            <div class="labor-category-header" onclick="toggleLaborCategory('finishing')">
              <span class="category-icon"></span>
              <span class="category-title">Finishing & Specialty</span>
              <span class="category-toggle" id="toggleFinishing"></span>
            </div>
            <div class="labor-category-items" id="laborItemsFinishing"></div>
          </div>

          <!-- Project Fees -->
          <div class="labor-category">
            <div class="labor-category-header" onclick="toggleLaborCategory('fees')">
              <span class="category-icon">$</span>
              <span class="category-title">Project Fees</span>
              <span class="category-toggle" id="toggleFees"></span>
            </div>
            <div class="labor-category-items" id="laborItemsFees"></div>
          </div>
        </div>

        <div style="padding: 16px; border-top: 1px solid var(--border-subtle); display: flex; gap: 12px; justify-content: flex-end;">
          <button class="btn btn-secondary" onclick="resetLaborRates()">Reset to Defaults</button>
          <button class="btn btn-primary" onclick="saveLaborRates()">Save Rates</button>
        </div>
      </div>

      <!-- Materials Tab (Slab Pricing) -->
      <div class="price-tab" id="priceTabMaterials" style="display:none; overflow-y: auto; max-height: calc(90vh - 140px);">
        <div style="padding: 12px; background: rgba(249,203,0,0.1); border-radius: 8px; margin-bottom: 16px;">
          <p style="font-size: 13px; color: var(--text-muted); margin: 0;">
            <strong style="color: var(--gold-primary);">Material Pricing</strong> - Materials sold by the slab are priced per slab, then fabrication/installation calculated per sqft.
          </p>
        </div>

        <div class="material-pricing-section">
          <h4 style="margin-bottom: 12px; color: #fff;">Slab Materials</h4>
          <p style="font-size: 12px; color: var(--text-muted); margin-bottom: 12px;">Enter slab cost. Fab & install are calculated from Labor Rates based on sqft.</p>
          <div id="slabMaterialsList"></div>
        </div>

        <div class="material-pricing-section" style="margin-top: 24px;">
          <h4 style="margin-bottom: 12px; color: #fff;">Per-Sqft Materials</h4>
          <div id="sqftMaterialsList"></div>
        </div>

        <div style="padding: 16px; border-top: 1px solid var(--border-subtle); display: flex; gap: 12px; justify-content: flex-end;">
          <button class="btn btn-primary" onclick="saveMaterialPricing()">Save Material Prices</button>
        </div>
      </div>

      <!-- Upload Tab -->
      <div class="price-tab" id="priceTabUpload" style="display:none;">
        <div class="upload-dropzone" id="priceListDropzone" onclick="document.getElementById('priceListFile').click()">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:48px;height:48px;margin-bottom:12px;opacity:0.5;">
            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
            <polyline points="17 8 12 3 7 8"/>
            <line x1="12" y1="3" x2="12" y2="15"/>
          </svg>
          <p style="margin-bottom:4px;">Drop Excel or CSV file here</p>
          <p class="hint" style="font-size:12px;color:var(--text-muted);">Supports .xlsx, .xls, .csv for material or labor price lists</p>
          <input type="file" id="priceListFile" accept=".xlsx,.xls,.csv" onchange="handlePriceListUpload(event)" style="display:none">
        </div>

        <div class="column-mapping" id="columnMapping" style="display:none;">
          <h4 style="margin-bottom:12px;">Map Columns</h4>
          <div class="mapping-row">
            <label>Item ID/SKU</label>
            <select id="mapMaterialId" class="property-select" onchange="updateMappingPreview()"></select>
          </div>
          <div class="mapping-row">
            <label>Item Name</label>
            <select id="mapMaterialName" class="property-select" onchange="updateMappingPreview()"></select>
          </div>
          <div class="mapping-row">
            <label>Price</label>
            <select id="mapPrice" class="property-select" onchange="updateMappingPreview()"></select>
          </div>
          <div class="mapping-row">
            <label>Unit (optional)</label>
            <select id="mapUnit" class="property-select" onchange="updateMappingPreview()"></select>
          </div>
          <div class="mapping-preview" id="mappingPreview"></div>
          <div class="mapping-actions">
            <button class="btn btn-secondary" onclick="cancelPriceUpload()">Cancel</button>
            <button class="btn btn-primary" onclick="applyPriceList()">Apply Prices</button>
          </div>
        </div>
      </div>

      <!-- Saved Lists Tab -->
      <div class="price-tab" id="priceTabSaved" style="display:none;">
        <div class="saved-lists" id="savedPriceLists">
          <p class="empty-state">No saved price lists</p>
        </div>
        <button class="btn btn-primary" onclick="savePriceList()" style="margin-top:16px;">Save Current Prices</button>
      </div>
    </div>
  </div>

  <!-- Quote Preview Modal -->
  <div class="modal-overlay" id="quotePreviewModal">
    <div class="modal" style="max-width: 900px; max-height: 90vh; overflow: hidden; display: flex; flex-direction: column;">
      <div class="modal-header">
        <div style="display: flex; align-items: center; gap: 12px;">
          <h3 class="modal-title">Quote Preview</h3>
          <div id="estimateNumberBadge" style="display: none; background: var(--gold); color: #000; padding: 4px 10px; border-radius: 4px; font-size: 12px; font-weight: 600;"></div>
        </div>
        <div style="display: flex; align-items: center; gap: 12px;">
          <select id="quoteRoomFilter" class="property-select" style="font-size: 12px; min-width: 140px;" onchange="filterQuoteByRoom(this.value)">
            <option value="all">All Rooms</option>
          </select>
          <button class="modal-close" onclick="closeModal('quotePreviewModal')"></button>
        </div>
      </div>

      <!-- Customer Info Section -->
      <div class="quote-customer-section" style="padding: 16px; background: var(--dark-elevated); border-bottom: 1px solid var(--border);">
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px;">
          <div>
            <label style="font-size: 11px; color: var(--text-muted); display: block; margin-bottom: 4px;">Customer Name *</label>
            <input type="text" id="quoteCustomerName" class="property-input" placeholder="Enter customer name" style="width: 100%;">
          </div>
          <div>
            <label style="font-size: 11px; color: var(--text-muted); display: block; margin-bottom: 4px;">Email *</label>
            <input type="email" id="quoteCustomerEmail" class="property-input" placeholder="customer@email.com" style="width: 100%;">
          </div>
          <div>
            <label style="font-size: 11px; color: var(--text-muted); display: block; margin-bottom: 4px;">Phone</label>
            <input type="tel" id="quoteCustomerPhone" class="property-input" placeholder="(555) 123-4567" style="width: 100%;">
          </div>
          <div>
            <label style="font-size: 11px; color: var(--text-muted); display: block; margin-bottom: 4px;">Project Name</label>
            <input type="text" id="quoteProjectName" class="property-input" placeholder="Kitchen Remodel" style="width: 100%;">
          </div>
          <div style="grid-column: span 2;">
            <label style="font-size: 11px; color: var(--text-muted); display: block; margin-bottom: 4px;">Project Address</label>
            <input type="text" id="quoteCustomerAddress" class="property-input" placeholder="123 Main St, Phoenix, AZ 85001" style="width: 100%;">
          </div>
        </div>
      </div>

      <!-- Quote Items Table -->
      <div class="quote-preview-content" style="flex: 1; overflow-y: auto; padding: 16px;">
        <table class="quote-preview-table" id="quotePreviewTable">
          <thead>
            <tr>
              <th style="width: 30px;"></th>
              <th>Item</th>
              <th style="width: 80px;">Qty</th>
              <th style="width: 100px;">Cost</th>
              <th style="width: 100px;">Retail</th>
              <th style="width: 60px;">Margin</th>
            </tr>
          </thead>
          <tbody id="quotePreviewBody">
            <!-- Populated by JavaScript -->
          </tbody>
        </table>
      </div>

      <!-- Quote Totals -->
      <div class="quote-preview-footer" style="padding: 16px; background: var(--dark-elevated); border-top: 1px solid var(--border);">
        <div style="display: flex; justify-content: space-between; align-items: flex-start;">
          <div style="flex: 1;">
            <label style="font-size: 11px; color: var(--text-muted); display: block; margin-bottom: 4px;">Notes / Terms</label>
            <textarea id="quoteNotes" class="property-input" rows="2" placeholder="Add notes, terms, or special conditions..." style="width: 100%; resize: none;"></textarea>
          </div>
          <div style="min-width: 250px; margin-left: 24px;">
            <div class="quote-totals-grid">
              <div style="display: flex; justify-content: space-between; padding: 6px 0; border-bottom: 1px solid var(--border);">
                <span style="color: var(--text-muted); font-size: 13px;">Subtotal</span>
                <span id="quotePreviewSubtotal" style="font-weight: 500;">$0.00</span>
              </div>
              <div style="display: flex; justify-content: space-between; padding: 6px 0; border-bottom: 1px solid var(--border);">
                <span style="color: var(--text-muted); font-size: 13px;">Tax (<span id="quoteTaxRate">0</span>%)</span>
                <span id="quotePreviewTax" style="font-weight: 500;">$0.00</span>
              </div>
              <div style="display: flex; justify-content: space-between; padding: 10px 0; font-size: 16px;">
                <span style="font-weight: 600;">Total</span>
                <span id="quotePreviewTotal" style="font-weight: 700; color: var(--gold);">$0.00</span>
              </div>
            </div>
            <div style="display: flex; gap: 8px; margin-top: 12px;">
              <input type="number" id="quoteTaxInput" class="property-input" value="0" min="0" max="20" step="0.5" style="width: 60px; text-align: center;" onchange="updateQuoteTax(this.value)" placeholder="%">
              <span style="font-size: 11px; color: var(--text-muted); align-self: center;">Tax %</span>
            </div>
          </div>
        </div>

        <!-- Action Buttons -->
        <div style="display: flex; gap: 12px; margin-top: 16px; padding-top: 16px; border-top: 1px solid var(--border);">
          <button class="btn btn-secondary" onclick="downloadQuotePDF()" style="flex: 1;">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:14px;height:14px;margin-right:6px;">
              <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
              <polyline points="7 10 12 15 17 10"/>
              <line x1="12" y1="15" x2="12" y2="3"/>
            </svg>
            PDF
          </button>
          <button class="btn btn-secondary" onclick="copyQuoteLink()" style="flex: 1;">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:14px;height:14px;margin-right:6px;">
              <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"/>
              <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"/>
            </svg>
            Link
          </button>
          <button class="btn btn-secondary" onclick="sendQuoteEmail()" style="flex: 1;">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:14px;height:14px;margin-right:6px;">
              <path d="M22 2L11 13"/><path d="M22 2l-7 20-4-9-9-4 20-7z"/>
            </svg>
            Email
          </button>
          <button id="saveEstimateBtn" class="btn btn-primary" onclick="saveEstimateToDatabase()" style="flex: 1.5;">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:14px;height:14px;margin-right:6px;">
              <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/>
              <polyline points="17 21 17 13 7 13 7 21"/>
              <polyline points="7 3 7 8 15 8"/>
            </svg>
            Save Estimate
          </button>
        </div>
        <!-- Estimate Status -->
        <div id="estimateStatusSection" style="display: none; margin-top: 12px; padding: 12px; background: rgba(34, 197, 94, 0.1); border: 1px solid rgba(34, 197, 94, 0.3); border-radius: 8px;">
          <div style="display: flex; align-items: center; gap: 8px;">
            <svg viewBox="0 0 24 24" fill="none" stroke="#22c55e" stroke-width="2" style="width:18px;height:18px;">
              <path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/><polyline points="22 4 12 14.01 9 11.01"/>
            </svg>
            <span id="estimateStatusText" style="color: #22c55e; font-weight: 500;">Estimate saved!</span>
          </div>
          <div id="estimateShareUrl" style="margin-top: 8px; display: none;">
            <label style="font-size: 11px; color: var(--text-muted); display: block; margin-bottom: 4px;">Customer View Link</label>
            <div style="display: flex; gap: 8px;">
              <input type="text" id="estimateViewLink" class="property-input" readonly style="flex: 1; font-size: 12px;">
              <button class="btn btn-secondary" onclick="copyEstimateLink()" style="padding: 8px 12px;">Copy</button>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Room Manager Modal -->
  <div class="modal-overlay" id="roomManagerModal">
    <div class="modal" style="max-width: 500px;">
      <div class="modal-header">
        <h3 class="modal-title">Manage Rooms</h3>
        <button class="modal-close" onclick="closeModal('roomManagerModal')"></button>
      </div>

      <div style="padding: 16px;">
        <p style="font-size: 13px; color: var(--text-muted); margin-bottom: 16px;">
          Organize your design by rooms. Each room will have its own quote section.
        </p>

        <!-- Add Room -->
        <div style="display: flex; gap: 8px; margin-bottom: 16px;">
          <input type="text" id="newRoomName" class="property-input" placeholder="New room name (e.g., Master Bath)" style="flex: 1;">
          <button class="btn btn-primary" onclick="addRoom()">Add Room</button>
        </div>

        <!-- Room List -->
        <div class="room-list" id="roomList">
          <!-- Populated by JavaScript -->
        </div>
      </div>

      <div style="padding: 16px; border-top: 1px solid var(--border); display: flex; justify-content: flex-end; gap: 8px;">
        <button class="btn btn-secondary" onclick="closeModal('roomManagerModal')">Close</button>
      </div>
    </div>
  </div>

  <!-- Customer Quote View Share Modal -->
  <div class="modal-overlay" id="shareQuoteModal">
    <div class="modal" style="max-width: 500px;">
      <div class="modal-header">
        <h3 class="modal-title">Share Quote with Customer</h3>
        <button class="modal-close" onclick="closeModal('shareQuoteModal')"></button>
      </div>

      <div style="padding: 16px;">
        <p style="font-size: 13px; color: var(--text-muted); margin-bottom: 16px;">
          Generate a link for your customer to view the design and quote. They can see all rooms and the total estimate.
        </p>

        <div style="margin-bottom: 16px;">
          <label style="font-size: 11px; color: var(--text-muted); display: block; margin-bottom: 4px;">Customer Email (optional)</label>
          <input type="email" id="shareCustomerEmail" class="property-input" placeholder="customer@email.com" style="width: 100%;">
        </div>

        <div style="margin-bottom: 16px;">
          <label style="font-size: 11px; color: var(--text-muted); display: block; margin-bottom: 4px;">Link Expiration</label>
          <select id="shareLinkExpiry" class="property-select" style="width: 100%;">
            <option value="7">7 days</option>
            <option value="14">14 days</option>
            <option value="30" selected>30 days</option>
            <option value="90">90 days</option>
            <option value="0">Never expires</option>
          </select>
        </div>

        <div style="margin-bottom: 16px;">
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
            <input type="checkbox" id="shareShowPricing" checked style="width: 16px; height: 16px;">
            <span style="font-size: 13px;">Show pricing to customer</span>
          </label>
        </div>

        <div style="margin-bottom: 16px;">
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
            <input type="checkbox" id="shareAllowDeposit" checked style="width: 16px; height: 16px;">
            <span style="font-size: 13px;">Allow customer to pay deposit</span>
          </label>
          <p style="font-size: 11px; color: var(--text-muted); margin: 4px 0 0 24px;">Customer can approve and pay 50% deposit via Stripe</p>
        </div>

        <div style="margin-bottom: 16px;">
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
            <input type="checkbox" id="shareAllowSchedule" checked style="width: 16px; height: 16px;">
            <span style="font-size: 13px;">Allow customer to schedule consultation</span>
          </label>
          <p style="font-size: 11px; color: var(--text-muted); margin: 4px 0 0 24px;">Shows scheduling options after deposit payment</p>
        </div>

        <!-- Generated Link -->
        <div id="generatedLinkSection" style="display: none; margin-top: 16px;">
          <label style="font-size: 11px; color: var(--text-muted); display: block; margin-bottom: 4px;">Shareable Link</label>
          <div style="display: flex; gap: 8px;">
            <input type="text" id="generatedShareLink" class="property-input" readonly style="flex: 1; font-size: 11px;">
            <button class="btn btn-secondary" onclick="copyGeneratedLink()" title="Copy link">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:14px;height:14px;">
                <rect x="9" y="9" width="13" height="13" rx="2"/>
                <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/>
              </svg>
            </button>
          </div>
        </div>
      </div>

      <div style="padding: 16px; border-top: 1px solid var(--border); display: flex; justify-content: flex-end; gap: 8px;">
        <button class="btn btn-secondary" onclick="closeModal('shareQuoteModal')">Cancel</button>
        <button class="btn btn-primary" onclick="generateQuoteShareLink()" id="generateLinkBtn">Generate Link</button>
      </div>
    </div>
  </div>

  <!-- Margin Settings Modal -->
  <div class="modal-overlay" id="marginModal">
    <div class="modal" style="max-width: 450px;">
      <div class="modal-header">
        <h3 class="modal-title">Margin Settings</h3>
        <button class="modal-close" onclick="closeModal('marginModal')"></button>
      </div>

      <div class="margin-section">
        <div class="margin-global">
          <label>Default Margin</label>
          <div class="margin-input-group">
            <input type="number" class="property-input" id="globalMarginInput" value="30" min="0" max="200">
            <span class="margin-symbol">%</span>
          </div>
          <p class="hint" style="font-size:11px;color:var(--text-muted);margin-top:4px;">Applied to all items without custom margin</p>
        </div>

        <div class="margin-categories">
          <h4 style="margin:16px 0 12px;">Category Margins</h4>
          <div class="category-margin-row">
            <span>Countertops</span>
            <div class="margin-input-group">
              <input type="number" class="property-input" data-category="countertop" value="35" min="0" max="200">
              <span class="margin-symbol">%</span>
            </div>
          </div>
          <div class="category-margin-row">
            <span>Cabinets</span>
            <div class="margin-input-group">
              <input type="number" class="property-input" data-category="cabinet" value="25" min="0" max="200">
              <span class="margin-symbol">%</span>
            </div>
          </div>
          <div class="category-margin-row">
            <span>Appliances</span>
            <div class="margin-input-group">
              <input type="number" class="property-input" data-category="appliance" value="15" min="0" max="200">
              <span class="margin-symbol">%</span>
            </div>
          </div>
          <div class="category-margin-row">
            <span>Flooring/Tile</span>
            <div class="margin-input-group">
              <input type="number" class="property-input" data-category="flooring" value="30" min="0" max="200">
              <span class="margin-symbol">%</span>
            </div>
          </div>
        </div>
      </div>

      <div class="modal-footer">
        <button class="btn btn-secondary" onclick="closeModal('marginModal')">Cancel</button>
        <button class="btn btn-primary" onclick="applyMargins()">Apply</button>
      </div>
    </div>
  </div>

  <!-- Material Picker Modal -->
  <div class="modal-overlay" id="materialModal">
    <div class="modal" style="max-width: 600px;">
      <div class="modal-header">
        <h3 class="modal-title">Choose Material</h3>
        <button class="modal-close" onclick="closeModal('materialModal')"></button>
      </div>
      <div class="material-categories" id="materialCategories">
        <!-- Categories rendered by JS -->
      </div>
      <div class="materials-modal-grid" id="materialsGrid">
        <!-- Materials rendered by JS -->
      </div>
    </div>
  </div>

  <!-- Takeoff Report Modal -->
  <div class="modal-overlay" id="takeoffModal" style="display: none;">
    <div class="modal" style="max-width: 900px; max-height: 90vh; overflow: hidden; display: flex; flex-direction: column;">
      <div class="modal-header" style="flex-shrink: 0;">
        <h3 class="modal-title" style="display: flex; align-items: center; gap: 10px;">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2"/>
            <rect x="9" y="3" width="6" height="4" rx="1"/>
          </svg>
          Material Takeoffs
        </h3>
        <div style="display: flex; gap: 8px; align-items: center;">
          <button class="btn btn-secondary btn-sm" onclick="exportTakeoffPDF()" style="font-size: 12px;">
            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="margin-right: 4px;">
              <path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4"/><polyline points="7,10 12,15 17,10"/><line x1="12" y1="15" x2="12" y2="3"/>
            </svg>
            Export PDF
          </button>
          <button class="modal-close" onclick="closeModal('takeoffModal')"></button>
        </div>
      </div>
      <div class="modal-body" id="takeoffContent" style="overflow-y: auto; flex: 1; padding: 20px;">
        <!-- Takeoff content rendered by JS -->
      </div>
    </div>
  </div>

  <style>
    /* Takeoff Modal Styles */
    .takeoff-section {
      background: var(--dark-elevated);
      border-radius: 12px;
      padding: 16px;
      margin-bottom: 16px;
    }
    .takeoff-section-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 12px;
      padding-bottom: 8px;
      border-bottom: 1px solid var(--border);
    }
    .takeoff-section-title {
      font-size: 16px;
      font-weight: 600;
      color: var(--text);
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .takeoff-section-badge {
      background: var(--primary);
      color: white;
      padding: 2px 8px;
      border-radius: 12px;
      font-size: 12px;
      font-weight: 600;
    }
    .takeoff-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 12px;
    }
    .takeoff-item {
      background: rgba(0,0,0,0.2);
      border-radius: 8px;
      padding: 12px;
    }
    .takeoff-item-label {
      font-size: 12px;
      color: var(--text-muted);
      margin-bottom: 4px;
    }
    .takeoff-item-value {
      font-size: 18px;
      font-weight: 700;
      color: var(--text);
    }
    .takeoff-item-unit {
      font-size: 12px;
      color: var(--text-secondary);
      font-weight: 400;
    }
    .takeoff-item-note {
      font-size: 11px;
      color: var(--text-muted);
      margin-top: 4px;
    }
    .takeoff-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 13px;
    }
    .takeoff-table th {
      text-align: left;
      padding: 8px;
      background: rgba(0,0,0,0.3);
      color: var(--text-secondary);
      font-weight: 500;
      font-size: 11px;
      text-transform: uppercase;
    }
    .takeoff-table td {
      padding: 8px;
      border-bottom: 1px solid var(--border);
      color: var(--text);
    }
    .takeoff-table tr:last-child td {
      border-bottom: none;
    }
    .takeoff-highlight {
      background: linear-gradient(135deg, rgba(99, 102, 241, 0.2) 0%, rgba(139, 92, 246, 0.2) 100%);
      border: 1px solid rgba(99, 102, 241, 0.3);
    }
    .takeoff-warning {
      background: rgba(245, 158, 11, 0.15);
      border: 1px solid rgba(245, 158, 11, 0.3);
      color: #fbbf24;
      padding: 12px;
      border-radius: 8px;
      font-size: 13px;
      display: flex;
      align-items: flex-start;
      gap: 8px;
      margin-top: 12px;
    }
    .takeoff-summary {
      background: linear-gradient(135deg, var(--dark) 0%, var(--dark-elevated) 100%);
      border: 2px solid var(--primary);
      border-radius: 12px;
      padding: 20px;
      margin-top: 16px;
    }
    .takeoff-summary-title {
      font-size: 14px;
      color: var(--text-secondary);
      margin-bottom: 8px;
    }
    .takeoff-summary-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 16px;
    }
    .slab-visual {
      display: flex;
      gap: 8px;
      margin-top: 12px;
      flex-wrap: wrap;
    }
    .slab-icon {
      width: 60px;
      height: 40px;
      background: linear-gradient(135deg, #64748b 0%, #475569 100%);
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      font-weight: 700;
      color: white;
      border: 2px solid rgba(255,255,255,0.2);
    }
    .slab-icon.used {
      background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
      border-color: rgba(255,255,255,0.4);
    }
  </style>

  <!-- Hidden file input -->
  <input type="file" id="materialUpload" accept="image/*" style="display: none" onchange="handleMaterialUpload(event)">

  <!-- Keyboard Shortcuts (hidden in review mode) -->
  <div class="shortcuts-hint" id="shortcutsHint">
    <div class="shortcut"><kbd>V</kbd> Select</div>
    <div class="shortcut"><kbd>W</kbd> Wall</div>
    <div class="shortcut"><kbd>C</kbd> Counter</div>
    <div class="shortcut"><kbd>Del</kbd> Delete</div>
    <div class="shortcut"><kbd>R</kbd> Rotate</div>
    <div class="shortcut"><kbd>Ctrl+D</kbd> Duplicate</div>
  </div>

  <script>
    // ===== CONFIGURATION =====
    const CONFIG = {
      MIN_PIXELS_PER_FOOT: 5,  // Allow zooming out to see very large rooms
      MAX_PIXELS_PER_FOOT: 200, // Allow zooming in for fine detail work
      DEFAULT_PIXELS_PER_FOOT: 40,
      GRID_SUBDIVISIONS: 12, // 12 subdivisions = 1 inch grid (12" per foot)
      MEASUREMENT_PRECISION: 16, // 1/16" precision
      WALL_THICKNESS: 6,
      PRICING: {
        'base-cabinet': 150,
        'wall-cabinet': 120,
        'tall-cabinet': 300,
        'fridge-cabinet': 450,
        'corner-cabinet': 200,
        'island': 400,
        'countertop': 65,
        'backsplash': 25,
        'flooring': 8,
        'tile': 15,
        'sink': 350,
        'stove': 800,
        'refrigerator': 1200,
        'dishwasher': 600,
        'microwave': 250,
        'range-hood': 450,
        'oven': 1500,
        'door': 200,
        'window': 300,
        'wall': 0
      }
    };

    // ===== PRICING & SHARING STATE =====
    const PRICING_STATE = {
      globalMargin: 30,           // Default 30% markup
      categoryMargins: {
        countertop: 35,
        cabinet: 25,
        appliance: 15,
        flooring: 30,
        other: 30
      },
      showCostView: false,        // Toggle between cost/retail view
      priceLists: [],             // Saved price list configurations
      activePriceList: null,      // Currently active price list name
      customPrices: {}            // Temporary price overrides from Excel import
    };

    const SHARE_STATE = {
      designId: null,             // Supabase design ID
      designToken: null,          // Current design's share token
      permission: 'full_collab',  // Current user's permission level
      isSharedView: false,        // Whether viewing a shared design
      allowedActions: null,       // Actions permitted by current permission
      realtimeChannel: null,      // Supabase realtime subscription channel
      commentsChannel: null,      // Supabase realtime subscription for comments
      isLiveConnected: false,     // Whether realtime is connected
      lastSyncTime: null,         // Last time design was synced
      leadId: null,               // Associated lead/customer ID
      customerName: null          // Customer name for notifications
    };

    // ===== REALTIME SYNC FOR SHARED DESIGNS =====
    // Enables hot-reload: customers see designer changes instantly

    function subscribeToDesignUpdates(designId) {
      const supabase = getSupabaseClient();
      if (!supabase || !designId) {
        console.log('Cannot subscribe to realtime: no supabase client or design ID');
        // Start polling fallback
        startPollingFallback(designId);
        return;
      }

      // Unsubscribe from any existing channel
      if (SHARE_STATE.realtimeChannel) {
        supabase.removeChannel(SHARE_STATE.realtimeChannel);
      }

      try {
        // Subscribe to changes on this specific design
        const channel = supabase.channel(`design-${designId}`)
          .on('postgres_changes', {
            event: 'UPDATE',
            schema: 'public',
            table: 'room_designs',
            filter: `id=eq.${designId}`
          }, (payload) => {
            console.log(' Realtime update received:', payload);
            handleRealtimeUpdate(payload.new);
          })
          .subscribe((status, err) => {
            console.log('Realtime subscription status:', status, err || '');
            if (status === 'SUBSCRIBED') {
              SHARE_STATE.isLiveConnected = true;
              // Clear polling if realtime connects
              if (SHARE_STATE.pollingInterval) {
                clearInterval(SHARE_STATE.pollingInterval);
                SHARE_STATE.pollingInterval = null;
              }
            } else if (status === 'CHANNEL_ERROR' || status === 'TIMED_OUT') {
              SHARE_STATE.isLiveConnected = false;
              console.warn('Realtime failed, starting polling fallback');
              startPollingFallback(designId);
            }
            updateLiveIndicator();
          });

        SHARE_STATE.realtimeChannel = channel;
        console.log('Subscribed to realtime updates for design:', designId);

        // Also start polling as backup (will be cleared if realtime works)
        setTimeout(() => {
          if (!SHARE_STATE.isLiveConnected) {
            console.log('Realtime not connected after 5s, starting polling');
            startPollingFallback(designId);
          }
        }, 5000);

      } catch (err) {
        console.error('Failed to subscribe to realtime:', err);
        startPollingFallback(designId);
      }
    }

    // ===== REALTIME COMMENT NOTIFICATIONS FOR DESIGNERS =====
    // When a customer comments, the designer sees a toast notification

    function subscribeToCustomerComments(leadId) {
      // Only subscribe if we're a designer (not shared view) and have a lead
      if (SHARE_STATE.isSharedView || !leadId) return;

      const supabase = getSupabaseClient();
      if (!supabase) return;

      // Unsubscribe from any existing comments channel
      if (SHARE_STATE.commentsChannel) {
        supabase.removeChannel(SHARE_STATE.commentsChannel);
      }

      try {
        const channel = supabase.channel(`comments-${leadId}`)
          .on('postgres_changes', {
            event: 'INSERT',
            schema: 'public',
            table: 'customer_messages',
            filter: `customer_id=eq.${leadId}`
          }, (payload) => {
            console.log(' New comment received:', payload);
            handleNewComment(payload.new);
          })
          .subscribe((status, err) => {
            if (status === 'SUBSCRIBED') {
              console.log('Subscribed to customer comments for lead:', leadId);
            } else if (err) {
              console.warn('Comment subscription error:', err);
            }
          });

        SHARE_STATE.commentsChannel = channel;
      } catch (err) {
        console.error('Failed to subscribe to comments:', err);
      }
    }

    function handleNewComment(comment) {
      // Only notify for inbound (customer) messages
      if (comment.direction !== 'inbound') return;

      // Don't notify if viewing shared view (customer's own messages)
      if (SHARE_STATE.isSharedView) return;

      const customerName = SHARE_STATE.customerName || 'Customer';
      const messagePreview = comment.message?.length > 50
        ? comment.message.substring(0, 50) + '...'
        : comment.message;

      // Show clickable toast notification
      window.showCommentNotification(customerName, messagePreview);

      // Update the comments list if visible (fire and forget with error handling)
      if (typeof loadCommentsFromMessages === 'function' && SHARE_STATE.leadId) {
        loadCommentsFromMessages(SHARE_STATE.leadId, SHARE_STATE.shareId)
          .catch(err => console.warn('Error updating comments list:', err));
      }

      // Update the designer messages panel if visible (fire and forget with error handling)
      if (typeof loadDesignerMessages === 'function' && SHARE_STATE.leadId) {
        loadDesignerMessages(SHARE_STATE.leadId)
          .catch(err => console.warn('Error updating messages panel:', err));
      }
    }

    window.showCommentNotification = function(customerName, message) {
      // Validate inputs
      if (!customerName || !message) return;

      // Escape to prevent XSS
      const safeCustomerName = String(customerName).replace(/[<>&"']/g, c => ({
        '<': '&lt;', '>': '&gt;', '&': '&amp;', '"': '&quot;', "'": '&#39;'
      })[c]);
      const safeMessage = String(message).replace(/[<>&"']/g, c => ({
        '<': '&lt;', '>': '&gt;', '&': '&amp;', '"': '&quot;', "'": '&#39;'
      })[c]);

      // Create notification toast
      const toast = document.createElement('div');
      toast.className = 'comment-notification-toast';
      toast.innerHTML = `
        <div class="comment-notification-icon"></div>
        <div class="comment-notification-content">
          <div class="comment-notification-title">${safeCustomerName} commented:</div>
          <div class="comment-notification-message">${safeMessage}</div>
        </div>
        <div class="comment-notification-action">View </div>
      `;

      // Make it clickable - scrolls to comments section
      toast.onclick = () => {
        toast.remove();
        openCommentsPanel();
      };

      document.body.appendChild(toast);

      // Auto-dismiss after 8 seconds
      setTimeout(() => {
        if (toast.parentNode) {
          toast.classList.add('fade-out');
          setTimeout(() => toast.remove(), 300);
        }
      }, 8000);

      // Play notification sound if available
      try {
        const audio = new Audio('data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2teleAA+ipq9q3kMJl2Kvqp1FyxYf7epbhszU3u4p2clOFF0tqRnKjxPc7ShZC0+TnKznmEwQE1xsZxfMkJNcK+aXTRETPGtmFo3Rkr0q5ZYOEhJ+qqUVjpJR/2okFM7TEb/p45RPlBF/6WNUD9RRP+li04/UkT/pYtNPlRD/6WKSz5VQv+liko+VkH/pYlJPlc//6WISD5YPv+lh0Y+Wj7/pYZFPls9/6WFRD5cPP+lhEM+XTv/pYNBPl46/6WCQD5fOf+lgD8+YDj/pX8+PmE3/6V+PT5iNv+lfDw+YzX/pXs7PmQ0/6V6Oj5lM/+leTs+ZjP/pXg6Pmcy/6V3OT5oMf+ldDg+aTH/pXM3Pmow/6VyNj5rL/+lcTU+bC7/pXA0Pm0u/6VvMz5uLf+lbjI+byz/pW0xPnAr/6VsMP5xK/+lazD+cSr/pWov/nIq/6VpLv5zKf+laC3+dCn/pWcs/nUp/6VmLP51Kf+lZSv+dij/pWQr/nYo/6VkKv52KP+lYyr+dyf/pWIp/ngo/6VhKP54J/+lYCj+eSf/pV8n/nkn/6VeJ/56Jv+lXSb+eyb/pVwm/nwm/6VbJf58Jf+lWiX+fSX/pVkk/n4l/6VYJP5+JP+lVyT+fyT/pVYj/oAk/6VVJP6AJP+lVCP+gSP/pVMj/oEj/6VSIP6CI/+lUSH+giL/pVAh/oIi/w==');
        audio.volume = 0.3;
        audio.play().catch(() => {}); // Ignore if blocked
      } catch (e) {}
    };

    function openCommentsPanel() {
      // Check if we're in designer mode (messages section visible)
      const messagesSection = document.getElementById('messagesSection');
      if (messagesSection) {
        // Ensure content is visible
        const content = document.getElementById('messagesContent');
        if (content) content.style.display = 'block';

        // Scroll to messages section in designer view
        messagesSection.scrollIntoView({ behavior: 'smooth', block: 'center' });
        messagesSection.style.boxShadow = '0 0 20px rgba(139, 92, 246, 0.5)';
        setTimeout(() => {
          messagesSection.style.boxShadow = '';
        }, 2000);

        // Focus the reply input
        const replyInput = document.getElementById('designerReplyInput');
        if (replyInput) {
          replyInput.focus();
        }
        return;
      }

      // Otherwise find and click the review/share tab (customer view)
      const reviewTab = document.querySelector('[onclick*="showTab"][onclick*="review"]') ||
                        document.querySelector('[data-tab="review"]') ||
                        document.querySelector('.tab-btn:last-child');

      if (reviewTab) {
        reviewTab.click();
      }

      // Scroll to comments section after a short delay
      setTimeout(() => {
        const commentsSection = document.getElementById('reviewComments') ||
                               document.querySelector('.review-comments-section');
        if (commentsSection) {
          commentsSection.scrollIntoView({ behavior: 'smooth', block: 'center' });
          // Highlight the section briefly
          commentsSection.style.boxShadow = '0 0 20px rgba(139, 92, 246, 0.5)';
          setTimeout(() => {
            commentsSection.style.boxShadow = '';
          }, 2000);
        }

        // Focus the comment input
        const commentInput = document.getElementById('newCommentInput');
        if (commentInput) {
          commentInput.focus();
        }
      }, 300);
    }

    // Fetch customer name from leads table for notifications
    async function fetchCustomerName(leadId) {
      if (!leadId) return;

      try {
        const supabase = getSupabaseClient();
        if (!supabase) return;

        const { data, error } = await supabase
          .from('leads')
          .select('name, first_name, last_name, email')
          .eq('id', leadId)
          .single();

        if (data && !error) {
          SHARE_STATE.customerName = data.name ||
            (data.first_name && data.last_name ? `${data.first_name} ${data.last_name}` : null) ||
            data.first_name ||
            data.email?.split('@')[0] ||
            'Customer';
          console.log('Fetched customer name:', SHARE_STATE.customerName);
        }
      } catch (err) {
        console.warn('Could not fetch customer name:', err);
      }
    }

    // Polling fallback when Realtime isn't available
    function startPollingFallback(designId) {
      if (SHARE_STATE.pollingInterval) return; // Already polling

      console.log('Starting polling fallback for design:', designId);
      SHARE_STATE.lastPollData = null;

      const pollForUpdates = async () => {
        if (!designId) return;

        try {
          const { url: SUPABASE_URL, anonKey: SUPABASE_ANON_KEY } = getSupabaseConfig();

          const response = await fetch(
            `${SUPABASE_URL}/rest/v1/room_designs?id=eq.${designId}&select=updated_at,elements,rooms,room_width,room_depth,settings`,
            {
              headers: {
                'apikey': SUPABASE_ANON_KEY,
                'Authorization': `Bearer ${SUPABASE_ANON_KEY}`
              }
            }
          );

          if (response.ok) {
            const data = await response.json();
            if (data && data.length > 0) {
              const design = data[0];
              // Check if updated since last poll
              if (SHARE_STATE.lastPollData && design.updated_at !== SHARE_STATE.lastPollData) {
                console.log('Polling detected update:', design.updated_at);
                handleRealtimeUpdate(design);
              }
              SHARE_STATE.lastPollData = design.updated_at;
              SHARE_STATE.isLiveConnected = true;
              updateLiveIndicator();
            }
          }
        } catch (err) {
          console.warn('Poll failed:', err);
        }
      };

      // Poll every 5 seconds
      SHARE_STATE.pollingInterval = setInterval(pollForUpdates, 5000);
      pollForUpdates(); // Initial poll

      // Stop polling after 30 minutes to prevent resource drain
      SHARE_STATE.pollingTimeout = setTimeout(() => {
        if (SHARE_STATE.pollingInterval) {
          clearInterval(SHARE_STATE.pollingInterval);
          SHARE_STATE.pollingInterval = null;
          console.log('Polling stopped after 30 minutes - refresh page to resume');
          showToast('Live updates paused. Refresh to resume.', 'info', 5000);
        }
      }, 30 * 60 * 1000);
    }

    function handleRealtimeUpdate(newData) {
      if (!newData) return;

      console.log('Applying realtime update...');
      SHARE_STATE.lastSyncTime = new Date();

      // Show sync notification
      showToast('Design updated by designer', 'info', 2000);

      // Update room dimensions first (needed for fitToScreen before deserialization)
      if (newData.room_width) roomWidth = newData.room_width;
      if (newData.room_depth) roomDepth = newData.room_depth;

      const savedScale = newData.settings?.pixelsPerFoot || pixelsPerFoot;

      // Update elements  only if new data has actual content
      if (newData.elements && Array.isArray(newData.elements) && newData.elements.length > 0) {
        elements.length = 0;
        newData.elements.forEach(el => {
          el.textureImg = null;
          deserializeElement(el, savedScale);
          elements.push(el);
        });
      } else if (newData.elements && Array.isArray(newData.elements) && newData.elements.length === 0) {
        console.warn('Realtime update has empty elements  skipping to prevent data loss');
      }

      // Update rooms array if present and non-empty
      const realtimeRooms = (newData.rooms && newData.rooms.length > 0) ? newData.rooms
        : (newData.settings?.rooms && newData.settings.rooms.length > 0) ? newData.settings.rooms
        : null;
      if (realtimeRooms) {
        rooms.length = 0;
        realtimeRooms.forEach(room => {
          room.elements = room.elements || [];
          room.elements.forEach(el => {
            el.textureImg = null;
            deserializeElement(el, savedScale);
          });
          if (room.walls) {
            room.walls.forEach(w => deserializeWall(w, savedScale));
          }
          room.pixelsPerFoot = pixelsPerFoot;
          rooms.push(room);
        });
      }

      // Update settings
      if (newData.settings) {
        if (newData.settings.walls) walls = newData.settings.walls;
        if (newData.settings.pricing_config) {
          PRICING_STATE.globalMargin = newData.settings.pricing_config.globalMargin || 30;
          PRICING_STATE.categoryMargins = newData.settings.pricing_config.categoryMargins || {};
        }
        // Also check for rooms inside settings (new format)
        if (newData.settings.rooms && Array.isArray(newData.settings.rooms) && newData.settings.rooms.length > 0 && !(newData.rooms && newData.rooms.length > 0)) {
          rooms.length = 0;
          newData.settings.rooms.forEach(room => {
            room.elements = room.elements || [];
            room.elements.forEach(el => el.textureImg = null);
            rooms.push(room);
          });
        }
      }

      // Reload textures and redraw
      elements.forEach(el => {
        if (el.texture) {
          const img = new Image();
          img.crossOrigin = 'anonymous';
          img.onload = () => {
            el.textureImg = img;
            draw();
          };
          img.src = el.texture;
        }
      });

      // Redraw 2D canvas
      draw();

      // Update 3D view
      if (currentView === '3d') {
        init3D();
        render3D();
      }

      // Update quote
      calculateQuote();
      buildQuotePreviewData();
      renderQuotePreview();

      // Update review panel if visible
      if (document.getElementById('reviewElements')) {
        populateReviewElements();
      }

      // Update properties panel to show current material info
      updateProperties();

      // Flash the live indicator
      flashLiveIndicator();
    }

    function updateLiveIndicator() {
      const indicator = document.getElementById('liveIndicator');
      if (indicator) {
        indicator.className = SHARE_STATE.isLiveConnected ? 'live-indicator connected' : 'live-indicator disconnected';
        indicator.title = SHARE_STATE.isLiveConnected ? 'Live sync active - changes appear instantly' : 'Disconnected - refresh to see changes';
      }
    }

    function flashLiveIndicator() {
      const indicator = document.getElementById('liveIndicator');
      if (indicator) {
        indicator.classList.add('flash');
        setTimeout(() => indicator.classList.remove('flash'), 1000);
      }
    }

    // Broadcast design changes to connected viewers (called on auto-save)
    async function broadcastDesignUpdate() {
      if (!SHARE_STATE.designId) return;

      const supabase = getSupabaseClient();
      if (!supabase) return;

      try {
        // The database update will trigger the realtime subscription
        // Just update the design record - subscribers will get notified automatically
        console.log('Design update will broadcast via Supabase Realtime');
      } catch (err) {
        console.error('Broadcast error:', err);
      }
    }

    // ===== REALTIME SYNC TEST FUNCTIONS =====
    // Call these from browser console to test realtime functionality

    window.testRealtimeStatus = function() {
      console.log('=== REALTIME SYNC STATUS ===');
      console.log('Design ID:', SHARE_STATE.designId);
      console.log('Is Shared View:', SHARE_STATE.isSharedView);
      console.log('Is Live Connected:', SHARE_STATE.isLiveConnected);
      console.log('Realtime Channel:', SHARE_STATE.realtimeChannel ? 'Active' : 'Not subscribed');
      console.log('Last Sync Time:', SHARE_STATE.lastSyncTime);
      console.log('Supabase Client:', getSupabaseClient() ? 'Available' : 'Not available');
      return SHARE_STATE;
    };

    window.testRealtimeUpdate = async function() {
      if (!SHARE_STATE.designId) {
        console.log('No design ID - save design to cloud first');
        return;
      }

      console.log('=== TESTING REALTIME UPDATE ===');
      console.log('Triggering cloud sync...');

      // Force a sync to trigger realtime for any connected viewers
      await syncDesignToCloud();

      console.log('Sync triggered - check connected viewer for update');
    };

    window.testRealtimeSubscribe = function(designId) {
      const id = designId || SHARE_STATE.designId;
      if (!id) {
        console.log('Please provide a design ID: testRealtimeSubscribe("your-design-id")');
        return;
      }

      console.log('=== SUBSCRIBING TO DESIGN ===');
      subscribeToDesignUpdates(id);
      console.log('Check console for subscription status messages');
    };

    window.simulateRealtimeUpdate = function() {
      console.log('=== SIMULATING REALTIME UPDATE ===');
      // Simulate what happens when a realtime update is received
      handleRealtimeUpdate({
        elements: elements.map(el => ({
          ...el,
          color: '#' + Math.floor(Math.random()*16777215).toString(16) // Random color
        })),
        room_width: roomWidth,
        room_depth: roomDepth
      });
      console.log('Simulated update applied - elements should have random colors');
    };

    // Test comment notification (for debugging)
    window.testCommentNotification = function(message = 'This is a test comment from the customer!') {
      console.log('=== TESTING COMMENT NOTIFICATION ===');
      console.log('showCommentNotification exists:', typeof window.showCommentNotification);
      const customerName = SHARE_STATE.customerName || 'Test Customer';
      window.showCommentNotification(customerName, message);
      console.log('Notification should appear. Click it to go to comments section.');
    };

    // Debug notification status
    window.debugNotifications = function() {
      console.log('=== NOTIFICATION DEBUG ===');
      console.log('Design ID:', SHARE_STATE.designId);
      console.log('Lead ID:', SHARE_STATE.leadId);
      console.log('Customer Name:', SHARE_STATE.customerName);
      console.log('Is Shared View:', SHARE_STATE.isSharedView);
      console.log('Comments Channel:', SHARE_STATE.commentsChannel ? 'Active' : 'Not subscribed');
      console.log('Realtime Channel:', SHARE_STATE.realtimeChannel ? 'Active' : 'Not subscribed');
      console.log('showCommentNotification:', typeof window.showCommentNotification);
      return {
        designId: SHARE_STATE.designId,
        leadId: SHARE_STATE.leadId,
        customerName: SHARE_STATE.customerName,
        isSharedView: SHARE_STATE.isSharedView,
        commentsSubscribed: !!SHARE_STATE.commentsChannel,
        realtimeSubscribed: !!SHARE_STATE.realtimeChannel
      };
    };

    // Pricing access control - only paid subscribers see pricing
    const PRICING_ACCESS = {
      isSubscribed: false,        // Whether user has paid subscription
      accountType: null,          // User's account type (homeowner, pro, fabricator, etc.)
      canViewPricing: false,      // Computed: can this user see pricing?
      checkedAt: null             // When we last checked subscription status
    };

    // Account types that can view pricing (paid tiers)
    const PAID_ACCOUNT_TYPES = ['pro', 'vendor', 'fabricator', 'business', 'enterprise', 'distributor', 'admin', 'super_admin'];

    // Check if current user can view pricing
    async function checkPricingAccess(forceRefresh = false) {
      try {
        const user = window.SgAuth?.getUser();
        let profile = null;

        // If force refresh, fetch directly from database
        if (forceRefresh && user) {
          const supabase = getSupabaseClient();
          if (supabase) {
            const { data } = await supabase
              .from('sg_users')
              .select('account_type, subscription_status')
              .eq('id', user.id)
              .single();
            profile = data;
            console.log('Force refreshed user profile:', profile);
          }
        } else {
          profile = await window.SgAuth?.getProfile?.();
        }

        PRICING_ACCESS.checkedAt = Date.now();

        // Super admin emails always get full access
        const SUPER_ADMIN_EMAILS = ['joshb@surprisegranite.com', 'info@surprisegranite.com'];
        const isSuperAdmin = user && SUPER_ADMIN_EMAILS.includes((user.email || '').toLowerCase());

        if (!user) {
          // Guest user - no pricing access
          PRICING_ACCESS.isSubscribed = false;
          PRICING_ACCESS.accountType = 'guest';
          PRICING_ACCESS.canViewPricing = false;
        } else if (isSuperAdmin) {
          // Super admin - full access regardless of account_type
          PRICING_ACCESS.accountType = 'super_admin';
          PRICING_ACCESS.isSubscribed = true;
          PRICING_ACCESS.canViewPricing = true;
          console.log('Super Admin detected - full pricing access granted');
        } else if (profile) {
          PRICING_ACCESS.accountType = (profile.account_type || 'homeowner').toLowerCase();
          PRICING_ACCESS.isSubscribed = PAID_ACCOUNT_TYPES.includes(PRICING_ACCESS.accountType);
          PRICING_ACCESS.canViewPricing = PRICING_ACCESS.isSubscribed;
          console.log('User account type:', PRICING_ACCESS.accountType, 'Can view pricing:', PRICING_ACCESS.canViewPricing);
        } else {
          // Logged in but no profile - treat as free tier
          PRICING_ACCESS.accountType = 'homeowner';
          PRICING_ACCESS.isSubscribed = false;
          PRICING_ACCESS.canViewPricing = false;
        }

        console.log('Pricing access:', PRICING_ACCESS);
        updatePricingVisibility();
        return PRICING_ACCESS.canViewPricing;
      } catch (err) {
        console.warn('Error checking pricing access:', err);
        PRICING_ACCESS.canViewPricing = false;
        updatePricingVisibility();
        return false;
      }
    }

    // Update UI to show/hide pricing based on access
    function updatePricingVisibility() {
      const canView = PRICING_ACCESS.canViewPricing;

      // Pricing section in properties panel
      const pricingSection = document.getElementById('pricingSection');
      if (pricingSection) {
        if (canView) {
          pricingSection.classList.remove('pricing-locked');
          pricingSection.style.display = '';
        } else {
          pricingSection.classList.add('pricing-locked');
        }
      }

      // Quote panel
      const quotePanel = document.getElementById('quotePanel');
      if (quotePanel) {
        if (canView) {
          quotePanel.classList.remove('pricing-locked');
        } else {
          quotePanel.classList.add('pricing-locked');
        }
      }

      // Quote total
      const quoteTotal = document.getElementById('quoteTotal');
      if (quoteTotal && !canView) {
        quoteTotal.textContent = '---';
      }

      // Show/hide manage subscription button
      const manageSubBtn = document.getElementById('manageSubscriptionBtn');
      if (manageSubBtn) {
        manageSubBtn.style.display = canView ? 'flex' : 'none';
      }

      // Add/update pricing locked overlay
      updatePricingLockedOverlay();

      // Refresh cabinet catalog to show/hide prices
      if (typeof renderCabinetCatalog === 'function') {
        renderCabinetCatalog();
      }

      // Refresh materials list to show/hide prices
      if (typeof renderMaterials === 'function' && typeof currentMaterialCategory !== 'undefined') {
        renderMaterials(currentMaterialCategory);
      }
    }

    // Open Stripe billing portal for subscription management
    async function openBillingPortal() {
      const user = window.SgAuth?.getUser();
      if (!user) {
        showNotification('Please sign in to manage your subscription', 'error');
        return;
      }

      try {
        showNotification('Opening billing portal...', 'info', 2000);

        const response = await fetch('/api/pro-billing-portal', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            user_id: user.id,
            return_url: window.location.href
          })
        });

        const data = await response.json();

        if (data.success && data.url) {
          window.location.href = data.url;
        } else {
          throw new Error(data.error || 'Failed to open billing portal');
        }
      } catch (err) {
        console.error('Billing portal error:', err);
        showNotification(err.message || 'Failed to open billing portal', 'error');
      }
    }

    // Create/update the pricing locked overlay
    function updatePricingLockedOverlay() {
      const existingOverlay = document.getElementById('pricingLockedOverlay');

      if (PRICING_ACCESS.canViewPricing) {
        // Remove overlay if it exists
        if (existingOverlay) existingOverlay.remove();
        return;
      }

      // Create overlay if doesn't exist
      if (!existingOverlay) {
        const overlay = document.createElement('div');
        overlay.id = 'pricingLockedOverlay';
        overlay.className = 'pricing-locked-overlay';

        const isLoggedIn = !!window.SgAuth?.getUser();
        const accountType = PRICING_ACCESS.accountType || 'guest';

        overlay.innerHTML = `
          <div class="pricing-locked-content">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:40px;height:40px;margin-bottom:12px;opacity:0.5;">
              <rect x="3" y="11" width="18" height="11" rx="2" ry="2"/>
              <path d="M7 11V7a5 5 0 0 1 10 0v4"/>
            </svg>
            <h4>Unlock Pricing</h4>
            <p style="margin-bottom:16px;">Upgrade to Pro to access material pricing, quotes, and takeoffs.</p>

            <div class="upgrade-plans" style="display:flex;flex-direction:column;gap:10px;margin-bottom:16px;">
              <button class="upgrade-plan-btn" data-plan="pro" onclick="startUpgrade('pro')">
                <div style="display:flex;justify-content:space-between;align-items:center;width:100%;">
                  <div style="text-align:left;">
                    <div style="font-weight:600;font-size:14px;">Pro Plan</div>
                    <div style="font-size:11px;opacity:0.8;">Pricing, quotes & takeoffs</div>
                  </div>
                  <div style="text-align:right;">
                    <div style="font-weight:700;font-size:16px;">$29<span style="font-size:11px;font-weight:400;">/mo</span></div>
                  </div>
                </div>
              </button>
              <button class="upgrade-plan-btn upgrade-plan-featured" data-plan="fabricator" onclick="startUpgrade('fabricator')">
                <div style="position:absolute;top:-8px;right:12px;background:#f9cb00;color:#1a1a2e;font-size:9px;padding:2px 8px;border-radius:4px;font-weight:600;">POPULAR</div>
                <div style="display:flex;justify-content:space-between;align-items:center;width:100%;">
                  <div style="text-align:left;">
                    <div style="font-weight:600;font-size:14px;">Fabricator Plan</div>
                    <div style="font-size:11px;opacity:0.8;">Wholesale pricing + CRM</div>
                  </div>
                  <div style="text-align:right;">
                    <div style="font-weight:700;font-size:16px;">$79<span style="font-size:11px;font-weight:400;">/mo</span></div>
                  </div>
                </div>
              </button>
            </div>

            ${!isLoggedIn ? `
              <div style="font-size:12px;color:var(--text-muted);margin-bottom:12px;">
                Already have an account? <a href="javascript:void(0)" onclick="showLoginPrompt('Log in to access your subscription.'); return false;" style="color:#6366f1;">Log in</a>
              </div>
            ` : accountType === 'homeowner' ? `
              <div style="font-size:12px;color:var(--text-muted);margin-bottom:12px;">
                Currently on free plan. Upgrade to unlock pricing.
              </div>
            ` : ''}

            <div style="font-size:11px;color:var(--text-muted);">
               Cancel anytime &nbsp;  7-day free trial
            </div>
          </div>
        `;

        // Insert after quote panel
        const quotePanel = document.getElementById('quotePanel');
        if (quotePanel) {
          quotePanel.parentNode.insertBefore(overlay, quotePanel.nextSibling);
        }
      }
    }

    // Start the upgrade process
    async function startUpgrade(plan = 'pro') {
      const user = window.SgAuth?.getUser();

      // If not logged in, prompt to sign up first
      if (!user) {
        showLoginPrompt('Create an account to start your Pro subscription.', () => {
          // After successful login, redirect to upgrade
          setTimeout(() => startUpgrade(plan), 500);
        });
        return;
      }

      // Show loading state
      const btn = document.querySelector(`[data-plan="${plan}"]`);
      if (btn) {
        btn.disabled = true;
        btn.innerHTML = '<div style="display:flex;align-items:center;justify-content:center;gap:8px;"><span class="spinner" style="width:16px;height:16px;border:2px solid rgba(255,255,255,0.3);border-top-color:#fff;border-radius:50%;animation:spin 1s linear infinite;"></span> Processing...</div>';
      }

      try {
        const response = await fetch('/api/create-pro-subscription', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            user_id: user.id,
            user_email: user.email,
            plan: plan,
            billing_cycle: 'monthly',
            success_url: window.location.origin + '/tools/room-designer/?subscription=success&plan=' + plan,
            cancel_url: window.location.origin + '/tools/room-designer/?subscription=canceled'
          })
        });

        const data = await response.json();

        if (data.success && data.url) {
          // Redirect to Stripe Checkout
          window.location.href = data.url;
        } else {
          throw new Error(data.error || 'Failed to create checkout session');
        }
      } catch (err) {
        console.error('Upgrade error:', err);
        showNotification('Failed to start upgrade. Please try again.', 'error');

        // Reset button
        if (btn) {
          btn.disabled = false;
          updatePricingLockedOverlay();
        }
      }
    }

    // Handle subscription callback from Stripe
    async function handleSubscriptionCallback(status, plan) {
      if (status === 'success') {
        // Subscription successful - force refresh pricing access from database
        // (webhook may have updated account_type)
        await checkPricingAccess(true);

        const planName = plan ? plan.charAt(0).toUpperCase() + plan.slice(1) : 'Pro';

        // Show success notification
        showNotification(`Welcome to ${planName}! You now have access to pricing, quotes, and takeoffs.`, 'success', 5000);

        // Show a celebration modal
        const modal = document.createElement('div');
        modal.className = 'modal-overlay';
        modal.id = 'subscriptionSuccessModal';
        modal.innerHTML = `
          <div class="modal" style="max-width: 420px; text-align: center;">
            <div style="font-size: 48px; margin-bottom: 16px;"></div>
            <h3 style="margin-bottom: 12px; color: #10b981;">Welcome to ${planName}!</h3>
            <p style="color: var(--text-muted); margin-bottom: 20px;">
              Your subscription is now active. You have full access to:
            </p>
            <ul style="text-align: left; margin: 0 0 24px 20px; color: var(--text);">
              <li style="margin-bottom: 8px;"> Real-time material pricing</li>
              <li style="margin-bottom: 8px;"> Professional quotes & estimates</li>
              <li style="margin-bottom: 8px;"> Detailed takeoff reports</li>
              <li style="margin-bottom: 8px;"> Unlimited design saves</li>
            </ul>
            <button class="btn btn-primary" onclick="document.getElementById('subscriptionSuccessModal').remove();" style="width: 100%;">
              Start Designing
            </button>
          </div>
        `;
        document.body.appendChild(modal);

      } else if (status === 'canceled') {
        showNotification('Subscription canceled. You can upgrade anytime to unlock pricing.', 'info', 4000);
      }
    }

    const PERMISSION_LEVELS = {
      full_collab: {
        name: 'Full Collaboration',
        description: 'Can edit everything including prices',
        canEdit: true,
        canViewPrices: true,
        canViewCosts: true,
        canViewMaterials: true,
        canExport: true,
        canApprove: false
      },
      quote_approval: {
        name: 'Design Approval',
        description: 'Customer can view design and approve with payment',
        canEdit: false,
        canViewPrices: true,
        canViewCosts: false,
        canViewMaterials: true,
        canExport: true,
        canApprove: true
      },
      quote_view: {
        name: 'Quote View',
        description: 'Can see prices but cannot edit',
        canEdit: false,
        canViewPrices: true,
        canViewCosts: false,
        canViewMaterials: true,
        canExport: true,
        canApprove: false
      },
      material_view: {
        name: 'Material View',
        description: 'See materials only, no pricing',
        canEdit: false,
        canViewPrices: false,
        canViewCosts: false,
        canViewMaterials: true,
        canExport: false
      },
      presentation: {
        name: 'Presentation',
        description: 'Client-pretty view, no costs shown',
        canEdit: false,
        canViewPrices: false,
        canViewCosts: false,
        canViewMaterials: false,
        canExport: false
      }
    };

    // ===== BUILDING STANDARDS =====
    const BUILDING_STANDARDS = {
      // Standard element dimensions (in feet)
      DOORS: {
        interior: { width: 2.667, height: 6.667, label: "2'-8\"  6'-8\"" },    // 32"  80"
        interiorWide: { width: 3, height: 6.667, label: "3'-0\"  6'-8\"" },    // 36"  80"
        exterior: { width: 3, height: 6.667, label: "3'-0\"  6'-8\"" },        // 36"  80"
        exteriorTall: { width: 3, height: 7, label: "3'-0\"  7'-0\"" },        // 36"  84"
        double: { width: 5, height: 6.667, label: "5'-0\"  6'-8\"" },          // 60"  80"
        sliding: { width: 6, height: 6.667, label: "6'-0\"  6'-8\"" },         // 72"  80"
        garage1car: { width: 8, height: 7, label: "8'-0\"  7'-0\"" },          // 96"  84"
        garage2car: { width: 16, height: 7, label: "16'-0\"  7'-0\"" }         // 192"  84"
      },
      WINDOWS: {
        small: { width: 2, height: 3, label: "2'-0\"  3'-0\"" },               // 24"  36"
        standard: { width: 3, height: 4, label: "3'-0\"  4'-0\"" },            // 36"  48"
        large: { width: 4, height: 5, label: "4'-0\"  5'-0\"" },               // 48"  60"
        picture: { width: 6, height: 4, label: "6'-0\"  4'-0\"" }              // 72"  48"
      },
      CABINETS: {
        // Base cabinets (height is depth in floor plan)
        base12: { width: 1, depth: 2, label: "12\" wide" },
        base15: { width: 1.25, depth: 2, label: "15\" wide" },
        base18: { width: 1.5, depth: 2, label: "18\" wide" },
        base21: { width: 1.75, depth: 2, label: "21\" wide" },
        base24: { width: 2, depth: 2, label: "24\" wide" },
        base27: { width: 2.25, depth: 2, label: "27\" wide" },
        base30: { width: 2.5, depth: 2, label: "30\" wide" },
        base33: { width: 2.75, depth: 2, label: "33\" wide" },
        base36: { width: 3, depth: 2, label: "36\" wide" },
        base42: { width: 3.5, depth: 2, label: "42\" wide" },
        base48: { width: 4, depth: 2, label: "48\" wide" },
        // Wall cabinets (shallower depth)
        wall12: { width: 1, depth: 1, label: "12\" wide" },
        wall15: { width: 1.25, depth: 1, label: "15\" wide" },
        wall18: { width: 1.5, depth: 1, label: "18\" wide" },
        wall24: { width: 2, depth: 1, label: "24\" wide" },
        wall30: { width: 2.5, depth: 1, label: "30\" wide" },
        wall36: { width: 3, depth: 1, label: "36\" wide" },
        // Tall/Pantry
        tall24: { width: 2, depth: 2, label: "24\" wide pantry" },
        tall36: { width: 3, depth: 2, label: "36\" wide pantry" }
      },
      COUNTERTOPS: {
        standardDepth: 2.083,  // 25" including overhang
        barHeight: 3.5,       // 42" bar height
        islandMinWidth: 2,    // 24" minimum
        islandMinDepth: 4     // 48" minimum for seating
      },
      // Clearance requirements (in feet)
      CLEARANCES: {
        walkway: 3,           // 36" minimum walkway
        twoCoook: 4,          // 48" for two cooks
        applianceOpen: 3.5,   // 42" in front of open appliance
        islandWalkway: 3.5,   // 42" around island
        adaTurning: 5,        // 60" ADA turning radius
        doorSwing: 1.5,       // 18" beside door latch
        doorFront: 5          // 60" in front of door
      },
      // Work triangle limits (in feet)
      WORK_TRIANGLE: {
        legMin: 4,            // Minimum leg length
        legMax: 9,            // Maximum leg length
        perimeterMin: 13,     // Minimum total perimeter
        perimeterMax: 26      // Maximum total perimeter
      },
      // Standard heights (for 3D and reference)
      HEIGHTS: {
        ceiling: 8,           // 8' standard ceiling
        ceilingTall: 9,       // 9' ceiling
        ceilingLuxury: 10,    // 10' ceiling
        baseCounter: 3,       // 36" counter height
        barCounter: 3.5,      // 42" bar height
        wallCabBottom: 4.5,   // 54" to bottom of wall cabinet
        wallCabTop: 7,        // 84" to top of wall cabinet
        rangeHood: 5.5,       // 66" to bottom of hood
        windowSill: 3         // 36" typical window sill
      }
    };

    // Standard snap dimensions (in feet) for smart snapping
    const SNAP_DIMENSIONS = {
      widths: [1, 1.25, 1.5, 1.75, 2, 2.25, 2.5, 2.75, 3, 3.5, 4, 4.5, 5, 6, 8],
      depths: [1, 1.5, 2, 2.5, 3, 4],
      tolerance: 0.0833  // 1" snap tolerance
    };

    // ===== MATERIAL TYPE RESTRICTIONS =====
    // Controls which material categories can be applied to which element types
    const MATERIAL_TYPE_MAP = {
      // Stone materials (granite, quartz, marble, quartzite, dekton, etc.) -> countertops only
      granite: ['countertop', 'countertop-corner', 'countertop-l', 'countertop-u', 'island', 'backsplash'],
      quartz: ['countertop', 'countertop-corner', 'countertop-l', 'countertop-u', 'island', 'backsplash'],
      marble: ['countertop', 'countertop-corner', 'countertop-l', 'countertop-u', 'island', 'backsplash'],
      quartzite: ['countertop', 'countertop-corner', 'countertop-l', 'countertop-u', 'island', 'backsplash'],
      stone: ['countertop', 'countertop-corner', 'countertop-l', 'countertop-u', 'island', 'backsplash'],
      // Sintered stone / ultra-compact surfaces (Dekton, Neolith, etc.)
      dekton: ['countertop', 'countertop-corner', 'countertop-l', 'countertop-u', 'island', 'backsplash'],
      sintered: ['countertop', 'countertop-corner', 'countertop-l', 'countertop-u', 'island', 'backsplash'],
      neolith: ['countertop', 'countertop-corner', 'countertop-l', 'countertop-u', 'island', 'backsplash'],
      porcelain: ['countertop', 'countertop-corner', 'countertop-l', 'countertop-u', 'island', 'backsplash', 'tile', 'flooring'],
      soapstone: ['countertop', 'countertop-corner', 'countertop-l', 'countertop-u', 'island'],
      onyx: ['countertop', 'countertop-corner', 'countertop-l', 'countertop-u', 'island', 'backsplash'],
      travertine: ['countertop', 'countertop-corner', 'countertop-l', 'countertop-u', 'island', 'backsplash', 'flooring'],
      limestone: ['countertop', 'countertop-corner', 'countertop-l', 'countertop-u', 'island', 'backsplash', 'flooring'],
      // Cabinet finishes -> cabinets only
      cabinets: ['base-cabinet', 'wall-cabinet', 'tall-cabinet', 'corner-cabinet', 'sink-base',
                 'drawer-base', 'lazy-susan', 'fridge-cabinet', 'pantry', 'blind-corner',
                 'microwave-cabinet', 'island'],
      cabinet: ['base-cabinet', 'wall-cabinet', 'tall-cabinet', 'corner-cabinet', 'sink-base',
                'drawer-base', 'lazy-susan', 'fridge-cabinet', 'pantry', 'blind-corner',
                'microwave-cabinet', 'island'],
      // Tile -> backsplash, flooring
      tile: ['backsplash', 'flooring', 'tile', 'shower-wall', 'shower-floor'],
      // Flooring -> floor elements
      flooring: ['flooring', 'tile']
    };

    // Helper function to check if a material category can be applied to an element
    function canApplyMaterialToElement(category, element, showWarning = true) {
      if (!category) return true; // No category restriction

      const normalizedCategory = category.toLowerCase().trim();
      const allowedTypes = MATERIAL_TYPE_MAP[normalizedCategory];

      // No restriction for this category
      if (!allowedTypes) return true;

      // Check if element type matches any allowed type
      const elementType = element.type || '';
      const isAllowed = allowedTypes.some(t => elementType.includes(t) || elementType === t);

      if (!isAllowed && showWarning) {
        const categoryLabel = normalizedCategory.charAt(0).toUpperCase() + normalizedCategory.slice(1);
        showToast(`${categoryLabel} materials can only be applied to ${allowedTypes.slice(0, 3).join(', ')}${allowedTypes.length > 3 ? '...' : ''}`, 'warning');
      }

      console.log('Material type check:', { category: normalizedCategory, elementType, allowedTypes, isAllowed });
      return isAllowed;
    }

    // ===== SLAB & MATERIAL STANDARDS =====
    const SLAB_STANDARDS = {
      // Standard slab sizes by material type (in inches)
      granite: {
        width: 115,       // Typical granite slab width
        height: 68,       // Typical granite slab height
        thickness: ['2cm', '3cm'],
        sqftPerSlab: 54.3, // 115  68 / 144
        wastePercent: 25,  // 25% waste for natural stone (irregular shapes, veining match)
        label: 'Granite Slab'
      },
      quartzite: {
        width: 120,
        height: 65,
        thickness: ['2cm', '3cm'],
        sqftPerSlab: 54.2,
        wastePercent: 25,
        label: 'Quartzite Slab'
      },
      marble: {
        width: 110,
        height: 65,
        thickness: ['2cm', '3cm'],
        sqftPerSlab: 49.7,
        wastePercent: 30,  // Higher waste for veining match
        label: 'Marble Slab'
      },
      quartz: {
        width: 126,       // Engineered quartz (Cambria, Silestone, etc.)
        height: 63,
        thickness: ['2cm', '3cm'],
        sqftPerSlab: 55.1,
        wastePercent: 20,  // Lower waste - consistent pattern
        label: 'Quartz Slab'
      },
      porcelain: {
        width: 126,       // Large format porcelain
        height: 63,
        thickness: ['6mm', '12mm', '20mm'],
        sqftPerSlab: 55.1,
        wastePercent: 15,  // Lowest waste
        label: 'Porcelain Slab'
      },
      dekton: {
        width: 126,       // Dekton / sintered stone (Cosentino)
        height: 56,
        thickness: ['8mm', '12mm', '20mm', '30mm'],
        sqftPerSlab: 49,
        wastePercent: 18,
        label: 'Dekton Slab'
      },
      sintered: {
        width: 126,       // Generic sintered stone (Neolith, etc.)
        height: 60,
        thickness: ['6mm', '12mm', '20mm'],
        sqftPerSlab: 52.5,
        wastePercent: 18,
        label: 'Sintered Stone Slab'
      },
      soapstone: {
        width: 84,
        height: 36,
        thickness: ['3cm'],
        sqftPerSlab: 21,
        wastePercent: 30,
        label: 'Soapstone Slab'
      },
      // Jumbo slabs (some suppliers)
      jumboQuartz: {
        width: 132,
        height: 65,
        thickness: ['2cm', '3cm'],
        sqftPerSlab: 59.6,
        wastePercent: 18,
        label: 'Jumbo Quartz Slab'
      },
      jumboGranite: {
        width: 130,
        height: 78,
        thickness: ['3cm'],
        sqftPerSlab: 70.4,
        wastePercent: 22,
        label: 'Jumbo Granite Slab'
      }
    };

    const TAKEOFF_STANDARDS = {
      // Cabinet standards
      cabinet: {
        // Standard cabinet widths in inches (most common sizes)
        standardWidths: [9, 12, 15, 18, 21, 24, 27, 30, 33, 36],
        // Toe kick specifications
        toeKick: {
          height: 4.5,  // inches
          depth: 3,     // inches recessed
          pricePerLF: 4.50  // $/LF
        },
        // Scribe molding for walls
        scribe: {
          pricePerLF: 8.50,
          widths: [0.5, 0.75, 1.5]  // inches
        },
        // Filler strips
        filler: {
          minWidth: 1.5,   // inches - minimum practical filler
          maxWidth: 6,     // inches - max before using cabinet
          pricePerLF: 12,  // $/LF height (typically 30" or 34.5" for base)
          standardWidths: [3, 6]  // inches
        },
        // Heights
        baseHeight: 34.5,  // inches (without countertop)
        wallHeight: 30,    // inches (standard wall cabinet)
        tallHeight: 84     // inches (tall/pantry cabinet)
      },
      // Slab/stone calculations
      slab: {
        standardSizes: [
          { name: 'Half Slab', width: 60, height: 55, sqft: 22.9 },
          { name: 'Standard Slab', width: 120, height: 55, sqft: 45.8 },
          { name: 'Jumbo Slab', width: 130, height: 65, sqft: 58.7 }
        ],
        wastePercent: 20,  // typical waste for countertop fabrication
        seamAllowance: 0.125  // 1/8" seam allowance
      },
      // Flooring waste factors
      flooring: {
        tile: { wastePercent: 15, boxSqft: 10, label: 'Tile' },
        hardwood: { wastePercent: 10, boxSqft: 20, label: 'Hardwood' },
        lvp: { wastePercent: 10, boxSqft: 24, label: 'LVP/LVT' },
        carpet: { wastePercent: 5, rollWidth: 12, label: 'Carpet' },
        naturalStone: { wastePercent: 20, boxSqft: 5, label: 'Natural Stone Tile' }
      },
      // Scribe molding requirements
      scribe: {
        pricePerLF: 8.50,   // $/LF for scribe molding
        widthOptions: [0.5, 0.75, 1.5, 3], // Standard scribe widths in inches
        requiresWhen: ['wall', 'corner', 'uneven']
      },
      // Filler requirements
      filler: {
        pricePerLF: 25,     // $/LF for filler strips
        minWidth: 0.125,    // 1.5" minimum to count
        standardWidths: [3, 6, 12] // Standard filler widths available (inches)
      },
      // Edge profile linear feet pricing
      edgeProfiles: {
        eased: { pricePerLF: 0, labor: 'standard' },
        bullnose: { pricePerLF: 12, labor: 'standard' },
        ogee: { pricePerLF: 18, labor: 'specialty' },
        dupont: { pricePerLF: 22, labor: 'specialty' },
        waterfall: { pricePerLF: 45, labor: 'miter' }
      },
      // Backsplash calculations
      backsplash: {
        standard4: { height: 4, pricePerLF: 35 },
        standard6: { height: 6, pricePerLF: 45 },
        fullHeight: { height: 18, pricePerLF: 85 }
      },
      // Sink cutout pricing
      sinkCutouts: {
        undermount: { price: 175, label: 'Undermount Cutout' },
        dropin: { price: 75, label: 'Drop-in Cutout' },
        farmhouse: { price: 225, label: 'Farmhouse/Apron Cutout' },
        prep: { price: 125, label: 'Prep Sink Cutout' }
      },
      // Cooktop cutout
      cooktopCutout: { price: 125, label: 'Cooktop Cutout' }
    };

    // ===== LABOR RATES CONFIGURATION =====
    // Editable labor pricing for all services
    const LABOR_RATES = {
      // Stone/Countertop Services (per sqft unless noted)
      stone: {
        fabrication: { rate: 35, unit: 'sqft', label: 'Stone Fabrication', category: 'countertop' },
        installation: { rate: 15, unit: 'sqft', label: 'Countertop Installation', category: 'countertop' },
        polish: { rate: 8, unit: 'sqft', label: 'Polish/Seal', category: 'countertop' },
        template: { rate: 150, unit: 'visit', label: 'Template Visit', category: 'countertop' },
        delivery: { rate: 125, unit: 'trip', label: 'Delivery', category: 'countertop' }
      },
      // Cabinet Services
      cabinet: {
        installation: { rate: 85, unit: 'cabinet', label: 'Cabinet Installation', category: 'cabinet' },
        assembly: { rate: 45, unit: 'cabinet', label: 'Cabinet Assembly (RTA)', category: 'cabinet' },
        crownMolding: { rate: 12, unit: 'lf', label: 'Crown Molding Install', category: 'cabinet' },
        hardwareInstall: { rate: 8, unit: 'piece', label: 'Hardware Installation', category: 'cabinet' },
        modification: { rate: 75, unit: 'hour', label: 'Cabinet Modification', category: 'cabinet' }
      },
      // Plumbing Services
      plumbing: {
        sinkInstall: { rate: 175, unit: 'each', label: 'Sink Installation', category: 'plumbing' },
        faucetInstall: { rate: 125, unit: 'each', label: 'Faucet Installation', category: 'plumbing' },
        disposal: { rate: 150, unit: 'each', label: 'Garbage Disposal Install', category: 'plumbing' },
        dishwasherHookup: { rate: 125, unit: 'each', label: 'Dishwasher Hookup', category: 'plumbing' },
        roughIn: { rate: 350, unit: 'location', label: 'Plumbing Rough-In', category: 'plumbing' },
        waterLine: { rate: 85, unit: 'hour', label: 'Water Line Work', category: 'plumbing' }
      },
      // Electrical Services
      electrical: {
        outletInstall: { rate: 125, unit: 'each', label: 'Outlet Installation', category: 'electrical' },
        underCabinetLight: { rate: 85, unit: 'lf', label: 'Under-Cabinet Lighting', category: 'electrical' },
        applianceCircuit: { rate: 275, unit: 'each', label: 'Appliance Circuit', category: 'electrical' },
        permitFee: { rate: 150, unit: 'permit', label: 'Electrical Permit', category: 'electrical' }
      },
      // Flooring Services
      flooring: {
        tileInstall: { rate: 12, unit: 'sqft', label: 'Tile Installation', category: 'flooring' },
        hardwoodInstall: { rate: 8, unit: 'sqft', label: 'Hardwood Installation', category: 'flooring' },
        lvpInstall: { rate: 5, unit: 'sqft', label: 'LVP/LVT Installation', category: 'flooring' },
        subfloorPrep: { rate: 3, unit: 'sqft', label: 'Subfloor Prep', category: 'flooring' },
        grout: { rate: 2, unit: 'sqft', label: 'Grouting', category: 'flooring' },
        baseboardInstall: { rate: 4, unit: 'lf', label: 'Baseboard Installation', category: 'flooring' }
      },
      // Demo & Prep Services
      demo: {
        cabinetRemoval: { rate: 45, unit: 'cabinet', label: 'Cabinet Removal', category: 'demo' },
        countertopRemoval: { rate: 8, unit: 'sqft', label: 'Countertop Removal', category: 'demo' },
        flooringRemoval: { rate: 3, unit: 'sqft', label: 'Flooring Removal', category: 'demo' },
        backsplashRemoval: { rate: 6, unit: 'sqft', label: 'Backsplash Removal', category: 'demo' },
        applianceRemoval: { rate: 75, unit: 'each', label: 'Appliance Removal', category: 'demo' },
        dumpster: { rate: 450, unit: 'load', label: 'Dumpster/Haul Away', category: 'demo' },
        generalDemo: { rate: 65, unit: 'hour', label: 'General Demo Labor', category: 'demo' }
      },
      // Finishing/Specialty
      finishing: {
        drywall: { rate: 4, unit: 'sqft', label: 'Drywall Repair', category: 'finishing' },
        paint: { rate: 3, unit: 'sqft', label: 'Painting', category: 'finishing' },
        caulk: { rate: 4, unit: 'lf', label: 'Caulking', category: 'finishing' },
        trim: { rate: 6, unit: 'lf', label: 'Trim Work', category: 'finishing' },
        carpentry: { rate: 75, unit: 'hour', label: 'General Carpentry', category: 'finishing' }
      },
      // Project Fees
      fees: {
        projectManagement: { rate: 0, unit: 'percent', label: 'Project Management', category: 'fees', percentOf: 'total' },
        permit: { rate: 250, unit: 'permit', label: 'Building Permit', category: 'fees' },
        design: { rate: 150, unit: 'hour', label: 'Design Services', category: 'fees' },
        inspection: { rate: 100, unit: 'visit', label: 'Site Inspection', category: 'fees' }
      }
    };

    // Material pricing modes (slab vs sqft)
    const MATERIAL_PRICING = {
      // Slab-based materials (sold by slab, fabricated by sqft)
      slabMaterials: {
        granite: { slabPrice: 0, slabSqft: 45, label: 'Granite', priceMode: 'slab' },
        marble: { slabPrice: 0, slabSqft: 45, label: 'Marble', priceMode: 'slab' },
        quartzite: { slabPrice: 0, slabSqft: 45, label: 'Quartzite', priceMode: 'slab' },
        quartz: { slabPrice: 0, slabSqft: 50, label: 'Quartz', priceMode: 'slab' },
        porcelain: { slabPrice: 0, slabSqft: 32, label: 'Porcelain Slab', priceMode: 'slab' }
      },
      // Per-sqft materials
      sqftMaterials: {
        laminate: { pricePerSqft: 25, label: 'Laminate', priceMode: 'sqft' },
        solidSurface: { pricePerSqft: 45, label: 'Solid Surface', priceMode: 'sqft' },
        butcherBlock: { pricePerSqft: 35, label: 'Butcher Block', priceMode: 'sqft' }
      }
    };

    // ===== TAKEOFF CALCULATIONS =====
    function calculateTakeoffs() {
      const takeoffs = {
        stone: {
          slabs: [], totalSqft: 0, slabsNeeded: 0, edgeLF: 0, cutouts: [],
          materials: {}, // Group by material for pricing
          totalMaterialCost: 0, totalEdgeCost: 0, totalCutoutCost: 0
        },
        cabinets: { base: [], wall: [], tall: [], totalCount: 0, totalLF: 0, totalCost: 0 },
        scribe: { locations: [], totalLF: 0, totalCost: 0 },
        filler: { pieces: [], totalLF: 0, totalCost: 0 },
        flooring: { rooms: [], totalSqft: 0, boxesNeeded: 0, wasteIncluded: 0, totalCost: 0 },
        appliances: { items: [], totalCount: 0, totalCost: 0 },
        plumbing: { sinks: [], faucets: [], totalCount: 0, totalCost: 0 },
        backsplash: { areas: [], totalSqft: 0, totalLF: 0, totalCost: 0 },
        summary: { totalMaterialCost: 0, laborHours: 0, grandTotal: 0 }
      };

      // Helper function to calculate actual square footage for different shapes
      function calculateActualSqft(el) {
        const w = el.width;
        const h = el.height;

        if (el.type === 'countertop-l') {
          // L-shaped: Calculate as two arms meeting at corner
          // Arm width is stored in el.armWidth, or use default 2.2ft (26" countertop depth)
          const armW = el.armWidth || 2.17;
          // Area = horizontal arm + vertical arm - corner overlap
          // Horizontal arm: w * armW
          // Vertical arm: armW * (h - armW)
          // Total: w * armW + armW * h - armW * armW = armW * (w + h - armW)
          return armW * (w + h - armW);
        }

        if (el.type === 'countertop-u') {
          // U-shaped: back arm + two side arms
          const backDepth = h * 0.3; // Back arm depth (30% of total)
          const sideWidth = w * 0.25; // Side arm width (25% of total)
          // Back arm area: w * backDepth
          // Left arm area: sideWidth * (h - backDepth)
          // Right arm area: sideWidth * (h - backDepth)
          return (w * backDepth) + (2 * sideWidth * (h - backDepth));
        }

        // Standard rectangular countertop/element
        return w * h;
      }

      // Collect all elements by type
      elements.forEach(el => {
        const type = el.type;
        const sqft = calculateActualSqft(el);
        const widthInches = el.width * 12;
        const heightInches = el.height * 12;

        // ===== COUNTERTOPS / STONE =====
        // Explicit countertop types - islands are handled as cabinets separately
        if (type === 'countertop' || type === 'countertop-l' || type === 'countertop-u' ||
            type === 'countertop-corner' || type === 'island-countertop' ||
            type.startsWith('countertop')) {
          takeoffs.stone.totalSqft += sqft;

          // Calculate edge linear feet (perimeter minus back wall)
          const hasBackWall = !el.overhangBack || el.overhangBack < 0.1;
          const perimeter = (el.width + el.height) * 2;
          const edgeLF = hasBackWall ? perimeter - el.width : perimeter; // Subtract back edge if against wall
          takeoffs.stone.edgeLF += edgeLF;

          // Get material info from element (set when user applies material)
          const materialName = el.materialName || 'Unspecified Stone';
          const materialPrice = el.materialPrice || 0; // Price per SF
          const materialBrand = el.materialBrand || '';
          const materialId = el.materialId || 'unknown';

          // Group by material for summary
          if (!takeoffs.stone.materials[materialId]) {
            takeoffs.stone.materials[materialId] = {
              name: materialName,
              brand: materialBrand,
              pricePerSF: materialPrice,
              totalSqft: 0,
              totalCost: 0,
              pieces: []
            };
          }
          takeoffs.stone.materials[materialId].totalSqft += sqft;
          takeoffs.stone.materials[materialId].totalCost += sqft * materialPrice;
          takeoffs.stone.materials[materialId].pieces.push(el.label || 'Countertop');

          takeoffs.stone.totalMaterialCost += sqft * materialPrice;

          // Track waterfall edges (special pricing)
          if (el.waterfallSides && el.waterfallSides.length > 0) {
            el.waterfallSides.forEach(side => {
              const waterfallHeight = 2.5; // Standard 30" cabinet height
              const waterfallSqft = (side === 'left' || side === 'right' ? el.height : el.width) * waterfallHeight;
              takeoffs.stone.cutouts.push({
                type: 'waterfall',
                side: side,
                linearFeet: side === 'left' || side === 'right' ? el.height : el.width,
                height: waterfallHeight,
                sqft: waterfallSqft,
                cost: waterfallSqft * materialPrice
              });
              takeoffs.stone.totalMaterialCost += waterfallSqft * materialPrice;
            });
          }

          // Edge profile cost
          const edgePrice = TAKEOFF_STANDARDS.edgeProfiles[el.edgeProfile || 'eased']?.pricePerLF || 0;
          takeoffs.stone.totalEdgeCost += edgeLF * edgePrice;

          takeoffs.stone.slabs.push({
            label: el.label || 'Countertop',
            width: el.width,
            height: el.height,
            sqft: sqft,
            edgeLF: edgeLF,
            edgeProfile: el.edgeProfile || 'eased',
            material: materialName,
            materialBrand: materialBrand,
            pricePerSF: materialPrice,
            cost: sqft * materialPrice,
            hasWaterfall: (el.waterfallSides && el.waterfallSides.length > 0)
          });
        }

        // ===== CABINETS (All Types) =====
        // Base cabinets (including sink-base, drawer-base, corner, lazy-susan, island)
        else if (type === 'base-cabinet' || type === 'sink-base' ||
                 type === 'drawer-base' || type === 'corner-cabinet' ||
                 type === 'lazy-susan' || type === 'blind-corner' ||
                 type === 'dishwasher' || type === 'laundry-cabinet' ||
                 type === 'single-oven-cabinet' || type === 'double-oven-cabinet' ||
                 type === 'drawer-unit' || type === 'jewelry-cabinet' ||
                 type === 'island' || type === 'peninsula' || // Island and peninsula cabinets
                 type.includes('-base') || // Catch-all for base variants
                 (type === 'sink' && el.width > 1.5) || // MSI sink bases (width > 18")
                 (type === 'drawer' && el.width > 0.5)) { // MSI drawer bases
          const cabinetWidth = Math.round(widthInches);
          const cabinetLabel = type.includes('sink') ? 'Sink Base' :
                              type.includes('drawer') ? 'Drawer Base' :
                              type.includes('corner') ? 'Corner Base' :
                              type.includes('lazy') ? 'Lazy Susan' :
                              type.includes('blind') ? 'Blind Corner' :
                              type === 'dishwasher' ? 'Dishwasher' : 'Base';
          takeoffs.cabinets.base.push({
            label: el.label || `${cabinetLabel} ${cabinetWidth}"`,
            width: el.width,
            widthInches: cabinetWidth,
            sku: el.sku || `B${cabinetWidth}`,
            count: 1,
            subtype: cabinetLabel
          });
          takeoffs.cabinets.totalCount++;
          takeoffs.cabinets.totalLF += el.width;
        }
        // Wall cabinets (including microwave cabinet which is typically wall-mounted)
        else if (type === 'wall-cabinet' || type === 'microwave-cabinet' ||
                 type === 'above-microwave-cabinet' || type === 'medicine-cabinet' ||
                 type.includes('wall-cabinet')) {
          const cabinetWidth = Math.round(widthInches);
          const cabinetLabel = type === 'microwave-cabinet' ? 'Microwave Cabinet' : 'Wall';
          takeoffs.cabinets.wall.push({
            label: el.label || `${cabinetLabel} ${cabinetWidth}"`,
            width: el.width,
            widthInches: cabinetWidth,
            sku: el.sku || `W${cabinetWidth}`,
            count: 1
          });
          takeoffs.cabinets.totalCount++;
          takeoffs.cabinets.totalLF += el.width;
        }
        // Tall cabinets (including pantry, fridge cabinet)
        else if (type === 'tall-cabinet' || type === 'pantry' ||
                 type === 'fridge-cabinet' || type.includes('pantry') ||
                 type.includes('tall-')) {
          const cabinetWidth = Math.round(widthInches);
          const cabinetLabel = type.includes('pantry') ? 'Pantry' :
                              type.includes('fridge') ? 'Fridge Cabinet' : 'Tall';
          takeoffs.cabinets.tall.push({
            label: el.label || `${cabinetLabel} ${cabinetWidth}"`,
            width: el.width,
            widthInches: cabinetWidth,
            sku: el.sku || `T${cabinetWidth}`,
            count: 1,
            subtype: cabinetLabel
          });
          takeoffs.cabinets.totalCount++;
        }

        // ===== SINKS (Cutouts) - actual sink fixtures, not sink-base cabinets =====
        else if (type === 'sink' || type === 'sink-double' || type === 'sink-farmhouse' ||
                 type === 'sink-prep' || type === 'sink-bar') {
          const sinkType = el.mountType || 'undermount';
          takeoffs.plumbing.sinks.push({
            label: el.label || 'Sink',
            type: sinkType,
            width: el.width,
            cutoutPrice: TAKEOFF_STANDARDS.sinkCutouts[sinkType]?.price || 175
          });
          takeoffs.plumbing.totalCount++;
          takeoffs.stone.cutouts.push({
            type: 'sink',
            subtype: sinkType,
            label: el.label || 'Sink Cutout'
          });
        }

        // ===== APPLIANCES =====
        else if (['refrigerator', 'range', 'oven', 'microwave', 'range-hood', 'cooktop'].includes(type)) {
          takeoffs.appliances.items.push({
            type: type,
            label: el.label || type,
            width: el.width,
            height: el.height
          });
          takeoffs.appliances.totalCount++;

          // Cooktop requires cutout
          if (type === 'cooktop') {
            takeoffs.stone.cutouts.push({
              type: 'cooktop',
              label: 'Cooktop Cutout'
            });
          }
        }

        // ===== FLOORING =====
        else if (type === 'flooring' || type === 'tile-floor') {
          takeoffs.flooring.rooms.push({
            label: el.label || 'Flooring',
            sqft: sqft,
            material: el.material || 'tile'
          });
          takeoffs.flooring.totalSqft += sqft;
        }

        // ===== BACKSPLASH =====
        else if (type === 'backsplash') {
          takeoffs.backsplash.areas.push({
            label: el.label || 'Backsplash',
            width: el.width,
            height: el.height,
            sqft: sqft,
            linearFeet: el.width
          });
          takeoffs.backsplash.totalSqft += sqft;
          takeoffs.backsplash.totalLF += el.width;
        }
      });

      // ===== CALCULATE SLAB REQUIREMENTS =====
      if (takeoffs.stone.totalSqft > 0) {
        // Default to quartz if no material specified
        const materialType = 'quartz';
        const slabSpec = SLAB_STANDARDS[materialType];

        // Calculate net square feet needed
        const netSqft = takeoffs.stone.totalSqft;
        // Add waste factor
        const grossSqft = netSqft * (1 + slabSpec.wastePercent / 100);
        // Calculate slabs needed
        const slabsNeeded = Math.ceil(grossSqft / slabSpec.sqftPerSlab);

        takeoffs.stone.slabsNeeded = slabsNeeded;
        takeoffs.stone.netSqft = netSqft;
        takeoffs.stone.grossSqft = grossSqft;
        takeoffs.stone.wastePercent = slabSpec.wastePercent;
        takeoffs.stone.slabSize = `${slabSpec.width}"  ${slabSpec.height}"`;
        takeoffs.stone.sqftPerSlab = slabSpec.sqftPerSlab;
      }

      // ===== CALCULATE SCRIBE & FILLER REQUIREMENTS =====
      // Scribe molding: used where cabinet faces meet uneven walls
      // Filler strips: used to fill gaps between cabinet runs and walls/corners

      const rWidth = typeof roomWidth !== 'undefined' ? roomWidth : 12;
      const rDepth = typeof roomDepth !== 'undefined' ? roomDepth : 10;
      const pxPerFt = pixelsPerFoot || 50;

      // Get all cabinet elements with positions
      const cabinets = elements.filter(el => {
        const t = el.type;
        return t === 'base-cabinet' || t === 'sink-base' || t === 'drawer-base' ||
               t === 'corner-cabinet' || t === 'lazy-susan' || t === 'blind-corner' ||
               t === 'wall-cabinet' || t === 'microwave-cabinet' || t === 'above-microwave-cabinet' ||
               t === 'tall-cabinet' || t === 'pantry' || t === 'fridge-cabinet' ||
               t === 'single-oven-cabinet' || t === 'double-oven-cabinet' ||
               t === 'laundry-cabinet' || t === 'drawer-unit' ||
               t === 'dishwasher' || t === 'island' ||
               t.includes('cabinet') || t.includes('-base');
      }).map(el => ({
        ...el,
        xFt: el.x / pxPerFt,
        yFt: el.y / pxPerFt,
        widthFt: el.width,
        heightFt: el.height,
        rightEdgeFt: el.x / pxPerFt + el.width,
        bottomEdgeFt: el.y / pxPerFt + el.height
      }));

      // Group cabinets by wall they're against
      const wallCabinets = {
        back: [],    // Y  0 (back wall)
        front: [],   // Y  roomDepth (front wall)
        left: [],    // X  0 (left wall)
        right: []    // X  roomWidth (right wall)
      };

      const wallThreshold = 0.5; // Within 6" of wall

      cabinets.forEach(cab => {
        if (cab.yFt < wallThreshold) wallCabinets.back.push(cab);
        if (cab.bottomEdgeFt > rDepth - wallThreshold) wallCabinets.front.push(cab);
        if (cab.xFt < wallThreshold) wallCabinets.left.push(cab);
        if (cab.rightEdgeFt > rWidth - wallThreshold) wallCabinets.right.push(cab);
      });

      // Calculate scribe for each wall run
      Object.entries(wallCabinets).forEach(([wall, cabs]) => {
        if (cabs.length === 0) return;

        // Sort by position along wall
        const isHorizontal = wall === 'back' || wall === 'front';
        cabs.sort((a, b) => isHorizontal ? a.xFt - b.xFt : a.yFt - b.yFt);

        // Scribe needed at end cabinets where they meet wall corners
        cabs.forEach((cab, i) => {
          const isFirst = i === 0;
          const isLast = i === cabs.length - 1;

          // For horizontal runs (back/front walls), check left/right ends
          if (isHorizontal) {
            // Left end scribe
            if (isFirst && cab.xFt < wallThreshold) {
              takeoffs.scribe.locations.push({
                wall: wall,
                side: 'left end',
                cabinet: cab.label || `${Math.round(cab.widthFt * 12)}" cabinet`,
                length: cab.heightFt, // Depth of cabinet
                reason: 'Wall corner transition'
              });
              takeoffs.scribe.totalLF += cab.heightFt;
            }
            // Right end scribe
            if (isLast && cab.rightEdgeFt > rWidth - wallThreshold) {
              takeoffs.scribe.locations.push({
                wall: wall,
                side: 'right end',
                cabinet: cab.label || `${Math.round(cab.widthFt * 12)}" cabinet`,
                length: cab.heightFt,
                reason: 'Wall corner transition'
              });
              takeoffs.scribe.totalLF += cab.heightFt;
            }
          } else {
            // For vertical runs (left/right walls), check top/bottom ends
            if (isFirst && cab.yFt < wallThreshold) {
              takeoffs.scribe.locations.push({
                wall: wall,
                side: 'top end',
                cabinet: cab.label || `${Math.round(cab.widthFt * 12)}" cabinet`,
                length: cab.widthFt,
                reason: 'Wall corner transition'
              });
              takeoffs.scribe.totalLF += cab.widthFt;
            }
            if (isLast && cab.bottomEdgeFt > rDepth - wallThreshold) {
              takeoffs.scribe.locations.push({
                wall: wall,
                side: 'bottom end',
                cabinet: cab.label || `${Math.round(cab.widthFt * 12)}" cabinet`,
                length: cab.widthFt,
                reason: 'Wall corner transition'
              });
              takeoffs.scribe.totalLF += cab.widthFt;
            }
          }
        });
      });

      // Calculate filler requirements
      // Fillers are needed when cabinet runs don't fill the available wall space
      Object.entries(wallCabinets).forEach(([wall, cabs]) => {
        if (cabs.length === 0) return;

        const isHorizontal = wall === 'back' || wall === 'front';
        cabs.sort((a, b) => isHorizontal ? a.xFt - b.xFt : a.yFt - b.yFt);

        if (isHorizontal) {
          // Calculate total cabinet width along wall
          let totalCabWidth = cabs.reduce((sum, c) => sum + c.widthFt, 0);

          // Find the span these cabinets cover
          const firstCab = cabs[0];
          const lastCab = cabs[cabs.length - 1];
          const runStart = firstCab.xFt;
          const runEnd = lastCab.rightEdgeFt;
          const availableSpace = runEnd - runStart;

          // Check for gaps between cabinets
          for (let i = 0; i < cabs.length - 1; i++) {
            const currentEnd = cabs[i].rightEdgeFt;
            const nextStart = cabs[i + 1].xFt;
            const gap = nextStart - currentEnd;

            if (gap > TAKEOFF_STANDARDS.filler.minWidth) {
              const gapInches = Math.round(gap * 12);
              // Recommend standard filler width
              const recommendedWidth = TAKEOFF_STANDARDS.filler.standardWidths.find(w => w >= gapInches) ||
                                       Math.max(...TAKEOFF_STANDARDS.filler.standardWidths);

              takeoffs.filler.pieces.push({
                wall: wall,
                location: `Between ${cabs[i].label || 'cabinet'} and ${cabs[i+1].label || 'cabinet'}`,
                gapWidth: gapInches,
                recommendedFiller: recommendedWidth,
                length: 34.5, // Standard base cabinet height in inches
                lengthFt: 2.875
              });
              takeoffs.filler.totalLF += 2.875; // Cabinet height
            }
          }

          // Check for gap at start of run (between wall and first cabinet)
          if (runStart > wallThreshold) {
            const gapInches = Math.round(runStart * 12);
            if (gapInches >= TAKEOFF_STANDARDS.filler.minWidth * 12) {
              const recommendedWidth = TAKEOFF_STANDARDS.filler.standardWidths.find(w => w >= gapInches) ||
                                       Math.max(...TAKEOFF_STANDARDS.filler.standardWidths);
              takeoffs.filler.pieces.push({
                wall: wall,
                location: `${wall} wall start to first cabinet`,
                gapWidth: gapInches,
                recommendedFiller: recommendedWidth,
                length: 34.5,
                lengthFt: 2.875
              });
              takeoffs.filler.totalLF += 2.875;
            }
          }

          // Check for gap at end of run (between last cabinet and corner/wall end)
          // Only if cabinets don't extend to another wall
          const distanceToEnd = rWidth - runEnd;
          if (distanceToEnd > wallThreshold && distanceToEnd < 3) { // Gap but not room for another cabinet
            const gapInches = Math.round(distanceToEnd * 12);
            if (gapInches >= TAKEOFF_STANDARDS.filler.minWidth * 12) {
              const recommendedWidth = TAKEOFF_STANDARDS.filler.standardWidths.find(w => w >= gapInches) ||
                                       Math.max(...TAKEOFF_STANDARDS.filler.standardWidths);
              takeoffs.filler.pieces.push({
                wall: wall,
                location: `Last cabinet to ${wall} wall end`,
                gapWidth: gapInches,
                recommendedFiller: recommendedWidth,
                length: 34.5,
                lengthFt: 2.875
              });
              takeoffs.filler.totalLF += 2.875;
            }
          }
        } else {
          // Similar logic for vertical runs (left/right walls)
          for (let i = 0; i < cabs.length - 1; i++) {
            const currentEnd = cabs[i].bottomEdgeFt;
            const nextStart = cabs[i + 1].yFt;
            const gap = nextStart - currentEnd;

            if (gap > TAKEOFF_STANDARDS.filler.minWidth) {
              const gapInches = Math.round(gap * 12);
              const recommendedWidth = TAKEOFF_STANDARDS.filler.standardWidths.find(w => w >= gapInches) ||
                                       Math.max(...TAKEOFF_STANDARDS.filler.standardWidths);

              takeoffs.filler.pieces.push({
                wall: wall,
                location: `Between ${cabs[i].label || 'cabinet'} and ${cabs[i+1].label || 'cabinet'}`,
                gapWidth: gapInches,
                recommendedFiller: recommendedWidth,
                length: 34.5,
                lengthFt: 2.875
              });
              takeoffs.filler.totalLF += 2.875;
            }
          }
        }
      });

      // Calculate costs
      takeoffs.scribe.totalCost = takeoffs.scribe.totalLF * TAKEOFF_STANDARDS.scribe.pricePerLF;
      takeoffs.filler.totalCost = takeoffs.filler.totalLF * TAKEOFF_STANDARDS.filler.pricePerLF;

      // ===== CALCULATE FLOORING WITH WASTE =====
      if (takeoffs.flooring.totalSqft > 0) {
        const floorSpec = TAKEOFF_STANDARDS.flooring.tile;
        const wasteSqft = takeoffs.flooring.totalSqft * (floorSpec.wastePercent / 100);
        takeoffs.flooring.wasteIncluded = wasteSqft;
        takeoffs.flooring.grossSqft = takeoffs.flooring.totalSqft + wasteSqft;
        takeoffs.flooring.boxesNeeded = Math.ceil(takeoffs.flooring.grossSqft / floorSpec.boxSqft);
      }

      // ===== CONSOLIDATE CABINETS BY SIZE =====
      takeoffs.cabinets.baseSummary = consolidateCabinets(takeoffs.cabinets.base);
      takeoffs.cabinets.wallSummary = consolidateCabinets(takeoffs.cabinets.wall);
      takeoffs.cabinets.tallSummary = consolidateCabinets(takeoffs.cabinets.tall);

      return takeoffs;
    }

    // Helper: Consolidate cabinet list by size
    function consolidateCabinets(cabinetList) {
      const summary = {};
      cabinetList.forEach(cab => {
        const key = cab.widthInches;
        if (!summary[key]) {
          summary[key] = { width: cab.widthInches, count: 0, sku: cab.sku };
        }
        summary[key].count++;
      });
      return Object.values(summary).sort((a, b) => a.width - b.width);
    }

    // ===== GENERATE TAKEOFF REPORT =====
    function generateTakeoffReport() {
      const takeoffs = calculateTakeoffs();
      showTakeoffModal(takeoffs);
    }

    // Show takeoff modal with detailed breakdown
    function showTakeoffModal(takeoffs) {
      const modal = document.getElementById('takeoffModal');
      const content = document.getElementById('takeoffContent');

      let html = '';

      // ===== STONE / COUNTERTOPS SECTION =====
      if (takeoffs.stone.totalSqft > 0) {
        const hasPricing = takeoffs.stone.totalMaterialCost > 0;
        const materialsList = Object.values(takeoffs.stone.materials);

        html += `
          <div class="takeoff-section takeoff-highlight">
            <div class="takeoff-section-header">
              <div class="takeoff-section-title">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <rect x="3" y="3" width="18" height="18" rx="2"/>
                </svg>
                Stone / Countertops
                <span class="takeoff-section-badge">${takeoffs.stone.slabsNeeded} Slab${takeoffs.stone.slabsNeeded > 1 ? 's' : ''}</span>
              </div>
              ${hasPricing ? `<div style="font-size: 16px; font-weight: 700; color: #10b981;">$${takeoffs.stone.totalMaterialCost.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2})}</div>` : ''}
            </div>

            ${materialsList.length > 0 ? `
              <div style="margin-bottom: 16px;">
                <div style="font-weight: 600; margin-bottom: 8px; color: var(--text-secondary); font-size: 12px; text-transform: uppercase;">Materials Selected</div>
                <table class="takeoff-table">
                  <thead>
                    <tr>
                      <th>Stone</th>
                      <th>Brand</th>
                      <th>SF</th>
                      <th>$/SF</th>
                      <th style="text-align: right;">Subtotal</th>
                    </tr>
                  </thead>
                  <tbody>
                    ${materialsList.map(m => `
                      <tr>
                        <td><strong>${m.name}</strong></td>
                        <td>${m.brand || '-'}</td>
                        <td>${m.totalSqft.toFixed(1)}</td>
                        <td>${m.pricePerSF > 0 ? '$' + m.pricePerSF.toFixed(2) : '-'}</td>
                        <td style="text-align: right; font-weight: 600;">${m.totalCost > 0 ? '$' + m.totalCost.toFixed(2) : '-'}</td>
                      </tr>
                    `).join('')}
                  </tbody>
                </table>
              </div>
            ` : `
              <div class="takeoff-warning" style="margin-bottom: 16px;">
                <span></span>
                <span>Select a stone material to see pricing. Click a countertop then choose from Materials panel.</span>
              </div>
            `}

            <div class="takeoff-grid">
              <div class="takeoff-item">
                <div class="takeoff-item-label">Net Square Feet</div>
                <div class="takeoff-item-value">${takeoffs.stone.netSqft?.toFixed(1) || takeoffs.stone.totalSqft.toFixed(1)} <span class="takeoff-item-unit">SF</span></div>
                <div class="takeoff-item-note">Actual countertop area</div>
              </div>
              <div class="takeoff-item">
                <div class="takeoff-item-label">Gross (w/ ${takeoffs.stone.wastePercent || 20}% waste)</div>
                <div class="takeoff-item-value">${takeoffs.stone.grossSqft?.toFixed(1) || (takeoffs.stone.totalSqft * 1.2).toFixed(1)} <span class="takeoff-item-unit">SF</span></div>
                <div class="takeoff-item-note">Includes cutting waste</div>
              </div>
              <div class="takeoff-item">
                <div class="takeoff-item-label">Slabs Required</div>
                <div class="takeoff-item-value">${takeoffs.stone.slabsNeeded || Math.ceil(takeoffs.stone.totalSqft * 1.2 / 55)}</div>
                <div class="takeoff-item-note">@ ${takeoffs.stone.sqftPerSlab?.toFixed(1) || '55'} SF/slab</div>
              </div>
              <div class="takeoff-item">
                <div class="takeoff-item-label">Edge Profile LF</div>
                <div class="takeoff-item-value">${takeoffs.stone.edgeLF?.toFixed(1) || '0'} <span class="takeoff-item-unit">LF</span></div>
                <div class="takeoff-item-note">${takeoffs.stone.totalEdgeCost > 0 ? '+$' + takeoffs.stone.totalEdgeCost.toFixed(2) : 'Eased edge included'}</div>
              </div>
            </div>

            <div class="slab-visual">
              ${Array(takeoffs.stone.slabsNeeded || Math.ceil(takeoffs.stone.totalSqft * 1.2 / 55)).fill(0).map((_, i) =>
                `<div class="slab-icon used">${i + 1}</div>`
              ).join('')}
            </div>

            ${takeoffs.stone.cutouts.length > 0 ? `
              <div style="margin-top: 16px;">
                <div style="font-weight: 600; margin-bottom: 8px; color: var(--text-secondary); font-size: 12px; text-transform: uppercase;">Cutouts & Fabrication</div>
                <table class="takeoff-table">
                  <thead>
                    <tr>
                      <th>Item</th>
                      <th>Type</th>
                      <th>Size</th>
                      <th style="text-align: right;">Cost</th>
                    </tr>
                  </thead>
                  <tbody>
                    ${takeoffs.stone.cutouts.map(c => `
                      <tr>
                        <td>${c.label || (c.type === 'waterfall' ? 'Waterfall Edge' : c.type)}</td>
                        <td>${c.subtype || c.type}</td>
                        <td>${c.sqft ? c.sqft.toFixed(1) + ' SF' : (c.linearFeet ? c.linearFeet.toFixed(1) + ' LF' : '1')}</td>
                        <td style="text-align: right;">${c.cost ? '$' + c.cost.toFixed(2) : (TAKEOFF_STANDARDS.sinkCutouts[c.subtype]?.price ? '$' + TAKEOFF_STANDARDS.sinkCutouts[c.subtype].price : '-')}</td>
                      </tr>
                    `).join('')}
                  </tbody>
                </table>
              </div>
            ` : ''}
          </div>
        `;
      }

      // ===== CABINETS SECTION =====
      if (takeoffs.cabinets.totalCount > 0) {
        html += `
          <div class="takeoff-section">
            <div class="takeoff-section-header">
              <div class="takeoff-section-title">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <rect x="3" y="3" width="7" height="9"/><rect x="14" y="3" width="7" height="9"/>
                  <rect x="3" y="14" width="7" height="7"/><rect x="14" y="14" width="7" height="7"/>
                </svg>
                Cabinets
                <span class="takeoff-section-badge">${takeoffs.cabinets.totalCount} Units</span>
              </div>
              <div style="font-size: 13px; color: var(--text-secondary);">
                ${takeoffs.cabinets.totalLF.toFixed(1)} LF total
              </div>
            </div>
            <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 16px;">
              ${takeoffs.cabinets.baseSummary.length > 0 ? `
                <div>
                  <div style="font-weight: 600; margin-bottom: 8px; color: var(--text-secondary); font-size: 12px;">BASE CABINETS</div>
                  <table class="takeoff-table">
                    <thead><tr><th>Size</th><th>Qty</th></tr></thead>
                    <tbody>
                      ${takeoffs.cabinets.baseSummary.map(c => `
                        <tr><td>B${c.width}" ${c.width >= 36 ? '(Sink/Range)' : ''}</td><td>${c.count}</td></tr>
                      `).join('')}
                    </tbody>
                  </table>
                </div>
              ` : ''}
              ${takeoffs.cabinets.wallSummary.length > 0 ? `
                <div>
                  <div style="font-weight: 600; margin-bottom: 8px; color: var(--text-secondary); font-size: 12px;">WALL CABINETS</div>
                  <table class="takeoff-table">
                    <thead><tr><th>Size</th><th>Qty</th></tr></thead>
                    <tbody>
                      ${takeoffs.cabinets.wallSummary.map(c => `
                        <tr><td>W${c.width}"</td><td>${c.count}</td></tr>
                      `).join('')}
                    </tbody>
                  </table>
                </div>
              ` : ''}
              ${takeoffs.cabinets.tallSummary.length > 0 ? `
                <div>
                  <div style="font-weight: 600; margin-bottom: 8px; color: var(--text-secondary); font-size: 12px;">TALL/PANTRY</div>
                  <table class="takeoff-table">
                    <thead><tr><th>Size</th><th>Qty</th></tr></thead>
                    <tbody>
                      ${takeoffs.cabinets.tallSummary.map(c => `
                        <tr><td>T${c.width}"</td><td>${c.count}</td></tr>
                      `).join('')}
                    </tbody>
                  </table>
                </div>
              ` : ''}
            </div>
          </div>
        `;
      }

      // ===== SCRIBE / FILLER SECTION =====
      if (takeoffs.scribe.totalLF > 0 || takeoffs.filler.pieces.length > 0) {
        const scribeCost = takeoffs.scribe.totalCost || (takeoffs.scribe.totalLF * TAKEOFF_STANDARDS.scribe.pricePerLF);
        const fillerCost = takeoffs.filler.totalCost || (takeoffs.filler.totalLF * TAKEOFF_STANDARDS.filler.pricePerLF);
        const totalCost = scribeCost + fillerCost;

        html += `
          <div class="takeoff-section">
            <div class="takeoff-section-header">
              <div class="takeoff-section-title">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M21 10H3M21 6H3M21 14H3M21 18H3"/>
                </svg>
                Scribe & Filler
                <span class="takeoff-section-badge">${(takeoffs.scribe.locations.length + takeoffs.filler.pieces.length)} Pieces</span>
              </div>
              ${totalCost > 0 ? `<div style="font-size: 16px; font-weight: 700; color: #10b981;">$${totalCost.toFixed(2)}</div>` : ''}
            </div>

            ${takeoffs.scribe.locations.length > 0 ? `
              <div style="margin-bottom: 16px;">
                <div style="font-weight: 600; margin-bottom: 8px; color: var(--text-secondary); font-size: 12px; text-transform: uppercase;">Scribe Molding @ $${TAKEOFF_STANDARDS.scribe.pricePerLF.toFixed(2)}/LF</div>
                <table class="takeoff-table">
                  <thead>
                    <tr>
                      <th>Wall</th>
                      <th>Location</th>
                      <th>Length</th>
                      <th style="text-align: right;">Cost</th>
                    </tr>
                  </thead>
                  <tbody>
                    ${takeoffs.scribe.locations.map(s => `
                      <tr>
                        <td style="text-transform: capitalize;">${s.wall}</td>
                        <td>${s.side} - ${s.cabinet}</td>
                        <td>${s.length.toFixed(1)} LF</td>
                        <td style="text-align: right;">$${(s.length * TAKEOFF_STANDARDS.scribe.pricePerLF).toFixed(2)}</td>
                      </tr>
                    `).join('')}
                    <tr style="font-weight: 600; border-top: 2px solid var(--border-color);">
                      <td colspan="2">Scribe Total</td>
                      <td>${takeoffs.scribe.totalLF.toFixed(1)} LF</td>
                      <td style="text-align: right;">$${scribeCost.toFixed(2)}</td>
                    </tr>
                  </tbody>
                </table>
              </div>
            ` : ''}

            ${takeoffs.filler.pieces.length > 0 ? `
              <div style="margin-bottom: 16px;">
                <div style="font-weight: 600; margin-bottom: 8px; color: var(--text-secondary); font-size: 12px; text-transform: uppercase;">Filler Strips @ $${TAKEOFF_STANDARDS.filler.pricePerLF.toFixed(2)}/LF</div>
                <table class="takeoff-table">
                  <thead>
                    <tr>
                      <th>Wall</th>
                      <th>Location</th>
                      <th>Gap</th>
                      <th>Filler Size</th>
                      <th style="text-align: right;">Cost</th>
                    </tr>
                  </thead>
                  <tbody>
                    ${takeoffs.filler.pieces.map(f => `
                      <tr>
                        <td style="text-transform: capitalize;">${f.wall}</td>
                        <td>${f.location}</td>
                        <td>${f.gapWidth}"</td>
                        <td>${f.recommendedFiller}"  ${f.length}" H</td>
                        <td style="text-align: right;">$${(f.lengthFt * TAKEOFF_STANDARDS.filler.pricePerLF).toFixed(2)}</td>
                      </tr>
                    `).join('')}
                    <tr style="font-weight: 600; border-top: 2px solid var(--border-color);">
                      <td colspan="3">Filler Total</td>
                      <td>${takeoffs.filler.totalLF.toFixed(1)} LF</td>
                      <td style="text-align: right;">$${fillerCost.toFixed(2)}</td>
                    </tr>
                  </tbody>
                </table>
              </div>
            ` : ''}

            ${takeoffs.scribe.totalLF > 0 || takeoffs.filler.pieces.length > 0 ? `
              <div class="takeoff-warning">
                <span></span>
                <span>Order 10% extra scribe/filler for cuts and adjustments. Fillers can be trimmed on-site to fit exact gaps.</span>
              </div>
            ` : ''}
          </div>
        `;
      }

      // ===== FLOORING SECTION =====
      if (takeoffs.flooring.totalSqft > 0) {
        html += `
          <div class="takeoff-section">
            <div class="takeoff-section-header">
              <div class="takeoff-section-title">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <rect x="3" y="3" width="18" height="18"/><path d="M3 9h18M3 15h18M9 3v18M15 3v18"/>
                </svg>
                Flooring
                <span class="takeoff-section-badge">${takeoffs.flooring.boxesNeeded} Boxes</span>
              </div>
            </div>
            <div class="takeoff-grid">
              <div class="takeoff-item">
                <div class="takeoff-item-label">Room Area</div>
                <div class="takeoff-item-value">${takeoffs.flooring.totalSqft.toFixed(1)} <span class="takeoff-item-unit">SF</span></div>
              </div>
              <div class="takeoff-item">
                <div class="takeoff-item-label">+ Waste (${TAKEOFF_STANDARDS.flooring.tile.wastePercent}%)</div>
                <div class="takeoff-item-value">${takeoffs.flooring.wasteIncluded?.toFixed(1) || '0'} <span class="takeoff-item-unit">SF</span></div>
              </div>
              <div class="takeoff-item">
                <div class="takeoff-item-label">Total Needed</div>
                <div class="takeoff-item-value">${takeoffs.flooring.grossSqft?.toFixed(1) || '0'} <span class="takeoff-item-unit">SF</span></div>
              </div>
              <div class="takeoff-item">
                <div class="takeoff-item-label">Boxes to Order</div>
                <div class="takeoff-item-value">${takeoffs.flooring.boxesNeeded || 0}</div>
                <div class="takeoff-item-note">@ ${TAKEOFF_STANDARDS.flooring.tile.boxSqft} SF/box</div>
              </div>
            </div>
          </div>
        `;
      }

      // ===== APPLIANCES SECTION =====
      if (takeoffs.appliances.totalCount > 0) {
        html += `
          <div class="takeoff-section">
            <div class="takeoff-section-header">
              <div class="takeoff-section-title">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <rect x="4" y="2" width="16" height="20" rx="2"/><line x1="8" y1="6" x2="16" y2="6"/>
                  <circle cx="12" cy="14" r="4"/>
                </svg>
                Appliances
                <span class="takeoff-section-badge">${takeoffs.appliances.totalCount}</span>
              </div>
            </div>
            <table class="takeoff-table">
              <thead>
                <tr><th>Item</th><th>Size</th><th>Qty</th></tr>
              </thead>
              <tbody>
                ${takeoffs.appliances.items.map(a => `
                  <tr>
                    <td>${a.label}</td>
                    <td>${Math.round(a.width * 12)}"W  ${Math.round(a.height * 12)}"D</td>
                    <td>1</td>
                  </tr>
                `).join('')}
              </tbody>
            </table>
          </div>
        `;
      }

      // ===== PLUMBING / FIXTURES SECTION =====
      if (takeoffs.plumbing.totalCount > 0) {
        html += `
          <div class="takeoff-section">
            <div class="takeoff-section-header">
              <div class="takeoff-section-title">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M5.5 5.5L8 3L10.5 5.5"/><path d="M8 3v6a4 4 0 004 4h4"/>
                  <circle cx="18" cy="13" r="2"/><path d="M18 15v6"/>
                </svg>
                Plumbing & Fixtures
                <span class="takeoff-section-badge">${takeoffs.plumbing.totalCount}</span>
              </div>
            </div>
            <table class="takeoff-table">
              <thead>
                <tr><th>Item</th><th>Type</th><th>Cutout</th></tr>
              </thead>
              <tbody>
                ${takeoffs.plumbing.sinks.map(s => `
                  <tr>
                    <td>${s.label}</td>
                    <td>${s.type}</td>
                    <td>$${s.cutoutPrice}</td>
                  </tr>
                `).join('')}
              </tbody>
            </table>
          </div>
        `;
      }

      // ===== SUMMARY SECTION =====
      // Calculate all costs itemized
      const costs = {
        stoneMaterial: takeoffs.stone.totalMaterialCost || 0,
        edgeProfile: takeoffs.stone.totalEdgeCost || 0,
        sinkCutouts: takeoffs.plumbing.sinks.reduce((sum, s) => sum + (s.cutoutPrice || 0), 0),
        cooktopCutouts: takeoffs.stone.cutouts.filter(c => c.type === 'cooktop').length * TAKEOFF_STANDARDS.cooktopCutout.price,
        scribe: (takeoffs.scribe.totalCost || takeoffs.scribe.totalLF * TAKEOFF_STANDARDS.scribe.pricePerLF),
        filler: (takeoffs.filler.totalCost || takeoffs.filler.totalLF * TAKEOFF_STANDARDS.filler.pricePerLF),
        cabinets: takeoffs.cabinets.totalCost || 0,
        flooring: takeoffs.flooring.totalCost || 0
      };
      const grandTotal = Object.values(costs).reduce((sum, c) => sum + c, 0);

      // Build itemized cost list (only items with values)
      const costItems = [];
      if (costs.stoneMaterial > 0) costItems.push({ label: 'Stone Material', qty: `${takeoffs.stone.totalSqft.toFixed(1)} SF`, cost: costs.stoneMaterial });
      if (costs.edgeProfile > 0) costItems.push({ label: 'Edge Profile', qty: `${takeoffs.stone.edgeLF.toFixed(1)} LF`, cost: costs.edgeProfile });
      if (costs.sinkCutouts > 0) costItems.push({ label: 'Sink Cutouts', qty: `${takeoffs.plumbing.sinks.length} cutout(s)`, cost: costs.sinkCutouts });
      if (costs.cooktopCutouts > 0) costItems.push({ label: 'Cooktop Cutout', qty: '1 cutout', cost: costs.cooktopCutouts });
      if (costs.scribe > 0) costItems.push({ label: 'Scribe Molding', qty: `${takeoffs.scribe.totalLF.toFixed(1)} LF`, cost: costs.scribe });
      if (costs.filler > 0) costItems.push({ label: 'Filler Strips', qty: `${takeoffs.filler.totalLF.toFixed(1)} LF`, cost: costs.filler });
      if (costs.cabinets > 0) costItems.push({ label: 'Cabinets', qty: `${takeoffs.cabinets.totalCount} units`, cost: costs.cabinets });
      if (costs.flooring > 0) costItems.push({ label: 'Flooring', qty: `${takeoffs.flooring.grossSqft?.toFixed(1) || 0} SF`, cost: costs.flooring });

      html += `
        <div class="takeoff-summary">
          <div class="takeoff-summary-title">ORDER SUMMARY</div>
          <div class="takeoff-summary-grid">
            <div class="takeoff-item">
              <div class="takeoff-item-label">Stone Slabs</div>
              <div class="takeoff-item-value">${takeoffs.stone.slabsNeeded || Math.ceil((takeoffs.stone.totalSqft || 0) * 1.2 / 55)}</div>
              <div class="takeoff-item-note">${takeoffs.stone.totalSqft.toFixed(1)} net SF</div>
            </div>
            <div class="takeoff-item">
              <div class="takeoff-item-label">Cabinets</div>
              <div class="takeoff-item-value">${takeoffs.cabinets.totalCount}</div>
              <div class="takeoff-item-note">${takeoffs.cabinets.totalLF.toFixed(1)} LF</div>
            </div>
            <div class="takeoff-item">
              <div class="takeoff-item-label">Scribe/Filler</div>
              <div class="takeoff-item-value">${(takeoffs.scribe.totalLF + takeoffs.filler.totalLF).toFixed(1)} <span class="takeoff-item-unit">LF</span></div>
              <div class="takeoff-item-note">${takeoffs.scribe.locations.length + takeoffs.filler.pieces.length} locations</div>
            </div>
            <div class="takeoff-item">
              <div class="takeoff-item-label">Sink Cutouts</div>
              <div class="takeoff-item-value">${takeoffs.plumbing.sinks.length}</div>
            </div>
          </div>

          ${costItems.length > 0 ? `
            <div style="margin-top: 20px; padding-top: 16px; border-top: 2px solid var(--border-color);">
              <div style="font-weight: 600; margin-bottom: 12px; color: var(--text-secondary); font-size: 12px; text-transform: uppercase;">
                Material Cost Breakdown
              </div>
              <table class="takeoff-table" style="margin-bottom: 16px;">
                <thead>
                  <tr>
                    <th>Item</th>
                    <th>Quantity</th>
                    <th style="text-align: right;">Cost</th>
                  </tr>
                </thead>
                <tbody>
                  ${costItems.map(item => `
                    <tr>
                      <td>${item.label}</td>
                      <td>${item.qty}</td>
                      <td style="text-align: right;">$${item.cost.toFixed(2)}</td>
                    </tr>
                  `).join('')}
                </tbody>
              </table>
            </div>
          ` : ''}

          ${grandTotal > 0 ? `
            <div style="margin-top: 16px; padding: 16px; background: linear-gradient(135deg, rgba(16, 185, 129, 0.1), rgba(16, 185, 129, 0.05)); border-radius: 8px; border: 1px solid rgba(16, 185, 129, 0.2);">
              <div style="display: flex; justify-content: space-between; align-items: center;">
                <div>
                  <div style="font-size: 14px; font-weight: 600; color: var(--text-primary);">Estimated Material Total</div>
                  <div style="font-size: 11px; color: var(--text-muted); margin-top: 2px;">Excludes labor & installation</div>
                </div>
                <div style="font-size: 28px; font-weight: 700; color: #10b981;">$${grandTotal.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2})}</div>
              </div>
            </div>
          ` : `
            <div style="margin-top: 16px; padding: 16px; background: var(--bg-secondary); border-radius: 8px; text-align: center;">
              <div style="font-size: 13px; color: var(--text-muted);">
                Select materials for countertops and cabinets to see pricing breakdown
              </div>
            </div>
          `}
          <div style="margin-top: 16px; display: flex; gap: 8px;">
            <button class="btn btn-primary" onclick="exportTakeoffPDF()" style="flex: 1;">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="margin-right: 6px;">
                <path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4"/><polyline points="7,10 12,15 17,10"/><line x1="12" y1="15" x2="12" y2="3"/>
              </svg>
              Download PDF
            </button>
            <button class="btn btn-secondary" onclick="copyTakeoffToClipboard()" style="flex: 1;">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="margin-right: 6px;">
                <rect x="9" y="9" width="13" height="13" rx="2"/><path d="M5 15H4a2 2 0 01-2-2V4a2 2 0 012-2h9a2 2 0 012 2v1"/>
              </svg>
              Copy to Clipboard
            </button>
          </div>
        </div>
      `;

      // Empty state
      if (takeoffs.stone.totalSqft === 0 && takeoffs.cabinets.totalCount === 0) {
        html = `
          <div style="text-align: center; padding: 60px 20px; color: var(--text-muted);">
            <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" style="margin-bottom: 16px; opacity: 0.5;">
              <path d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2"/>
              <rect x="9" y="3" width="6" height="4" rx="1"/>
            </svg>
            <div style="font-size: 16px; margin-bottom: 8px;">No Elements to Calculate</div>
            <div style="font-size: 13px;">Add cabinets, countertops, and other elements to generate takeoffs.</div>
          </div>
        `;
      }

      content.innerHTML = html;
      modal.style.display = 'flex';
    }

    // Export takeoff as PDF
    function exportTakeoffPDF() {
      // Use existing PDF export functionality
      if (typeof jspdf !== 'undefined') {
        const { jsPDF } = window.jspdf;
        const doc = new jsPDF();
        const takeoffs = calculateTakeoffs();

        doc.setFontSize(20);
        doc.text('Material Takeoff Report', 20, 20);

        doc.setFontSize(12);
        doc.text(`Project: ${projectName || 'Untitled Project'}`, 20, 35);
        doc.text(`Date: ${new Date().toLocaleDateString()}`, 20, 42);

        let y = 55;

        // Stone section
        if (takeoffs.stone.slabsNeeded > 0) {
          doc.setFontSize(14);
          doc.text('Stone / Countertops', 20, y);
          y += 8;
          doc.setFontSize(10);
          doc.text(`Slabs Required: ${takeoffs.stone.slabsNeeded}`, 25, y); y += 6;
          doc.text(`Net Area: ${takeoffs.stone.netSqft?.toFixed(1)} SF`, 25, y); y += 6;
          doc.text(`Gross (w/ waste): ${takeoffs.stone.grossSqft?.toFixed(1)} SF`, 25, y); y += 6;
          doc.text(`Edge LF: ${takeoffs.stone.edgeLF?.toFixed(1)} LF`, 25, y); y += 10;
        }

        // Cabinets section
        if (takeoffs.cabinets.totalCount > 0) {
          doc.setFontSize(14);
          doc.text('Cabinets', 20, y);
          y += 8;
          doc.setFontSize(10);
          doc.text(`Total Cabinets: ${takeoffs.cabinets.totalCount}`, 25, y); y += 6;
          doc.text(`Total Linear Feet: ${takeoffs.cabinets.totalLF.toFixed(1)} LF`, 25, y); y += 10;
        }

        // Scribe & Filler section
        if (takeoffs.scribe.totalLF > 0 || takeoffs.filler.pieces.length > 0) {
          doc.setFontSize(14);
          doc.text('Scribe & Filler', 20, y);
          y += 8;
          doc.setFontSize(10);
          if (takeoffs.scribe.totalLF > 0) {
            doc.text(`Scribe Molding: ${takeoffs.scribe.totalLF.toFixed(1)} LF @ $${TAKEOFF_STANDARDS.scribe.pricePerLF}/LF = $${(takeoffs.scribe.totalLF * TAKEOFF_STANDARDS.scribe.pricePerLF).toFixed(2)}`, 25, y);
            y += 6;
            takeoffs.scribe.locations.forEach(s => {
              doc.text(`  - ${s.wall} wall, ${s.side}: ${s.length.toFixed(1)} LF`, 30, y);
              y += 5;
            });
          }
          if (takeoffs.filler.pieces.length > 0) {
            doc.text(`Filler Strips: ${takeoffs.filler.totalLF.toFixed(1)} LF @ $${TAKEOFF_STANDARDS.filler.pricePerLF}/LF = $${(takeoffs.filler.totalLF * TAKEOFF_STANDARDS.filler.pricePerLF).toFixed(2)}`, 25, y);
            y += 6;
            takeoffs.filler.pieces.forEach(f => {
              doc.text(`  - ${f.wall} wall: ${f.gapWidth}" gap, use ${f.recommendedFiller}" filler`, 30, y);
              y += 5;
            });
          }
          y += 5;
        }

        // Cost Summary
        const costs = {
          stoneMaterial: takeoffs.stone.totalMaterialCost || 0,
          edgeProfile: takeoffs.stone.totalEdgeCost || 0,
          sinkCutouts: takeoffs.plumbing.sinks.reduce((sum, s) => sum + (s.cutoutPrice || 0), 0),
          scribe: takeoffs.scribe.totalLF * TAKEOFF_STANDARDS.scribe.pricePerLF,
          filler: takeoffs.filler.totalLF * TAKEOFF_STANDARDS.filler.pricePerLF
        };
        const grandTotal = Object.values(costs).reduce((sum, c) => sum + c, 0);

        if (grandTotal > 0) {
          y += 10;
          doc.setFontSize(14);
          doc.text('Cost Summary', 20, y);
          y += 8;
          doc.setFontSize(10);
          if (costs.stoneMaterial > 0) { doc.text(`Stone Material: $${costs.stoneMaterial.toFixed(2)}`, 25, y); y += 6; }
          if (costs.edgeProfile > 0) { doc.text(`Edge Profile: $${costs.edgeProfile.toFixed(2)}`, 25, y); y += 6; }
          if (costs.sinkCutouts > 0) { doc.text(`Sink Cutouts: $${costs.sinkCutouts.toFixed(2)}`, 25, y); y += 6; }
          if (costs.scribe > 0) { doc.text(`Scribe Molding: $${costs.scribe.toFixed(2)}`, 25, y); y += 6; }
          if (costs.filler > 0) { doc.text(`Filler Strips: $${costs.filler.toFixed(2)}`, 25, y); y += 6; }
          y += 4;
          doc.setFontSize(12);
          doc.text(`TOTAL: $${grandTotal.toFixed(2)}`, 25, y);
        }

        doc.save('takeoff-report.pdf');
      } else {
        alert('PDF export requires jsPDF library');
      }
    }

    // Copy takeoff to clipboard as text
    function copyTakeoffToClipboard() {
      const takeoffs = calculateTakeoffs();
      const materialsList = Object.values(takeoffs.stone.materials);

      let text = `MATERIAL TAKEOFF REPORT\n`;
      text += `Project: ${projectName || 'Untitled Project'}\n`;
      text += `Date: ${new Date().toLocaleDateString()}\n`;
      text += `${'='.repeat(50)}\n\n`;

      // Stone section
      if (takeoffs.stone.totalSqft > 0) {
        text += `STONE / COUNTERTOPS\n`;
        text += `-`.repeat(30) + `\n`;
        text += `Slabs Required: ${takeoffs.stone.slabsNeeded || Math.ceil(takeoffs.stone.totalSqft * 1.2 / 55)}\n`;
        text += `Net Area: ${takeoffs.stone.totalSqft.toFixed(1)} SF\n`;
        text += `Gross (w/ waste): ${(takeoffs.stone.totalSqft * 1.2).toFixed(1)} SF\n`;
        text += `Edge LF: ${takeoffs.stone.edgeLF?.toFixed(1) || '0'} LF\n`;

        if (materialsList.length > 0) {
          text += `\nMaterials:\n`;
          materialsList.forEach(m => {
            text += `   ${m.name} (${m.brand || 'N/A'}): ${m.totalSqft.toFixed(1)} SF`;
            if (m.pricePerSF > 0) text += ` @ $${m.pricePerSF.toFixed(2)}/SF = $${m.totalCost.toFixed(2)}`;
            text += `\n`;
          });
        }

        if (takeoffs.stone.cutouts.length > 0) {
          text += `\nCutouts:\n`;
          takeoffs.stone.cutouts.forEach(c => {
            text += `   ${c.label || c.type} (${c.subtype || c.type})\n`;
          });
        }
        text += `\n`;
      }

      // Cabinets section
      if (takeoffs.cabinets.totalCount > 0) {
        text += `CABINETS\n`;
        text += `-`.repeat(30) + `\n`;
        text += `Total Units: ${takeoffs.cabinets.totalCount}\n`;
        text += `Total Linear Feet: ${takeoffs.cabinets.totalLF.toFixed(1)} LF\n`;

        if (takeoffs.cabinets.baseSummary.length > 0) {
          text += `\nBase Cabinets:\n`;
          takeoffs.cabinets.baseSummary.forEach(c => {
            text += `   B${c.width}" x ${c.count}\n`;
          });
        }
        if (takeoffs.cabinets.wallSummary.length > 0) {
          text += `\nWall Cabinets:\n`;
          takeoffs.cabinets.wallSummary.forEach(c => {
            text += `   W${c.width}" x ${c.count}\n`;
          });
        }
        text += `\n`;
      }

      // Scribe & Filler section
      if (takeoffs.scribe.totalLF > 0 || takeoffs.filler.pieces.length > 0) {
        text += `SCRIBE & FILLER\n`;
        text += `-`.repeat(30) + `\n`;

        if (takeoffs.scribe.locations.length > 0) {
          text += `\nScribe Molding: ${takeoffs.scribe.totalLF.toFixed(1)} LF @ $${TAKEOFF_STANDARDS.scribe.pricePerLF}/LF\n`;
          takeoffs.scribe.locations.forEach(s => {
            text += `   ${s.wall} wall, ${s.side}: ${s.length.toFixed(1)} LF ($${(s.length * TAKEOFF_STANDARDS.scribe.pricePerLF).toFixed(2)})\n`;
          });
          text += `  Scribe Subtotal: $${(takeoffs.scribe.totalLF * TAKEOFF_STANDARDS.scribe.pricePerLF).toFixed(2)}\n`;
        }

        if (takeoffs.filler.pieces.length > 0) {
          text += `\nFiller Strips: ${takeoffs.filler.totalLF.toFixed(1)} LF @ $${TAKEOFF_STANDARDS.filler.pricePerLF}/LF\n`;
          takeoffs.filler.pieces.forEach(f => {
            text += `   ${f.wall} wall - ${f.location}: ${f.gapWidth}" gap  use ${f.recommendedFiller}" filler ($${(f.lengthFt * TAKEOFF_STANDARDS.filler.pricePerLF).toFixed(2)})\n`;
          });
          text += `  Filler Subtotal: $${(takeoffs.filler.totalLF * TAKEOFF_STANDARDS.filler.pricePerLF).toFixed(2)}\n`;
        }
        text += `\n`;
      }

      // Flooring section
      if (takeoffs.flooring.totalSqft > 0) {
        text += `FLOORING\n`;
        text += `-`.repeat(30) + `\n`;
        text += `Area: ${takeoffs.flooring.totalSqft.toFixed(1)} SF\n`;
        text += `With Waste: ${takeoffs.flooring.grossSqft?.toFixed(1) || (takeoffs.flooring.totalSqft * 1.15).toFixed(1)} SF\n`;
        text += `Boxes Needed: ${takeoffs.flooring.boxesNeeded || Math.ceil(takeoffs.flooring.totalSqft * 1.15 / 10)}\n\n`;
      }

      // Itemized cost summary
      const costs = {
        stoneMaterial: takeoffs.stone.totalMaterialCost || 0,
        edgeProfile: takeoffs.stone.totalEdgeCost || 0,
        sinkCutouts: takeoffs.plumbing.sinks.reduce((sum, s) => sum + (s.cutoutPrice || 0), 0),
        cooktopCutouts: takeoffs.stone.cutouts.filter(c => c.type === 'cooktop').length * TAKEOFF_STANDARDS.cooktopCutout.price,
        scribe: takeoffs.scribe.totalLF * TAKEOFF_STANDARDS.scribe.pricePerLF,
        filler: takeoffs.filler.totalLF * TAKEOFF_STANDARDS.filler.pricePerLF
      };
      const grandTotal = Object.values(costs).reduce((sum, c) => sum + c, 0);

      if (grandTotal > 0) {
        text += `${'='.repeat(50)}\n`;
        text += `COST BREAKDOWN\n`;
        text += `-`.repeat(30) + `\n`;
        if (costs.stoneMaterial > 0) text += `Stone Material:     $${costs.stoneMaterial.toFixed(2)}\n`;
        if (costs.edgeProfile > 0) text += `Edge Profile:       $${costs.edgeProfile.toFixed(2)}\n`;
        if (costs.sinkCutouts > 0) text += `Sink Cutouts:       $${costs.sinkCutouts.toFixed(2)}\n`;
        if (costs.cooktopCutouts > 0) text += `Cooktop Cutout:     $${costs.cooktopCutouts.toFixed(2)}\n`;
        if (costs.scribe > 0) text += `Scribe Molding:     $${costs.scribe.toFixed(2)}\n`;
        if (costs.filler > 0) text += `Filler Strips:      $${costs.filler.toFixed(2)}\n`;
        text += `-`.repeat(30) + `\n`;
        text += `TOTAL:              $${grandTotal.toFixed(2)}\n`;
        text += `(Excludes labor & installation)\n`;
      }

      navigator.clipboard.writeText(text).then(() => {
        showToast('Takeoff copied to clipboard!', 'success');
      }).catch(err => {
        console.error('Copy failed:', err);
        showToast('Failed to copy', 'error');
      });
    }

    // ===== MEASUREMENT FORMATTING =====
    // Format feet (decimal) to feet-inches-fractions string
    // Supports 1/16" precision
    function formatDimension(feet, showFractions = true) {
      const totalInches = feet * 12;
      const wholeInches = Math.floor(totalInches);
      const wholeFeet = Math.floor(wholeInches / 12);
      const remainingInches = wholeInches % 12;
      const fractionalInches = totalInches - wholeInches;

      // Convert to 16ths for fraction display
      const sixteenths = Math.round(fractionalInches * 16);

      // Simplify fraction
      let fractionStr = '';
      if (sixteenths > 0 && showFractions) {
        if (sixteenths === 16) {
          // Round up to next inch
          return formatDimension(feet + (1/192), showFractions);
        } else if (sixteenths === 8) {
          fractionStr = '';
        } else if (sixteenths === 4) {
          fractionStr = '';
        } else if (sixteenths === 12) {
          fractionStr = '';
        } else if (sixteenths % 2 === 0) {
          // Can simplify to eighths
          fractionStr = `${sixteenths/2}/8`;
        } else {
          fractionStr = `${sixteenths}/16`;
        }
      }

      // Build output string
      if (wholeFeet > 0 && remainingInches > 0) {
        return `${wholeFeet}'-${remainingInches}${fractionStr}"`;
      } else if (wholeFeet > 0 && fractionStr) {
        return `${wholeFeet}'-0${fractionStr}"`;
      } else if (wholeFeet > 0) {
        return `${wholeFeet}'-0"`;
      } else if (remainingInches > 0 || fractionStr) {
        return `${remainingInches}${fractionStr}"`;
      } else {
        return '0"';
      }
    }

    // Format dimensions as W  H
    function formatSize(widthFt, heightFt) {
      return `${formatDimension(widthFt)}  ${formatDimension(heightFt)}`;
    }

    // Calculate actual square footage accounting for L and U shapes
    function getElementSqft(el) {
      const w = el.width || 0;
      const h = el.height || 0;

      if (el.type === 'countertop-l') {
        // L-shaped: two arms meeting at corner
        const armW = el.armWidth || 2.17; // Default 26" countertop depth
        // Area = horizontal arm + vertical arm - corner overlap
        return armW * (w + h - armW);
      }

      if (el.type === 'countertop-u') {
        // U-shaped: back arm + two side arms
        const backDepth = h * 0.3;
        const sideWidth = w * 0.25;
        return (w * backDepth) + (2 * sideWidth * (h - backDepth));
      }

      // Standard rectangular
      return w * h;
    }

    // Parse dimension string back to feet (for input)
    // Accepts: "3'-6"", "3.5", "42"", "3' 6"", etc.
    function parseDimension(str) {
      if (typeof str === 'number') return str;
      str = str.toString().trim();

      // Already decimal feet
      if (/^[\d.]+$/.test(str)) {
        return parseFloat(str);
      }

      // Feet and inches: 3'-6" or 3' 6" or 3'6"
      const feetInchMatch = str.match(/(\d+)[''][\s-]*(\d+)?(?:\s*(\d+)\/(\d+))?[""]?/);
      if (feetInchMatch) {
        const feet = parseInt(feetInchMatch[1]) || 0;
        const inches = parseInt(feetInchMatch[2]) || 0;
        const fracNum = parseInt(feetInchMatch[3]) || 0;
        const fracDen = parseInt(feetInchMatch[4]) || 1;
        return feet + (inches + fracNum/fracDen) / 12;
      }

      // Just inches: 42" or 36"
      const inchMatch = str.match(/^(\d+)(?:\s*(\d+)\/(\d+))?[""]$/);
      if (inchMatch) {
        const inches = parseInt(inchMatch[1]) || 0;
        const fracNum = parseInt(inchMatch[2]) || 0;
        const fracDen = parseInt(inchMatch[3]) || 1;
        return (inches + fracNum/fracDen) / 12;
      }

      // Fallback
      return parseFloat(str) || 0;
    }

    // Round to nearest 1/16"
    function roundToSixteenth(feet) {
      const sixteenthsPerFoot = 12 * 16; // 192 sixteenths per foot
      return Math.round(feet * sixteenthsPerFoot) / sixteenthsPerFoot;
    }

    // ===== BUILDING CODE VALIDATION =====
    let validationIssues = [];
    let showWorkTriangle = false;

    // Find elements by type
    function findElementsByType(types) {
      if (!Array.isArray(types)) types = [types];
      return elements.filter(el => types.includes(el.type));
    }

    // Get element center point
    function getElementCenter(el) {
      return {
        x: el.x + (el.width * pixelsPerFoot) / 2,
        y: el.y + (el.height * pixelsPerFoot) / 2
      };
    }

    // Calculate distance between two elements (center to center)
    function getDistance(el1, el2) {
      const c1 = getElementCenter(el1);
      const c2 = getElementCenter(el2);
      const dx = (c2.x - c1.x) / pixelsPerFoot;
      const dy = (c2.y - c1.y) / pixelsPerFoot;
      return Math.sqrt(dx * dx + dy * dy);
    }

    // Get gap between two elements (edge to edge)
    function getGapBetween(el1, el2) {
      const r1 = {
        left: el1.x / pixelsPerFoot,
        right: (el1.x + el1.width * pixelsPerFoot) / pixelsPerFoot,
        top: el1.y / pixelsPerFoot,
        bottom: (el1.y + el1.height * pixelsPerFoot) / pixelsPerFoot
      };
      const r2 = {
        left: el2.x / pixelsPerFoot,
        right: (el2.x + el2.width * pixelsPerFoot) / pixelsPerFoot,
        top: el2.y / pixelsPerFoot,
        bottom: (el2.y + el2.height * pixelsPerFoot) / pixelsPerFoot
      };

      // Calculate gaps in each direction
      const gapX = Math.max(r1.left - r2.right, r2.left - r1.right, 0);
      const gapY = Math.max(r1.top - r2.bottom, r2.top - r1.bottom, 0);

      return Math.sqrt(gapX * gapX + gapY * gapY);
    }

    // Validate kitchen work triangle
    function validateWorkTriangle() {
      const issues = [];
      const sinks = findElementsByType('sink');
      const stoves = findElementsByType(['stove', 'range', 'cooktop']);
      const fridges = findElementsByType(['refrigerator', 'fridge']);

      if (sinks.length === 0 || stoves.length === 0 || fridges.length === 0) {
        return { valid: false, issues: [], triangle: null, message: 'Need sink, stove, and refrigerator for work triangle' };
      }

      const sink = sinks[0];
      const stove = stoves[0];
      const fridge = fridges[0];

      const leg1 = getDistance(sink, stove);
      const leg2 = getDistance(stove, fridge);
      const leg3 = getDistance(fridge, sink);
      const perimeter = leg1 + leg2 + leg3;

      const { legMin, legMax, perimeterMin, perimeterMax } = BUILDING_STANDARDS.WORK_TRIANGLE;

      // Check each leg
      if (leg1 < legMin) issues.push({ type: 'warning', message: `Sink-Stove: ${formatDimension(leg1)} (min ${formatDimension(legMin)})` });
      if (leg1 > legMax) issues.push({ type: 'warning', message: `Sink-Stove: ${formatDimension(leg1)} (max ${formatDimension(legMax)})` });
      if (leg2 < legMin) issues.push({ type: 'warning', message: `Stove-Fridge: ${formatDimension(leg2)} (min ${formatDimension(legMin)})` });
      if (leg2 > legMax) issues.push({ type: 'warning', message: `Stove-Fridge: ${formatDimension(leg2)} (max ${formatDimension(legMax)})` });
      if (leg3 < legMin) issues.push({ type: 'warning', message: `Fridge-Sink: ${formatDimension(leg3)} (min ${formatDimension(legMin)})` });
      if (leg3 > legMax) issues.push({ type: 'warning', message: `Fridge-Sink: ${formatDimension(leg3)} (max ${formatDimension(legMax)})` });

      // Check perimeter
      if (perimeter < perimeterMin) {
        issues.push({ type: 'error', message: `Triangle too small: ${formatDimension(perimeter)} (min ${formatDimension(perimeterMin)})` });
      }
      if (perimeter > perimeterMax) {
        issues.push({ type: 'error', message: `Triangle too large: ${formatDimension(perimeter)} (max ${formatDimension(perimeterMax)})` });
      }

      return {
        valid: issues.length === 0,
        issues,
        triangle: { sink, stove, fridge, leg1, leg2, leg3, perimeter },
        message: issues.length === 0 ? 'Work triangle OK' : `${issues.length} issue(s)`
      };
    }

    // Validate clearances between elements
    function validateClearances() {
      const issues = [];
      const { walkway, islandWalkway, applianceOpen } = BUILDING_STANDARDS.CLEARANCES;

      // Check island clearances
      const islands = findElementsByType('island');
      const counters = findElementsByType('countertop');
      const cabinets = findElementsByType(['base-cabinet', 'tall-cabinet']);

      islands.forEach(island => {
        // Check clearance to counters and cabinets
        [...counters, ...cabinets].forEach(other => {
          const gap = getGapBetween(island, other);
          if (gap > 0 && gap < islandWalkway) {
            issues.push({
              type: 'warning',
              message: `Island clearance: ${formatDimension(gap)} (min ${formatDimension(islandWalkway)})`,
              elements: [island, other]
            });
          }
        });
      });

      // Check walkway between parallel counters
      for (let i = 0; i < counters.length; i++) {
        for (let j = i + 1; j < counters.length; j++) {
          const gap = getGapBetween(counters[i], counters[j]);
          if (gap > 0 && gap < walkway) {
            issues.push({
              type: 'warning',
              message: `Counter gap: ${formatDimension(gap)} (min ${formatDimension(walkway)})`,
              elements: [counters[i], counters[j]]
            });
          }
        }
      }

      // Check appliance clearances
      const appliances = findElementsByType(['stove', 'refrigerator', 'dishwasher', 'oven']);
      appliances.forEach(app => {
        // Check for adequate space in front (simplified - check distance to facing elements)
        const facing = [...islands, ...counters].filter(other => {
          const gap = getGapBetween(app, other);
          return gap > 0 && gap < applianceOpen;
        });

        facing.forEach(other => {
          const gap = getGapBetween(app, other);
          issues.push({
            type: 'info',
            message: `${app.label} front clearance: ${formatDimension(gap)} (rec. ${formatDimension(applianceOpen)})`,
            elements: [app, other]
          });
        });
      });

      return issues;
    }

    // Validate door clearances
    function validateDoorClearances() {
      const issues = [];
      const doors = findElementsByType(['door', 'double-door', 'entry-archway']);
      const allElements = elements.filter(el => !['door', 'double-door', 'entry-archway', 'window'].includes(el.type));

      doors.forEach(door => {
        allElements.forEach(other => {
          const gap = getGapBetween(door, other);
          if (gap > 0 && gap < BUILDING_STANDARDS.CLEARANCES.doorSwing) {
            issues.push({
              type: 'warning',
              message: `Door swing blocked: ${formatDimension(gap)} to ${other.label}`,
              elements: [door, other]
            });
          }
        });
      });

      return issues;
    }

    // Run all validations
    function runValidation() {
      validationIssues = [];

      // Work triangle
      const triangleResult = validateWorkTriangle();
      if (triangleResult.issues.length > 0) {
        validationIssues.push(...triangleResult.issues.map(i => ({
          ...i,
          category: 'Work Triangle'
        })));
      }

      // Clearances
      const clearanceIssues = validateClearances();
      validationIssues.push(...clearanceIssues.map(i => ({
        ...i,
        category: 'Clearances'
      })));

      // Door clearances
      const doorIssues = validateDoorClearances();
      validationIssues.push(...doorIssues.map(i => ({
        ...i,
        category: 'Door Swing'
      })));

      updateValidationPanel();
      return validationIssues;
    }

    // Update the validation panel UI
    function updateValidationPanel() {
      const panel = document.getElementById('validationPanel');
      if (!panel) return;

      const content = document.getElementById('validationContent');
      if (!content) return;

      if (validationIssues.length === 0) {
        content.innerHTML = '<div class="validation-ok"> No issues found</div>';
        return;
      }

      // Group by category
      const grouped = {};
      validationIssues.forEach(issue => {
        if (!grouped[issue.category]) grouped[issue.category] = [];
        grouped[issue.category].push(issue);
      });

      content.innerHTML = Object.entries(grouped).map(([category, issues]) => `
        <div class="validation-category">
          <div class="validation-category-title">${category}</div>
          ${issues.map(issue => `
            <div class="validation-issue validation-${issue.type}">
              <span class="validation-icon">${issue.type === 'error' ? '' : issue.type === 'warning' ? '' : ''}</span>
              <span class="validation-message">${issue.message}</span>
            </div>
          `).join('')}
        </div>
      `).join('');
    }

    // Draw work triangle on canvas
    function drawWorkTriangle() {
      if (!showWorkTriangle) return;

      const result = validateWorkTriangle();
      if (!result.triangle) return;

      const { sink, stove, fridge, leg1, leg2, leg3 } = result.triangle;

      ctx.save();
      ctx.setLineDash([10, 5]);
      ctx.lineWidth = 2;
      ctx.strokeStyle = result.valid ? 'rgba(34, 197, 94, 0.7)' : 'rgba(239, 68, 68, 0.7)';
      ctx.fillStyle = result.valid ? 'rgba(34, 197, 94, 0.1)' : 'rgba(239, 68, 68, 0.1)';

      const c1 = getElementCenter(sink);
      const c2 = getElementCenter(stove);
      const c3 = getElementCenter(fridge);

      // Draw triangle
      ctx.beginPath();
      ctx.moveTo(c1.x, c1.y);
      ctx.lineTo(c2.x, c2.y);
      ctx.lineTo(c3.x, c3.y);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();

      // Draw leg labels
      ctx.setLineDash([]);
      ctx.font = 'bold 11px Inter';
      ctx.fillStyle = result.valid ? '#22c55e' : '#ef4444';
      ctx.textAlign = 'center';

      // Leg 1 (sink-stove)
      const mid1 = { x: (c1.x + c2.x) / 2, y: (c1.y + c2.y) / 2 };
      ctx.fillText(formatDimension(leg1), mid1.x, mid1.y - 8);

      // Leg 2 (stove-fridge)
      const mid2 = { x: (c2.x + c3.x) / 2, y: (c2.y + c3.y) / 2 };
      ctx.fillText(formatDimension(leg2), mid2.x, mid2.y - 8);

      // Leg 3 (fridge-sink)
      const mid3 = { x: (c3.x + c1.x) / 2, y: (c3.y + c1.y) / 2 };
      ctx.fillText(formatDimension(leg3), mid3.x, mid3.y - 8);

      ctx.restore();
    }

    // Snap to standard dimension
    function snapToStandard(value, type = 'width') {
      const standards = type === 'width' ? SNAP_DIMENSIONS.widths : SNAP_DIMENSIONS.depths;
      const tolerance = SNAP_DIMENSIONS.tolerance;

      for (const std of standards) {
        if (Math.abs(value - std) <= tolerance) {
          return std;
        }
      }
      return value;
    }

    // Get suggested standard size for element type
    function getSuggestedSize(elementType) {
      switch (elementType) {
        case 'door':
          return { width: 3, height: 0.5, note: "Standard 36\" door" };
        case 'double-door':
          return { width: 5, height: 0.5, note: "Standard 60\" double door" };
        case 'sliding-door':
          return { width: 6, height: 0.5, note: "Standard 72\" slider" };
        case 'window':
          return { width: 3, height: 0.5, note: "Standard 36\" window" };
        case 'base-cabinet':
          return { width: 2, height: 2, note: "Standard 24\" base cabinet" };
        case 'wall-cabinet':
          return { width: 2.5, height: 1, note: "Standard 30\" wall cabinet" };
        case 'tall-cabinet':
          return { width: 2, height: 2, note: "Standard 24\" pantry" };
        case 'fridge-cabinet':
          return { width: 3, height: 7, note: "Enclosure for 36\" fridge" };
        case 'island':
          return { width: 4, height: 2.5, note: "Minimum island size" };
        case 'countertop':
          return { width: 3, height: 2.083, note: "Standard 25\" depth" };
        default:
          return null;
      }
    }

    // SVG icons for element thumbnails (single-line for reliability)
    const ELEMENT_ICONS = {
      'base-cabinet': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="12" width="40" height="32" rx="2" fill="#8B5A2B"/><rect x="6" y="14" width="17" height="28" rx="1" fill="#A0522D"/><rect x="25" y="14" width="17" height="28" rx="1" fill="#A0522D"/><rect x="8" y="16" width="13" height="24" rx="1" fill="#CD853F"/><rect x="27" y="16" width="13" height="24" rx="1" fill="#CD853F"/><rect x="19" y="24" width="2" height="8" rx="1" fill="#FFD700"/><rect x="35" y="24" width="2" height="8" rx="1" fill="#FFD700"/><rect x="4" y="44" width="40" height="4" fill="#2a2a2a"/></svg>',
      'wall-cabinet': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="8" width="40" height="24" rx="2" fill="#8B5A2B"/><rect x="6" y="10" width="17" height="20" rx="1" fill="#A0522D"/><rect x="25" y="10" width="17" height="20" rx="1" fill="#A0522D"/><rect x="8" y="12" width="13" height="16" rx="1" fill="#CD853F"/><rect x="27" y="12" width="13" height="16" rx="1" fill="#CD853F"/><rect x="19" y="18" width="2" height="6" rx="1" fill="#FFD700"/><rect x="35" y="18" width="2" height="6" rx="1" fill="#FFD700"/></svg>',
      'microwave-cabinet': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="4" width="40" height="40" rx="2" fill="#5C5040"/><rect x="6" y="6" width="36" height="10" rx="1" fill="#6B5D4D"/><rect x="8" y="8" width="32" height="6" rx="1" fill="#7A6B5A"/><rect x="6" y="18" width="36" height="16" rx="1" fill="#2a2a2a"/><rect x="8" y="20" width="24" height="12" fill="#1a1a1a"/><rect x="34" y="20" width="6" height="12" fill="#3a3a3a"/><circle cx="37" cy="24" r="1.5" fill="#444"/><circle cx="37" cy="28" r="1.5" fill="#444"/><rect x="6" y="36" width="36" height="6" rx="1" fill="#6B5D4D"/><rect x="20" y="38" width="8" height="2" rx="1" fill="#A0A0A0"/></svg>',
      'above-microwave-cabinet': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="4" width="40" height="16" rx="2" fill="#8B5A2B"/><rect x="6" y="6" width="36" height="12" rx="1" fill="#A0522D"/><rect x="8" y="8" width="32" height="8" rx="1" fill="#CD853F"/><rect x="20" y="10" width="8" height="2" rx="1" fill="#FFD700"/><rect x="4" y="24" width="40" height="20" rx="2" fill="#3a3a3a"/><rect x="6" y="26" width="26" height="16" rx="1" fill="#1a1a1a"/><rect x="8" y="28" width="22" height="12" fill="#222"/><rect x="34" y="28" width="8" height="12" rx="1" fill="#4a4a4a"/><circle cx="38" cy="32" r="1.5" fill="#666"/><circle cx="38" cy="38" r="1.5" fill="#666"/></svg>',
      'tall-cabinet': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="10" y="2" width="28" height="44" rx="2" fill="#8B5A2B"/><rect x="12" y="4" width="24" height="18" rx="1" fill="#A0522D"/><rect x="12" y="24" width="24" height="20" rx="1" fill="#A0522D"/><rect x="14" y="6" width="20" height="14" rx="1" fill="#CD853F"/><rect x="14" y="26" width="20" height="16" rx="1" fill="#CD853F"/><rect x="32" y="11" width="2" height="6" rx="1" fill="#FFD700"/><rect x="32" y="32" width="2" height="6" rx="1" fill="#FFD700"/></svg>',
      'corner-cabinet': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><path d="M4 4 L4 44 L24 44 L24 24 L44 24 L44 4 Z" fill="#8B5A2B"/><path d="M6 6 L6 42 L22 42 L22 22 L42 22 L42 6 Z" fill="#A0522D"/><line x1="22" y1="22" x2="42" y2="42" stroke="#CD853F" stroke-width="2"/><circle cx="28" cy="28" r="8" fill="none" stroke="#CD853F" stroke-width="1.5"/><rect x="32" y="32" width="3" height="10" rx="1" fill="#FFD700" transform="rotate(45 33.5 37)"/><rect x="4" y="44" width="20" height="4" fill="#2a2a2a"/></svg>',
      'island': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="16" width="44" height="24" rx="2" fill="#8B5A2B"/><rect x="2" y="12" width="44" height="6" rx="1" fill="#708090"/><rect x="4" y="18" width="12" height="20" rx="1" fill="#CD853F"/><rect x="18" y="18" width="12" height="20" rx="1" fill="#CD853F"/><rect x="32" y="18" width="12" height="20" rx="1" fill="#CD853F"/><rect x="14" y="26" width="2" height="6" rx="1" fill="#FFD700"/><rect x="28" y="26" width="2" height="6" rx="1" fill="#FFD700"/><rect x="2" y="40" width="44" height="4" fill="#2a2a2a"/></svg>',
      'drawer-base': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="12" width="40" height="32" rx="2" fill="#8B5A2B"/><rect x="6" y="14" width="36" height="7" rx="1" fill="#CD853F"/><rect x="6" y="23" width="36" height="7" rx="1" fill="#CD853F"/><rect x="6" y="32" width="36" height="10" rx="1" fill="#CD853F"/><rect x="20" y="16" width="8" height="2" rx="1" fill="#FFD700"/><rect x="20" y="25" width="8" height="2" rx="1" fill="#FFD700"/><rect x="20" y="35" width="8" height="2" rx="1" fill="#FFD700"/><rect x="4" y="44" width="40" height="4" fill="#2a2a2a"/></svg>',
      'sink-base': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="12" width="40" height="32" rx="2" fill="#8B5A2B"/><rect x="6" y="14" width="36" height="5" rx="1" fill="#A0522D"/><rect x="6" y="21" width="17" height="21" rx="1" fill="#CD853F"/><rect x="25" y="21" width="17" height="21" rx="1" fill="#CD853F"/><rect x="19" y="29" width="2" height="6" rx="1" fill="#FFD700"/><rect x="35" y="29" width="2" height="6" rx="1" fill="#FFD700"/><ellipse cx="24" cy="8" rx="12" ry="4" fill="#E0E0E0"/><ellipse cx="24" cy="8" rx="8" ry="2.5" fill="#808080"/><rect x="4" y="44" width="40" height="4" fill="#2a2a2a"/></svg>',
      'lazy-susan': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><path d="M4 4 L4 44 L24 44 L24 24 L44 24 L44 4 Z" fill="#8B5A2B"/><path d="M6 6 L6 42 L22 42 L22 22 L42 22 L42 6 Z" fill="#A0522D"/><circle cx="24" cy="24" r="10" fill="none" stroke="#CD853F" stroke-width="2"/><circle cx="24" cy="24" r="6" fill="none" stroke="#CD853F" stroke-width="1.5"/><circle cx="24" cy="24" r="2" fill="#CD853F"/><path d="M24 14 L26 18 L22 18 Z" fill="#FFD700"/><rect x="4" y="44" width="20" height="4" fill="#2a2a2a"/></svg>',
      'countertop': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="18" width="44" height="8" rx="1" fill="#708090"/><rect x="2" y="20" width="44" height="4" fill="#5a6a7a"/><circle cx="10" cy="22" r="2" fill="#8090a0"/><circle cx="24" cy="22" r="2" fill="#8090a0"/><circle cx="38" cy="22" r="2" fill="#8090a0"/><rect x="2" y="26" width="44" height="2" fill="#4a5a6a"/></svg>',
      'backsplash': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="8" width="40" height="32" fill="#D4AF37"/><rect x="4" y="8" width="10" height="10" fill="#E5C158" stroke="#B8860B"/><rect x="14" y="8" width="10" height="10" fill="#D4AF37" stroke="#B8860B"/><rect x="24" y="8" width="10" height="10" fill="#E5C158" stroke="#B8860B"/><rect x="34" y="8" width="10" height="10" fill="#D4AF37" stroke="#B8860B"/><rect x="4" y="18" width="10" height="10" fill="#D4AF37" stroke="#B8860B"/><rect x="14" y="18" width="10" height="10" fill="#E5C158" stroke="#B8860B"/><rect x="24" y="18" width="10" height="10" fill="#D4AF37" stroke="#B8860B"/><rect x="34" y="18" width="10" height="10" fill="#E5C158" stroke="#B8860B"/><rect x="4" y="28" width="10" height="10" fill="#E5C158" stroke="#B8860B"/><rect x="14" y="28" width="10" height="10" fill="#D4AF37" stroke="#B8860B"/><rect x="24" y="28" width="10" height="10" fill="#E5C158" stroke="#B8860B"/><rect x="34" y="28" width="10" height="10" fill="#D4AF37" stroke="#B8860B"/></svg>',
      'flooring': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="2" width="22" height="44" fill="#CD853F"/><rect x="24" y="2" width="22" height="44" fill="#DEB887"/><line x1="2" y1="13" x2="24" y2="13" stroke="#8B4513"/><line x1="2" y1="24" x2="24" y2="24" stroke="#8B4513"/><line x1="2" y1="35" x2="24" y2="35" stroke="#8B4513"/><line x1="24" y1="8" x2="46" y2="8" stroke="#8B4513"/><line x1="24" y1="19" x2="46" y2="19" stroke="#8B4513"/><line x1="24" y1="30" x2="46" y2="30" stroke="#8B4513"/><line x1="24" y1="41" x2="46" y2="41" stroke="#8B4513"/></svg>',
      'tile': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="2" width="14" height="14" fill="#E8E8E8" stroke="#CCC"/><rect x="17" y="2" width="14" height="14" fill="#F5F5F5" stroke="#CCC"/><rect x="32" y="2" width="14" height="14" fill="#E8E8E8" stroke="#CCC"/><rect x="2" y="17" width="14" height="14" fill="#F5F5F5" stroke="#CCC"/><rect x="17" y="17" width="14" height="14" fill="#E8E8E8" stroke="#CCC"/><rect x="32" y="17" width="14" height="14" fill="#F5F5F5" stroke="#CCC"/><rect x="2" y="32" width="14" height="14" fill="#E8E8E8" stroke="#CCC"/><rect x="17" y="32" width="14" height="14" fill="#F5F5F5" stroke="#CCC"/><rect x="32" y="32" width="14" height="14" fill="#E8E8E8" stroke="#CCC"/></svg>',
      'sink': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="16" width="40" height="24" rx="4" fill="#E0E0E0"/><rect x="8" y="20" width="32" height="16" rx="2" fill="#404040"/><ellipse cx="24" cy="28" rx="12" ry="6" fill="#505050"/><rect x="22" y="6" width="4" height="10" rx="2" fill="#C0C0C0"/><ellipse cx="24" cy="6" rx="3" ry="2" fill="#A0A0A0"/><circle cx="24" cy="28" r="2" fill="#303030"/></svg>',
      'sink-double': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="16" width="44" height="24" rx="4" fill="#E0E0E0"/><rect x="5" y="20" width="17" height="16" rx="2" fill="#404040"/><rect x="26" y="20" width="17" height="16" rx="2" fill="#404040"/><ellipse cx="13.5" cy="28" rx="6" ry="5" fill="#505050"/><ellipse cx="34.5" cy="28" rx="6" ry="5" fill="#505050"/><rect x="22" y="6" width="4" height="10" rx="2" fill="#C0C0C0"/><ellipse cx="24" cy="6" rx="3" ry="2" fill="#A0A0A0"/><circle cx="13.5" cy="28" r="1.5" fill="#303030"/><circle cx="34.5" cy="28" r="1.5" fill="#303030"/></svg>',
      'sink-farmhouse': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="14" width="40" height="28" rx="2" fill="#F5F5DC" stroke="#D4C8A8" stroke-width="2"/><rect x="6" y="16" width="36" height="24" fill="#FFFEF7"/><rect x="8" y="18" width="32" height="20" rx="1" fill="#404040"/><ellipse cx="24" cy="28" rx="12" ry="7" fill="#505050"/><rect x="22" y="4" width="4" height="12" rx="2" fill="#C0C0C0"/><ellipse cx="24" cy="4" rx="3" ry="2" fill="#A0A0A0"/><circle cx="24" cy="30" r="2" fill="#303030"/><path d="M4 20 L4 14 Q4 12 6 12 L42 12 Q44 12 44 14 L44 20" fill="none" stroke="#C9B896" stroke-width="2"/></svg>',
      'stove': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="8" width="40" height="36" rx="2" fill="#2a2a2a"/><rect x="6" y="10" width="36" height="16" rx="1" fill="#1a1a1a"/><circle cx="14" cy="18" r="5" fill="#333" stroke="#444" stroke-width="2"/><circle cx="34" cy="18" r="5" fill="#333" stroke="#444" stroke-width="2"/><rect x="8" y="28" width="32" height="14" rx="1" fill="#1a1a1a"/><rect x="12" y="30" width="24" height="10" rx="1" fill="#111"/></svg>',
      'refrigerator': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="8" y="2" width="32" height="44" rx="2" fill="#D0D0D0"/><rect x="10" y="4" width="28" height="14" rx="1" fill="#E0E0E0"/><rect x="10" y="20" width="28" height="24" rx="1" fill="#E0E0E0"/><rect x="34" y="8" width="2" height="6" rx="1" fill="#888"/><rect x="34" y="28" width="2" height="10" rx="1" fill="#888"/><line x1="10" y1="18" x2="38" y2="18" stroke="#999" stroke-width="2"/></svg>',
      'dishwasher': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="6" y="8" width="36" height="36" rx="2" fill="#A0A0A0"/><rect x="8" y="10" width="32" height="6" rx="1" fill="#606060"/><rect x="8" y="18" width="32" height="24" rx="1" fill="#B8B8B8"/><rect x="12" y="12" width="4" height="2" rx="1" fill="#888"/><rect x="18" y="12" width="4" height="2" rx="1" fill="#888"/><rect x="14" y="32" width="20" height="2" rx="1" fill="#909090"/></svg>',
      'microwave': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="12" width="40" height="24" rx="2" fill="#3a3a3a"/><rect x="6" y="14" width="26" height="20" rx="1" fill="#1a1a1a"/><rect x="8" y="16" width="22" height="16" rx="1" fill="#222"/><rect x="34" y="16" width="8" height="16" rx="1" fill="#4a4a4a"/><circle cx="38" cy="20" r="2" fill="#666"/><circle cx="38" cy="28" r="2" fill="#666"/></svg>',
      'range-hood': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><path d="M8 32 L16 12 L32 12 L40 32 Z" fill="#808080"/><rect x="6" y="32" width="36" height="8" rx="1" fill="#909090"/><rect x="20" y="4" width="8" height="8" fill="#707070"/><rect x="10" y="36" width="6" height="2" rx="1" fill="#606060"/><rect x="21" y="36" width="6" height="2" rx="1" fill="#606060"/><rect x="32" y="36" width="6" height="2" rx="1" fill="#606060"/></svg>',
      'oven': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="6" y="4" width="36" height="40" rx="2" fill="#2a2a2a"/><rect x="8" y="6" width="32" height="8" rx="1" fill="#3a3a3a"/><rect x="8" y="16" width="32" height="26" rx="1" fill="#1a1a1a"/><rect x="12" y="20" width="24" height="18" rx="1" fill="#222"/><rect x="14" y="8" width="20" height="4" rx="1" fill="#444"/></svg>',
      'door': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="8" y="4" width="32" height="40" rx="1" fill="#DEB887"/><rect x="10" y="6" width="12" height="16" rx="1" fill="#D2B48C"/><rect x="26" y="6" width="12" height="16" rx="1" fill="#D2B48C"/><rect x="10" y="26" width="12" height="16" rx="1" fill="#D2B48C"/><rect x="26" y="26" width="12" height="16" rx="1" fill="#D2B48C"/><circle cx="36" cy="26" r="2" fill="#FFD700"/></svg>',
      'double-door': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="4" width="18" height="40" rx="1" fill="#DEB887"/><rect x="26" y="4" width="18" height="40" rx="1" fill="#DEB887"/><rect x="6" y="8" width="14" height="32" rx="1" fill="#D2B48C"/><rect x="28" y="8" width="14" height="32" rx="1" fill="#D2B48C"/><circle cx="18" cy="26" r="2" fill="#FFD700"/><circle cx="30" cy="26" r="2" fill="#FFD700"/></svg>',
      'sliding-door': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="4" width="44" height="40" rx="1" fill="#BC8F8F"/><rect x="4" y="6" width="20" height="36" fill="#ADD8E6" opacity="0.6"/><rect x="24" y="6" width="20" height="36" fill="#ADD8E6" opacity="0.4"/><line x1="24" y1="6" x2="24" y2="42" stroke="#888" stroke-width="2"/><rect x="4" y="42" width="40" height="2" fill="#666"/></svg>',
      'entry-archway': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><path d="M4 44 L4 16 Q4 4 24 4 Q44 4 44 16 L44 44" fill="none" stroke="#DAA520" stroke-width="4"/><path d="M8 44 L8 18 Q8 8 24 8 Q40 8 40 18 L40 44" fill="#F5DEB3" opacity="0.3"/></svg>',
      'garage-door': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="4" width="44" height="40" rx="1" fill="#A9A9A9"/><rect x="4" y="6" width="40" height="8" fill="#888"/><rect x="4" y="16" width="40" height="8" fill="#999"/><rect x="4" y="26" width="40" height="8" fill="#888"/><rect x="4" y="36" width="40" height="6" fill="#999"/><rect x="20" y="38" width="8" height="2" fill="#666"/></svg>',
      'window': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="8" width="40" height="32" rx="2" fill="#FFF"/><rect x="6" y="10" width="17" height="13" fill="#87CEEB"/><rect x="25" y="10" width="17" height="13" fill="#87CEEB"/><rect x="6" y="25" width="17" height="13" fill="#87CEEB"/><rect x="25" y="25" width="17" height="13" fill="#87CEEB"/><line x1="24" y1="10" x2="24" y2="38" stroke="#FFF" stroke-width="2"/><line x1="6" y1="24" x2="42" y2="24" stroke="#FFF" stroke-width="2"/></svg>',
      'wall': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="4" width="40" height="8" fill="#666"/><rect x="4" y="14" width="18" height="8" fill="#555"/><rect x="24" y="14" width="20" height="8" fill="#555"/><rect x="4" y="24" width="40" height="8" fill="#666"/><rect x="4" y="34" width="18" height="8" fill="#555"/><rect x="24" y="34" width="20" height="8" fill="#555"/></svg>',
      'wall-wood-2x4': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="8" y="2" width="6" height="44" fill="#DEB887"/><rect x="20" y="2" width="6" height="44" fill="#DEB887"/><rect x="32" y="2" width="6" height="44" fill="#DEB887"/><rect x="6" y="10" width="36" height="4" fill="#D2B48C"/><rect x="6" y="32" width="36" height="4" fill="#D2B48C"/></svg>',
      'wall-wood-2x6': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="6" y="2" width="8" height="44" fill="#CD853F"/><rect x="20" y="2" width="8" height="44" fill="#CD853F"/><rect x="34" y="2" width="8" height="44" fill="#CD853F"/><rect x="4" y="10" width="40" height="5" fill="#DEB887"/><rect x="4" y="32" width="40" height="5" fill="#DEB887"/></svg>',
      'wall-steel': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="10" y="2" width="4" height="44" fill="#708090"/><rect x="22" y="2" width="4" height="44" fill="#708090"/><rect x="34" y="2" width="4" height="44" fill="#708090"/><rect x="8" y="8" width="32" height="3" fill="#A9A9A9"/><rect x="8" y="36" width="32" height="3" fill="#A9A9A9"/><circle cx="12" cy="10" r="2" fill="#666"/><circle cx="24" cy="10" r="2" fill="#666"/><circle cx="36" cy="10" r="2" fill="#666"/></svg>',
      'wall-aluminum': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="10" y="2" width="3" height="44" fill="#C0C0C0"/><rect x="22" y="2" width="3" height="44" fill="#C0C0C0"/><rect x="34" y="2" width="3" height="44" fill="#C0C0C0"/><rect x="8" y="6" width="32" height="2" fill="#D3D3D3"/><rect x="8" y="22" width="32" height="2" fill="#D3D3D3"/><rect x="8" y="38" width="32" height="2" fill="#D3D3D3"/></svg>',
      'wall-concrete': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="4" width="40" height="40" fill="#808080"/><circle cx="12" cy="12" r="2" fill="#696969"/><circle cx="28" cy="18" r="3" fill="#696969"/><circle cx="18" cy="32" r="2" fill="#696969"/><circle cx="36" cy="28" r="2" fill="#696969"/><circle cx="24" cy="38" r="2" fill="#696969"/></svg>',
      'wall-brick': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="4" width="10" height="6" fill="#B22222"/><rect x="14" y="4" width="10" height="6" fill="#B22222"/><rect x="26" y="4" width="10" height="6" fill="#B22222"/><rect x="38" y="4" width="8" height="6" fill="#B22222"/><rect x="2" y="12" width="5" height="6" fill="#CD5C5C"/><rect x="9" y="12" width="10" height="6" fill="#CD5C5C"/><rect x="21" y="12" width="10" height="6" fill="#CD5C5C"/><rect x="33" y="12" width="10" height="6" fill="#CD5C5C"/><rect x="2" y="20" width="10" height="6" fill="#B22222"/><rect x="14" y="20" width="10" height="6" fill="#B22222"/><rect x="26" y="20" width="10" height="6" fill="#B22222"/><rect x="38" y="20" width="8" height="6" fill="#B22222"/><rect x="2" y="28" width="5" height="6" fill="#CD5C5C"/><rect x="9" y="28" width="10" height="6" fill="#CD5C5C"/><rect x="21" y="28" width="10" height="6" fill="#CD5C5C"/><rect x="33" y="28" width="10" height="6" fill="#CD5C5C"/><rect x="2" y="36" width="10" height="6" fill="#B22222"/><rect x="14" y="36" width="10" height="6" fill="#B22222"/><rect x="26" y="36" width="10" height="6" fill="#B22222"/><rect x="38" y="36" width="8" height="6" fill="#B22222"/></svg>',
      'wall-block': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="4" width="14" height="10" fill="#696969" stroke="#555"/><rect x="18" y="4" width="14" height="10" fill="#696969" stroke="#555"/><rect x="34" y="4" width="12" height="10" fill="#696969" stroke="#555"/><rect x="2" y="16" width="14" height="10" fill="#787878" stroke="#555"/><rect x="18" y="16" width="14" height="10" fill="#787878" stroke="#555"/><rect x="34" y="16" width="12" height="10" fill="#787878" stroke="#555"/><rect x="2" y="28" width="14" height="10" fill="#696969" stroke="#555"/><rect x="18" y="28" width="14" height="10" fill="#696969" stroke="#555"/><rect x="34" y="28" width="12" height="10" fill="#696969" stroke="#555"/></svg>',
      'steel-beam': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="18" width="40" height="12" fill="#4A4A4A"/><rect x="4" y="18" width="40" height="3" fill="#5A5A5A"/><rect x="4" y="27" width="40" height="3" fill="#3A3A3A"/><rect x="4" y="22" width="40" height="4" fill="#606060"/></svg>',
      'steel-column': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="16" y="4" width="16" height="40" fill="#4A4A4A"/><rect x="16" y="4" width="4" height="40" fill="#5A5A5A"/><rect x="28" y="4" width="4" height="40" fill="#3A3A3A"/><rect x="20" y="4" width="8" height="40" fill="#555"/></svg>',
      'wood-beam': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="18" width="40" height="12" fill="#8B6914" rx="1"/><line x1="8" y1="20" x2="8" y2="28" stroke="#6B4914" stroke-width="1"/><line x1="18" y1="20" x2="18" y2="28" stroke="#6B4914" stroke-width="1"/><line x1="28" y1="20" x2="28" y2="28" stroke="#6B4914" stroke-width="1"/><line x1="38" y1="20" x2="38" y2="28" stroke="#6B4914" stroke-width="1"/></svg>',
      'wood-post': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="16" y="4" width="16" height="40" fill="#8B6914" rx="1"/><line x1="20" y1="8" x2="20" y2="40" stroke="#6B4914" stroke-width="1"/><line x1="24" y1="8" x2="24" y2="40" stroke="#6B4914" stroke-width="1"/><line x1="28" y1="8" x2="28" y2="40" stroke="#6B4914" stroke-width="1"/></svg>',
      'concrete-beam': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="16" width="40" height="16" fill="#707070"/><circle cx="12" cy="22" r="2" fill="#606060"/><circle cx="28" cy="26" r="2" fill="#606060"/><circle cx="38" cy="22" r="2" fill="#808080"/></svg>',
      'concrete-column': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="12" y="4" width="24" height="40" fill="#707070"/><circle cx="20" cy="14" r="2" fill="#606060"/><circle cx="28" cy="28" r="2" fill="#606060"/><circle cx="22" cy="38" r="2" fill="#808080"/></svg>',
      'header': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="18" width="40" height="12" fill="#CD853F" rx="1"/><line x1="4" y1="24" x2="44" y2="24" stroke="#8B6914" stroke-width="1"/><rect x="4" y="18" width="40" height="2" fill="#DEB887"/></svg>',
      'lvl-beam': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="14" width="40" height="20" fill="#DEB887"/><line x1="4" y1="18" x2="44" y2="18" stroke="#C4A76C" stroke-width="1"/><line x1="4" y1="22" x2="44" y2="22" stroke="#C4A76C" stroke-width="1"/><line x1="4" y1="26" x2="44" y2="26" stroke="#C4A76C" stroke-width="1"/><line x1="4" y1="30" x2="44" y2="30" stroke="#C4A76C" stroke-width="1"/></svg>',
      'surface-stainless': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="16" width="44" height="16" rx="1" fill="#C0C0C0"/><line x1="4" y1="20" x2="44" y2="20" stroke="#D8D8D8" stroke-width="1"/><line x1="4" y1="24" x2="44" y2="24" stroke="#D8D8D8" stroke-width="1"/><line x1="4" y1="28" x2="44" y2="28" stroke="#D8D8D8" stroke-width="1"/><rect x="2" y="16" width="44" height="3" fill="#E0E0E0"/><rect x="2" y="29" width="44" height="3" fill="#A0A0A0"/></svg>',
      'surface-solid': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="16" width="44" height="16" rx="2" fill="#E8E4E0"/><rect x="2" y="16" width="44" height="2" fill="#F0ECE8"/><rect x="2" y="30" width="44" height="2" fill="#D8D4D0"/></svg>',
      'surface-laminate': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="18" width="44" height="12" fill="#D4C4A8"/><rect x="2" y="16" width="44" height="3" fill="#E8D8BC"/><rect x="2" y="29" width="44" height="3" fill="#4A4A4A"/><line x1="12" y1="18" x2="12" y2="30" stroke="#C4B498" stroke-width="1"/><line x1="24" y1="18" x2="24" y2="30" stroke="#C4B498" stroke-width="1"/><line x1="36" y1="18" x2="36" y2="30" stroke="#C4B498" stroke-width="1"/></svg>',
      'surface-butcherblock': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="16" width="44" height="16" fill="#C4A76C"/><line x1="8" y1="16" x2="8" y2="32" stroke="#8B6914" stroke-width="1"/><line x1="14" y1="16" x2="14" y2="32" stroke="#8B6914" stroke-width="1"/><line x1="20" y1="16" x2="20" y2="32" stroke="#8B6914" stroke-width="1"/><line x1="26" y1="16" x2="26" y2="32" stroke="#8B6914" stroke-width="1"/><line x1="32" y1="16" x2="32" y2="32" stroke="#8B6914" stroke-width="1"/><line x1="38" y1="16" x2="38" y2="32" stroke="#8B6914" stroke-width="1"/><rect x="2" y="16" width="44" height="2" fill="#D4B77C"/></svg>',
      'surface-concrete': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="16" width="44" height="16" fill="#808080"/><circle cx="10" cy="22" r="2" fill="#707070"/><circle cx="28" cy="26" r="3" fill="#707070"/><circle cx="38" cy="20" r="2" fill="#909090"/><circle cx="18" cy="28" r="2" fill="#909090"/></svg>',
      'glass-door': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="8" y="4" width="32" height="40" rx="1" fill="#FFF"/><rect x="10" y="6" width="28" height="36" fill="#ADD8E6" opacity="0.5"/><rect x="12" y="8" width="24" height="32" fill="#87CEEB" opacity="0.3"/><rect x="34" y="20" width="2" height="10" rx="1" fill="#C0C0C0"/></svg>',
      'french-door': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="4" width="40" height="40" rx="1" fill="#F5F5DC"/><rect x="6" y="6" width="17" height="36" fill="#ADD8E6" opacity="0.4"/><rect x="25" y="6" width="17" height="36" fill="#ADD8E6" opacity="0.4"/><line x1="24" y1="6" x2="24" y2="42" stroke="#F5F5DC" stroke-width="3"/><line x1="6" y1="16" x2="23" y2="16" stroke="#F5F5DC" stroke-width="2"/><line x1="6" y1="28" x2="23" y2="28" stroke="#F5F5DC" stroke-width="2"/><line x1="25" y1="16" x2="42" y2="16" stroke="#F5F5DC" stroke-width="2"/><line x1="25" y1="28" x2="42" y2="28" stroke="#F5F5DC" stroke-width="2"/></svg>',
      'window-large': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="8" width="44" height="32" rx="2" fill="#FFF"/><rect x="4" y="10" width="40" height="28" fill="#87CEEB"/><rect x="4" y="26" width="40" height="12" fill="#90EE90" opacity="0.5"/></svg>',
      'window-bay': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><path d="M8 8 L18 4 L30 4 L40 8 L40 40 L8 40 Z" fill="#FFF"/><path d="M10 10 L17 6 L31 6 L38 10 L38 38 L10 38 Z" fill="#87CEEB"/><line x1="17" y1="6" x2="14" y2="38" stroke="#FFF" stroke-width="2"/><line x1="31" y1="6" x2="34" y2="38" stroke="#FFF" stroke-width="2"/></svg>',
      'crown-molding': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="18" width="44" height="12" fill="#F5F5F5"/><path d="M2 18 Q24 14 46 18" fill="none" stroke="#E0E0E0" stroke-width="2"/><line x1="2" y1="22" x2="46" y2="22" stroke="#DDD" stroke-width="1"/><line x1="2" y1="26" x2="46" y2="26" stroke="#DDD" stroke-width="1"/></svg>',
      'baseboard': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="28" width="44" height="16" fill="#F5F5F5"/><line x1="2" y1="32" x2="46" y2="32" stroke="#E0E0E0" stroke-width="1"/><line x1="2" y1="36" x2="46" y2="36" stroke="#E0E0E0" stroke-width="1"/><rect x="2" y="42" width="44" height="2" fill="#DDD"/></svg>',
      'chair-rail': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="20" width="44" height="8" fill="#F5F5F5"/><path d="M2 20 Q24 18 46 20" fill="none" stroke="#E8E8E8" stroke-width="1"/><line x1="2" y1="24" x2="46" y2="24" stroke="#DDD" stroke-width="1"/></svg>',
      'countertop-l': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><path d="M4 4 L4 44 L28 44 L28 24 L44 24 L44 4 Z" fill="#708090"/><path d="M6 6 L6 42 L26 42 L26 22 L42 22 L42 6 Z" fill="#5a6a7a"/></svg>',
      'countertop-u': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><path d="M4 4 L4 44 L44 44 L44 4 L34 4 L34 34 L14 34 L14 4 Z" fill="#708090"/><path d="M6 6 L6 42 L42 42 L42 6 L32 6 L32 32 L16 32 L16 6 Z" fill="#5a6a7a"/></svg>',
      // Pony Walls & Half Walls
      'pony-wall': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="20" width="40" height="24" fill="#888"/><rect x="2" y="18" width="44" height="4" fill="#708090" rx="1"/><rect x="4" y="44" width="40" height="2" fill="#666"/></svg>',
      'pony-wall-bar': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="16" width="40" height="28" fill="#888"/><rect x="2" y="14" width="44" height="4" fill="#708090" rx="1"/><rect x="0" y="12" width="48" height="4" fill="#5a6a7a" rx="1"/><rect x="4" y="44" width="40" height="2" fill="#666"/></svg>',
      'knee-wall': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="28" width="40" height="16" fill="#888"/><rect x="2" y="26" width="44" height="4" fill="#708090" rx="1"/><rect x="4" y="44" width="40" height="2" fill="#666"/></svg>',
      // Niches & Recesses
      'wall-niche': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="4" width="40" height="40" fill="#888"/><rect x="10" y="10" width="28" height="28" fill="#333"/><rect x="12" y="12" width="24" height="24" fill="#222"/></svg>',
      'fireplace-niche': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="8" width="40" height="36" fill="#888"/><rect x="8" y="12" width="32" height="28" fill="#333"/><rect x="10" y="14" width="28" height="24" fill="#1a1a1a"/><ellipse cx="24" cy="32" rx="8" ry="4" fill="#FF4500" opacity="0.8"/><ellipse cx="24" cy="30" rx="5" ry="3" fill="#FFD700" opacity="0.6"/></svg>',
      'tv-niche': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="8" width="40" height="32" fill="#888"/><rect x="8" y="12" width="32" height="24" fill="#222"/><rect x="10" y="14" width="28" height="20" fill="#1a1a1a"/><rect x="12" y="16" width="24" height="16" fill="#333" stroke="#444"/></svg>',
      'shower-niche': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="10" y="8" width="28" height="32" fill="#87CEEB"/><rect x="14" y="12" width="20" height="24" fill="#555"/><rect x="16" y="14" width="16" height="20" fill="#444"/><ellipse cx="24" cy="24" rx="4" ry="2" fill="#666"/></svg>',
      'grab-bar': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="20" width="40" height="8" rx="4" fill="#C0C0C0"/><circle cx="8" cy="24" r="5" fill="#888"/><circle cx="40" cy="24" r="5" fill="#888"/><rect x="8" y="21" width="32" height="2" fill="#E0E0E0"/></svg>',
      'grab-bar-24': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="8" y="20" width="32" height="8" rx="4" fill="#C0C0C0"/><circle cx="12" cy="24" r="5" fill="#888"/><circle cx="36" cy="24" r="5" fill="#888"/><rect x="12" y="21" width="24" height="2" fill="#E0E0E0"/><text x="24" y="40" font-size="8" fill="#666" text-anchor="middle">24"</text></svg>',
      'grab-bar-36': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="20" width="40" height="8" rx="4" fill="#C0C0C0"/><circle cx="8" cy="24" r="5" fill="#888"/><circle cx="40" cy="24" r="5" fill="#888"/><rect x="8" y="21" width="32" height="2" fill="#E0E0E0"/><text x="24" y="40" font-size="8" fill="#666" text-anchor="middle">36"</text></svg>',
      'grab-bar-42': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="20" width="44" height="8" rx="4" fill="#C0C0C0"/><circle cx="6" cy="24" r="5" fill="#888"/><circle cx="42" cy="24" r="5" fill="#888"/><rect x="6" y="21" width="36" height="2" fill="#E0E0E0"/><text x="24" y="40" font-size="8" fill="#666" text-anchor="middle">42"</text></svg>',
      // Stone Caps & Ledges
      'wall-cap': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="20" width="44" height="8" fill="#708090" rx="1"/><path d="M2 28 Q24 30 46 28" fill="#5a6a7a"/><rect x="4" y="26" width="40" height="16" fill="#aaa" opacity="0.3"/></svg>',
      'bar-top': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="18" width="44" height="6" fill="#708090" rx="1"/><path d="M2 24 Q24 26 46 24" fill="#5a6a7a"/><rect x="0" y="16" width="48" height="4" fill="#5a6a7a" rx="1"/><rect x="6" y="22" width="36" height="20" fill="#888" opacity="0.3"/></svg>',
      'niche-surround': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="4" width="8" height="40" fill="#708090"/><rect x="36" y="4" width="8" height="40" fill="#708090"/><rect x="4" y="4" width="40" height="8" fill="#708090"/><rect x="4" y="36" width="40" height="8" fill="#708090"/><rect x="12" y="12" width="24" height="24" fill="#333"/></svg>',
      'fireplace-surround': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="4" width="10" height="40" fill="#708090"/><rect x="36" y="4" width="10" height="40" fill="#708090"/><rect x="2" y="4" width="44" height="8" fill="#708090"/><rect x="2" y="36" width="44" height="8" fill="#5a6a7a"/><rect x="12" y="12" width="24" height="24" fill="#1a1a1a"/><ellipse cx="24" cy="30" rx="6" ry="3" fill="#FF4500" opacity="0.7"/></svg>',
      'fireplace-hearth': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="28" width="44" height="16" fill="#708090" rx="1"/><rect x="4" y="20" width="40" height="10" fill="#5a6a7a"/><path d="M2 44 Q24 46 46 44" fill="#4a5a6a"/></svg>',
      'mantel': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="18" width="44" height="6" fill="#8B4513" rx="1"/><rect x="6" y="24" width="6" height="16" fill="#A0522D"/><rect x="36" y="24" width="6" height="16" fill="#A0522D"/><rect x="0" y="16" width="48" height="4" fill="#A0522D" rx="1"/></svg>',
      'window-sill': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="8" y="8" width="32" height="24" fill="#87CEEB" stroke="#FFF" stroke-width="2"/><rect x="4" y="32" width="40" height="6" fill="#708090" rx="1"/><path d="M4 38 Q24 40 44 38" fill="#5a6a7a"/></svg>',
      'threshold': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="20" width="40" height="8" fill="#708090" rx="1"/><rect x="2" y="10" width="4" height="28" fill="#DEB887"/><rect x="42" y="10" width="4" height="28" fill="#DEB887"/><path d="M4 28 Q24 30 44 28" fill="#5a6a7a"/></svg>',
      // ===== BATHROOM ELEMENTS =====
      'toilet': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><ellipse cx="24" cy="30" rx="10" ry="12" fill="#F5F5F5" stroke="#DDD" stroke-width="1"/><rect x="14" y="8" width="20" height="14" rx="2" fill="#F0F0F0" stroke="#DDD"/><rect x="18" y="4" width="12" height="6" rx="1" fill="#E8E8E8"/><ellipse cx="24" cy="32" rx="6" ry="8" fill="#E0E0E0"/></svg>',
      'toilet-round': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><ellipse cx="24" cy="28" rx="10" ry="10" fill="#F5F5F5" stroke="#DDD" stroke-width="1"/><rect x="14" y="8" width="20" height="12" rx="2" fill="#F0F0F0" stroke="#DDD"/><rect x="18" y="4" width="12" height="6" rx="1" fill="#E8E8E8"/><ellipse cx="24" cy="28" rx="6" ry="6" fill="#E0E0E0"/></svg>',
      'toilet-wall': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><ellipse cx="24" cy="30" rx="10" ry="12" fill="#F5F5F5" stroke="#DDD" stroke-width="1"/><rect x="10" y="6" width="28" height="8" fill="#888" stroke="#666"/><ellipse cx="24" cy="32" rx="6" ry="8" fill="#E0E0E0"/></svg>',
      'bidet': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><ellipse cx="24" cy="28" rx="10" ry="12" fill="#F5F5F5" stroke="#DDD" stroke-width="1"/><ellipse cx="24" cy="28" rx="6" ry="8" fill="#E0E0E0"/><circle cx="24" cy="16" r="3" fill="#C0C0C0"/><circle cx="24" cy="28" r="2" fill="#888"/></svg>',
      'bathtub': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="12" width="40" height="28" rx="3" fill="#F5F5F5" stroke="#DDD" stroke-width="1"/><rect x="6" y="14" width="36" height="24" rx="2" fill="#E8E8E8"/><circle cx="10" cy="20" r="3" fill="#C0C0C0"/><rect x="8" y="10" width="4" height="4" rx="1" fill="#A0A0A0"/></svg>',
      'bathtub-freestanding': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><ellipse cx="24" cy="24" rx="20" ry="12" fill="#F5F5F5" stroke="#DDD" stroke-width="1"/><ellipse cx="24" cy="24" rx="16" ry="8" fill="#E8E8E8"/><ellipse cx="8" cy="38" rx="3" ry="4" fill="#A0A0A0"/><ellipse cx="40" cy="38" rx="3" ry="4" fill="#A0A0A0"/></svg>',
      'bathtub-corner': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><path d="M4 4 L44 4 L44 44 L4 44 Z" fill="#F5F5F5" stroke="#DDD" stroke-width="1"/><path d="M8 8 L40 8 L40 40 Q24 40 8 24 Z" fill="#E8E8E8"/><circle cx="36" cy="12" r="3" fill="#C0C0C0"/></svg>',
      'bathtub-walk-in': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="12" width="40" height="32" rx="2" fill="#F0F0F0" stroke="#DDD" stroke-width="1"/><rect x="6" y="14" width="36" height="28" rx="1" fill="#E8E8E8"/><rect x="4" y="12" width="8" height="32" fill="#D0D0D0"/><rect x="10" y="20" width="2" height="16" rx="1" fill="#C0C0C0"/></svg>',
      'vanity-24': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="8" y="16" width="32" height="28" rx="2" fill="#8B7355"/><rect x="10" y="18" width="28" height="24" rx="1" fill="#A08060"/><rect x="22" y="28" width="4" height="6" rx="1" fill="#FFD700"/><ellipse cx="24" cy="10" rx="10" ry="5" fill="#E0E0E0"/><ellipse cx="24" cy="10" rx="6" ry="3" fill="#808080"/></svg>',
      'vanity-30': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="6" y="16" width="36" height="28" rx="2" fill="#8B7355"/><rect x="8" y="18" width="32" height="24" rx="1" fill="#A08060"/><rect x="22" y="28" width="4" height="6" rx="1" fill="#FFD700"/><ellipse cx="24" cy="10" rx="12" ry="5" fill="#E0E0E0"/><ellipse cx="24" cy="10" rx="8" ry="3" fill="#808080"/></svg>',
      'vanity-36': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="16" width="40" height="28" rx="2" fill="#8B7355"/><rect x="6" y="18" width="36" height="24" rx="1" fill="#A08060"/><rect x="22" y="28" width="4" height="6" rx="1" fill="#FFD700"/><ellipse cx="24" cy="10" rx="14" ry="5" fill="#E0E0E0"/><ellipse cx="24" cy="10" rx="10" ry="3" fill="#808080"/></svg>',
      'vanity-48': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="16" width="44" height="28" rx="2" fill="#8B7355"/><rect x="4" y="18" width="40" height="24" rx="1" fill="#A08060"/><rect x="22" y="28" width="4" height="6" rx="1" fill="#FFD700"/><ellipse cx="24" cy="10" rx="16" ry="5" fill="#E0E0E0"/><ellipse cx="24" cy="10" rx="12" ry="3" fill="#808080"/></svg>',
      'vanity-60': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="16" width="44" height="28" rx="2" fill="#8B7355"/><rect x="4" y="18" width="40" height="24" rx="1" fill="#A08060"/><rect x="12" y="28" width="4" height="6" rx="1" fill="#FFD700"/><rect x="32" y="28" width="4" height="6" rx="1" fill="#FFD700"/><ellipse cx="14" cy="10" rx="8" ry="4" fill="#E0E0E0"/><ellipse cx="34" cy="10" rx="8" ry="4" fill="#E0E0E0"/></svg>',
      'vanity-72': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="16" width="44" height="28" rx="2" fill="#8B7355"/><rect x="4" y="18" width="40" height="24" rx="1" fill="#A08060"/><rect x="10" y="28" width="4" height="6" rx="1" fill="#FFD700"/><rect x="34" y="28" width="4" height="6" rx="1" fill="#FFD700"/><ellipse cx="12" cy="10" rx="7" ry="4" fill="#E0E0E0"/><ellipse cx="36" cy="10" rx="7" ry="4" fill="#E0E0E0"/></svg>',
      'shower-base-36': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="6" y="6" width="36" height="36" rx="2" fill="#D0D0D0" stroke="#B0B0B0"/><rect x="8" y="8" width="32" height="32" rx="1" fill="#E0E0E0"/><circle cx="24" cy="24" r="3" fill="#888"/><circle cx="24" cy="24" r="8" fill="none" stroke="#CCC" stroke-width="1"/></svg>',
      'shower-base-48': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="8" width="40" height="32" rx="2" fill="#D0D0D0" stroke="#B0B0B0"/><rect x="6" y="10" width="36" height="28" rx="1" fill="#E0E0E0"/><circle cx="24" cy="24" r="3" fill="#888"/><circle cx="24" cy="24" r="8" fill="none" stroke="#CCC" stroke-width="1"/></svg>',
      'shower-base-60': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="10" width="44" height="28" rx="2" fill="#D0D0D0" stroke="#B0B0B0"/><rect x="4" y="12" width="40" height="24" rx="1" fill="#E0E0E0"/><circle cx="24" cy="24" r="3" fill="#888"/><circle cx="24" cy="24" r="8" fill="none" stroke="#CCC" stroke-width="1"/></svg>',
      'shower-bench': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="6" y="24" width="36" height="20" rx="2" fill="#A0A0A0" stroke="#888"/><rect x="4" y="20" width="40" height="6" rx="1" fill="#B8B8B8"/><rect x="10" y="32" width="4" height="12" fill="#888"/><rect x="34" y="32" width="4" height="12" fill="#888"/></svg>',
      'shower-glass': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="8" y="4" width="32" height="40" rx="1" fill="#B8E0FF" opacity="0.4" stroke="#87CEEB" stroke-width="2"/><line x1="12" y1="8" x2="12" y2="40" stroke="#ADD8E6" stroke-width="1" opacity="0.5"/><line x1="24" y1="8" x2="24" y2="40" stroke="#ADD8E6" stroke-width="1" opacity="0.5"/><line x1="36" y1="8" x2="36" y2="40" stroke="#ADD8E6" stroke-width="1" opacity="0.5"/></svg>',
      'shower-door': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="6" y="4" width="36" height="40" rx="1" fill="#C4E8FF" opacity="0.5" stroke="#87CEEB" stroke-width="2"/><rect x="36" y="18" width="4" height="12" rx="2" fill="#C0C0C0"/><line x1="20" y1="4" x2="20" y2="44" stroke="#87CEEB" stroke-width="2"/></svg>',
      'mirror': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="6" y="8" width="36" height="32" rx="2" fill="#E8E8FF" stroke="#CCC" stroke-width="2"/><rect x="8" y="10" width="32" height="28" fill="#F0F0FF"/><path d="M12 14 L18 20 L12 20 Z" fill="#FFF" opacity="0.6"/></svg>',
      'medicine-cabinet': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="8" y="6" width="32" height="36" rx="2" fill="#C0C0C0" stroke="#A0A0A0"/><rect x="10" y="8" width="28" height="32" rx="1" fill="#E8E8FF"/><line x1="24" y1="8" x2="24" y2="40" stroke="#C0C0C0" stroke-width="2"/><rect x="28" y="20" width="3" height="8" rx="1" fill="#888"/></svg>',
      'towel-bar': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="20" width="40" height="4" rx="2" fill="#C0C0C0"/><circle cx="8" cy="22" r="4" fill="#888"/><circle cx="40" cy="22" r="4" fill="#888"/><path d="M10 24 Q24 32 38 24" fill="none" stroke="#DEB887" stroke-width="3"/></svg>',
      'toilet-paper': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="16" y="12" width="16" height="24" rx="2" fill="#A0A0A0"/><ellipse cx="24" cy="24" rx="10" ry="12" fill="#F5F5F5"/><ellipse cx="24" cy="24" rx="4" ry="5" fill="#888"/><path d="M30 16 Q36 24 30 32" fill="none" stroke="#E8E8E8" stroke-width="2"/></svg>',
      'fridge-cabinet': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="6" y="2" width="36" height="44" rx="2" fill="#8B5A2B"/><rect x="8" y="4" width="4" height="38" fill="#A0522D"/><rect x="36" y="4" width="4" height="38" fill="#A0522D"/><rect x="12" y="4" width="24" height="10" rx="1" fill="#A0522D"/><rect x="14" y="6" width="20" height="6" rx="1" fill="#CD853F"/><rect x="22" y="8" width="6" height="2" rx="1" fill="#FFD700"/><rect x="12" y="16" width="24" height="26" fill="#2a2a2a"/><rect x="14" y="18" width="20" height="22" rx="1" fill="#D5D5D5"/><rect x="14" y="18" width="9" height="14" fill="#E0E0E0"/><rect x="25" y="18" width="9" height="14" fill="#E0E0E0"/><rect x="14" y="34" width="20" height="6" fill="#E0E0E0"/><rect x="22" y="22" width="4" height="6" fill="#444"/><rect x="6" y="42" width="36" height="4" fill="#1a1a1a"/></svg>',
      // Shower panels (structure elements that need icons)
      'shower-pan': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="8" width="40" height="32" rx="3" fill="#D0D0D0" stroke="#B0B0B0"/><rect x="6" y="10" width="36" height="28" rx="2" fill="#E8E8E8"/><circle cx="24" cy="24" r="4" fill="#808080"/></svg>',
      'shower-curb': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="18" width="40" height="12" rx="2" fill="#808080"/><rect x="4" y="16" width="40" height="4" fill="#909090" rx="1"/></svg>',
      'shower-wall': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="4" width="40" height="40" fill="#B0B0B0"/><rect x="6" y="6" width="36" height="36" fill="#C8C8C8"/><line x1="6" y1="16" x2="42" y2="16" stroke="#B0B0B0"/><line x1="6" y1="26" x2="42" y2="26" stroke="#B0B0B0"/><line x1="6" y1="36" x2="42" y2="36" stroke="#B0B0B0"/></svg>',
      'wall-tile': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="2" width="10" height="10" fill="#E8E8E8" stroke="#CCC"/><rect x="14" y="2" width="10" height="10" fill="#F0F0F0" stroke="#CCC"/><rect x="26" y="2" width="10" height="10" fill="#E8E8E8" stroke="#CCC"/><rect x="38" y="2" width="8" height="10" fill="#F0F0F0" stroke="#CCC"/><rect x="2" y="14" width="10" height="10" fill="#F0F0F0" stroke="#CCC"/><rect x="14" y="14" width="10" height="10" fill="#E8E8E8" stroke="#CCC"/><rect x="26" y="14" width="10" height="10" fill="#F0F0F0" stroke="#CCC"/><rect x="38" y="14" width="8" height="10" fill="#E8E8E8" stroke="#CCC"/><rect x="2" y="26" width="10" height="10" fill="#E8E8E8" stroke="#CCC"/><rect x="14" y="26" width="10" height="10" fill="#F0F0F0" stroke="#CCC"/><rect x="26" y="26" width="10" height="10" fill="#E8E8E8" stroke="#CCC"/><rect x="38" y="26" width="8" height="10" fill="#F0F0F0" stroke="#CCC"/><rect x="2" y="38" width="10" height="8" fill="#F0F0F0" stroke="#CCC"/><rect x="14" y="38" width="10" height="8" fill="#E8E8E8" stroke="#CCC"/><rect x="26" y="38" width="10" height="8" fill="#F0F0F0" stroke="#CCC"/><rect x="38" y="38" width="8" height="8" fill="#E8E8E8" stroke="#CCC"/></svg>',
      'accent-wall': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="4" width="40" height="40" fill="#888"/><rect x="6" y="6" width="36" height="36" fill="#666"/><rect x="8" y="8" width="14" height="14" fill="#555"/><rect x="26" y="8" width="14" height="14" fill="#777"/><rect x="8" y="26" width="14" height="14" fill="#777"/><rect x="26" y="26" width="14" height="14" fill="#555"/></svg>',
      // ===== LAUNDRY ELEMENTS =====
      'washer': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="6" y="4" width="36" height="40" rx="3" fill="#E8E8E8" stroke="#CCC"/><rect x="8" y="6" width="32" height="8" rx="1" fill="#D0D0D0"/><circle cx="24" cy="28" r="12" fill="#F5F5F5" stroke="#CCC" stroke-width="2"/><circle cx="24" cy="28" r="8" fill="#87CEEB" opacity="0.5"/><circle cx="14" cy="10" r="2" fill="#4CAF50"/><circle cx="20" cy="10" r="2" fill="#888"/></svg>',
      'dryer': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="6" y="4" width="36" height="40" rx="3" fill="#E0E0E0" stroke="#CCC"/><rect x="8" y="6" width="32" height="8" rx="1" fill="#D0D0D0"/><circle cx="24" cy="28" r="12" fill="#F0F0F0" stroke="#CCC" stroke-width="2"/><circle cx="24" cy="28" r="8" fill="#DDD"/><circle cx="14" cy="10" r="2" fill="#FF9800"/><circle cx="20" cy="10" r="2" fill="#888"/></svg>',
      'washer-dryer-stack': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="8" y="2" width="32" height="22" rx="2" fill="#E0E0E0" stroke="#CCC"/><rect x="8" y="24" width="32" height="22" rx="2" fill="#E8E8E8" stroke="#CCC"/><circle cx="24" cy="13" r="7" fill="#F0F0F0" stroke="#CCC"/><circle cx="24" cy="35" r="7" fill="#87CEEB" opacity="0.5" stroke="#CCC"/><circle cx="12" cy="6" r="1.5" fill="#FF9800"/><circle cx="12" cy="28" r="1.5" fill="#4CAF50"/></svg>',
      'utility-sink': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="6" y="16" width="36" height="28" rx="2" fill="#D0D0D0" stroke="#B0B0B0"/><rect x="8" y="18" width="32" height="24" rx="1" fill="#E8E8E8"/><rect x="10" y="20" width="28" height="20" fill="#505050"/><rect x="22" y="6" width="4" height="12" rx="2" fill="#C0C0C0"/><circle cx="24" cy="6" r="3" fill="#A0A0A0"/></svg>',
      'laundry-sink': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="6" y="18" width="36" height="26" rx="2" fill="#E0E0E0" stroke="#C0C0C0"/><rect x="8" y="20" width="32" height="22" rx="1" fill="#F0F0F0"/><rect x="10" y="22" width="28" height="18" fill="#606060"/><rect x="22" y="8" width="4" height="12" rx="2" fill="#B0B0B0"/><circle cx="24" cy="8" r="3" fill="#909090"/></svg>',
      'laundry-cabinet': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="6" y="8" width="36" height="36" rx="2" fill="#8B7355"/><rect x="8" y="10" width="15" height="32" rx="1" fill="#A08060"/><rect x="25" y="10" width="15" height="32" rx="1" fill="#A08060"/><rect x="18" y="24" width="2" height="8" rx="1" fill="#FFD700"/><rect x="35" y="24" width="2" height="8" rx="1" fill="#FFD700"/></svg>',
      'ironing-board': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><path d="M8 20 L40 20 L44 24 L40 28 L8 28 Z" fill="#C0C0C0"/><rect x="12" y="22" width="28" height="4" fill="#E8E8E8"/><line x1="16" y1="28" x2="12" y2="40" stroke="#888" stroke-width="2"/><line x1="36" y1="28" x2="40" y2="40" stroke="#888" stroke-width="2"/><line x1="24" y1="28" x2="24" y2="36" stroke="#888" stroke-width="2"/></svg>',
      'drying-rack': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="8" y="8" width="4" height="32" fill="#A0A0A0"/><rect x="36" y="8" width="4" height="32" fill="#A0A0A0"/><line x1="12" y1="12" x2="36" y2="12" stroke="#C0C0C0" stroke-width="2"/><line x1="12" y1="20" x2="36" y2="20" stroke="#C0C0C0" stroke-width="2"/><line x1="12" y1="28" x2="36" y2="28" stroke="#C0C0C0" stroke-width="2"/><line x1="12" y1="36" x2="36" y2="36" stroke="#C0C0C0" stroke-width="2"/></svg>',
      // ===== CLOSET ELEMENTS =====
      'closet-rod': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="20" width="40" height="4" rx="2" fill="#C0C0C0"/><ellipse cx="8" cy="22" rx="4" ry="6" fill="#A0A0A0"/><ellipse cx="40" cy="22" rx="4" ry="6" fill="#A0A0A0"/><path d="M12 24 L12 36 M20 24 L20 38 M28 24 L28 36 M36 24 L36 38" stroke="#8B7355" stroke-width="2"/></svg>',
      'closet-shelf': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="20" width="40" height="6" rx="1" fill="#D4C4A8"/><rect x="4" y="26" width="4" height="16" fill="#C4B498"/><rect x="40" y="26" width="4" height="16" fill="#C4B498"/><rect x="8" y="22" width="8" height="3" fill="#DEB887"/><rect x="20" y="22" width="8" height="3" fill="#DEB887"/><rect x="32" y="22" width="8" height="3" fill="#DEB887"/></svg>',
      'closet-drawers': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="8" y="8" width="32" height="36" rx="2" fill="#8B7355"/><rect x="10" y="10" width="28" height="10" rx="1" fill="#A08060"/><rect x="10" y="22" width="28" height="10" rx="1" fill="#A08060"/><rect x="10" y="34" width="28" height="8" rx="1" fill="#A08060"/><rect x="22" y="13" width="4" height="4" rx="1" fill="#FFD700"/><rect x="22" y="25" width="4" height="4" rx="1" fill="#FFD700"/><rect x="22" y="36" width="4" height="4" rx="1" fill="#FFD700"/></svg>',
      'drawer-unit': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="8" y="8" width="32" height="36" rx="2" fill="#8B7355"/><rect x="10" y="10" width="28" height="10" rx="1" fill="#A08060"/><rect x="10" y="22" width="28" height="10" rx="1" fill="#A08060"/><rect x="10" y="34" width="28" height="8" rx="1" fill="#A08060"/><rect x="22" y="13" width="4" height="4" rx="1" fill="#C0C0C0"/><rect x="22" y="25" width="4" height="4" rx="1" fill="#C0C0C0"/><rect x="22" y="36" width="4" height="4" rx="1" fill="#C0C0C0"/></svg>',
      'shoe-rack': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="6" y="8" width="36" height="4" fill="#A0A0A0"/><rect x="6" y="18" width="36" height="4" fill="#A0A0A0"/><rect x="6" y="28" width="36" height="4" fill="#A0A0A0"/><rect x="6" y="38" width="36" height="4" fill="#A0A0A0"/><rect x="6" y="8" width="4" height="34" fill="#888"/><rect x="38" y="8" width="4" height="34" fill="#888"/><ellipse cx="16" cy="10" rx="4" ry="2" fill="#4A3728"/><ellipse cx="28" cy="10" rx="4" ry="2" fill="#2F1F14"/></svg>',
      'closet-island': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="6" y="16" width="36" height="28" rx="2" fill="#8B7355"/><rect x="4" y="12" width="40" height="6" rx="1" fill="#A08060"/><rect x="8" y="18" width="14" height="24" rx="1" fill="#A08060"/><rect x="26" y="18" width="14" height="24" rx="1" fill="#A08060"/><rect x="18" y="28" width="2" height="6" rx="1" fill="#FFD700"/><rect x="36" y="28" width="2" height="6" rx="1" fill="#FFD700"/></svg>',
      'jewelry-cabinet': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="10" y="4" width="28" height="40" rx="2" fill="#8B7355"/><rect x="12" y="6" width="24" height="36" rx="1" fill="#A08060"/><rect x="14" y="8" width="20" height="8" fill="#2a2a2a" rx="1"/><rect x="14" y="18" width="20" height="8" fill="#2a2a2a" rx="1"/><rect x="14" y="28" width="20" height="8" fill="#2a2a2a" rx="1"/><circle cx="24" cy="12" r="2" fill="#FFD700"/><circle cx="20" cy="22" r="1.5" fill="#C0C0C0"/><circle cx="28" cy="22" r="1.5" fill="#B8860B"/><circle cx="24" cy="32" r="2" fill="#E0E0FF"/></svg>',
      'jewelry-drawer': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="6" y="16" width="36" height="16" rx="2" fill="#8B7355"/><rect x="8" y="18" width="32" height="12" rx="1" fill="#A08060"/><rect x="10" y="20" width="8" height="8" fill="#2a2a2a"/><rect x="20" y="20" width="8" height="8" fill="#2a2a2a"/><rect x="30" y="20" width="8" height="8" fill="#2a2a2a"/><circle cx="14" cy="24" r="2" fill="#FFD700"/><circle cx="24" cy="24" r="2" fill="#C0C0C0"/><circle cx="34" cy="24" r="2" fill="#B8860B"/></svg>',
      'tie-rack': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="8" y="8" width="32" height="6" rx="1" fill="#A0A0A0"/><rect x="12" y="14" width="2" height="28" fill="#C0C0C0"/><rect x="22" y="14" width="2" height="28" fill="#C0C0C0"/><rect x="32" y="14" width="2" height="28" fill="#C0C0C0"/><path d="M11 18 L15 18 L14 32 L12 32 Z" fill="#4169E1"/><path d="M21 18 L25 18 L24 30 L22 30 Z" fill="#DC143C"/><path d="M31 18 L35 18 L34 34 L32 34 Z" fill="#228B22"/></svg>',
      'full-mirror': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="12" y="2" width="24" height="44" rx="2" fill="#E8E8FF" stroke="#CCC" stroke-width="2"/><rect x="14" y="4" width="20" height="40" fill="#F0F0FF"/><path d="M18 8 L24 16 L18 16 Z" fill="#FFF" opacity="0.6"/></svg>',
      // ===== MISSING ELEMENTS (ADDED) =====
      'single-oven-cabinet': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="8" y="2" width="32" height="44" rx="2" fill="#8B5A2B"/><rect x="10" y="4" width="28" height="10" rx="1" fill="#A0522D"/><rect x="12" y="6" width="24" height="6" rx="1" fill="#CD853F"/><rect x="22" y="8" width="4" height="2" rx="1" fill="#FFD700"/><rect x="10" y="16" width="28" height="28" rx="1" fill="#2a2a2a"/><rect x="12" y="18" width="24" height="6" rx="1" fill="#3a3a3a"/><rect x="14" y="19" width="20" height="4" rx="1" fill="#444"/><rect x="12" y="26" width="24" height="16" rx="1" fill="#1a1a1a"/><rect x="14" y="28" width="20" height="12" rx="1" fill="#222"/><rect x="34" y="32" width="2" height="4" rx="1" fill="#666"/></svg>',
      'tall-oven': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="8" y="2" width="32" height="44" rx="2" fill="#8B5A2B"/><rect x="10" y="4" width="28" height="10" rx="1" fill="#A0522D"/><rect x="12" y="6" width="24" height="6" rx="1" fill="#CD853F"/><rect x="22" y="8" width="4" height="2" rx="1" fill="#FFD700"/><rect x="10" y="16" width="28" height="28" rx="1" fill="#2a2a2a"/><rect x="12" y="18" width="24" height="6" rx="1" fill="#3a3a3a"/><rect x="14" y="19" width="20" height="4" rx="1" fill="#444"/><rect x="12" y="26" width="24" height="16" rx="1" fill="#1a1a1a"/><rect x="14" y="28" width="20" height="12" rx="1" fill="#222"/><rect x="34" y="32" width="2" height="4" rx="1" fill="#666"/></svg>',
      'double-oven-cabinet': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="8" y="2" width="32" height="44" rx="2" fill="#8B5A2B"/><rect x="10" y="4" width="28" height="6" rx="1" fill="#A0522D"/><rect x="12" y="5" width="24" height="4" rx="1" fill="#CD853F"/><rect x="22" y="6" width="4" height="2" rx="1" fill="#FFD700"/><rect x="10" y="12" width="28" height="15" rx="1" fill="#2a2a2a"/><rect x="12" y="14" width="24" height="11" rx="1" fill="#1a1a1a"/><rect x="14" y="16" width="20" height="7" rx="1" fill="#222"/><rect x="32" y="18" width="2" height="3" rx="1" fill="#666"/><rect x="10" y="29" width="28" height="15" rx="1" fill="#2a2a2a"/><rect x="12" y="31" width="24" height="11" rx="1" fill="#1a1a1a"/><rect x="14" y="33" width="20" height="7" rx="1" fill="#222"/><rect x="32" y="35" width="2" height="3" rx="1" fill="#666"/></svg>',
      'blind-corner': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><path d="M4 4 L4 44 L44 44 L44 24 L24 24 L24 4 Z" fill="#8B5A2B"/><path d="M6 6 L6 42 L42 42 L42 26 L22 26 L22 6 Z" fill="#A0522D"/><rect x="8" y="8" width="12" height="16" rx="1" fill="#CD853F"/><rect x="8" y="28" width="12" height="12" rx="1" fill="#CD853F"/><rect x="24" y="28" width="16" height="12" rx="1" fill="#CD853F"/><rect x="18" y="14" width="2" height="6" rx="1" fill="#FFD700"/><rect x="18" y="32" width="2" height="6" rx="1" fill="#FFD700"/><rect x="38" y="32" width="2" height="6" rx="1" fill="#FFD700"/><rect x="4" y="44" width="40" height="4" fill="#2a2a2a"/></svg>',
      'countertop-corner': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><path d="M4 4 L4 44 L24 44 L24 24 L44 24 L44 4 Z" fill="#708090"/><path d="M6 6 L6 42 L22 42 L22 22 L42 22 L42 6 Z" fill="#5a6a7a"/><circle cx="12" cy="14" r="2" fill="#8090a0"/><circle cx="12" cy="32" r="2" fill="#8090a0"/><circle cx="32" cy="14" r="2" fill="#8090a0"/><path d="M4 44 L4 46 L26 46 L26 24 L44 24 L44 22 L24 22 L24 44 Z" fill="#4a5a6a"/></svg>',
      'slide-in-range': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="4" width="40" height="40" rx="2" fill="#2a2a2a"/><rect x="4" y="4" width="40" height="12" rx="2" fill="#1a1a1a"/><circle cx="14" cy="10" r="4" fill="#333" stroke="#444" stroke-width="1.5"/><circle cx="24" cy="10" r="4" fill="#333" stroke="#444" stroke-width="1.5"/><circle cx="34" cy="10" r="4" fill="#333" stroke="#444" stroke-width="1.5"/><rect x="6" y="18" width="36" height="4" rx="1" fill="#3a3a3a"/><circle cx="12" cy="20" r="1.5" fill="#666"/><circle cx="20" cy="20" r="1.5" fill="#666"/><circle cx="28" cy="20" r="1.5" fill="#666"/><circle cx="36" cy="20" r="1.5" fill="#666"/><rect x="8" y="24" width="32" height="18" rx="1" fill="#1a1a1a"/><rect x="10" y="26" width="28" height="14" rx="1" fill="#111"/></svg>',
      'cooktop': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="14" width="44" height="20" rx="2" fill="#1a1a1a"/><rect x="4" y="16" width="40" height="16" rx="1" fill="#2a2a2a"/><circle cx="14" cy="24" r="6" fill="#333" stroke="#555" stroke-width="2"/><circle cx="34" cy="24" r="6" fill="#333" stroke="#555" stroke-width="2"/><circle cx="14" cy="24" r="3" fill="#444"/><circle cx="34" cy="24" r="3" fill="#444"/><circle cx="14" cy="24" r="1" fill="#ff4500" opacity="0.6"/><circle cx="34" cy="24" r="1" fill="#ff4500" opacity="0.6"/><rect x="22" y="18" width="4" height="12" fill="#3a3a3a"/><circle cx="24" cy="20" r="1" fill="#666"/><circle cx="24" cy="28" r="1" fill="#666"/></svg>',
      'wall-oven-double': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="6" y="2" width="36" height="44" rx="2" fill="#2a2a2a"/><rect x="8" y="4" width="32" height="20" rx="1" fill="#3a3a3a"/><rect x="10" y="6" width="28" height="16" rx="1" fill="#1a1a1a"/><rect x="12" y="8" width="24" height="12" rx="1" fill="#222"/><rect x="34" y="12" width="2" height="4" rx="1" fill="#666"/><rect x="8" y="26" width="32" height="20" rx="1" fill="#3a3a3a"/><rect x="10" y="28" width="28" height="16" rx="1" fill="#1a1a1a"/><rect x="12" y="30" width="24" height="12" rx="1" fill="#222"/><rect x="34" y="34" width="2" height="4" rx="1" fill="#666"/></svg>'
    };

    const ELEMENT_TYPES = {
      cabinets: [
        // Base cabinets: standard 24" (2ft) deep
        { type: 'base-cabinet', width: 3, height: 2, color: '#8B4513', label: 'Base Cabinet 36"' },
        { type: 'drawer-base', width: 1.5, height: 2, color: '#8B4513', label: 'Drawer Base 18"' },
        { type: 'sink-base', width: 3, height: 2, color: '#8B4513', label: 'Sink Base 36"' },
        // Wall cabinets: standard 12" (1ft) deep
        { type: 'wall-cabinet', width: 3, height: 1, color: '#A0522D', label: 'Wall Cabinet 36"' },
        { type: 'microwave-cabinet', width: 2.5, height: 1.5, color: '#8B4513', label: 'Microwave Shelf' },
        { type: 'above-microwave-cabinet', width: 2.5, height: 1, color: '#8B4513', label: 'Above Microwave' },
        // Tall/Pantry cabinets: 24" (2ft) deep (same as base)
        { type: 'tall-cabinet', width: 2, height: 2, color: '#8B4513', label: 'Tall Cabinet 24"' },
        { type: 'fridge-cabinet', width: 3, height: 2, color: '#8B4513', label: 'Fridge Cabinet 36"' },
        // Oven cabinets: built-in oven housings (30" wide standard, 24" deep)
        { type: 'single-oven-cabinet', width: 2.5, height: 2, color: '#8B4513', label: 'Single Oven Cabinet 30"' },
        { type: 'tall-oven', width: 2.5, height: 2, color: '#8B4513', label: 'Tall Oven Cabinet 30"' },
        { type: 'double-oven-cabinet', width: 2.5, height: 2, color: '#8B4513', label: 'Double Oven Cabinet 30"' },
        // Corner cabinets: 36"x36" footprint
        { type: 'corner-cabinet', width: 3, height: 3, color: '#7B3F00', label: 'Corner Cabinet' },
        { type: 'lazy-susan', width: 3, height: 3, color: '#7B3F00', label: 'Lazy Susan' },
        { type: 'blind-corner', width: 3.5, height: 2, color: '#7B3F00', label: 'Blind Corner' },
        // Island: 6ft wide, 3ft deep
        { type: 'island', width: 6, height: 3, color: '#654321', label: 'Island' }
      ],
      surfaces: [
        // Standard countertop: 25.5" depth (2.125') with 1.5" overhang = 2.17' total
        // Quartz slabs are typically 126" x 63" (10.5' x 5.25') - seams needed after ~10'
        { type: 'countertop', width: 8, height: 2.17, color: '#708090', label: 'Countertop Run' },
        // Corner countertop: sits in corner, 2.17' x 2.17' (symmetrical)
        { type: 'countertop-corner', width: 2.17, height: 2.17, color: '#708090', label: 'Corner Counter' },
        // L-Counter and U-Counter for full kitchen layouts
        { type: 'countertop-l', width: 8, height: 6, color: '#708090', label: 'L-Counter', armWidth: 2.17 },
        { type: 'countertop-u', width: 8, height: 6, color: '#708090', label: 'U-Counter' },
        // Material-specific surfaces
        { type: 'surface-stainless', width: 4, height: 2, color: '#C0C0C0', label: 'Stainless Steel' },
        { type: 'surface-solid', width: 4, height: 2, color: '#E8E4E0', label: 'Solid Surface' },
        { type: 'surface-laminate', width: 4, height: 2, color: '#D4C4A8', label: 'Laminate/Formica' },
        { type: 'surface-butcherblock', width: 3, height: 2, color: '#C4A76C', label: 'Butcher Block' },
        { type: 'surface-concrete', width: 4, height: 2, color: '#808080', label: 'Concrete' },
        { type: 'backsplash', width: 6, height: 0.08, verticalHeight: 1.5, color: '#B8860B', label: 'Backsplash' },
        { type: 'flooring', width: 5, height: 5, color: '#D2691E', label: 'Flooring' },
        { type: 'tile', width: 4, height: 4, color: '#CCC', label: 'Tile Area' },
        // Stone Caps & Ledges (for pony walls, entryways, etc.)
        { type: 'wall-cap', width: 4, height: 0.5, color: '#708090', label: 'Wall Cap/Ledge', capHeight: 3.5, thickness: 0.125 },
        { type: 'bar-top', width: 6, height: 1.5, color: '#708090', label: 'Bar Top', capHeight: 3.5, thickness: 0.125 },
        // Stone Bezels & Surrounds (for niches, fireplaces)
        { type: 'niche-surround', width: 3, height: 4, color: '#708090', label: 'Niche Surround' },
        { type: 'fireplace-surround', width: 5, height: 4, color: '#708090', label: 'Fireplace Surround' },
        { type: 'fireplace-hearth', width: 5, height: 1.5, color: '#708090', label: 'Hearth' },
        { type: 'mantel', width: 5, height: 0.5, color: '#8B4513', label: 'Mantel/Shelf' },
        // Window & Door Sills
        { type: 'window-sill', width: 3, height: 0.5, color: '#708090', label: 'Window Sill' },
        { type: 'threshold', width: 3, height: 0.33, color: '#708090', label: 'Door Threshold' }
      ],
      appliances: [
        { type: 'sink', width: 2.75, height: 1.83, color: '#C0C0C0', label: 'Single Sink', mountType: 'undermount' },
        { type: 'sink-double', width: 3, height: 1.83, color: '#C0C0C0', label: 'Double Sink', mountType: 'undermount' },
        { type: 'sink-farmhouse', width: 2.5, height: 1.75, color: '#F5F5DC', label: 'Farmhouse Sink', mountType: 'farmhouse' },
        { type: 'stove', width: 2.5, height: 2.5, color: '#2F2F2F', label: 'Freestanding Range' },
        { type: 'slide-in-range', width: 2.5, height: 2, color: '#2F2F2F', label: 'Slide-In Range' },
        { type: 'cooktop', width: 2.5, height: 1.75, color: '#1a1a1a', label: 'Cooktop' },
        { type: 'refrigerator', width: 3, height: 3, color: '#A9A9A9', label: 'Refrigerator' },
        { type: 'dishwasher', width: 2, height: 2, color: '#808080', label: 'Dishwasher' },
        { type: 'microwave', width: 2, height: 1.5, color: '#4a4a4a', label: 'Microwave' },
        { type: 'range-hood', width: 2.5, height: 1.5, color: '#696969', label: 'Range Hood' },
        { type: 'oven', width: 2.5, height: 2.5, color: '#3a3a3a', label: 'Wall Oven' },
        { type: 'wall-oven-double', width: 2.5, height: 2.5, color: '#3a3a3a', label: 'Double Wall Oven' }
      ],
      structure: [
        // Doors & Entryways
        { type: 'door', width: 3, height: 0.5, color: '#DEB887', label: 'Standard Door' },
        { type: 'double-door', width: 5, height: 0.5, color: '#D2B48C', label: 'Double Door' },
        { type: 'sliding-door', width: 6, height: 0.5, color: '#BC8F8F', label: 'Sliding Door' },
        { type: 'glass-door', width: 3, height: 0.5, color: '#ADD8E6', label: 'Glass Door' },
        { type: 'french-door', width: 5, height: 0.5, color: '#F5F5DC', label: 'French Door' },
        { type: 'entry-archway', width: 4, height: 0.5, color: '#DAA520', label: 'Archway' },
        { type: 'garage-door', width: 8, height: 0.5, color: '#A9A9A9', label: 'Garage Door' },
        // Windows
        { type: 'window', width: 4, height: 0.5, color: '#87CEEB', label: 'Window' },
        { type: 'window-large', width: 6, height: 0.5, color: '#87CEEB', label: 'Picture Window' },
        { type: 'window-bay', width: 5, height: 1, color: '#87CEEB', label: 'Bay Window' },
        // Trim & Molding
        { type: 'crown-molding', width: 10, height: 0.25, color: '#F5F5F5', label: 'Crown Molding' },
        { type: 'baseboard', width: 10, height: 0.15, color: '#F5F5F5', label: 'Baseboard' },
        { type: 'chair-rail', width: 10, height: 0.1, color: '#F5F5F5', label: 'Chair Rail' },
        // Walls - Residential
        { type: 'wall', width: 0.5, height: 8, color: '#555', label: 'Wall (Drywall)' },
        { type: 'wall-wood-2x4', width: 0.33, height: 8, color: '#8B7355', label: 'Wall (2x4 Wood)' },
        { type: 'wall-wood-2x6', width: 0.5, height: 8, color: '#8B6914', label: 'Wall (2x6 Wood)' },
        // Walls - Commercial
        { type: 'wall-steel', width: 0.33, height: 10, color: '#708090', label: 'Wall (Steel Frame)' },
        { type: 'wall-aluminum', width: 0.33, height: 10, color: '#C0C0C0', label: 'Wall (Aluminum)' },
        // Walls - Masonry
        { type: 'wall-concrete', width: 0.67, height: 8, color: '#808080', label: 'Wall (Concrete)' },
        { type: 'wall-brick', width: 0.67, height: 8, color: '#B22222', label: 'Wall (Brick)' },
        { type: 'wall-block', width: 0.67, height: 8, color: '#696969', label: 'Wall (CMU Block)' },
        // Structural - Beams & Columns
        { type: 'steel-beam', width: 8, height: 0.67, color: '#4A4A4A', label: 'Steel I-Beam' },
        { type: 'steel-column', width: 0.5, height: 0.5, color: '#4A4A4A', label: 'Steel Column' },
        { type: 'wood-beam', width: 6, height: 0.5, color: '#8B6914', label: 'Wood Beam' },
        { type: 'wood-post', width: 0.33, height: 0.33, color: '#8B6914', label: 'Wood Post 4x4' },
        { type: 'concrete-beam', width: 8, height: 0.83, color: '#707070', label: 'Concrete Beam' },
        { type: 'concrete-column', width: 1, height: 1, color: '#707070', label: 'Concrete Column' },
        { type: 'header', width: 4, height: 0.33, color: '#CD853F', label: 'Header/Lintel' },
        { type: 'lvl-beam', width: 8, height: 0.92, color: '#DEB887', label: 'LVL Beam' },
        // Pony Walls & Half Walls (for stone caps)
        { type: 'pony-wall', width: 4, height: 0.5, color: '#888', label: 'Pony Wall', wallHeight: 3.5 },
        { type: 'pony-wall-bar', width: 6, height: 0.5, color: '#888', label: 'Bar Height Wall', wallHeight: 3.5 },
        { type: 'knee-wall', width: 4, height: 0.5, color: '#888', label: 'Knee Wall', wallHeight: 2.5 },
        // Niches & Recesses (for stone bezels/surrounds)
        { type: 'wall-niche', width: 3, height: 4, color: '#444', label: 'Wall Niche' },
        { type: 'fireplace-niche', width: 4, height: 3, color: '#333', label: 'Fireplace Recess' },
        { type: 'tv-niche', width: 5, height: 3, color: '#222', label: 'TV Recess' },
        { type: 'shower-niche', width: 1, height: 1.5, color: '#555', label: 'Shower Niche' },
        // Shower Components
        { type: 'shower-pan', width: 4, height: 3, color: '#D0D0D0', label: 'Shower Pan' },
        { type: 'shower-curb', width: 4, height: 0.5, color: '#808080', label: 'Shower Curb' },
        { type: 'shower-wall', width: 4, height: 0.35, color: '#B0B0B0', label: 'Shower Wall Panel' },
        // Tile Surfaces
        { type: 'wall-tile', width: 4, height: 4, color: '#CCC', label: 'Wall Tile Panel' },
        { type: 'accent-wall', width: 6, height: 0.5, color: '#888', label: 'Accent Wall' },
        // ADA Accessibility
        { type: 'grab-bar-24', width: 2, height: 0.25, color: '#C0C0C0', label: 'Grab Bar 24"' },
        { type: 'grab-bar-36', width: 3, height: 0.25, color: '#C0C0C0', label: 'Grab Bar 36"' },
        { type: 'grab-bar-42', width: 3.5, height: 0.25, color: '#C0C0C0', label: 'Grab Bar 42"' }
      ],
      bathroom: [
        // Toilets
        { type: 'toilet', width: 1.5, height: 2.3, color: '#FFFFFF', label: 'Toilet (Elongated)' },
        { type: 'toilet-round', width: 1.5, height: 2, color: '#FFFFFF', label: 'Toilet (Round)' },
        { type: 'toilet-wall', width: 1.5, height: 1.8, color: '#FFFFFF', label: 'Wall-Hung Toilet' },
        { type: 'bidet', width: 1.5, height: 2, color: '#FFFFFF', label: 'Bidet' },
        // Bathtubs
        { type: 'bathtub', width: 5, height: 2.7, color: '#F5F5F5', label: 'Alcove Tub (60")' },
        { type: 'bathtub-freestanding', width: 5.5, height: 2.5, color: '#FFFFFF', label: 'Freestanding Tub' },
        { type: 'bathtub-corner', width: 5, height: 5, color: '#F5F5F5', label: 'Corner Tub' },
        { type: 'bathtub-walk-in', width: 4.5, height: 2.5, color: '#F0F0F0', label: 'Walk-in Tub' },
        // Vanities
        { type: 'vanity-24', width: 2, height: 1.75, color: '#8B7355', label: 'Vanity 24"' },
        { type: 'vanity-30', width: 2.5, height: 1.75, color: '#8B7355', label: 'Vanity 30"' },
        { type: 'vanity-36', width: 3, height: 1.75, color: '#8B7355', label: 'Vanity 36"' },
        { type: 'vanity-48', width: 4, height: 1.75, color: '#8B7355', label: 'Vanity 48"' },
        { type: 'vanity-60', width: 5, height: 1.75, color: '#8B7355', label: 'Double Vanity 60"' },
        { type: 'vanity-72', width: 6, height: 1.75, color: '#8B7355', label: 'Double Vanity 72"' },
        // Shower Components
        { type: 'shower-base-36', width: 3, height: 3, color: '#D0D0D0', label: 'Shower Base 36x36' },
        { type: 'shower-base-48', width: 4, height: 3, color: '#D0D0D0', label: 'Shower Base 48x36' },
        { type: 'shower-base-60', width: 5, height: 3, color: '#D0D0D0', label: 'Shower Base 60x36' },
        { type: 'shower-bench', width: 2, height: 1.5, color: '#A0A0A0', label: 'Shower Bench' },
        { type: 'shower-glass', width: 3, height: 0.15, color: '#B8E0FF', label: 'Glass Panel' },
        { type: 'shower-door', width: 2.5, height: 0.15, color: '#C4E8FF', label: 'Shower Door' },
        // Accessories
        { type: 'mirror', width: 3, height: 0.15, color: '#E8E8FF', label: 'Mirror' },
        { type: 'medicine-cabinet', width: 2, height: 0.5, color: '#C0C0C0', label: 'Medicine Cabinet' },
        { type: 'towel-bar', width: 2, height: 0.15, color: '#C0C0C0', label: 'Towel Bar' },
        { type: 'toilet-paper', width: 0.5, height: 0.5, color: '#A0A0A0', label: 'TP Holder' }
      ],
      laundry: [
        { type: 'washer', width: 2.3, height: 2.3, color: '#E8E8E8', label: 'Washer' },
        { type: 'dryer', width: 2.3, height: 2.3, color: '#E0E0E0', label: 'Dryer' },
        { type: 'washer-dryer-stack', width: 2.3, height: 2.3, color: '#E8E8E8', label: 'Stacked W/D' },
        { type: 'utility-sink', width: 2, height: 2, color: '#D0D0D0', label: 'Utility Sink' },
        { type: 'laundry-sink', width: 2, height: 1.75, color: '#E0E0E0', label: 'Laundry Sink' },
        { type: 'laundry-cabinet', width: 3, height: 2, color: '#8B7355', label: 'Laundry Cabinet' },
        { type: 'ironing-board', width: 1, height: 4, color: '#C0C0C0', label: 'Ironing Board' },
        { type: 'drying-rack', width: 2, height: 3, color: '#A0A0A0', label: 'Drying Rack' }
      ],
      closet: [
        { type: 'closet-rod', width: 4, height: 0.15, color: '#C0C0C0', label: 'Closet Rod' },
        { type: 'closet-shelf', width: 4, height: 1, color: '#D4C4A8', label: 'Shelf' },
        { type: 'closet-drawers', width: 2, height: 2, color: '#8B7355', label: 'Drawer Unit' },
        { type: 'drawer-unit', width: 2, height: 2, color: '#8B7355', label: 'Drawer Unit (Alt)' },
        { type: 'shoe-rack', width: 3, height: 1.5, color: '#A0A0A0', label: 'Shoe Rack' },
        { type: 'closet-island', width: 3, height: 2, color: '#8B7355', label: 'Closet Island' },
        { type: 'jewelry-cabinet', width: 1.5, height: 1, color: '#8B7355', label: 'Jewelry Cabinet' },
        { type: 'jewelry-drawer', width: 2, height: 0.5, color: '#8B7355', label: 'Jewelry Drawer' },
        { type: 'tie-rack', width: 1.5, height: 2, color: '#A0A0A0', label: 'Tie/Belt Rack' },
        { type: 'full-mirror', width: 2, height: 0.15, color: '#E8E8FF', label: 'Full-Length Mirror' }
      ]
    };

    const FLOOR_PLANS = [
      { id: 'empty', name: 'Empty', walls: [] },
      { id: 'square', name: 'Square', walls: [
        { x: 0, y: 0, w: 1, h: 1, type: 'full' }
      ]},
      { id: 'l-shape', name: 'L-Shape', walls: [
        { x: 0, y: 0, w: 0.6, h: 1, type: 'rect' },
        { x: 0, y: 0, w: 1, h: 0.5, type: 'rect' }
      ]},
      { id: 'u-shape', name: 'U-Shape', walls: [
        { x: 0, y: 0, w: 0.3, h: 1, type: 'rect' },
        { x: 0.7, y: 0, w: 0.3, h: 1, type: 'rect' },
        { x: 0, y: 0.7, w: 1, h: 0.3, type: 'rect' }
      ]},
      { id: 'galley', name: 'Galley', walls: [
        { x: 0, y: 0, w: 0.2, h: 1, type: 'rect' },
        { x: 0.8, y: 0, w: 0.2, h: 1, type: 'rect' }
      ]},
      { id: 'open', name: 'Open Plan', walls: [
        { x: 0, y: 0.7, w: 0.4, h: 0.3, type: 'rect' }
      ]}
    ];

    // Helper function to resolve asset URLs for both file:// and http:// protocols
    function resolveAssetUrl(url) {
      if (!url) return null;
      if (url.startsWith('http') || url.startsWith('data:') || url.startsWith('blob:')) {
        return url;
      }
      // For local file:// protocol, construct absolute path
      if (window.location.protocol === 'file:') {
        const basePath = window.location.href.replace(/\/tools\/room-designer\/.*$/, '');
        return basePath + url;
      }
      // For http/https, relative paths work
      return url;
    }

    // Materials library using actual Surprise Granite product images + Daltile CTF Price List
    const MATERIALS = {
      granite: [
        // Daltile Natural Stone - Granite (CTF Price List Jan 2026)
        { id: 'daltile-absolute-black', name: 'Absolute Black', color: '#0a0a0a', sku: 'L75712121L', price: 10.45, brand: 'Daltile' },
        { id: 'daltile-alaska-white', name: 'Alaska White', color: '#E8E4E0', sku: 'L77612121L', price: 23.40, brand: 'Daltile' },
        { id: 'daltile-bianco-antico', name: 'Bianco Antico', color: '#E0D8D0', sku: 'L79912121L', price: 25.90, brand: 'Daltile' },
        { id: 'daltile-black-galaxy', name: 'Black Galaxy', color: '#1a1a2e', sku: 'L76712121L', price: 10.45, brand: 'Daltile' },
        { id: 'daltile-blue-pearl', name: 'Blue Pearl', color: '#3d4f6b', sku: 'L75812121L', price: 16.05, brand: 'Daltile' },
        { id: 'daltile-colonial-white', name: 'Colonial White', color: '#F0EBE5', sku: 'L79512121L', price: 23.40, brand: 'Daltile' },
        { id: 'daltile-delicatus-white', name: 'Delicatus White', color: '#FAF8F5', sku: 'L80812121L', price: 31.45, brand: 'Daltile' },
        { id: 'daltile-fantasy-brown', name: 'Fantasy Brown', color: '#C4B7A6', sku: 'L81212121L', price: 25.90, brand: 'Daltile' },
        { id: 'daltile-giallo-ornamental', name: 'Giallo Ornamental', color: '#C9B896', sku: 'L76012121L', price: 10.45, brand: 'Daltile' },
        { id: 'daltile-new-venetian-gold', name: 'New Venetian Gold', color: '#D4B878', sku: 'L76112121L', price: 10.45, brand: 'Daltile' },
        { id: 'daltile-river-white', name: 'River White', color: '#F0EBE5', sku: 'L80712121L', price: 23.40, brand: 'Daltile' },
        { id: 'daltile-santa-cecilia', name: 'Santa Cecilia', color: '#C8A878', sku: 'L76212121L', price: 10.45, brand: 'Daltile' },
        { id: 'daltile-steel-grey', name: 'Steel Grey', color: '#6B6B6B', sku: 'L78512121L', price: 10.45, brand: 'Daltile' },
        { id: 'daltile-typhoon-bordeaux', name: 'Typhoon Bordeaux', color: '#8B4A4A', sku: 'L79812121L', price: 25.90, brand: 'Daltile' },
        { id: 'daltile-uba-tuba', name: 'Uba Tuba', color: '#2A3A2A', sku: 'L76312121L', price: 5.80, brand: 'Daltile' },
        { id: 'daltile-white-ice', name: 'White Ice', color: '#F8F8F8', sku: 'L81112121L', price: 23.40, brand: 'Daltile' }
      ],
      quartz: [
        // Surprise Granite Collection
        { id: 'quartz-stellar-white', name: 'Stellar White', color: '#f5f5f5', url: 'https://cdn.prod.website-files.com/6456ce4476abb25581fbad0c/6456ce4576abb21af6fbc914_msi-surfaces-quartz-surprise-granite-stellar-white-moment.webp', brand: 'MSI' },
        { id: 'quartz-shell-white', name: 'Shell White', color: '#faf8f5', url: 'https://cdn.prod.website-files.com/6456ce4476abb25581fbad0c/6456ce4576abb28a6bfbc8cb_msi-surfaces-quartz-surprise-granite-shell-white-close-up.webp', brand: 'MSI' },
        { id: 'quartz-perla-white', name: 'Perla White', color: '#f0ece5', url: 'https://cdn.prod.website-files.com/6456ce4476abb25581fbad0c/6456ce4576abb20436fbc89c_msi-surfaces-quartz-surprise-granite-perla-white-moment.webp', brand: 'MSI' },
        { id: 'quartz-stellar-gray', name: 'Stellar Gray', color: '#8a8a8a', url: 'https://cdn.prod.website-files.com/6456ce4476abb25581fbad0c/6456ce4576abb2590afbc90f_msi-surfaces-quartz-surprise-granite-sstellar-gray-moment.webp', brand: 'MSI' },
        { id: 'quartz-midnight', name: 'Midnight Majesty', color: '#1a1a2e', url: 'https://cdn.prod.website-files.com/6456ce4476abb25581fbad0c/6456ce4576abb2eaa9fbc85a_msi-surfaces-quartz-surprise-granite-midnight-majesty-close-up.webp', brand: 'MSI' },
        { id: 'quartz-calacatta', name: 'Calacatta Laurent', color: '#f8f6f0', url: 'https://cdn.prod.website-files.com/6456ce4476abb25581fbad0c/6456ce4576abb294bffbc2da_dekton-surprise-granite-laurent-quartz-close-up.webp', brand: 'Dekton' },
        // MSI Premium Natural Quartz (Jan 2025 Price List) - with CDN images
        { id: 'msi-aruca-white', name: 'Aruca White', color: '#F5F5F5', sku: 'QSL-ARUCAWHT', price: 8.40, brand: 'MSI Quartz', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/aruca-white-quartz.jpg' },
        { id: 'msi-frost-white', name: 'Frost White', color: '#FFFFFF', sku: 'QSL-FRSTWHT', price: 8.40, brand: 'MSI Quartz', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/frost-white-quartz.jpg' },
        { id: 'msi-sparkling-white', name: 'Sparkling White', color: '#FAFAFA', sku: 'QSL-SPRWHT', price: 8.40, brand: 'MSI Quartz', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/sparkling-white-quartz.jpg' },
        { id: 'msi-arctic-white', name: 'Arctic White', color: '#F0F0F0', sku: 'QSL-ARCWHT', price: 9.00, brand: 'MSI Quartz', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/arctic-white-quartz.jpg' },
        { id: 'msi-carrara-mist', name: 'Carrara Mist', color: '#E8E8E8', sku: 'QSL-CARRMIST', price: 10.75, brand: 'MSI Quartz', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/carrara-mist-quartz.jpg' },
        { id: 'msi-calacatta-alto', name: 'Calacatta Alto', color: '#FAF8F5', sku: 'QSL-CALAALTO', price: 10.75, brand: 'MSI Quartz', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/calacatta-alto-quartz.jpg' },
        { id: 'msi-midnight-majesty', name: 'Midnight Majesty', color: '#1A1A1A', sku: 'QSL-MIDMAJ', price: 10.75, brand: 'MSI Quartz', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/midnight-majesty-quartz.jpg' },
        { id: 'msi-alabaster-white', name: 'Alabaster White', color: '#FAF8F5', sku: 'QSL-ALABWHT', price: 13.15, brand: 'MSI Quartz', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/alabaster-white-quartz.jpg' },
        { id: 'msi-calacatta-vicenza', name: 'Calacatta Vicenza', color: '#F8F5F0', sku: 'QSL-CALVIC', price: 13.15, brand: 'MSI Quartz', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/calacatta-vicenza-quartz.jpg' },
        { id: 'msi-calacatta-laza', name: 'Calacatta Laza', color: '#FAFAFA', sku: 'QSL-CALALAZA', price: 15.00, brand: 'MSI Quartz', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/calacatta-laza-quartz.jpg' },
        { id: 'msi-babylon-gray', name: 'Babylon Gray', color: '#4A4A4A', sku: 'QSL-BABYLONGRY', price: 15.00, brand: 'MSI Quartz', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/babylon-gray-quartz.jpg' },
        { id: 'msi-soapstone-mist', name: 'Soapstone Mist', color: '#686868', sku: 'QSL-SPSTNMIST', price: 15.00, brand: 'MSI Quartz', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/soapstone-mist-quartz.jpg' },
        { id: 'msi-calacatta-miraggio', name: 'Calacatta Miraggio', color: '#FAF8F5', sku: 'QSL-CALAMIRAGGIO', price: 18.00, brand: 'MSI Quartz', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/calacatta-miraggio-quartz.jpg' },
        { id: 'msi-calacatta-versailles', name: 'Calacatta Versailles', color: '#FAFAFA', sku: 'QSL-CALAVERSA', price: 20.75, brand: 'MSI Quartz', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/calacatta-versailles-quartz.jpg' },
        { id: 'msi-lumataj', name: 'Lumataj', color: '#F5F0E8', sku: 'QSL-LUMATAJ', price: 21.80, brand: 'MSI Quartz', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/lumataj-quartz.jpg' },
        // MSI Premium Quartz - Additional Colors (Jan 2025) - with CDN images
        { id: 'msi-iced-white', name: 'Iced White', color: '#F8F8F8', sku: 'QSL-ICEDWHT', price: 8.40, brand: 'MSI Quartz', tier: 'Group 0', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/iced-white-quartz.jpg' },
        { id: 'msi-bayshore-sand', name: 'Bayshore Sand', color: '#D4C4A8', sku: 'QSL-BAYSHRSND', price: 8.40, brand: 'MSI Quartz', tier: 'Group 0', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/bayshore-sand-quartz.jpg' },
        { id: 'msi-snow-white', name: 'Snow White', color: '#FEFEFE', sku: 'QSL-SNOWHTE', price: 9.00, brand: 'MSI Quartz', tier: 'Group 1', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/snow-white-quartz.jpg' },
        { id: 'msi-carrara-marmi', name: 'Carrara Marmi', color: '#F5F5F5', sku: 'QSL-CARMARMI', price: 10.75, brand: 'MSI Quartz', tier: 'Group 2', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/carrara-marmi-quartz.jpg' },
        { id: 'msi-stellar-white-g2', name: 'Stellar White', color: '#F5F5F5', sku: 'QSL-STELLARWHT', price: 10.75, brand: 'MSI Quartz', tier: 'Group 2', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/stellar-white-quartz.jpg' },
        { id: 'msi-calacatta-classique', name: 'Calacatta Classique', color: '#FAFAFA', sku: 'QSL-CALACLSQUE', price: 13.15, brand: 'MSI Quartz', tier: 'Group 3', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/calacatta-classique-quartz.jpg' },
        { id: 'msi-fairy-white', name: 'Fairy White', color: '#F8F8F8', sku: 'QSL-FAIWHT', price: 13.15, brand: 'MSI Quartz', tier: 'Group 3', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/fairy-white-quartz.jpg' },
        { id: 'msi-calacatta-botanica', name: 'Calacatta Botanica', color: '#F5F2EE', sku: 'QSL-CALABOTNICA', price: 15.00, brand: 'MSI Quartz', tier: 'Group 4', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/calacatta-botanica-quartz.jpg' },
        { id: 'msi-perla-white-g4', name: 'Perla White', color: '#F0ECE5', sku: 'QSL-PERWHT', price: 15.00, brand: 'MSI Quartz', tier: 'Group 4', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/perla-white-quartz.jpg' },
        { id: 'msi-calacatta-monaco', name: 'Calacatta Monaco', color: '#F8F5F0', sku: 'QSL-CALAMONACO', price: 17.00, brand: 'MSI Quartz', tier: 'Group 5', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/calacatta-monaco-quartz.jpg' },
        { id: 'msi-glacier-white', name: 'Glacier White', color: '#F8F8F8', sku: 'QSL-GLACIERWHT', price: 17.00, brand: 'MSI Quartz', tier: 'Group 5', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/glacier-white-quartz.jpg' },
        { id: 'msi-statuary-classique', name: 'Statuary Classique', color: '#FAFAFA', sku: 'QSL-STACLSQUE', price: 17.00, brand: 'MSI Quartz', tier: 'Group 5', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/statuary-classique-quartz.jpg' },
        { id: 'msi-calacatta-clara', name: 'Calacatta Clara', color: '#FAFAFA', sku: 'QSL-CALACLARA', price: 18.00, brand: 'MSI Quartz', tier: 'Group 6', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/calacatta-clara-quartz.jpg' },
        { id: 'msi-calacatta-luccia', name: 'Calacatta Luccia', color: '#FAFAFA', sku: 'QSL-CALALUCCIA', price: 18.00, brand: 'MSI Quartz', tier: 'Group 6', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/calacatta-luccia-quartz.jpg' },
        { id: 'msi-calacatta-trevi', name: 'Calacatta Trevi', color: '#FAFAFA', sku: 'QSL-CALATREVI', price: 18.00, brand: 'MSI Quartz', tier: 'Group 6', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/calacatta-trevi-quartz.jpg' },
        { id: 'msi-calacatta-goa', name: 'Calacatta Goa', color: '#FAF8F5', sku: 'QSL-CALAGOA', price: 20.75, brand: 'MSI Quartz', tier: 'Group 7', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/calacatta-goa-quartz.jpg' },
        { id: 'msi-calacatta-miraggio-gold', name: 'Calacatta Miraggio Gold', color: '#FAF5E8', sku: 'QSL-CALAMIRGOLD', price: 20.75, brand: 'MSI Quartz', tier: 'Group 7', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/calacatta-miraggio-gold-quartz.jpg' },
        { id: 'msi-azurmatt', name: 'Azurmatt', color: '#4A6B8C', sku: 'QSL-AZURMATT', price: 21.80, brand: 'MSI Quartz', tier: 'Group 8', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/azurmatt-quartz.jpg' },
        { id: 'msi-calacatta-viraldi', name: 'Calacatta Viraldi', color: '#FAF8F5', sku: 'QSL-CALAVIRALDI', price: 21.80, brand: 'MSI Quartz', tier: 'Group 8', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/calacatta-viraldi-quartz.jpg' },
        // Daltile ONE Quartz Surfaces (CTF Price List Jan 2026)
        { id: 'daltile-quartz-alabaster', name: 'Alabaster White', color: '#FAF8F5', sku: 'NQ90', price: 7.90, brand: 'Daltile ONE Quartz' },
        { id: 'daltile-quartz-simply-white', name: 'Simply White', color: '#FEFEFE', sku: 'NQ51', price: 7.90, brand: 'Daltile ONE Quartz' },
        { id: 'daltile-quartz-frost-white', name: 'Frost White', color: '#FFFFFF', sku: 'NQ01', price: 12.60, brand: 'Daltile ONE Quartz' },
        { id: 'daltile-quartz-carrara-mist', name: 'Carrara Mist', color: '#F5F5F5', sku: 'NQ64', price: 21.15, brand: 'Daltile ONE Quartz' },
        { id: 'daltile-quartz-calacatta-laza', name: 'Calacatta Laza', color: '#FAFAFA', sku: 'NQ73', price: 34.60, brand: 'Daltile ONE Quartz' }
      ],
      marble: [
        // Daltile Natural Stone - Marble (CTF Price List Jan 2026)
        { id: 'daltile-carrara-honed', name: 'Carrara White (Honed)', color: '#F5F5F5', sku: 'M70112181U', price: 10.45, brand: 'Daltile' },
        { id: 'daltile-carrara-polished', name: 'Carrara White (Polished)', color: '#FAFAFA', sku: 'M70112181L', price: 12.25, brand: 'Daltile' },
        { id: 'daltile-first-snow', name: 'First Snow Elegance', color: '#FFFFFF', sku: 'M19012181L', price: 38.80, brand: 'Daltile' }
      ],
      quartzite: [
        // Daltile Natural Stone - Quartzite (CTF Price List Jan 2026)
        { id: 'daltile-super-white', name: 'Super White', color: '#FEFEFE', sku: 'L02212121L', price: 39.85, brand: 'Daltile' },
        { id: 'daltile-taj-mahal', name: 'Taj Mahal', color: '#F5F0E8', sku: 'L02112121L', price: 39.85, brand: 'Daltile' },
        { id: 'daltile-calacatta-macaubas', name: 'Calacatta Macaubas', color: '#FAF8F5', sku: 'L02612121L', price: 39.85, brand: 'Daltile' },
        { id: 'daltile-azul-macaubas', name: 'Azul Macaubas', color: '#4A6B8C', sku: 'L02512121L', price: 39.85, brand: 'Daltile' },
        { id: 'daltile-sea-pearl', name: 'Sea Pearl', color: '#D8E0E8', sku: 'L02312121L', price: 39.85, brand: 'Daltile' },
        { id: 'daltile-madre-perla', name: 'Madre Perla', color: '#F0E8E0', sku: 'L02812121L', price: 31.20, brand: 'Daltile' }
      ],
      porcelain: [],
      cabinets: [
        { id: 'cabinet-white', name: 'Shaker White', color: '#f5f5f5', url: 'https://cdn.prod.website-files.com/6456ce4476abb25581fbad0c/6456ce4476abb22994fbb0d6_Liberty%20Shaker%20White%20Cabinet.webp' },
        { id: 'cabinet-grey', name: 'Shaker Grey', color: '#7a7a7a', url: 'https://cdn.prod.website-files.com/6456ce4476abb25581fbad0c/6456ce4476abb22121fbb0d7_Liberty%20Shaker%20Grey%20Cabinet.webp' },
        { id: 'cabinet-espresso', name: 'Shaker Espresso', color: '#3d2b1f', url: 'https://cdn.prod.website-files.com/6456ce4476abb25581fbad0c/6456ce4476abb20cc6fbb0d5_Liberty%20Shaker%20Espresso.webp' },
        { id: 'cabinet-black', name: 'Onyx Black', color: '#1a1a1a', url: 'https://cdn.prod.website-files.com/6456ce4476abb25581fbad0c/6456ce4476abb24601fbb0e8_Onyx%20Black%20Shaker.webp' },
        { id: 'cabinet-uptown', name: 'Uptown White', color: '#fefefe', url: 'https://cdn.prod.website-files.com/6456ce4476abb25581fbad0c/6456ce4476abb232ddfbb0eb_Uptown%20White%20Shaker.webp' },
        // MSI Cabinet Collection - Base Cabinets (Jan 2025 Pricing)
        // Colors represent default shaker white finish - actual color changes based on selected series
        { id: 'msi-cab-b09', name: 'MSI Base 9"', color: '#e8ddd0', sku: 'B09', price: 119.13, brand: 'MSI', type: 'base', width: 9, finish: 'shaker-white' },
        { id: 'msi-cab-b12', name: 'MSI Base 12"', color: '#e8ddd0', sku: 'B12', price: 127.63, brand: 'MSI', type: 'base', width: 12, finish: 'shaker-white' },
        { id: 'msi-cab-b15', name: 'MSI Base 15"', color: '#e8ddd0', sku: 'B15', price: 137.25, brand: 'MSI', type: 'base', width: 15, finish: 'shaker-white' },
        { id: 'msi-cab-b18', name: 'MSI Base 18"', color: '#e8ddd0', sku: 'B18', price: 146.30, brand: 'MSI', type: 'base', width: 18, finish: 'shaker-white' },
        { id: 'msi-cab-b21', name: 'MSI Base 21"', color: '#d4a76a', sku: 'B21', price: 155.00, brand: 'MSI', type: 'base', width: 21, finish: 'natural-oak' },
        { id: 'msi-cab-b24', name: 'MSI Base 24"', color: '#d4a76a', sku: 'B24', price: 175.71, brand: 'MSI', type: 'base', width: 24, finish: 'natural-oak' },
        { id: 'msi-cab-b30', name: 'MSI Base 30"', color: '#5d4037', sku: 'B30', price: 196.45, brand: 'MSI', type: 'base', width: 30, finish: 'rustic-walnut' },
        { id: 'msi-cab-b36', name: 'MSI Base 36"', color: '#5d4037', sku: 'B36', price: 245.41, brand: 'MSI', type: 'base', width: 36, finish: 'rustic-walnut' },
        { id: 'msi-cab-sb30', name: 'MSI Sink Base 30"', color: '#6a6a6a', sku: 'SB30', price: 151.82, brand: 'MSI', type: 'sink', width: 30, finish: 'euro-grey' },
        { id: 'msi-cab-sb36', name: 'MSI Sink Base 36"', color: '#6a6a6a', sku: 'SB36', price: 171.82, brand: 'MSI', type: 'sink', width: 36, finish: 'euro-grey' },
        { id: 'msi-cab-3db15', name: 'MSI Drawer Base 15"', color: '#c78b4a', sku: '3DB15', price: 206.32, brand: 'MSI', type: 'drawer', width: 15, finish: 'autumn-oak' },
        { id: 'msi-cab-3db18', name: 'MSI Drawer Base 18"', color: '#c78b4a', sku: '3DB18', price: 219.00, brand: 'MSI', type: 'drawer', width: 18, finish: 'autumn-oak' },
        // MSI Cabinet Collection - Wall Cabinets
        { id: 'msi-cab-w1236', name: 'MSI Wall 12x36"', color: '#e0c8a0', sku: 'W1236', price: 82.15, brand: 'MSI', type: 'wall', width: 12, height: 36, finish: 'light-oak' },
        { id: 'msi-cab-w1536', name: 'MSI Wall 15x36"', color: '#e0c8a0', sku: 'W1536', price: 92.77, brand: 'MSI', type: 'wall', width: 15, height: 36, finish: 'light-oak' },
        { id: 'msi-cab-w1836', name: 'MSI Wall 18x36"', color: '#9e8b7d', sku: 'W1836', price: 103.55, brand: 'MSI', type: 'wall', width: 18, height: 36, finish: 'driftwood' },
        { id: 'msi-cab-w2436', name: 'MSI Wall 24x36"', color: '#9e8b7d', sku: 'W2436', price: 136.01, brand: 'MSI', type: 'wall', width: 24, height: 36, finish: 'driftwood' },
        { id: 'msi-cab-w3036', name: 'MSI Wall 30x36"', color: '#3d2b1f', sku: 'W3036', price: 154.95, brand: 'MSI', type: 'wall', width: 30, height: 36, finish: 'java' },
        { id: 'msi-cab-w3630', name: 'MSI Wall 36x30"', color: '#3d2b1f', sku: 'W3630', price: 154.95, brand: 'MSI', type: 'wall', width: 36, height: 30, finish: 'java' },
        { id: 'msi-cab-w1242', name: 'MSI Wall 12x42"', color: '#8b7355', sku: 'W1242', price: 95.99, brand: 'MSI', type: 'wall', width: 12, height: 42, finish: 'toffee' },
        { id: 'msi-cab-w2442', name: 'MSI Wall 24x42"', color: '#8b7355', sku: 'W2442', price: 159.90, brand: 'MSI', type: 'wall', width: 24, height: 42, finish: 'toffee' },
        { id: 'msi-cab-w3042', name: 'MSI Wall 30x42"', color: '#6b5344', sku: 'W3042', price: 184.23, brand: 'MSI', type: 'wall', width: 30, height: 42, finish: 'barnwood' },
        // MSI Cabinet Collection - Vanity Cabinets
        { id: 'msi-cab-v3021', name: 'MSI Vanity 30x21"', color: '#d3d3d3', sku: 'V3021', price: 152.48, brand: 'MSI', type: 'vanity', width: 30, finish: 'shaker-dove' },
        { id: 'msi-cab-v3621', name: 'MSI Vanity 36x21"', color: '#d3d3d3', sku: 'V3621', price: 172.00, brand: 'MSI', type: 'vanity', width: 36, finish: 'shaker-dove' },
        { id: 'msi-cab-vdb4221', name: 'MSI Vanity Combo 42x21"', color: '#7b3f00', sku: 'VDB4221R', price: 328.93, brand: 'MSI', type: 'vanity', width: 42, finish: 'chestnut' },
        { id: 'msi-cab-vdb4821', name: 'MSI Vanity Combo 48x21"', color: '#7b3f00', sku: 'VDB4821', price: 361.88, brand: 'MSI', type: 'vanity', width: 48, finish: 'chestnut' }
      ],
      tile: [
        // Existing tiles
        { id: 'tile-perla', name: 'Taja Perla', color: '#d4cfc5', url: 'https://cdn.prod.website-files.com/6456ce4476abb25581fbad0c/6456ce4576abb2d4d0fbcc56_taja-perla-porcelain-close-up-thumbnail.jpg' },
        { id: 'tile-white', name: 'White Subway', color: '#ffffff', url: '' },
        { id: 'tile-marble', name: 'Carrara Look', color: '#e8e8e8', url: '' },
        { id: 'tile-slate', name: 'Slate Grey', color: '#708090', url: '' },
        // Daltile PANORAMIC Porcelain Surfaces (CTF Price List Jan 2026)
        { id: 'daltile-panoramic-calacatta', name: 'PANORAMIC Calacatta', color: '#FAFAFA', sku: 'PAN-CAL', price: 31.20, brand: 'Daltile', series: 'PANORAMIC' },
        { id: 'daltile-panoramic-statuario', name: 'PANORAMIC Statuario', color: '#F8F8F8', sku: 'PAN-STA', price: 31.20, brand: 'Daltile', series: 'PANORAMIC' },
        { id: 'daltile-panoramic-nero', name: 'PANORAMIC Nero Marquina', color: '#1A1A1A', sku: 'PAN-NER', price: 28.80, brand: 'Daltile', series: 'PANORAMIC' },
        { id: 'daltile-panoramic-cement', name: 'PANORAMIC Cement', color: '#9E9E9E', sku: 'PAN-CEM', price: 8.90, brand: 'Daltile', series: 'PANORAMIC' }
      ],
      flooring: [
        { id: 'floor-premium', name: 'Premium LVP', color: '#b8956c', url: 'https://cdn.prod.website-files.com/6456ce4476abb25581fbad0c/6456ce4476abb2d85bfbb1d2_All%20Flooring%20Hero%20Background%20Image.webp' },
        { id: 'floor-oak', name: 'Natural Oak', color: '#c4a76c', url: '' },
        { id: 'floor-walnut', name: 'Dark Walnut', color: '#5d4037', url: '' },
        { id: 'floor-maple', name: 'Light Maple', color: '#deb887', url: '' },
        // MSI Everlife LVT Flooring - Ashton Series (Tier 4 Pricing Q1 2025) - with CDN images
        { id: 'msi-lvt-bergen-hills', name: 'Ashton Bergen Hills', color: '#C4A76C', sku: 'ASHTON-BERGENHILLS', price: 1.25, brand: 'MSI Everlife', series: 'Ashton', warranty: '25yr Res' },
        { id: 'msi-lvt-maracay-brown', name: 'Ashton Maracay Brown', color: '#8B7355', sku: 'ASHTON-MARACAYBROWN', price: 1.25, brand: 'MSI Everlife', series: 'Ashton', warranty: '25yr Res' },
        { id: 'msi-lvt-york-gray', name: 'Ashton York Gray', color: '#7A7A7A', sku: 'ASHTON-YORKGRAY', price: 1.25, brand: 'MSI Everlife', series: 'Ashton', warranty: '25yr Res' },
        // MSI Everlife LVT - Cyrus Series - with CDN images
        { id: 'msi-lvt-akadia', name: 'Cyrus Akadia', color: '#A08060', sku: 'CYRUS-AKADIA', price: 1.55, brand: 'MSI Everlife', series: 'Cyrus', warranty: 'Lifetime/10yr Comm' },
        { id: 'msi-lvt-barnstorm', name: 'Cyrus Barnstorm', color: '#5D4037', sku: 'CYRUS-BARNSTORM', price: 1.55, brand: 'MSI Everlife', series: 'Cyrus', warranty: 'Lifetime/10yr Comm' },
        { id: 'msi-lvt-braly', name: 'Cyrus Braly', color: '#6B5344', sku: 'CYRUS-BRALY', price: 1.55, brand: 'MSI Everlife', series: 'Cyrus', warranty: 'Lifetime/10yr Comm' },
        { id: 'msi-lvt-fauna', name: 'Cyrus Fauna', color: '#9E8B7D', sku: 'CYRUS-FAUNA', price: 1.55, brand: 'MSI Everlife', series: 'Cyrus', warranty: 'Lifetime/10yr Comm' },
        { id: 'msi-lvt-katella-ash', name: 'Cyrus Katella Ash', color: '#8A8A8A', sku: 'CYRUS-KATELLAASH', price: 1.55, brand: 'MSI Everlife', series: 'Cyrus', warranty: 'Lifetime/10yr Comm' },
        { id: 'msi-lvt-ludlow', name: 'Cyrus Ludlow', color: '#7D6B5D', sku: 'CYRUS-LUDLOW', price: 1.55, brand: 'MSI Everlife', series: 'Cyrus', warranty: 'Lifetime/10yr Comm' },
        { id: 'msi-lvt-sandino', name: 'Cyrus Sandino', color: '#C4A878', sku: 'CYRUS-SANDINO', price: 1.55, brand: 'MSI Everlife', series: 'Cyrus', warranty: 'Lifetime/10yr Comm' },
        // MSI Everlife LVT - Prescott Series (Premium Commercial) - with CDN images
        { id: 'msi-lvt-prescott-akadia', name: 'Prescott Akadia', color: '#A08060', sku: 'PRESCOTT-AKADIA', price: 1.79, brand: 'MSI Everlife', series: 'Prescott', warranty: 'Lifetime/20yr Comm' },
        { id: 'msi-lvt-prescott-braly', name: 'Prescott Braly', color: '#6B5344', sku: 'PRESCOTT-BRALY', price: 1.79, brand: 'MSI Everlife', series: 'Prescott', warranty: 'Lifetime/20yr Comm' },
        { id: 'msi-lvt-prescott-fauna', name: 'Prescott Fauna', color: '#9E8B7D', sku: 'PRESCOTT-FAUNA', price: 1.79, brand: 'MSI Everlife', series: 'Prescott', warranty: 'Lifetime/20yr Comm' },
        { id: 'msi-lvt-prescott-ludlow', name: 'Prescott Ludlow', color: '#7D6B5D', sku: 'PRESCOTT-LUDLOW', price: 1.79, brand: 'MSI Everlife', series: 'Prescott', warranty: 'Lifetime/20yr Comm' },
        // MSI Everlife LVT - Andover Series - with CDN images
        { id: 'msi-lvt-bayhill-blonde', name: 'Andover Bayhill Blonde', color: '#DEB887', sku: 'ANDOVER-BAYHILLBLONDE', price: 1.79, brand: 'MSI Everlife', series: 'Andover', warranty: 'Lifetime/15yr Comm' },
        { id: 'msi-lvt-hatfield', name: 'Andover Hatfield', color: '#8B7355', sku: 'ANDOVER-HATFIELD', price: 1.79, brand: 'MSI Everlife', series: 'Andover', warranty: 'Lifetime/15yr Comm' },
        { id: 'msi-lvt-kingsdown-gray', name: 'Andover Kingsdown Gray', color: '#6E6E6E', sku: 'ANDOVER-KINGSDOWNGRAY', price: 1.79, brand: 'MSI Everlife', series: 'Andover', warranty: 'Lifetime/15yr Comm' },
        { id: 'msi-lvt-whitby-white', name: 'Andover Whitby White', color: '#E8E4DC', sku: 'ANDOVER-WHITBYWHITE', price: 1.79, brand: 'MSI Everlife', series: 'Andover', warranty: 'Lifetime/15yr Comm' },
        // MSI Everlife LVT - Trecento Series (Stone Look 12x24) - with CDN images
        { id: 'msi-lvt-calacatta-legend', name: 'Trecento Calacatta Legend', color: '#F5F5F5', sku: 'TRECENTO-CALACATTALEGEND', price: 1.75, brand: 'MSI Everlife', series: 'Trecento', warranty: 'Lifetime/10yr Comm' },
        { id: 'msi-lvt-carrara-avell', name: 'Trecento Carrara Avell', color: '#E8E8E8', sku: 'TRECENTO-CARRARAAVELL', price: 1.75, brand: 'MSI Everlife', series: 'Trecento', warranty: 'Lifetime/10yr Comm' },
        { id: 'msi-lvt-mountains-gray', name: 'Trecento Mountains Gray', color: '#9E9E9E', sku: 'TRECENTO-MOUNTAINSGRAY', price: 1.75, brand: 'MSI Everlife', series: 'Trecento', warranty: 'Lifetime/10yr Comm' },
        // MSI Everlife LVT - Laurel Series - with CDN images
        { id: 'msi-lvt-coastal-cottage', name: 'Laurel Coastal Cottage', color: '#D4C8B8', sku: 'LAUREL-COASTALCOTTAGE', price: 1.69, brand: 'MSI Everlife', series: 'Laurel', warranty: 'Lifetime/15yr Comm' },
        { id: 'msi-lvt-honey-hollow', name: 'Laurel Honey Hollow', color: '#C4A76C', sku: 'LAUREL-HONEYHOLLOW', price: 1.69, brand: 'MSI Everlife', series: 'Laurel', warranty: 'Lifetime/15yr Comm' },
        { id: 'msi-lvt-scandi', name: 'Laurel Scandi', color: '#E8E0D8', sku: 'LAUREL-SCANDI', price: 1.69, brand: 'MSI Everlife', series: 'Laurel', warranty: 'Lifetime/15yr Comm' },
        // MSI Everlife LVT - Studio Collection (Ultra Premium) - with CDN images
        { id: 'msi-lvt-studio-bozeman', name: 'Studio Bozeman', color: '#6B5344', sku: 'STUDIO-BOZEMAN', price: 3.39, brand: 'MSI Everlife', series: 'Studio', warranty: 'Lifetime/30yr Comm' },
        { id: 'msi-lvt-studio-taos', name: 'Studio Taos', color: '#8B7355', sku: 'STUDIO-TAOS', price: 3.39, brand: 'MSI Everlife', series: 'Studio', warranty: 'Lifetime/30yr Comm' },
        { id: 'msi-lvt-studio-roswell', name: 'Studio Roswell', color: '#A08060', sku: 'STUDIO-ROSWELL', price: 3.39, brand: 'MSI Everlife', series: 'Studio', warranty: 'Lifetime/30yr Comm' },
        // MSI DryBack LVT - Katavia Series (Budget)
        { id: 'msi-dryback-katavia-bleached-elm', name: 'Katavia Bleached Elm', color: '#D4C8B8', sku: 'VTGBLEELM6X48-2MM-6MIL', price: 0.80, brand: 'MSI DryBack', series: 'Katavia', warranty: '15yr Res' },
        { id: 'msi-dryback-katavia-burnished-acacia', name: 'Katavia Burnished Acacia', color: '#8B7355', sku: 'VTGBURACA6X48-2MM-6MIL', price: 0.80, brand: 'MSI DryBack', series: 'Katavia', warranty: '15yr Res' },
        { id: 'msi-dryback-katavia-charcoal-oak', name: 'Katavia Charcoal Oak', color: '#4A4A4A', sku: 'VTGCHAOAK6X48-2MM-6MIL', price: 0.80, brand: 'MSI DryBack', series: 'Katavia', warranty: '15yr Res' },
        { id: 'msi-dryback-katavia-elmwood-ash', name: 'Katavia Elmwood Ash', color: '#9E8B7D', sku: 'VTGELMASH6X48-2MM-6MIL', price: 0.80, brand: 'MSI DryBack', series: 'Katavia', warranty: '15yr Res' },
        { id: 'msi-dryback-katavia-twilight-oak', name: 'Katavia Twilight Oak', color: '#5D4037', sku: 'VTGTWIOAK6X48-2MM-6MIL', price: 0.80, brand: 'MSI DryBack', series: 'Katavia', warranty: '15yr Res' },
        { id: 'msi-dryback-katavia-woodrift-gray', name: 'Katavia Woodrift Gray', color: '#6E6E6E', sku: 'VTGWOOGRA6X48-2MM-6MIL', price: 0.80, brand: 'MSI DryBack', series: 'Katavia', warranty: '15yr Res' },
        // MSI DryBack LVT - Glenridge Series
        { id: 'msi-dryback-glenridge-aged-hickory', name: 'Glenridge Aged Hickory', color: '#7D6B5D', sku: 'VTGAGEHIC6X48-2MM-12MIL', price: 0.89, brand: 'MSI DryBack', series: 'Glenridge', warranty: '25yr Res/6yr Comm' },
        { id: 'msi-dryback-glenridge-coastal-mix', name: 'Glenridge Coastal Mix', color: '#A8A090', sku: 'VTGCOAMIX6X48-2MM-12MIL', price: 0.89, brand: 'MSI DryBack', series: 'Glenridge', warranty: '25yr Res/6yr Comm' },
        { id: 'msi-dryback-glenridge-jatoba', name: 'Glenridge Jatoba', color: '#6B4A3A', sku: 'VTGJATOBA6X48-2MM-12MIL', price: 0.89, brand: 'MSI DryBack', series: 'Glenridge', warranty: '25yr Res/6yr Comm' },
        { id: 'msi-dryback-glenridge-midnight-maple', name: 'Glenridge Midnight Maple', color: '#3D2B1F', sku: 'VTGMIDMAP6X48-2MM-12MIL', price: 0.89, brand: 'MSI DryBack', series: 'Glenridge', warranty: '25yr Res/6yr Comm' },
        { id: 'msi-dryback-glenridge-saddle-oak', name: 'Glenridge Saddle Oak', color: '#8B7355', sku: 'VTGSADOAK6X48-2MM-12MIL', price: 0.89, brand: 'MSI DryBack', series: 'Glenridge', warranty: '25yr Res/6yr Comm' },
        { id: 'msi-dryback-glenridge-tawny-birch', name: 'Glenridge Tawny Birch', color: '#C4A878', sku: 'VTGTAWBIR6X48-2MM-12MIL', price: 0.89, brand: 'MSI DryBack', series: 'Glenridge', warranty: '25yr Res/6yr Comm' },
        // MSI DryBack LVT - Acclima Series
        { id: 'msi-dryback-acclima-ayla', name: 'Acclima Ayla', color: '#C4A76C', sku: 'VTGAYLA7X48-2MM-12MIL', price: 0.98, brand: 'MSI DryBack', series: 'Acclima', warranty: '25yr Res/6yr Comm' },
        { id: 'msi-dryback-acclima-louis-hill', name: 'Acclima Louis Hill', color: '#8B7355', sku: 'VTGLOUHIL7X48-2MM-12MIL', price: 0.98, brand: 'MSI DryBack', series: 'Acclima', warranty: '25yr Res/6yr Comm' },
        { id: 'msi-dryback-acclima-ludlow', name: 'Acclima Ludlow', color: '#7D6B5D', sku: 'VTGLUDLOW7X48-2MM-12MIL', price: 0.98, brand: 'MSI DryBack', series: 'Acclima', warranty: '25yr Res/6yr Comm' },
        { id: 'msi-dryback-acclima-waldorf', name: 'Acclima Waldorf', color: '#A08060', sku: 'VTGWALDOR7X48-2MM-12MIL', price: 0.98, brand: 'MSI DryBack', series: 'Acclima', warranty: '25yr Res/6yr Comm' },
        { id: 'msi-dryback-acclima-whitfield-gray', name: 'Acclima Whitfield Gray', color: '#8A8A8A', sku: 'VTGWHTGRA7X48-2MM-12MIL', price: 0.98, brand: 'MSI DryBack', series: 'Acclima', warranty: '25yr Res/6yr Comm' },
        // MSI DryBack LVT - Wilmont Series (20mil wear layer)
        { id: 'msi-dryback-wilmont-burnished-acacia', name: 'Wilmont Burnished Acacia', color: '#8B7355', sku: 'VTGBURACA7X48-2.5MM-20MIL', price: 1.19, brand: 'MSI DryBack', series: 'Wilmont', warranty: 'Lifetime/15yr Comm' },
        { id: 'msi-dryback-wilmont-charcoal-oak', name: 'Wilmont Charcoal Oak', color: '#4A4A4A', sku: 'VTGCHAOAK7X48-2.5MM-20MIL', price: 1.19, brand: 'MSI DryBack', series: 'Wilmont', warranty: 'Lifetime/15yr Comm' },
        { id: 'msi-dryback-wilmont-elmwood-ash', name: 'Wilmont Elmwood Ash', color: '#9E8B7D', sku: 'VTGELMASH7X48-2.5MM-20MIL', price: 1.19, brand: 'MSI DryBack', series: 'Wilmont', warranty: 'Lifetime/15yr Comm' },
        { id: 'msi-dryback-wilmont-lime-washed', name: 'Wilmont Lime Washed Oak', color: '#E8E0D8', sku: 'VTGLIMWAS7X48-2.5MM-20MIL', price: 1.19, brand: 'MSI DryBack', series: 'Wilmont', warranty: 'Lifetime/15yr Comm' },
        { id: 'msi-dryback-wilmont-twilight-oak', name: 'Wilmont Twilight Oak', color: '#5D4037', sku: 'VTGTWIOAK7X48-2.5MM-20MIL', price: 1.19, brand: 'MSI DryBack', series: 'Wilmont', warranty: 'Lifetime/15yr Comm' },
        // MSI DryBack LVT - Kallum Series (Looselay Premium)
        { id: 'msi-dryback-kallum-akadia', name: 'Kallum Akadia', color: '#A08060', sku: 'VTGAKADIA9X48-5MM-20MIL', price: 1.69, brand: 'MSI DryBack', series: 'Kallum', warranty: 'Lifetime/25yr Comm' },
        { id: 'msi-dryback-kallum-cranton', name: 'Kallum Cranton', color: '#8B7355', sku: 'VTGCRANTO9X48-5MM-20MIL', price: 1.69, brand: 'MSI DryBack', series: 'Kallum', warranty: 'Lifetime/25yr Comm' },
        { id: 'msi-dryback-kallum-fauna', name: 'Kallum Fauna', color: '#9E8B7D', sku: 'VTGFAUNA9X48-5MM-20MIL', price: 1.69, brand: 'MSI DryBack', series: 'Kallum', warranty: 'Lifetime/25yr Comm' },
        { id: 'msi-dryback-kallum-finely', name: 'Kallum Finely', color: '#6B5344', sku: 'VTGFINELY9X48-5MM-20MIL', price: 1.69, brand: 'MSI DryBack', series: 'Kallum', warranty: 'Lifetime/25yr Comm' },
        { id: 'msi-dryback-kallum-larkin', name: 'Kallum Larkin', color: '#C4A76C', sku: 'VTGLARKIN9X48-5MM-20MIL', price: 1.69, brand: 'MSI DryBack', series: 'Kallum', warranty: 'Lifetime/25yr Comm' },
        { id: 'msi-dryback-kallum-walnut-waves', name: 'Kallum Walnut Waves', color: '#5D4037', sku: 'VTGWALWAV9X48-5MM-20MIL', price: 1.69, brand: 'MSI DryBack', series: 'Kallum', warranty: 'Lifetime/25yr Comm' }
      ],
      showerPanels: [
        // Daltile LUXORA Shower Panels (CTF Price List Jan 2026)
        { id: 'luxora-calacatta-gold', name: 'LUXORA Calacatta Gold', color: '#FAF8F0', sku: 'LUX-CAL-G', price: 5.80, brand: 'Daltile' },
        { id: 'luxora-carrara', name: 'LUXORA Carrara', color: '#F5F5F5', sku: 'LUX-CAR', price: 5.20, brand: 'Daltile' },
        { id: 'luxora-bianco-statuario', name: 'LUXORA Bianco Statuario', color: '#FEFEFE', sku: 'LUX-BIA', price: 5.80, brand: 'Daltile' }
      ],
      // MSI Hardscape Products (Tier 3 Q1 2025 Pricing)
      hardscape: [
        // Travertine Pavers - with CDN images
        { id: 'msi-trav-tuscany-beige', name: 'Tuscany Beige Travertine Paver 16x24', color: '#D4C4A8', sku: 'LPATBEI1624TUMBLED', price: 4.07, brand: 'MSI', category: 'Travertine Pavers', size: '16x24' },
        { id: 'msi-trav-tuscany-beige-6x12', name: 'Tuscany Beige Travertine Paver 6x12', color: '#D4C4A8', sku: 'LPATBEI0612TUMBLED', price: 3.58, brand: 'MSI', category: 'Travertine Pavers', size: '6x12' },
        { id: 'msi-trav-tuscany-choc', name: 'Tuscany Chocolat Travertine Paver 16x24', color: '#6B5344', sku: 'LPATCHOC1624TUMBLED', price: 5.44, brand: 'MSI', category: 'Travertine Pavers', size: '16x24' },
        { id: 'msi-trav-tuscany-ivory', name: 'Tuscany Ivory Travertine Paver 16x24', color: '#F0E8E0', sku: 'LPATIVORY1624TUMBLED', price: 5.13, brand: 'MSI', category: 'Travertine Pavers', size: '16x24' },
        { id: 'msi-trav-tuscany-walnut', name: 'Tuscany Walnut Travertine Paver 16x24', color: '#8B7355', sku: 'LPATWALNUT1624TUMBLED', price: 4.91, brand: 'MSI', category: 'Travertine Pavers', size: '16x24' },
        // Pool Coping - with CDN images
        { id: 'msi-coping-tuscany-beige', name: 'Tuscany Beige Pool Coping 4x12', color: '#D4C4A8', sku: 'LCOPATBEI412TUMBLED', price: 9.45, brand: 'MSI', category: 'Pool Coping', size: '4x12' },
        { id: 'msi-coping-tuscany-ivory', name: 'Tuscany Ivory Pool Coping 4x12', color: '#F0E8E0', sku: 'LCOPATIVORY412TUMBLED', price: 9.81, brand: 'MSI', category: 'Pool Coping', size: '4x12' },
        { id: 'msi-coping-tuscany-walnut', name: 'Tuscany Walnut Pool Coping 4x12', color: '#8B7355', sku: 'LCOPATWALNUT412TUMBLED', price: 11.03, brand: 'MSI', category: 'Pool Coping', size: '4x12' },
        // Porcelain Pavers - Arterra Collection - with CDN images
        { id: 'msi-arterra-beton-gray', name: 'Arterra Beton Gray 24x24', color: '#9E9E9E', sku: 'LPARTBETGRY2424', price: 5.98, brand: 'MSI', category: 'Porcelain Pavers', size: '24x24' },
        { id: 'msi-arterra-legions-aspen', name: 'Arterra Legions Aspen Ash 24x24', color: '#A08060', sku: 'LPARTLEGASP2424', price: 6.98, brand: 'MSI', category: 'Porcelain Pavers', size: '24x24' },
        { id: 'msi-arterra-praia-grey', name: 'Arterra Praia Grey 24x24', color: '#7A7A7A', sku: 'LPARTPRAIAGRY2424', price: 5.98, brand: 'MSI', category: 'Porcelain Pavers', size: '24x24' },
        { id: 'msi-arterra-tierra-sol', name: 'Arterra Tierra Sol Beige 24x24', color: '#C4A878', sku: 'LPARTTIERBEI2424', price: 5.98, brand: 'MSI', category: 'Porcelain Pavers', size: '24x24' },
        // Stacked Stone - with CDN images
        { id: 'msi-stack-arctic-white', name: 'Arctic White Stacked Stone', color: '#F5F5F5', sku: 'LSLEDARCWHT', price: 10.98, brand: 'MSI', category: 'Stacked Stone', size: '6x24' },
        { id: 'msi-stack-charcoal', name: 'Charcoal Stacked Stone', color: '#4A4A4A', sku: 'LSLEDCHAR', price: 9.98, brand: 'MSI', category: 'Stacked Stone', size: '6x24' },
        { id: 'msi-stack-golden-honey', name: 'Golden Honey Stacked Stone', color: '#C4A76C', sku: 'LSLEDGLDHNY', price: 9.98, brand: 'MSI', category: 'Stacked Stone', size: '6x24' },
        { id: 'msi-stack-white-oak', name: 'White Oak Stacked Stone', color: '#E8E4DC', sku: 'LSLEDWHTOAK', price: 11.98, brand: 'MSI', category: 'Stacked Stone', size: '6x24' },
        // Decomposed Granite & Aggregates
        { id: 'msi-dg-pathway', name: 'Decomposed Granite Pathway', color: '#C4A878', sku: 'DG-PATHWAY', price: 89.00, brand: 'MSI', category: 'Aggregates', unit: 'per yard' },
        // Pebbles (40lb bags)
        { id: 'msi-pebble-amazon-multi', name: 'Amazon Multi Pebbles', color: '#8B7355', sku: 'LPEBQAMZMUL3NAT40', price: 14.50, brand: 'MSI', category: 'Pebbles', unit: 'per 40lb bag' },
        { id: 'msi-pebble-black', name: 'Black Polished Pebbles', color: '#1A1A1A', sku: 'LPEBQBLK3POL40', price: 14.50, brand: 'MSI', category: 'Pebbles', unit: 'per 40lb bag' },
        { id: 'msi-pebble-white', name: 'White Polished Pebbles', color: '#F5F5F5', sku: 'LPEBMWHI3POL40', price: 14.50, brand: 'MSI', category: 'Pebbles', unit: 'per 40lb bag' },
        { id: 'msi-pebble-mixed', name: 'Mixed Polished Pebbles', color: '#9E8B7D', sku: 'LPEBMMIX3POL40', price: 14.50, brand: 'MSI', category: 'Pebbles', unit: 'per 40lb bag' },
        { id: 'msi-pebble-nile-gray', name: 'Nile Gray Pebbles', color: '#7A7A7A', sku: 'LPEBQNILGRY3NAT40', price: 14.50, brand: 'MSI', category: 'Pebbles', unit: 'per 40lb bag' },
        { id: 'msi-pebble-himalaya-white', name: 'Himalaya White Pebbles', color: '#FAFAFA', sku: 'LPEBMHIMWHI3NAT40', price: 14.50, brand: 'MSI', category: 'Pebbles', unit: 'per 40lb bag' },
        // Fire Glass (20lb bags)
        { id: 'msi-fireglass-galaxy-black', name: 'Fire Glass Galaxy Black', color: '#0A0A0A', sku: 'LFIRGGALBLK0.5CRU20', price: 21.00, brand: 'MSI', category: 'Fire Glass', unit: 'per 20lb bag' },
        { id: 'msi-fireglass-aqua-blue', name: 'Fire Glass Aqua Blue', color: '#00CED1', sku: 'LFIRGAQUBLU0.25CRU20', price: 21.00, brand: 'MSI', category: 'Fire Glass', unit: 'per 20lb bag' },
        { id: 'msi-fireglass-sapphire-blue', name: 'Fire Glass Sapphire Blue', color: '#0F52BA', sku: 'LFIRGSAPBLU0.5CRU20', price: 21.00, brand: 'MSI', category: 'Fire Glass', unit: 'per 20lb bag' },
        { id: 'msi-fireglass-marine-blue', name: 'Fire Glass Marine Blue', color: '#4169E1', sku: 'LFIRGMARBLU0.5CRU20', price: 21.00, brand: 'MSI', category: 'Fire Glass', unit: 'per 20lb bag' },
        { id: 'msi-fireglass-copper-brown', name: 'Fire Glass Copper Brown', color: '#B87333', sku: 'LFIRGCOPBRO0.5CRU20', price: 21.00, brand: 'MSI', category: 'Fire Glass', unit: 'per 20lb bag' },
        { id: 'msi-fireglass-glacial-silver', name: 'Fire Glass Glacial Silver', color: '#C0C0C0', sku: 'LFIRGGLASIL0.5CRU20', price: 21.00, brand: 'MSI', category: 'Fire Glass', unit: 'per 20lb bag' }
      ],
      // MSI Vanity Collections (2024 Flyer)
      vanities: [
        // RTA Vanities - Ready-To-Assemble Collection
        { id: 'msi-rta-v2721-white', name: 'RTA Vanity 27x21 White', color: '#FFFFFF', sku: 'VANHDR-V2721-WHT', brand: 'MSI', collection: 'RTA', width: 27, features: 'Plywood, Soft-close doors' },
        { id: 'msi-rta-v3021-white', name: 'RTA Vanity 30x21 White', color: '#FFFFFF', sku: 'VANHDR-V3021-WHT', brand: 'MSI', collection: 'RTA', width: 30, features: 'Plywood, Soft-close doors' },
        { id: 'msi-rta-v3621-white', name: 'RTA Vanity 36x21 White', color: '#FFFFFF', sku: 'VANHDR-V3621-WHT', brand: 'MSI', collection: 'RTA', width: 36, features: 'Plywood, Soft-close doors' },
        { id: 'msi-rta-v4821-white', name: 'RTA Vanity 48x21 Single Bowl White', color: '#FFFFFF', sku: 'VANHDR-V4821SB-FLSW-2H', brand: 'MSI', collection: 'RTA', width: 48, features: '4 doors, 2 drawers, Plywood' },
        { id: 'msi-rta-v6021-white', name: 'RTA Vanity 60x21 Double Bowl White', color: '#FFFFFF', sku: 'VANHDR-V6021DB-FLSW-2H', brand: 'MSI', collection: 'RTA', width: 60, features: '4 doors, 2 tilted drawers, Plywood' },
        { id: 'msi-rta-vdb15-white', name: 'RTA Drawer Vanity 15" White', color: '#FFFFFF', sku: 'VDB15-3', brand: 'MSI', collection: 'RTA', width: 15, features: '3-Drawer, Plywood' },
        { id: 'msi-rta-vdb21-white', name: 'RTA Drawer Vanity 21" White', color: '#FFFFFF', sku: 'VDB21-3', brand: 'MSI', collection: 'RTA', width: 21, features: '3-Drawer, Plywood' },
        // RTA Vanities - Grey Color
        { id: 'msi-rta-v3021-grey', name: 'RTA Vanity 30x21 Grey', color: '#7A7A7A', sku: 'VANHDR-V3021-GRY', brand: 'MSI', collection: 'RTA', width: 30, features: 'Plywood, Soft-close doors' },
        { id: 'msi-rta-v3621-grey', name: 'RTA Vanity 36x21 Grey', color: '#7A7A7A', sku: 'VANHDR-V3621-GRY', brand: 'MSI', collection: 'RTA', width: 36, features: 'Plywood, Soft-close doors' },
        { id: 'msi-rta-v4821-grey', name: 'RTA Vanity 48x21 Grey', color: '#7A7A7A', sku: 'VANHDR-V4821SB-GRY', brand: 'MSI', collection: 'RTA', width: 48, features: '4 doors, 2 drawers, Plywood' },
        // RTA Vanities - Blue Color
        { id: 'msi-rta-v3021-blue', name: 'RTA Vanity 30x21 Blue', color: '#4A6B8C', sku: 'VANHDR-V3021-BLU', brand: 'MSI', collection: 'RTA', width: 30, features: 'Plywood, Soft-close doors' },
        { id: 'msi-rta-v3621-blue', name: 'RTA Vanity 36x21 Blue', color: '#4A6B8C', sku: 'VANHDR-V3621-BLU', brand: 'MSI', collection: 'RTA', width: 36, features: 'Plywood, Soft-close doors' },
        // RTA Vanities - Black Color
        { id: 'msi-rta-v3021-black', name: 'RTA Vanity 30x21 Black', color: '#1A1A1A', sku: 'VANHDR-V3021-BLK', brand: 'MSI', collection: 'RTA', width: 30, features: 'Plywood, Soft-close doors' },
        { id: 'msi-rta-v3621-black', name: 'RTA Vanity 36x21 Black', color: '#1A1A1A', sku: 'VANHDR-V3621-BLK', brand: 'MSI', collection: 'RTA', width: 36, features: 'Plywood, Soft-close doors' },
        // RTA Vanities - Natural Oak
        { id: 'msi-rta-v3021-oak', name: 'RTA Vanity 30x21 Natural Oak', color: '#C4A76C', sku: 'VANHDR-V3021-OAK', brand: 'MSI', collection: 'RTA', width: 30, features: 'Wood veneer, Soft-close doors' },
        { id: 'msi-rta-v3621-oak', name: 'RTA Vanity 36x21 Natural Oak', color: '#C4A76C', sku: 'VANHDR-V3621-OAK', brand: 'MSI', collection: 'RTA', width: 36, features: 'Wood veneer, Soft-close doors' },
        // Fluted Vanities - Pre-Assembled Collection
        { id: 'msi-fluted-v3021', name: 'Fluted Vanity 30x21', color: '#DEB887', sku: 'VANFLT-V3021', brand: 'MSI', collection: 'Fluted', width: 30, features: 'Solid wood, Wood veneer, Pre-assembled' },
        { id: 'msi-fluted-v3621', name: 'Fluted Vanity 36x21', color: '#DEB887', sku: 'VANFLT-V3621', brand: 'MSI', collection: 'Fluted', width: 36, features: 'Solid wood, 3 drawers, Pre-assembled' },
        { id: 'msi-fluted-v3021-tilt', name: 'Fluted Vanity 30x21 w/Tilt Drawer', color: '#DEB887', sku: 'VANFLT-V3021-TILT', brand: 'MSI', collection: 'Fluted', width: 30, features: 'Solid wood, Tilted drawer, Pre-assembled' },
        { id: 'msi-fluted-v3621-tilt', name: 'Fluted Vanity 36x21 w/Tilt Drawer', color: '#DEB887', sku: 'VANFLT-V3621-TILT', brand: 'MSI', collection: 'Fluted', width: 36, features: 'Solid wood, 2 tilted drawers, Pre-assembled' },
        // Folding Vanities - Easy Assembly Collection
        { id: 'msi-fold-v2421', name: 'Folding Vanity 24x21', color: '#FFFFFF', sku: 'VANFOLD-V2421', brand: 'MSI', collection: 'Folding', width: 24, features: 'Solid wood frame, Plywood box, Easy assembly' },
        { id: 'msi-fold-v3021', name: 'Folding Vanity 30x21', color: '#FFFFFF', sku: 'VANFOLD-V3021', brand: 'MSI', collection: 'Folding', width: 30, features: 'Solid wood frame, Plywood box, Easy assembly' },
        { id: 'msi-fold-v3621', name: 'Folding Vanity 36x21', color: '#FFFFFF', sku: 'VANFOLD-V3621', brand: 'MSI', collection: 'Folding', width: 36, features: 'Solid wood frame, Plywood box, Easy assembly' },
        { id: 'msi-fold-v4221', name: 'Folding Vanity 42x21', color: '#FFFFFF', sku: 'VANFOLD-V4221', brand: 'MSI', collection: 'Folding', width: 42, features: 'Solid wood frame, Plywood box, Easy assembly' },
        { id: 'msi-fold-v4821', name: 'Folding Vanity 48x21', color: '#FFFFFF', sku: 'VANFOLD-V4821', brand: 'MSI', collection: 'Folding', width: 48, features: 'Solid wood frame, Plywood box, Easy assembly' },
        { id: 'msi-fold-v6021', name: 'Folding Vanity 60x21', color: '#FFFFFF', sku: 'VANFOLD-V6021', brand: 'MSI', collection: 'Folding', width: 60, features: 'Solid wood frame, Plywood box, Easy assembly' }
      ],
      // MSI Flooring Trim & Accessories
      flooringTrims: [
        { id: 'msi-trim-stairtread', name: 'Stair Tread (Eased Edge)', color: '#8B7355', sku: 'STAIR-TREAD', price: 37.00, brand: 'MSI', size: '47.25" x 12"', unit: 'each' },
        { id: 'msi-trim-stairnose-flush', name: 'Stair Nose (Flush)', color: '#8B7355', sku: 'STAIRNOSE-FLUSH', price: 32.00, brand: 'MSI', size: '94"', unit: 'each' },
        { id: 'msi-trim-stairnose-overlap', name: 'Stair Nose (Overlapping)', color: '#8B7355', sku: 'STAIRNOSE-OVERLAP', price: 27.00, brand: 'MSI', size: '94"', unit: 'each' },
        { id: 'msi-trim-endcap', name: 'End Cap', color: '#8B7355', sku: 'ENDCAP', price: 27.00, brand: 'MSI', size: '94"', unit: 'each' },
        { id: 'msi-trim-reducer', name: 'Surface Reducer', color: '#8B7355', sku: 'REDUCER', price: 22.00, brand: 'MSI', size: '94"', unit: 'each' },
        { id: 'msi-trim-tmolding', name: 'T-Molding', color: '#8B7355', sku: 'TMOLDING', price: 27.00, brand: 'MSI', size: '94"', unit: 'each' },
        { id: 'msi-trim-quarterround', name: 'Quarter Round', color: '#8B7355', sku: 'QUARTERROUND', price: 20.00, brand: 'MSI', size: '94"', unit: 'each' }
      ],
      // Cabinet Accessories
      cabinetAccessories: [
        { id: 'msi-acc-basepanel', name: 'Base Panel 36x96', color: '#F5F5F5', sku: 'BP3696', price: 59.39, brand: 'MSI' },
        { id: 'msi-acc-dishwasher-return', name: 'Dishwasher Return Panel', color: '#F5F5F5', sku: 'DWR3', price: 26.35, brand: 'MSI' },
        { id: 'msi-acc-basefiller', name: 'Base Filler 3x30', color: '#F5F5F5', sku: 'F330', price: 12.73, brand: 'MSI' },
        { id: 'msi-acc-scribemolding', name: 'Scribe Molding 96"', color: '#F5F5F5', sku: 'SM8', price: 6.43, brand: 'MSI' },
        { id: 'msi-acc-tallendpanel', name: 'Tall End Panel 30x96', color: '#F5F5F5', sku: 'TEP3096', price: 170.32, brand: 'MSI' },
        { id: 'msi-acc-toekick', name: 'Toe Kick 96"', color: '#F5F5F5', sku: 'TK8', price: 8.88, brand: 'MSI' },
        { id: 'msi-acc-wallfiller36', name: 'Wall Filler 3x36', color: '#F5F5F5', sku: 'WF336', price: 27.19, brand: 'MSI' },
        { id: 'msi-acc-wallfiller42', name: 'Wall Filler 3x42', color: '#F5F5F5', sku: 'WF342', price: 31.58, brand: 'MSI' },
        { id: 'msi-acc-wallfiller96', name: 'Wall Filler 3x96', color: '#F5F5F5', sku: 'WF396', price: 41.64, brand: 'MSI' }
      ]
    };

    // Stone pricing loaded from external JSON file (contains 1137 materials from Excel import)
    let stonePricingLoaded = false;

    // Load stone pricing data from external JSON file and merge into MATERIALS
    async function loadStonePricing() {
      if (stonePricingLoaded) return; // Already loaded

      try {
        const response = await fetch('stone-pricing.json');
        if (!response.ok) {
          console.warn('Stone pricing file not found, using built-in materials only');
          return;
        }

        const stonePricing = await response.json();
        let addedCount = 0;

        // Merge each category  deduplicate by BOTH id AND name
        for (const category of ['granite', 'quartz', 'quartzite', 'marble', 'porcelain']) {
          if (stonePricing[category]) {
            if (!MATERIALS[category]) MATERIALS[category] = [];

            const existingIds = new Set(MATERIALS[category].map(m => m.id));
            const existingNames = new Set(MATERIALS[category].map(m => (m.name || '').toLowerCase().trim()));

            for (const material of stonePricing[category]) {
              if (existingIds.has(material.id)) continue;

              const nameKey = (material.name || '').toLowerCase().trim();
              if (existingNames.has(nameKey)) {
                // Same name already exists (possibly different distributor)
                // Merge price into existing if it lacks one
                const existing = MATERIALS[category].find(m => (m.name || '').toLowerCase().trim() === nameKey);
                if (existing && !existing.price && material.price) {
                  existing.price = material.price;
                  existing.tier = material.tier;
                }
                continue;
              }

              MATERIALS[category].push(material);
              existingIds.add(material.id);
              existingNames.add(nameKey);
              addedCount++;
            }
          }
        }

        stonePricingLoaded = true;
        console.log(`Loaded ${addedCount} stone materials from pricing file`);

        // Refresh the materials panel if it's currently showing a stone category
        if (['granite', 'quartz', 'quartzite', 'marble', 'porcelain'].includes(currentMaterialCategory)) {
          renderMaterials(currentMaterialCategory);
        }

        return addedCount;
      } catch (error) {
        console.warn('Could not load stone pricing:', error);
        return 0;
      }
    }

    // ===== LOAD COUNTERTOPS.JSON (874 products with images) =====
    let countertopsJsonLoaded = false;

    // Brand slug  display name mapping
    const BRAND_SLUG_MAP = {
      'msi-surfaces': 'MSI Surfaces',
      'cambria': 'Cambria',
      'pentalquartz': 'Pentalquartz',
      'radianz-quartz': 'Radianz',
      'silestone': 'Silestone',
      'bolder-image-stone': 'Bolder Image Stone',
      'cosentino': 'Cosentino',
      'sensa': 'Sensa',
      'arizona-tile': 'Arizona Tile',
      'lx-hausys': 'LX Hausys',
      'daltile': 'Daltile'
    };

    // Color name  hex mapping for primaryColor field
    const COLOR_NAME_MAP = {
      'White': '#F5F5F5',
      'Gray': '#888888',
      'Cream': '#F5F0E0',
      'Black': '#1a1a1a',
      'Beige': '#D4C4A8',
      'Brown': '#6B4226',
      'Gold': '#C8A84E',
      'Green': '#4A6B4A',
      'Blue': '#4A6B8C',
      'Red': '#8B4A4A',
      'Tan': '#C8B08A',
      'Silver': '#A8A8A8',
      'Multi': '#B0A090',
      'Yellow': '#D4C878',
      'Pink': '#C8A0A0',
      'Orange': '#C88A4A',
      'Purple': '#6B4A8B',
      'Taupe': '#9B8878'
    };

    // Type  category mapping
    const TYPE_CATEGORY_MAP = {
      'Quartz': 'quartz',
      'Granite': 'granite',
      'Marble': 'marble',
      'Quartzite': 'quartzite',
      'Porcelain': 'porcelain',
      'Dekton': 'porcelain'
    };

    async function loadCountertopsJson() {
      if (countertopsJsonLoaded) return 0;

      try {
        // Determine the path relative to the room designer
        const basePath = window.location.pathname.includes('/tools/room-designer')
          ? '../../data/countertops.json'
          : '/data/countertops.json';

        const response = await fetch(basePath);
        if (!response.ok) {
          console.warn('countertops.json not found at', basePath);
          return 0;
        }

        const data = await response.json();
        const countertops = data.countertops || [];
        console.log(`Loaded countertops.json: ${countertops.length} products`);

        // Build existing name sets per category to avoid duplicates
        const existingNames = {};
        for (const cat of Object.keys(MATERIALS)) {
          if (Array.isArray(MATERIALS[cat])) {
            existingNames[cat] = new Set(
              MATERIALS[cat].map(m => (m.name || '').toLowerCase().trim())
            );
          }
        }

        let added = 0;
        const brandCounts = {};

        for (const product of countertops) {
          if (!product.name || !product.primaryImage) continue;
          if (!product.primaryImage.startsWith('http')) continue;

          // Map type to category
          const category = TYPE_CATEGORY_MAP[product.type];
          if (!category) continue;

          // Ensure category exists
          if (!MATERIALS[category]) MATERIALS[category] = [];
          if (!existingNames[category]) existingNames[category] = new Set();

          // Deduplicate by name (case-insensitive)
          const nameKey = product.name.toLowerCase().trim();
          if (existingNames[category].has(nameKey)) {
            // If existing material has no image, update it with the image from countertops.json
            const existing = MATERIALS[category].find(m => (m.name || '').toLowerCase().trim() === nameKey);
            if (existing && (!existing.url || !existing.url.startsWith('http')) && product.primaryImage) {
              existing.url = product.primaryImage;
              existing.source = existing.source ? existing.source + '+countertops.json' : 'countertops.json';
            }
            continue;
          }

          // Map brand slug to display name
          const brandDisplay = BRAND_SLUG_MAP[product.brand] ||
            (product.brand || '').replace(/-/g, ' ').replace(/\b\w/g, c => c.toUpperCase());

          // Map color name to hex
          const colorHex = COLOR_NAME_MAP[product.primaryColor] || '#888888';

          const material = {
            id: `ctjson-${product.slug || product.name.toLowerCase().replace(/[^a-z0-9]+/g, '-')}`,
            name: product.name,
            brand: brandDisplay,
            url: product.primaryImage,
            color: colorHex,
            price: null, // Price comes from stone-pricing.json
            primaryColor: product.primaryColor || '',
            style: product.style || '',
            source: 'countertops.json'
          };

          MATERIALS[category].push(material);
          existingNames[category].add(nameKey);
          added++;

          // Track brand counts
          brandCounts[brandDisplay] = (brandCounts[brandDisplay] || 0) + 1;
        }

        countertopsJsonLoaded = true;
        console.log(`Added ${added} countertops from countertops.json`);
        console.log('By brand:', brandCounts);

        // Merge pricing from stone-pricing into newly added materials
        mergePricingIntoMaterials();

        // Refresh materials panel
        renderMaterials(currentMaterialCategory);

        return added;
      } catch (error) {
        console.warn('Could not load countertops.json:', error);
        return 0;
      }
    }

    /**
     * Merge pricing data from stone-pricing materials into countertops.json materials
     * that were added without prices
     */
    function mergePricingIntoMaterials() {
      for (const category of Object.keys(MATERIALS)) {
        if (!Array.isArray(MATERIALS[category])) continue;

        // Build a price lookup from materials that have prices
        const priceLookup = {};
        MATERIALS[category].forEach(m => {
          if (m.price && m.name) {
            priceLookup[m.name.toLowerCase().trim()] = m.price;
          }
        });

        // Apply prices to materials that are missing them
        MATERIALS[category].forEach(m => {
          if (!m.price && m.name) {
            const key = m.name.toLowerCase().trim();
            if (priceLookup[key]) {
              m.price = priceLookup[key];
            }
          }
        });
      }
    }

    // ===== HELPER: Detect valid image URL (HTTP or relative path) =====
    function hasValidImageUrl(url) {
      if (!url) return false;
      return url.startsWith('http') || url.startsWith('/');
    }

    // ===== LOAD TILE.JSON (466 tiles with images) =====
    let tileJsonLoaded = false;

    async function loadTileJson() {
      if (tileJsonLoaded) return 0;

      try {
        const basePath = window.location.pathname.includes('/tools/room-designer')
          ? '../../data/tile.json'
          : '/data/tile.json';

        const response = await fetch(basePath);
        if (!response.ok) {
          console.warn('tile.json not found at', basePath);
          return 0;
        }

        const data = await response.json();
        const tiles = data.tiles || [];
        console.log(`Loaded tile.json: ${tiles.length} products`);

        // Build existing name set for tile category to avoid duplicates
        if (!MATERIALS.tile) MATERIALS.tile = [];
        const existingNames = new Set(
          MATERIALS.tile.map(m => (m.name || '').toLowerCase().trim())
        );

        let added = 0;
        const brandCounts = {};

        const TILE_BRAND_MAP = {
          'msi': 'MSI',
          'bravo-tile': 'Bravo Tile'
        };

        for (const product of tiles) {
          if (!product.name) continue;
          if (!product.primaryImage && !product.image) continue;

          const imageUrl = product.primaryImage || product.image;
          if (!hasValidImageUrl(imageUrl)) continue;

          const nameKey = product.name.toLowerCase().trim();
          if (existingNames.has(nameKey)) {
            // Backfill image if existing entry lacks one
            const existing = MATERIALS.tile.find(m => (m.name || '').toLowerCase().trim() === nameKey);
            if (existing && !hasValidImageUrl(existing.url) && imageUrl) {
              existing.url = imageUrl;
            }
            continue;
          }

          const brandDisplay = TILE_BRAND_MAP[product.brand] ||
            (product.brand || '').replace(/-/g, ' ').replace(/\b\w/g, c => c.toUpperCase());

          const COLOR_HEX = {
            'White': '#F5F5F5', 'Gray': '#888888', 'Beige': '#D4C5A9',
            'Brown': '#8B6914', 'Black': '#2C2C2C', 'Cream': '#FFFDD0',
            'Gold': '#D4AF37', 'Blue': '#4169E1', 'Green': '#2E8B57',
            'Silver': '#C0C0C0', 'Ivory': '#FFFFF0', 'Multi': '#C0C0C0'
          };

          const material = {
            id: `tile-${product.slug || product.name.toLowerCase().replace(/[^a-z0-9]+/g, '-')}`,
            name: product.name,
            brand: brandDisplay,
            url: imageUrl,
            color: COLOR_HEX[product.primaryColor] || '#888888',
            price: null,
            material: product.material || '',
            tileType: product.type || '',
            subcategory: product.subcategory || '',
            source: 'tile.json'
          };

          MATERIALS.tile.push(material);
          existingNames.add(nameKey);
          added++;
          brandCounts[brandDisplay] = (brandCounts[brandDisplay] || 0) + 1;
        }

        tileJsonLoaded = true;
        console.log(`Added ${added} tiles from tile.json`);
        console.log('Tile brands:', brandCounts);

        return added;
      } catch (error) {
        console.warn('Could not load tile.json:', error);
        return 0;
      }
    }

    // ===== LOAD BRAVO-TILE.JSON (82 products with wholesale pricing) =====
    let bravoTileJsonLoaded = false;

    async function loadBravoTileJson() {
      if (bravoTileJsonLoaded) return 0;

      try {
        const basePath = window.location.pathname.includes('/tools/room-designer')
          ? '../../data/bravo-tile.json'
          : '/data/bravo-tile.json';

        const response = await fetch(basePath);
        if (!response.ok) {
          console.warn('bravo-tile.json not found at', basePath);
          return 0;
        }

        const data = await response.json();
        const products = data.products || [];
        console.log(`Loaded bravo-tile.json: ${products.length} products`);

        if (!MATERIALS.tile) MATERIALS.tile = [];

        // Build lookup of existing tile materials by name for price merging
        const existingByName = {};
        MATERIALS.tile.forEach(m => {
          if (m.name) existingByName[m.name.toLowerCase().trim()] = m;
        });

        let pricesMerged = 0;
        let added = 0;

        for (const product of products) {
          if (!product.name) continue;

          const nameKey = product.name.toLowerCase().trim();
          const existing = existingByName[nameKey];

          if (existing) {
            // Merge wholesale pricing into existing material
            if (product.wholesalePrice && !existing.price) {
              existing.price = product.wholesalePrice;
              existing.unit = product.unit || 'SF';
              pricesMerged++;
            }
            // Merge additional data
            if (product.size && !existing.size) existing.size = product.size;
            if (product.finish && !existing.finish) existing.finish = product.finish;
            if (product.origin && !existing.origin) existing.origin = product.origin;
            // Backfill image if missing
            if (!hasValidImageUrl(existing.url) && hasValidImageUrl(product.primaryImage)) {
              existing.url = product.primaryImage;
            }
          } else {
            // New product not in tile.json  add it
            const imageUrl = product.primaryImage || '';
            const COLOR_HEX = {
              'White': '#F5F5F5', 'Gray': '#888888', 'Beige': '#D4C5A9',
              'Brown': '#8B6914', 'Black': '#2C2C2C', 'Cream': '#FFFDD0',
              'Gold': '#D4AF37', 'Blue': '#4169E1', 'Green': '#2E8B57',
              'Silver': '#C0C0C0', 'Ivory': '#FFFFF0', 'Multi': '#C0C0C0'
            };

            const material = {
              id: `bravo-${product.slug || product.name.toLowerCase().replace(/[^a-z0-9]+/g, '-')}`,
              name: product.name,
              brand: 'Bravo Tile',
              url: imageUrl,
              color: COLOR_HEX[product.primaryColor] || '#888888',
              price: product.wholesalePrice || null,
              unit: product.unit || 'SF',
              size: product.size || '',
              finish: product.finish || '',
              origin: product.origin || '',
              material: product.category || '',
              subcategory: product.subcategory || '',
              source: 'bravo-tile.json'
            };

            MATERIALS.tile.push(material);
            existingByName[nameKey] = material;
            added++;
          }
        }

        bravoTileJsonLoaded = true;
        console.log(`Bravo Tile: merged ${pricesMerged} prices, added ${added} new products`);

        // Refresh panel if showing tile
        if (currentMaterialCategory === 'tile') {
          renderMaterials('tile');
        }

        return pricesMerged + added;
      } catch (error) {
        console.warn('Could not load bravo-tile.json:', error);
        return 0;
      }
    }

    // Load products from Supabase and add to materials
    let supabaseProductsLoaded = false;
    async function loadSupabaseProducts() {
      if (supabaseProductsLoaded) return;

      // Inline config since getSupabaseConfig may not be defined yet
      const SUPABASE_URL = 'https://ypeypgwsycxcagncgdur.supabase.co';
      const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InlwZXlwZ3dzeWN4Y2FnbmNnZHVyIiwicm9sZSI6ImFub24iLCJpYXQiOjE3Njc3NTQ4MjMsImV4cCI6MjA4MzMzMDgyM30.R13pNv2FDtGhfeu7gUcttYNrQAbNYitqR4FIq3O2-ME';

      try {
        // Fetch ALL products (paginate)
        let allProducts = [];
        let offset = 0;
        const limit = 1000;

        while (true) {
          const response = await fetch(
            `${SUPABASE_URL}/rest/v1/shopify_products?select=id,name,handle,vendor,product_type,image_url,price,tags&limit=${limit}&offset=${offset}`,
            {
              headers: {
                'apikey': SUPABASE_ANON_KEY,
                'Authorization': `Bearer ${SUPABASE_ANON_KEY}`
              }
            }
          );

          if (!response.ok) {
            console.warn('Failed to fetch products:', response.status);
            break;
          }

          const products = await response.json();
          allProducts = allProducts.concat(products);

          if (products.length < limit) break;
          offset += limit;
        }

        const withImages = allProducts.filter(p => p.image_url).length;
        console.log(`Fetched ${allProducts.length} products from Supabase (${withImages} with images)`);

        // Categorize and add products
        let countertops = 0, tiles = 0, floors = 0, skippedDupes = 0;

        // Track existing IDs AND NAMES to avoid duplicates across all sources
        const existingIds = {};
        const existingNames = {};
        for (const cat of Object.keys(MATERIALS)) {
          if (Array.isArray(MATERIALS[cat])) {
            existingIds[cat] = new Set(MATERIALS[cat].map(m => m.id));
            existingNames[cat] = new Set(MATERIALS[cat].map(m => (m.name || '').toLowerCase().trim()));
          }
        }

        // Helper: detect tile-like product names
        const isTileName = (n) => /\btile\b|\btiles\b|\bpaver\b|\bpavers\b|\bmosaic\b|\bbacksplash\b|\bsubway\b|\bledger\b|\bmolding\b|\btrim\b|\b\d+x\d+\b/.test(n);

        // Only import Supabase products that are surface materials for the Room Designer
        const allowedTypes = new Set([
          'tile', 'ceramic', 'glass', 'quartz', 'granite', 'marble',
          'travertine', 'quartzite', 'porcelain', 'dekton', 'natural stone',
          'luxury vinyl', 'slate', 'paver', 'limestone', 'trim'
        ]);

        for (const product of allProducts) {
          // Skip products without name or valid image
          if (!product.name || !product.image_url) continue;
          if (product.image_url.includes('placeholder') || !product.image_url.startsWith('http')) continue;

          const type = (product.product_type || '').toLowerCase();
          const name = (product.name || '').toLowerCase();
          const vendor = (product.vendor || '').toLowerCase();

          // Skip non-surface products entirely (sinks, faucets, furniture, etc.)
          if (type && !allowedTypes.has(type) && !type.includes('tile') && !type.includes('floor') && !type.includes('slab') && !type.includes('countertop') && !type.includes('quartz') && !type.includes('granite') && !type.includes('marble')) {
            continue;
          }

          // Determine category based on product_type and vendor
          let category = null;

          // Check vendor first - Bravo Tile products are always tile
          if (vendor.includes('bravo') && vendor.includes('tile')) {
            category = 'tile';
            tiles++;
          }
          // Direct tile types
          else if (type === 'tile' || type === 'ceramic' || type === 'glass' || type === 'slate' || type === 'paver' || type === 'limestone' || type === 'trim') {
            category = 'tile';
            tiles++;
          }
          // Travertine: check if it's a tile or a slab
          else if (type === 'travertine') {
            if (isTileName(name)) { category = 'tile'; tiles++; }
            else { category = 'marble'; countertops++; }
          }
          // Natural stone: check for tile-like names FIRST, then stone categories
          else if (type === 'natural stone') {
            if (isTileName(name)) { category = 'tile'; tiles++; }
            else if (name.includes('marble')) { category = 'marble'; countertops++; }
            else if (name.includes('quartzite')) { category = 'quartzite'; countertops++; }
            else { category = 'granite'; countertops++; }
          }
          // Direct stone types
          else if (type === 'quartz') { category = 'quartz'; countertops++; }
          else if (type === 'granite') { category = 'granite'; countertops++; }
          else if (type === 'marble') { category = 'marble'; countertops++; }
          else if (type === 'quartzite') { category = 'quartzite'; countertops++; }
          else if (type === 'porcelain' || type === 'dekton') { category = 'porcelain'; countertops++; }
          // Flooring: LVP/LVT/Luxury Vinyl
          else if (type === 'luxury vinyl' || type.includes('floor') || name.includes('lvp') || name.includes('lvt') || name.includes('flooring')) {
            category = 'flooring';
            floors++;
          }
          // Fallback tile detection
          else if (type.includes('tile') || isTileName(name)) {
            category = 'tile';
            tiles++;
          }
          // Fallback stone detection
          else if (type.includes('quartz') || type.includes('granite') || type.includes('marble') || type.includes('slab') || type.includes('countertop')) {
            if (name.includes('quartzite')) { category = 'quartzite'; }
            else if (name.includes('marble')) { category = 'marble'; }
            else if (name.includes('granite')) { category = 'granite'; }
            else { category = 'quartz'; }
            countertops++;
          }
          // Skip everything else (sinks, faucets, furniture, etc.)

          if (!category) continue;

          // Create material object
          const matId = `supabase-${product.id}`;
          if (existingIds[category]?.has(matId)) continue;

          // Skip if a material with the same name already exists in this category
          const nameKey = (product.name || '').toLowerCase().trim();
          if (existingNames[category]?.has(nameKey)) {
            // Backfill image if existing entry lacks one
            const existing = MATERIALS[category].find(m => (m.name || '').toLowerCase().trim() === nameKey);
            if (existing && !hasValidImageUrl(existing.url) && product.image_url) {
              existing.url = product.image_url;
            }
            skippedDupes++;
            continue;
          }

          // Don't import Supabase prices for stone categories (they're full-slab prices, not per-sqft)
          const stoneCategories = ['granite', 'quartz', 'quartzite', 'marble', 'porcelain'];
          const skipPrice = stoneCategories.includes(category);

          const material = {
            id: matId,
            name: product.name,
            brand: product.vendor || '',
            url: product.image_url || '',
            price: skipPrice ? null : (product.price || null),
            handle: product.handle || '',
            color: '#888888',
            source: 'supabase'
          };

          if (!MATERIALS[category]) MATERIALS[category] = [];
          if (!existingNames[category]) existingNames[category] = new Set();
          MATERIALS[category].push(material);
          existingIds[category]?.add(matId);
          existingNames[category].add(nameKey);
        }

        supabaseProductsLoaded = true;
        console.log(`Added from Supabase: ${countertops} countertops, ${tiles} tiles, ${floors} flooring (${skippedDupes} name-dupes skipped)`);

        // Refresh materials panel
        renderMaterials(currentMaterialCategory);

        return { countertops, tiles, floors };
      } catch (error) {
        console.warn('Could not load Supabase product images:', error);
        return 0;
      }
    }

    // ===== DISTRIBUTOR MARKETPLACE INTEGRATION =====
    const MARKETPLACE_API_BASE = (window.SG_CONFIG && window.SG_CONFIG.API_BASE)
      ? window.SG_CONFIG.API_BASE
      : 'https://surprise-granite-email-api.onrender.com';

    const MARKETPLACE_ENDPOINTS = {
      products: `${MARKETPLACE_API_BASE}/api/marketplace/products`,
      slabs: `${MARKETPLACE_API_BASE}/api/marketplace/slabs`,
      slabDetail: (id) => `${MARKETPLACE_API_BASE}/api/marketplace/slabs/${id}`,
      slabInquiry: (id) => `${MARKETPLACE_API_BASE}/api/marketplace/slabs/${id}/inquiry`
    };

    // Surface finish options by material group
    const FINISH_OPTIONS = {
      stone: ['Polished', 'Honed', 'Leathered', 'Matte', 'Brushed', 'Flamed', 'Natural'],
      tile:  ['Polished', 'Matte', 'Natural'],
      cabinet: []
    };
    const CATEGORY_FINISH_GROUP = {
      granite: 'stone', quartz: 'stone', marble: 'stone', quartzite: 'stone',
      porcelain: 'tile', tile: 'tile', flooring: 'tile', hardscape: 'stone',
      showerPanels: 'tile', cabinets: 'cabinet', vanities: 'cabinet',
      flooringTrims: 'cabinet', cabinetAccessories: 'cabinet'
    };

    // Map Room Designer categories  API material_type filter values
    const CATEGORY_TO_API_MATERIAL = {
      'granite': 'granite',
      'quartz': 'quartz',
      'marble': 'marble',
      'quartzite': 'quartzite',
      'porcelain': 'porcelain',
      'tile': 'tile',
      'flooring': 'flooring',
      'hardscape': 'hardscape',
      'cabinets': 'cabinets',
      'vanities': 'vanities',
      'showerPanels': 'shower_panels',
      'flooringTrims': 'flooring_trims',
      'cabinetAccessories': 'cabinet_accessories'
    };

    // Cache for distributor products per category
    const distributorCache = {};
    let distributorApiAvailable = null; // null = untested

    function isStale(cacheEntry) {
      if (!cacheEntry?.lastFetched) return true;
      return (Date.now() - cacheEntry.lastFetched) > 5 * 60 * 1000; // 5 minutes
    }

    function getDisplayPrice(material) {
      if (!PRICING_ACCESS.canViewPricing) return null;
      const accountType = PRICING_ACCESS.accountType;
      const isTradeAccount = ['fabricator', 'vendor', 'distributor'].includes(accountType);

      if (material.source?.includes('distributor')) {
        if (isTradeAccount && material.tradePrice) {
          return { amount: material.tradePrice, label: 'Trade' };
        }
        if (material.retailPrice) {
          return { amount: material.retailPrice, label: '' };
        }
      }
      if (material.price) {
        return { amount: material.price, label: '' };
      }
      return null;
    }

    function transformDistributorProduct(product, category, isSlab) {
      const name = isSlab ? (product.product_name || product.name) : product.name;

      // Resolve image URL from images array or primary_image_url
      let resolvedImage = '';
      if (Array.isArray(product.images) && product.images.length > 0) {
        const first = product.images[0];
        resolvedImage = typeof first === 'string' ? first : (first.url || first.src || '');
      }
      if (!resolvedImage) {
        resolvedImage = product.primary_image_url || '';
      }

      const colorHex = (typeof COLOR_NAME_MAP !== 'undefined' && (COLOR_NAME_MAP[product.color_family] || COLOR_NAME_MAP[product.primary_color]))
        || product.color || '#888888';

      const wholesalePrice = isSlab ? product.price_per_sqft : product.wholesale_price;
      const retailPrice = product.retail_price || product.msrp_per_sqft || wholesalePrice;
      const tradePrice = product.trade_price_per_sqft || wholesalePrice;

      return {
        id: `dist-${product.id}`,
        name: name || 'Unknown Product',
        brand: product.brand || (product.distributor?.company_name) || '',
        url: resolvedImage,
        color: colorHex,
        price: wholesalePrice || null,
        retailPrice: retailPrice || null,
        tradePrice: tradePrice || null,
        unit: isSlab ? 'sf' : (product.unit_type || 'sf'),
        sku: product.sku || product.product_sku || '',
        finish: product.finish || '',
        material: product.material_type || '',
        source: 'distributor',
        distributorId: product.distributor_id,
        distributorName: product.distributor?.company_name || '',
        distributorLogo: product.distributor?.logo_url || '',
        productUUID: product.id,
        status: product.status || 'available',
        isFeatured: product.is_featured || false
      };
    }

    async function fetchDistributorProducts(category) {
      const apiMaterialType = CATEGORY_TO_API_MATERIAL[category];
      if (!apiMaterialType) {
        console.log(`No API mapping for category "${category}", skipping fetch`);
        return [];
      }

      // Return cached if fresh
      if (distributorCache[category]?.loaded && !isStale(distributorCache[category])) {
        return distributorCache[category].products;
      }

      // Prevent duplicate concurrent fetches
      if (distributorCache[category]?.loading) {
        return new Promise((resolve) => {
          const check = setInterval(() => {
            if (!distributorCache[category]?.loading) {
              clearInterval(check);
              resolve(distributorCache[category]?.products || []);
            }
          }, 100);
          setTimeout(() => { clearInterval(check); resolve([]); }, 10000);
        });
      }

      distributorCache[category] = { products: [], loaded: false, loading: true, error: null, lastFetched: null };

      try {
        const isSlabCategory = ['granite', 'quartz', 'marble', 'quartzite', 'porcelain'].includes(category);
        const endpoint = isSlabCategory ? MARKETPLACE_ENDPOINTS.slabs : MARKETPLACE_ENDPOINTS.products;

        const params = new URLSearchParams({
          material_type: apiMaterialType,
          limit: '100',
          offset: '0'
        });

        const response = await fetch(`${endpoint}?${params.toString()}`, {
          headers: { 'Content-Type': 'application/json' }
        });

        if (!response.ok) throw new Error(`API returned ${response.status}`);

        const data = await response.json();
        const rawProducts = isSlabCategory ? (data.slabs || []) : (data.products || []);
        const materials = rawProducts.map(p => transformDistributorProduct(p, category, isSlabCategory));

        distributorCache[category] = { products: materials, loaded: true, loading: false, error: null, lastFetched: Date.now() };
        distributorApiAvailable = true;
        console.log(`Loaded ${materials.length} distributor products for ${category}`);
        return materials;
      } catch (error) {
        console.warn(`Could not load distributor products for ${category}:`, error.message);
        distributorCache[category] = { products: [], loaded: false, loading: false, error: error.message, lastFetched: null };
        if (distributorApiAvailable === null) distributorApiAvailable = false;
        return [];
      }
    }

    function mergeDistributorMaterials(category, newMaterials) {
      if (!MATERIALS[category]) MATERIALS[category] = [];

      const existingNames = new Set(MATERIALS[category].map(m => (m.name || '').toLowerCase().trim()));
      const existingIds = new Set(MATERIALS[category].map(m => m.id));
      let added = 0;

      for (const mat of newMaterials) {
        if (existingIds.has(mat.id)) continue;

        const nameKey = (mat.name || '').toLowerCase().trim();
        if (existingNames.has(nameKey)) {
          // Backfill onto existing entry
          const existing = MATERIALS[category].find(m => (m.name || '').toLowerCase().trim() === nameKey);
          if (existing) {
            if (!hasValidImageUrl(existing.url) && hasValidImageUrl(mat.url)) existing.url = mat.url;
            if (!existing.price && mat.price) existing.price = mat.price;
            if (mat.tradePrice) existing.tradePrice = mat.tradePrice;
            if (mat.retailPrice) existing.retailPrice = mat.retailPrice;
            existing.productUUID = mat.productUUID;
            existing.distributorId = mat.distributorId;
            existing.distributorName = mat.distributorName;
            existing.distributorLogo = mat.distributorLogo;
            existing.source = (existing.source || 'static') + '+distributor';
          }
          continue;
        }

        MATERIALS[category].push(mat);
        existingIds.add(mat.id);
        existingNames.add(nameKey);
        added++;
      }
      if (added > 0) console.log(`Added ${added} new distributor materials to ${category}`);
    }

    async function loadDistributorDataForCategory(category) {
      const apiMaterialType = CATEGORY_TO_API_MATERIAL[category];
      if (!apiMaterialType) {
        console.log(`No API mapping for category "${category}", skipping load`);
        return;
      }

      if (distributorCache[category]?.loaded && !isStale(distributorCache[category])) return;

      // Show loading indicator
      const grid = document.getElementById('materialGrid');
      if (grid && !distributorCache[category]?.loaded) {
        const el = document.createElement('div');
        el.id = 'distributor-loading-indicator';
        el.textContent = 'Loading distributor inventory...';
        grid.appendChild(el);
      }

      try {
        const distributorMaterials = await fetchDistributorProducts(category);
        if (distributorMaterials.length > 0) {
          mergeDistributorMaterials(category, distributorMaterials);
          if (currentMaterialCategory === category) {
            renderMaterials(category);
          }
        }
      } catch (err) {
        console.warn('Distributor load failed for', category, err);
      }

      const loadingEl = document.getElementById('distributor-loading-indicator');
      if (loadingEl) loadingEl.remove();
    }

    // Inquiry modal for distributor products
    function showProductInquiryModal(materialId) {
      let material = null;
      for (const cat of Object.keys(MATERIALS)) {
        if (Array.isArray(MATERIALS[cat])) {
          material = MATERIALS[cat].find(m => m.id === materialId);
          if (material) break;
        }
      }
      if (!material || !material.productUUID) {
        showToast('Product inquiry not available for this material', 'info');
        return;
      }

      const user = window.SgAuth?.getUser?.();
      const profile = window.SgAuth?.getProfile?.();
      const displayPrice = getDisplayPrice(material);

      const modalHtml = `
        <div id="inquiryModal" style="position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.6);z-index:10000;display:flex;align-items:center;justify-content:center;" onclick="if(event.target===this)this.remove()">
          <div style="background:#1a1a2e;border:1px solid var(--gold);border-radius:12px;padding:24px;max-width:480px;width:90%;max-height:80vh;overflow-y:auto;">
            <h3 style="color:var(--gold);margin:0 0 12px;">Inquire About ${material.name}</h3>
            ${material.distributorName ? `<p style="font-size:13px;opacity:0.7;margin:0 0 4px;">Available from: ${material.distributorName}</p>` : ''}
            ${displayPrice ? `<p style="font-size:14px;margin:0 0 16px;">Price: $${displayPrice.amount.toFixed(2)}/${material.unit || 'sf'}${displayPrice.label ? ' <span class="material-trade-label">(' + displayPrice.label + ')</span>' : ''}</p>` : '<div style="margin-bottom:16px;"></div>'}
            <form id="inquiryForm" style="display:flex;flex-direction:column;gap:10px;">
              <input type="text" name="name" placeholder="Your Name *" required value="${user?.user_metadata?.full_name || profile?.full_name || ''}" style="padding:8px;border-radius:6px;border:1px solid #444;background:#0f0f23;color:#fff;font-size:14px;">
              <input type="email" name="email" placeholder="Email *" required value="${user?.email || ''}" style="padding:8px;border-radius:6px;border:1px solid #444;background:#0f0f23;color:#fff;font-size:14px;">
              <input type="tel" name="phone" placeholder="Phone" value="${profile?.phone || ''}" style="padding:8px;border-radius:6px;border:1px solid #444;background:#0f0f23;color:#fff;font-size:14px;">
              <input type="text" name="company_name" placeholder="Company Name" value="${profile?.company_name || ''}" style="padding:8px;border-radius:6px;border:1px solid #444;background:#0f0f23;color:#fff;font-size:14px;">
              <textarea name="message" placeholder="Tell us about your project..." rows="3" style="padding:8px;border-radius:6px;border:1px solid #444;background:#0f0f23;color:#fff;font-size:14px;resize:vertical;"></textarea>
              <select name="timeline" style="padding:8px;border-radius:6px;border:1px solid #444;background:#0f0f23;color:#fff;font-size:14px;">
                <option value="">When do you need this?</option>
                <option value="asap">ASAP</option>
                <option value="1_month">Within 1 month</option>
                <option value="1_3_months">1-3 months</option>
                <option value="3_plus_months">3+ months</option>
                <option value="just_browsing">Just browsing</option>
              </select>
              <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:8px;">
                <button type="button" onclick="document.getElementById('inquiryModal').remove();" style="padding:8px 16px;border-radius:6px;border:1px solid #555;background:transparent;color:#fff;cursor:pointer;font-size:14px;">Cancel</button>
                <button type="submit" style="padding:8px 16px;border-radius:6px;border:none;background:var(--gold);color:#000;cursor:pointer;font-weight:bold;font-size:14px;">Send Inquiry</button>
              </div>
            </form>
          </div>
        </div>`;

      document.body.insertAdjacentHTML('beforeend', modalHtml);
      document.getElementById('inquiryForm').addEventListener('submit', async (e) => {
        e.preventDefault();
        await submitProductInquiry(material, e.target);
      });
    }

    async function submitProductInquiry(material, form) {
      const formData = new FormData(form);
      const submitBtn = form.querySelector('button[type="submit"]');
      submitBtn.disabled = true;
      submitBtn.textContent = 'Sending...';

      try {
        const response = await fetch(MARKETPLACE_ENDPOINTS.slabInquiry(material.productUUID), {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            name: formData.get('name'),
            email: formData.get('email'),
            phone: formData.get('phone') || undefined,
            company_name: formData.get('company_name') || undefined,
            inquirer_type: PRICING_ACCESS.accountType || 'homeowner',
            message: formData.get('message') || undefined,
            timeline: formData.get('timeline') || undefined,
            project_type: 'room_designer'
          })
        });

        if (response.ok) {
          showToast('Inquiry sent! The distributor will contact you soon.', 'success');
          document.getElementById('inquiryModal')?.remove();
        } else {
          const err = await response.json().catch(() => ({}));
          throw new Error(err.error || 'Failed to submit inquiry');
        }
      } catch (error) {
        showToast(`Error: ${error.message}`, 'error');
        submitBtn.disabled = false;
        submitBtn.textContent = 'Send Inquiry';
      }
    }

    // Price tier helper for materials
    const PRICE_TIERS = {
      budget: { min: 0, max: 12.60, label: 'Budget-Friendly', color: '#10b981' },
      popular: { min: 12.60, max: 25.90, label: 'Popular Choice', color: '#f59e0b' },
      premium: { min: 25.90, max: 100, label: 'Premium', color: '#8b5cf6' }
    };

    function getMaterialPriceTier(price) {
      if (!price) return null;
      if (price <= PRICE_TIERS.budget.max) return 'budget';
      if (price <= PRICE_TIERS.popular.max) return 'popular';
      return 'premium';
    }

    // ===== CENTRALIZED CORS HANDLING =====
    // Configuration for CORS-friendly domains
    const CORS_CONFIG = {
      // Domains that support CORS natively
      corsFriendly: [
        'cdn.shopify.com',
        'supabase.co',
        'images.weserv.nl',
        'localhost',
        window.location.hostname
      ],
      // Domains that need proxying
      needsProxy: [
        'cdn.msisurfaces.com',
        'cdn.prod.website-files.com',
        'uploads-ssl.webflow.com'
      ],
      // Proxy URL template
      proxyUrl: 'https://images.weserv.nl/?url='
    };

    /**
     * Check if URL needs CORS handling
     */
    function needsCorsHandling(url) {
      if (!url) return false;
      return CORS_CONFIG.corsFriendly.some(domain => url.includes(domain));
    }

    /**
     * Check if URL needs to be proxied for CORS
     */
    function needsProxying(url) {
      if (!url) return false;
      return CORS_CONFIG.needsProxy.some(domain => url.includes(domain));
    }

    /**
     * Get proxied URL for CORS (using images.weserv.nl)
     */
    function getProxiedUrl(url) {
      if (!url) return url;
      if (needsProxying(url)) {
        return `${CORS_CONFIG.proxyUrl}${url.replace('https://', '').replace('http://', '')}`;
      }
      return url;
    }

    /**
     * Centralized image loading with proper CORS handling
     * @param {string} url - Image URL to load
     * @param {function} onLoad - Callback when image loads
     * @param {function} onError - Callback on error
     * @returns {Image} - The image element
     */
    function loadImageWithCors(url, onLoad, onError) {
      const img = new Image();

      // Apply proxy if needed
      const finalUrl = getProxiedUrl(url);

      // Only set crossOrigin for CORS-friendly domains (including proxied ones)
      if (needsCorsHandling(finalUrl) || needsProxying(url)) {
        img.crossOrigin = 'anonymous';
      }

      img.onload = () => {
        if (onLoad) onLoad(img);
      };

      img.onerror = (err) => {
        console.warn('Image load failed:', url, err);
        if (onError) onError(err);
      };

      img.src = finalUrl;
      return img;
    }

    /**
     * Load Three.js texture with proper CORS handling
     * @param {string} url - Texture URL
     * @param {function} onLoad - Callback with texture
     * @param {function} onError - Callback on error
     */
    function loadTextureWithCors(url, onLoad, onError) {
      // Apply proxy if needed
      const finalUrl = getProxiedUrl(url);

      // Check LRU cache first
      const cached = getTextureFromCache(finalUrl);
      if (cached) {
        if (onLoad) onLoad(cached.clone());
        return;
      }

      textureLoader.load(
        finalUrl,
        (texture) => {
          // Cache the loaded texture
          addTextureToCache(finalUrl, texture);
          if (url !== finalUrl) {
            addTextureToCache(url, texture);
          }
          if (onLoad) onLoad(texture);
        },
        undefined,
        (err) => {
          console.warn('Texture load failed:', url, err);
          if (onError) onError(err);
        }
      );
    }

    // Cabinet Catalogs from Manufacturers
    const CABINET_CATALOGS = {
      procraft: {
        name: 'ProCraft Cabinetry',
        logo: 'https://cdn.prod.website-files.com/6456ce4476abb25581fbad0c/6456ce4476abb265e5fbb1f1_62708265be16bc2ec3e69111_procraft-cabinetry-p-500.png',
        series: {
          // Painted Finishes (flat/no grain)
          'shaker-white': { name: 'Shaker White', color: '#f5f5f5', finish: 'painted', grainType: 'flat' },
          'shaker-grey': { name: 'Shaker Grey', color: '#7a7a7a', finish: 'painted', grainType: 'flat' },
          'dove-grey': { name: 'Dove Grey', color: '#b0b0b0', finish: 'painted', grainType: 'flat' },
          'navy-blue': { name: 'Navy Blue', color: '#1e3a5f', finish: 'painted', grainType: 'flat' },
          'sage-green': { name: 'Sage Green', color: '#8fbc8f', finish: 'painted', grainType: 'flat' },
          'onyx-black': { name: 'Onyx Black', color: '#1a1a1a', finish: 'painted', grainType: 'flat' },
          // Wood Grain Finishes - Oak
          'natural-oak': { name: 'Natural Oak', color: '#d4a76a', finish: 'wood-grain', grainType: 'oak' },
          'honey-oak': { name: 'Honey Oak', color: '#c4973d', finish: 'wood-grain', grainType: 'oak' },
          'golden-oak': { name: 'Golden Oak', color: '#bb8b41', finish: 'wood-grain', grainType: 'oak' },
          // Wood Grain Finishes - Maple
          'natural-maple': { name: 'Natural Maple', color: '#f5deb3', finish: 'wood-grain', grainType: 'maple' },
          'honey-maple': { name: 'Honey Maple', color: '#e8c07d', finish: 'wood-grain', grainType: 'maple' },
          // Wood Grain Finishes - Cherry
          'cherry': { name: 'Cherry', color: '#a0522d', finish: 'wood-grain', grainType: 'cherry' },
          'dark-cherry': { name: 'Dark Cherry', color: '#8b2500', finish: 'wood-grain', grainType: 'cherry' },
          // Wood Grain Finishes - Walnut
          'walnut': { name: 'Walnut', color: '#5d4037', finish: 'wood-grain', grainType: 'walnut' },
          'dark-walnut': { name: 'Dark Walnut', color: '#3e2723', finish: 'wood-grain', grainType: 'walnut' },
          'shaker-espresso': { name: 'Espresso', color: '#3d2b1f', finish: 'wood-grain', grainType: 'walnut' },
          // Wood Grain Finishes - Hickory
          'hickory': { name: 'Hickory', color: '#b8860b', finish: 'wood-grain', grainType: 'hickory' },
          'pecan': { name: 'Pecan', color: '#9e7b57', finish: 'wood-grain', grainType: 'hickory' }
        },
        cabinets: {
          base: [
            { sku: 'B09', name: 'Base 9"', width: 0.75, height: 2, depth: 2, type: 'base-cabinet', price: 185 },
            { sku: 'B12', name: 'Base 12"', width: 1, height: 2, depth: 2, type: 'base-cabinet', price: 215 },
            { sku: 'B15', name: 'Base 15"', width: 1.25, height: 2, depth: 2, type: 'base-cabinet', price: 245 },
            { sku: 'B18', name: 'Base 18"', width: 1.5, height: 2, depth: 2, type: 'base-cabinet', price: 275 },
            { sku: 'B21', name: 'Base 21"', width: 1.75, height: 2, depth: 2, type: 'base-cabinet', price: 305 },
            { sku: 'B24', name: 'Base 24"', width: 2, height: 2, depth: 2, type: 'base-cabinet', price: 335 },
            { sku: 'B27', name: 'Base 27"', width: 2.25, height: 2, depth: 2, type: 'base-cabinet', price: 365 },
            { sku: 'B30', name: 'Base 30"', width: 2.5, height: 2, depth: 2, type: 'base-cabinet', price: 395 },
            { sku: 'B33', name: 'Base 33"', width: 2.75, height: 2, depth: 2, type: 'base-cabinet', price: 425 },
            { sku: 'B36', name: 'Base 36"', width: 3, height: 2, depth: 2, type: 'base-cabinet', price: 455 },
            { sku: 'B42', name: 'Base 42"', width: 3.5, height: 2, depth: 2, type: 'base-cabinet', price: 515 },
            { sku: 'B48', name: 'Base 48"', width: 4, height: 2, depth: 2, type: 'base-cabinet', price: 575 }
          ],
          wall: [
            { sku: 'W0930', name: 'Wall 9"x30"', width: 0.75, height: 1.25, depth: 2.5, type: 'wall-cabinet', price: 145 },
            { sku: 'W1230', name: 'Wall 12"x30"', width: 1, height: 1.25, depth: 2.5, type: 'wall-cabinet', price: 165 },
            { sku: 'W1530', name: 'Wall 15"x30"', width: 1.25, height: 1.25, depth: 2.5, type: 'wall-cabinet', price: 185 },
            { sku: 'W1830', name: 'Wall 18"x30"', width: 1.5, height: 1.25, depth: 2.5, type: 'wall-cabinet', price: 205 },
            { sku: 'W2130', name: 'Wall 21"x30"', width: 1.75, height: 1.25, depth: 2.5, type: 'wall-cabinet', price: 225 },
            { sku: 'W2430', name: 'Wall 24"x30"', width: 2, height: 1.25, depth: 2.5, type: 'wall-cabinet', price: 245 },
            { sku: 'W3030', name: 'Wall 30"x30"', width: 2.5, height: 1.25, depth: 2.5, type: 'wall-cabinet', price: 285 },
            { sku: 'W3630', name: 'Wall 36"x30"', width: 3, height: 1.25, depth: 2.5, type: 'wall-cabinet', price: 325 },
            { sku: 'W0936', name: 'Wall 9"x36"', width: 0.75, height: 1.25, depth: 3, type: 'wall-cabinet', price: 165 },
            { sku: 'W1236', name: 'Wall 12"x36"', width: 1, height: 1.25, depth: 3, type: 'wall-cabinet', price: 185 },
            { sku: 'W1536', name: 'Wall 15"x36"', width: 1.25, height: 1.25, depth: 3, type: 'wall-cabinet', price: 215 },
            { sku: 'W1836', name: 'Wall 18"x36"', width: 1.5, height: 1.25, depth: 3, type: 'wall-cabinet', price: 245 },
            { sku: 'W2436', name: 'Wall 24"x36"', width: 2, height: 1.25, depth: 3, type: 'wall-cabinet', price: 285 },
            { sku: 'W3036', name: 'Wall 30"x36"', width: 2.5, height: 1.25, depth: 3, type: 'wall-cabinet', price: 335 },
            { sku: 'W3636', name: 'Wall 36"x36"', width: 3, height: 1.25, depth: 3, type: 'wall-cabinet', price: 385 },
            { sku: 'W0942', name: 'Wall 9"x42"', width: 0.75, height: 1.25, depth: 3.5, type: 'wall-cabinet', price: 185 },
            { sku: 'W1242', name: 'Wall 12"x42"', width: 1, height: 1.25, depth: 3.5, type: 'wall-cabinet', price: 215 },
            { sku: 'W1842', name: 'Wall 18"x42"', width: 1.5, height: 1.25, depth: 3.5, type: 'wall-cabinet', price: 275 },
            { sku: 'W2442', name: 'Wall 24"x42"', width: 2, height: 1.25, depth: 3.5, type: 'wall-cabinet', price: 325 },
            { sku: 'W3042', name: 'Wall 30"x42"', width: 2.5, height: 1.25, depth: 3.5, type: 'wall-cabinet', price: 385 },
            { sku: 'W3642', name: 'Wall 36"x42"', width: 3, height: 1.25, depth: 3.5, type: 'wall-cabinet', price: 445 }
          ],
          tall: [
            { sku: 'T189024', name: 'Pantry 18"x90"', width: 1.5, height: 2, depth: 7.5, type: 'tall-cabinet', price: 685 },
            { sku: 'T249024', name: 'Pantry 24"x90"', width: 2, height: 2, depth: 7.5, type: 'tall-cabinet', price: 795 },
            { sku: 'T309024', name: 'Pantry 30"x90"', width: 2.5, height: 2, depth: 7.5, type: 'tall-cabinet', price: 895 },
            { sku: 'T369024', name: 'Pantry 36"x90"', width: 3, height: 2, depth: 7.5, type: 'tall-cabinet', price: 995 },
            { sku: 'OC3390', name: 'Oven Cabinet 33"x90"', width: 2.75, height: 2, depth: 7.5, type: 'tall-cabinet', price: 945 },
            { sku: 'OC3396', name: 'Oven Cabinet 33"x96"', width: 2.75, height: 2, depth: 8, type: 'tall-cabinet', price: 1045 }
          ],
          corner: [
            { sku: 'DERA36', name: 'Diagonal Corner 36"', width: 3, height: 3, depth: 2, type: 'corner-cabinet', price: 545 },
            { sku: 'WDC2430', name: 'Diagonal Wall 24"x30"', width: 2, height: 2, depth: 2.5, type: 'corner-cabinet', price: 385 },
            { sku: 'WDC2436', name: 'Diagonal Wall 24"x36"', width: 2, height: 2, depth: 3, type: 'corner-cabinet', price: 425 },
            { sku: 'WDC2442', name: 'Diagonal Wall 24"x42"', width: 2, height: 2, depth: 3.5, type: 'corner-cabinet', price: 465 }
          ],
          lazySusan: [
            { sku: 'BLS33', name: 'Lazy Susan 33"', width: 2.75, height: 2.75, depth: 2, type: 'lazy-susan', price: 595 },
            { sku: 'BLS36', name: 'Lazy Susan 36"', width: 3, height: 3, depth: 2, type: 'lazy-susan', price: 645 },
            { sku: 'BLS39', name: 'Lazy Susan 39"', width: 3.25, height: 3.25, depth: 2, type: 'lazy-susan', price: 695 }
          ],
          sink: [
            { sku: 'SB30', name: 'Sink Base 30"', width: 2.5, height: 2, depth: 2, type: 'sink-base', price: 365 },
            { sku: 'SB33', name: 'Sink Base 33"', width: 2.75, height: 2, depth: 2, type: 'sink-base', price: 395 },
            { sku: 'SB36', name: 'Sink Base 36"', width: 3, height: 2, depth: 2, type: 'sink-base', price: 425 },
            { sku: 'SB42', name: 'Sink Base 42"', width: 3.5, height: 2, depth: 2, type: 'sink-base', price: 485 }
          ],
          drawer: [
            { sku: 'DB12', name: 'Drawer Base 12"', width: 1, height: 2, depth: 2, type: 'drawer-base', price: 295 },
            { sku: 'DB15', name: 'Drawer Base 15"', width: 1.25, height: 2, depth: 2, type: 'drawer-base', price: 335 },
            { sku: 'DB18', name: 'Drawer Base 18"', width: 1.5, height: 2, depth: 2, type: 'drawer-base', price: 375 },
            { sku: 'DB24', name: 'Drawer Base 24"', width: 2, height: 2, depth: 2, type: 'drawer-base', price: 425 },
            { sku: 'DB30', name: 'Drawer Base 30"', width: 2.5, height: 2, depth: 2, type: 'drawer-base', price: 485 },
            { sku: 'DB36', name: 'Drawer Base 36"', width: 3, height: 2, depth: 2, type: 'drawer-base', price: 545 }
          ]
        }
      },
      msi: {
        name: 'MSI Cabinetry',
        logo: null,
        series: {
          // Painted/Laminate Finishes (flat/no grain)
          'euro-white': { name: 'Euro White', color: '#ffffff', finish: 'matte', grainType: 'flat' },
          'euro-grey': { name: 'Euro Grey', color: '#6a6a6a', finish: 'matte', grainType: 'flat' },
          'shaker-dove': { name: 'Shaker Dove', color: '#d3d3d3', finish: 'painted', grainType: 'flat' },
          'shaker-graphite': { name: 'Shaker Graphite', color: '#4a4a4a', finish: 'painted', grainType: 'flat' },
          'charcoal': { name: 'Charcoal', color: '#36454f', finish: 'painted', grainType: 'flat' },
          'midnight-black': { name: 'Midnight Black', color: '#121212', finish: 'gloss', grainType: 'flat' },
          // Wood Grain Finishes - Oak
          'natural-oak': { name: 'Natural Oak', color: '#d4a76a', finish: 'wood-grain', grainType: 'oak' },
          'light-oak': { name: 'Light Oak', color: '#e0c8a0', finish: 'wood-grain', grainType: 'oak' },
          'autumn-oak': { name: 'Autumn Oak', color: '#c78b4a', finish: 'wood-grain', grainType: 'oak' },
          // Wood Grain Finishes - Hickory/Rustic
          'driftwood': { name: 'Driftwood', color: '#9e8b7d', finish: 'wood-grain', grainType: 'hickory' },
          'barnwood': { name: 'Barnwood', color: '#6b5344', finish: 'wood-grain', grainType: 'hickory' },
          // Wood Grain Finishes - Walnut
          'rustic-walnut': { name: 'Rustic Walnut', color: '#5d4037', finish: 'wood-grain', grainType: 'walnut' },
          'java': { name: 'Java', color: '#3d2b1f', finish: 'wood-grain', grainType: 'walnut' },
          'toffee': { name: 'Toffee', color: '#8b7355', finish: 'wood-grain', grainType: 'walnut' },
          // Wood Grain Finishes - Cherry
          'chestnut': { name: 'Chestnut', color: '#7b3f00', finish: 'wood-grain', grainType: 'cherry' }
        },
        cabinets: {
          base: [
            { sku: 'MSI-B12', name: 'Base 12"', width: 1, height: 2, depth: 2, type: 'base-cabinet', price: 189 },
            { sku: 'MSI-B15', name: 'Base 15"', width: 1.25, height: 2, depth: 2, type: 'base-cabinet', price: 219 },
            { sku: 'MSI-B18', name: 'Base 18"', width: 1.5, height: 2, depth: 2, type: 'base-cabinet', price: 249 },
            { sku: 'MSI-B21', name: 'Base 21"', width: 1.75, height: 2, depth: 2, type: 'base-cabinet', price: 279 },
            { sku: 'MSI-B24', name: 'Base 24"', width: 2, height: 2, depth: 2, type: 'base-cabinet', price: 309 },
            { sku: 'MSI-B27', name: 'Base 27"', width: 2.25, height: 2, depth: 2, type: 'base-cabinet', price: 339 },
            { sku: 'MSI-B30', name: 'Base 30"', width: 2.5, height: 2, depth: 2, type: 'base-cabinet', price: 369 },
            { sku: 'MSI-B33', name: 'Base 33"', width: 2.75, height: 2, depth: 2, type: 'base-cabinet', price: 399 },
            { sku: 'MSI-B36', name: 'Base 36"', width: 3, height: 2, depth: 2, type: 'base-cabinet', price: 429 }
          ],
          wall: [
            { sku: 'MSI-W1230', name: 'Wall 12"x30"', width: 1, height: 1.25, depth: 2.5, type: 'wall-cabinet', price: 149 },
            { sku: 'MSI-W1530', name: 'Wall 15"x30"', width: 1.25, height: 1.25, depth: 2.5, type: 'wall-cabinet', price: 169 },
            { sku: 'MSI-W1830', name: 'Wall 18"x30"', width: 1.5, height: 1.25, depth: 2.5, type: 'wall-cabinet', price: 189 },
            { sku: 'MSI-W2430', name: 'Wall 24"x30"', width: 2, height: 1.25, depth: 2.5, type: 'wall-cabinet', price: 229 },
            { sku: 'MSI-W3030', name: 'Wall 30"x30"', width: 2.5, height: 1.25, depth: 2.5, type: 'wall-cabinet', price: 269 },
            { sku: 'MSI-W3630', name: 'Wall 36"x30"', width: 3, height: 1.25, depth: 2.5, type: 'wall-cabinet', price: 309 },
            { sku: 'MSI-W1236', name: 'Wall 12"x36"', width: 1, height: 1.25, depth: 3, type: 'wall-cabinet', price: 169 },
            { sku: 'MSI-W1536', name: 'Wall 15"x36"', width: 1.25, height: 1.25, depth: 3, type: 'wall-cabinet', price: 199 },
            { sku: 'MSI-W1836', name: 'Wall 18"x36"', width: 1.5, height: 1.25, depth: 3, type: 'wall-cabinet', price: 229 },
            { sku: 'MSI-W2436', name: 'Wall 24"x36"', width: 2, height: 1.25, depth: 3, type: 'wall-cabinet', price: 269 },
            { sku: 'MSI-W3036', name: 'Wall 30"x36"', width: 2.5, height: 1.25, depth: 3, type: 'wall-cabinet', price: 319 },
            { sku: 'MSI-W3636', name: 'Wall 36"x36"', width: 3, height: 1.25, depth: 3, type: 'wall-cabinet', price: 369 }
          ],
          tall: [
            { sku: 'MSI-T1890', name: 'Pantry 18"x90"', width: 1.5, height: 2, depth: 7.5, type: 'tall-cabinet', price: 649 },
            { sku: 'MSI-T2490', name: 'Pantry 24"x90"', width: 2, height: 2, depth: 7.5, type: 'tall-cabinet', price: 749 },
            { sku: 'MSI-T3090', name: 'Pantry 30"x90"', width: 2.5, height: 2, depth: 7.5, type: 'tall-cabinet', price: 849 }
          ],
          corner: [
            { sku: 'MSI-BC36', name: 'Base Corner 36"', width: 3, height: 3, depth: 2, type: 'corner-cabinet', price: 495 },
            { sku: 'MSI-WC24', name: 'Wall Corner 24"', width: 2, height: 2, depth: 2.5, type: 'corner-cabinet', price: 359 }
          ],
          sink: [
            { sku: 'MSI-SB30', name: 'Sink Base 30"', width: 2.5, height: 2, depth: 2, type: 'sink-base', price: 339 },
            { sku: 'MSI-SB33', name: 'Sink Base 33"', width: 2.75, height: 2, depth: 2, type: 'sink-base', price: 369 },
            { sku: 'MSI-SB36', name: 'Sink Base 36"', width: 3, height: 2, depth: 2, type: 'sink-base', price: 399 }
          ],
          drawer: [
            { sku: 'MSI-DB12', name: 'Drawer Base 12"', width: 1, height: 2, depth: 2, type: 'drawer-base', price: 269 },
            { sku: 'MSI-DB15', name: 'Drawer Base 15"', width: 1.25, height: 2, depth: 2, type: 'drawer-base', price: 309 },
            { sku: 'MSI-DB18', name: 'Drawer Base 18"', width: 1.5, height: 2, depth: 2, type: 'drawer-base', price: 349 },
            { sku: 'MSI-DB24', name: 'Drawer Base 24"', width: 2, height: 2, depth: 2, type: 'drawer-base', price: 399 }
          ]
        }
      },
      custom: {
        name: 'Custom Cabinets',
        logo: null,
        series: {},
        cabinets: {
          imported: [] // User-uploaded cabinet list
        }
      }
    };

    let currentCatalog = 'procraft';
    let currentCabinetCategory = 'base';
    let currentCabinetSeries = 'shaker-white';

    // ===== STATE =====
    let canvas, ctx;
    let currentTool = 'select';
    let currentView = '2d';
    let zoom = 1;
    let pixelsPerFoot = 40;
    let elements = [];
    let walls = [];
    let selectedElement = null;
    let isDragging = false;
    let dragOffset = { x: 0, y: 0 };
    let autoRotationApplied = false; // Track if auto-rotation was applied during this drag
    let lastSnappedWall = null; // Track which wall we last snapped to

    // Element locking (simple grouping)
    let nextGroupId = 1;

    // Element cycling state - for cycling through overlapping elements
    let lastClickPos = { x: 0, y: 0 };
    let lastClickTime = 0;
    let cycleIndex = 0;
    const CLICK_CYCLE_THRESHOLD = 20; // pixels - how close clicks need to be to cycle
    const CLICK_CYCLE_TIME = 1000; // ms - max time between clicks to cycle

    // Resize state
    let isResizing = false;
    let resizeHandle = null; // 'nw', 'n', 'ne', 'e', 'se', 's', 'sw', 'w'
    let resizeStart = { x: 0, y: 0, width: 0, height: 0, elX: 0, elY: 0 };
    const HANDLE_SIZE = 10;

    let roomWidth = 20;
    let roomDepth = 16;
    let roomHeight = 8; // Ceiling height in feet (8', 9', 10', 12')
    let currentFloorPlan = 'empty';
    let contextMenuElement = null;
    let elementTextures = {}; // Store custom textures for element types
    let customMaterials = []; // User uploaded materials

    // Multi-room support
    let rooms = [];
    let currentRoomId = null;

    // Initialize default room
    function initializeRooms() {
      if (rooms.length === 0) {
        rooms.push({
          id: 'room-' + Date.now(),
          name: 'Kitchen',
          type: 'kitchen',
          width: roomWidth,
          depth: roomDepth,
          offsetX: 0,  // Position in multi-room layout
          offsetY: 0,
          elements: [],
          walls: [],
          floorPlan: 'empty'
        });
        currentRoomId = rooms[0].id;
      }
    }

    // ===== POSITION SERIALIZATION (feet-based) =====
    // Store positions in feet so they're stable across viewport sizes and rooms
    function serializeElement(el) {
      return {
        ...el,
        textureImg: null,
        xFt: (el.x || 0) / (pixelsPerFoot || 40),
        yFt: (el.y || 0) / (pixelsPerFoot || 40)
      };
    }

    function serializeWall(wall) {
      const ppf = pixelsPerFoot || 40;
      return {
        ...wall,
        x1Ft: wall.x1 !== undefined ? wall.x1 / ppf : undefined,
        y1Ft: wall.y1 !== undefined ? wall.y1 / ppf : undefined,
        x2Ft: wall.x2 !== undefined ? wall.x2 / ppf : undefined,
        y2Ft: wall.y2 !== undefined ? wall.y2 / ppf : undefined
      };
    }

    function deserializeElement(el, savedPixelsPerFoot) {
      if (el.xFt !== undefined && el.yFt !== undefined) {
        // New format: feet-based  multiply by current scale
        el.x = el.xFt * pixelsPerFoot;
        el.y = el.yFt * pixelsPerFoot;
      } else if (savedPixelsPerFoot && savedPixelsPerFoot !== pixelsPerFoot && savedPixelsPerFoot > 0) {
        // Legacy format: pixel-based  scale ratio conversion
        const ratio = pixelsPerFoot / savedPixelsPerFoot;
        el.x = (el.x || 0) * ratio;
        el.y = (el.y || 0) * ratio;
      }
      return el;
    }

    function deserializeWall(wall, savedPixelsPerFoot) {
      if (wall.x1Ft !== undefined) {
        wall.x1 = wall.x1Ft * pixelsPerFoot;
        wall.y1 = wall.y1Ft * pixelsPerFoot;
        wall.x2 = wall.x2Ft * pixelsPerFoot;
        wall.y2 = wall.y2Ft * pixelsPerFoot;
      } else if (savedPixelsPerFoot && savedPixelsPerFoot !== pixelsPerFoot && savedPixelsPerFoot > 0) {
        const ratio = pixelsPerFoot / savedPixelsPerFoot;
        if (wall.x1 !== undefined) wall.x1 *= ratio;
        if (wall.y1 !== undefined) wall.y1 *= ratio;
        if (wall.x2 !== undefined) wall.x2 *= ratio;
        if (wall.y2 !== undefined) wall.y2 *= ratio;
      }
      return wall;
    }

    // Get current room object
    function getCurrentRoom() {
      return rooms.find(r => r.id === currentRoomId) || rooms[0];
    }

    // Save current room state before switching
    function saveCurrentRoomState() {
      const room = getCurrentRoom();
      if (room) {
        room.width = roomWidth;
        room.depth = roomDepth;
        // Deep copy with feet-based positions for stable storage
        room.elements = elements.map(el => serializeElement(el));
        room.walls = walls.map(w => serializeWall(w));
        room.floorPlan = currentFloorPlan;
        room.pixelsPerFoot = pixelsPerFoot;
      }
    }

    // Switch to a different room
    function switchToRoom(roomId) {
      saveCurrentRoomState();

      const room = rooms.find(r => r.id === roomId);
      if (!room) return;

      currentRoomId = roomId;
      roomWidth = room.width;
      roomDepth = room.depth;
      currentFloorPlan = room.floorPlan || 'empty';

      // Update UI
      document.getElementById('roomWidth').value = roomWidth;
      document.getElementById('roomDepth').value = roomDepth;
      document.getElementById('roomType').value = room.type || 'kitchen';

      // Recalculate scale for new room dimensions BEFORE deserializing
      const savedScale = room.pixelsPerFoot || pixelsPerFoot;
      fitToScreen();

      // Deep copy + deserialize from feet-based positions
      elements = (room.elements || []).map(el => {
        const copy = { ...el, textureImg: el.textureImg || null };
        return deserializeElement(copy, savedScale);
      });
      walls = (room.walls || []).map(w => {
        const copy = { ...w };
        return deserializeWall(copy, savedScale);
      });

      // Redraw
      draw();
      updateRoomList();
      calculateQuote();

      // Rebuild 3D if in 3D view
      if (currentView === '3d') {
        init3D();
        render3D();
      }

      showToast(`Switched to ${room.name}`, 'info');
    }

    // Add a new room
    function addNewRoom(name, type, width, depth) {
      saveCurrentRoomState();

      // Calculate position for new room (to the right of existing rooms)
      let maxX = 0;
      rooms.forEach(r => {
        const rightEdge = r.offsetX + r.width;
        if (rightEdge > maxX) maxX = rightEdge;
      });

      const newRoom = {
        id: 'room-' + Date.now(),
        name: name || `Room ${rooms.length + 1}`,
        type: type || 'kitchen',
        width: width || 12,
        depth: depth || 10,
        offsetX: maxX + 2,  // 2ft gap between rooms
        offsetY: 0,
        elements: [],
        walls: [],
        floorPlan: 'empty'
      };

      rooms.push(newRoom);
      switchToRoom(newRoom.id);

      return newRoom;
    }

    // Delete a room (legacy multi-room system)
    function deleteRoomLegacy(roomId) {
      if (rooms.length <= 1) {
        showToast('Cannot delete the only room', 'error');
        return;
      }

      const index = rooms.findIndex(r => r.id === roomId);
      if (index === -1) return;

      const roomName = rooms[index].name;
      rooms.splice(index, 1);

      // If deleted current room, switch to first room
      if (currentRoomId === roomId) {
        switchToRoom(rooms[0].id);
      }

      updateRoomList();
      showToast(`Deleted ${roomName}`, 'info');
    }

    // Update room list UI
    function updateRoomList() {
      const container = document.getElementById('roomList');
      if (!container) return;

      container.innerHTML = rooms.map(room => `
        <div class="room-item ${room.id === currentRoomId ? 'active' : ''}" onclick="switchToRoom('${room.id}')">
          <span class="room-icon">${room.type === 'kitchen' ? '' : room.type === 'bathroom' ? '' : ''}</span>
          <span class="room-name" ondblclick="event.stopPropagation(); renameRoom('${room.id}')" title="Double-click to rename">${room.name}</span>
          <span class="room-size">${room.width}'${room.depth}'</span>
          <button class="room-edit-btn" onclick="event.stopPropagation(); renameRoom('${room.id}')" title="Rename room"></button>
          ${rooms.length > 1 ? `<button class="room-delete-btn" onclick="event.stopPropagation(); deleteRoomLegacy('${room.id}')" title="Delete room"></button>` : ''}
        </div>
      `).join('');
    }

    // Rename a room
    function renameRoom(roomId) {
      const room = rooms.find(r => r.id === roomId);
      if (!room) return;

      const newName = prompt('Enter new room name:', room.name);
      if (newName && newName.trim()) {
        room.name = newName.trim();
        updateRoomList();
        showToast(`Room renamed to "${room.name}"`, 'success');
      }
    }

    window.renameRoom = renameRoom;

    // Show add room modal
    function showAddRoomModal() {
      const modal = document.getElementById('addRoomModal');
      if (modal) {
        // Prefill defaults
        const nameInput = document.getElementById('addRoomName');
        if (nameInput) nameInput.value = `Room ${rooms.length + 1}`;
        openModal('addRoomModal');
      } else {
        // Simple prompt fallback
        const name = prompt('Room name:', `Room ${rooms.length + 1}`);
        if (name) {
          const type = prompt('Room type (kitchen, bathroom, laundry, other):', 'kitchen');
          const width = parseInt(prompt('Room width (feet):', '12')) || 12;
          const depth = parseInt(prompt('Room depth (feet):', '10')) || 10;
          addNewRoom(name, type, width, depth);
        }
      }
    }

    function submitAddRoom() {
      const name = document.getElementById('addRoomName').value.trim() || `Room ${rooms.length + 1}`;
      const type = document.getElementById('addRoomType').value || 'kitchen';
      const width = parseInt(document.getElementById('addRoomWidth').value) || 12;
      const depth = parseInt(document.getElementById('addRoomDepth').value) || 10;
      closeModal('addRoomModal');
      addNewRoom(name, type, width, depth);
    }

    // Make functions globally accessible
    window.switchToRoom = switchToRoom;
    window.addNewRoom = addNewRoom;
    window.deleteRoomLegacy = deleteRoomLegacy;
    window.showAddRoomModal = showAddRoomModal;
    window.updateRoomList = updateRoomList;

    // View all rooms in 3D (multi-room layout)
    let viewingAllRooms = false;

    function viewAllRooms3D() {
      saveCurrentRoomState();
      viewingAllRooms = true;

      // Switch to 3D view
      setView('3d');

      // Rebuild 3D scene with all rooms
      setTimeout(() => {
        init3DMultiRoom();
        showToast('Viewing all rooms - click a room to edit', 'info');
      }, 100);
    }

    // Initialize 3D scene with all rooms
    function init3DMultiRoom() {
      if (!window.THREE) {
        console.error('Three.js not loaded');
        return;
      }

      const container = document.getElementById('view3D');
      if (!container) return;

      // Clear existing scene
      container.innerHTML = '';

      // Calculate total layout dimensions
      let totalWidth = 0;
      let totalDepth = 0;
      rooms.forEach(room => {
        const rightEdge = room.offsetX + room.width;
        const bottomEdge = room.offsetY + room.depth;
        if (rightEdge > totalWidth) totalWidth = rightEdge;
        if (bottomEdge > totalDepth) totalDepth = bottomEdge;
      });

      // Create scene
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x1a1a2e);

      // Create camera with view of entire layout
      const camera = new THREE.PerspectiveCamera(
        60,
        container.clientWidth / container.clientHeight,
        0.1,
        1000
      );
      camera.position.set(totalWidth / 2, Math.max(totalWidth, totalDepth) * 1.5, totalDepth * 1.5);
      camera.lookAt(totalWidth / 2, 0, totalDepth / 2);

      // Create renderer with enhanced quality
      const renderer = new THREE.WebGLRenderer({
        antialias: true,
        powerPreference: 'high-performance',
        alpha: false
      });
      renderer.setSize(container.clientWidth, container.clientHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      renderer.outputEncoding = THREE.sRGBEncoding;
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 1.2;
      container.appendChild(renderer.domElement);

      // Add controls
      const controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.target.set(totalWidth / 2, 0, totalDepth / 2);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.update();

      // Enhanced Lighting for clarity
      // Hemisphere light for natural sky/ground ambient
      const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.4);
      hemiLight.position.set(0, 20, 0);
      scene.add(hemiLight);

      // Main ambient for overall illumination
      const ambient = new THREE.AmbientLight(0xffffff, 0.5);
      scene.add(ambient);

      // Key light (sun) - warm directional
      const sun = new THREE.DirectionalLight(0xFFFBF0, 1.2);
      sun.position.set(totalWidth, 25, totalDepth / 2);
      sun.castShadow = true;
      sun.shadow.mapSize.width = 2048;
      sun.shadow.mapSize.height = 2048;
      sun.shadow.camera.near = 0.5;
      sun.shadow.camera.far = 100;
      sun.shadow.camera.left = -30;
      sun.shadow.camera.right = 30;
      sun.shadow.camera.top = 30;
      sun.shadow.camera.bottom = -30;
      sun.shadow.bias = -0.0001;
      scene.add(sun);

      // Fill light - softer, cooler from opposite side
      const fillLight = new THREE.DirectionalLight(0xE8F0FF, 0.4);
      fillLight.position.set(-totalWidth, 15, totalDepth);
      scene.add(fillLight);

      // Rim light for edge definition
      const rimLight = new THREE.DirectionalLight(0xFFFFFF, 0.3);
      rimLight.position.set(0, 5, -totalDepth);
      scene.add(rimLight);

      // Render each room
      rooms.forEach((room, roomIndex) => {
        const roomGroup = new THREE.Group();
        roomGroup.position.set(room.offsetX, 0, room.offsetY);
        roomGroup.userData = { roomId: room.id, roomName: room.name };

        // Floor
        const floorGeo = new THREE.PlaneGeometry(room.width, room.depth);
        const floorMat = new THREE.MeshStandardMaterial({
          color: roomIndex === rooms.findIndex(r => r.id === currentRoomId) ? 0x3a5a8a : 0x2a3a4a,
          side: THREE.DoubleSide
        });
        const floor = new THREE.Mesh(floorGeo, floorMat);
        floor.rotation.x = -Math.PI / 2;
        floor.position.set(room.width / 2, 0, room.depth / 2);
        floor.receiveShadow = true;
        roomGroup.add(floor);

        // Room label
        const canvas = document.createElement('canvas');
        canvas.width = 256;
        canvas.height = 64;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = '#f9cb00';
        ctx.font = 'bold 24px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(room.name, 128, 40);

        const labelTexture = new THREE.CanvasTexture(canvas);
        const labelGeo = new THREE.PlaneGeometry(4, 1);
        const labelMat = new THREE.MeshBasicMaterial({ map: labelTexture, transparent: true });
        const label = new THREE.Mesh(labelGeo, labelMat);
        label.position.set(room.width / 2, 0.1, room.depth / 2);
        label.rotation.x = -Math.PI / 2;
        roomGroup.add(label);

        // Walls (outline)
        const wallHeight = room.height || roomHeight || 8;
        const wallMat = new THREE.MeshStandardMaterial({ color: 0x555555, transparent: true, opacity: 0.3 });

        // Back wall
        const backWall = new THREE.Mesh(new THREE.BoxGeometry(room.width, wallHeight, 0.3), wallMat);
        backWall.position.set(room.width / 2, wallHeight / 2, 0.15);
        roomGroup.add(backWall);

        // Left wall
        const leftWall = new THREE.Mesh(new THREE.BoxGeometry(0.3, wallHeight, room.depth), wallMat);
        leftWall.position.set(0.15, wallHeight / 2, room.depth / 2);
        roomGroup.add(leftWall);

        // Render elements for this room
        if (room.elements && room.elements.length > 0) {
          room.elements.forEach(el => {
            const elMesh = createSimple3DElement(el);
            if (elMesh) {
              // Convert 2D position to 3D
              const x3d = (el.x / pixelsPerFoot);
              const z3d = (el.y / pixelsPerFoot);
              elMesh.position.set(x3d + el.width / 2, 0, z3d + el.height / 2);
              roomGroup.add(elMesh);
            }
          });
        }

        scene.add(roomGroup);
      });

      // Animation loop
      function animate() {
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
      }
      animate();

      // Handle resize
      window.addEventListener('resize', () => {
        camera.aspect = container.clientWidth / container.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(container.clientWidth, container.clientHeight);
      });
    }

    // Create simplified 3D element for multi-room view
    function createSimple3DElement(el) {
      if (!window.THREE) return null;

      const w = el.width;
      const d = el.height;
      let h = 2.5; // default height

      // Adjust height based on type
      if (el.type.includes('tall')) h = 7;
      else if (el.type.includes('wall-cabinet')) h = 2.5;
      else if (el.type.includes('cabinet')) h = 2.9;
      else if (el.type === 'countertop') h = 0.1;
      else if (el.type === 'sink' || el.type === 'stove') h = 0.5;
      else if (el.type === 'refrigerator') h = 5.5;

      const color = new THREE.Color(el.color || '#808080');
      const geometry = new THREE.BoxGeometry(w, h, d);
      const material = new THREE.MeshStandardMaterial({ color: color });
      const mesh = new THREE.Mesh(geometry, material);
      mesh.castShadow = true;
      mesh.position.y = h / 2;

      return mesh;
    }

    // Export multi-room layout
    function exportMultiRoomLayout() {
      saveCurrentRoomState();

      const layoutData = {
        version: '1.0',
        projectName: document.getElementById('projectName').value || 'Multi-Room Design',
        createdAt: new Date().toISOString(),
        rooms: rooms.map(room => ({
          ...room,
          elements: room.elements.map(el => ({ ...el, textureImg: null }))
        })),
        currentRoomId: currentRoomId
      };

      const blob = new Blob([JSON.stringify(layoutData, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `multi-room-layout-${Date.now()}.json`;
      a.click();
      URL.revokeObjectURL(url);

      showToast('Layout exported successfully', 'success');
    }

    window.viewAllRooms3D = viewAllRooms3D;
    window.exportMultiRoomLayout = exportMultiRoomLayout;

    // Pan offset (for infinite canvas navigation)
    let panX = 0;
    let panY = 0;
    let isPanning = false;
    let panStart = { x: 0, y: 0 };
    let viewLocked = false; // Lock view to prevent accidental pan/zoom

    // Wall drawing
    let isDrawingWall = false;
    let wallStart = null;

    // Countertop drawing
    let isDrawingCountertop = false;
    let countertopStart = null;

    // Cabinet Settings State
    let cabinetSettings = {
      construction: 'frameless', // 'frameless' or 'framed'
      doorStyle: 'shaker',       // 'shaker', 'shaker-beaded', 'flat', 'raised', 'slab'
      doorOverlay: 'full',       // 'full', 'partial', 'inset'
      cabinetFinish: 'wood-grain', // 'wood-grain', 'painted', 'matte', 'gloss'
      grainType: 'oak',          // 'oak', 'walnut', 'cherry', 'maple', 'hickory', 'flat'
      currentFloor: 1,
      floors: [{ id: 1, name: 'Floor 1', height: 0 }]
    };

    // Environment/Scene settings
    let sceneSettings = {
      timeOfDay: 'noon', // 'morning', 'noon', 'evening', 'night'
      showOutdoorView: true,
      showFrontWall: false, // Show 4th wall (front wall) - useful for enclosed rooms
      wallTransparency: 0.3 // Transparency for front wall when shown
    };

    // Outdoor view colors based on time of day
    const OUTDOOR_COLORS = {
      morning: { sky: 0xFDB813, horizon: 0xFFE4B5, ambient: 0xFFF8DC },
      noon: { sky: 0x87CEEB, horizon: 0xE0F7FA, ambient: 0xFFFFFF },
      evening: { sky: 0xFFA07A, horizon: 0xFFDAB9, ambient: 0xFFE4C4 },
      night: { sky: 0x191970, horizon: 0x2F4F4F, ambient: 0x404040 }
    };

    // Three.js
    let scene, camera, renderer, controls;
    let composer; // Post-processing effect composer
    let animationId = null; // Track animation frame to prevent duplicates
    let postProcessingEnabled = true; // Toggle for post-processing effects

    // ===== INCREMENTAL 3D SCENE UPDATE SYSTEM =====
    // Mesh cache: element ID -> { group: THREE.Group, version: number }
    const meshCache3D = new Map();
    // Element versions: element ID -> version number (incremented on change)
    const elementVersions = new Map();
    // Dirty elements that need 3D update
    const dirtyElements3D = new Set();
    // Flag to force full scene rebuild
    let forceFullRebuild3D = true;
    // Cached room structure
    let cachedRoomStructure = null;
    let cachedRoomDimensions = { width: 0, depth: 0, height: 0 };

    /**
     * Mark an element as needing 3D update
     */
    function markElement3DDirty(elementId) {
      if (elementId) {
        dirtyElements3D.add(elementId);
        // Increment version
        const currentVersion = elementVersions.get(elementId) || 0;
        elementVersions.set(elementId, currentVersion + 1);
      }
    }

    /**
     * Mark all elements as dirty (for full rebuild scenarios)
     */
    function markAllElements3DDirty() {
      elements.forEach(el => markElement3DDirty(el.id));
      forceFullRebuild3D = true;
    }

    /**
     * Remove element from 3D cache and scene
     */
    function removeElement3D(elementId) {
      const cached = meshCache3D.get(elementId);
      if (cached && cached.group) {
        // Dispose geometry and materials
        cached.group.traverse(obj => {
          if (obj.geometry) obj.geometry.dispose();
          if (obj.material) {
            if (Array.isArray(obj.material)) {
              obj.material.forEach(m => {
                if (m.map) m.map.dispose();
                m.dispose();
              });
            } else {
              if (obj.material.map) obj.material.map.dispose();
              obj.material.dispose();
            }
          }
        });
        // Remove from scene
        if (scene) scene.remove(cached.group);
      }
      meshCache3D.delete(elementId);
      elementVersions.delete(elementId);
      dirtyElements3D.delete(elementId);
    }

    /**
     * Clear all 3D caches (for full cleanup)
     */
    function clearAll3DCaches() {
      meshCache3D.forEach((cached, id) => {
        if (cached && cached.group) {
          cached.group.traverse(obj => {
            if (obj.geometry) obj.geometry.dispose();
            if (obj.material) {
              if (Array.isArray(obj.material)) {
                obj.material.forEach(m => m.dispose());
              } else {
                obj.material.dispose();
              }
            }
          });
        }
      });
      meshCache3D.clear();
      elementVersions.clear();
      dirtyElements3D.clear();
      cachedRoomStructure = null;
      forceFullRebuild3D = true;
    }

    // ===== INITIALIZATION =====
    document.addEventListener('DOMContentLoaded', init);

    // Undo/Redo state
    let undoStack = [];
    let redoStack = [];
    const MAX_UNDO_STATES = 50;

    // Track if we're waiting for login to continue
    let pendingAuthInit = false;
    let workspaceInitialized = false;

    // Wait for SgAuth to initialize (shared auth system)
    async function waitForAuth() {
      // Wait for SgAuth to be available
      let attempts = 0;
      while (!window.SgAuth && attempts < 30) {
        await new Promise(r => setTimeout(r, 100));
        attempts++;
      }

      // Wait for SgAuth to initialize with error handling
      if (window.SgAuth && window.SgAuth.init) {
        try {
          await window.SgAuth.init();
        } catch (err) {
          // Handle AbortError and other init errors gracefully
          if (err.name === 'AbortError') {
            console.warn('SgAuth init aborted (may have timed out):', err.message);
          } else {
            console.warn('SgAuth init error:', err);
          }
          // Continue without auth - user can still use the tool
        }
      }
    }

    async function init() {
      // Start preloader animation immediately
      showPreloader('Loading workspace', 'Surprise Granite');

      // Check if viewing a shared design (allow without login)
      const urlParams = new URLSearchParams(window.location.search);
      const shareToken = urlParams.get('share') || urlParams.get('p');

      // Check for subscription callback (returning from Stripe)
      const subscriptionStatus = urlParams.get('subscription');
      const subscriptionPlan = urlParams.get('plan');

      if (subscriptionStatus) {
        // Clean URL
        const cleanUrl = new URL(window.location);
        cleanUrl.searchParams.delete('subscription');
        cleanUrl.searchParams.delete('plan');
        history.replaceState(null, '', cleanUrl.toString());

        // Show appropriate message after workspace loads
        setTimeout(() => handleSubscriptionCallback(subscriptionStatus, subscriptionPlan), 1000);
      }

      // Check if this is an OAuth callback (has hash with access_token)
      const hashParams = new URLSearchParams(window.location.hash.substring(1));
      const isOAuthCallback = hashParams.has('access_token') || hashParams.has('error');

      // Wait for global auth system to be ready
      await waitForAuth();

      const supabase = getSupabaseClient();

      if (isOAuthCallback && supabase) {
        // Wait for Supabase to process the OAuth callback
        // Clear the hash from URL for cleaner look
        history.replaceState(null, '', window.location.pathname + window.location.search);

        // Give Supabase a moment to process the tokens
        await new Promise(resolve => setTimeout(resolve, 500));

        // Check session after OAuth processing
        try {
          const { data: { session } } = await supabase.auth.getSession();
          if (session) {
            initializeWorkspace();
            return;
          }
        } catch (authErr) {
          if (authErr.name !== 'AbortError') {
            console.warn('OAuth callback session check failed:', authErr.message);
          }
          // Continue without auth
        }
      }

      // If NOT a shared design, check authentication
      // Allow local file:// access without login for development
      const isLocalFile = window.location.protocol === 'file:';

      if (!shareToken && !isLocalFile) {
        // First check if SgAuth already has a logged-in user
        if (window.SgAuth && window.SgAuth.isLoggedIn()) {
          initializeWorkspace();
          return;
        }

        // Check if Supabase is available
        if (!supabase) {
          console.warn('Supabase not available, continuing without auth');
          initializeWorkspace();
          return;
        }

        // Try to get session with error handling
        let session = null;
        try {
          const result = await supabase.auth.getSession();
          session = result.data?.session;
        } catch (authErr) {
          // AbortError is benign - happens during page refresh/navigation
          if (authErr.name !== 'AbortError') {
            console.warn('Auth session check failed:', authErr.message);
          }
          // Continue without session - will initialize workspace
        }

        if (!session) {
          // Not logged in - show login prompt with guest option
          pendingAuthInit = true;
          hidePreloader();
          showLoginPromptRequired();

          // Listen for auth state changes (for when user logs in)
          try {
            supabase.auth.onAuthStateChange((event, session) => {
              if (event === 'SIGNED_IN' && session && !workspaceInitialized) {
                pendingAuthInit = false;
                // Force close login modal (remove required attribute first)
                const loginModal = document.getElementById('loginModal');
                loginModal.removeAttribute('data-required');
                loginModal.classList.remove('active');
                initializeWorkspace();
              }
            });
          } catch (authErr) {
            if (authErr.name !== 'AbortError') {
              console.warn('Auth state listener failed:', authErr.message);
            }
          }
          return;
        }
      }

      // Continue with normal initialization
      initializeWorkspace();
    }

    // Initialize the workspace (called after auth check passes)
    function initializeWorkspace() {
      if (workspaceInitialized) return; // Prevent double initialization
      workspaceInitialized = true;

      canvas = document.getElementById('canvas');
      ctx = canvas.getContext('2d');

      renderSidebar();
      renderFloorPlans();
      renderMaterials('granite');

      // Initialize cabinet catalog with series dropdown
      changeCatalog(currentCatalog);
      renderCabinetCatalog();

      // Load extended stone pricing from Excel import (async, non-blocking)
      loadStonePricing().then(count => {
        if (count > 0) {
          showToast(`Loaded ${count} stone materials with pricing`, 'success');
        }
        // Load countertops.json (874 products with images) after stone pricing
        return loadCountertopsJson();
      }).then(ctCount => {
        if (ctCount > 0) {
          showToast(`Loaded ${ctCount} countertop colors with images`, 'success');
        }
        // Load tile.json (466 tiles) then bravo-tile.json (pricing)
        return loadTileJson();
      }).then(tileCount => {
        if (tileCount > 0) {
          showToast(`Loaded ${tileCount} tile products`, 'success');
        }
        return loadBravoTileJson();
      }).then(bravoCount => {
        if (bravoCount > 0) {
          showToast(`Loaded Bravo Tile pricing for ${bravoCount} products`, 'success');
        }
        // Load products from Supabase last
        loadSupabaseProducts();
        // Pre-fetch distributor data for the default tab after static data loads
        setTimeout(() => {
          if (typeof loadDistributorDataForCategory === 'function') {
            loadDistributorDataForCategory(currentMaterialCategory || 'granite');
          }
        }, 1000);
      });

      setupEventListeners();
      setupDragDrop();
      fitToScreen();

      // Try to load auto-saved design FIRST (before initializing rooms)
      // This ensures we restore the saved room structure
      const urlParams = new URLSearchParams(window.location.search);
      const shareToken = urlParams.get('share') || urlParams.get('p');
      let autoSaveLoaded = false;
      if (!shareToken) {
        autoSaveLoaded = loadAutoSavedDesign();
        if (autoSaveLoaded) {
          console.log('Restored auto-saved design with', elements.length, 'elements and', rooms.length, 'rooms');
        }
      }

      // Initialize multi-room system (only creates new room if no rooms exist from autosave)
      initializeRooms();

      // Only sync elements with first room if we DIDN'T load from autosave
      // (autosave already has proper room-element associations)
      if (!autoSaveLoaded) {
        const firstRoom = getCurrentRoom();
        if (firstRoom) {
          firstRoom.elements = elements;
          firstRoom.walls = walls;
        }
      }
      updateRoomList();

      // Initialize auth UI
      initAuth();

      // Check pricing access based on subscription status
      checkPricingAccess();

      // Check for shared design URL
      checkSharedDesignUrl();

      // Check for lead info from account page
      checkLeadInfo();

      // Restore lead context from localStorage (if not coming fresh from account)
      if (!currentLeadInfo) {
        restoreLeadInfo();
      }

      // Keyboard shortcuts for undo/redo
      document.addEventListener('keydown', (e) => {
        if ((e.ctrlKey || e.metaKey) && e.key === 'z') {
          e.preventDefault();
          if (e.shiftKey) {
            redo();
          } else {
            undo();
          }
        }
        if ((e.ctrlKey || e.metaKey) && e.key === 'y') {
          e.preventDefault();
          redo();
        }
      });

      // Auto-hide keyboard shortcuts bar after 5 seconds
      const shortcutsHint = document.getElementById('shortcutsHint');
      if (shortcutsHint) {
        setTimeout(() => {
          shortcutsHint.classList.add('hidden');
        }, 5000);

        // Show on hover
        shortcutsHint.addEventListener('mouseenter', () => {
          shortcutsHint.classList.remove('hidden');
        });

        // Hide again after mouse leaves (with delay)
        shortcutsHint.addEventListener('mouseleave', () => {
          setTimeout(() => {
            shortcutsHint.classList.add('hidden');
          }, 2000);
        });
      }

      // Show restore notification if autosave was loaded earlier
      if (autoSaveLoaded) {
        showToast(`Restored your design (${elements.length} elements)`, 'success');
        draw();
        render3D();
      }

      // Save initial undo state AFTER loading any saved design
      saveUndoState();

      // Initialize element selector dropdown and item picker
      updateElementSelector();
      updateItemPicker();

      // Hide preloader - workspace is ready
      hidePreloader();

      // Ensure messages section is visible (for signed-in designers)
      const messagesSection = document.getElementById('messagesSection');
      if (messagesSection) {
        messagesSection.style.display = 'block';
        const content = document.getElementById('messagesContent');
        if (content) content.style.display = 'block';
        console.log('Messages section visibility ensured');
      }

      // Show auto-save indicator
      console.log('Room Designer initialized. Auto-save enabled.');
    }

    // ===== AUTO-SAVE TO LOCALSTORAGE =====
    const AUTOSAVE_KEY = 'room_designer_autosave';
    let autosaveTimeout = null;
    let lastSaveTime = 0;
    let hasUnsavedChanges = false;

    function autoSaveDesign(immediate = false) {
      hasUnsavedChanges = true;

      // Debounce auto-save to avoid excessive writes
      if (autosaveTimeout) clearTimeout(autosaveTimeout);

      const doSave = async () => {
        try {
          // SAFETY: Don't overwrite existing non-empty save with empty state
          if (elements.length === 0) {
            try {
              const existingSave = localStorage.getItem(AUTOSAVE_KEY);
              if (existingSave) {
                const existing = JSON.parse(existingSave);
                if (existing.elements && existing.elements.length > 0) {
                  console.log('Auto-save skipped: would overwrite', existing.elements.length, 'elements with empty state');
                  return;
                }
              }
            } catch (e) { /* parse error  safe to overwrite */ }
          }

          // Save current room state before saving
          if (typeof saveCurrentRoomState === 'function') {
            saveCurrentRoomState();
          }

          const saveData = {
            elements: elements.map(el => serializeElement(el)),
            walls: walls.map(w => serializeWall(w)),
            roomWidth: roomWidth,
            roomDepth: roomDepth,
            roomHeight: roomHeight,
            roomType: document.getElementById('roomType')?.value || 'kitchen',
            projectName: document.getElementById('projectName')?.value || 'Untitled',
            timestamp: Date.now(),
            version: 4, // v4: feet-based positions (xFt/yFt)
            pixelsPerFoot: pixelsPerFoot,
            // Save multi-room data (already serialized by saveCurrentRoomState)
            rooms: rooms.map(room => ({
              ...room,
              elements: (room.elements || []).map(el =>
                el.xFt !== undefined ? { ...el, textureImg: null } : serializeElement(el)
              ),
              walls: (room.walls || []).map(w =>
                w.x1Ft !== undefined ? { ...w } : serializeWall(w)
              )
            })),
            currentRoomId: currentRoomId,
            currentRoom: currentRoom,
            projectRooms: projectRooms
          };
          const saveJson = JSON.stringify(saveData);

          // Create backup of previous save before overwriting
          try {
            const prevSave = localStorage.getItem(AUTOSAVE_KEY);
            if (prevSave) {
              localStorage.setItem(AUTOSAVE_KEY + '_backup', prevSave);
            }
          } catch (backupErr) {
            // Quota exceeded  free space by trimming old local designs
            console.warn('Backup save failed, freeing space:', backupErr.message);
            try {
              const designs = JSON.parse(localStorage.getItem('room_designs') || '[]');
              if (designs.length > 5) {
                localStorage.setItem('room_designs', JSON.stringify(designs.slice(0, 5)));
                console.log('Trimmed local designs from', designs.length, 'to 5 to free quota');
                // Retry backup
                const prevSave = localStorage.getItem(AUTOSAVE_KEY);
                if (prevSave) localStorage.setItem(AUTOSAVE_KEY + '_backup', prevSave);
              }
            } catch (trimErr) { /* give up on backup */ }
          }

          try {
            localStorage.setItem(AUTOSAVE_KEY, saveJson);
          } catch (quotaErr) {
            // Main save quota exceeded  trim designs and retry
            console.warn('Auto-save quota exceeded, freeing space...');
            try {
              const designs = JSON.parse(localStorage.getItem('room_designs') || '[]');
              if (designs.length > 3) {
                localStorage.setItem('room_designs', JSON.stringify(designs.slice(0, 3)));
              }
              localStorage.removeItem(AUTOSAVE_KEY + '_backup');
              localStorage.setItem(AUTOSAVE_KEY, saveJson);
            } catch (retryErr) {
              console.error('Auto-save failed even after freeing space:', retryErr);
            }
          }
          lastSaveTime = Date.now();
          hasUnsavedChanges = false;
          console.log('Auto-saved design:', elements.length, 'elements');

          // Show subtle auto-save feedback
          showAutoSaveIndicator();

          // ===== REALTIME SYNC TO CLOUD =====
          // If design is saved to cloud, sync changes for live viewers
          if (SHARE_STATE.designId && !SHARE_STATE.isSharedView) {
            syncDesignToCloud();
          }
        } catch (e) {
          console.warn('Auto-save failed:', e);
        }
      };

      if (immediate) {
        doSave();
      } else {
        autosaveTimeout = setTimeout(doSave, 1000); // 1 second debounce
      }
    }

    // Sync design changes to cloud for realtime updates
    let cloudSyncTimeout = null;
    async function syncDesignToCloud() {
      // Debounce cloud sync to avoid excessive API calls
      if (cloudSyncTimeout) clearTimeout(cloudSyncTimeout);

      cloudSyncTimeout = setTimeout(async () => {
        if (!SHARE_STATE.designId) return;

        const supabase = getSupabaseClient();
        if (!supabase) return;

        try {
          const updateData = {
            elements: elements.map(el => serializeElement(el)),
            room_width: roomWidth,
            room_depth: roomDepth,
            settings: {
              walls: walls.map(w => serializeWall(w)),
              pricing_config: {
                globalMargin: PRICING_STATE.globalMargin,
                categoryMargins: PRICING_STATE.categoryMargins,
                customPrices: PRICING_STATE.customPrices
              },
              pixelsPerFoot: pixelsPerFoot,
              rooms: rooms.map(room => ({
                ...room,
                elements: (room.elements || []).map(el =>
                  el.xFt !== undefined ? { ...el, textureImg: null } : serializeElement(el)
                ),
                walls: (room.walls || []).map(w =>
                  w.x1Ft !== undefined ? { ...w } : serializeWall(w)
                )
              }))
            },
            updated_at: new Date().toISOString()
          };

          const { error } = await supabase
            .from('room_designs')
            .update(updateData)
            .eq('id', SHARE_STATE.designId);

          if (error) {
            console.warn('Cloud sync failed:', error);
          } else {
            console.log('Design synced to cloud - live viewers will see update');
          }
        } catch (err) {
          console.warn('Cloud sync error:', err);
        }
      }, 2000); // 2 second debounce for cloud sync
    }

    // Helper to check if there's any design data to save
    function hasDesignData() {
      if (elements.length > 0) return true;
      if (rooms.some(r => r.elements && r.elements.length > 0)) return true;
      return false;
    }

    // Save before page unload
    window.addEventListener('beforeunload', (e) => {
      if (hasDesignData()) {
        // Save current room state first
        if (typeof saveCurrentRoomState === 'function') {
          saveCurrentRoomState();
        }
        // Force immediate save
        autoSaveDesign(true);

        // Only show warning if there are unsaved changes
        if (hasUnsavedChanges) {
          e.preventDefault();
          e.returnValue = 'You have unsaved changes. Are you sure you want to leave?';
          return e.returnValue;
        }
      }
    });

    // Also save on visibility change (tab switch, minimize)
    document.addEventListener('visibilitychange', () => {
      if (document.visibilityState === 'hidden' && hasDesignData()) {
        if (typeof saveCurrentRoomState === 'function') {
          saveCurrentRoomState();
        }
        autoSaveDesign(true);
      }
    });

    // Periodic auto-save every 30 seconds if there are changes
    setInterval(() => {
      if (hasUnsavedChanges && hasDesignData()) {
        autoSaveDesign(true);
      }
    }, 30000);

    // ===== INACTIVITY TIMEOUT =====
    const INACTIVITY_TIMEOUT = 5 * 60 * 1000; // 5 minutes
    const INACTIVITY_WARNING = 60 * 1000; // 1 minute warning before timeout
    let lastActivityTime = Date.now();
    let inactivityTimer = null;
    let warningTimer = null;
    let isSessionLocked = false;

    function resetActivityTimer() {
      lastActivityTime = Date.now();

      // Clear existing timers
      if (inactivityTimer) clearTimeout(inactivityTimer);
      if (warningTimer) clearTimeout(warningTimer);

      // Hide warning if shown
      hideInactivityWarning();

      // Don't set new timers if session is locked
      if (isSessionLocked) return;

      // Set warning timer (1 minute before timeout)
      warningTimer = setTimeout(() => {
        showInactivityWarning();
      }, INACTIVITY_TIMEOUT - INACTIVITY_WARNING);

      // Set timeout timer
      inactivityTimer = setTimeout(() => {
        handleInactivityTimeout();
      }, INACTIVITY_TIMEOUT);
    }

    function showInactivityWarning() {
      // Don't show if no work to save
      if (elements.length === 0) return;

      // Create warning modal if it doesn't exist
      let modal = document.getElementById('inactivityModal');
      if (!modal) {
        modal = document.createElement('div');
        modal.id = 'inactivityModal';
        modal.className = 'modal-overlay';
        modal.innerHTML = `
          <div class="modal" style="max-width: 400px; text-align: center;">
            <div class="modal-header">
              <h3 style="color: #f59e0b;"> Session Timeout Warning</h3>
            </div>
            <div class="modal-body" style="padding: 20px;">
              <p style="font-size: 16px; margin-bottom: 15px;">You've been inactive for a while.</p>
              <p style="margin-bottom: 20px;">Your session will be saved and locked in <strong id="inactivityCountdown">60</strong> seconds.</p>
              <button class="btn btn-primary" onclick="stayActive()" style="padding: 12px 30px; font-size: 16px;">
                I'm Still Here
              </button>
            </div>
          </div>
        `;
        document.body.appendChild(modal);
      }

      modal.classList.add('active');

      // Start countdown
      let countdown = 60;
      const countdownEl = document.getElementById('inactivityCountdown');
      const countdownInterval = setInterval(() => {
        countdown--;
        if (countdownEl) countdownEl.textContent = countdown;
        if (countdown <= 0 || isSessionLocked) {
          clearInterval(countdownInterval);
        }
      }, 1000);

      modal.dataset.countdownInterval = countdownInterval;
    }

    function hideInactivityWarning() {
      const modal = document.getElementById('inactivityModal');
      if (modal) {
        modal.classList.remove('active');
        if (modal.dataset.countdownInterval) {
          clearInterval(parseInt(modal.dataset.countdownInterval));
        }
      }
    }

    function stayActive() {
      hideInactivityWarning();
      resetActivityTimer();
      showToast('Session extended', 'success');
    }

    function handleInactivityTimeout() {
      // Save work first
      if (elements.length > 0) {
        autoSaveDesign(true);
      }

      isSessionLocked = true;
      hideInactivityWarning();

      // Show locked screen
      let lockScreen = document.getElementById('sessionLockScreen');
      if (!lockScreen) {
        lockScreen = document.createElement('div');
        lockScreen.id = 'sessionLockScreen';
        lockScreen.style.cssText = `
          position: fixed;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          background: rgba(0, 0, 0, 0.9);
          z-index: 100000;
          display: flex;
          align-items: center;
          justify-content: center;
          flex-direction: column;
        `;
        lockScreen.innerHTML = `
          <div style="text-align: center; color: white; padding: 40px;">
            <div style="font-size: 60px; margin-bottom: 20px;"></div>
            <h2 style="font-size: 28px; margin-bottom: 15px;">Session Timed Out</h2>
            <p style="font-size: 16px; color: #aaa; margin-bottom: 10px;">You were inactive for 5 minutes.</p>
            <p style="font-size: 14px; color: #888; margin-bottom: 30px;">Your work has been saved automatically.</p>
            <button onclick="unlockSession()" style="
              background: linear-gradient(135deg, #3b82f6, #2563eb);
              color: white;
              border: none;
              padding: 15px 40px;
              font-size: 18px;
              border-radius: 8px;
              cursor: pointer;
              font-weight: 600;
            ">
              Resume Working
            </button>
          </div>
        `;
        document.body.appendChild(lockScreen);
      }
      lockScreen.style.display = 'flex';
    }

    function unlockSession() {
      isSessionLocked = false;
      const lockScreen = document.getElementById('sessionLockScreen');
      if (lockScreen) {
        lockScreen.style.display = 'none';
      }
      resetActivityTimer();
      showToast('Welcome back! Your work was saved.', 'success');
    }

    // Track user activity
    const activityEvents = ['mousedown', 'mousemove', 'keydown', 'touchstart', 'scroll', 'click'];
    activityEvents.forEach(event => {
      document.addEventListener(event, () => {
        if (!isSessionLocked) {
          resetActivityTimer();
        }
      }, { passive: true });
    });

    // Start activity tracking
    resetActivityTimer();

    function loadAutoSavedDesign() {
      try {
        const saved = localStorage.getItem(AUTOSAVE_KEY);
        if (!saved) {
          console.log('No auto-save found');
          return false;
        }

        const data = JSON.parse(saved);
        if (!data.elements || !Array.isArray(data.elements)) {
          console.log('Invalid auto-save data');
          return false;
        }

        // Check if save is recent (within 30 days)
        const age = Date.now() - (data.timestamp || 0);
        const maxAge = 30 * 24 * 60 * 60 * 1000; // 30 days
        if (age > maxAge) {
          console.log('Auto-save too old, clearing');
          clearAutoSave();
          return false;
        }

        // Skip if no elements to restore
        if (data.elements.length === 0) {
          console.log('Auto-save is empty');
          return false;
        }

        // Restore elements
        elements.length = 0;
        data.elements.forEach(el => {
          // Ensure element has required properties
          if (!el.id) el.id = Date.now() + Math.random();
          if (!el.type) return; // Skip invalid elements

          // Restore texture images if URLs exist
          if (el.texture && !el.textureImg) {
            const img = new Image();
            img.crossOrigin = 'anonymous';
            img.onload = () => {
              el.textureImg = img;
              draw();
            };
            img.onerror = () => {
              console.warn('Failed to load texture:', el.texture);
            };
            img.src = el.texture;
          }
          elements.push(el);
        });

        // Restore walls
        if (data.walls && Array.isArray(data.walls)) {
          walls.length = 0;
          data.walls.forEach(w => walls.push(w));
        }

        // Restore room settings with validation
        if (data.roomWidth && data.roomWidth > 0 && data.roomWidth <= 100) {
          roomWidth = data.roomWidth;
          const roomWidthEl = document.getElementById('roomWidth');
          if (roomWidthEl) roomWidthEl.value = roomWidth;
        }
        if (data.roomDepth && data.roomDepth > 0 && data.roomDepth <= 100) {
          roomDepth = data.roomDepth;
          const roomDepthEl = document.getElementById('roomDepth');
          if (roomDepthEl) roomDepthEl.value = roomDepth;
        }
        if (data.roomHeight && data.roomHeight > 0 && data.roomHeight <= 30) {
          roomHeight = data.roomHeight;
          const roomHeightEl = document.getElementById('roomHeight');
          if (roomHeightEl) roomHeightEl.value = roomHeight;
        }
        if (data.roomType) {
          const roomTypeEl = document.getElementById('roomType');
          if (roomTypeEl) roomTypeEl.value = data.roomType;
        }
        if (data.projectName) {
          const projectNameEl = document.getElementById('projectName');
          if (projectNameEl) projectNameEl.value = data.projectName;
        }

        // Restore multi-room data if present
        if (data.rooms && Array.isArray(data.rooms) && data.rooms.length > 0) {
          rooms.length = 0;
          data.rooms.forEach(room => {
            // Restore texture images in room elements
            if (room.elements) {
              room.elements.forEach(el => {
                if (el.texture && !el.textureImg) {
                  const img = new Image();
                  img.crossOrigin = 'anonymous';
                  img.onload = () => {
                    el.textureImg = img;
                    draw();
                  };
                  img.src = el.texture;
                }
              });
            }
            rooms.push(room);
          });
          console.log('Restored', rooms.length, 'rooms');
        }
        if (data.currentRoomId) {
          currentRoomId = data.currentRoomId;
        }
        if (data.currentRoom) {
          currentRoom = data.currentRoom;
        }
        if (data.projectRooms && Array.isArray(data.projectRooms)) {
          projectRooms.length = 0;
          data.projectRooms.forEach(r => projectRooms.push(r));
        }

        // Deserialize positions from feet-based format (or legacy pixel-based with scale conversion)
        updateCanvasSize(); // Calculate current pixelsPerFoot first
        const savedScale = data.pixelsPerFoot || 40;
        console.log('Auto-save scale:', savedScale, 'Current scale:', pixelsPerFoot);

        // Deserialize element and wall positions
        elements.forEach(el => deserializeElement(el, savedScale));
        walls.forEach(w => deserializeWall(w, savedScale));

        // Deserialize room element and wall positions
        rooms.forEach(room => {
          if (room.elements) {
            room.elements.forEach(el => deserializeElement(el, savedScale));
          }
          if (room.walls) {
            room.walls.forEach(w => deserializeWall(w, savedScale));
          }
          room.pixelsPerFoot = pixelsPerFoot; // Update to current scale
        });

        // If rooms were restored, sync global elements with current room
        if (rooms.length > 0) {
          // Find the current room (by saved currentRoomId or first room)
          let activeRoom = rooms.find(r => r.id === currentRoomId);
          if (!activeRoom) {
            activeRoom = rooms[0];
            currentRoomId = activeRoom.id;
          }

          // If the room has elements, use those instead of the global elements
          // (they should be the same, but room.elements is the authoritative source)
          if (activeRoom.elements && activeRoom.elements.length > 0) {
            elements.length = 0;
            activeRoom.elements.forEach(el => elements.push(el));
          } else {
            // Otherwise, save current elements to the room
            activeRoom.elements = [...elements];
          }

          if (activeRoom.walls && activeRoom.walls.length > 0) {
            walls.length = 0;
            activeRoom.walls.forEach(w => walls.push(w));
          } else {
            activeRoom.walls = [...walls];
          }

          // Update room dimensions from active room
          if (activeRoom.width) roomWidth = activeRoom.width;
          if (activeRoom.depth) roomDepth = activeRoom.depth;
        }

        // Update room list UI if available
        if (typeof updateRoomList === 'function') {
          updateRoomList();
        }

        // Update UI components
        updateElementSelector();
        updateItemPicker();
        calculateQuote();

        console.log('Loaded auto-saved design:', elements.length, 'elements from', rooms.length, 'rooms');
        hasUnsavedChanges = false;
        return true;
      } catch (e) {
        console.warn('Failed to load auto-save:', e);
        // Try backup before clearing
        try {
          const backup = localStorage.getItem(AUTOSAVE_KEY + '_backup');
          if (backup) {
            console.log('Attempting to restore from backup auto-save...');
            localStorage.setItem(AUTOSAVE_KEY, backup);
            return loadAutoSavedDesign(); // Retry with backup
          }
        } catch (backupErr) {
          console.warn('Backup restore also failed:', backupErr);
        }
        clearAutoSave();
        return false;
      }
    }

    // Recovery function  accessible from browser console as recoverDesignFromBackup()
    window.recoverDesignFromBackup = function() {
      try {
        const backup = localStorage.getItem(AUTOSAVE_KEY + '_backup');
        if (!backup) {
          console.log('No backup save found.');
          return false;
        }
        const data = JSON.parse(backup);
        console.log('Backup save found:', data.elements?.length, 'elements,', data.rooms?.length, 'rooms, saved at', new Date(data.timestamp).toLocaleString());
        localStorage.setItem(AUTOSAVE_KEY, backup);
        console.log('Backup restored to main save. Reload the page to see your design.');
        return true;
      } catch (e) {
        console.error('Recovery failed:', e);
        return false;
      }
    };

    function clearAutoSave() {
      try {
        localStorage.removeItem(AUTOSAVE_KEY);
        hasUnsavedChanges = false;
        console.log('Auto-save cleared');
      } catch (e) {
        console.warn('Failed to clear auto-save:', e);
      }
    }

    // Check if there's saved work
    function hasSavedWork() {
      try {
        const saved = localStorage.getItem(AUTOSAVE_KEY);
        if (!saved) return false;
        const data = JSON.parse(saved);
        return data.elements && data.elements.length > 0;
      } catch (e) {
        return false;
      }
    }

    // ===== UNDO/REDO =====
    function saveUndoState() {
      // Clone current state
      const state = {
        elements: JSON.parse(JSON.stringify(elements.map(el => ({
          ...el,
          textureImg: el.textureImg ? el.textureImg.src : null
        })))),
        walls: JSON.parse(JSON.stringify(walls)),
        roomWidth: roomWidth,
        roomDepth: roomDepth
      };

      undoStack.push(state);

      // Limit stack size
      if (undoStack.length > MAX_UNDO_STATES) {
        undoStack.shift();
      }

      // Clear redo stack on new action
      redoStack = [];

      updateUndoButtons();

      // Auto-save to localStorage
      autoSaveDesign();
    }

    function undo() {
      if (undoStack.length <= 1) return; // Keep at least one state

      // Save current to redo
      const currentState = undoStack.pop();
      redoStack.push(currentState);

      // Restore previous state
      const prevState = undoStack[undoStack.length - 1];
      restoreState(prevState);

      updateUndoButtons();
    }

    function redo() {
      if (redoStack.length === 0) return;

      const state = redoStack.pop();
      undoStack.push(state);
      restoreState(state);

      updateUndoButtons();
    }

    function restoreState(state) {
      elements = state.elements.map(el => {
        const restored = { ...el };
        // Reload texture if it had one
        if (el.textureImg) {
          const img = new Image();
          img.crossOrigin = 'anonymous';
          img.onload = () => {
            restored.textureImg = img;
            draw();
          };
          img.src = el.textureImg;
          restored.textureImg = null; // Will be set when loaded
        }
        return restored;
      });
      walls = state.walls;
      roomWidth = state.roomWidth;
      roomDepth = state.roomDepth;

      selectedElement = null;
      updateProperties();
      calculateQuote();
      draw();
    }

    function updateUndoButtons() {
      const undoBtn = document.getElementById('undoBtn');
      const redoBtn = document.getElementById('redoBtn');

      if (undoBtn) {
        undoBtn.disabled = undoStack.length <= 1;
        undoBtn.title = `Undo (${undoStack.length - 1} steps)`;
      }
      if (redoBtn) {
        redoBtn.disabled = redoStack.length === 0;
        redoBtn.title = `Redo (${redoStack.length} steps)`;
      }
    }

    function resetCanvas() {
      if (!confirm('RESET ENTIRE PROJECT?\n\nThis will:\n Delete all elements\n Clear room settings\n Erase saved progress\n\nThis cannot be undone!')) return;

      // Clear everything
      elements = [];
      walls = [];
      selectedElement = null;
      undoStack = [];
      redoStack = [];

      // Reset room settings to defaults
      roomWidth = 12;
      roomDepth = 10;
      roomHeight = 8;
      document.getElementById('roomWidth').value = 12;
      document.getElementById('roomDepth').value = 10;
      document.getElementById('roomHeight').value = 8;

      const projectNameEl = document.getElementById('projectName');
      if (projectNameEl) projectNameEl.value = 'Untitled Project';

      const roomTypeEl = document.getElementById('roomType');
      if (roomTypeEl) roomTypeEl.value = 'kitchen';

      // Clear auto-save so refresh starts fresh
      clearAutoSave();

      updateProperties();
      updateElementSelector();
      updateItemPicker();
      calculateQuote();
      updateCanvasSize();
      draw();
      render3D();

      showToast('Project reset to defaults', 'info');
    }

    function renderSidebar() {
      // Render element grids with SVG icons
      ['cabinets', 'surfaces', 'appliances', 'structure', 'bathroom', 'laundry', 'closet'].forEach(category => {
        const grid = document.getElementById(category + 'Grid');
        if (!grid) return;

        grid.innerHTML = ELEMENT_TYPES[category].map(el => {
          // Get the SVG icon for this element type
          const svgIcon = ELEMENT_ICONS[el.type];

          // Build icon content - prefer SVG, fallback to color
          let iconContent;
          if (elementTextures[el.type]) {
            // Custom uploaded texture
            iconContent = `<div class="element-icon" style="background-image: url(${elementTextures[el.type]}); background-size: cover; background-position: center;"></div>`;
          } else if (svgIcon) {
            // SVG icon from ELEMENT_ICONS
            iconContent = `<div class="element-icon element-svg">${svgIcon}</div>`;
          } else {
            // Color fallback
            iconContent = `<div class="element-icon" style="background: ${el.color};"></div>`;
          }

          return `
            <div class="element-item ${elementTextures[el.type] ? 'has-texture' : ''}"
                 draggable="true"
                 data-type="${el.type}"
                 data-category="${category}">
              ${iconContent}
              <div class="element-name">${el.label}</div>
              <div class="element-upload-btn" onclick="event.stopPropagation(); uploadElementTexture('${el.type}')" title="Upload custom texture">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                  <polyline points="17 8 12 3 7 8"/>
                  <line x1="12" y1="3" x2="12" y2="15"/>
                </svg>
              </div>
            </div>
          `;
        }).join('');
      });
    }

    function renderFloorPlans() {
      const grid = document.getElementById('floorplanGrid');
      grid.innerHTML = FLOOR_PLANS.map(fp => `
        <div class="floorplan-item ${currentFloorPlan === fp.id ? 'active' : ''}"
             onclick="selectFloorPlan('${fp.id}')">
          <div class="floorplan-preview">
            ${getFloorPlanSVG(fp)}
          </div>
          <div class="floorplan-name">${fp.name}</div>
        </div>
      `).join('');
    }

    function getFloorPlanSVG(fp) {
      if (fp.id === 'empty') {
        return `<svg viewBox="0 0 40 30"><rect x="2" y="2" width="36" height="26" fill="none" stroke="#666" stroke-width="1" stroke-dasharray="2"/></svg>`;
      }
      if (fp.id === 'square') {
        return `<svg viewBox="0 0 40 30"><rect x="2" y="2" width="36" height="26" fill="#333" stroke="#666" stroke-width="1"/></svg>`;
      }
      if (fp.id === 'l-shape') {
        return `<svg viewBox="0 0 40 30"><path d="M2 2 H26 V15 H15 V28 H2 Z" fill="#333" stroke="#666" stroke-width="1"/></svg>`;
      }
      if (fp.id === 'u-shape') {
        return `<svg viewBox="0 0 40 30"><path d="M2 2 H12 V20 H28 V2 H38 V28 H2 Z" fill="#333" stroke="#666" stroke-width="1"/></svg>`;
      }
      if (fp.id === 'galley') {
        return `<svg viewBox="0 0 40 30"><rect x="2" y="2" width="8" height="26" fill="#333" stroke="#666"/><rect x="30" y="2" width="8" height="26" fill="#333" stroke="#666"/></svg>`;
      }
      if (fp.id === 'open') {
        return `<svg viewBox="0 0 40 30"><rect x="2" y="2" width="36" height="26" fill="none" stroke="#666" stroke-dasharray="2"/><rect x="2" y="18" width="16" height="10" fill="#333" stroke="#666"/></svg>`;
      }
      return `<svg viewBox="0 0 40 30"><rect x="2" y="2" width="36" height="26" fill="none" stroke="#666"/></svg>`;
    }

    // ===== MATERIALS LIBRARY =====
    let selectedMaterial = null;
    let currentMaterialCategory = 'granite';

    // Current brand filter
    let currentBrandFilter = '';

    let currentPriceFilter = '';
    let currentFinishFilter = '';

    function applyMaterialFilters() {
      currentBrandFilter = document.getElementById('brandFilter')?.value || '';
      currentPriceFilter = document.getElementById('priceFilter')?.value || '';
      currentFinishFilter = document.getElementById('finishFilter')?.value || '';
      renderMaterials(currentMaterialCategory);
    }

    function clearAllMaterialFilters() {
      currentBrandFilter = '';
      currentPriceFilter = '';
      currentFinishFilter = '';
      const bf = document.getElementById('brandFilter');
      const pf = document.getElementById('priceFilter');
      const ff = document.getElementById('finishFilter');
      if (bf) bf.value = '';
      if (pf) pf.value = '';
      if (ff) ff.value = '';
      renderMaterials(currentMaterialCategory);
    }

    // Legacy compat
    function filterMaterialsByBrand(brand) {
      currentBrandFilter = brand;
      renderMaterials(currentMaterialCategory);
    }
    function clearBrandFilter() { clearAllMaterialFilters(); }

    function renderMaterials(category = 'granite') {
      currentMaterialCategory = category;
      const grid = document.getElementById('materialGrid');
      let materials = MATERIALS[category] || [];

      // DEDUPLICATE: Remove duplicates by NAME only (case-insensitive)
      // Same stone/product from different distributors = same product
      // Score picks the best version: image + price + sku
      const seenKeys = new Map();
      for (const m of materials) {
        const key = (m.name || '').toLowerCase().trim();
        if (!key) continue;

        if (seenKeys.has(key)) {
          const existing = seenKeys.get(key);
          // Score: higher is better (image=10, price=5, sku=3, brand=1)
          const existingScore = (hasValidImageUrl(existing.url) ? 10 : 0) +
                               (existing.price ? 5 : 0) +
                               (existing.sku ? 3 : 0) +
                               (existing.brand ? 1 : 0);
          const newScore = (hasValidImageUrl(m.url) ? 10 : 0) +
                          (m.price ? 5 : 0) +
                          (m.sku ? 3 : 0) +
                          (m.brand ? 1 : 0);
          if (newScore > existingScore) {
            // Carry forward data from existing if new is missing it
            if (!m.price && existing.price) m.price = existing.price;
            if (!m.unit && existing.unit) m.unit = existing.unit;
            if (!hasValidImageUrl(m.url) && hasValidImageUrl(existing.url)) m.url = existing.url;
            if (!m.brand && existing.brand) m.brand = existing.brand;
            seenKeys.set(key, m);
          } else {
            // Carry forward data from new entry if existing is missing it
            if (!existing.price && m.price) existing.price = m.price;
            if (!existing.unit && m.unit) existing.unit = m.unit;
            if (!hasValidImageUrl(existing.url) && hasValidImageUrl(m.url)) existing.url = m.url;
            if (!existing.brand && m.brand) existing.brand = m.brand;
          }
        } else {
          seenKeys.set(key, m);
        }
      }
      // Get the deduplicated list
      materials = Array.from(seenKeys.values());

      // Sanitize prices: anything over $200/unit is likely a full-slab or product price, not per-sqft
      for (const m of materials) {
        if (m.price && m.price > 200) {
          m.price = null;
        }
      }

      // Filter: only show materials with images (http URLs or relative paths) or valid colors
      materials = materials.filter(m => {
        const hasImage = hasValidImageUrl(m.url);
        const hasColor = m.color && m.color !== '#888888';
        return hasImage || hasColor;
      });

      // --- Populate filter dropdowns from ALL materials (before filtering) ---
      const allBrands = [...new Set(materials.map(m => m.brand).filter(Boolean))].sort();
      const allFinishes = [...new Set(materials.map(m => m.finish).filter(Boolean))].sort();

      const brandFilterEl = document.getElementById('brandFilter');
      if (brandFilterEl) {
        brandFilterEl.innerHTML = '<option value="">All Vendors (' + materials.length + ')</option>' +
          allBrands.map(b => {
            const count = materials.filter(m => m.brand === b).length;
            return `<option value="${b}" ${currentBrandFilter === b ? 'selected' : ''}>${b} (${count})</option>`;
          }).join('');
      }

      const finishFilterEl = document.getElementById('finishFilter');
      if (finishFilterEl) {
        finishFilterEl.innerHTML = '<option value="">All Finishes</option>' +
          allFinishes.map(f => {
            const count = materials.filter(m => m.finish === f).length;
            return `<option value="${f}" ${currentFinishFilter === f ? 'selected' : ''}>${f} (${count})</option>`;
          }).join('');
      }

      const priceFilterEl = document.getElementById('priceFilter');
      if (priceFilterEl && currentPriceFilter) {
        priceFilterEl.value = currentPriceFilter;
      }

      // --- Apply all active filters ---
      if (currentBrandFilter) {
        materials = materials.filter(m => m.brand === currentBrandFilter);
      }
      if (currentFinishFilter) {
        materials = materials.filter(m => m.finish === currentFinishFilter);
      }
      if (currentPriceFilter) {
        materials = materials.filter(m => {
          const p = m.price || (m.tradePrice) || (m.retailPrice) || null;
          if (currentPriceFilter === 'has') return p != null;
          if (!p) return false;
          const ranges = { '0-5': [0,5], '5-15': [5,15], '15-30': [15,30], '30-50': [30,50], '50-100': [50,100] };
          if (ranges[currentPriceFilter]) {
            const [lo, hi] = ranges[currentPriceFilter];
            return p >= lo && p < hi;
          }
          if (currentPriceFilter === '100+') return p >= 100;
          return true;
        });
      }

      // Sort: image+real color first, then image+grey fallback last, then by name
      materials.sort((a, b) => {
        const aImg = hasValidImageUrl(a.url);
        const bImg = hasValidImageUrl(b.url);
        const aRealColor = a.color && a.color !== '#888888' && a.color !== '#C0C0C0';
        const bRealColor = b.color && b.color !== '#888888' && b.color !== '#C0C0C0';
        // Tier: 0 = has image + real color, 1 = has image only, 2 = color only, 3 = neither
        const aTier = aImg && aRealColor ? 0 : aImg ? 1 : aRealColor ? 2 : 3;
        const bTier = bImg && bRealColor ? 0 : bImg ? 1 : bRealColor ? 2 : 3;
        if (aTier !== bTier) return aTier - bTier;
        return (a.name || '').localeCompare(b.name || '');
      });

      const canShowPrice = PRICING_ACCESS.canViewPricing;

      // Render all materials as a flat alphabetical grid (no brand separators)
      grid.innerHTML = materials.map(mat => {
        // Get account-aware display price (trade vs retail)
        const displayPrice = (typeof getDisplayPrice === 'function') ? getDisplayPrice(mat) : (canShowPrice && mat.price ? { amount: mat.price, label: '' } : null);

        // Build tooltip with details
        let tooltip = mat.name;
        if (mat.brand) tooltip += ` | ${mat.brand}`;
        if (displayPrice) tooltip += ` | $${Number(displayPrice.amount).toFixed(2)}/${mat.unit || 'sf'}${displayPrice.label ? ' (' + displayPrice.label + ')' : ''}`;
        if (mat.sku) tooltip += ` | SKU: ${mat.sku}`;
        if (mat.material) tooltip += ` | ${mat.material}`;
        if (mat.size) tooltip += ` | ${mat.size}`;
        if (mat.finish) tooltip += ` | ${mat.finish}`;
        if (mat.origin) tooltip += ` | ${mat.origin}`;
        if (mat.series) tooltip += ` | ${mat.series}`;
        if (mat.warranty) tooltip += ` | ${mat.warranty}`;
        if (mat.features) tooltip += ` | ${mat.features}`;

        // Brand badge
        const brandBadge = mat.brand
          ? `<div class="material-brand-badge">${mat.brand.replace('MSI ', '').replace('Daltile ', '').substring(0, 10)}</div>`
          : '';

        // Distributor "In Stock" badge for live inventory items
        const distributorBadge = (mat.source === 'distributor' && mat.distributorName)
          ? `<div class="material-distributor-badge">${mat.distributorLogo ? `<img src="${mat.distributorLogo}" alt="">` : ''}${mat.distributorName}</div>`
          : '';

        // Use image URL directly
        const imageUrl = mat.url || '';

        // Determine background style
        let bgStyle = mat.color || '#666';
        let bgImage = imageUrl ? `background-image: url(${imageUrl});` : '';

        // Special handling for cabinets - wood grain pattern
        if (!imageUrl && category === 'cabinets' && mat.color) {
          const baseColor = mat.color;
          const darkColor = adjustColor(baseColor, -15);
          const lightColor = adjustColor(baseColor, 10);
          bgStyle = `repeating-linear-gradient(90deg, transparent 0px, transparent 2px, rgba(0,0,0,0.1) 2px, rgba(0,0,0,0.1) 3px, transparent 3px, transparent 8px), repeating-linear-gradient(90deg, transparent 0px, transparent 12px, rgba(255,255,255,0.06) 12px, rgba(255,255,255,0.06) 14px, transparent 14px, transparent 25px), linear-gradient(180deg, ${lightColor} 0%, ${baseColor} 35%, ${darkColor} 65%, ${baseColor} 100%)`;
        }

        // Add indicator if no texture (color only) - but not for cabinets with wood grain
        const noTextureBadge = !imageUrl && category !== 'cabinets'
          ? '<div class="material-no-texture-badge" title="Color only - no texture image"></div>'
          : '';

        // Use img tag for materials with images
        // On error: hide the broken image. If the fallback color is just default grey, hide the whole swatch.
        const imgTag = imageUrl
          ? `<img src="${imageUrl}" onerror="this.style.display='none'; if(this.parentElement.style.backgroundColor==='rgb(136, 136, 136)')this.parentElement.style.display='none';">`
          : '';

        return `
        <div class="material-swatch ${selectedMaterial?.id === mat.id ? 'selected' : ''}"
             style="background-color: ${mat.color || '#666'};"
             onclick="selectMaterial('${mat.id}')"
             draggable="true"
             ondragstart="dragMaterialSwatch(event, '${mat.id}')"
             data-material-id="${mat.id}"
             data-url="${imageUrl || ''}"
             data-color="${mat.color || '#666'}"
             title="${tooltip}">
          ${imgTag}
          ${noTextureBadge}
          ${distributorBadge}
          <div class="material-swatch-label">${mat.name}${displayPrice ? `<br><span style="font-size:10px;opacity:0.85${displayPrice.label ? ';color:#10b981' : ''}">$${Number(displayPrice.amount).toFixed(2)}/${mat.unit || 'sf'}${displayPrice.label ? ' ' + displayPrice.label : ''}</span>` : ''}</div>
        </div>
      `;
      }).join('');
    }

    function showMaterialCategory(category, btn) {
      // Update tab buttons
      document.querySelectorAll('.material-tab').forEach(t => t.classList.remove('active'));
      btn.classList.add('active');

      // Reset all filters when switching tabs
      currentBrandFilter = '';
      currentPriceFilter = '';
      currentFinishFilter = '';
      const bf = document.getElementById('brandFilter');
      const pf = document.getElementById('priceFilter');
      const ff = document.getElementById('finishFilter');
      if (bf) bf.value = '';
      if (pf) pf.value = '';
      if (ff) ff.value = '';

      // Render materials for category
      renderMaterials(category);

      // Lazy-load distributor data for this category (async, non-blocking)
      if (typeof loadDistributorDataForCategory === 'function') {
        loadDistributorDataForCategory(category);
      }
    }

    // ==========================================
    // Product Catalog from Website/Store
    // ==========================================
    let storeProducts = [];
    let currentProductCategory = 'countertops';
    let selectedStoreProduct = null;

    // Load products from the search index
    async function loadStoreProducts() {
      try {
        // Try to load from the website's search index
        const basePath = window.location.protocol === 'file:'
          ? window.location.href.replace(/\/tools\/room-designer\/.*$/, '')
          : '';
        const response = await fetch(basePath + '/data/search-index.json');
        const data = await response.json();
        storeProducts = data.products || [];

        // Populate brand filter
        const brands = [...new Set(storeProducts.map(p => p.brand).filter(Boolean))];
        const brandSelect = document.getElementById('productBrandFilter');
        if (brandSelect) {
          brandSelect.innerHTML = '<option value="">All Brands</option>' +
            brands.map(b => `<option value="${b}">${formatBrandName(b)}</option>`).join('');
        }

        // Populate type filter
        const types = [...new Set(storeProducts.map(p => p.type).filter(Boolean))];
        const typeSelect = document.getElementById('productTypeFilter');
        if (typeSelect) {
          typeSelect.innerHTML = '<option value="">All Types</option>' +
            types.map(t => `<option value="${t}">${t}</option>`).join('');
        }

        renderStoreProducts();
      } catch (e) {
        console.warn('Could not load store products:', e);
        const grid = document.getElementById('productCatalogGrid');
        if (grid) {
          grid.innerHTML = '<div class="loading-products">Products unavailable offline</div>';
        }
      }
    }

    // Format brand name for display
    function formatBrandName(brand) {
      const brandNames = {
        'msi-surfaces': 'MSI Surfaces',
        'cosentino': 'Cosentino',
        'radianz-quartz': 'Radianz',
        'lx-hausys': 'LX Hausys',
        'cambria': 'Cambria',
        'daltile': 'Daltile',
        'bedrosians': 'Bedrosians'
      };
      return brandNames[brand] || brand.replace(/-/g, ' ').replace(/\b\w/g, c => c.toUpperCase());
    }

    // Show products by category
    function showProductCategory(category, btn) {
      // Update tabs
      document.querySelectorAll('#productCategoryTabs .material-tab').forEach(t => t.classList.remove('active'));
      btn.classList.add('active');
      currentProductCategory = category;
      renderStoreProducts();
    }

    // Filter store products based on search and dropdowns
    function filterStoreProducts() {
      renderStoreProducts();
    }

    // Render products in the grid
    function renderStoreProducts() {
      const grid = document.getElementById('productCatalogGrid');
      if (!grid) return;

      const searchTerm = (document.getElementById('productSearchInput')?.value || '').toLowerCase();
      const brandFilter = document.getElementById('productBrandFilter')?.value || '';
      const typeFilter = document.getElementById('productTypeFilter')?.value || '';

      // Filter products
      let filtered = storeProducts.filter(p => {
        // Category filter
        if (currentProductCategory === 'countertops' && p.category !== 'countertops') return false;
        if (currentProductCategory === 'tile' && p.category !== 'tile' && !p.type?.toLowerCase().includes('tile')) return false;
        if (currentProductCategory === 'flooring' && p.category !== 'flooring') return false;
        if (currentProductCategory === 'sinks' && !p.type?.toLowerCase().includes('sink')) return false;

        // Search filter
        if (searchTerm && !p.name.toLowerCase().includes(searchTerm) &&
            !p.brand?.toLowerCase().includes(searchTerm) &&
            !p.type?.toLowerCase().includes(searchTerm)) return false;

        // Brand filter
        if (brandFilter && p.brand !== brandFilter) return false;

        // Type filter
        if (typeFilter && p.type !== typeFilter) return false;

        return true;
      });

      // Limit to 50 for performance
      filtered = filtered.slice(0, 50);

      if (filtered.length === 0) {
        grid.innerHTML = '<div class="loading-products">No products found</div>';
        return;
      }

      grid.innerHTML = filtered.map(product => `
        <div class="product-card ${selectedStoreProduct?.slug === product.slug ? 'selected' : ''}"
             onclick="selectStoreProduct('${product.slug}')"
             draggable="true"
             ondragstart="dragStoreProduct(event, '${product.slug}')">
          <img class="product-card-image" src="${product.primaryImage}" alt="${product.name}" loading="lazy"
               onerror="this.src='data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><rect fill=%22%23333%22 width=%22100%22 height=%22100%22/><text x=%2250%22 y=%2255%22 text-anchor=%22middle%22 fill=%22%23666%22 font-size=%2210%22>${encodeURIComponent(product.name.substring(0, 8))}</text></svg>'">
          <div class="product-card-name">${product.name}</div>
          <div class="product-card-meta">${product.type || ''} ${product.brand ? ' ' + formatBrandName(product.brand) : ''}</div>
        </div>
      `).join('');
    }

    // Select a store product
    function selectStoreProduct(slug) {
      const product = storeProducts.find(p => p.slug === slug);
      if (!product) return;

      selectedStoreProduct = product;
      renderStoreProducts();

      // Update hint
      const hint = document.querySelector('.product-hint');
      if (hint) {
        hint.innerHTML = `<strong>${product.name}</strong> selected. Click an element to apply.`;
        hint.style.color = 'var(--gold)';
      }
    }

    // Drag store product
    function dragStoreProduct(event, slug) {
      const product = storeProducts.find(p => p.slug === slug);
      if (product) {
        event.dataTransfer.effectAllowed = 'copy';
        event.dataTransfer.setData('text/plain', JSON.stringify({
          type: 'store-product',
          product: product
        }));
        console.log('Dragging store product:', product.name);
      }
    }

    // Apply store product as material to element
    function applyStoreProductToElement(element) {
      if (!selectedStoreProduct) return false;

      const product = selectedStoreProduct;
      console.log('Applying store product to element:', product.name, 'Element type:', element.type);

      // Check material type compatibility using product type
      const productType = product.type?.toLowerCase() || '';
      if (!canApplyMaterialToElement(productType, element)) {
        return false;
      }

      // Store complete product info on element for 3D rendering
      element.storeProduct = {
        name: product.name,
        slug: product.slug,
        brand: product.brand,
        image: product.primaryImage,
        type: product.type
      };

      // Apply product as material
      element.materialId = product.slug;
      element.materialName = product.name;
      element.materialBrand = product.brand;
      element.texture = product.primaryImage;
      element.label = product.name; // Update label to product name

      // Extract color from product primaryColor if available (for fallback)
      const colorMap = {
        'White': '#f5f5f5',
        'Black': '#2a2a2a',
        'Gray': '#808080',
        'Beige': '#d4c4a8',
        'Brown': '#8b7355',
        'Gold': '#d4a574',
        'Blue': '#4a6b8c',
        'Green': '#4a6b4a'
      };
      element.color = colorMap[product.primaryColor] || '#a0a0a0';

      // Update quote/pricing
      if (product.price) {
        element.priceOverride = parseFloat(product.price) || 0;
      }

      // Load texture for 2D canvas
      if (product.primaryImage) {
        const img = new Image();
        img.crossOrigin = 'anonymous';
        img.onload = () => {
          element.textureImg = img;
          console.log('Texture image loaded for 2D:', product.primaryImage);
          draw();
          // Force 3D scene rebuild to show new texture
          if (currentView === '3d') {
            console.log('Rebuilding 3D scene with new texture');
            init3D();
            render3D();
          }
        };
        img.onerror = () => {
          console.warn('Failed to load product image:', product.primaryImage);
          draw();
        };
        img.src = product.primaryImage;
      } else {
        // No image, still update views
        draw();
        if (currentView === '3d') {
          init3D();
          render3D();
        }
      }

      // Clear selection
      const prevProduct = selectedStoreProduct.name;
      selectedStoreProduct = null;
      renderStoreProducts();

      const hint = document.querySelector('.product-hint');
      if (hint) {
        hint.innerHTML = `Applied <strong>${prevProduct}</strong>!`;
        hint.style.color = 'var(--success)';
        setTimeout(() => {
          hint.innerHTML = 'Click product to apply as material';
          hint.style.color = '';
        }, 2000);
      }

      showSnapFeedback(`Applied ${prevProduct} to ${element.type}`);
      calculateQuote(); // Update pricing
      return true;
    }

    // Initialize product catalog on load
    document.addEventListener('DOMContentLoaded', () => {
      setTimeout(loadStoreProducts, 500);
    });

    function applyFinishToElement(finishId) {
      if (!selectedElement) return;
      selectedElement.finish = finishId;
      markElement3DDirty(selectedElement.id);
      saveUndoState();
      draw();
      update3DScene();
      updateProperties();
    }

    // Drag-and-drop material swatch onto canvas
    function dragMaterialSwatch(event, materialId) {
      event.dataTransfer.setData('material-id', materialId);
      event.dataTransfer.effectAllowed = 'copy';
      // Also select it so the hint updates
      selectMaterial(materialId);
    }

    function selectMaterial(materialId) {
      // Find material in all categories
      for (const [cat, materials] of Object.entries(MATERIALS)) {
        const mat = materials.find(m => m.id === materialId);
        if (mat) {
          selectedMaterial = { ...mat, category: cat };
          break;
        }
      }

      // Update UI
      renderMaterials(currentMaterialCategory);

      // Update hint
      const hint = document.querySelector('.material-hint');
      if (hint && selectedMaterial) {
        const inquireLink = selectedMaterial.productUUID
          ? ` <a href="#" onclick="event.preventDefault(); showProductInquiryModal('${selectedMaterial.id}')" style="color: var(--gold); text-decoration: underline; margin-left: 8px; font-size: 12px;">Inquire</a>`
          : '';
        hint.innerHTML = `<strong>${selectedMaterial.name}</strong> selected. Click an element to apply.${inquireLink}`;
        hint.style.borderColor = 'var(--gold)';
      }
    }

    function applyMaterialToElement(element) {
      if (!selectedMaterial) return false;

      // Use global helper to check material type compatibility
      if (!canApplyMaterialToElement(selectedMaterial.category, element)) {
        return false;
      }

      // Apply the material
      element.color = selectedMaterial.color;
      element.materialId = selectedMaterial.id;
      element.materialName = selectedMaterial.name;
      const matDisplayPrice = (typeof getDisplayPrice === 'function') ? getDisplayPrice(selectedMaterial) : null;
      element.materialPrice = matDisplayPrice ? matDisplayPrice.amount : (selectedMaterial.price || null);
      element.materialBrand = selectedMaterial.brand || null;
      element.materialCategory = selectedMaterial.category || null;

      // Mark element as needing 3D update
      markElement3DDirty(element.id);

      // Recalculate quote with new material pricing
      calculateQuote();

      // Resolve texture URL using helper
      const textureUrl = resolveAssetUrl(selectedMaterial.url);

      // Store resolved texture URL
      element.texture = textureUrl || null;

      // Load texture image if URL exists (using centralized CORS handling)
      if (textureUrl) {
        let loadTimeout;
        const img = loadImageWithCors(
          textureUrl,
          () => {
            clearTimeout(loadTimeout);
            console.log('Texture loaded successfully:', textureUrl);
            element.textureImg = img;
            draw();
            update3DScene();
          },
          (err) => {
            clearTimeout(loadTimeout);
            // Clear texture reference on error
            element.texture = null;
            element.textureImg = null;
            // Fallback: use solid color
            draw();
            showToast(`Could not load texture image, using solid color`, 'error');
          }
        );
        // Set a timeout to handle hung requests
        loadTimeout = setTimeout(() => {
          if (!img.complete) {
            console.warn('Texture load timeout:', textureUrl);
            element.texture = null;
            element.textureImg = null;
            draw();
          }
        }, 10000);
      } else {
        // No texture URL - material only has color (this is normal for some materials)
        element.textureImg = null;
        element.texture = null;
        console.log('Material has no texture URL, using color:', element.color);
      }

      // Clear selection after applying
      const prevMaterial = selectedMaterial.name;
      selectedMaterial = null;
      materialHoverElement = null;
      materialDropHighlight = null;
      renderMaterials(currentMaterialCategory);

      // Reset hint
      const hint = document.querySelector('.material-hint');
      if (hint) {
        hint.innerHTML = `Applied <strong>${prevMaterial}</strong>! Click material, then element to apply.`;
        hint.style.borderColor = 'var(--success)';
        setTimeout(() => {
          hint.innerHTML = 'Click material, then click element to apply';
          hint.style.borderColor = 'var(--border)';
        }, 2000);
      }

      return true;
    }

    // ===== CABINET CATALOG =====
    function renderCabinetCatalog() {
      const catalog = CABINET_CATALOGS[currentCatalog];
      if (!catalog) return;

      const list = document.getElementById('cabinetCatalogList');
      const cabinets = catalog.cabinets[currentCabinetCategory] || [];
      const series = catalog.series[currentCabinetSeries] || { color: '#8B4513' };

      if (cabinets.length === 0) {
        list.innerHTML = '<div style="padding: 20px; text-align: center; color: var(--text-muted); font-size: 11px;">No cabinets in this category</div>';
        return;
      }

      const canShowPrice = PRICING_ACCESS.canViewPricing;
      list.innerHTML = cabinets.map(cab => `
        <div class="cabinet-catalog-item"
             draggable="true"
             ondragstart="dragCatalogCabinet(event, '${cab.sku}')"
             onclick="addCatalogCabinet('${cab.sku}')">
          <div class="cabinet-item-info">
            <span class="cabinet-item-sku">${cab.sku}</span>
            <span class="cabinet-item-name">${cab.name}</span>
            <span class="cabinet-item-size">${cab.width}'  ${cab.height}'</span>
            ${canShowPrice && cab.price ? `<span class="cabinet-item-price">$${cab.price}</span>` : ''}
          </div>
          <button class="cabinet-item-add" onclick="event.stopPropagation(); addCatalogCabinet('${cab.sku}')" title="Add to canvas">+</button>
        </div>
      `).join('');
    }

    function changeCatalog(catalogId) {
      currentCatalog = catalogId;
      const catalog = CABINET_CATALOGS[catalogId];

      // Update series dropdown
      const seriesSelect = document.getElementById('seriesSelect');
      const seriesDiv = document.getElementById('catalogSeries');

      if (catalog && Object.keys(catalog.series).length > 0) {
        seriesDiv.style.display = 'block';

        // Group series by finish type for better organization
        const paintedFinishes = [];
        const woodGrainFinishes = [];
        const otherFinishes = [];

        Object.entries(catalog.series).forEach(([id, s]) => {
          const finish = s.finish || 'wood-grain';
          if (finish === 'painted' || finish === 'matte' || finish === 'gloss') {
            paintedFinishes.push([id, s]);
          } else if (finish === 'wood-grain') {
            woodGrainFinishes.push([id, s]);
          } else {
            otherFinishes.push([id, s]);
          }
        });

        let optionsHtml = '';

        // Add painted finishes group
        if (paintedFinishes.length > 0) {
          optionsHtml += '<optgroup label="Painted / Solid Colors">';
          paintedFinishes.forEach(([id, s]) => {
            optionsHtml += `<option value="${id}" style="background: linear-gradient(90deg, ${s.color} 20px, transparent 20px);">${s.name}</option>`;
          });
          optionsHtml += '</optgroup>';
        }

        // Add wood grain finishes group
        if (woodGrainFinishes.length > 0) {
          optionsHtml += '<optgroup label="Wood Grain Finishes">';
          woodGrainFinishes.forEach(([id, s]) => {
            optionsHtml += `<option value="${id}" style="background: linear-gradient(90deg, ${s.color} 20px, transparent 20px);">${s.name}</option>`;
          });
          optionsHtml += '</optgroup>';
        }

        // Add other finishes
        if (otherFinishes.length > 0) {
          otherFinishes.forEach(([id, s]) => {
            optionsHtml += `<option value="${id}">${s.name}</option>`;
          });
        }

        seriesSelect.innerHTML = optionsHtml;
        currentCabinetSeries = Object.keys(catalog.series)[0];

        // Update finish dropdown to match
        const series = catalog.series[currentCabinetSeries];
        if (series?.finish) {
          const finishSelect = document.getElementById('cabinetFinish');
          if (finishSelect) {
            finishSelect.value = series.finish;
            cabinetSettings.cabinetFinish = series.finish;
          }
        }
      } else {
        seriesDiv.style.display = catalogId === 'custom' ? 'none' : 'block';
      }

      renderCabinetCatalog();
    }

    function changeSeries(seriesId) {
      currentCabinetSeries = seriesId;

      // Update the finish dropdown to match the series finish type
      const catalog = CABINET_CATALOGS[currentCatalog];
      const series = catalog?.series[seriesId];
      if (series?.finish) {
        const finishSelect = document.getElementById('cabinetFinish');
        if (finishSelect) {
          finishSelect.value = series.finish;
          cabinetSettings.cabinetFinish = series.finish;
        }
      }
      // Also update grain type from series
      if (series?.grainType) {
        cabinetSettings.grainType = series.grainType;
      } else if (series?.finish === 'painted' || series?.finish === 'matte' || series?.finish === 'gloss') {
        // Default to flat for painted finishes
        cabinetSettings.grainType = 'flat';
      } else {
        // Default to oak for wood grain finishes
        cabinetSettings.grainType = 'oak';
      }

      renderCabinetCatalog();
    }

    function showCabinetCategory(category, btn) {
      currentCabinetCategory = category;
      document.querySelectorAll('#cabinetCategoryTabs .material-tab').forEach(t => t.classList.remove('active'));
      btn.classList.add('active');
      renderCabinetCatalog();
    }

    function getCatalogCabinet(sku) {
      const catalog = CABINET_CATALOGS[currentCatalog];
      if (!catalog) return null;

      for (const category of Object.values(catalog.cabinets)) {
        const cab = category.find(c => c.sku === sku);
        if (cab) return cab;
      }
      return null;
    }

    function addCatalogCabinet(sku) {
      const cab = getCatalogCabinet(sku);
      if (!cab) return;

      const catalog = CABINET_CATALOGS[currentCatalog];
      const series = catalog.series[currentCabinetSeries] || { color: '#8B4513', name: 'Default', finish: 'wood-grain', grainType: 'oak' };

      // Calculate position (center of visible area)
      const centerX = (canvas.width / 2 - panX) / pixelsPerFoot;
      const centerY = (canvas.height / 2 - panY) / pixelsPerFoot;

      // Use series finish type if defined, otherwise use cabinetSettings
      const finishType = series.finish || cabinetSettings.cabinetFinish || 'wood-grain';
      // Use series grain type if defined, otherwise use cabinetSettings (flat for painted finishes)
      const grainType = series.grainType || (finishType === 'painted' || finishType === 'matte' || finishType === 'gloss' ? 'flat' : cabinetSettings.grainType || 'oak');

      const element = {
        id: Date.now() + Math.random(),
        type: cab.type,
        x: centerX * pixelsPerFoot,
        y: centerY * pixelsPerFoot,
        width: cab.width,
        height: cab.height,
        rotation: 0,
        color: series.color,
        label: `${cab.name} (${series.name})`,
        sku: cab.sku,
        catalog: currentCatalog,
        series: currentCabinetSeries,
        roomId: currentRoom,
        // Store original SKU dimensions for linear fill calculation
        skuWidth: cab.width,  // Original box width (e.g., 3 for 36" cabinet)
        skuHeight: cab.height, // Original box depth
        skuName: cab.name,
        // Cabinet settings - use series finish type for wood grain colors
        construction: cabinetSettings.construction,
        doorStyle: cabinetSettings.doorStyle,
        doorOverlay: cabinetSettings.doorOverlay,
        cabinetFinish: finishType,
        grainType: grainType,
        floorLevel: cabinetSettings.currentFloor
      };

      elements.push(element);
      selectedElement = element;
      updateProperties();
      calculateQuote();
      saveUndoState();
      draw();
    }

    function dragCatalogCabinet(e, sku) {
      e.dataTransfer.setData('catalog-cabinet', sku);
      e.dataTransfer.effectAllowed = 'copy';
    }

    function importCabinetList() {
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = '.csv,.json,.txt';
      input.onchange = async (e) => {
        const file = e.target.files[0];
        if (!file) return;

        const text = await file.text();
        let cabinets = [];

        try {
          if (file.name.endsWith('.json')) {
            // JSON format: array of cabinet objects
            cabinets = JSON.parse(text);
          } else {
            // CSV format: sku,name,width,height,type
            const lines = text.split('\n').filter(l => l.trim());
            const hasHeader = lines[0].toLowerCase().includes('sku') || lines[0].toLowerCase().includes('name');

            (hasHeader ? lines.slice(1) : lines).forEach(line => {
              const parts = line.split(',').map(p => p.trim().replace(/"/g, ''));
              if (parts.length >= 4) {
                cabinets.push({
                  sku: parts[0] || `CUSTOM-${Date.now()}`,
                  name: parts[1] || 'Custom Cabinet',
                  width: parseFloat(parts[2]) || 2,
                  height: parseFloat(parts[3]) || 2,
                  depth: parseFloat(parts[4]) || 2,
                  type: parts[5] || 'base-cabinet'
                });
              }
            });
          }

          if (cabinets.length > 0) {
            CABINET_CATALOGS.custom.cabinets.imported = cabinets;
            currentCatalog = 'custom';
            currentCabinetCategory = 'imported';
            document.getElementById('catalogSelect').value = 'custom';

            // Add imported tab if not exists
            const tabs = document.getElementById('cabinetCategoryTabs');
            if (!tabs.innerHTML.includes('imported')) {
              tabs.innerHTML += '<button class="material-tab" onclick="showCabinetCategory(\'imported\', this)">Imported</button>';
            }

            renderCabinetCatalog();
            alert(`Imported ${cabinets.length} cabinets successfully!`);
          } else {
            alert('No valid cabinet data found in file.');
          }
        } catch (err) {
          console.error('Import error:', err);
          alert('Error importing file. Please check the format.\n\nExpected CSV format:\nsku,name,width,height,depth,type\nB24,Base 24",2,2,2,base-cabinet');
        }
      };
      input.click();
    }

    function selectFloorPlan(id) {
      currentFloorPlan = id;
      const plan = FLOOR_PLANS.find(p => p.id === id);

      // Clear existing walls
      walls = [];

      // Add walls based on floor plan
      if (plan && plan.walls) {
        plan.walls.forEach(w => {
          if (w.type === 'full') {
            // Full room walls
            addWall(0, 0, roomWidth * pixelsPerFoot, CONFIG.WALL_THICKNESS);
            addWall(0, 0, CONFIG.WALL_THICKNESS, roomDepth * pixelsPerFoot);
            addWall(0, roomDepth * pixelsPerFoot - CONFIG.WALL_THICKNESS, roomWidth * pixelsPerFoot, CONFIG.WALL_THICKNESS);
            addWall(roomWidth * pixelsPerFoot - CONFIG.WALL_THICKNESS, 0, CONFIG.WALL_THICKNESS, roomDepth * pixelsPerFoot);
          } else if (w.type === 'rect') {
            const x = w.x * roomWidth * pixelsPerFoot;
            const y = w.y * roomDepth * pixelsPerFoot;
            const width = w.w * roomWidth * pixelsPerFoot;
            const height = w.h * roomDepth * pixelsPerFoot;
            // Add as a filled area indicator
            walls.push({ x, y, width, height, type: 'area' });
          }
        });
      }

      renderFloorPlans();
      draw();
    }

    function addWall(x, y, width, height) {
      walls.push({
        id: Date.now() + Math.random(),
        x, y, width, height,
        type: 'wall',
        color: '#444'
      });
    }

    function fitToScreen() {
      const wrapper = document.getElementById('canvasWrapper');
      const padding = 80;
      const availableWidth = wrapper.clientWidth - padding;
      const availableHeight = wrapper.clientHeight - padding;

      const scaleX = availableWidth / roomWidth;
      const scaleY = availableHeight / roomDepth;

      // Use configured limits for zoom range
      pixelsPerFoot = Math.min(scaleX, scaleY, CONFIG.MAX_PIXELS_PER_FOOT || 200);
      pixelsPerFoot = Math.max(pixelsPerFoot, CONFIG.MIN_PIXELS_PER_FOOT);

      // Center the room in the canvas
      panX = (wrapper.clientWidth - roomWidth * pixelsPerFoot) / 2;
      panY = (wrapper.clientHeight - roomDepth * pixelsPerFoot) / 2;

      document.getElementById('scaleMode').value = 'fit';
      updateCanvasSize();
    }

    function updateScale() {
      const mode = document.getElementById('scaleMode').value;
      if (mode === 'fit') {
        fitToScreen();
      } else {
        pixelsPerFoot = parseInt(mode);
        // Re-center when changing scale
        const wrapper = document.getElementById('canvasWrapper');
        panX = (wrapper.clientWidth - roomWidth * pixelsPerFoot) / 2;
        panY = (wrapper.clientHeight - roomDepth * pixelsPerFoot) / 2;
        updateCanvasSize();
      }
    }

    function updateCanvasSize() {
      const wrapper = document.getElementById('canvasWrapper');

      // Guard against missing elements (e.g., after share link error overlay)
      if (!wrapper || !canvas) return;

      // Canvas fills entire workspace
      canvas.width = wrapper.clientWidth;
      canvas.height = wrapper.clientHeight;

      const sizeEl = document.getElementById('canvasSize');
      if (sizeEl) {
        sizeEl.textContent = `${roomWidth}'  ${roomDepth}'`;
      }

      draw();
    }

    function setupEventListeners() {
      // Mouse events
      canvas.addEventListener('mousedown', onMouseDown);
      canvas.addEventListener('mousemove', onMouseMove);
      canvas.addEventListener('mouseup', onMouseUp);
      canvas.addEventListener('mouseleave', onMouseUp);
      canvas.addEventListener('contextmenu', onContextMenu);
      canvas.addEventListener('dblclick', onDoubleClick);
      canvas.addEventListener('wheel', onWheel, { passive: false });

      // Touch events for mobile/tablet support
      canvas.addEventListener('touchstart', onTouchStart, { passive: false });
      canvas.addEventListener('touchmove', onTouchMove, { passive: false });
      canvas.addEventListener('touchend', onTouchEnd, { passive: false });
      canvas.addEventListener('touchcancel', onTouchEnd, { passive: false });

      document.addEventListener('keydown', onKeyDown);
      document.addEventListener('keyup', onKeyUp);

      document.addEventListener('click', (e) => {
        if (!e.target.closest('.context-menu')) {
          hideContextMenu();
        }
      });

      window.addEventListener('resize', () => {
        updateCanvasSize();
        const scaleMode = document.getElementById('scaleMode');
        if (scaleMode && scaleMode.value === 'fit') {
          fitToScreen();
        }
      });
    }

    // ===== TOUCH EVENT HANDLERS =====
    let lastTouchTime = 0;
    let touchStartPos = null;
    let pinchStartDistance = null;
    let pinchStartZoom = null;

    function getTouchPos(touch) {
      const rect = canvas.getBoundingClientRect();
      return {
        clientX: touch.clientX,
        clientY: touch.clientY,
        offsetX: touch.clientX - rect.left,
        offsetY: touch.clientY - rect.top
      };
    }

    function onTouchStart(e) {
      e.preventDefault();

      if (e.touches.length === 2) {
        // Pinch zoom start
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        pinchStartDistance = Math.sqrt(dx * dx + dy * dy);
        pinchStartZoom = pixelsPerFoot;
        return;
      }

      if (e.touches.length === 1) {
        const touch = e.touches[0];
        const touchPos = getTouchPos(touch);
        touchStartPos = { x: touchPos.offsetX, y: touchPos.offsetY };

        // Detect double-tap
        const now = Date.now();
        if (now - lastTouchTime < 300) {
          // Double tap - trigger double click handler
          onDoubleClick({ offsetX: touchPos.offsetX, offsetY: touchPos.offsetY, preventDefault: () => {} });
          lastTouchTime = 0;
          return;
        }
        lastTouchTime = now;

        // Simulate mousedown
        onMouseDown({
          ...touchPos,
          button: 0,
          preventDefault: () => {},
          stopPropagation: () => {}
        });
      }
    }

    function onTouchMove(e) {
      e.preventDefault();

      if (e.touches.length === 2 && pinchStartDistance) {
        // Pinch zoom
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        const scale = distance / pinchStartDistance;

        // Calculate zoom center
        const centerX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
        const centerY = (e.touches[0].clientY + e.touches[1].clientY) / 2;
        const rect = canvas.getBoundingClientRect();
        const canvasCenterX = centerX - rect.left;
        const canvasCenterY = centerY - rect.top;

        // Apply zoom
        const newZoom = Math.max(15, Math.min(100, pinchStartZoom * scale));
        if (newZoom !== pixelsPerFoot) {
          const worldX = (canvasCenterX - panX) / pixelsPerFoot;
          const worldY = (canvasCenterY - panY) / pixelsPerFoot;
          pixelsPerFoot = newZoom;
          panX = canvasCenterX - worldX * pixelsPerFoot;
          panY = canvasCenterY - worldY * pixelsPerFoot;
          updateZoomDisplay();
          draw();
        }
        return;
      }

      if (e.touches.length === 1) {
        const touch = e.touches[0];
        const touchPos = getTouchPos(touch);

        // Simulate mousemove
        onMouseMove({
          ...touchPos,
          buttons: 1,
          preventDefault: () => {},
          stopPropagation: () => {}
        });
      }
    }

    function onTouchEnd(e) {
      e.preventDefault();
      pinchStartDistance = null;
      pinchStartZoom = null;

      // Simulate mouseup
      onMouseUp({
        button: 0,
        preventDefault: () => {},
        stopPropagation: () => {}
      });
    }

    function setupDragDrop() {
      document.addEventListener('dragstart', (e) => {
        if (e.target.classList.contains('element-item')) {
          e.dataTransfer.setData('element-type', e.target.dataset.type);
          e.dataTransfer.effectAllowed = 'copy';
          e.target.style.opacity = '0.5';
          isHtmlDragging = true;
        }
      });

      document.addEventListener('dragend', (e) => {
        if (e.target.classList.contains('element-item')) {
          e.target.style.opacity = '1';
        }
        isHtmlDragging = false;
      });

      canvas.addEventListener('dragover', (e) => {
        e.preventDefault();
        e.dataTransfer.dropEffect = 'copy';
        isHtmlDragging = true;

        // Highlight element under cursor during material drag
        if (selectedMaterial) {
          const rect = canvas.getBoundingClientRect();
          const screenX = e.clientX - rect.left;
          const screenY = e.clientY - rect.top;
          const { x, y } = screenToWorld(screenX, screenY);
          const hit = [...elements].reverse().find(el => isPointInElement(x, y, el));
          const newHighlight = hit ? hit.id : null;
          if (newHighlight !== materialDropHighlight) {
            materialDropHighlight = newHighlight;
            draw();
          }
        }
      });
      canvas.addEventListener('dragleave', () => {
        isHtmlDragging = false;
        if (materialDropHighlight) {
          materialDropHighlight = null;
          draw();
        }
      });
      canvas.addEventListener('drop', (e) => {
        isHtmlDragging = false;
        onDrop(e);
      });
    }

    // ===== DRAWING =====
    function draw() {
      if (!ctx) return;

      // Clear entire canvas with dark background
      ctx.fillStyle = '#0d0d15';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Apply pan transformation
      ctx.save();
      ctx.translate(panX, panY);

      // Draw infinite grid
      drawGrid();

      // Draw room boundary (the actual room shape)
      drawRoomBoundary();

      // Draw floor plan areas
      drawFloorPlanAreas();

      // Draw walls
      drawWalls();

      // Draw elements
      drawElements();

      // Draw snap guides when dragging cabinets
      drawSnapGuides();

      // Draw work triangle overlay if enabled
      drawWorkTriangle();

      // Draw layout tool preview
      drawLayoutToolPreview();

      ctx.restore();

      document.getElementById('elementCount').textContent = `${elements.length} element${elements.length !== 1 ? 's' : ''}`;
      calculateQuote();

      // Update element layer list panel
      updateElementList();
    }

    // Draw snap guides when dragging cabinets near walls
    function drawSnapGuides() {
      if (!isDragging || !selectedElement) return;

      const isCabinetType = ['base-cabinet', 'wall-cabinet', 'tall-cabinet', 'corner-cabinet',
                             'drawer-base', 'sink-base', 'lazy-susan',
                             'island', 'countertop', 'sink', 'stove', 'dishwasher',
                             'refrigerator', 'oven'].includes(selectedElement.type);

      if (!isCabinetType) return;

      // Draw hint text at top of canvas
      ctx.save();
      ctx.setTransform(1, 0, 0, 1, 0, 0); // Reset to screen coordinates
      ctx.font = '12px Inter';
      ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
      ctx.textAlign = 'center';
      ctx.fillText('Hold SHIFT for free placement (no snap/rotate)', canvas.width / 2, 25);
      ctx.restore();

      const snapZone = pixelsPerFoot * 0.5; // Match the reduced snap distance
      const roomW = roomWidth * pixelsPerFoot;
      const roomH = roomDepth * pixelsPerFoot;

      const elX = selectedElement.x;
      const elY = selectedElement.y;
      const elW = selectedElement.width * pixelsPerFoot;
      const elH = selectedElement.height * pixelsPerFoot;

      ctx.save();
      ctx.setLineDash([8, 4]);
      ctx.lineWidth = 2;

      // Back wall snap guide (top)
      if (Math.abs(elY) < snapZone) {
        ctx.strokeStyle = '#4CAF50';
        ctx.beginPath();
        ctx.moveTo(-50, 0);
        ctx.lineTo(roomW + 50, 0);
        ctx.stroke();
        // Highlight indicator
        ctx.fillStyle = 'rgba(76, 175, 80, 0.2)';
        ctx.fillRect(-50, 0, roomW + 100, snapZone);
      }

      // Left wall snap guide
      if (Math.abs(elX) < snapZone) {
        ctx.strokeStyle = '#2196F3';
        ctx.beginPath();
        ctx.moveTo(0, -50);
        ctx.lineTo(0, roomH + 50);
        ctx.stroke();
        ctx.fillStyle = 'rgba(33, 150, 243, 0.2)';
        ctx.fillRect(0, -50, snapZone, roomH + 100);
      }

      // Right wall snap guide
      if (Math.abs((elX + elW) - roomW) < snapZone) {
        ctx.strokeStyle = '#FF9800';
        ctx.beginPath();
        ctx.moveTo(roomW, -50);
        ctx.lineTo(roomW, roomH + 50);
        ctx.stroke();
        ctx.fillStyle = 'rgba(255, 152, 0, 0.2)';
        ctx.fillRect(roomW - snapZone, -50, snapZone, roomH + 100);
      }

      // Front wall snap guide (bottom)
      if (Math.abs((elY + elH) - roomH) < snapZone) {
        ctx.strokeStyle = '#9C27B0';
        ctx.beginPath();
        ctx.moveTo(-50, roomH);
        ctx.lineTo(roomW + 50, roomH);
        ctx.stroke();
        ctx.fillStyle = 'rgba(156, 39, 176, 0.2)';
        ctx.fillRect(-50, roomH - snapZone, roomW + 100, snapZone);
      }

      // Corner indicators for corner cabinets
      const isCornerCabinet = ['corner-cabinet', 'lazy-susan'].includes(selectedElement.type);
      if (isCornerCabinet) {
        const cornerZone = pixelsPerFoot * 1.0;

        // Top-left corner
        if (Math.abs(elX) < cornerZone && Math.abs(elY) < cornerZone) {
          ctx.fillStyle = 'rgba(76, 175, 80, 0.4)';
          ctx.beginPath();
          ctx.arc(0, 0, cornerZone, 0, Math.PI / 2);
          ctx.lineTo(0, 0);
          ctx.fill();
        }

        // Top-right corner
        if (Math.abs((elX + elW) - roomW) < cornerZone && Math.abs(elY) < cornerZone) {
          ctx.fillStyle = 'rgba(255, 152, 0, 0.4)';
          ctx.beginPath();
          ctx.arc(roomW, 0, cornerZone, Math.PI / 2, Math.PI);
          ctx.lineTo(roomW, 0);
          ctx.fill();
        }

        // Bottom-left corner
        if (Math.abs(elX) < cornerZone && Math.abs((elY + elH) - roomH) < cornerZone) {
          ctx.fillStyle = 'rgba(33, 150, 243, 0.4)';
          ctx.beginPath();
          ctx.arc(0, roomH, cornerZone, -Math.PI / 2, 0);
          ctx.lineTo(0, roomH);
          ctx.fill();
        }

        // Bottom-right corner
        if (Math.abs((elX + elW) - roomW) < cornerZone && Math.abs((elY + elH) - roomH) < cornerZone) {
          ctx.fillStyle = 'rgba(156, 39, 176, 0.4)';
          ctx.beginPath();
          ctx.arc(roomW, roomH, cornerZone, Math.PI, Math.PI * 1.5);
          ctx.lineTo(roomW, roomH);
          ctx.fill();
        }
      }

      ctx.restore();
    }

    // Toggle work triangle visualization
    function toggleWorkTriangle() {
      showWorkTriangle = !showWorkTriangle;
      const btn = document.querySelector('.validation-toggle');
      if (btn) {
        btn.classList.toggle('active', showWorkTriangle);
      }
      if (showWorkTriangle) {
        runValidation();
      }
      draw();
    }

    function drawGrid() {
      const gridSize = pixelsPerFoot / CONFIG.GRID_SUBDIVISIONS;
      const roomW = roomWidth * pixelsPerFoot;
      const roomH = roomDepth * pixelsPerFoot;

      // Calculate visible area for grid
      const startX = -panX - pixelsPerFoot;
      const startY = -panY - pixelsPerFoot;
      const endX = canvas.width - panX + pixelsPerFoot;
      const endY = canvas.height - panY + pixelsPerFoot;

      // Sub-grid (faint lines)
      ctx.strokeStyle = 'rgba(255,255,255,0.02)';
      ctx.lineWidth = 1;

      const gridStartX = Math.floor(startX / gridSize) * gridSize;
      const gridStartY = Math.floor(startY / gridSize) * gridSize;

      for (let x = gridStartX; x < endX; x += gridSize) {
        ctx.beginPath();
        ctx.moveTo(x, startY);
        ctx.lineTo(x, endY);
        ctx.stroke();
      }
      for (let y = gridStartY; y < endY; y += gridSize) {
        ctx.beginPath();
        ctx.moveTo(startX, y);
        ctx.lineTo(endX, y);
        ctx.stroke();
      }

      // Main grid (1ft lines)
      ctx.strokeStyle = 'rgba(255,255,255,0.06)';
      const mainStartX = Math.floor(startX / pixelsPerFoot) * pixelsPerFoot;
      const mainStartY = Math.floor(startY / pixelsPerFoot) * pixelsPerFoot;

      for (let x = mainStartX; x < endX; x += pixelsPerFoot) {
        ctx.beginPath();
        ctx.moveTo(x, startY);
        ctx.lineTo(x, endY);
        ctx.stroke();
      }
      for (let y = mainStartY; y < endY; y += pixelsPerFoot) {
        ctx.beginPath();
        ctx.moveTo(startX, y);
        ctx.lineTo(endX, y);
        ctx.stroke();
      }
    }

    // Room resize state
    let isResizingRoom = false;
    let roomResizeHandle = null; // 'e', 's', 'se' (east, south, southeast corner)
    let roomResizeStart = { x: 0, y: 0, width: 0, depth: 0 };
    const ROOM_HANDLE_SIZE = 16;

    // Get room resize handles (only right, bottom, and bottom-right corner)
    function getRoomResizeHandles() {
      const roomW = roomWidth * pixelsPerFoot;
      const roomH = roomDepth * pixelsPerFoot;
      const hs = ROOM_HANDLE_SIZE;

      return {
        e: { x: roomW, y: roomH / 2, cursor: 'ew-resize' },    // Right edge center
        s: { x: roomW / 2, y: roomH, cursor: 'ns-resize' },    // Bottom edge center
        se: { x: roomW, y: roomH, cursor: 'nwse-resize' }      // Bottom-right corner
      };
    }

    // Check if point is on a room resize handle
    function getRoomHandleAtPosition(worldX, worldY) {
      const handles = getRoomResizeHandles();
      const hs = ROOM_HANDLE_SIZE + 6; // Slightly larger hit area

      for (const [name, handle] of Object.entries(handles)) {
        if (worldX >= handle.x - hs/2 && worldX <= handle.x + hs/2 &&
            worldY >= handle.y - hs/2 && worldY <= handle.y + hs/2) {
          return { name, ...handle };
        }
      }
      return null;
    }

    function drawRoomBoundary() {
      const roomW = roomWidth * pixelsPerFoot;
      const roomH = roomDepth * pixelsPerFoot;

      // Room floor (lighter area)
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, roomW, roomH);

      // Room border with measurements
      ctx.strokeStyle = '#4a4a6a';
      ctx.lineWidth = 3;
      ctx.strokeRect(0, 0, roomW, roomH);

      // Corner markers (static - top-left, top-right, bottom-left)
      const markerSize = 12;
      ctx.fillStyle = '#6366f1';
      ctx.fillRect(-markerSize/2, -markerSize/2, markerSize, markerSize);
      ctx.fillRect(roomW - markerSize/2, -markerSize/2, markerSize, markerSize);
      ctx.fillRect(-markerSize/2, roomH - markerSize/2, markerSize, markerSize);

      // Room resize handles (interactive - right edge, bottom edge, bottom-right corner)
      const handles = getRoomResizeHandles();
      const hs = ROOM_HANDLE_SIZE;

      // Right edge handle (east)
      ctx.fillStyle = isResizingRoom && roomResizeHandle === 'e' ? '#22c55e' : '#f97316';
      ctx.fillRect(handles.e.x - hs/2, handles.e.y - hs, hs, hs * 2);
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 2;
      ctx.strokeRect(handles.e.x - hs/2, handles.e.y - hs, hs, hs * 2);
      // Arrow indicator
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 12px Inter';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('', handles.e.x, handles.e.y);

      // Bottom edge handle (south)
      ctx.fillStyle = isResizingRoom && roomResizeHandle === 's' ? '#22c55e' : '#f97316';
      ctx.fillRect(handles.s.x - hs, handles.s.y - hs/2, hs * 2, hs);
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 2;
      ctx.strokeRect(handles.s.x - hs, handles.s.y - hs/2, hs * 2, hs);
      // Arrow indicator
      ctx.fillText('', handles.s.x, handles.s.y);
      ctx.save();
      ctx.translate(handles.s.x, handles.s.y);
      ctx.rotate(Math.PI / 2);
      ctx.fillText('', 0, 0);
      ctx.restore();

      // Bottom-right corner handle (southeast) - main resize handle
      ctx.fillStyle = isResizingRoom && roomResizeHandle === 'se' ? '#22c55e' : '#ef4444';
      ctx.beginPath();
      ctx.moveTo(roomW - hs * 1.5, roomH);
      ctx.lineTo(roomW, roomH);
      ctx.lineTo(roomW, roomH - hs * 1.5);
      ctx.closePath();
      ctx.fill();
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 2;
      ctx.stroke();
      // Diagonal resize indicator
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 14px Inter';
      ctx.fillText('', roomW - hs * 0.6, roomH - hs * 0.4);

      // Dimension labels along edges
      ctx.fillStyle = 'rgba(255,255,255,0.6)';
      ctx.font = `bold ${Math.max(12, pixelsPerFoot / 3)}px Inter`;
      ctx.textAlign = 'center';

      // Top dimension
      ctx.fillText(`${roomWidth}'`, roomW / 2, -10);
      // Left dimension
      ctx.save();
      ctx.translate(-10, roomH / 2);
      ctx.rotate(-Math.PI / 2);
      ctx.fillText(`${roomDepth}'`, 0, 0);
      ctx.restore();

      // Foot markers along room edges
      ctx.fillStyle = 'rgba(255,255,255,0.4)';
      ctx.font = `${Math.max(9, pixelsPerFoot / 5)}px Inter`;
      for (let x = pixelsPerFoot; x < roomW; x += pixelsPerFoot) {
        ctx.fillText(`${Math.round(x / pixelsPerFoot)}'`, x, -25);
        // Tick mark
        ctx.strokeStyle = 'rgba(255,255,255,0.3)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, -6);
        ctx.stroke();
      }
      for (let y = pixelsPerFoot; y < roomH; y += pixelsPerFoot) {
        ctx.save();
        ctx.translate(-25, y);
        ctx.rotate(-Math.PI / 2);
        ctx.fillText(`${Math.round(y / pixelsPerFoot)}'`, 0, 0);
        ctx.restore();
        // Tick mark
        ctx.strokeStyle = 'rgba(255,255,255,0.3)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(-6, y);
        ctx.stroke();
      }
    }

    function drawFloorPlanAreas() {
      walls.filter(w => w.type === 'area').forEach(area => {
        ctx.fillStyle = 'rgba(60, 60, 80, 0.6)';
        ctx.fillRect(area.x, area.y, area.width, area.height);
        ctx.strokeStyle = '#666';
        ctx.lineWidth = 2;
        ctx.strokeRect(area.x, area.y, area.width, area.height);
      });
    }

    function drawWalls() {
      walls.filter(w => w.type === 'wall').forEach(wall => {
        ctx.fillStyle = wall.color;
        ctx.fillRect(wall.x, wall.y, wall.width, wall.height);
      });
    }

    // ===== RENDERING HELPER FUNCTIONS =====

    // Adjust a hex color by amount (-255 to 255)
    function adjustColor(color, amount) {
      if (!color || color.charAt(0) !== '#') return color;
      let r = parseInt(color.slice(1, 3), 16);
      let g = parseInt(color.slice(3, 5), 16);
      let b = parseInt(color.slice(5, 7), 16);
      r = Math.max(0, Math.min(255, r + amount));
      g = Math.max(0, Math.min(255, g + amount));
      b = Math.max(0, Math.min(255, b + amount));
      return `#${r.toString(16).padStart(2,'0')}${g.toString(16).padStart(2,'0')}${b.toString(16).padStart(2,'0')}`;
    }

    // Draw wood grain pattern
    function drawWoodGrain(ctx, x, y, w, h, baseColor, opacity = 1) {
      // Guard against invalid dimensions
      w = Math.abs(w);
      h = Math.abs(h);
      if (w < 1 || h < 1) return;

      const seed = Math.floor(x * 7 + y * 13) % 1000;
      const rand = (n) => ((seed + n * 31) % 100) / 100;

      ctx.save();
      ctx.globalAlpha = opacity;

      // Subtle wood grain lines
      ctx.strokeStyle = 'rgba(0,0,0,0.12)';
      ctx.lineWidth = 0.8;

      const grainCount = Math.floor(h / 6);
      for (let i = 0; i < grainCount; i++) {
        const gy = y + 4 + i * (h - 8) / grainCount;
        const waveAmp = 1 + rand(i) * 2;
        const waveFreq = 0.02 + rand(i + 50) * 0.03;

        ctx.beginPath();
        ctx.moveTo(x + 2, gy);

        for (let gx = x + 2; gx < x + w - 2; gx += 3) {
          const yOffset = Math.sin((gx - x) * waveFreq + rand(i + 100) * Math.PI) * waveAmp;
          ctx.lineTo(gx, gy + yOffset);
        }
        ctx.stroke();
      }

      // Occasional darker grain knots
      ctx.fillStyle = 'rgba(0,0,0,0.08)';
      const knotCount = Math.floor(w * h / 3000);
      for (let k = 0; k < knotCount; k++) {
        const kx = x + rand(k * 3) * w * 0.8 + w * 0.1;
        const ky = y + rand(k * 5) * h * 0.8 + h * 0.1;
        const kr = 2 + rand(k * 7) * 4;
        ctx.beginPath();
        ctx.ellipse(kx, ky, Math.abs(kr), Math.abs(kr * 0.6), rand(k * 11) * Math.PI, 0, Math.PI * 2);
        ctx.fill();
      }

      ctx.restore();
    }

    // Draw a single cabinet door with shaker style
    function drawCabinetDoor(ctx, x, y, w, h, color) {
      // Guard against invalid dimensions
      w = Math.abs(w);
      h = Math.abs(h);
      if (w < 1 || h < 1) return;

      // Door background
      ctx.fillStyle = color;
      ctx.fillRect(x, y, w, h);

      // Wood grain
      drawWoodGrain(ctx, x, y, w, h, color, 0.5);

      // Shaker panel inset
      const inset = Math.min(10, w * 0.1, h * 0.08);
      const px = x + inset;
      const py = y + inset;
      const pw = w - inset * 2;
      const ph = h - inset * 2;

      // Panel shadow (inset effect)
      ctx.fillStyle = 'rgba(0,0,0,0.15)';
      ctx.fillRect(px, py, pw, 2);
      ctx.fillRect(px, py, 2, ph);

      // Panel highlight
      ctx.fillStyle = 'rgba(255,255,255,0.1)';
      ctx.fillRect(px, py + ph - 2, pw, 2);
      ctx.fillRect(px + pw - 2, py, 2, ph);

      // Inner panel darker
      ctx.fillStyle = 'rgba(0,0,0,0.05)';
      ctx.fillRect(px + 2, py + 2, pw - 4, ph - 4);

      // Edge highlights
      ctx.fillStyle = 'rgba(255,255,255,0.1)';
      ctx.fillRect(x, y, w, 2);
      ctx.fillRect(x, y, 2, h);

      ctx.fillStyle = 'rgba(0,0,0,0.12)';
      ctx.fillRect(x, y + h - 2, w, 2);
      ctx.fillRect(x + w - 2, y, 2, h);

      // Handle
      const handleLen = Math.min(18, h * 0.3);
      const handleX = x + w - 8;
      const handleY = y + h / 2 - handleLen / 2;
      ctx.fillStyle = 'rgba(180,180,180,0.85)';
      ctx.fillRect(handleX, handleY, 3, handleLen);
      ctx.fillStyle = 'rgba(255,255,255,0.3)';
      ctx.fillRect(handleX, handleY, 1, handleLen);
    }

    // Draw countertop surface with material-specific patterns
    function drawCountertopSurface(ctx, x, y, w, h, color, materialName) {
      const name = (materialName || '').toLowerCase();
      const seed = Math.floor(x * 11 + y * 17) % 1000;
      const rand = (n) => ((seed + n * 23) % 100) / 100;

      // Determine material type from name
      let materialType = 'granite'; // default
      if (name.includes('marble') || name.includes('calacatta') || name.includes('carrara') || name.includes('statuario')) {
        materialType = 'marble';
      } else if (name.includes('quartz') || name.includes('silestone') || name.includes('caesarstone')) {
        materialType = 'quartz';
      } else if (name.includes('quartzite') || name.includes('taj') || name.includes('fantasy')) {
        materialType = 'quartzite';
      } else if (name.includes('concrete') || name.includes('cement')) {
        materialType = 'concrete';
      } else if (name.includes('butcher') || name.includes('wood') || name.includes('walnut') || name.includes('maple')) {
        materialType = 'wood';
      }

      ctx.save();

      switch (materialType) {
        case 'marble':
          // Marble: Dramatic veining on light background
          // Base with subtle variation
          const marbleGrad = ctx.createLinearGradient(x, y, x + w, y + h);
          marbleGrad.addColorStop(0, color);
          marbleGrad.addColorStop(0.5, adjustColor(color, 8));
          marbleGrad.addColorStop(1, adjustColor(color, -5));
          ctx.fillStyle = marbleGrad;
          ctx.fillRect(x, y, w, h);

          // Primary dramatic veins
          ctx.strokeStyle = 'rgba(80,80,90,0.35)';
          ctx.lineWidth = 2.5;
          for (let i = 0; i < 3; i++) {
            ctx.beginPath();
            const startX = x + rand(i) * w * 0.3;
            const startY = y + rand(i + 10) * h;
            ctx.moveTo(startX, startY);

            // Create flowing vein path
            const cp1x = x + w * (0.2 + rand(i + 20) * 0.3);
            const cp1y = y + h * rand(i + 30);
            const cp2x = x + w * (0.5 + rand(i + 40) * 0.3);
            const cp2y = y + h * rand(i + 50);
            const endX = x + w - rand(i + 60) * w * 0.2;
            const endY = y + rand(i + 70) * h;

            ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, endX, endY);
            ctx.stroke();

            // Feathered edges on main veins
            ctx.strokeStyle = 'rgba(80,80,90,0.15)';
            ctx.lineWidth = 5;
            ctx.stroke();
          }

          // Secondary thinner veins
          ctx.strokeStyle = 'rgba(100,100,110,0.2)';
          ctx.lineWidth = 1;
          for (let i = 0; i < 6; i++) {
            ctx.beginPath();
            ctx.moveTo(x + rand(i + 80) * w, y + rand(i + 90) * h);
            ctx.quadraticCurveTo(
              x + w * rand(i + 100),
              y + h * rand(i + 110),
              x + rand(i + 120) * w,
              y + rand(i + 130) * h
            );
            ctx.stroke();
          }
          break;

        case 'quartz':
          // Quartz: Uniform with subtle sparkle/flecks
          ctx.fillStyle = color;
          ctx.fillRect(x, y, w, h);

          // Fine uniform speckling
          const speckleCount = Math.floor(w * h / 40);
          for (let i = 0; i < speckleCount; i++) {
            const sx = x + rand(i) * w;
            const sy = y + rand(i + 500) * h;
            const brightness = rand(i + 1000) > 0.5 ? 'rgba(255,255,255,' : 'rgba(0,0,0,';
            const alpha = 0.05 + rand(i + 1500) * 0.1;
            ctx.fillStyle = brightness + alpha + ')';
            ctx.fillRect(sx, sy, 1.5, 1.5);
          }

          // Occasional larger sparkle spots
          ctx.fillStyle = 'rgba(255,255,255,0.25)';
          for (let i = 0; i < speckleCount / 20; i++) {
            const sx = x + rand(i + 2000) * w;
            const sy = y + rand(i + 2500) * h;
            ctx.beginPath();
            ctx.arc(sx, sy, 1, 0, Math.PI * 2);
            ctx.fill();
          }
          break;

        case 'quartzite':
          // Quartzite: Natural flowing patterns with crystalline look
          ctx.fillStyle = color;
          ctx.fillRect(x, y, w, h);

          // Flowing wave patterns
          ctx.strokeStyle = 'rgba(255,255,255,0.15)';
          ctx.lineWidth = 3;
          for (let i = 0; i < 5; i++) {
            ctx.beginPath();
            const startY = y + (i / 5) * h + rand(i) * h * 0.1;
            ctx.moveTo(x, startY);

            for (let px = 0; px <= w; px += 20) {
              const py = startY + Math.sin((px / w) * Math.PI * (2 + rand(i + 10))) * h * 0.1 * rand(i + 20);
              ctx.lineTo(x + px, py);
            }
            ctx.stroke();
          }

          // Crystalline shimmer
          ctx.fillStyle = 'rgba(255,255,255,0.08)';
          for (let i = 0; i < 30; i++) {
            const cx = x + rand(i + 300) * w;
            const cy = y + rand(i + 400) * h;
            ctx.beginPath();
            ctx.moveTo(cx, cy - 3);
            ctx.lineTo(cx + 2, cy);
            ctx.lineTo(cx, cy + 3);
            ctx.lineTo(cx - 2, cy);
            ctx.closePath();
            ctx.fill();
          }
          break;

        case 'concrete':
          // Concrete: Matte with subtle texture
          ctx.fillStyle = color;
          ctx.fillRect(x, y, w, h);

          // Subtle aggregate texture
          ctx.fillStyle = 'rgba(0,0,0,0.03)';
          for (let i = 0; i < w * h / 100; i++) {
            const cx = x + rand(i) * w;
            const cy = y + rand(i + 500) * h;
            ctx.beginPath();
            ctx.arc(cx, cy, 1 + rand(i + 1000) * 2, 0, Math.PI * 2);
            ctx.fill();
          }

          // Subtle variation patches
          for (let i = 0; i < 4; i++) {
            ctx.fillStyle = rand(i) > 0.5 ? 'rgba(0,0,0,0.02)' : 'rgba(255,255,255,0.02)';
            ctx.beginPath();
            ctx.ellipse(
              x + rand(i + 100) * Math.abs(w),
              y + rand(i + 200) * Math.abs(h),
              Math.abs(rand(i + 300) * w * 0.3) || 1,
              Math.abs(rand(i + 400) * h * 0.3) || 1,
              rand(i + 500) * Math.PI,
              0, Math.PI * 2
            );
            ctx.fill();
          }
          break;

        case 'wood':
          // Wood countertop: butcher block style
          drawWoodGrain(ctx, x, y, w, h, color);

          // Butcher block strips
          const stripWidth = pixelsPerFoot * 0.25;
          ctx.strokeStyle = 'rgba(0,0,0,0.1)';
          ctx.lineWidth = 1;
          for (let sx = x + stripWidth; sx < x + w; sx += stripWidth) {
            ctx.beginPath();
            ctx.moveTo(sx, y);
            ctx.lineTo(sx, y + h);
            ctx.stroke();
          }
          break;

        default: // granite
          // Granite: Speckled with various mineral colors
          ctx.fillStyle = color;
          ctx.fillRect(x, y, w, h);

          // Multi-colored speckles (mineral flecks)
          const mineralColors = [
            'rgba(0,0,0,0.3)',
            'rgba(255,255,255,0.25)',
            'rgba(150,150,150,0.2)',
            'rgba(100,80,60,0.15)',
            'rgba(60,60,70,0.2)'
          ];

          const graniteSpeckles = Math.floor(w * h / 25);
          for (let i = 0; i < graniteSpeckles; i++) {
            const gx = x + rand(i) * w;
            const gy = y + rand(i + 500) * h;
            const colorIdx = Math.floor(rand(i + 1000) * mineralColors.length);
            ctx.fillStyle = mineralColors[colorIdx];
            const size = 1 + rand(i + 1500) * 2;
            ctx.fillRect(gx, gy, size, size);
          }

          // Larger mineral clusters
          for (let i = 0; i < graniteSpeckles / 30; i++) {
            const cx = x + rand(i + 2000) * w;
            const cy = y + rand(i + 2500) * h;
            const ccolor = mineralColors[Math.floor(rand(i + 3000) * mineralColors.length)];
            ctx.fillStyle = ccolor;
            ctx.beginPath();
            ctx.arc(cx, cy, 2 + rand(i + 3500) * 3, 0, Math.PI * 2);
            ctx.fill();
          }
      }

      // Edge profile (bullnose/eased edge look)
      // Top edge highlight
      ctx.fillStyle = 'rgba(255,255,255,0.2)';
      ctx.fillRect(x, y, w, 3);
      ctx.fillRect(x, y, 3, h);

      // Bottom edge shadow
      ctx.fillStyle = 'rgba(0,0,0,0.25)';
      ctx.fillRect(x, y + h - 3, w, 3);
      ctx.fillRect(x + w - 3, y, 3, h);

      // Outer border
      ctx.strokeStyle = 'rgba(255,255,255,0.15)';
      ctx.lineWidth = 1;
      ctx.strokeRect(x + 1, y + 1, w - 2, h - 2);

      ctx.restore();
    }

    // Draw architectural details for each element type
    function drawElementDetails(el, x, y, w, h) {
      ctx.strokeStyle = 'rgba(255,255,255,0.4)';
      ctx.fillStyle = 'rgba(255,255,255,0.1)';
      ctx.lineWidth = 1;

      const type = el.type;
      const padding = Math.min(w, h) * 0.08;

      // Check if element has a loaded texture image
      const hasTexture = el.textureImg && el.textureImg.complete && el.textureImg.naturalWidth > 0;

      switch(type) {
        case 'base-cabinet':
        case 'wall-cabinet':
          // CLEAN, CRISP CABINET RENDERING
          // Determine cabinet style from material or default to shaker
          const cabinetStyle = el.materialName?.toLowerCase().includes('flat') ? 'flat' : 'shaker';
          const isWallCab = type === 'wall-cabinet';

          // Toe kick dimensions for base cabinets (4" tall, 3" recessed)
          const toeKickH = isWallCab ? 0 : Math.max(6, h * 0.12);
          const toeKickRecess = isWallCab ? 0 : Math.max(4, w * 0.05);

          // Cabinet body height (excluding toe kick)
          const cabinetBodyH = h - toeKickH;

          // Draw cabinet body fill (clean solid color)
          ctx.fillStyle = el.color;
          ctx.fillRect(x, y, w, cabinetBodyH);

          // Draw toe kick recess for base cabinets
          if (!isWallCab && toeKickH > 0) {
            // Dark recessed void under cabinet
            ctx.fillStyle = '#0a0a0e';
            ctx.fillRect(x + toeKickRecess, y + cabinetBodyH, w - toeKickRecess * 2, toeKickH);

            // Clean shadow line at top of toe kick
            ctx.fillStyle = 'rgba(0,0,0,0.5)';
            ctx.fillRect(x + toeKickRecess, y + cabinetBodyH, w - toeKickRecess * 2, 2);
          }

          // Calculate door layout
          const doorCount = Math.max(1, Math.floor(w / (pixelsPerFoot * 1.5)));
          const doorWidth = (w - 6) / doorCount; // Minimal gap between doors
          const doorGap = 2;

          for (let i = 0; i < doorCount; i++) {
            const dx = x + 3 + i * doorWidth;
            const dy = y + 3;
            const dw = doorWidth - doorGap;
            const dh = cabinetBodyH - 6;

            // Door face - clean solid
            ctx.fillStyle = el.color;
            ctx.fillRect(dx, dy, dw, dh);

            // Clean door outline
            ctx.strokeStyle = 'rgba(0,0,0,0.25)';
            ctx.lineWidth = 1;
            ctx.strokeRect(dx + 0.5, dy + 0.5, dw - 1, dh - 1);

            if (cabinetStyle === 'shaker') {
              // Shaker style - clean recessed panel
              const panelInset = Math.min(10, Math.max(6, dw * 0.1));
              const px = dx + panelInset;
              const py = dy + panelInset;
              const pw = dw - panelInset * 2;
              const ph = dh - panelInset * 2;

              // Panel recess - clean lines
              ctx.strokeStyle = 'rgba(0,0,0,0.18)';
              ctx.lineWidth = 1;
              ctx.strokeRect(px + 0.5, py + 0.5, pw - 1, ph - 1);

              // Inner panel slightly recessed
              ctx.fillStyle = 'rgba(0,0,0,0.05)';
              ctx.fillRect(px + 1, py + 1, pw - 2, ph - 2);

              // Subtle highlight on panel frame
              ctx.strokeStyle = 'rgba(255,255,255,0.08)';
              ctx.strokeRect(px - 0.5, py - 0.5, pw + 1, ph + 1);
            }

            // Door edge highlights - subtle and clean
            ctx.fillStyle = 'rgba(255,255,255,0.1)';
            ctx.fillRect(dx, dy, dw, 1); // top highlight
            ctx.fillRect(dx, dy, 1, dh); // left highlight

            ctx.fillStyle = 'rgba(0,0,0,0.1)';
            ctx.fillRect(dx, dy + dh - 1, dw, 1); // bottom shadow
            ctx.fillRect(dx + dw - 1, dy, 1, dh); // right shadow

            // Door handle - clean bar pull
            const handleLen = Math.min(20, dh * 0.3);
            const handleX = dx + dw - 8;
            const handleY = dy + dh / 2 - handleLen / 2;

            // Handle shadow
            ctx.fillStyle = 'rgba(0,0,0,0.2)';
            ctx.fillRect(handleX + 1, handleY + 1, 3, handleLen);

            // Handle body - clean metallic
            ctx.fillStyle = '#C0C0C0';
            ctx.fillRect(handleX, handleY, 3, handleLen);

            // Handle highlight
            ctx.fillStyle = 'rgba(255,255,255,0.4)';
            ctx.fillRect(handleX, handleY, 1, handleLen);
          }

          // Cabinet side edges - clean dark line
          ctx.fillStyle = 'rgba(0,0,0,0.15)';
          ctx.fillRect(x, y, 1, cabinetBodyH);
          ctx.fillRect(x + w - 1, y, 1, cabinetBodyH);
          break;

        case 'microwave-cabinet': {
          // Microwave cabinet - open box/shelf with microwave inside
          // Standard microwave opening: 30" wide x 18" tall x 15" deep
          const mwcPad = padding;
          const boxThickness = Math.max(4, w * 0.05);

          // Cabinet box frame (open front)
          ctx.fillStyle = el.color || '#5C5040';

          // Top of box
          ctx.fillRect(x, y, w, boxThickness);
          // Bottom of box
          ctx.fillRect(x, y + h - boxThickness, w, boxThickness);
          // Left side
          ctx.fillRect(x, y, boxThickness, h);
          // Right side
          ctx.fillRect(x + w - boxThickness, y, boxThickness, h);

          // Wood grain on frame
          if (!hasTexture) {
            drawWoodGrain(ctx, x, y, w, boxThickness, el.color, 0.4);
            drawWoodGrain(ctx, x, y + h - boxThickness, w, boxThickness, el.color, 0.4);
          }

          // Dark interior (open box showing depth)
          ctx.fillStyle = '#1a1a1a';
          ctx.fillRect(x + boxThickness, y + boxThickness, w - boxThickness * 2, h - boxThickness * 2);

          // Microwave face inside the opening
          const mwPad = boxThickness + 4;
          const mwW = w - mwPad * 2;
          const mwH = h - mwPad * 2;

          // Microwave body
          ctx.fillStyle = '#2a2a2a';
          ctx.fillRect(x + mwPad, y + mwPad, mwW, mwH);

          // Microwave glass door (left 65%)
          ctx.fillStyle = '#1a1a1a';
          ctx.fillRect(x + mwPad + 4, y + mwPad + 4, mwW * 0.6, mwH - 8);

          // Glass reflection
          ctx.fillStyle = 'rgba(255,255,255,0.05)';
          ctx.fillRect(x + mwPad + 8, y + mwPad + 8, mwW * 0.3, mwH * 0.4);

          // Control panel (right 35%)
          ctx.fillStyle = '#3a3a3a';
          ctx.fillRect(x + mwPad + mwW * 0.65, y + mwPad + 4, mwW * 0.3, mwH - 8);

          // Buttons/display
          ctx.fillStyle = '#222';
          ctx.fillRect(x + mwPad + mwW * 0.68, y + mwPad + 10, mwW * 0.22, mwH * 0.2);

          // Button grid
          for (let row = 0; row < 3; row++) {
            for (let col = 0; col < 3; col++) {
              ctx.fillStyle = '#444';
              ctx.fillRect(
                x + mwPad + mwW * 0.7 + col * (mwW * 0.07),
                y + mwPad + mwH * 0.4 + row * (mwH * 0.15),
                mwW * 0.05,
                mwH * 0.1
              );
            }
          }

          // Door handle
          ctx.fillStyle = '#666';
          ctx.fillRect(x + mwPad + mwW * 0.58, y + mwPad + mwH * 0.3, 4, mwH * 0.4);

          break;
        }

        case 'drawer-base': {
          // Drawer base cabinet - 3-4 stacked drawer fronts
          const dbToeKickH = Math.max(8, h * 0.15);
          const dbToeKickRecess = Math.max(5, w * 0.06);
          const dbBodyH = h - dbToeKickH;

          // Draw toe kick recess
          ctx.fillStyle = '#0d0d12';
          ctx.fillRect(x + dbToeKickRecess, y + dbBodyH, w - dbToeKickRecess * 2, dbToeKickH);
          ctx.fillStyle = 'rgba(0,0,0,0.7)';
          ctx.fillRect(x + dbToeKickRecess, y + dbBodyH, w - dbToeKickRecess * 2, 3);
          ctx.fillStyle = adjustColor(el.color, -40);
          ctx.fillRect(x, y + dbBodyH - 2, w, 2);

          // Draw wood grain background
          if (!hasTexture) {
            drawWoodGrain(ctx, x, y, w, dbBodyH, el.color);
          }

          // Calculate drawer layout (3-4 drawers)
          const numDrawers = w > pixelsPerFoot * 2 ? 4 : 3;
          const drawerHeight = (dbBodyH - padding * 2 - (numDrawers - 1) * 3) / numDrawers;

          for (let i = 0; i < numDrawers; i++) {
            const dx = x + padding;
            const dy = y + padding + i * (drawerHeight + 3);
            const dw = w - padding * 2;
            const dh = drawerHeight;

            // Drawer shadow
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.fillRect(dx + 3, dy + 3, dw, dh);

            // Drawer face
            ctx.fillStyle = el.color;
            ctx.fillRect(dx, dy, dw, dh);

            // Drawer panel detail (shaker style)
            const panelInset = Math.min(8, dw * 0.08);
            ctx.fillStyle = 'rgba(0,0,0,0.15)';
            ctx.fillRect(dx + panelInset, dy + panelInset, 2, dh - panelInset * 2);
            ctx.fillRect(dx + panelInset, dy + panelInset, dw - panelInset * 2, 2);
            ctx.fillStyle = 'rgba(255,255,255,0.1)';
            ctx.fillRect(dx + dw - panelInset - 2, dy + panelInset, 2, dh - panelInset * 2);
            ctx.fillRect(dx + panelInset, dy + dh - panelInset - 2, dw - panelInset * 2, 2);

            // Drawer edge highlights
            ctx.fillStyle = 'rgba(255,255,255,0.12)';
            ctx.fillRect(dx, dy, dw, 2);
            ctx.fillRect(dx, dy, 2, dh);
            ctx.fillStyle = 'rgba(0,0,0,0.15)';
            ctx.fillRect(dx, dy + dh - 2, dw, 2);
            ctx.fillRect(dx + dw - 2, dy, 2, dh);

            // Centered bar pull handle
            const handleLen = Math.min(dw * 0.4, 40);
            const handleX = dx + dw / 2 - handleLen / 2;
            const handleY = dy + dh / 2 - 2;

            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.fillRect(handleX + 2, handleY + 2, handleLen, 4);

            const handleGrad = ctx.createLinearGradient(0, handleY, 0, handleY + 4);
            handleGrad.addColorStop(0, 'rgba(220,220,220,0.95)');
            handleGrad.addColorStop(0.5, 'rgba(250,250,250,0.95)');
            handleGrad.addColorStop(1, 'rgba(190,190,190,0.9)');
            ctx.fillStyle = handleGrad;
            ctx.fillRect(handleX, handleY, handleLen, 4);
          }

          // Side panel edges
          ctx.fillStyle = adjustColor(el.color, -25);
          ctx.fillRect(x, y, 2, dbBodyH);
          ctx.fillRect(x + w - 2, y, 2, dbBodyH);
          break;
        }

        case 'sink-base': {
          // Sink base cabinet - false drawer front at top, open interior
          const sbToeKickH = Math.max(8, h * 0.15);
          const sbToeKickRecess = Math.max(5, w * 0.06);
          const sbBodyH = h - sbToeKickH;

          // Draw toe kick recess
          ctx.fillStyle = '#0d0d12';
          ctx.fillRect(x + sbToeKickRecess, y + sbBodyH, w - sbToeKickRecess * 2, sbToeKickH);
          ctx.fillStyle = 'rgba(0,0,0,0.7)';
          ctx.fillRect(x + sbToeKickRecess, y + sbBodyH, w - sbToeKickRecess * 2, 3);
          ctx.fillStyle = adjustColor(el.color, -40);
          ctx.fillRect(x, y + sbBodyH - 2, w, 2);

          // Draw wood grain background
          if (!hasTexture) {
            drawWoodGrain(ctx, x, y, w, sbBodyH, el.color);
          }

          // False drawer front at top (non-functional)
          const falseDrawerH = Math.min(sbBodyH * 0.18, 20);
          const fdx = x + padding;
          const fdy = y + padding;
          const fdw = w - padding * 2;

          ctx.fillStyle = 'rgba(0,0,0,0.3)';
          ctx.fillRect(fdx + 3, fdy + 3, fdw, falseDrawerH);
          ctx.fillStyle = el.color;
          ctx.fillRect(fdx, fdy, fdw, falseDrawerH);
          ctx.fillStyle = 'rgba(255,255,255,0.12)';
          ctx.fillRect(fdx, fdy, fdw, 2);
          ctx.fillStyle = 'rgba(0,0,0,0.1)';
          ctx.fillRect(fdx, fdy + falseDrawerH - 2, fdw, 2);

          // False drawer handle
          const fhandleLen = Math.min(fdw * 0.4, 35);
          const fhandleX = fdx + fdw / 2 - fhandleLen / 2;
          const fhandleY = fdy + falseDrawerH / 2 - 2;
          ctx.fillStyle = 'rgba(200,200,200,0.9)';
          ctx.fillRect(fhandleX, fhandleY, fhandleLen, 3);

          // Double door section below
          const doorsY = fdy + falseDrawerH + 4;
          const doorsH = sbBodyH - padding * 2 - falseDrawerH - 4;
          const doorW = (fdw - 4) / 2;

          for (let i = 0; i < 2; i++) {
            const ddx = fdx + i * (doorW + 4);
            const ddy = doorsY;
            const ddw = doorW;
            const ddh = doorsH;

            // Door shadow
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.fillRect(ddx + 3, ddy + 3, ddw, ddh);

            // Door face
            ctx.fillStyle = el.color;
            ctx.fillRect(ddx, ddy, ddw, ddh);

            // Shaker panel
            const panelInset = Math.min(10, ddw * 0.1);
            ctx.fillStyle = 'rgba(0,0,0,0.15)';
            ctx.fillRect(ddx + panelInset, ddy + panelInset, 2, ddh - panelInset * 2);
            ctx.fillRect(ddx + panelInset, ddy + panelInset, ddw - panelInset * 2, 2);
            ctx.fillStyle = 'rgba(255,255,255,0.1)';
            ctx.fillRect(ddx + ddw - panelInset - 2, ddy + panelInset, 2, ddh - panelInset * 2);
            ctx.fillRect(ddx + panelInset, ddy + ddh - panelInset - 2, ddw - panelInset * 2, 2);

            // Door edge highlights
            ctx.fillStyle = 'rgba(255,255,255,0.12)';
            ctx.fillRect(ddx, ddy, ddw, 2);
            ctx.fillRect(ddx, ddy, 2, ddh);
            ctx.fillStyle = 'rgba(0,0,0,0.15)';
            ctx.fillRect(ddx, ddy + ddh - 2, ddw, 2);
            ctx.fillRect(ddx + ddw - 2, ddy, 2, ddh);

            // Door handle
            const dhandleLen = Math.min(20, ddh * 0.3);
            const dhandleX = i === 0 ? ddx + ddw - 10 : ddx + 6;
            const dhandleY = ddy + ddh / 2 - dhandleLen / 2;
            ctx.fillStyle = 'rgba(200,200,200,0.9)';
            ctx.fillRect(dhandleX, dhandleY, 4, dhandleLen);
          }

          // Side panel edges
          ctx.fillStyle = adjustColor(el.color, -25);
          ctx.fillRect(x, y, 2, sbBodyH);
          ctx.fillRect(x + w - 2, y, 2, sbBodyH);
          break;
        }

        case 'lazy-susan': {
          // LAZY SUSAN - L-shaped corner cabinet with two bi-fold doors (like turnstyle)
          const lsToeKickH = Math.max(6, h * 0.1);
          const lsToeKickRecess = Math.max(4, w * 0.05);
          const lsBodyH = h - lsToeKickH;
          const lsArmW = w * 0.5;
          const lsArmH = h * 0.5;

          // L-shape cabinet body (clean solid fill)
          ctx.fillStyle = el.color;
          ctx.beginPath();
          ctx.moveTo(x, y);
          ctx.lineTo(x, y + h - lsToeKickH);
          ctx.lineTo(x + lsArmW, y + h - lsToeKickH);
          ctx.lineTo(x + lsArmW, y + lsArmH);
          ctx.lineTo(x + w, y + lsArmH);
          ctx.lineTo(x + w, y);
          ctx.closePath();
          ctx.fill();

          // Toe kick recess (dark void)
          ctx.fillStyle = '#0a0a0e';
          ctx.fillRect(x + lsToeKickRecess, y + h - lsToeKickH, lsArmW - lsToeKickRecess, lsToeKickH);

          // TWO BI-FOLD DOORS meeting at diagonal (turnstyle style)
          // Left door panel (horizontal arm)
          const leftDoorX = x + 3;
          const leftDoorY = y + lsArmH + 3;
          const leftDoorW = lsArmW - 6;
          const leftDoorH = lsBodyH - lsArmH - 6;

          ctx.fillStyle = el.color;
          ctx.fillRect(leftDoorX, leftDoorY, leftDoorW, leftDoorH);
          ctx.strokeStyle = 'rgba(0,0,0,0.25)';
          ctx.lineWidth = 1;
          ctx.strokeRect(leftDoorX + 0.5, leftDoorY + 0.5, leftDoorW - 1, leftDoorH - 1);

          // Left door shaker panel
          const panelInset = Math.min(8, leftDoorW * 0.1);
          ctx.strokeStyle = 'rgba(0,0,0,0.15)';
          ctx.strokeRect(leftDoorX + panelInset, leftDoorY + panelInset, leftDoorW - panelInset * 2, leftDoorH - panelInset * 2);
          ctx.fillStyle = 'rgba(0,0,0,0.04)';
          ctx.fillRect(leftDoorX + panelInset + 1, leftDoorY + panelInset + 1, leftDoorW - panelInset * 2 - 2, leftDoorH - panelInset * 2 - 2);

          // Left door handle
          ctx.fillStyle = '#C0C0C0';
          ctx.fillRect(leftDoorX + leftDoorW - 7, leftDoorY + leftDoorH / 2 - 8, 3, 16);

          // Right door panel (vertical arm)
          const rightDoorX = x + lsArmW + 3;
          const rightDoorY = y + 3;
          const rightDoorW = w - lsArmW - 6;
          const rightDoorH = lsArmH - 6;

          ctx.fillStyle = el.color;
          ctx.fillRect(rightDoorX, rightDoorY, rightDoorW, rightDoorH);
          ctx.strokeStyle = 'rgba(0,0,0,0.25)';
          ctx.strokeRect(rightDoorX + 0.5, rightDoorY + 0.5, rightDoorW - 1, rightDoorH - 1);

          // Right door shaker panel
          ctx.strokeStyle = 'rgba(0,0,0,0.15)';
          ctx.strokeRect(rightDoorX + panelInset, rightDoorY + panelInset, rightDoorW - panelInset * 2, rightDoorH - panelInset * 2);
          ctx.fillStyle = 'rgba(0,0,0,0.04)';
          ctx.fillRect(rightDoorX + panelInset + 1, rightDoorY + panelInset + 1, rightDoorW - panelInset * 2 - 2, rightDoorH - panelInset * 2 - 2);

          // Right door handle
          ctx.fillStyle = '#C0C0C0';
          ctx.fillRect(rightDoorX + rightDoorW / 2 - 8, rightDoorY + rightDoorH - 7, 16, 3);

          // Diagonal corner line (where doors meet)
          ctx.strokeStyle = 'rgba(0,0,0,0.3)';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(x + lsArmW, y + lsArmH);
          ctx.lineTo(x + lsArmW + 4, y + lsArmH + 4);
          ctx.stroke();

          // Cabinet outline
          ctx.strokeStyle = 'rgba(0,0,0,0.2)';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(x, y);
          ctx.lineTo(x, y + h - lsToeKickH);
          ctx.lineTo(x + lsArmW, y + h - lsToeKickH);
          ctx.lineTo(x + lsArmW, y + lsArmH);
          ctx.lineTo(x + w, y + lsArmH);
          ctx.lineTo(x + w, y);
          ctx.closePath();
          ctx.stroke();
          break;
        }

        case 'blind-corner': {
          // BLIND CORNER CABINET - Two doors side by side
          const bcToeKickH = Math.max(6, h * 0.1);
          const bcToeKickRecess = Math.max(4, w * 0.05);
          const bcBodyH = h - bcToeKickH;

          // Cabinet body fill
          ctx.fillStyle = el.color;
          ctx.fillRect(x, y, w, bcBodyH);

          // Toe kick recess
          ctx.fillStyle = '#0a0a0e';
          ctx.fillRect(x + bcToeKickRecess, y + bcBodyH, w - bcToeKickRecess * 2, bcToeKickH);
          ctx.fillStyle = 'rgba(0,0,0,0.5)';
          ctx.fillRect(x + bcToeKickRecess, y + bcBodyH, w - bcToeKickRecess * 2, 2);

          // Two doors (30/70 split - blind side is narrower)
          const blindDoorW = (w - 9) * 0.3;
          const mainDoorW = (w - 9) * 0.7;
          const doorGap = 3;

          // Blind door (narrower, left side)
          const blindDx = x + 3;
          const blindDy = y + 3;
          const blindDh = bcBodyH - 6;

          ctx.fillStyle = el.color;
          ctx.fillRect(blindDx, blindDy, blindDoorW, blindDh);
          ctx.strokeStyle = 'rgba(0,0,0,0.25)';
          ctx.lineWidth = 1;
          ctx.strokeRect(blindDx + 0.5, blindDy + 0.5, blindDoorW - 1, blindDh - 1);

          // Blind door shaker panel
          const bcInset = Math.min(6, blindDoorW * 0.12);
          ctx.strokeStyle = 'rgba(0,0,0,0.15)';
          ctx.strokeRect(blindDx + bcInset, blindDy + bcInset, blindDoorW - bcInset * 2, blindDh - bcInset * 2);
          ctx.fillStyle = 'rgba(0,0,0,0.04)';
          ctx.fillRect(blindDx + bcInset + 1, blindDy + bcInset + 1, blindDoorW - bcInset * 2 - 2, blindDh - bcInset * 2 - 2);

          // Main door (wider, right side)
          const mainDx = blindDx + blindDoorW + doorGap;

          ctx.fillStyle = el.color;
          ctx.fillRect(mainDx, blindDy, mainDoorW, blindDh);
          ctx.strokeStyle = 'rgba(0,0,0,0.25)';
          ctx.strokeRect(mainDx + 0.5, blindDy + 0.5, mainDoorW - 1, blindDh - 1);

          // Main door shaker panel
          const mainInset = Math.min(8, mainDoorW * 0.1);
          ctx.strokeStyle = 'rgba(0,0,0,0.15)';
          ctx.strokeRect(mainDx + mainInset, blindDy + mainInset, mainDoorW - mainInset * 2, blindDh - mainInset * 2);
          ctx.fillStyle = 'rgba(0,0,0,0.04)';
          ctx.fillRect(mainDx + mainInset + 1, blindDy + mainInset + 1, mainDoorW - mainInset * 2 - 2, blindDh - mainInset * 2 - 2);

          // Door handles
          ctx.fillStyle = '#C0C0C0';
          ctx.fillRect(blindDx + blindDoorW - 6, blindDy + blindDh / 2 - 8, 3, 16);
          ctx.fillRect(mainDx + 3, blindDy + blindDh / 2 - 8, 3, 16);

          // Side edges
          ctx.fillStyle = 'rgba(0,0,0,0.15)';
          ctx.fillRect(x, y, 1, bcBodyH);
          ctx.fillRect(x + w - 1, y, 1, bcBodyH);
          break;
        }

        case 'tall-cabinet':
          // CLEAN TALL CABINET RENDERING
          const tallToeH = Math.max(6, h * 0.06);
          const tallToeRecess = Math.max(4, w * 0.05);
          const tallBodyH = h - tallToeH;

          // Cabinet body fill
          ctx.fillStyle = el.color;
          ctx.fillRect(x, y, w, tallBodyH);

          // Draw toe kick recess
          ctx.fillStyle = '#0a0a0e';
          ctx.fillRect(x + tallToeRecess, y + tallBodyH, w - tallToeRecess * 2, tallToeH);
          ctx.fillStyle = 'rgba(0,0,0,0.5)';
          ctx.fillRect(x + tallToeRecess, y + tallBodyH, w - tallToeRecess * 2, 2);

          // Two-section tall cabinet (upper 35%, lower 65%)
          const tallMidY = y + tallBodyH * 0.35;
          const sectionGap = 3;

          // Upper door
          const upperDx = x + 3;
          const upperDy = y + 3;
          const upperDw = w - 6;
          const upperDh = tallMidY - y - 3 - sectionGap/2;

          ctx.fillStyle = el.color;
          ctx.fillRect(upperDx, upperDy, upperDw, upperDh);
          ctx.strokeStyle = 'rgba(0,0,0,0.25)';
          ctx.lineWidth = 1;
          ctx.strokeRect(upperDx + 0.5, upperDy + 0.5, upperDw - 1, upperDh - 1);

          // Upper shaker panel
          const upperInset = Math.min(8, upperDw * 0.08);
          ctx.strokeStyle = 'rgba(0,0,0,0.15)';
          ctx.strokeRect(upperDx + upperInset, upperDy + upperInset, upperDw - upperInset * 2, upperDh - upperInset * 2);
          ctx.fillStyle = 'rgba(0,0,0,0.04)';
          ctx.fillRect(upperDx + upperInset + 1, upperDy + upperInset + 1, upperDw - upperInset * 2 - 2, upperDh - upperInset * 2 - 2);

          // Upper handle
          const upperHandleLen = Math.min(18, upperDh * 0.25);
          ctx.fillStyle = '#C0C0C0';
          ctx.fillRect(upperDx + upperDw - 7, upperDy + upperDh - upperHandleLen - 8, 3, upperHandleLen);

          // Lower door
          const lowerDy = tallMidY + sectionGap/2;
          const lowerDh = tallBodyH - (tallMidY - y) - 3 - sectionGap/2;

          ctx.fillStyle = el.color;
          ctx.fillRect(upperDx, lowerDy, upperDw, lowerDh);
          ctx.strokeStyle = 'rgba(0,0,0,0.25)';
          ctx.strokeRect(upperDx + 0.5, lowerDy + 0.5, upperDw - 1, lowerDh - 1);

          // Lower shaker panel
          ctx.strokeStyle = 'rgba(0,0,0,0.15)';
          ctx.strokeRect(upperDx + upperInset, lowerDy + upperInset, upperDw - upperInset * 2, lowerDh - upperInset * 2);
          ctx.fillStyle = 'rgba(0,0,0,0.04)';
          ctx.fillRect(upperDx + upperInset + 1, lowerDy + upperInset + 1, upperDw - upperInset * 2 - 2, lowerDh - upperInset * 2 - 2);

          // Lower handle
          const lowerHandleLen = Math.min(18, lowerDh * 0.2);
          ctx.fillStyle = '#C0C0C0';
          ctx.fillRect(upperDx + upperDw - 7, lowerDy + 8, 3, lowerHandleLen);

          // Side edges
          ctx.fillStyle = 'rgba(0,0,0,0.15)';
          ctx.fillRect(x, y, 1, tallBodyH);
          ctx.fillRect(x + w - 1, y, 1, tallBodyH);
          break;

        case 'fridge-cabinet': {
          // Fridge enclosure cabinet - frame with opening for fridge and cabinet above
          const fridgeCabPadding = 4;
          const panelWidth = w * 0.08; // Side panels
          const topCabinetH = h * 0.25; // Cabinet above fridge
          const fridgeOpeningH = h * 0.70; // Opening for fridge
          const toeKickH = h * 0.05;

          // Draw outer frame/panels
          ctx.fillStyle = el.color || '#8B4513';

          // Left panel
          ctx.fillRect(x, y, panelWidth, h - toeKickH);
          // Right panel
          ctx.fillRect(x + w - panelWidth, y, panelWidth, h - toeKickH);
          // Top cabinet section
          ctx.fillRect(x, y, w, topCabinetH);

          // Draw cabinet door on top section
          drawCabinetDoor(ctx, x + fridgeCabPadding, y + fridgeCabPadding, w - fridgeCabPadding * 2, topCabinetH - fridgeCabPadding * 2, el.color);

          // Fridge opening (dark recess)
          ctx.fillStyle = '#1a1a1a';
          ctx.fillRect(x + panelWidth, y + topCabinetH, w - panelWidth * 2, fridgeOpeningH);

          // Fridge icon in opening
          ctx.fillStyle = '#888';
          const fridgeIconX = x + panelWidth + (w - panelWidth * 2) * 0.15;
          const fridgeIconY = y + topCabinetH + fridgeOpeningH * 0.1;
          const fridgeIconW = (w - panelWidth * 2) * 0.7;
          const fridgeIconH = fridgeOpeningH * 0.8;
          ctx.fillRect(fridgeIconX, fridgeIconY, fridgeIconW, fridgeIconH);
          // Fridge handle
          ctx.fillStyle = '#555';
          ctx.fillRect(fridgeIconX + fridgeIconW - 8, fridgeIconY + fridgeIconH * 0.2, 4, fridgeIconH * 0.3);
          ctx.fillRect(fridgeIconX + fridgeIconW - 8, fridgeIconY + fridgeIconH * 0.6, 4, fridgeIconH * 0.3);

          // Toe kick
          ctx.fillStyle = '#0d0d12';
          ctx.fillRect(x + panelWidth * 0.5, y + h - toeKickH, w - panelWidth, toeKickH);

          // Panel edges/shadows
          ctx.fillStyle = adjustColor(el.color, -25);
          ctx.fillRect(x + panelWidth - 2, y + topCabinetH, 2, fridgeOpeningH);
          ctx.fillRect(x + w - panelWidth, y + topCabinetH, 2, fridgeOpeningH);
          break;
        }

        case 'island':
          // Island with countertop overhang and cabinet base with toe kick
          const counterOverhang = 10; // Countertop overhangs the base
          const islandToeH = 6; // Toe kick height
          const islandToeRecess = 5; // Toe kick recessed from cabinet face

          // Cabinet base dimensions (inside the countertop overhang)
          const islandBaseX = x + counterOverhang;
          const islandBaseY = y + counterOverhang;
          const islandBaseW = w - counterOverhang * 2;
          const islandBaseH = h - counterOverhang * 2;

          // Cabinet body (above toe kick)
          const islandCabH = islandBaseH - islandToeH;

          // Draw toe kick recess FIRST (all 4 sides since island is accessible from all sides)
          ctx.fillStyle = '#0d0d12';
          // Front (bottom in Y)
          ctx.fillRect(islandBaseX + islandToeRecess, islandBaseY + islandCabH, islandBaseW - islandToeRecess * 2, islandToeH);
          // Back (top in Y)
          ctx.fillRect(islandBaseX + islandToeRecess, islandBaseY, islandBaseW - islandToeRecess * 2, islandToeH);
          // Left
          ctx.fillRect(islandBaseX, islandBaseY + islandToeRecess, islandToeH, islandBaseH - islandToeRecess * 2);
          // Right
          ctx.fillRect(islandBaseX + islandBaseW - islandToeH, islandBaseY + islandToeRecess, islandToeH, islandBaseH - islandToeRecess * 2);

          // Shadow lines at toe kick edges
          ctx.fillStyle = 'rgba(0,0,0,0.6)';
          ctx.fillRect(islandBaseX + islandToeRecess, islandBaseY + islandCabH, islandBaseW - islandToeRecess * 2, 2);
          ctx.fillRect(islandBaseX + islandToeRecess, islandBaseY + islandToeH - 2, islandBaseW - islandToeRecess * 2, 2);

          // Cabinet body (between toe kicks)
          const cabBodyX = islandBaseX + islandToeH;
          const cabBodyY = islandBaseY + islandToeH;
          const cabBodyW = islandBaseW - islandToeH * 2;
          const cabBodyH = islandCabH - islandToeH;

          // Cabinet base color
          ctx.fillStyle = adjustColor(el.color, -30);
          ctx.fillRect(cabBodyX, cabBodyY, cabBodyW, cabBodyH);

          // Draw cabinet doors on the cabinet body
          const islandDoorCount = Math.max(2, Math.floor(cabBodyW / (pixelsPerFoot * 1.2)));
          const islandDoorW = (cabBodyW - 8) / islandDoorCount;

          for (let i = 0; i < islandDoorCount; i++) {
            const idx = cabBodyX + 4 + i * islandDoorW;
            const idy = cabBodyY + 4;
            const idw = islandDoorW - 4;
            const idh = cabBodyH - 8;

            // Door panel
            ctx.fillStyle = adjustColor(el.color, -20);
            ctx.fillRect(idx, idy, idw, idh);

            // Shaker panel inset
            const inset = Math.min(8, idw * 0.1);
            ctx.strokeStyle = 'rgba(0,0,0,0.2)';
            ctx.lineWidth = 1;
            ctx.strokeRect(idx + inset, idy + inset, idw - inset * 2, idh - inset * 2);

            // Handle
            ctx.fillStyle = 'rgba(180,180,180,0.8)';
            ctx.fillRect(idx + idw - 8, idy + idh/2 - 8, 3, 16);
          }

          // Draw countertop surface LAST (on top, with overhang)
          if (!hasTexture) {
            drawCountertopSurface(ctx, x, y, w, h, el.color, el.materialName);
          } else {
            // Just edge highlights for textured countertop
            ctx.fillStyle = 'rgba(255,255,255,0.2)';
            ctx.fillRect(x, y, w, 3);
            ctx.fillRect(x, y, 3, h);
            ctx.fillStyle = 'rgba(0,0,0,0.25)';
            ctx.fillRect(x, y + h - 3, w, 3);
            ctx.fillRect(x + w - 3, y, 3, h);
          }

          break;

        case 'countertop':
          // Draw countertop with material-specific patterns (only if no texture)
          if (!hasTexture) {
            drawCountertopSurface(ctx, x, y, w, h, el.color, el.materialName);
          } else {
            // Just add edge profile for textured countertops
            ctx.fillStyle = 'rgba(255,255,255,0.15)';
            ctx.fillRect(x, y, w, 3);
            ctx.fillRect(x, y, 3, h);
            ctx.fillStyle = 'rgba(0,0,0,0.2)';
            ctx.fillRect(x, y + h - 3, w, 3);
            ctx.fillRect(x + w - 3, y, 3, h);
          }

          // Draw slab boundary indicators (show where standard slabs would end)
          // Only show when countertop is selected
          if (selectedElement && el.id === selectedElement.id) {
            const widthInches = el.width * 12;
            const maxSlabWidth = FABRICATION_STANDARDS?.seams?.maxSlabWidth || 120;

            // If countertop exceeds one slab width, show boundary markers
            if (widthInches > maxSlabWidth) {
              ctx.save();
              ctx.setLineDash([3, 6]);
              ctx.strokeStyle = 'rgba(59, 130, 246, 0.5)'; // Blue dashed lines
              ctx.lineWidth = 1;

              // Draw boundary lines at slab width intervals
              let boundaryPos = maxSlabWidth;
              while (boundaryPos < widthInches) {
                const boundaryX = x + (boundaryPos / widthInches) * w;
                ctx.beginPath();
                ctx.moveTo(boundaryX, y);
                ctx.lineTo(boundaryX, y + h);
                ctx.stroke();

                // Small label at top
                ctx.font = '9px sans-serif';
                ctx.fillStyle = 'rgba(59, 130, 246, 0.8)';
                ctx.fillText(`${boundaryPos}"`, boundaryX + 2, y + 10);

                boundaryPos += maxSlabWidth;
              }
              ctx.restore();
            }
          }

          // Draw seams if present
          if (el.seams && el.seams.length > 0) {
            el.seams.forEach(seam => {
              const seamX = x + w * seam.position;
              // Seam line (dashed)
              ctx.save();
              ctx.setLineDash([6, 4]);
              ctx.strokeStyle = '#dc3545';
              ctx.lineWidth = 2;
              ctx.beginPath();
              ctx.moveTo(seamX, y + 2);
              ctx.lineTo(seamX, y + h - 2);
              ctx.stroke();
              ctx.restore();

              // Seam marker (small diamond)
              ctx.fillStyle = '#dc3545';
              ctx.beginPath();
              ctx.moveTo(seamX, y - 6);
              ctx.lineTo(seamX + 5, y);
              ctx.lineTo(seamX, y + 6);
              ctx.lineTo(seamX - 5, y);
              ctx.closePath();
              ctx.fill();
            });
          }
          break;

        case 'countertop-l': {
          // L-shaped countertop - draw as actual L shape in 2D
          // Both arms are 2.2ft (26.4") wide - standard countertop depth
          const armWidthFt = el.armWidth || 2.17;
          const armDepth = armWidthFt * pixelsPerFoot;  // Horizontal arm depth
          const armWidth = armWidthFt * pixelsPerFoot;  // Vertical arm width

          // Cutout area is transparent (not drawn) - only the L-shape is filled

          // Draw L shape using path
          ctx.beginPath();
          ctx.moveTo(x, y);
          ctx.lineTo(x + w, y);
          ctx.lineTo(x + w, y + armDepth);
          ctx.lineTo(x + armWidth, y + armDepth);
          ctx.lineTo(x + armWidth, y + h);
          ctx.lineTo(x, y + h);
          ctx.closePath();

          // Fill with color or texture
          if (!hasTexture) {
            ctx.fillStyle = el.color || '#708090';
            ctx.fill();

            // Add stone-like speckle pattern
            ctx.fillStyle = 'rgba(255,255,255,0.15)';
            for (let i = 0; i < 30; i++) {
              const dotX = x + Math.random() * w;
              const dotY = y + Math.random() * h;
              // Only draw dot if it's in the L area
              if (dotY < y + armDepth || dotX < x + armWidth) {
                ctx.beginPath();
                ctx.arc(dotX, dotY, 1 + Math.random(), 0, Math.PI * 2);
                ctx.fill();
              }
            }
            ctx.fillStyle = 'rgba(0,0,0,0.1)';
            for (let i = 0; i < 20; i++) {
              const dotX = x + Math.random() * w;
              const dotY = y + Math.random() * h;
              if (dotY < y + armDepth || dotX < x + armWidth) {
                ctx.beginPath();
                ctx.arc(dotX, dotY, 1 + Math.random(), 0, Math.PI * 2);
                ctx.fill();
              }
            }
          } else {
            ctx.fill();
          }

          // Edge highlights
          ctx.strokeStyle = 'rgba(255,255,255,0.2)';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(x, y);
          ctx.lineTo(x + w, y);
          ctx.lineTo(x + w, y + armDepth);
          ctx.stroke();

          ctx.beginPath();
          ctx.moveTo(x, y);
          ctx.lineTo(x, y + h);
          ctx.lineTo(x + armWidth, y + h);
          ctx.stroke();

          // Shadow edges
          ctx.strokeStyle = 'rgba(0,0,0,0.25)';
          ctx.beginPath();
          ctx.moveTo(x + w, y + armDepth);
          ctx.lineTo(x + armWidth, y + armDepth);
          ctx.lineTo(x + armWidth, y + h);
          ctx.stroke();

          break;
        }

        case 'countertop-corner': {
          // Corner countertop - small square piece that sits in corner
          // Used to join two countertop runs at 90 degrees
          if (!hasTexture) {
            ctx.fillStyle = el.color || '#708090';
            ctx.fillRect(x, y, w, h);

            // Stone speckle pattern
            ctx.fillStyle = 'rgba(255,255,255,0.15)';
            for (let i = 0; i < 15; i++) {
              ctx.beginPath();
              ctx.arc(x + Math.random() * w, y + Math.random() * h, 1 + Math.random(), 0, Math.PI * 2);
              ctx.fill();
            }
            ctx.fillStyle = 'rgba(0,0,0,0.1)';
            for (let i = 0; i < 10; i++) {
              ctx.beginPath();
              ctx.arc(x + Math.random() * w, y + Math.random() * h, 1 + Math.random(), 0, Math.PI * 2);
              ctx.fill();
            }
          }

          // Edge profile
          ctx.fillStyle = 'rgba(255,255,255,0.2)';
          ctx.fillRect(x, y, w, 3);
          ctx.fillRect(x, y, 3, h);
          ctx.fillStyle = 'rgba(0,0,0,0.2)';
          ctx.fillRect(x, y + h - 3, w, 3);
          ctx.fillRect(x + w - 3, y, 3, h);

          // Seam indicator lines (shows where countertop runs join)
          ctx.strokeStyle = 'rgba(220, 53, 69, 0.5)';
          ctx.lineWidth = 1;
          ctx.setLineDash([4, 4]);
          // Seam on right edge
          ctx.beginPath();
          ctx.moveTo(x + w, y);
          ctx.lineTo(x + w, y + h);
          ctx.stroke();
          // Seam on bottom edge
          ctx.beginPath();
          ctx.moveTo(x, y + h);
          ctx.lineTo(x + w, y + h);
          ctx.stroke();
          ctx.setLineDash([]);

          break;
        }

        case 'surface-stainless':
          // Stainless steel with brushed effect
          ctx.fillStyle = '#C0C0C0';
          ctx.fillRect(x, y, w, h);
          // Brushed lines
          ctx.strokeStyle = 'rgba(255,255,255,0.3)';
          ctx.lineWidth = 1;
          for (let ly = y + 3; ly < y + h; ly += 4) {
            ctx.beginPath();
            ctx.moveTo(x + 2, ly);
            ctx.lineTo(x + w - 2, ly);
            ctx.stroke();
          }
          // Metallic highlight
          ctx.fillStyle = 'rgba(255,255,255,0.15)';
          ctx.fillRect(x, y, w, 4);
          ctx.fillRect(x, y, 4, h);
          // Shadow edge
          ctx.fillStyle = 'rgba(0,0,0,0.15)';
          ctx.fillRect(x, y + h - 3, w, 3);
          ctx.fillRect(x + w - 3, y, 3, h);
          break;

        case 'surface-solid':
          // Solid surface (Corian-style) - smooth matte
          ctx.fillStyle = el.color || '#E8E4E0';
          ctx.fillRect(x, y, w, h);
          // Subtle seamless look
          ctx.fillStyle = 'rgba(255,255,255,0.1)';
          ctx.fillRect(x + 1, y + 1, w - 2, 2);
          ctx.fillStyle = 'rgba(0,0,0,0.1)';
          ctx.fillRect(x + 1, y + h - 3, w - 2, 2);
          break;

        case 'surface-laminate':
          // Laminate/Formica with edge banding
          ctx.fillStyle = el.color || '#D4C4A8';
          ctx.fillRect(x, y, w, h);
          // Dark edge banding
          ctx.strokeStyle = '#4A4A4A';
          ctx.lineWidth = 2;
          ctx.strokeRect(x, y, w, h);
          // Subtle pattern if no texture
          if (!hasTexture) {
            ctx.fillStyle = 'rgba(0,0,0,0.03)';
            for (let px = x; px < x + w; px += 8) {
              ctx.fillRect(px, y, 4, h);
            }
          }
          break;

        case 'surface-butcherblock':
          // Butcher block with wood grain
          ctx.fillStyle = el.color || '#C4A76C';
          ctx.fillRect(x, y, w, h);
          // Wood strips
          ctx.strokeStyle = 'rgba(139,69,19,0.4)';
          ctx.lineWidth = 1;
          for (let sx = x + 6; sx < x + w; sx += 6) {
            ctx.beginPath();
            ctx.moveTo(sx, y + 2);
            ctx.lineTo(sx, y + h - 2);
            ctx.stroke();
          }
          // Highlights
          ctx.fillStyle = 'rgba(255,255,255,0.1)';
          ctx.fillRect(x, y, w, 3);
          break;

        case 'surface-concrete':
          // Concrete with industrial look
          ctx.fillStyle = el.color || '#808080';
          ctx.fillRect(x, y, w, h);
          // Aggregate texture spots
          ctx.fillStyle = 'rgba(0,0,0,0.1)';
          for (let i = 0; i < 20; i++) {
            const spotX = x + 5 + Math.random() * (w - 10);
            const spotY = y + 5 + Math.random() * (h - 10);
            ctx.beginPath();
            ctx.arc(spotX, spotY, 2 + Math.random() * 2, 0, Math.PI * 2);
            ctx.fill();
          }
          // Light aggregate
          ctx.fillStyle = 'rgba(255,255,255,0.1)';
          for (let i = 0; i < 15; i++) {
            const spotX = x + 5 + Math.random() * (w - 10);
            const spotY = y + 5 + Math.random() * (h - 10);
            ctx.beginPath();
            ctx.arc(spotX, spotY, 1 + Math.random() * 2, 0, Math.PI * 2);
            ctx.fill();
          }
          break;

        case 'backsplash':
          // If texture is loaded, just add subtle edge detail
          if (hasTexture) {
            ctx.strokeStyle = 'rgba(255,255,255,0.2)';
            ctx.lineWidth = 1;
            ctx.strokeRect(x + 1, y + 1, w - 2, h - 2);
            break;
          }

          // Draw backsplash with material-specific pattern
          const bsName = (el.materialName || '').toLowerCase();
          const bsSeed = Math.floor(x * 13 + y * 19) % 1000;
          const bsRand = (n) => ((bsSeed + n * 29) % 100) / 100;

          // Determine tile style from material name
          let tileStyle = 'subway'; // default
          if (bsName.includes('mosaic') || bsName.includes('penny')) {
            tileStyle = 'mosaic';
          } else if (bsName.includes('herringbone')) {
            tileStyle = 'herringbone';
          } else if (bsName.includes('hexagon') || bsName.includes('hex')) {
            tileStyle = 'hexagon';
          } else if (bsName.includes('arabesque') || bsName.includes('lantern')) {
            tileStyle = 'arabesque';
          } else if (bsName.includes('chevron')) {
            tileStyle = 'chevron';
          } else if (bsName.includes('marble') || bsName.includes('granite') || bsName.includes('quartz') || bsName.includes('slab')) {
            tileStyle = 'slab';
          }

          switch (tileStyle) {
            case 'subway':
              // Classic subway tile (3x6 ratio)
              const subwayH = Math.max(12, h / 4);
              const subwayW = subwayH * 2;
              let subwayRow = 0;

              for (let ty = y; ty < y + h; ty += subwayH) {
                const offset = (subwayRow % 2) * (subwayW / 2);
                for (let tx = x - offset; tx < x + w + subwayW; tx += subwayW) {
                  if (tx + subwayW > x && tx < x + w) {
                    const tileX = Math.max(tx, x);
                    const tileW = Math.min(tx + subwayW, x + w) - tileX;
                    const tileY = Math.max(ty, y);
                    const tileH = Math.min(ty + subwayH, y + h) - tileY;

                    // Tile face with subtle variation
                    const variation = (bsRand(tx + ty) - 0.5) * 10;
                    ctx.fillStyle = adjustColor(el.color, variation);
                    ctx.fillRect(tileX + 1, tileY + 1, tileW - 2, tileH - 2);

                    // Tile bevel highlight (top/left)
                    ctx.fillStyle = 'rgba(255,255,255,0.15)';
                    ctx.fillRect(tileX + 1, tileY + 1, tileW - 2, 2);
                    ctx.fillRect(tileX + 1, tileY + 1, 2, tileH - 2);

                    // Tile bevel shadow (bottom/right)
                    ctx.fillStyle = 'rgba(0,0,0,0.1)';
                    ctx.fillRect(tileX + 1, tileY + tileH - 3, tileW - 2, 2);
                    ctx.fillRect(tileX + tileW - 3, tileY + 1, 2, tileH - 2);
                  }
                }
                subwayRow++;
              }
              // Grout lines
              ctx.strokeStyle = 'rgba(100,100,100,0.4)';
              ctx.lineWidth = 1;
              ctx.strokeRect(x, y, w, h);
              break;

            case 'mosaic':
              // Small mosaic tiles
              const mosaicSize = Math.max(8, Math.min(w, h) / 8);
              for (let ty = y; ty < y + h; ty += mosaicSize) {
                for (let tx = x; tx < x + w; tx += mosaicSize) {
                  const variation = (bsRand(tx * 3 + ty * 7) - 0.5) * 20;
                  ctx.fillStyle = adjustColor(el.color, variation);
                  ctx.fillRect(tx + 0.5, ty + 0.5, mosaicSize - 1, mosaicSize - 1);

                  // Slight 3D effect
                  ctx.fillStyle = 'rgba(255,255,255,0.1)';
                  ctx.fillRect(tx + 0.5, ty + 0.5, mosaicSize - 1, 1);
                }
              }
              break;

            case 'herringbone':
              // Herringbone pattern
              const hbW = Math.max(8, w / 12);
              const hbH = hbW * 3;
              ctx.save();
              ctx.beginPath();
              ctx.rect(x, y, w, h);
              ctx.clip();

              for (let row = -2; row < h / (hbH/2) + 2; row++) {
                for (let col = -2; col < w / hbW + 2; col++) {
                  const isEven = (row + col) % 2 === 0;
                  const tx = x + col * hbW;
                  const ty = y + row * (hbH / 2);

                  ctx.save();
                  ctx.translate(tx + hbW/2, ty + hbH/4);
                  ctx.rotate(isEven ? Math.PI/4 : -Math.PI/4);

                  const variation = (bsRand(row * 5 + col * 11) - 0.5) * 15;
                  ctx.fillStyle = adjustColor(el.color, variation);
                  ctx.fillRect(-hbW/2 + 1, -hbH/4 + 1, hbW - 2, hbH/2 - 2);

                  ctx.restore();
                }
              }
              ctx.restore();
              break;

            case 'hexagon':
              // Hexagon tiles
              const hexR = Math.max(10, Math.min(w, h) / 6);
              const hexH = hexR * Math.sqrt(3);
              let hexRow = 0;

              for (let ty = y - hexH; ty < y + h + hexH; ty += hexH * 0.75) {
                const offset = (hexRow % 2) * (hexR * 1.5);
                for (let tx = x - hexR + offset; tx < x + w + hexR * 2; tx += hexR * 3) {
                  const variation = (bsRand(hexRow * 7 + tx) - 0.5) * 15;
                  ctx.fillStyle = adjustColor(el.color, variation);
                  ctx.beginPath();
                  for (let i = 0; i < 6; i++) {
                    const angle = (Math.PI / 3) * i - Math.PI / 6;
                    const hx = tx + hexR * Math.cos(angle);
                    const hy = ty + hexR * Math.sin(angle);
                    if (i === 0) ctx.moveTo(hx, hy);
                    else ctx.lineTo(hx, hy);
                  }
                  ctx.closePath();
                  ctx.fill();
                  ctx.strokeStyle = 'rgba(100,100,100,0.3)';
                  ctx.lineWidth = 1;
                  ctx.stroke();
                }
                hexRow++;
              }
              break;

            case 'slab':
              // Full slab (like matching countertop)
              drawCountertopSurface(ctx, x, y, w, h, el.color, el.materialName);
              break;

            default:
              // Default grid tiles
              const defTileSize = Math.max(15, Math.min(w, h) / 4);
              for (let ty = y; ty < y + h; ty += defTileSize) {
                for (let tx = x; tx < x + w; tx += defTileSize) {
                  const variation = (bsRand(tx + ty * 3) - 0.5) * 12;
                  ctx.fillStyle = adjustColor(el.color, variation);
                  ctx.fillRect(tx + 1, ty + 1, defTileSize - 2, defTileSize - 2);

                  ctx.fillStyle = 'rgba(255,255,255,0.1)';
                  ctx.fillRect(tx + 1, ty + 1, defTileSize - 2, 2);
                  ctx.fillRect(tx + 1, ty + 1, 2, defTileSize - 2);
                }
              }
          }
          break;

        case 'sink':
        case 'sink-double':
        case 'sink-farmhouse': {
          const isDouble = el.type === 'sink-double';
          const isFarmhouse = el.type === 'sink-farmhouse';
          const basinPadding = Math.min(w, h) * 0.12;

          // Outer rim
          ctx.strokeStyle = isFarmhouse ? 'rgba(200,180,140,0.8)' : 'rgba(180,180,180,0.8)';
          ctx.lineWidth = isFarmhouse ? 4 : 2;
          ctx.strokeRect(x + basinPadding/2, y + basinPadding/2, w - basinPadding, h - basinPadding);

          if (isDouble) {
            // Double basin
            const basinW = (w - basinPadding * 2 - 6) / 2;
            // Left basin
            ctx.fillStyle = 'rgba(60,60,60,0.4)';
            ctx.fillRect(x + basinPadding, y + basinPadding, basinW, h - basinPadding * 2);
            // Right basin
            ctx.fillRect(x + basinPadding + basinW + 6, y + basinPadding, basinW, h - basinPadding * 2);
            // Divider
            ctx.fillStyle = 'rgba(180,180,180,0.6)';
            ctx.fillRect(x + w/2 - 3, y + basinPadding, 6, h - basinPadding * 2);
            // Drains
            ctx.fillStyle = 'rgba(50,50,50,0.7)';
            ctx.beginPath();
            ctx.arc(x + basinPadding + basinW/2, y + h/2, Math.min(w, h) * 0.05, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x + w - basinPadding - basinW/2, y + h/2, Math.min(w, h) * 0.05, 0, Math.PI * 2);
            ctx.fill();
          } else {
            // Single basin
            ctx.fillStyle = isFarmhouse ? 'rgba(245,245,220,0.5)' : 'rgba(60,60,60,0.4)';
            ctx.fillRect(x + basinPadding, y + basinPadding, w - basinPadding * 2, h - basinPadding * 2);
            // Inner basin shadow
            ctx.fillStyle = isFarmhouse ? 'rgba(200,180,140,0.3)' : 'rgba(40,40,40,0.3)';
            ctx.fillRect(x + basinPadding + 4, y + basinPadding + 4, w - basinPadding * 2 - 8, h - basinPadding * 2 - 8);
            // Drain
            ctx.fillStyle = 'rgba(50,50,50,0.7)';
            ctx.beginPath();
            ctx.arc(x + w/2, y + h/2 + 5, Math.min(w, h) * 0.06, 0, Math.PI * 2);
            ctx.fill();
          }

          // Faucet (centered at back)
          ctx.fillStyle = 'rgba(200,200,200,0.9)';
          ctx.fillRect(x + w/2 - 8, y + basinPadding/2 - 6, 16, 8);
          // Faucet spout
          ctx.beginPath();
          ctx.arc(x + w/2, y + basinPadding/2 - 6, 8, Math.PI, 0);
          ctx.fill();
          // Handles
          ctx.fillStyle = 'rgba(180,180,180,0.8)';
          ctx.beginPath();
          ctx.arc(x + w/2 - 20, y + basinPadding/2, 5, 0, Math.PI * 2);
          ctx.fill();
          ctx.beginPath();
          ctx.arc(x + w/2 + 20, y + basinPadding/2, 5, 0, Math.PI * 2);
          ctx.fill();
          break;
        }

        case 'stove':
          // Draw stove burners
          ctx.strokeStyle = 'rgba(50,50,50,0.8)';
          ctx.lineWidth = 2;
          const burnerRadius = Math.min(w, h) * 0.15;
          const positions = [
            [x + w * 0.3, y + h * 0.35],
            [x + w * 0.7, y + h * 0.35],
            [x + w * 0.3, y + h * 0.7],
            [x + w * 0.7, y + h * 0.7]
          ];
          positions.forEach(([bx, by]) => {
            // Outer ring
            ctx.beginPath();
            ctx.arc(bx, by, burnerRadius, 0, Math.PI * 2);
            ctx.stroke();
            // Inner ring
            ctx.beginPath();
            ctx.arc(bx, by, burnerRadius * 0.6, 0, Math.PI * 2);
            ctx.stroke();
            // Grate lines
            ctx.beginPath();
            ctx.moveTo(bx - burnerRadius, by);
            ctx.lineTo(bx + burnerRadius, by);
            ctx.moveTo(bx, by - burnerRadius);
            ctx.lineTo(bx, by + burnerRadius);
            ctx.stroke();
          });
          // Control panel area
          ctx.fillStyle = 'rgba(40,40,40,0.5)';
          ctx.fillRect(x + padding, y + padding, w - padding * 2, h * 0.12);
          break;

        case 'refrigerator':
          // Draw refrigerator doors
          ctx.strokeStyle = 'rgba(150,150,150,0.5)';
          ctx.lineWidth = 2;
          const fridgeMid = y + h * 0.65;
          // Upper section (freezer)
          ctx.strokeRect(x + padding, y + padding, w - padding * 2, fridgeMid - y - padding * 1.5);
          // Lower section (fridge)
          ctx.strokeRect(x + padding, fridgeMid, w - padding * 2, y + h - fridgeMid - padding);
          // Handles
          ctx.fillStyle = 'rgba(200,200,200,0.6)';
          ctx.fillRect(x + w - padding - 6, y + (fridgeMid - y) / 2 - 12, 3, 24);
          ctx.fillRect(x + w - padding - 6, fridgeMid + (y + h - fridgeMid) / 2 - 15, 3, 30);
          // Ice dispenser
          ctx.fillStyle = 'rgba(60,60,60,0.4)';
          ctx.fillRect(x + w * 0.3, y + padding + 10, w * 0.4, 15);
          break;

        case 'dishwasher':
          // Draw dishwasher front
          ctx.strokeStyle = 'rgba(120,120,120,0.5)';
          ctx.lineWidth = 1.5;
          // Main door
          ctx.strokeRect(x + padding, y + padding, w - padding * 2, h - padding * 2);
          // Control panel
          ctx.fillStyle = 'rgba(60,60,60,0.4)';
          ctx.fillRect(x + padding + 4, y + padding + 4, w - padding * 2 - 8, h * 0.12);
          // Handle
          ctx.fillStyle = 'rgba(180,180,180,0.6)';
          ctx.fillRect(x + padding + 8, y + h * 0.18, w - padding * 2 - 16, 4);
          break;

        case 'flooring': {
          // Draw realistic wood plank flooring with grain direction support
          const grainDir = el.grainDirection || 0;
          const floorSeed = (el.x * 11 + el.y * 13) % 50;

          // Save context for rotation if needed
          ctx.save();

          // For diagonal directions, we'll use rotation
          if (grainDir === 45 || grainDir === 135) {
            // Clip to element bounds
            ctx.beginPath();
            ctx.rect(x, y, w, h);
            ctx.clip();

            // Rotate around center
            const cx = x + w / 2;
            const cy = y + h / 2;
            ctx.translate(cx, cy);
            ctx.rotate(grainDir * Math.PI / 180);
            ctx.translate(-cx, -cy);

            // Expand drawing area to cover after rotation
            const diagonal = Math.sqrt(w * w + h * h);
            const expandedX = cx - diagonal / 2;
            const expandedY = cy - diagonal / 2;
            const expandedW = diagonal;
            const expandedH = diagonal;

            drawPlanks(expandedX, expandedY, expandedW, expandedH, 0);
          } else if (grainDir === 90) {
            // Vertical planks - swap dimensions conceptually
            drawPlanks(x, y, w, h, 90);
          } else {
            // Horizontal planks (default)
            drawPlanks(x, y, w, h, 0);
          }

          ctx.restore();

          // Helper function to draw planks
          function drawPlanks(px, py, pw, ph, dir) {
            const plankLong = pixelsPerFoot * 2;
            const plankShort = pixelsPerFoot * 0.35;

            let rowNum = 0;
            if (dir === 90) {
              // Vertical planks
              for (let colX = px; colX < px + pw; colX += plankShort) {
                const colOffset = (rowNum % 3) * (plankLong / 3);
                let plankNum = 0;

                for (let rowY = py - colOffset; rowY < py + ph; rowY += plankLong) {
                  if (rowY + plankLong < py) continue;
                  if (rowY > py + ph) break;

                  const drawX = Math.max(colX, px);
                  const drawW = Math.min(colX + plankShort, px + pw) - drawX;
                  const drawY = Math.max(rowY, py);
                  const drawH = Math.min(rowY + plankLong, py + ph) - drawY;

                  if (drawW > 0 && drawH > 0) {
                    drawSinglePlank(drawX, drawY, drawW, drawH, rowNum, plankNum, true);
                  }
                  plankNum++;
                }
                rowNum++;
              }
            } else {
              // Horizontal planks
              for (let rowY = py; rowY < py + ph; rowY += plankShort) {
                const rowOffset = (rowNum % 3) * (plankLong / 3);
                let plankNum = 0;

                for (let colX = px - rowOffset; colX < px + pw; colX += plankLong) {
                  if (colX + plankLong < px) continue;
                  if (colX > px + pw) break;

                  const drawX = Math.max(colX, px);
                  const drawW = Math.min(colX + plankLong, px + pw) - drawX;
                  const drawY = Math.max(rowY, py);
                  const drawH = Math.min(rowY + plankShort, py + ph) - drawY;

                  if (drawW > 0 && drawH > 0) {
                    drawSinglePlank(drawX, drawY, drawW, drawH, rowNum, plankNum, false);
                  }
                  plankNum++;
                }
                rowNum++;
              }
            }
          }

          function drawSinglePlank(drawX, drawY, drawW, drawH, rowNum, plankNum, vertical) {
            // Plank base with slight color variation
            const variation = ((floorSeed + rowNum * 7 + plankNum * 3) % 20 - 10) / 100;
            ctx.fillStyle = `rgba(${variation > 0 ? 255 : 0},${variation > 0 ? 255 : 0},${variation > 0 ? 255 : 0},${Math.abs(variation)})`;
            ctx.fillRect(drawX, drawY, drawW, drawH);

            // Plank border (groove between planks)
            ctx.strokeStyle = 'rgba(0,0,0,0.2)';
            ctx.lineWidth = 1;
            ctx.strokeRect(drawX + 0.5, drawY + 0.5, drawW - 1, drawH - 1);

            // Wood grain lines
            ctx.strokeStyle = 'rgba(0,0,0,0.06)';
            ctx.lineWidth = 0.5;

            if (vertical) {
              // Vertical grain
              const grainCount = Math.floor(drawW / 4);
              for (let g = 0; g < grainCount; g++) {
                const gx = drawX + 2 + g * (drawW - 4) / Math.max(1, grainCount);
                const wave = Math.sin((floorSeed + plankNum + g) * 0.5) * 2;
                ctx.beginPath();
                ctx.moveTo(gx, drawY + 2);
                ctx.bezierCurveTo(
                  gx + wave, drawY + drawH * 0.3,
                  gx - wave, drawY + drawH * 0.7,
                  gx + wave * 0.5, drawY + drawH - 2
                );
                ctx.stroke();
              }
            } else {
              // Horizontal grain
              const grainCount = Math.floor(drawH / 4);
              for (let g = 0; g < grainCount; g++) {
                const gy = drawY + 2 + g * (drawH - 4) / Math.max(1, grainCount);
                const wave = Math.sin((floorSeed + plankNum + g) * 0.5) * 2;
                ctx.beginPath();
                ctx.moveTo(drawX + 2, gy);
                ctx.bezierCurveTo(
                  drawX + drawW * 0.3, gy + wave,
                  drawX + drawW * 0.7, gy - wave,
                  drawX + drawW - 2, gy + wave * 0.5
                );
                ctx.stroke();
              }
            }

            // Subtle knot marks occasionally
            if ((floorSeed + rowNum + plankNum) % 7 === 0) {
              ctx.fillStyle = 'rgba(0,0,0,0.08)';
              ctx.beginPath();
              ctx.ellipse(
                drawX + Math.abs(drawW) * 0.6,
                drawY + Math.abs(drawH) * 0.5,
                vertical ? 5 : 3, vertical ? 3 : 5, vertical ? 0.8 : 0.3, 0, Math.PI * 2
              );
              ctx.fill();
            }
          }
          break;
        }

        case 'tile': {
          // Draw realistic tile pattern with grout lines and variation
          // Supports diagonal orientation (45 or 135)
          const tileGrainDir = el.grainDirection || 0;
          const tileSz = Math.min(pixelsPerFoot * 0.5, Math.min(w, h) / 3);
          const groutWidth = 2;
          const tileSeed = (el.x * 17 + el.y * 23) % 100;

          ctx.save();

          // Clip to element bounds
          ctx.beginPath();
          ctx.rect(x, y, w, h);
          ctx.clip();

          // For diagonal tiles, rotate the pattern
          if (tileGrainDir === 45 || tileGrainDir === 135) {
            const cx = x + w / 2;
            const cy = y + h / 2;
            ctx.translate(cx, cy);
            ctx.rotate(tileGrainDir * Math.PI / 180);
            ctx.translate(-cx, -cy);

            // Expand drawing area to cover after rotation
            const diagonal = Math.sqrt(w * w + h * h);
            const expandX = cx - diagonal / 2;
            const expandY = cy - diagonal / 2;
            drawTileGrid(expandX, expandY, diagonal, diagonal);
          } else {
            drawTileGrid(x, y, w, h);
          }

          ctx.restore();

          function drawTileGrid(startX, startY, gridW, gridH) {
            // Draw tiles
            let tileRow = 0;
            for (let ty = startY; ty < startY + gridH; ty += tileSz) {
              let tileCol = 0;
              for (let tx = startX; tx < startX + gridW; tx += tileSz) {
                const tileW = tileSz - groutWidth;
                const tileH = tileSz - groutWidth;

                if (tileW > 0 && tileH > 0) {
                  // Subtle color variation per tile
                  const variation = ((tileSeed + tileRow * 5 + tileCol * 3) % 15) / 100;
                  ctx.fillStyle = `rgba(255,255,255,${0.02 + variation * 0.03})`;
                  ctx.fillRect(tx + 1, ty + 1, tileW, tileH);

                  // Tile surface texture (subtle speckling)
                  ctx.fillStyle = 'rgba(255,255,255,0.03)';
                  for (let s = 0; s < 3; s++) {
                    const sx = tx + 5 + ((tileSeed + tileCol + s * 7) % Math.max(1, tileW - 10));
                    const sy = ty + 5 + ((tileSeed + tileRow + s * 11) % Math.max(1, tileH - 10));
                    ctx.beginPath();
                    ctx.arc(sx, sy, 1, 0, Math.PI * 2);
                    ctx.fill();
                  }

                  // Light reflection on tile edge (top-left highlight)
                  ctx.fillStyle = 'rgba(255,255,255,0.08)';
                  ctx.fillRect(tx + 1, ty + 1, tileW, 1);
                  ctx.fillRect(tx + 1, ty + 1, 1, tileH);
                }
                tileCol++;
              }
              tileRow++;
            }

            // Grout lines (darker)
            ctx.strokeStyle = 'rgba(100,100,100,0.4)';
            ctx.lineWidth = groutWidth;
            for (let tx = startX; tx <= startX + gridW; tx += tileSz) {
              ctx.beginPath();
              ctx.moveTo(tx, startY);
              ctx.lineTo(tx, startY + gridH);
              ctx.stroke();
            }
            for (let ty = startY; ty <= startY + gridH; ty += tileSz) {
              ctx.beginPath();
              ctx.moveTo(startX, ty);
              ctx.lineTo(startX + gridW, ty);
              ctx.stroke();
            }
          }
          break;
        }

        case 'door':
          // Draw door with swing arc
          ctx.strokeStyle = 'rgba(255,255,255,0.4)';
          ctx.lineWidth = 1.5;
          // Door panel
          ctx.fillStyle = 'rgba(180,140,100,0.3)';
          ctx.fillRect(x, y, w * 0.1, h);
          // Swing arc
          ctx.beginPath();
          ctx.arc(x, y + h, w * 0.9, -Math.PI/2, 0);
          ctx.stroke();
          // Door line
          ctx.beginPath();
          ctx.moveTo(x, y + h);
          ctx.lineTo(x + w * 0.9, y + h);
          ctx.stroke();
          break;

        case 'window':
          // Draw window with transparent glass effect showing "outside"
          // Outer frame (white)
          ctx.strokeStyle = 'rgba(255,255,255,0.9)';
          ctx.lineWidth = 4;
          ctx.strokeRect(x + 2, y + 2, w - 4, h - 4);

          // Sky gradient background (simulated outdoor view)
          const skyGradient = ctx.createLinearGradient(x, y, x, y + h);
          skyGradient.addColorStop(0, 'rgba(135,206,250,0.7)'); // Light sky blue
          skyGradient.addColorStop(0.6, 'rgba(176,224,230,0.6)'); // Powder blue
          skyGradient.addColorStop(1, 'rgba(144,238,144,0.5)'); // Light green (trees/ground)
          ctx.fillStyle = skyGradient;
          ctx.fillRect(x + 6, y + 6, w - 12, h - 12);

          // Glass reflection effect (diagonal shine)
          ctx.strokeStyle = 'rgba(255,255,255,0.3)';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(x + w * 0.2, y + 4);
          ctx.lineTo(x + 4, y + h * 0.3);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(x + w * 0.35, y + 4);
          ctx.lineTo(x + 4, y + h * 0.5);
          ctx.stroke();

          // Center divider (mullion)
          ctx.strokeStyle = 'rgba(255,255,255,0.8)';
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.moveTo(x + w/2, y + 4);
          ctx.lineTo(x + w/2, y + h - 4);
          ctx.stroke();

          // Horizontal divider for classic look
          ctx.beginPath();
          ctx.moveTo(x + 4, y + h/2);
          ctx.lineTo(x + w - 4, y + h/2);
          ctx.stroke();
          break;

        case 'wall':
        case 'wall-wood-2x4':
        case 'wall-wood-2x6':
          // Wall section with hatch pattern
          ctx.strokeStyle = 'rgba(255,255,255,0.2)';
          ctx.lineWidth = 1;
          const step = 8;
          for (let i = 0; i < Math.max(w, h) * 2; i += step) {
            ctx.beginPath();
            ctx.moveTo(x + i, y);
            ctx.lineTo(x, y + i);
            ctx.stroke();
          }
          // Wood grain for wood walls
          if (type.includes('wood')) {
            ctx.strokeStyle = 'rgba(139,69,19,0.3)';
            ctx.lineWidth = 0.5;
            for (let g = 0; g < 3; g++) {
              ctx.beginPath();
              ctx.moveTo(x + g * w/3, y);
              ctx.lineTo(x + g * w/3, y + h);
              ctx.stroke();
            }
          }
          break;

        case 'wall-steel':
        case 'wall-aluminum':
          // Metal stud pattern
          ctx.strokeStyle = type.includes('steel') ? 'rgba(112,128,144,0.6)' : 'rgba(192,192,192,0.6)';
          ctx.lineWidth = 2;
          const studSpacing = pixelsPerFoot * 1.33; // 16" on center
          for (let sx = x; sx <= x + w; sx += studSpacing) {
            ctx.beginPath();
            ctx.moveTo(sx, y);
            ctx.lineTo(sx, y + h);
            ctx.stroke();
          }
          // Track at top and bottom
          ctx.fillStyle = type.includes('steel') ? 'rgba(112,128,144,0.4)' : 'rgba(192,192,192,0.4)';
          ctx.fillRect(x, y, w, 4);
          ctx.fillRect(x, y + h - 4, w, 4);
          break;

        case 'wall-concrete':
          // Concrete texture
          ctx.fillStyle = 'rgba(128,128,128,0.3)';
          ctx.fillRect(x, y, w, h);
          // Aggregate speckles
          ctx.fillStyle = 'rgba(100,100,100,0.4)';
          for (let i = 0; i < 10; i++) {
            const cx = x + (Math.random() * w);
            const cy = y + (Math.random() * h);
            ctx.beginPath();
            ctx.arc(cx, cy, Math.random() * 3 + 1, 0, Math.PI * 2);
            ctx.fill();
          }
          break;

        case 'wall-brick':
          // Brick pattern
          const brickH = pixelsPerFoot * 0.25;
          const brickW = pixelsPerFoot * 0.67;
          ctx.strokeStyle = 'rgba(139,69,19,0.5)';
          ctx.lineWidth = 1;
          let brickRow = 0;
          for (let by = y; by < y + h; by += brickH) {
            const offset = (brickRow % 2) * (brickW / 2);
            for (let bx = x - offset; bx < x + w; bx += brickW) {
              if (bx + brickW > x && bx < x + w) {
                ctx.strokeRect(Math.max(bx, x), by, Math.min(brickW, x + w - bx), brickH);
              }
            }
            brickRow++;
          }
          break;

        case 'wall-block':
          // CMU block pattern
          const blockH = pixelsPerFoot * 0.67;
          const blockW = pixelsPerFoot * 1.33;
          ctx.strokeStyle = 'rgba(80,80,80,0.5)';
          ctx.lineWidth = 2;
          let blockRow = 0;
          for (let by = y; by < y + h; by += blockH) {
            const offset = (blockRow % 2) * (blockW / 2);
            for (let bx = x - offset; bx < x + w; bx += blockW) {
              if (bx + blockW > x && bx < x + w) {
                ctx.strokeRect(Math.max(bx, x), by, Math.min(blockW, x + w - bx), blockH);
              }
            }
            blockRow++;
          }
          break;

        case 'steel-beam':
          // Steel I-Beam cross-section (horizontal beam)
          ctx.fillStyle = el.color || '#4A4A4A';
          ctx.fillRect(x, y, w, h);
          // Flange highlights
          ctx.fillStyle = 'rgba(255,255,255,0.15)';
          ctx.fillRect(x, y, w, h * 0.2);
          ctx.fillRect(x, y + h * 0.8, w, h * 0.2);
          // Web line
          ctx.strokeStyle = 'rgba(0,0,0,0.3)';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(x, y + h/2);
          ctx.lineTo(x + w, y + h/2);
          ctx.stroke();
          break;

        case 'steel-column':
          // Steel column (square HSS)
          ctx.fillStyle = el.color || '#4A4A4A';
          ctx.fillRect(x, y, w, h);
          // Highlight edges
          ctx.fillStyle = 'rgba(255,255,255,0.2)';
          ctx.fillRect(x, y, w * 0.2, h);
          ctx.fillStyle = 'rgba(0,0,0,0.2)';
          ctx.fillRect(x + w * 0.8, y, w * 0.2, h);
          // Center (hollow indicator)
          ctx.fillStyle = 'rgba(0,0,0,0.3)';
          ctx.fillRect(x + w * 0.25, y + h * 0.25, w * 0.5, h * 0.5);
          break;

        case 'wood-beam':
          // Wood beam (solid timber)
          ctx.fillStyle = el.color || '#8B6914';
          ctx.fillRect(x, y, w, h);
          // Wood grain lines
          ctx.strokeStyle = 'rgba(0,0,0,0.2)';
          ctx.lineWidth = 1;
          for (let gx = x + w * 0.2; gx < x + w; gx += w * 0.25) {
            ctx.beginPath();
            ctx.moveTo(gx, y);
            ctx.lineTo(gx, y + h);
            ctx.stroke();
          }
          // Highlight
          ctx.fillStyle = 'rgba(255,255,255,0.1)';
          ctx.fillRect(x, y, w, h * 0.15);
          break;

        case 'wood-post':
          // Wood post (4x4 or 6x6)
          ctx.fillStyle = el.color || '#8B6914';
          ctx.fillRect(x, y, w, h);
          // Wood grain
          ctx.strokeStyle = 'rgba(0,0,0,0.15)';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(x + w * 0.3, y);
          ctx.lineTo(x + w * 0.3, y + h);
          ctx.moveTo(x + w * 0.5, y);
          ctx.lineTo(x + w * 0.5, y + h);
          ctx.moveTo(x + w * 0.7, y);
          ctx.lineTo(x + w * 0.7, y + h);
          ctx.stroke();
          break;

        case 'concrete-beam':
          // Concrete beam
          ctx.fillStyle = el.color || '#707070';
          ctx.fillRect(x, y, w, h);
          // Aggregate texture
          ctx.fillStyle = 'rgba(0,0,0,0.15)';
          for (let i = 0; i < 8; i++) {
            const cx = x + Math.random() * w;
            const cy = y + Math.random() * h;
            ctx.beginPath();
            ctx.arc(cx, cy, 2 + Math.random() * 3, 0, Math.PI * 2);
            ctx.fill();
          }
          // Form line
          ctx.strokeStyle = 'rgba(0,0,0,0.2)';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(x, y + h/2);
          ctx.lineTo(x + w, y + h/2);
          ctx.stroke();
          break;

        case 'concrete-column':
          // Concrete column
          ctx.fillStyle = el.color || '#707070';
          ctx.fillRect(x, y, w, h);
          // Aggregate spots
          ctx.fillStyle = 'rgba(0,0,0,0.12)';
          for (let i = 0; i < 6; i++) {
            const cx = x + w * 0.15 + Math.random() * w * 0.7;
            const cy = y + h * 0.15 + Math.random() * h * 0.7;
            ctx.beginPath();
            ctx.arc(cx, cy, 2 + Math.random() * 2, 0, Math.PI * 2);
            ctx.fill();
          }
          // Chamfer indicators at corners
          ctx.strokeStyle = 'rgba(0,0,0,0.3)';
          ctx.lineWidth = 2;
          const chamfer = Math.min(w, h) * 0.1;
          ctx.beginPath();
          ctx.moveTo(x, y + chamfer);
          ctx.lineTo(x + chamfer, y);
          ctx.moveTo(x + w - chamfer, y);
          ctx.lineTo(x + w, y + chamfer);
          ctx.moveTo(x + w, y + h - chamfer);
          ctx.lineTo(x + w - chamfer, y + h);
          ctx.moveTo(x + chamfer, y + h);
          ctx.lineTo(x, y + h - chamfer);
          ctx.stroke();
          break;

        case 'header':
          // Header/Lintel
          ctx.fillStyle = el.color || '#CD853F';
          ctx.fillRect(x, y, w, h);
          // Wood grain
          ctx.strokeStyle = 'rgba(0,0,0,0.2)';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(x, y + h/2);
          ctx.lineTo(x + w, y + h/2);
          ctx.stroke();
          // Highlight
          ctx.fillStyle = 'rgba(255,255,255,0.15)';
          ctx.fillRect(x, y, w, h * 0.2);
          break;

        case 'lvl-beam':
          // LVL (Laminated Veneer Lumber) beam
          ctx.fillStyle = el.color || '#DEB887';
          ctx.fillRect(x, y, w, h);
          // Lamination lines
          ctx.strokeStyle = 'rgba(139,105,20,0.3)';
          ctx.lineWidth = 1;
          const lamSpacing = Math.max(4, h / 8);
          for (let ly = y + lamSpacing; ly < y + h; ly += lamSpacing) {
            ctx.beginPath();
            ctx.moveTo(x, ly);
            ctx.lineTo(x + w, ly);
            ctx.stroke();
          }
          break;

        case 'double-door':
          // Double door with two panels
          ctx.strokeStyle = 'rgba(255,255,255,0.4)';
          ctx.lineWidth = 1.5;
          ctx.fillStyle = 'rgba(180,140,100,0.3)';
          // Left door
          ctx.fillRect(x, y, w * 0.05, h);
          ctx.beginPath();
          ctx.arc(x, y + h, w * 0.45, -Math.PI/2, 0);
          ctx.stroke();
          // Right door
          ctx.fillRect(x + w * 0.95, y, w * 0.05, h);
          ctx.beginPath();
          ctx.arc(x + w, y + h, w * 0.45, Math.PI, -Math.PI/2);
          ctx.stroke();
          break;

        case 'sliding-door':
          // Sliding glass door with outdoor view
          // Outdoor background (green/blue gradient)
          const slidingGrad = ctx.createLinearGradient(x, y, x, y + h);
          slidingGrad.addColorStop(0, 'rgba(135,206,235,0.4)'); // Sky blue
          slidingGrad.addColorStop(0.6, 'rgba(135,206,235,0.3)');
          slidingGrad.addColorStop(0.6, 'rgba(144,238,144,0.3)'); // Light green
          slidingGrad.addColorStop(1, 'rgba(34,139,34,0.3)'); // Forest green
          ctx.fillStyle = slidingGrad;
          ctx.fillRect(x, y, w, h);
          ctx.strokeStyle = 'rgba(100,100,100,0.6)';
          ctx.lineWidth = 2;
          ctx.strokeRect(x, y, w, h);
          // Sliding panels
          ctx.strokeStyle = 'rgba(80,80,80,0.5)';
          ctx.beginPath();
          ctx.moveTo(x + w/2, y);
          ctx.lineTo(x + w/2, y + h);
          ctx.stroke();
          // Arrow indicating slide direction
          ctx.fillStyle = 'rgba(255,255,255,0.6)';
          ctx.beginPath();
          ctx.moveTo(x + w * 0.35, y + h/2);
          ctx.lineTo(x + w * 0.25, y + h/2 - 5);
          ctx.lineTo(x + w * 0.25, y + h/2 + 5);
          ctx.fill();
          break;

        case 'glass-door':
          // Single glass door with outdoor view
          const glassDoorGrad = ctx.createLinearGradient(x, y, x, y + h);
          glassDoorGrad.addColorStop(0, 'rgba(135,206,235,0.35)');
          glassDoorGrad.addColorStop(0.65, 'rgba(135,206,235,0.25)');
          glassDoorGrad.addColorStop(0.65, 'rgba(144,238,144,0.25)');
          glassDoorGrad.addColorStop(1, 'rgba(34,139,34,0.25)');
          ctx.fillStyle = glassDoorGrad;
          ctx.fillRect(x, y, w, h);
          // Frame
          ctx.strokeStyle = 'rgba(255,255,255,0.9)';
          ctx.lineWidth = 3;
          ctx.strokeRect(x, y, w, h);
          // Handle
          ctx.fillStyle = 'rgba(200,200,200,0.8)';
          ctx.fillRect(x + w - 10, y + h/2 - 15, 5, 30);
          break;

        case 'french-door':
          // French door with grid and outdoor view
          const frenchDoorGrad = ctx.createLinearGradient(x, y, x, y + h);
          frenchDoorGrad.addColorStop(0, 'rgba(135,206,235,0.35)');
          frenchDoorGrad.addColorStop(0.6, 'rgba(135,206,235,0.25)');
          frenchDoorGrad.addColorStop(0.6, 'rgba(144,238,144,0.25)');
          frenchDoorGrad.addColorStop(1, 'rgba(34,139,34,0.3)');
          ctx.fillStyle = frenchDoorGrad;
          ctx.fillRect(x, y, w, h);
          // Frame
          ctx.strokeStyle = 'rgba(245,245,220,0.9)';
          ctx.lineWidth = 4;
          ctx.strokeRect(x, y, w, h);
          // Center divider
          ctx.beginPath();
          ctx.moveTo(x + w/2, y);
          ctx.lineTo(x + w/2, y + h);
          ctx.stroke();
          // Grid lines
          ctx.lineWidth = 1.5;
          for (let gy = 1; gy < 4; gy++) {
            ctx.beginPath();
            ctx.moveTo(x, y + gy * h/4);
            ctx.lineTo(x + w, y + gy * h/4);
            ctx.stroke();
          }
          break;

        case 'window-large':
          // Large picture window
          const pictureWinGrad = ctx.createLinearGradient(x, y, x, y + h);
          pictureWinGrad.addColorStop(0, 'rgba(135,206,250,0.5)');
          pictureWinGrad.addColorStop(0.55, 'rgba(135,206,250,0.4)');
          pictureWinGrad.addColorStop(0.55, 'rgba(144,238,144,0.35)');
          pictureWinGrad.addColorStop(1, 'rgba(34,139,34,0.4)');
          ctx.fillStyle = pictureWinGrad;
          ctx.fillRect(x, y, w, h);
          // White frame
          ctx.strokeStyle = 'rgba(255,255,255,0.95)';
          ctx.lineWidth = 4;
          ctx.strokeRect(x, y, w, h);
          break;

        case 'window-bay':
          // Bay window (angled trapezoid shape)
          const bayDepth = h * 0.3;
          const bayGrad = ctx.createLinearGradient(x, y, x, y + h);
          bayGrad.addColorStop(0, 'rgba(135,206,250,0.45)');
          bayGrad.addColorStop(0.5, 'rgba(135,206,250,0.35)');
          bayGrad.addColorStop(0.5, 'rgba(144,238,144,0.3)');
          bayGrad.addColorStop(1, 'rgba(34,139,34,0.35)');
          ctx.fillStyle = bayGrad;
          // Draw trapezoid shape
          ctx.beginPath();
          ctx.moveTo(x + bayDepth, y);
          ctx.lineTo(x + w - bayDepth, y);
          ctx.lineTo(x + w, y + h);
          ctx.lineTo(x, y + h);
          ctx.closePath();
          ctx.fill();
          // Frame
          ctx.strokeStyle = 'rgba(255,255,255,0.9)';
          ctx.lineWidth = 3;
          ctx.stroke();
          // Interior lines for panes
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(x + w * 0.33, y + h * 0.1);
          ctx.lineTo(x + w * 0.25, y + h);
          ctx.moveTo(x + w * 0.67, y + h * 0.1);
          ctx.lineTo(x + w * 0.75, y + h);
          ctx.stroke();
          break;

        case 'entry-archway':
          // Archway opening - shows as a transparent passthrough
          // Supports multiple arch styles: round, pointed, flat, elliptical
          const archFrameWidth = Math.max(4, w * 0.08);
          const archStyle2D = el.archwayStyle || 'round';

          // Calculate arch-specific proportions
          let archTopY, archCurveHeight;
          if (archStyle2D === 'flat') {
            archTopY = y + archFrameWidth * 2;
            archCurveHeight = 0;
          } else if (archStyle2D === 'pointed') {
            archTopY = y;
            archCurveHeight = h * 0.4;
          } else if (archStyle2D === 'elliptical') {
            archTopY = y + h * 0.15;
            archCurveHeight = h * 0.2;
          } else { // round
            archTopY = y + h * 0.3;
            archCurveHeight = h * 0.3;
          }

          // Draw "through" view - darker to simulate depth/another room
          ctx.fillStyle = 'rgba(60,60,70,0.4)';
          ctx.beginPath();
          ctx.moveTo(x + archFrameWidth, y + h);
          if (archStyle2D === 'flat') {
            ctx.lineTo(x + archFrameWidth, archTopY);
            ctx.lineTo(x + w - archFrameWidth, archTopY);
          } else if (archStyle2D === 'pointed') {
            ctx.lineTo(x + archFrameWidth, y + h * 0.35);
            ctx.lineTo(x + w/2, archTopY + archFrameWidth);
            ctx.lineTo(x + w - archFrameWidth, y + h * 0.35);
          } else if (archStyle2D === 'elliptical') {
            ctx.lineTo(x + archFrameWidth, archTopY + archCurveHeight);
            ctx.quadraticCurveTo(x + w/2, archTopY, x + w - archFrameWidth, archTopY + archCurveHeight);
          } else { // round
            ctx.lineTo(x + archFrameWidth, y + h * 0.35);
            ctx.quadraticCurveTo(x + w/2, y + archFrameWidth, x + w - archFrameWidth, y + h * 0.35);
          }
          ctx.lineTo(x + w - archFrameWidth, y + h);
          ctx.closePath();
          ctx.fill();

          // Inner shadow for depth
          ctx.fillStyle = 'rgba(40,40,50,0.3)';
          ctx.beginPath();
          ctx.moveTo(x + archFrameWidth, y + h);
          if (archStyle2D === 'flat') {
            ctx.lineTo(x + archFrameWidth, archTopY);
            ctx.lineTo(x + archFrameWidth + 8, archTopY + 3);
          } else if (archStyle2D === 'pointed') {
            ctx.lineTo(x + archFrameWidth, y + h * 0.35);
            ctx.lineTo(x + archFrameWidth + 8, y + h * 0.38);
          } else {
            ctx.lineTo(x + archFrameWidth, y + h * 0.35);
            ctx.lineTo(x + archFrameWidth + 8, y + h * 0.38);
          }
          ctx.lineTo(x + archFrameWidth + 8, y + h);
          ctx.closePath();
          ctx.fill();

          // Arch frame (outer edge - golden/wood color)
          ctx.strokeStyle = 'rgba(218,165,32,0.9)';
          ctx.lineWidth = archFrameWidth;
          ctx.beginPath();
          ctx.moveTo(x + archFrameWidth/2, y + h);
          if (archStyle2D === 'flat') {
            ctx.lineTo(x + archFrameWidth/2, archTopY - archFrameWidth/2);
            ctx.lineTo(x + w - archFrameWidth/2, archTopY - archFrameWidth/2);
          } else if (archStyle2D === 'pointed') {
            ctx.lineTo(x + archFrameWidth/2, y + h * 0.3);
            ctx.lineTo(x + w/2, y);
            ctx.lineTo(x + w - archFrameWidth/2, y + h * 0.3);
          } else if (archStyle2D === 'elliptical') {
            const ellipseY = archTopY + archCurveHeight * 0.5;
            ctx.lineTo(x + archFrameWidth/2, ellipseY);
            ctx.quadraticCurveTo(x + w/2, y - archFrameWidth, x + w - archFrameWidth/2, ellipseY);
          } else { // round
            ctx.lineTo(x + archFrameWidth/2, y + h * 0.3);
            ctx.quadraticCurveTo(x + w/2, y, x + w - archFrameWidth/2, y + h * 0.3);
          }
          ctx.lineTo(x + w - archFrameWidth/2, y + h);
          ctx.stroke();

          // Inner edge highlight
          ctx.strokeStyle = 'rgba(255,235,180,0.5)';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(x + archFrameWidth, y + h);
          if (archStyle2D === 'flat') {
            ctx.lineTo(x + archFrameWidth, archTopY);
            ctx.lineTo(x + w - archFrameWidth, archTopY);
          } else if (archStyle2D === 'pointed') {
            ctx.lineTo(x + archFrameWidth, y + h * 0.35);
            ctx.lineTo(x + w/2, archTopY + archFrameWidth);
            ctx.lineTo(x + w - archFrameWidth, y + h * 0.35);
          } else if (archStyle2D === 'elliptical') {
            ctx.lineTo(x + archFrameWidth, archTopY + archCurveHeight);
            ctx.quadraticCurveTo(x + w/2, archTopY, x + w - archFrameWidth, archTopY + archCurveHeight);
          } else { // round
            ctx.lineTo(x + archFrameWidth, y + h * 0.35);
            ctx.quadraticCurveTo(x + w/2, y + archFrameWidth, x + w - archFrameWidth, y + h * 0.35);
          }
          ctx.lineTo(x + w - archFrameWidth, y + h);
          ctx.stroke();
          break;

        case 'garage-door':
          // Garage door with sections
          ctx.fillStyle = 'rgba(169,169,169,0.4)';
          ctx.fillRect(x, y, w, h);
          ctx.strokeStyle = 'rgba(100,100,100,0.6)';
          ctx.lineWidth = 2;
          ctx.strokeRect(x, y, w, h);
          // Panel sections
          const panelH = h / 4;
          for (let py = y + panelH; py < y + h; py += panelH) {
            ctx.beginPath();
            ctx.moveTo(x, py);
            ctx.lineTo(x + w, py);
            ctx.stroke();
          }
          // Handle
          ctx.fillStyle = 'rgba(80,80,80,0.6)';
          ctx.fillRect(x + w/2 - 10, y + h - panelH/2 - 3, 20, 6);
          break;

        case 'corner-cabinet': {
          // CORNER CABINET - L-shaped with two equal cabinet sections and open shelf in corner
          // Like two equal base cabinets (18") butted together
          const ccToeKickH = Math.max(6, h * 0.1);
          const ccToeKickRecess = Math.max(4, w * 0.05);
          const ccBodyH = h - ccToeKickH;

          // Equal arms - both half width/height
          const ccArmW = w * 0.5;
          const ccArmH = h * 0.5;

          // L-shape cabinet body (clean solid fill)
          ctx.fillStyle = el.color;
          ctx.beginPath();
          ctx.moveTo(x, y);
          ctx.lineTo(x, y + ccBodyH);
          ctx.lineTo(x + ccArmW, y + ccBodyH);
          ctx.lineTo(x + ccArmW, y + ccArmH);
          ctx.lineTo(x + w, y + ccArmH);
          ctx.lineTo(x + w, y);
          ctx.closePath();
          ctx.fill();

          // Toe kick recesses
          ctx.fillStyle = '#0a0a0e';
          ctx.fillRect(x + ccToeKickRecess, y + ccBodyH, ccArmW - ccToeKickRecess, ccToeKickH);

          // Open shelf/box in corner area (dark interior)
          ctx.fillStyle = 'rgba(30,30,35,0.6)';
          ctx.fillRect(x + ccArmW - 4, y + ccArmH - 4, w - ccArmW + 4 - 3, ccBodyH - ccArmH + 4 - 3);

          // Shelf lines
          ctx.strokeStyle = 'rgba(255,255,255,0.1)';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(x + ccArmW, y + ccArmH + (ccBodyH - ccArmH) * 0.5);
          ctx.lineTo(x + w - 3, y + ccArmH + (ccBodyH - ccArmH) * 0.5);
          ctx.stroke();

          // LEFT DOOR (vertical arm - bottom section)
          const leftDoorX = x + 3;
          const leftDoorY = y + ccArmH + 3;
          const leftDoorW = ccArmW - 9;
          const leftDoorH = ccBodyH - ccArmH - 6;

          ctx.fillStyle = el.color;
          ctx.fillRect(leftDoorX, leftDoorY, leftDoorW, leftDoorH);
          ctx.strokeStyle = 'rgba(0,0,0,0.25)';
          ctx.lineWidth = 1;
          ctx.strokeRect(leftDoorX + 0.5, leftDoorY + 0.5, leftDoorW - 1, leftDoorH - 1);

          // Left door shaker panel
          const ccInset = Math.min(8, leftDoorW * 0.1);
          ctx.strokeStyle = 'rgba(0,0,0,0.15)';
          ctx.strokeRect(leftDoorX + ccInset, leftDoorY + ccInset, leftDoorW - ccInset * 2, leftDoorH - ccInset * 2);
          ctx.fillStyle = 'rgba(0,0,0,0.04)';
          ctx.fillRect(leftDoorX + ccInset + 1, leftDoorY + ccInset + 1, leftDoorW - ccInset * 2 - 2, leftDoorH - ccInset * 2 - 2);

          // Left door handle
          ctx.fillStyle = '#C0C0C0';
          ctx.fillRect(leftDoorX + leftDoorW - 7, leftDoorY + leftDoorH / 2 - 8, 3, 16);

          // RIGHT DOOR (horizontal arm - top section)
          const rightDoorX = x + ccArmW + 3;
          const rightDoorY = y + 3;
          const rightDoorW = w - ccArmW - 6;
          const rightDoorH = ccArmH - 6;

          ctx.fillStyle = el.color;
          ctx.fillRect(rightDoorX, rightDoorY, rightDoorW, rightDoorH);
          ctx.strokeStyle = 'rgba(0,0,0,0.25)';
          ctx.strokeRect(rightDoorX + 0.5, rightDoorY + 0.5, rightDoorW - 1, rightDoorH - 1);

          // Right door shaker panel
          ctx.strokeStyle = 'rgba(0,0,0,0.15)';
          ctx.strokeRect(rightDoorX + ccInset, rightDoorY + ccInset, rightDoorW - ccInset * 2, rightDoorH - ccInset * 2);
          ctx.fillStyle = 'rgba(0,0,0,0.04)';
          ctx.fillRect(rightDoorX + ccInset + 1, rightDoorY + ccInset + 1, rightDoorW - ccInset * 2 - 2, rightDoorH - ccInset * 2 - 2);

          // Right door handle
          ctx.fillStyle = '#C0C0C0';
          ctx.fillRect(rightDoorX + rightDoorW / 2 - 8, rightDoorY + rightDoorH - 7, 16, 3);

          // Cabinet outline
          ctx.strokeStyle = 'rgba(0,0,0,0.2)';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(x, y);
          ctx.lineTo(x, y + ccBodyH);
          ctx.lineTo(x + ccArmW, y + ccBodyH);
          ctx.lineTo(x + ccArmW, y + ccArmH);
          ctx.lineTo(x + w, y + ccArmH);
          ctx.lineTo(x + w, y);
          ctx.closePath();
          ctx.stroke();
          break;
        }

        case 'microwave':
          // Draw microwave front
          ctx.strokeStyle = 'rgba(100,100,100,0.6)';
          ctx.lineWidth = 1.5;
          // Door frame
          ctx.strokeRect(x + padding, y + padding, w * 0.75 - padding, h - padding * 2);
          // Glass window
          ctx.fillStyle = 'rgba(20,20,20,0.4)';
          ctx.fillRect(x + padding + 4, y + padding + 4, w * 0.75 - padding - 8, h - padding * 2 - 8);
          // Control panel
          ctx.fillStyle = 'rgba(60,60,60,0.5)';
          ctx.fillRect(x + w * 0.78, y + padding, w * 0.2 - padding, h - padding * 2);
          // Buttons
          ctx.fillStyle = 'rgba(100,100,100,0.6)';
          for (let i = 0; i < 3; i++) {
            ctx.fillRect(x + w * 0.82, y + padding + 8 + i * 12, 8, 8);
          }
          // Handle
          ctx.fillStyle = 'rgba(180,180,180,0.6)';
          ctx.fillRect(x + w * 0.72, y + h/2 - 10, 3, 20);
          break;

        case 'range-hood':
          // Draw range hood (trapezoidal shape from above)
          ctx.strokeStyle = 'rgba(120,120,120,0.6)';
          ctx.lineWidth = 2;
          // Outer shape
          ctx.beginPath();
          ctx.moveTo(x + padding, y + h - padding);
          ctx.lineTo(x + w * 0.2, y + padding);
          ctx.lineTo(x + w * 0.8, y + padding);
          ctx.lineTo(x + w - padding, y + h - padding);
          ctx.closePath();
          ctx.stroke();
          // Filter lines
          ctx.strokeStyle = 'rgba(150,150,150,0.4)';
          ctx.lineWidth = 1;
          const filterLines = 4;
          for (let i = 1; i < filterLines; i++) {
            const yPos = y + padding + (h - padding * 2) * (i / filterLines);
            ctx.beginPath();
            ctx.moveTo(x + w * 0.25, yPos);
            ctx.lineTo(x + w * 0.75, yPos);
            ctx.stroke();
          }
          // Vent duct indicator
          ctx.fillStyle = 'rgba(80,80,80,0.4)';
          ctx.beginPath();
          ctx.arc(x + w/2, y + h * 0.3, Math.min(w, h) * 0.12, 0, Math.PI * 2);
          ctx.fill();
          break;

        case 'oven':
          // Draw wall oven
          ctx.strokeStyle = 'rgba(100,100,100,0.5)';
          ctx.lineWidth = 1.5;
          // Outer frame
          ctx.strokeRect(x + padding, y + padding, w - padding * 2, h - padding * 2);
          // Glass window
          ctx.fillStyle = 'rgba(30,30,30,0.5)';
          ctx.fillRect(x + padding + 6, y + h * 0.25, w - padding * 2 - 12, h * 0.5);
          // Window reflection
          ctx.strokeStyle = 'rgba(255,255,255,0.15)';
          ctx.beginPath();
          ctx.moveTo(x + padding + 10, y + h * 0.3);
          ctx.lineTo(x + w - padding - 20, y + h * 0.3);
          ctx.stroke();
          // Control panel
          ctx.fillStyle = 'rgba(50,50,50,0.6)';
          ctx.fillRect(x + padding + 6, y + padding + 4, w - padding * 2 - 12, h * 0.12);
          // Control knobs
          ctx.fillStyle = 'rgba(120,120,120,0.7)';
          const knobCount = 4;
          for (let i = 0; i < knobCount; i++) {
            const kx = x + padding + 15 + i * (w - padding * 2 - 30) / (knobCount - 1);
            ctx.beginPath();
            ctx.arc(kx, y + padding + 10, 4, 0, Math.PI * 2);
            ctx.fill();
          }
          // Handle
          ctx.fillStyle = 'rgba(180,180,180,0.6)';
          ctx.fillRect(x + w * 0.3, y + h * 0.78, w * 0.4, 3);
          break;

        case 'crown-molding':
          // Crown molding - ornate profile along wall
          ctx.fillStyle = el.color || '#F5F5F5';
          ctx.fillRect(x, y, w, h);
          // Ornate shadow lines
          ctx.strokeStyle = 'rgba(0,0,0,0.2)';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(x, y + h * 0.3);
          ctx.lineTo(x + w, y + h * 0.3);
          ctx.moveTo(x, y + h * 0.6);
          ctx.lineTo(x + w, y + h * 0.6);
          ctx.stroke();
          // Top highlight
          ctx.strokeStyle = 'rgba(255,255,255,0.5)';
          ctx.beginPath();
          ctx.moveTo(x, y + 2);
          ctx.lineTo(x + w, y + 2);
          ctx.stroke();
          // Label
          ctx.fillStyle = 'rgba(0,0,0,0.4)';
          ctx.font = '8px Inter';
          ctx.fillText('Crown', x + 4, y + h - 3);
          break;

        case 'baseboard':
          // Baseboard molding along floor - shadow in FRONT (inside room)
          // First draw shadow (offset outward into room)
          ctx.fillStyle = 'rgba(0,0,0,0.15)';
          ctx.fillRect(x + 2, y + h, w, 4); // Shadow extends into room (below baseboard in plan view)
          // Main baseboard body
          ctx.fillStyle = el.color || '#F5F5F5';
          ctx.fillRect(x, y, w, h);
          // Profile detail lines
          ctx.strokeStyle = 'rgba(0,0,0,0.15)';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(x, y + h * 0.2);
          ctx.lineTo(x + w, y + h * 0.2);
          ctx.moveTo(x, y + h * 0.5);
          ctx.lineTo(x + w, y + h * 0.5);
          ctx.stroke();
          // Top highlight
          ctx.strokeStyle = 'rgba(255,255,255,0.3)';
          ctx.beginPath();
          ctx.moveTo(x, y + 1);
          ctx.lineTo(x + w, y + 1);
          ctx.stroke();
          break;

        case 'chair-rail':
          // Chair rail at mid-height
          ctx.fillStyle = el.color || '#F5F5F5';
          ctx.fillRect(x, y, w, h);
          // Curved profile suggestion
          ctx.strokeStyle = 'rgba(0,0,0,0.2)';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(x, y + h * 0.4);
          ctx.lineTo(x + w, y + h * 0.4);
          ctx.stroke();
          // Top highlight
          ctx.strokeStyle = 'rgba(255,255,255,0.4)';
          ctx.beginPath();
          ctx.moveTo(x, y + 1);
          ctx.lineTo(x + w, y + 1);
          ctx.stroke();
          break;

        case 'fireplace-niche': {
          // Fireplace recess/opening
          const fpPad = padding * 1.5;
          // Outer surround
          ctx.fillStyle = '#4a4a4a';
          ctx.fillRect(x, y, w, h);
          // Inner opening (darker)
          ctx.fillStyle = '#1a1a1a';
          ctx.fillRect(x + fpPad, y + fpPad, w - fpPad * 2, h - fpPad * 2);
          // Fire glow effect
          const glowGrad = ctx.createRadialGradient(
            x + w/2, y + h * 0.7, 0,
            x + w/2, y + h * 0.7, Math.min(w, h) * 0.4
          );
          glowGrad.addColorStop(0, 'rgba(255, 100, 0, 0.7)');
          glowGrad.addColorStop(0.5, 'rgba(255, 50, 0, 0.4)');
          glowGrad.addColorStop(1, 'rgba(0, 0, 0, 0)');
          ctx.fillStyle = glowGrad;
          ctx.fillRect(x + fpPad, y + fpPad, w - fpPad * 2, h - fpPad * 2);
          // Log shapes
          ctx.fillStyle = '#2d1b0e';
          ctx.beginPath();
          ctx.ellipse(x + w * 0.35, y + h * 0.8, w * 0.12, h * 0.06, 0.1, 0, Math.PI * 2);
          ctx.fill();
          ctx.beginPath();
          ctx.ellipse(x + w * 0.65, y + h * 0.78, w * 0.1, h * 0.05, -0.1, 0, Math.PI * 2);
          ctx.fill();
          // Mantel suggestion (top)
          ctx.fillStyle = '#5a4a3a';
          ctx.fillRect(x - 4, y - 6, w + 8, 8);
          break;
        }

        case 'tv-niche': {
          // TV recess/media niche
          const tvPad = padding;
          // Wall frame
          ctx.fillStyle = '#3a3a3a';
          ctx.fillRect(x, y, w, h);
          // Recessed area
          ctx.fillStyle = '#1a1a1a';
          ctx.fillRect(x + tvPad, y + tvPad, w - tvPad * 2, h - tvPad * 2);
          // TV screen
          const screenPad = tvPad * 2;
          ctx.fillStyle = '#111';
          ctx.fillRect(x + screenPad, y + screenPad, w - screenPad * 2, h - screenPad * 2);
          // Screen reflection
          ctx.fillStyle = 'rgba(60, 60, 80, 0.3)';
          ctx.fillRect(x + screenPad + 4, y + screenPad + 4, (w - screenPad * 2) * 0.6, (h - screenPad * 2) * 0.3);
          // TV stand indicator
          ctx.fillStyle = '#2a2a2a';
          ctx.fillRect(x + w * 0.4, y + h - tvPad - 4, w * 0.2, 4);
          break;
        }

        case 'wall-niche':
        case 'shower-niche': {
          // Decorative wall niche
          const nichePad = padding;
          // Frame
          ctx.fillStyle = '#e8e4dc';
          ctx.fillRect(x, y, w, h);
          // Inner recess (shadow)
          ctx.fillStyle = '#c5c0b5';
          ctx.fillRect(x + nichePad, y + nichePad, w - nichePad * 2, h - nichePad * 2);
          // Back of niche
          ctx.fillStyle = '#b5b0a5';
          ctx.fillRect(x + nichePad + 2, y + nichePad + 2, w - nichePad * 2 - 4, h - nichePad * 2 - 4);
          // Shadow on left and top inside
          ctx.fillStyle = 'rgba(0,0,0,0.15)';
          ctx.fillRect(x + nichePad, y + nichePad, 3, h - nichePad * 2);
          ctx.fillRect(x + nichePad, y + nichePad, w - nichePad * 2, 3);
          // Highlight on right and bottom inside
          ctx.fillStyle = 'rgba(255,255,255,0.2)';
          ctx.fillRect(x + w - nichePad - 3, y + nichePad, 3, h - nichePad * 2);
          ctx.fillRect(x + nichePad, y + h - nichePad - 3, w - nichePad * 2, 3);
          break;
        }

        case 'grab-bar':
        case 'grab-bar-24':
        case 'grab-bar-36':
        case 'grab-bar-42': {
          // ADA grab bar
          const barRadius = Math.min(h * 0.4, 6);
          // Mounting plates
          ctx.fillStyle = '#888';
          ctx.beginPath();
          ctx.arc(x + barRadius * 2, y + h/2, barRadius * 1.5, 0, Math.PI * 2);
          ctx.arc(x + w - barRadius * 2, y + h/2, barRadius * 1.5, 0, Math.PI * 2);
          ctx.fill();
          // Bar body
          const barGrad = ctx.createLinearGradient(x, y, x, y + h);
          barGrad.addColorStop(0, '#d0d0d0');
          barGrad.addColorStop(0.3, '#f0f0f0');
          barGrad.addColorStop(0.7, '#c0c0c0');
          barGrad.addColorStop(1, '#a0a0a0');
          ctx.fillStyle = barGrad;
          ctx.beginPath();
          ctx.roundRect(x + barRadius * 2, y + h/2 - barRadius, w - barRadius * 4, barRadius * 2, barRadius);
          ctx.fill();
          // Highlight
          ctx.strokeStyle = 'rgba(255,255,255,0.5)';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(x + barRadius * 3, y + h/2 - barRadius + 2);
          ctx.lineTo(x + w - barRadius * 3, y + h/2 - barRadius + 2);
          ctx.stroke();
          break;
        }

        // ===== DECORATIVE ELEMENTS =====
        case 'mantel': {
          // Fireplace mantel shelf (top-down view)
          ctx.fillStyle = el.color || '#8B7355';
          ctx.strokeStyle = 'rgba(0,0,0,0.3)';
          ctx.lineWidth = 2;

          // Main shelf
          ctx.fillRect(x, y, w, h);
          ctx.strokeRect(x, y, w, h);

          // Front edge detail (thicker/decorative)
          ctx.fillStyle = 'rgba(0,0,0,0.1)';
          ctx.fillRect(x, y + h - 4, w, 4);

          // Corbel indicators on ends
          ctx.fillStyle = 'rgba(0,0,0,0.15)';
          ctx.fillRect(x + 2, y + h * 0.3, 8, h * 0.6);
          ctx.fillRect(x + w - 10, y + h * 0.3, 8, h * 0.6);

          // Wood grain or stone texture lines
          ctx.strokeStyle = 'rgba(0,0,0,0.1)';
          ctx.lineWidth = 1;
          for (let lx = x + 15; lx < x + w - 10; lx += 20) {
            ctx.beginPath();
            ctx.moveTo(lx, y + 2);
            ctx.lineTo(lx, y + h - 2);
            ctx.stroke();
          }
          break;
        }

        case 'fireplace-surround':
        case 'niche-surround': {
          // Stone surround frame (top-down view)
          const isFireplace = el.type === 'fireplace-surround';
          const frameWidth = Math.min(w * 0.15, 15);

          // Outer frame
          ctx.fillStyle = el.color || (isFireplace ? '#8B7355' : '#A09080');
          ctx.strokeStyle = 'rgba(0,0,0,0.3)';
          ctx.lineWidth = 2;
          ctx.fillRect(x, y, w, h);
          ctx.strokeRect(x, y, w, h);

          // Inner opening (dark void)
          ctx.fillStyle = isFireplace ? 'rgba(20,20,20,0.9)' : 'rgba(40,40,40,0.85)';
          ctx.fillRect(x + frameWidth, y + frameWidth, w - frameWidth * 2, h - frameWidth * 2);

          // Inner shadow depth
          ctx.fillStyle = 'rgba(0,0,0,0.3)';
          ctx.fillRect(x + frameWidth, y + frameWidth, w - frameWidth * 2, 4);
          ctx.fillRect(x + frameWidth, y + frameWidth, 4, h - frameWidth * 2);

          // Stone texture on frame
          ctx.fillStyle = 'rgba(255,255,255,0.1)';
          ctx.fillRect(x + 2, y + 2, w - 4, 3);

          if (isFireplace) {
            // Fire glow hint
            const glowGrad = ctx.createRadialGradient(
              x + w/2, y + h * 0.7, 0,
              x + w/2, y + h * 0.7, Math.min(w, h) * 0.25
            );
            glowGrad.addColorStop(0, 'rgba(255, 100, 0, 0.4)');
            glowGrad.addColorStop(1, 'rgba(0, 0, 0, 0)');
            ctx.fillStyle = glowGrad;
            ctx.fillRect(x + frameWidth, y + frameWidth, w - frameWidth * 2, h - frameWidth * 2);
          }
          break;
        }

        case 'fireplace-hearth': {
          // Hearth stone on floor (top-down view)
          ctx.fillStyle = el.color || '#707070';
          ctx.strokeStyle = 'rgba(0,0,0,0.3)';
          ctx.lineWidth = 2;

          // Main hearth
          ctx.beginPath();
          ctx.roundRect(x, y, w, h, 3);
          ctx.fill();
          ctx.stroke();

          // Stone texture - deterministic pattern based on element position
          ctx.fillStyle = 'rgba(0,0,0,0.08)';
          const stoneSpots = [
            { ox: 0.15, oy: 0.25, r: 0.04 },
            { ox: 0.45, oy: 0.4, r: 0.06 },
            { ox: 0.75, oy: 0.2, r: 0.05 },
            { ox: 0.3, oy: 0.7, r: 0.045 },
            { ox: 0.6, oy: 0.65, r: 0.055 }
          ];
          stoneSpots.forEach(spot => {
            const hx = x + 5 + spot.ox * (w - 10);
            const hy = y + 3 + spot.oy * (h - 6);
            const radius = 2 + spot.r * (w + h) / 2;
            ctx.beginPath();
            ctx.arc(hx, hy, radius, 0, Math.PI * 2);
            ctx.fill();
          });

          // Front edge (raised lip)
          ctx.fillStyle = 'rgba(0,0,0,0.15)';
          ctx.fillRect(x, y + h - 5, w, 5);

          // Highlight on front edge
          ctx.fillStyle = 'rgba(255,255,255,0.2)';
          ctx.fillRect(x + 2, y + 2, w - 4, 2);
          break;
        }

        // ===== BATHROOM ELEMENTS =====
        case 'toilet': {
          // Toilet (top-down view)
          const tankW = w * 0.7;
          const tankH = h * 0.35;
          const bowlW = w * 0.85;
          const bowlH = h * 0.65;

          // Tank
          ctx.fillStyle = 'rgba(255,255,255,0.9)';
          ctx.strokeStyle = 'rgba(180,180,180,0.8)';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.roundRect(x + (w - tankW) / 2, y, tankW, tankH, 4);
          ctx.fill();
          ctx.stroke();

          // Bowl (elongated oval)
          ctx.beginPath();
          ctx.ellipse(x + w / 2, y + tankH + bowlH / 2, bowlW / 2, bowlH / 2, 0, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();

          // Seat opening
          ctx.strokeStyle = 'rgba(150,150,150,0.6)';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.ellipse(x + w / 2, y + tankH + bowlH / 2 + 2, bowlW / 2 - 6, bowlH / 2 - 6, 0, 0, Math.PI * 2);
          ctx.stroke();

          // Flush handle
          ctx.fillStyle = 'rgba(192,192,192,0.8)';
          ctx.fillRect(x + (w - tankW) / 2 - 6, y + tankH * 0.4, 8, 4);
          break;
        }

        case 'toilet-round': {
          // Round toilet (top-down view)
          const tankW = w * 0.7;
          const tankH = h * 0.35;
          const bowlW = w * 0.9;
          const bowlH = h * 0.55; // Rounder than elongated

          // Tank
          ctx.fillStyle = 'rgba(255,255,255,0.9)';
          ctx.strokeStyle = 'rgba(180,180,180,0.8)';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.roundRect(x + (w - tankW) / 2, y, tankW, tankH, 4);
          ctx.fill();
          ctx.stroke();

          // Bowl (circular)
          ctx.beginPath();
          const bowlRadius = Math.min(bowlW, bowlH) / 2;
          ctx.arc(x + w / 2, y + tankH + bowlH / 2, bowlRadius, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();

          // Seat opening
          ctx.strokeStyle = 'rgba(150,150,150,0.6)';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.arc(x + w / 2, y + tankH + bowlH / 2 + 2, bowlRadius - 8, 0, Math.PI * 2);
          ctx.stroke();

          // Flush handle
          ctx.fillStyle = 'rgba(192,192,192,0.8)';
          ctx.fillRect(x + (w - tankW) / 2 - 6, y + tankH * 0.4, 8, 4);
          break;
        }

        case 'toilet-wall': {
          // Wall-hung toilet (no visible tank, compact)
          const bowlW = w * 0.9;
          const bowlH = h * 0.85;

          // Wall mount plate
          ctx.fillStyle = 'rgba(200,200,200,0.7)';
          ctx.strokeStyle = 'rgba(160,160,160,0.8)';
          ctx.lineWidth = 2;
          ctx.fillRect(x + w * 0.15, y, w * 0.7, h * 0.12);
          ctx.strokeRect(x + w * 0.15, y, w * 0.7, h * 0.12);

          // Bowl (elongated, floating)
          ctx.fillStyle = 'rgba(255,255,255,0.95)';
          ctx.strokeStyle = 'rgba(180,180,180,0.8)';
          ctx.beginPath();
          ctx.ellipse(x + w / 2, y + h * 0.12 + bowlH / 2, bowlW / 2, bowlH / 2, 0, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();

          // Seat opening
          ctx.strokeStyle = 'rgba(150,150,150,0.6)';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.ellipse(x + w / 2, y + h * 0.12 + bowlH / 2 + 2, bowlW / 2 - 6, bowlH / 2 - 6, 0, 0, Math.PI * 2);
          ctx.stroke();

          // Flush button (on wall)
          ctx.fillStyle = 'rgba(220,220,220,0.9)';
          ctx.strokeStyle = 'rgba(180,180,180,0.8)';
          ctx.beginPath();
          ctx.roundRect(x + w / 2 - 10, y + 2, 20, 8, 2);
          ctx.fill();
          ctx.stroke();
          break;
        }

        case 'bidet': {
          // Bidet (top-down view)
          const rimW = w * 0.85;
          const rimH = h * 0.9;

          // Outer rim
          ctx.fillStyle = 'rgba(255,255,255,0.95)';
          ctx.strokeStyle = 'rgba(180,180,180,0.8)';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.ellipse(x + w / 2, y + h / 2, rimW / 2, rimH / 2, 0, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();

          // Inner basin
          ctx.fillStyle = 'rgba(240,245,250,0.9)';
          ctx.strokeStyle = 'rgba(200,200,200,0.6)';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.ellipse(x + w / 2, y + h / 2, rimW / 2 - 8, rimH / 2 - 8, 0, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();

          // Faucet
          ctx.fillStyle = 'rgba(192,192,192,0.9)';
          ctx.beginPath();
          ctx.arc(x + w / 2, y + 10, 6, 0, Math.PI * 2);
          ctx.fill();

          // Drain
          ctx.fillStyle = 'rgba(128,128,128,0.7)';
          ctx.beginPath();
          ctx.arc(x + w / 2, y + h - 15, 5, 0, Math.PI * 2);
          ctx.fill();
          break;
        }

        case 'bathtub':
        case 'bathtub-freestanding': {
          // Bathtub (top-down view)
          const rimWidth = 6;

          // Outer rim
          ctx.fillStyle = 'rgba(255,255,255,0.95)';
          ctx.strokeStyle = 'rgba(180,180,180,0.8)';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.roundRect(x, y, w, h, 8);
          ctx.fill();
          ctx.stroke();

          // Inner basin
          ctx.fillStyle = 'rgba(240,240,250,0.9)';
          ctx.strokeStyle = 'rgba(200,200,200,0.6)';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.roundRect(x + rimWidth, y + rimWidth, w - rimWidth * 2, h - rimWidth * 2, 6);
          ctx.fill();
          ctx.stroke();

          // Drain
          ctx.fillStyle = 'rgba(128,128,128,0.7)';
          ctx.beginPath();
          ctx.arc(x + w / 2, y + h - rimWidth - 15, 8, 0, Math.PI * 2);
          ctx.fill();

          // Faucet area
          ctx.fillStyle = 'rgba(192,192,192,0.8)';
          ctx.beginPath();
          ctx.arc(x + w / 2, y + rimWidth + 10, 10, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillRect(x + w / 2 - 20, y + rimWidth + 5, 12, 6);
          ctx.fillRect(x + w / 2 + 8, y + rimWidth + 5, 12, 6);
          break;
        }

        case 'bathtub-corner': {
          // Corner bathtub (top-down view - triangular shape)
          const rimWidth = 6;

          // Outer shape (quarter circle)
          ctx.fillStyle = 'rgba(255,255,255,0.95)';
          ctx.strokeStyle = 'rgba(180,180,180,0.8)';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(x, y);
          ctx.lineTo(x + w, y);
          ctx.lineTo(x + w, y + h);
          ctx.arc(x, y + h, Math.min(w, h), 0, -Math.PI / 2, true);
          ctx.closePath();
          ctx.fill();
          ctx.stroke();

          // Inner basin (curved)
          ctx.fillStyle = 'rgba(240,240,250,0.9)';
          ctx.strokeStyle = 'rgba(200,200,200,0.6)';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(x + rimWidth, y + rimWidth);
          ctx.lineTo(x + w - rimWidth, y + rimWidth);
          ctx.lineTo(x + w - rimWidth, y + h - rimWidth);
          ctx.arc(x + rimWidth, y + h - rimWidth, Math.min(w, h) - rimWidth * 2, 0, -Math.PI / 2, true);
          ctx.closePath();
          ctx.fill();
          ctx.stroke();

          // Drain
          ctx.fillStyle = 'rgba(128,128,128,0.7)';
          ctx.beginPath();
          ctx.arc(x + w * 0.6, y + h * 0.6, 8, 0, Math.PI * 2);
          ctx.fill();

          // Faucet area (corner)
          ctx.fillStyle = 'rgba(192,192,192,0.8)';
          ctx.beginPath();
          ctx.arc(x + rimWidth + 15, y + rimWidth + 15, 10, 0, Math.PI * 2);
          ctx.fill();
          break;
        }

        case 'bathtub-walk-in': {
          // Walk-in bathtub with door (top-down view)
          const rimWidth = 6;
          const doorWidth = w * 0.4;

          // Outer tub
          ctx.fillStyle = 'rgba(245,245,245,0.95)';
          ctx.strokeStyle = 'rgba(180,180,180,0.8)';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.roundRect(x, y, w, h, 6);
          ctx.fill();
          ctx.stroke();

          // Inner basin
          ctx.fillStyle = 'rgba(235,235,240,0.9)';
          ctx.strokeStyle = 'rgba(200,200,200,0.6)';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.roundRect(x + rimWidth, y + rimWidth, w - rimWidth * 2, h - rimWidth * 2, 4);
          ctx.fill();
          ctx.stroke();

          // Door indication (on side)
          ctx.strokeStyle = 'rgba(100,100,100,0.7)';
          ctx.lineWidth = 3;
          ctx.setLineDash([4, 2]);
          ctx.beginPath();
          ctx.moveTo(x + (w - doorWidth) / 2, y + h);
          ctx.lineTo(x + (w + doorWidth) / 2, y + h);
          ctx.stroke();
          ctx.setLineDash([]);

          // Door handle
          ctx.fillStyle = 'rgba(192,192,192,0.9)';
          ctx.beginPath();
          ctx.arc(x + w / 2, y + h - 8, 5, 0, Math.PI * 2);
          ctx.fill();

          // Seat (built-in)
          ctx.fillStyle = 'rgba(220,220,225,0.9)';
          ctx.strokeStyle = 'rgba(180,180,180,0.6)';
          ctx.lineWidth = 1;
          ctx.fillRect(x + rimWidth + 4, y + rimWidth + 4, w * 0.35, h * 0.3);
          ctx.strokeRect(x + rimWidth + 4, y + rimWidth + 4, w * 0.35, h * 0.3);

          // Drain
          ctx.fillStyle = 'rgba(128,128,128,0.7)';
          ctx.beginPath();
          ctx.arc(x + w * 0.7, y + h * 0.5, 6, 0, Math.PI * 2);
          ctx.fill();

          // Faucet
          ctx.fillStyle = 'rgba(192,192,192,0.8)';
          ctx.beginPath();
          ctx.arc(x + w - rimWidth - 12, y + rimWidth + 12, 8, 0, Math.PI * 2);
          ctx.fill();
          break;
        }

        case 'shower-base-36':
        case 'shower-base-48':
        case 'shower-base-60': {
          // Shower base/pan (top-down view)
          const isLarge = el.type === 'shower-base-48' || el.type === 'shower-base-60';

          // Base
          ctx.fillStyle = 'rgba(220,220,220,0.95)';
          ctx.strokeStyle = 'rgba(180,180,180,0.8)';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.roundRect(x, y, w, h, 4);
          ctx.fill();
          ctx.stroke();

          // Non-slip texture pattern
          ctx.strokeStyle = 'rgba(200,200,200,0.5)';
          ctx.lineWidth = 1;
          const spacing = 12;
          for (let px = x + spacing; px < x + w - spacing / 2; px += spacing) {
            for (let py = y + spacing; py < y + h - spacing / 2; py += spacing) {
              ctx.beginPath();
              ctx.arc(px, py, 2, 0, Math.PI * 2);
              ctx.stroke();
            }
          }

          // Drain (center or offset)
          ctx.fillStyle = 'rgba(128,128,128,0.8)';
          ctx.strokeStyle = 'rgba(100,100,100,0.7)';
          ctx.lineWidth = 1;
          const drainX = isLarge ? x + w * 0.7 : x + w / 2;
          const drainY = y + h / 2;
          ctx.beginPath();
          ctx.arc(drainX, drainY, 10, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();

          // Drain grate lines
          ctx.strokeStyle = 'rgba(80,80,80,0.6)';
          ctx.lineWidth = 1;
          for (let i = -6; i <= 6; i += 3) {
            ctx.beginPath();
            ctx.moveTo(drainX + i, drainY - 8);
            ctx.lineTo(drainX + i, drainY + 8);
            ctx.stroke();
          }

          // Threshold/curb indication
          ctx.fillStyle = 'rgba(200,200,200,0.8)';
          ctx.fillRect(x, y + h - 6, w, 6);
          break;
        }

        case 'vanity-24':
        case 'vanity-30':
        case 'vanity-36':
        case 'vanity-48':
        case 'vanity-60':
        case 'vanity-72': {
          // Bathroom vanity (top-down view)
          const isDouble = w > pixelsPerFoot * 4;

          // Counter
          ctx.fillStyle = el.color || 'rgba(232,224,216,0.95)';
          ctx.strokeStyle = 'rgba(180,180,180,0.8)';
          ctx.lineWidth = 2;
          ctx.fillRect(x, y, w, h);
          ctx.strokeRect(x, y, w, h);

          // Sink basin(s)
          const sinkPadding = w * 0.15;
          const sinkW = isDouble ? (w - sinkPadding * 3) / 2 : w - sinkPadding * 2;
          const sinkH = h * 0.5;
          const sinkY = y + (h - sinkH) / 2;

          ctx.fillStyle = 'rgba(255,255,255,0.9)';
          ctx.strokeStyle = 'rgba(200,200,200,0.8)';
          ctx.lineWidth = 1;

          if (isDouble) {
            // Left sink
            ctx.beginPath();
            ctx.ellipse(x + sinkPadding + sinkW / 2, sinkY + sinkH / 2, sinkW / 2, sinkH / 2, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            // Right sink
            ctx.beginPath();
            ctx.ellipse(x + w - sinkPadding - sinkW / 2, sinkY + sinkH / 2, sinkW / 2, sinkH / 2, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
          } else {
            // Single sink
            ctx.beginPath();
            ctx.ellipse(x + w / 2, sinkY + sinkH / 2, sinkW / 2, sinkH / 2, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
          }

          // Faucet(s)
          ctx.fillStyle = 'rgba(192,192,192,0.9)';
          if (isDouble) {
            ctx.beginPath();
            ctx.arc(x + sinkPadding + sinkW / 2, y + 8, 5, 0, Math.PI * 2);
            ctx.arc(x + w - sinkPadding - sinkW / 2, y + 8, 5, 0, Math.PI * 2);
            ctx.fill();
          } else {
            ctx.beginPath();
            ctx.arc(x + w / 2, y + 8, 6, 0, Math.PI * 2);
            ctx.fill();
          }
          break;
        }

        case 'shower-bench': {
          // Built-in shower bench (top-down view)
          ctx.fillStyle = el.color || 'rgba(212,212,212,0.9)';
          ctx.strokeStyle = 'rgba(160,160,160,0.8)';
          ctx.lineWidth = 2;
          ctx.fillRect(x, y, w, h);
          ctx.strokeRect(x, y, w, h);

          // Seat indication lines
          ctx.strokeStyle = 'rgba(180,180,180,0.5)';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(x + 4, y + 4);
          ctx.lineTo(x + 4, y + h - 4);
          ctx.moveTo(x + w - 4, y + 4);
          ctx.lineTo(x + w - 4, y + h - 4);
          ctx.stroke();
          break;
        }

        case 'towel-warmer': {
          // Wall-mounted towel warmer (front view)
          ctx.strokeStyle = 'rgba(192,192,192,0.9)';
          ctx.lineWidth = 3;

          // Vertical rails
          ctx.beginPath();
          ctx.moveTo(x + 4, y);
          ctx.lineTo(x + 4, y + h);
          ctx.moveTo(x + w - 4, y);
          ctx.lineTo(x + w - 4, y + h);
          ctx.stroke();

          // Horizontal bars
          const numBars = Math.max(4, Math.floor(h / 15));
          ctx.lineWidth = 2;
          for (let i = 0; i < numBars; i++) {
            const barY = y + 8 + (i * (h - 16) / (numBars - 1));
            ctx.beginPath();
            ctx.moveTo(x + 4, barY);
            ctx.lineTo(x + w - 4, barY);
            ctx.stroke();
          }
          break;
        }

        // ===== LAUNDRY ELEMENTS =====
        case 'washer': {
          // Front-loading washer (top-down view)
          ctx.fillStyle = 'rgba(240,240,240,0.95)';
          ctx.strokeStyle = 'rgba(180,180,180,0.8)';
          ctx.lineWidth = 2;
          ctx.fillRect(x, y, w, h);
          ctx.strokeRect(x, y, w, h);

          // Door circle
          const doorRadius = Math.min(w, h) * 0.35;
          ctx.fillStyle = 'rgba(74,96,128,0.4)';
          ctx.strokeStyle = 'rgba(160,160,160,0.8)';
          ctx.beginPath();
          ctx.arc(x + w / 2, y + h * 0.55, doorRadius, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();

          // Control panel
          ctx.fillStyle = 'rgba(60,60,60,0.7)';
          ctx.fillRect(x + 6, y + 6, w - 12, h * 0.15);

          // Dial
          ctx.fillStyle = 'rgba(192,192,192,0.9)';
          ctx.beginPath();
          ctx.arc(x + w * 0.25, y + 6 + h * 0.075, 8, 0, Math.PI * 2);
          ctx.fill();
          break;
        }

        case 'dryer': {
          // Front-loading dryer (top-down view)
          ctx.fillStyle = 'rgba(232,232,232,0.95)';
          ctx.strokeStyle = 'rgba(180,180,180,0.8)';
          ctx.lineWidth = 2;
          ctx.fillRect(x, y, w, h);
          ctx.strokeRect(x, y, w, h);

          // Door circle (solid)
          const dryerDoorRadius = Math.min(w, h) * 0.35;
          ctx.fillStyle = 'rgba(216,216,216,0.9)';
          ctx.strokeStyle = 'rgba(160,160,160,0.8)';
          ctx.beginPath();
          ctx.arc(x + w / 2, y + h * 0.55, dryerDoorRadius, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();

          // Control panel
          ctx.fillStyle = 'rgba(70,70,70,0.7)';
          ctx.fillRect(x + 6, y + 6, w - 12, h * 0.15);

          // Dials
          ctx.fillStyle = 'rgba(192,192,192,0.9)';
          ctx.beginPath();
          ctx.arc(x + w * 0.25, y + 6 + h * 0.075, 7, 0, Math.PI * 2);
          ctx.arc(x + w * 0.75, y + 6 + h * 0.075, 7, 0, Math.PI * 2);
          ctx.fill();
          break;
        }

        case 'utility-sink':
        case 'laundry-sink': {
          // Deep utility sink (top-down view)
          ctx.fillStyle = 'rgba(245,245,245,0.95)';
          ctx.strokeStyle = 'rgba(180,180,180,0.8)';
          ctx.lineWidth = 2;
          ctx.fillRect(x, y, w, h);
          ctx.strokeRect(x, y, w, h);

          // Basin
          const basinPad = 8;
          ctx.fillStyle = 'rgba(232,232,232,0.9)';
          ctx.strokeStyle = 'rgba(200,200,200,0.8)';
          ctx.lineWidth = 1;
          ctx.fillRect(x + basinPad, y + basinPad, w - basinPad * 2, h - basinPad * 2);
          ctx.strokeRect(x + basinPad, y + basinPad, w - basinPad * 2, h - basinPad * 2);

          // Drain
          ctx.fillStyle = 'rgba(128,128,128,0.7)';
          ctx.beginPath();
          ctx.arc(x + w / 2, y + h / 2, 6, 0, Math.PI * 2);
          ctx.fill();

          // Faucet
          ctx.fillStyle = 'rgba(176,176,176,0.9)';
          ctx.beginPath();
          ctx.arc(x + w / 2, y + basinPad + 8, 8, 0, Math.PI * 2);
          ctx.fill();
          break;
        }

        case 'drying-rack': {
          // Drying rack (top-down view)
          ctx.strokeStyle = 'rgba(192,192,192,0.8)';
          ctx.lineWidth = 2;

          // Frame
          ctx.strokeRect(x, y, w, h);

          // Rods
          const numRods = Math.max(4, Math.floor(h / 12));
          ctx.lineWidth = 1.5;
          for (let i = 0; i < numRods; i++) {
            const rodY = y + 4 + (i * (h - 8) / (numRods - 1));
            ctx.beginPath();
            ctx.moveTo(x + 3, rodY);
            ctx.lineTo(x + w - 3, rodY);
            ctx.stroke();
          }
          break;
        }

        case 'washer-dryer-stack': {
          // Stacked washer/dryer (top-down shows washer on bottom)
          ctx.fillStyle = 'rgba(240,240,240,0.95)';
          ctx.strokeStyle = 'rgba(180,180,180,0.8)';
          ctx.lineWidth = 2;
          ctx.fillRect(x, y, w, h);
          ctx.strokeRect(x, y, w, h);

          // Door circle (washer door, visible from top)
          const doorRadius = Math.min(w, h) * 0.32;
          ctx.fillStyle = 'rgba(74,96,128,0.4)';
          ctx.strokeStyle = 'rgba(160,160,160,0.8)';
          ctx.beginPath();
          ctx.arc(x + w / 2, y + h * 0.55, doorRadius, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();

          // Control panel
          ctx.fillStyle = 'rgba(50,50,50,0.7)';
          ctx.fillRect(x + 6, y + 6, w - 12, h * 0.12);

          // Dial
          ctx.fillStyle = 'rgba(192,192,192,0.9)';
          ctx.beginPath();
          ctx.arc(x + w * 0.25, y + 6 + h * 0.06, 6, 0, Math.PI * 2);
          ctx.fill();

          // Stack indicator line
          ctx.strokeStyle = 'rgba(100,100,100,0.6)';
          ctx.setLineDash([4, 2]);
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(x + 2, y + h * 0.2);
          ctx.lineTo(x + w - 2, y + h * 0.2);
          ctx.stroke();
          ctx.setLineDash([]);

          // "S" label for stacked
          ctx.fillStyle = 'rgba(80,80,80,0.7)';
          ctx.font = 'bold 12px sans-serif';
          ctx.textAlign = 'center';
          ctx.fillText('STACK', x + w / 2, y + h * 0.15);
          break;
        }

        case 'laundry-cabinet': {
          // Laundry room cabinet (top-down view)
          ctx.fillStyle = el.color || 'rgba(139,115,85,0.95)';
          ctx.strokeStyle = 'rgba(100,80,60,0.8)';
          ctx.lineWidth = 2;
          ctx.fillRect(x, y, w, h);
          ctx.strokeRect(x, y, w, h);

          // Door split line
          ctx.strokeStyle = 'rgba(80,60,40,0.5)';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(x + w / 2, y + 2);
          ctx.lineTo(x + w / 2, y + h - 2);
          ctx.stroke();

          // Handles
          ctx.fillStyle = 'rgba(192,192,192,0.9)';
          ctx.fillRect(x + w / 2 - 12, y + h / 2 - 3, 6, 6);
          ctx.fillRect(x + w / 2 + 6, y + h / 2 - 3, 6, 6);

          // Counter top indication
          ctx.strokeStyle = 'rgba(120,100,80,0.4)';
          ctx.lineWidth = 1;
          ctx.strokeRect(x + 2, y + 2, w - 4, h - 4);
          break;
        }

        case 'ironing-board': {
          // Ironing board (top-down view - shows tapered shape)
          // Board shape (wider at one end)
          ctx.fillStyle = 'rgba(200,200,200,0.95)';
          ctx.strokeStyle = 'rgba(160,160,160,0.8)';
          ctx.lineWidth = 2;

          ctx.beginPath();
          // Tapered shape: narrow at top, wider at bottom
          const narrowEnd = w * 0.4;
          const wideEnd = w * 0.9;
          ctx.moveTo(x + (w - narrowEnd) / 2, y);
          ctx.lineTo(x + (w + narrowEnd) / 2, y);
          ctx.lineTo(x + (w + wideEnd) / 2, y + h);
          ctx.lineTo(x + (w - wideEnd) / 2, y + h);
          ctx.closePath();
          ctx.fill();
          ctx.stroke();

          // Padding/cover pattern (subtle lines)
          ctx.strokeStyle = 'rgba(180,180,180,0.4)';
          ctx.lineWidth = 1;
          for (let ly = y + 10; ly < y + h - 5; ly += 8) {
            const progress = (ly - y) / h;
            const lineW = narrowEnd + (wideEnd - narrowEnd) * progress;
            ctx.beginPath();
            ctx.moveTo(x + (w - lineW) / 2 + 4, ly);
            ctx.lineTo(x + (w + lineW) / 2 - 4, ly);
            ctx.stroke();
          }

          // Legs indication (X pattern)
          ctx.strokeStyle = 'rgba(100,100,100,0.5)';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(x + w * 0.3, y + h * 0.3);
          ctx.lineTo(x + w * 0.7, y + h * 0.7);
          ctx.moveTo(x + w * 0.7, y + h * 0.3);
          ctx.lineTo(x + w * 0.3, y + h * 0.7);
          ctx.stroke();
          break;
        }

        // ===== CLOSET ELEMENTS =====
        case 'closet-rod': {
          // Clothing rod (top-down view shows as line)
          ctx.strokeStyle = 'rgba(192,192,192,0.9)';
          ctx.lineWidth = 4;
          ctx.beginPath();
          ctx.moveTo(x, y + h / 2);
          ctx.lineTo(x + w, y + h / 2);
          ctx.stroke();

          // End brackets
          ctx.fillStyle = 'rgba(128,128,128,0.8)';
          ctx.fillRect(x, y + h / 2 - 6, 8, 12);
          ctx.fillRect(x + w - 8, y + h / 2 - 6, 8, 12);
          break;
        }

        case 'closet-shelf': {
          // Closet shelf (top-down view)
          ctx.fillStyle = el.color || 'rgba(232,232,232,0.9)';
          ctx.strokeStyle = 'rgba(200,200,200,0.8)';
          ctx.lineWidth = 1;
          ctx.fillRect(x, y, w, h);
          ctx.strokeRect(x, y, w, h);

          // Front edge
          ctx.fillStyle = 'rgba(210,210,210,0.9)';
          ctx.fillRect(x, y + h - 4, w, 4);
          break;
        }

        case 'closet-drawers': // Alias for drawer-unit
        case 'drawer-unit': {
          // Multi-drawer unit (top-down view)
          ctx.fillStyle = el.color || 'rgba(245,240,230,0.95)';
          ctx.strokeStyle = 'rgba(180,180,180,0.8)';
          ctx.lineWidth = 2;
          ctx.fillRect(x, y, w, h);
          ctx.strokeRect(x, y, w, h);

          // Drawer fronts
          const numDrawers = Math.max(3, Math.floor(h / 20));
          const drawerH = (h - 8) / numDrawers;
          ctx.strokeStyle = 'rgba(160,160,160,0.6)';
          ctx.lineWidth = 1;
          for (let i = 0; i < numDrawers; i++) {
            const dY = y + 4 + i * drawerH;
            ctx.strokeRect(x + 4, dY, w - 8, drawerH - 2);

            // Handle
            ctx.fillStyle = 'rgba(192,192,192,0.8)';
            ctx.fillRect(x + w / 2 - 10, dY + drawerH / 2 - 2, 20, 4);
          }
          break;
        }

        case 'shoe-rack': {
          // Shoe rack (top-down view)
          ctx.fillStyle = el.color || 'rgba(222,184,135,0.9)';
          ctx.strokeStyle = 'rgba(180,160,140,0.8)';
          ctx.lineWidth = 2;
          ctx.fillRect(x, y, w, h);
          ctx.strokeRect(x, y, w, h);

          // Shelves
          const numShelves = Math.max(3, Math.floor(h / 18));
          ctx.strokeStyle = 'rgba(160,140,120,0.6)';
          ctx.lineWidth = 1;
          for (let i = 1; i < numShelves; i++) {
            const shelfY = y + (i * h / numShelves);
            ctx.beginPath();
            ctx.moveTo(x + 4, shelfY);
            ctx.lineTo(x + w - 4, shelfY);
            ctx.stroke();
          }
          break;
        }

        case 'closet-island': {
          // Closet island (top-down view)
          ctx.fillStyle = el.color || 'rgba(245,240,230,0.95)';
          ctx.strokeStyle = 'rgba(180,180,180,0.8)';
          ctx.lineWidth = 2;
          ctx.fillRect(x, y, w, h);
          ctx.strokeRect(x, y, w, h);

          // Top surface (different color)
          ctx.fillStyle = 'rgba(232,224,216,0.9)';
          ctx.fillRect(x + 2, y + 2, w - 4, h - 4);

          // Drawer indication
          ctx.strokeStyle = 'rgba(200,190,180,0.6)';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(x + w / 4, y + 4);
          ctx.lineTo(x + w / 4, y + h - 4);
          ctx.moveTo(x + w * 3 / 4, y + 4);
          ctx.lineTo(x + w * 3 / 4, y + h - 4);
          ctx.stroke();
          break;
        }

        case 'jewelry-drawer': // Alias for jewelry-cabinet style
        case 'jewelry-cabinet': {
          // Jewelry cabinet (front view in 2D)
          ctx.fillStyle = el.color || 'rgba(245,240,230,0.95)';
          ctx.strokeStyle = 'rgba(180,180,180,0.8)';
          ctx.lineWidth = 2;
          ctx.fillRect(x, y, w, h);
          ctx.strokeRect(x, y, w, h);

          // Mirror
          ctx.fillStyle = 'rgba(200,210,220,0.7)';
          ctx.fillRect(x + 6, y + 6, w - 12, h - 12);

          // Mirror shine
          ctx.strokeStyle = 'rgba(255,255,255,0.4)';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(x + w * 0.2, y + 6);
          ctx.lineTo(x + 6, y + h * 0.3);
          ctx.stroke();
          break;
        }

        case 'tie-rack': {
          // Tie/belt rack (top-down view shows as bar with hooks)
          ctx.fillStyle = el.color || 'rgba(160,160,160,0.9)';
          ctx.strokeStyle = 'rgba(128,128,128,0.8)';
          ctx.lineWidth = 2;

          // Main bar
          ctx.fillRect(x, y, w, 8);
          ctx.strokeRect(x, y, w, 8);

          // Hooks/pegs
          const numHooks = Math.max(3, Math.floor(w / 15));
          const hookSpacing = w / (numHooks + 1);
          ctx.fillStyle = 'rgba(192,192,192,0.9)';
          for (let i = 1; i <= numHooks; i++) {
            const hookX = x + i * hookSpacing;
            ctx.beginPath();
            ctx.arc(hookX, y + h / 2, 4, 0, Math.PI * 2);
            ctx.fill();
          }

          // Ties hanging (visual indicator)
          ctx.lineWidth = 3;
          const tieColors = ['#4169E1', '#DC143C', '#228B22', '#8B4513', '#4B0082'];
          for (let i = 1; i <= Math.min(numHooks, 5); i++) {
            const tieX = x + i * hookSpacing;
            ctx.strokeStyle = tieColors[(i - 1) % tieColors.length];
            ctx.beginPath();
            ctx.moveTo(tieX, y + 8);
            ctx.lineTo(tieX - 2, y + h - 4);
            ctx.lineTo(tieX + 2, y + h - 4);
            ctx.closePath();
            ctx.stroke();
          }
          break;
        }

        case 'full-mirror': {
          // Full-length mirror (top-down view shows as thin rectangle)
          // Frame
          ctx.fillStyle = 'rgba(139,115,85,0.9)';
          ctx.strokeStyle = 'rgba(100,80,60,0.8)';
          ctx.lineWidth = 2;
          ctx.fillRect(x, y, w, h);
          ctx.strokeRect(x, y, w, h);

          // Mirror surface (reflective appearance)
          ctx.fillStyle = 'rgba(220,230,240,0.85)';
          ctx.fillRect(x + 3, y + 3, w - 6, h - 6);

          // Shine effect
          ctx.fillStyle = 'rgba(255,255,255,0.3)';
          ctx.beginPath();
          ctx.moveTo(x + 3, y + 3);
          ctx.lineTo(x + w / 3, y + 3);
          ctx.lineTo(x + 3, y + h / 3);
          ctx.closePath();
          ctx.fill();
          break;
        }
      }

      ctx.lineWidth = 1;
    }

    function drawElements() {
      // Define z-order for element types (lower = drawn first = below)
      // Layer 0-9: Floor level (flooring, rugs)
      // Layer 10-19: Base level (cabinets, appliances on floor)
      // Layer 20-29: Counter level (countertops, sinks)
      // Layer 30-39: Above counter (backsplash, upper cabs)
      // Layer 40-49: Wall fixtures (windows, doors, niches)
      // Layer 50-59: Walls and partitions
      // Layer 60+: Annotations, labels
      const zOrder = {
        // Floor level
        'flooring': 0,
        'tile': 1,
        'rug': 2,
        'threshold': 3,
        'fireplace-hearth': 4,

        // Base level
        'island': 10,
        'base-cabinet': 11,
        'drawer-base': 11,
        'sink-base': 11,
        'corner-cabinet': 12,
        'lazy-susan': 12,
        'tall-cabinet': 13,
        'pantry': 13,
        'refrigerator': 14,
        'oven': 14,
        'dishwasher': 14,
        'stove': 15,
        'range': 15,
        'cooktop': 16,

        // Counter level
        'countertop': 20,
        'bar-top': 21,
        'wall-cap': 21,
        'sink': 22,
        'sink-double': 22,
        'sink-farmhouse': 22,

        // Above counter
        'backsplash': 30,
        'wall-cabinet': 31,
        'range-hood': 32,
        'microwave': 32,

        // Wall fixtures
        'window': 40,
        'bay-window': 40,
        'picture-window': 40,
        'door': 41,
        'sliding-door': 41,
        'french-door': 41,
        'glass-door': 41,
        'wall-niche': 42,
        'shower-niche': 42,
        'fireplace-niche': 43,
        'tv-niche': 43,
        'grab-bar': 44,
        'grab-bar-24': 44,
        'grab-bar-36': 44,
        'grab-bar-42': 44,

        // Walls and partitions
        'wall': 50,
        'wall-block': 50,
        'wall-concrete': 50,
        'wall-framed': 50,
        'pony-wall': 51,
        'pony-wall-bar': 51,
        'knee-wall': 51,

        // Fixtures and accessories (bathroom)
        'toilet': 45,
        'toilet-round': 45,
        'toilet-wall': 45,
        'bidet': 45,
        'bathtub': 45,
        'bathtub-freestanding': 45,
        'bathtub-corner': 45,
        'bathtub-walk-in': 45,
        'shower': 45,
        'shower-base-36': 5,
        'shower-base-48': 5,
        'shower-base-60': 5,
        'vanity-24': 46,
        'vanity-30': 46,
        'vanity-36': 46,
        'vanity-48': 46,
        'vanity-60': 46,
        'vanity-72': 46,
        'shower-bench': 44,
        'towel-warmer': 47,

        // Laundry elements
        'washer': 14,
        'dryer': 14,
        'washer-dryer-stack': 14,
        'laundry-cabinet': 13,
        'ironing-board': 15,
        'utility-sink': 22,
        'laundry-sink': 22,
        'drying-rack': 47,

        // Closet elements
        'closet-rod': 35,
        'closet-shelf': 36,
        'drawer-unit': 13,
        'closet-drawers': 13,
        'shoe-rack': 12,
        'closet-island': 11,
        'jewelry-cabinet': 46,
        'jewelry-drawer': 46,
        'tie-rack': 37,
        'full-mirror': 48,

        // Decorative
        'crown-molding': 55,
        'mantel': 55,
        'fireplace-surround': 55,
        'niche-surround': 55
      };

      // Filter out hidden elements based on visibility settings AND by current room
      const visibleElements = elements.filter(el => {
        if (el.hidden) return false;
        // Only show elements belonging to current room (check both room tracking systems)
        const activeRoomId = currentRoomId || currentRoom || 'default';
        if (el.roomId && el.roomId !== activeRoomId && el.roomId !== currentRoom) return false;
        const category = getElementCategory(el.type);
        return !hiddenCategories[category];
      });

      // Sort elements by z-order, then by custom zIndex override, then selected last
      const sortedElements = [...visibleElements].sort((a, b) => {
        // Selected element always draws last (on top)
        if (a === selectedElement) return 1;
        if (b === selectedElement) return -1;

        // Get base z-order from type
        const aBase = zOrder[a.type] ?? 25;
        const bBase = zOrder[b.type] ?? 25;

        // Apply custom zIndex offset if set (from send to back/bring to front)
        const aZ = aBase + (a.zIndexOffset || 0);
        const bZ = bBase + (b.zIndexOffset || 0);

        return aZ - bZ;
      });

      sortedElements.forEach(el => {
        drawElement(el, el === selectedElement);
      });
    }

    // Get element category for visibility toggles
    function getElementCategory(type) {
      const categories = {
        cabinets: ['base-cabinet', 'drawer-base', 'sink-base', 'corner-cabinet', 'lazy-susan', 'blind-corner', 'wall-cabinet', 'tall-cabinet', 'pantry', 'island', 'vanity', 'microwave-cabinet', 'above-microwave-cabinet', 'single-oven-cabinet', 'tall-oven', 'double-oven-cabinet', 'fridge-cabinet'],
        countertops: ['countertop', 'countertop-corner', 'countertop-l', 'countertop-u', 'bar-top', 'wall-cap', 'backsplash', 'surface-stainless', 'surface-solid', 'surface-laminate', 'surface-butcherblock', 'surface-concrete', 'window-sill'],
        appliances: ['refrigerator', 'stove', 'range', 'slide-in-range', 'cooktop', 'oven', 'wall-oven-double', 'dishwasher', 'microwave', 'range-hood'],
        sinks: ['sink', 'sink-double', 'sink-farmhouse'],
        flooring: ['flooring', 'tile', 'rug', 'threshold'],
        walls: ['wall', 'wall-block', 'wall-concrete', 'wall-framed', 'wall-wood-2x4', 'wall-wood-2x6', 'wall-brick', 'wall-steel', 'wall-aluminum', 'pony-wall', 'pony-wall-bar', 'knee-wall', 'shower-wall', 'wall-tile', 'accent-wall'],
        windows: ['window', 'window-large', 'bay-window', 'picture-window'],
        doors: ['door', 'double-door', 'sliding-door', 'french-door', 'glass-door', 'entry-archway', 'garage-door'],
        niches: ['wall-niche', 'shower-niche', 'fireplace-niche', 'tv-niche', 'niche-surround'],
        fixtures: ['toilet', 'toilet-round', 'toilet-wall', 'bidet', 'bathtub', 'bathtub-freestanding', 'bathtub-corner', 'bathtub-walk-in', 'shower', 'shower-base-36', 'shower-base-48', 'shower-base-60', 'grab-bar', 'grab-bar-24', 'grab-bar-36', 'grab-bar-42', 'shower-pan', 'shower-curb', 'shower-bench', 'towel-warmer'],
        bathroom: ['vanity-24', 'vanity-30', 'vanity-36', 'vanity-48', 'vanity-60', 'vanity-72'],
        laundry: ['washer', 'dryer', 'washer-dryer-stack', 'laundry-cabinet', 'ironing-board', 'utility-sink', 'laundry-sink', 'drying-rack'],
        closet: ['closet-rod', 'closet-shelf', 'drawer-unit', 'closet-drawers', 'shoe-rack', 'closet-island', 'jewelry-cabinet', 'jewelry-drawer', 'tie-rack', 'full-mirror'],
        decorative: ['crown-molding', 'mantel', 'fireplace-surround', 'fireplace-hearth', 'niche-surround'],
        structural: ['steel-beam', 'steel-column', 'wood-beam', 'wood-post', 'concrete-beam', 'concrete-column', 'header', 'lvl-beam', 'baseboard', 'chair-rail']
      };

      for (const [category, types] of Object.entries(categories)) {
        if (types.includes(type)) return category;
      }
      return 'other';
    }

    // Track hidden categories
    let hiddenCategories = {};

    function toggleCategoryVisibility(category, visible) {
      if (visible) {
        delete hiddenCategories[category];
      } else {
        hiddenCategories[category] = true;
      }
      draw();
      update3DScene();
    }

    function showAllCategories() {
      hiddenCategories = {};
      // Reset all checkboxes
      document.querySelectorAll('.visibility-toggle input[type="checkbox"]').forEach(cb => {
        cb.checked = true;
      });
      draw();
      update3DScene();
    }

    function hideElement(el) {
      if (el) {
        el.hidden = true;
        if (el === selectedElement) {
          selectedElement = null;
          updateProperties();
        }
        draw();
        update3DScene();
      }
    }

    function showElement(el) {
      if (el) {
        el.hidden = false;
        draw();
        update3DScene();
      }
    }

    function drawElement(el, isSelected) {
      const x = el.x;
      const y = el.y;
      const w = el.width * pixelsPerFoot;
      const h = el.height * pixelsPerFoot;

      ctx.save();
      ctx.translate(x + w/2, y + h/2);
      ctx.rotate((el.rotation || 0) * Math.PI / 180);
      ctx.translate(-(x + w/2), -(y + h/2));

      // Background with slight shadow
      ctx.shadowColor = 'rgba(0,0,0,0.4)';
      ctx.shadowBlur = 10;
      ctx.shadowOffsetX = 3;
      ctx.shadowOffsetY = 3;

      // Draw base shape with texture or color (skip for L/U shaped - they draw their own shape)
      const isLOrUShape = el.type === 'countertop-l' || el.type === 'countertop-u';
      if (!isLOrUShape) {
        if (el.textureImg) {
          // Scale texture proportionally to slab dimensions for realistic stone/tile look
          // Standard stone slab: 10ft  5ft; tile: repeating at natural size
          ctx.save();
          ctx.beginPath();
          ctx.rect(x, y, w, h);
          ctx.clip();
          // Create repeating pattern at proper scale
          const imgW = el.textureImg.naturalWidth || el.textureImg.width;
          const imgH = el.textureImg.naturalHeight || el.textureImg.height;
          if (imgW > 0 && imgH > 0) {
            // For stone: map the slab image across element proportionally
            // For small elements, show full texture; for large, tile it
            const slabWidthPx = 10 * pixelsPerFoot; // 10ft slab width
            const slabHeightPx = 5 * pixelsPerFoot; // 5ft slab height
            const drawW = Math.max(w, slabWidthPx);
            const drawH = drawW * (imgH / imgW);
            // Tile the texture across the element
            for (let tx = x; tx < x + w; tx += drawW) {
              for (let ty = y; ty < y + h; ty += drawH) {
                ctx.drawImage(el.textureImg, tx, ty, drawW, drawH);
              }
            }
          } else {
            ctx.drawImage(el.textureImg, x, y, w, h);
          }
          ctx.restore();
        } else {
          ctx.fillStyle = el.color;
          ctx.fillRect(x, y, w, h);
        }
      }

      // Reset shadow
      ctx.shadowColor = 'transparent';
      ctx.shadowBlur = 0;
      ctx.shadowOffsetX = 0;
      ctx.shadowOffsetY = 0;

      // Draw architectural details based on element type
      drawElementDetails(el, x, y, w, h);

      // Border (skip for L/U shaped - they draw their own outline)
      // Locked/grouped elements show a subtle indicator
      const isLocked = el.groupId !== undefined;

      if (!isLOrUShape) {
        ctx.strokeStyle = isSelected ? '#6366f1' : (isLocked ? 'rgba(99, 102, 241, 0.5)' : 'rgba(255,255,255,0.3)');
        ctx.lineWidth = isSelected ? 3 : 1.5;
        ctx.strokeRect(x, y, w, h);
      } else if (isSelected) {
        // Draw L-shape selection outline
        const armWidthFt = el.armWidth || 2.17;
        const armPx = armWidthFt * pixelsPerFoot;
        ctx.strokeStyle = '#6366f1';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x + w, y);
        ctx.lineTo(x + w, y + armPx);
        ctx.lineTo(x + armPx, y + armPx);
        ctx.lineTo(x + armPx, y + h);
        ctx.lineTo(x, y + h);
        ctx.closePath();
        ctx.stroke();
      }

      // Small lock icon for locked/grouped elements
      if (isLocked && !isSelected) {
        ctx.fillStyle = 'rgba(99, 102, 241, 0.8)';
        ctx.font = '10px sans-serif';
        ctx.fillText('', x + 4, y + 12);
      }

      // Only show label if element is large enough or selected
      const showLabel = w > 60 || h > 60 || isSelected;
      if (showLabel) {
        // Get display label with fallback
        const typeName = el.type ? el.type.replace(/-/g, ' ').replace(/\b\w/g, c => c.toUpperCase()) : '';
        const displayLabel = el.label || typeName || 'Element';
        const labelFontSize = Math.max(9, Math.min(14, pixelsPerFoot / 3));
        ctx.font = `${labelFontSize}px Inter`;
        const labelWidth = ctx.measureText(displayLabel).width + 8;

        // Label background
        ctx.fillStyle = 'rgba(0,0,0,0.6)';
        ctx.fillRect(x + w/2 - labelWidth/2, y + h - labelFontSize - 8, labelWidth, labelFontSize + 4);

        // Label text
        ctx.fillStyle = 'rgba(255,255,255,0.95)';
        ctx.textAlign = 'center';
        ctx.fillText(displayLabel, x + w/2, y + h - 6);
      }

      // Dimensions  always show on elements large enough, highlighted when selected
      const dimFontSize = Math.max(9, Math.min(12, pixelsPerFoot / 4));
      if (isSelected) {
        ctx.fillStyle = '#6366f1';
        ctx.font = `bold ${dimFontSize + 2}px Inter`;
        ctx.textAlign = 'center';
        ctx.fillText(formatSize(el.width, el.height), x + w/2, y - 8);
      } else if (w > 50 && h > 30) {
        // Compact inline dimension on non-selected elements
        const dimText = formatSize(el.width, el.height);
        ctx.font = `${dimFontSize}px Inter`;
        const dimW = ctx.measureText(dimText).width + 6;
        ctx.fillStyle = 'rgba(0,0,0,0.5)';
        ctx.fillRect(x + w/2 - dimW/2, y + 2, dimW, dimFontSize + 3);
        ctx.fillStyle = 'rgba(255,255,255,0.75)';
        ctx.textAlign = 'center';
        ctx.fillText(dimText, x + w/2, y + dimFontSize + 1);
      }

      // Material hover/drop highlight overlay
      const isMaterialHover = (materialHoverElement === el.id || materialDropHighlight === el.id);
      if (isMaterialHover) {
        ctx.save();
        ctx.globalAlpha = 0.3;
        ctx.fillStyle = '#f9cb00';
        if (!isLOrUShape) {
          ctx.fillRect(x, y, w, h);
        }
        ctx.globalAlpha = 1;
        ctx.strokeStyle = '#f9cb00';
        ctx.lineWidth = 3;
        ctx.setLineDash([6, 4]);
        if (!isLOrUShape) {
          ctx.strokeRect(x, y, w, h);
        }
        ctx.setLineDash([]);
        ctx.restore();
      }

      // Lock icon (drawn in rotated context)
      if (isSelected && el.locked) {
        ctx.fillStyle = 'rgba(239, 68, 68, 0.9)';
        ctx.font = '14px Inter';
        ctx.fillText('', x + w - 12, y + 16);
      }

      // Restore context BEFORE drawing handles (handles use world coordinates)
      ctx.restore();

      // Selection handles (8 handles for resize) - drawn in world space
      if (isSelected && !el.locked) {
        const hs = HANDLE_SIZE;
        ctx.fillStyle = '#6366f1';
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;

        // Get all 8 handle positions (already in world coordinates with rotation applied)
        const handles = getResizeHandles(el);
        Object.values(handles).forEach(handle => {
          ctx.fillRect(handle.x - hs/2, handle.y - hs/2, hs, hs);
          ctx.strokeRect(handle.x - hs/2, handle.y - hs/2, hs, hs);
        });
      }

      // Locked element handles - drawn in world space
      if (isSelected && el.locked) {
        const hs = HANDLE_SIZE;
        ctx.fillStyle = '#ef4444';
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        // Use rotated handle positions for locked elements too
        const handles = getResizeHandles(el);
        [handles.nw, handles.ne, handles.sw, handles.se].forEach(handle => {
          ctx.fillRect(handle.x - hs/2, handle.y - hs/2, hs, hs);
          ctx.strokeRect(handle.x - hs/2, handle.y - hs/2, hs, hs);
        });
      }

      // Edge preview indicator for countertops - pulsing dot on front edge
      if (isSelected && (el.type === 'countertop' || el.type === 'countertop-l' || el.type === 'countertop-u')) {
        const rotation = (el.rotation || 0) * Math.PI / 180;
        const cx = x + w / 2;
        const cy = y + h / 2;

        // Calculate indicator position on front edge (bottom of countertop in 2D)
        // Rotate the point based on element rotation
        let indicatorX = cx;
        let indicatorY = y + h + 15; // Below the front edge

        if (rotation !== 0) {
          // Rotate indicator position around center
          const dx = indicatorX - cx;
          const dy = indicatorY - cy;
          indicatorX = cx + dx * Math.cos(rotation) - dy * Math.sin(rotation);
          indicatorY = cy + dx * Math.sin(rotation) + dy * Math.cos(rotation);
        }

        // Store indicator position for click detection
        el._edgeIndicator = { x: indicatorX, y: indicatorY, radius: 14 };

        // Pulsing animation
        const pulse = (Math.sin(Date.now() / 300) + 1) / 2; // 0 to 1
        const baseRadius = 10;
        const pulseRadius = baseRadius + pulse * 4;

        // Outer glow
        const gradient = ctx.createRadialGradient(indicatorX, indicatorY, 0, indicatorX, indicatorY, pulseRadius + 8);
        gradient.addColorStop(0, 'rgba(99, 102, 241, 0.8)');
        gradient.addColorStop(0.5, 'rgba(99, 102, 241, 0.3)');
        gradient.addColorStop(1, 'rgba(99, 102, 241, 0)');
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(indicatorX, indicatorY, pulseRadius + 8, 0, Math.PI * 2);
        ctx.fill();

        // Main indicator dot
        ctx.fillStyle = '#6366f1';
        ctx.beginPath();
        ctx.arc(indicatorX, indicatorY, baseRadius, 0, Math.PI * 2);
        ctx.fill();

        // White border
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.stroke();

        // Eye icon inside
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 10px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('', indicatorX, indicatorY);

        // Label
        ctx.fillStyle = 'rgba(99, 102, 241, 0.9)';
        ctx.font = '10px Inter, sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('Edge', indicatorX, indicatorY + 22);
      }
    }

    // ===== RESIZE HANDLES =====
    function getResizeHandles(el) {
      const x = el.x;
      const y = el.y;
      const w = el.width * pixelsPerFoot;
      const h = el.height * pixelsPerFoot;
      const rotation = (el.rotation || 0) * Math.PI / 180;
      const cx = x + w / 2;
      const cy = y + h / 2;

      // Helper to rotate a point around the center
      function rotatePoint(px, py) {
        if (rotation === 0) return { x: px, y: py };
        const dx = px - cx;
        const dy = py - cy;
        const cosR = Math.cos(rotation);
        const sinR = Math.sin(rotation);
        return {
          x: cx + dx * cosR - dy * sinR,
          y: cy + dx * sinR + dy * cosR
        };
      }

      // Get rotated handle positions
      const nw = rotatePoint(x, y);
      const n = rotatePoint(x + w/2, y);
      const ne = rotatePoint(x + w, y);
      const e = rotatePoint(x + w, y + h/2);
      const se = rotatePoint(x + w, y + h);
      const s = rotatePoint(x + w/2, y + h);
      const sw = rotatePoint(x, y + h);
      const west = rotatePoint(x, y + h/2);

      return {
        nw: { ...nw, cursor: 'nwse-resize' },
        n:  { ...n, cursor: 'ns-resize' },
        ne: { ...ne, cursor: 'nesw-resize' },
        e:  { ...e, cursor: 'ew-resize' },
        se: { ...se, cursor: 'nwse-resize' },
        s:  { ...s, cursor: 'ns-resize' },
        sw: { ...sw, cursor: 'nesw-resize' },
        w:  { ...west, cursor: 'ew-resize' }
      };
    }

    function getHandleAtPosition(el, worldX, worldY) {
      if (!el || el.locked) return null;

      const handles = getResizeHandles(el);
      const hs = HANDLE_SIZE + 4; // Slightly larger hit area

      for (const [name, handle] of Object.entries(handles)) {
        if (worldX >= handle.x - hs/2 && worldX <= handle.x + hs/2 &&
            worldY >= handle.y - hs/2 && worldY <= handle.y + hs/2) {
          return { name, ...handle };
        }
      }
      return null;
    }

    function getCursorForHandle(handleName) {
      const cursors = {
        nw: 'nwse-resize',
        n: 'ns-resize',
        ne: 'nesw-resize',
        e: 'ew-resize',
        se: 'nwse-resize',
        s: 'ns-resize',
        sw: 'nesw-resize',
        w: 'ew-resize'
      };
      return cursors[handleName] || 'default';
    }

    function applyResize(el, handle, dx, dy) {
      // Transform world-space delta to local-space delta based on rotation
      const rotation = (el.rotation || 0) * Math.PI / 180;
      let localDx = dx;
      let localDy = dy;

      if (rotation !== 0) {
        const cosR = Math.cos(-rotation);
        const sinR = Math.sin(-rotation);
        localDx = dx * cosR - dy * sinR;
        localDy = dx * sinR + dy * cosR;
      }

      // Convert pixel delta to feet
      const dxFeet = localDx / pixelsPerFoot;
      const dyFeet = localDy / pixelsPerFoot;

      // Minimum size in feet
      const minSize = 0.5;

      // Calculate fixed edges (the edges that should NOT move)
      // For each resize, we anchor from the opposite edge
      const originalRight = resizeStart.elX + resizeStart.width * pixelsPerFoot;
      const originalBottom = resizeStart.elY + resizeStart.height * pixelsPerFoot;
      const originalLeft = resizeStart.elX;
      const originalTop = resizeStart.elY;

      // Apply resize based on which handle is being dragged
      // Each case anchors the opposite edge(s) to stay fixed
      switch(handle) {
        case 'nw': // Anchor bottom-right corner
          el.width = Math.max(minSize, resizeStart.width - dxFeet);
          el.height = Math.max(minSize, resizeStart.height - dyFeet);
          break;

        case 'n': // Anchor bottom edge
          el.height = Math.max(minSize, resizeStart.height - dyFeet);
          break;

        case 'ne': // Anchor bottom-left corner
          el.width = Math.max(minSize, resizeStart.width + dxFeet);
          el.height = Math.max(minSize, resizeStart.height - dyFeet);
          break;

        case 'e': // Anchor left edge
          el.width = Math.max(minSize, resizeStart.width + dxFeet);
          break;

        case 'se': // Anchor top-left corner
          el.width = Math.max(minSize, resizeStart.width + dxFeet);
          el.height = Math.max(minSize, resizeStart.height + dyFeet);
          break;

        case 's': // Anchor top edge
          el.height = Math.max(minSize, resizeStart.height + dyFeet);
          break;

        case 'sw': // Anchor top-right corner
          el.width = Math.max(minSize, resizeStart.width - dxFeet);
          el.height = Math.max(minSize, resizeStart.height + dyFeet);
          break;

        case 'w': // Anchor right edge
          el.width = Math.max(minSize, resizeStart.width - dxFeet);
          break;
      }

      // Smart snap to standard dimensions if close, otherwise round to 1/16"
      el.width = snapToStandard(el.width, 'width');
      el.height = snapToStandard(el.height, 'depth');
      el.width = roundToSixteenth(el.width);
      el.height = roundToSixteenth(el.height);

      // NOW recalculate position to keep the anchored edge fixed AFTER snapping
      // This ensures the opposite edge doesn't move when we snap to standard sizes
      switch(handle) {
        case 'nw': // Keep bottom-right fixed
          el.x = originalRight - el.width * pixelsPerFoot;
          el.y = originalBottom - el.height * pixelsPerFoot;
          break;

        case 'n': // Keep bottom fixed
          el.y = originalBottom - el.height * pixelsPerFoot;
          break;

        case 'ne': // Keep bottom-left fixed, x stays at originalLeft
          el.x = originalLeft;
          el.y = originalBottom - el.height * pixelsPerFoot;
          break;

        case 'e': // Keep left fixed
          el.x = originalLeft;
          break;

        case 'se': // Keep top-left fixed
          el.x = originalLeft;
          el.y = originalTop;
          break;

        case 's': // Keep top fixed
          el.y = originalTop;
          break;

        case 'sw': // Keep top-right fixed
          el.x = originalRight - el.width * pixelsPerFoot;
          el.y = originalTop;
          break;

        case 'w': // Keep right fixed
          el.x = originalRight - el.width * pixelsPerFoot;
          break;
      }

      // Show snap indicator if snapped to standard
      const suggested = getSuggestedSize(el.type);
      if (suggested && Math.abs(el.width - suggested.width) < 0.01 && Math.abs(el.height - suggested.height) < 0.01) {
        showSnapFeedback(suggested.note);
      }
    }

    // Show brief feedback when snapping to standard
    function showSnapFeedback(message) {
      const hint = document.querySelector('.material-hint');
      if (hint) {
        const original = hint.innerHTML;
        hint.innerHTML = ` Snapped to: ${message}`;
        hint.style.borderColor = 'var(--success)';
        setTimeout(() => {
          hint.innerHTML = original;
          hint.style.borderColor = 'var(--border)';
        }, 1500);
      }
    }

    // ===== MOUSE EVENTS =====
    // Convert screen coordinates to world coordinates (accounting for pan)
    function screenToWorld(screenX, screenY) {
      return {
        x: screenX - panX,
        y: screenY - panY
      };
    }

    function onMouseDown(e) {
      // Ignore right-click - let context menu handle it
      if (e.button === 2) {
        return;
      }

      const rect = canvas.getBoundingClientRect();
      const screenX = e.clientX - rect.left;
      const screenY = e.clientY - rect.top;
      const { x, y } = screenToWorld(screenX, screenY);

      // Check for edge indicator click on selected countertop
      if (selectedElement && selectedElement._edgeIndicator) {
        const ind = selectedElement._edgeIndicator;
        const dist = Math.sqrt((x - ind.x) ** 2 + (y - ind.y) ** 2);
        if (dist <= ind.radius + 5) {
          showEdgePreviewModal(selectedElement);
          return;
        }
      }

      // Check for seam placement mode click
      if (seamPlacementMode && handleSeamPlacementClick(e)) {
        return;
      }

      // Check for room resize handle click (only in select mode)
      if (currentTool === 'select') {
        const roomHandle = getRoomHandleAtPosition(x, y);
        if (roomHandle) {
          isResizingRoom = true;
          roomResizeHandle = roomHandle.name;
          roomResizeStart = {
            x: x,
            y: y,
            width: roomWidth,
            depth: roomDepth
          };
          canvas.style.cursor = roomHandle.cursor;
          return;
        }
      }

      // Pan tool or middle mouse button (unless view is locked)
      if ((currentTool === 'pan' || e.button === 1) && !viewLocked) {
        isPanning = true;
        panStart = { x: screenX - panX, y: screenY - panY };
        canvas.style.cursor = 'grabbing';
        e.preventDefault();
        return;
      }

      // Space + drag to pan (unless view is locked)
      if (spacePressed && !viewLocked) {
        isPanning = true;
        panStart = { x: screenX - panX, y: screenY - panY };
        return;
      }

      if (currentTool === 'wall') {
        isDrawingWall = true;
        wallStart = { x, y };
        return;
      }

      if (currentTool === 'countertop') {
        isDrawingCountertop = true;
        countertopStart = { x, y };
        return;
      }

      if (currentTool === 'layout') {
        startLayoutDraw(x, y);
        return;
      }

      if (currentTool !== 'select') return;

      // Check if clicking on a resize handle of selected element
      if (selectedElement && !selectedElement.locked) {
        const handle = getHandleAtPosition(selectedElement, x, y);
        if (handle) {
          isResizing = true;
          resizeHandle = handle.name;
          resizeStart = {
            x: x,
            y: y,
            width: selectedElement.width,
            height: selectedElement.height,
            elX: selectedElement.x,
            elY: selectedElement.y
          };
          canvas.style.cursor = getCursorForHandle(handle.name);
          return;
        }
      }

      // Get ALL elements at this position (for cycling)
      const elementsAtPoint = [...elements].reverse().filter(el => isPointInElement(x, y, el));

      if (elementsAtPoint.length > 0) {
        const now = Date.now();
        const sameSpot = Math.abs(x - lastClickPos.x) < CLICK_CYCLE_THRESHOLD &&
                         Math.abs(y - lastClickPos.y) < CLICK_CYCLE_THRESHOLD;
        const quickClick = (now - lastClickTime) < CLICK_CYCLE_TIME;

        // Cycle through overlapping elements if clicking same spot quickly
        if (sameSpot && quickClick && elementsAtPoint.length > 1) {
          cycleIndex = (cycleIndex + 1) % elementsAtPoint.length;
          showSnapFeedback(`Element ${cycleIndex + 1} of ${elementsAtPoint.length} at this position`);
        } else {
          cycleIndex = 0;
        }

        lastClickPos = { x, y };
        lastClickTime = now;

        const clicked = elementsAtPoint[cycleIndex];

        // If a material is selected, apply it to the clicked element
        if (selectedMaterial) {
          const applied = applyMaterialToElement(clicked);
          if (applied) {
            selectedElement = clicked;
            updateProperties();
            draw();
          }
          // Always return - either material was applied or error was shown
          return;
        }

        // If a store product is selected, apply it as material
        if (selectedStoreProduct) {
          applyStoreProductToElement(clicked);
          selectedElement = clicked;
          updateProperties();
          draw();
          return;
        }

        // If in lock mode, complete the lock with clicked element
        if (lockMode && lockSourceElement) {
          completeLock(clicked);
          return;
        }

        selectedElement = clicked;
        updateLockUI();
        if (!clicked.locked) {
          isDragging = true;
          dragOffset = { x: x - clicked.x, y: y - clicked.y };
          autoRotationApplied = false; // Reset auto-rotation tracking for new drag
          lastSnappedWall = null;
        }
        updateProperties();
      } else {
        selectedElement = null;
        cancelLockMode(); // Cancel lock mode if clicking empty space
        cycleIndex = 0;
        updateProperties();
      }

      draw();
    }

    function onMouseMove(e) {
      const rect = canvas.getBoundingClientRect();
      const screenX = e.clientX - rect.left;
      const screenY = e.clientY - rect.top;
      const { x, y } = screenToWorld(screenX, screenY);

      // Handle panning
      if (isPanning) {
        panX = screenX - panStart.x;
        panY = screenY - panStart.y;
        draw();
        return;
      }

      // Handle room resizing
      if (isResizingRoom && roomResizeHandle) {
        const dx = (x - roomResizeStart.x) / pixelsPerFoot;
        const dy = (y - roomResizeStart.y) / pixelsPerFoot;

        let newWidth = roomResizeStart.width;
        let newDepth = roomResizeStart.depth;

        if (roomResizeHandle === 'e' || roomResizeHandle === 'se') {
          newWidth = Math.max(8, Math.round(roomResizeStart.width + dx));
        }
        if (roomResizeHandle === 's' || roomResizeHandle === 'se') {
          newDepth = Math.max(8, Math.round(roomResizeStart.depth + dy));
        }

        // Update room size
        roomWidth = Math.min(100, newWidth);
        roomDepth = Math.min(100, newDepth);

        // Update UI inputs
        document.getElementById('roomWidth').value = roomWidth;
        document.getElementById('roomDepth').value = roomDepth;

        // Redraw
        if (document.getElementById('scaleMode').value === 'fit') {
          fitToScreen();
        } else {
          updateCanvasSize();
        }
        draw();
        return;
      }

      // Handle layout brush drawing
      if (currentTool === 'layout' && layoutMode.isDrawing) {
        continueLayoutDraw(x, y);
        return;
      }

      // Handle resizing
      if (isResizing && selectedElement && resizeHandle) {
        const dx = x - resizeStart.x;
        const dy = y - resizeStart.y;
        applyResize(selectedElement, resizeHandle, dx, dy);
        updateProperties();
        draw();
        return;
      }

      if (isDrawingWall && wallStart) {
        // Preview wall while drawing
        draw();
        ctx.save();
        ctx.translate(panX, panY);
        ctx.fillStyle = 'rgba(100, 100, 100, 0.5)';
        const wx = Math.min(wallStart.x, x);
        const wy = Math.min(wallStart.y, y);
        const ww = Math.abs(x - wallStart.x) || CONFIG.WALL_THICKNESS;
        const wh = Math.abs(y - wallStart.y) || CONFIG.WALL_THICKNESS;
        ctx.fillRect(wx, wy, ww, wh);
        ctx.restore();
        return;
      }

      if (isDrawingCountertop && countertopStart) {
        // Preview countertop while drawing with measurements
        draw();
        ctx.save();
        ctx.translate(panX, panY);

        const cx = Math.min(countertopStart.x, x);
        const cy = Math.min(countertopStart.y, y);
        const cw = Math.abs(x - countertopStart.x) || pixelsPerFoot * 2;
        const ch = Math.abs(y - countertopStart.y) || pixelsPerFoot * 2;

        // Draw countertop preview
        ctx.fillStyle = 'rgba(112, 128, 144, 0.6)';
        ctx.fillRect(cx, cy, cw, ch);
        ctx.strokeStyle = '#708090';
        ctx.lineWidth = 2;
        ctx.strokeRect(cx, cy, cw, ch);

        // Show measurements
        const widthFt = (cw / pixelsPerFoot).toFixed(1);
        const depthFt = (ch / pixelsPerFoot).toFixed(1);
        const sqft = (widthFt * depthFt).toFixed(1);

        ctx.fillStyle = '#fff';
        ctx.font = 'bold 14px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(`${widthFt}'  ${depthFt}'`, cx + cw/2, cy + ch/2 - 10);
        ctx.font = '12px Arial';
        ctx.fillText(`${sqft} sq ft`, cx + cw/2, cy + ch/2 + 10);

        ctx.restore();
        return;
      }

      // Material hover preview  highlight element under cursor when a material is selected
      if (selectedMaterial && currentTool === 'select' && !isDragging) {
        const hit = [...elements].reverse().find(el => isPointInElement(x, y, el));
        const newHover = hit ? hit.id : null;
        if (newHover !== materialHoverElement) {
          materialHoverElement = newHover;
          draw();
        }
        canvas.style.cursor = hit ? 'copy' : 'crosshair';
        if (!isDragging && !isResizing) return;
      }

      // Update cursor when hovering over room resize handles
      if (currentTool === 'select' && !isDragging && !isResizing) {
        const roomHandle = getRoomHandleAtPosition(x, y);
        if (roomHandle) {
          canvas.style.cursor = roomHandle.cursor;
          return;
        }
      }

      // Update cursor when hovering over resize handles
      if (selectedElement && !selectedElement.locked && !isDragging) {
        const handle = getHandleAtPosition(selectedElement, x, y);
        if (handle) {
          canvas.style.cursor = getCursorForHandle(handle.name);
        } else if (isPointInElement(x, y, selectedElement)) {
          canvas.style.cursor = 'move';
        } else {
          canvas.style.cursor = 'default';
        }
      }

      if (!isDragging || !selectedElement || selectedElement.locked) return;

      // Hold Shift to disable ALL snapping (completely free placement)
      const freePlace = e.shiftKey;

      if (freePlace) {
        // Completely free movement - no snapping at all
        const newX = x - dragOffset.x;
        const newY = y - dragOffset.y;
        const dx = newX - selectedElement.x;
        const dy = newY - selectedElement.y;

        selectedElement.x = newX;
        selectedElement.y = newY;

        // Mark element as needing 3D update
        markElement3DDirty(selectedElement.id);

        // Move locked elements too
        if (selectedElement.groupId) {
          moveGroupedElements(selectedElement, dx, dy);
        }

        draw();
        return;
      }

      const gridSnap = pixelsPerFoot / CONFIG.GRID_SUBDIVISIONS;
      let snapX = Math.round((x - dragOffset.x) / gridSnap) * gridSnap;
      let snapY = Math.round((y - dragOffset.y) / gridSnap) * gridSnap;

      // Element-to-element snapping (for placing cabinets together)
      const snapDistance = pixelsPerFoot * 0.4; // Reduced from 0.5 for less aggressive snap
      const elW = selectedElement.width * pixelsPerFoot;
      const elH = selectedElement.height * pixelsPerFoot;

      // Check if this is a cabinet-type element for stricter alignment
      const cabinetTypes = ['base-cabinet', 'drawer-base', 'sink-base', 'wall-cabinet',
                            'tall-cabinet', 'corner-cabinet', 'lazy-susan'];
      const isCabinetElement = cabinetTypes.includes(selectedElement.type);

      // Wall element types - these should ATTRACT cabinets, not repel them
      const wallTypes = ['wall', 'wall-block', 'wall-concrete', 'wall-framed', 'wall-wood-2x4',
                         'wall-wood-2x6', 'wall-brick', 'wall-steel', 'wall-aluminum',
                         'pony-wall', 'pony-wall-bar', 'knee-wall'];

      elements.forEach(other => {
        if (other.id === selectedElement.id) return;

        const otherX = other.x;
        const otherY = other.y;
        const otherW = other.width * pixelsPerFoot;
        const otherH = other.height * pixelsPerFoot;
        const isOtherCabinet = cabinetTypes.includes(other.type);
        const isOtherWall = wallTypes.includes(other.type);

        // WALL ELEMENTS: Cabinets should snap AGAINST walls (back of cabinet to wall surface)
        if (isOtherWall && isCabinetElement) {
          const wallSnapDist = pixelsPerFoot * 0.75; // Generous snap distance for walls

          // Determine wall orientation
          const isVerticalWall = otherH > otherW;

          if (isVerticalWall) {
            // Vertical wall - cabinet can snap to left or right side
            // Snap cabinet's back (left edge) against wall's right face
            if (Math.abs(snapX - (otherX + otherW)) < wallSnapDist) {
              snapX = otherX + otherW; // Cabinet left edge meets wall right edge
            }
            // Snap cabinet's back (right edge) against wall's left face
            if (Math.abs((snapX + elW) - otherX) < wallSnapDist) {
              snapX = otherX - elW; // Cabinet right edge meets wall left edge
            }
          } else {
            // Horizontal wall - cabinet can snap to top or bottom side
            // Snap cabinet's back (top edge) against wall's bottom face
            if (Math.abs(snapY - (otherY + otherH)) < wallSnapDist) {
              snapY = otherY + otherH; // Cabinet top edge meets wall bottom edge
            }
            // Snap cabinet's back (bottom edge) against wall's top face
            if (Math.abs((snapY + elH) - otherY) < wallSnapDist) {
              snapY = otherY - elH; // Cabinet bottom edge meets wall top edge
            }
          }
          return; // Skip regular element snapping for walls
        }

        // Skip walls for regular element-to-element snapping (handled above)
        if (isOtherWall) return;

        // For cabinets, use tighter snap for edge-to-edge (butt joints)
        const edgeSnapDist = isCabinetElement ? pixelsPerFoot * 0.5 : snapDistance;

        // When both are cabinets, use much larger snap distance for forming runs
        const cabinetRunSnapDist = (isCabinetElement && isOtherCabinet) ? pixelsPerFoot * 0.8 : edgeSnapDist;

        // Snap right edge of selected to left edge of other (place side by side)
        if (Math.abs((snapX + elW) - otherX) < cabinetRunSnapDist) {
          snapX = otherX - elW;
          // Only align Y if already close (within 0.3ft) - don't force alignment
          if (isCabinetElement && isOtherCabinet && Math.abs(snapY - otherY) < pixelsPerFoot * 0.3) {
            snapY = otherY;
          }
        }
        // Snap left edge of selected to right edge of other
        if (Math.abs(snapX - (otherX + otherW)) < cabinetRunSnapDist) {
          snapX = otherX + otherW;
          // Only align Y if already close (within 0.3ft) - don't force alignment
          if (isCabinetElement && isOtherCabinet && Math.abs(snapY - otherY) < pixelsPerFoot * 0.3) {
            snapY = otherY;
          }
        }
        // Snap bottom edge of selected to top edge of other
        if (Math.abs((snapY + elH) - otherY) < edgeSnapDist) {
          snapY = otherY - elH;
        }
        // Snap top edge of selected to bottom edge of other
        if (Math.abs(snapY - (otherY + otherH)) < edgeSnapDist) {
          snapY = otherY + otherH;
        }

        // Align tops when close (for cabinet runs along a wall)
        if (Math.abs(snapY - otherY) < snapDistance) {
          snapY = otherY;
        }
        // Align bottoms when close
        if (Math.abs((snapY + elH) - (otherY + otherH)) < snapDistance) {
          snapY = otherY + otherH - elH;
        }
        // Align lefts when close
        if (Math.abs(snapX - otherX) < snapDistance) {
          snapX = otherX;
        }
        // Align rights when close
        if (Math.abs((snapX + elW) - (otherX + otherW)) < snapDistance) {
          snapX = otherX + otherW - elW;
        }
      });

      // Wall snapping for cabinets and countertops
      const wallSnapDistance = pixelsPerFoot * 0.5; // Snap within 0.5 feet of walls (reduced for less aggressive snap)
      const isCabinetType = ['base-cabinet', 'wall-cabinet', 'tall-cabinet', 'corner-cabinet',
                             'drawer-base', 'sink-base', 'lazy-susan',
                             'island', 'countertop', 'sink', 'stove', 'dishwasher',
                             'refrigerator', 'oven'].includes(selectedElement.type);

      // Track which wall we're snapping to for auto-rotation
      let snappedToWall = null;

      if (isCabinetType) {
        // Room boundary walls (in pixels)
        const roomLeftWall = 0;
        const roomTopWall = 0; // Back wall in 3D view
        const roomRightWall = roomWidth * pixelsPerFoot;
        const roomBottomWall = roomDepth * pixelsPerFoot;

        // Snap to back wall (top of 2D canvas = back wall in 3D)
        if (Math.abs(snapY - roomTopWall) < wallSnapDistance) {
          snapY = roomTopWall;
          snappedToWall = 'back';
        }

        // Snap to left wall
        if (Math.abs(snapX - roomLeftWall) < wallSnapDistance) {
          snapX = roomLeftWall;
          snappedToWall = 'left';
        }

        // Snap to right wall (right edge of element to wall)
        if (Math.abs((snapX + elW) - roomRightWall) < wallSnapDistance) {
          snapX = roomRightWall - elW;
          snappedToWall = 'right';
        }

        // Snap to front (bottom edge in 2D - not usually needed but available)
        if (Math.abs((snapY + elH) - roomBottomWall) < wallSnapDistance) {
          snapY = roomBottomWall - elH;
          snappedToWall = 'front';
        }

        // Auto-rotate cabinets so their FRONT (doors) faces INTO the room
        // Only rotate when element is actually AT the wall (distance < 0.1 ft = ~1 inch)
        const autoRotateTypes = ['base-cabinet', 'wall-cabinet', 'tall-cabinet', 'drawer-base', 'sink-base',
                                  'sink', 'stove', 'dishwasher', 'oven'];
        // Note: refrigerator removed from auto-rotate - users can place it any direction

        // Check if element is actually touching the wall (not just near it)
        const touchingWall = (snappedToWall === 'back' && snapY === 0) ||
                             (snappedToWall === 'left' && snapX === 0) ||
                             (snappedToWall === 'right' && Math.abs((snapX + elW) - roomRightWall) < 1) ||
                             (snappedToWall === 'front' && Math.abs((snapY + elH) - roomBottomWall) < 1);

        // Only apply rotation if this is a NEW wall snap AND element is touching
        if (snappedToWall && snappedToWall !== lastSnappedWall && touchingWall && autoRotateTypes.includes(selectedElement.type)) {
          lastSnappedWall = snappedToWall;

          // Cabinet BACK goes against wall, FRONT (doors) faces into room
          // rotation=0: front faces DOWN, rotation=90: front faces LEFT
          // rotation=180: front faces UP, rotation=270: front faces RIGHT
          let targetRotation;
          switch(snappedToWall) {
            case 'back':
              targetRotation = 0;
              break;
            case 'left':
              targetRotation = 270;
              break;
            case 'right':
              targetRotation = 90;
              break;
            case 'front':
              targetRotation = 180;
              break;
            default:
              targetRotation = selectedElement.rotation || 0;
          }

          selectedElement.rotation = targetRotation;
          showSnapFeedback(`Snapped to ${snappedToWall} wall`);
        } else if (!snappedToWall) {
          // Reset when not snapped to any wall
          lastSnappedWall = null;
        }

        // Snap to custom drawn walls - cabinets snap AGAINST walls (like magnets attracting)
        walls.forEach(wall => {
          const wallLeft = wall.x;
          const wallTop = wall.y;
          const wallRight = wall.x + wall.width;
          const wallBottom = wall.y + wall.height;
          const wallCenterX = wallLeft + wall.width / 2;
          const wallCenterY = wallTop + wall.height / 2;

          // Determine if wall is horizontal or vertical based on aspect ratio
          const isVerticalWall = wall.height > wall.width;

          // Calculate element center
          const elCenterX = snapX + elW / 2;
          const elCenterY = snapY + elH / 2;

          if (isVerticalWall) {
            // Vertical wall - snap cabinet against whichever side is closer
            const distToLeftSide = Math.abs(snapX - wallRight); // Cabinet left to wall right
            const distToRightSide = Math.abs((snapX + elW) - wallLeft); // Cabinet right to wall left

            if (elCenterX < wallCenterX) {
              // Cabinet is to the left of wall - snap cabinet's right edge to wall's left edge
              if (distToRightSide < wallSnapDistance) {
                snapX = wallLeft - elW;
              }
            } else {
              // Cabinet is to the right of wall - snap cabinet's left edge to wall's right edge
              if (distToLeftSide < wallSnapDistance) {
                snapX = wallRight;
              }
            }
          } else {
            // Horizontal wall - snap cabinet against whichever side is closer
            const distToTopSide = Math.abs(snapY - wallBottom); // Cabinet top to wall bottom
            const distToBottomSide = Math.abs((snapY + elH) - wallTop); // Cabinet bottom to wall top

            if (elCenterY < wallCenterY) {
              // Cabinet is above wall - snap cabinet's bottom edge to wall's top edge
              if (distToBottomSide < wallSnapDistance) {
                snapY = wallTop - elH;
              }
            } else {
              // Cabinet is below wall - snap cabinet's top edge to wall's bottom edge
              if (distToTopSide < wallSnapDistance) {
                snapY = wallBottom;
              }
            }
          }
        });

        // Special corner snap for corner cabinets and lazy-susan
        const isCornerCabinet = ['corner-cabinet', 'lazy-susan'].includes(selectedElement.type);
        if (isCornerCabinet) {
          const cornerSnapDistance = pixelsPerFoot * 1.0; // Larger snap distance for corners

          // Check if near top-left corner (back-left in 3D)
          if (Math.abs(snapX - roomLeftWall) < cornerSnapDistance &&
              Math.abs(snapY - roomTopWall) < cornerSnapDistance) {
            snapX = roomLeftWall;
            snapY = roomTopWall;
            selectedElement.rotation = 0; // L opens toward front-right
            showSnapFeedback('Corner Snap: Back-Left');
          }
          // Check if near top-right corner (back-right in 3D)
          else if (Math.abs((snapX + elW) - roomRightWall) < cornerSnapDistance &&
                   Math.abs(snapY - roomTopWall) < cornerSnapDistance) {
            snapX = roomRightWall - elW;
            snapY = roomTopWall;
            selectedElement.rotation = 270; // L opens toward front-left
            showSnapFeedback('Corner Snap: Back-Right');
          }
          // Check if near bottom-left corner (front-left in 3D)
          else if (Math.abs(snapX - roomLeftWall) < cornerSnapDistance &&
                   Math.abs((snapY + elH) - roomBottomWall) < cornerSnapDistance) {
            snapX = roomLeftWall;
            snapY = roomBottomWall - elH;
            selectedElement.rotation = 90; // L opens toward back-right
            showSnapFeedback('Corner Snap: Front-Left');
          }
          // Check if near bottom-right corner (front-right in 3D)
          else if (Math.abs((snapX + elW) - roomRightWall) < cornerSnapDistance &&
                   Math.abs((snapY + elH) - roomBottomWall) < cornerSnapDistance) {
            snapX = roomRightWall - elW;
            snapY = roomBottomWall - elH;
            selectedElement.rotation = 180; // L opens toward back-left
            showSnapFeedback('Corner Snap: Front-Right');
          }
        }

        // Cabinet-to-cabinet alignment for L and U shaped runs
        // Find adjacent cabinets and align depth with them
        const adjacentCabinets = elements.filter(el => {
          if (el === selectedElement) return false;
          if (!['base-cabinet', 'wall-cabinet', 'tall-cabinet', 'drawer-base', 'sink-base'].includes(el.type)) return false;

          const elX = el.x;
          const elY = el.y;
          const elRight = elX + el.width * pixelsPerFoot;
          const elBottom = elY + el.height * pixelsPerFoot;

          // Check if horizontally adjacent (within 0.5 feet)
          const horizGap = Math.min(
            Math.abs(snapX - elRight),
            Math.abs((snapX + elW) - elX)
          );

          // Check if vertically adjacent
          const vertGap = Math.min(
            Math.abs(snapY - elBottom),
            Math.abs((snapY + elH) - elY)
          );

          return horizGap < pixelsPerFoot * 0.5 || vertGap < pixelsPerFoot * 0.5;
        });

        // If there are adjacent cabinets, help align for L-shape connections
        if (adjacentCabinets.length > 0) {
          adjacentCabinets.forEach(adj => {
            const adjRight = adj.x + adj.width * pixelsPerFoot;
            const adjBottom = adj.y + adj.height * pixelsPerFoot;

            // Snap to form perpendicular L-connection
            // If adjacent cabinet is horizontal (on back wall), connect vertically (on side wall)
            if (Math.abs(adj.y - roomTopWall) < wallSnapDistance) {
              // Adjacent is on back wall, snap our top to their bottom for L
              if (Math.abs(snapY - adjBottom) < pixelsPerFoot * 0.5) {
                snapY = adjBottom;
              }
            }

            // If we're forming an L, snap our edge to their edge
            if (Math.abs(snapX - adjRight) < pixelsPerFoot * 0.3) {
              snapX = adjRight;
            }
            if (Math.abs((snapX + elW) - adj.x) < pixelsPerFoot * 0.3) {
              snapX = adj.x - elW;
            }
          });
        }
      }

      // Allow elements to be placed anywhere (no canvas boundary restriction)
      // Calculate movement delta before updating position
      const dx = snapX - selectedElement.x;
      const dy = snapY - selectedElement.y;

      selectedElement.x = snapX;
      selectedElement.y = snapY;

      // Mark element as needing 3D update
      markElement3DDirty(selectedElement.id);

      // Move all locked elements together
      if (selectedElement.groupId) {
        moveGroupedElements(selectedElement, dx, dy);
      }

      draw();
    }

    function onMouseUp(e) {
      // End room resizing
      if (isResizingRoom) {
        isResizingRoom = false;
        roomResizeHandle = null;
        canvas.style.cursor = 'default';

        // Update 3D if in 3D view
        if (currentView === '3d') {
          init3D();
          render3D();
        }

        saveUndoState();
        showSnapFeedback(`Room size: ${roomWidth}'  ${roomDepth}'`);
        return;
      }

      // End resizing
      if (isResizing) {
        isResizing = false;
        resizeHandle = null;
        canvas.style.cursor = 'default';
        calculateQuote();
        saveUndoState();
        return;
      }

      if (isPanning) {
        isPanning = false;
        canvas.style.cursor = currentTool === 'pan' ? 'grab' : (currentTool === 'wall' ? 'crosshair' : 'default');
        return;
      }

      if (isDrawingWall && wallStart) {
        const rect = canvas.getBoundingClientRect();
        const screenX = e.clientX - rect.left;
        const screenY = e.clientY - rect.top;
        const { x, y } = screenToWorld(screenX, screenY);

        const wx = Math.min(wallStart.x, x);
        const wy = Math.min(wallStart.y, y);
        let ww = Math.abs(x - wallStart.x);
        let wh = Math.abs(y - wallStart.y);

        // Make it a proper wall (thin in one dimension)
        if (ww < wh) {
          ww = CONFIG.WALL_THICKNESS;
        } else {
          wh = CONFIG.WALL_THICKNESS;
        }

        if (ww > 10 || wh > 10) {
          addWall(wx, wy, ww, wh);
          saveUndoState();
        }

        isDrawingWall = false;
        wallStart = null;
        draw();
        return;
      }

      if (isDrawingCountertop && countertopStart) {
        const rect = canvas.getBoundingClientRect();
        const screenX = e.clientX - rect.left;
        const screenY = e.clientY - rect.top;
        const { x, y } = screenToWorld(screenX, screenY);

        const cx = Math.min(countertopStart.x, x);
        const cy = Math.min(countertopStart.y, y);
        let cw = Math.abs(x - countertopStart.x);
        let ch = Math.abs(y - countertopStart.y);

        // Minimum size of 1 foot
        if (cw < pixelsPerFoot) cw = pixelsPerFoot * 2;
        if (ch < pixelsPerFoot) ch = pixelsPerFoot * 2;

        // Create countertop element
        const countertop = {
          id: 'countertop-' + Date.now(),
          type: 'countertop',
          x: cx,
          y: cy,
          width: cw / pixelsPerFoot,
          height: ch / pixelsPerFoot,
          color: '#708090',
          label: 'Countertop',
          rotation: 0,
          locked: false,
          roomId: currentRoom
        };

        elements.push(countertop);
        selectedElement = countertop;
        calculateQuote();
        saveUndoState();

        isDrawingCountertop = false;
        countertopStart = null;
        draw();
        updateProperties();
        return;
      }

      // Handle layout brush release
      if (currentTool === 'layout' && layoutMode.isDrawing) {
        finishLayoutDraw();
        return;
      }

      // Save undo state if we were dragging an element
      if (isDragging && selectedElement) {
        saveUndoState();
      }

      isDragging = false;
    }

    function onContextMenu(e) {
      e.preventDefault();

      const rect = canvas.getBoundingClientRect();
      const screenX = e.clientX - rect.left;
      const screenY = e.clientY - rect.top;
      const { x, y } = screenToWorld(screenX, screenY);

      const clicked = [...elements].reverse().find(el => isPointInElement(x, y, el));

      if (clicked) {
        selectedElement = clicked;
        contextMenuElement = clicked;
        showContextMenu(e.clientX, e.clientY, clicked);
        draw();
      }
    }

    function onDoubleClick(e) {
      // If in layout mode, finalize the cabinet run
      if (currentTool === 'layout' && layoutMode.points.length >= 2) {
        finalizeLayoutRun();
        return;
      }

      const rect = canvas.getBoundingClientRect();
      const screenX = e.clientX - rect.left;
      const screenY = e.clientY - rect.top;
      const { x, y } = screenToWorld(screenX, screenY);

      const clicked = [...elements].reverse().find(el => isPointInElement(x, y, el));

      if (clicked) {
        const newLabel = prompt('Enter label:', clicked.label);
        if (newLabel) {
          clicked.label = newLabel;
          draw();
        }
      }
    }

    function isPointInElement(px, py, el) {
      const w = el.width * pixelsPerFoot;
      const h = el.height * pixelsPerFoot;
      const rotation = (el.rotation || 0) * Math.PI / 180;

      // If no rotation, use simple bounds check
      if (rotation === 0) {
        return px >= el.x && px <= el.x + w && py >= el.y && py <= el.y + h;
      }

      // For rotated elements, transform the click point to element's local space
      const cx = el.x + w / 2;
      const cy = el.y + h / 2;

      // Translate point to origin (element center)
      const dx = px - cx;
      const dy = py - cy;

      // Rotate point in opposite direction to get local coordinates
      const cosR = Math.cos(-rotation);
      const sinR = Math.sin(-rotation);
      const localX = dx * cosR - dy * sinR;
      const localY = dx * sinR + dy * cosR;

      // Check if local point is within unrotated bounds (centered at origin)
      return localX >= -w/2 && localX <= w/2 && localY >= -h/2 && localY <= h/2;
    }

    // ===== KEYBOARD EVENTS =====
    let spacePressed = false;

    function onKeyDown(e) {
      if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') return;

      // Space to pan
      if (e.code === 'Space' && !spacePressed) {
        spacePressed = true;
        canvas.style.cursor = 'grab';
        e.preventDefault();
        return;
      }

      switch(e.key.toLowerCase()) {
        case 'v': setTool('select'); break;
        case 'w': setTool('wall'); break;
        case 'c': setTool('countertop'); break;
        case 'h': setTool('pan'); break;
        case 'l': setTool('layout'); break; // L for layout tool
        case 'f': fitToScreen(); break; // F to fit
        case 'delete':
        case 'backspace':
          if (selectedElement && !selectedElement.locked) {
            elements = elements.filter(el => el !== selectedElement);
            selectedElement = null;
            updateProperties();
            draw();
          }
          break;
        case 'r':
          if (selectedElement && !selectedElement.locked) {
            selectedElement.rotation = ((selectedElement.rotation || 0) + 90) % 360;
            updateProperties();
            draw();
          }
          break;
        case 'd':
          if ((e.ctrlKey || e.metaKey) && selectedElement) {
            e.preventDefault();
            duplicateElement(selectedElement);
          }
          break;
        case 'l':
          // L key to start lock mode (when not in layout tool)
          if (currentTool !== 'layout' && selectedElement) {
            lockElementsTogether();
          } else if (currentTool !== 'layout') {
            setTool('layout');
          }
          break;
        case 'u':
          // U key to unlock element
          if (selectedElement && selectedElement.groupId) {
            unlockElement();
          }
          break;
        case 'escape':
          // Cancel layout tool if active
          if (currentTool === 'layout' && layoutMode.points.length > 0) {
            layoutMode.points = [];
            showSnapFeedback('Layout cancelled');
          }
          // Cancel seam placement mode
          if (seamPlacementMode) {
            seamPlacementMode = false;
            const btn = document.getElementById('seamPlaceModeBtn');
            if (btn) {
              btn.style.background = 'rgba(139, 92, 246, 0.3)';
              btn.textContent = ' Click to Place';
            }
          }
          // Cancel lock mode
          if (lockMode) {
            cancelLockMode();
          }
          // Cancel material selection
          if (selectedMaterial) {
            selectedMaterial = null;
            materialHoverElement = null;
            materialDropHighlight = null;
            renderMaterials(currentMaterialCategory);
            const hint = document.querySelector('.material-hint');
            if (hint) {
              hint.innerHTML = 'Click material, then click element to apply';
              hint.style.borderColor = 'var(--border)';
            }
            canvas.style.cursor = 'default';
          }
          selectedElement = null;
          hideContextMenu();
          updateProperties();
          draw();
          break;
        case '=':
        case '+':
          if (e.ctrlKey || e.metaKey) {
            e.preventDefault();
            zoomIn();
          }
          break;
        case '-':
          if (e.ctrlKey || e.metaKey) {
            e.preventDefault();
            zoomOut();
          }
          break;
        case '0':
          if (e.ctrlKey || e.metaKey) {
            e.preventDefault();
            fitToScreen();
          } else {
            // Plain 0 resets view
            resetView();
          }
          break;
        case 'home':
          // Home key resets view
          e.preventDefault();
          resetView();
          break;
      }
    }

    function onKeyUp(e) {
      if (e.code === 'Space') {
        spacePressed = false;
        canvas.style.cursor = currentTool === 'pan' ? 'grab' : (currentTool === 'wall' ? 'crosshair' : 'default');
      }
    }

    // Track if HTML5 drag is in progress
    let isHtmlDragging = false;
    let materialDropHighlight = null; // Element ID highlighted during material drag
    let materialHoverElement = null; // Element highlighted during material select+hover

    // Mouse wheel zoom with throttling for smooth trackpad support
    let lastWheelTime = 0;
    let wheelAccumulator = 0;
    let wheelTimeout = null;

    function onWheel(e) {
      // Don't zoom if view is locked or during any drag operation
      if (viewLocked || isDragging || isResizing || isHtmlDragging || isPanning) {
        e.preventDefault();
        return;
      }

      e.preventDefault();

      const now = Date.now();
      const timeDelta = now - lastWheelTime;
      lastWheelTime = now;

      // Detect if this is a trackpad gesture (small, frequent deltas) or mouse wheel (larger, less frequent)
      const isTrackpad = Math.abs(e.deltaY) < 50 && timeDelta < 50;

      // Accumulate for trackpad, apply immediately for mouse wheel
      if (isTrackpad) {
        wheelAccumulator += e.deltaY;

        // Clear existing timeout
        if (wheelTimeout) clearTimeout(wheelTimeout);

        // Apply accumulated zoom after brief pause
        wheelTimeout = setTimeout(() => {
          applyZoom(wheelAccumulator, e.clientX, e.clientY);
          wheelAccumulator = 0;
        }, 16); // ~60fps
      } else {
        // Mouse wheel - apply immediately but with gentler factor
        applyZoom(e.deltaY, e.clientX, e.clientY);
      }
    }

    function applyZoom(deltaY, clientX, clientY) {
      // Safety check - don't zoom if values are invalid
      if (!isFinite(deltaY) || !isFinite(clientX) || !isFinite(clientY)) {
        wheelAccumulator = 0;
        return;
      }

      const rect = canvas.getBoundingClientRect();
      const mouseX = clientX - rect.left;
      const mouseY = clientY - rect.top;

      // Get world position before zoom
      const worldX = (mouseX - panX) / pixelsPerFoot;
      const worldY = (mouseY - panY) / pixelsPerFoot;

      // Safety check for world coordinates
      if (!isFinite(worldX) || !isFinite(worldY)) {
        wheelAccumulator = 0;
        return;
      }

      // Calculate zoom factor - gentler for accumulated trackpad gestures
      const normalizedDelta = Math.max(-100, Math.min(100, deltaY)); // Clamp extreme values
      const zoomFactor = normalizedDelta < 0 ? 1.08 : 0.92;
      const newPixelsPerFoot = Math.max(5, Math.min(200, pixelsPerFoot * zoomFactor)); // Extended range: 5-200

      // Adjust pan to zoom toward mouse position
      const newPanX = mouseX - worldX * newPixelsPerFoot;
      const newPanY = mouseY - worldY * newPixelsPerFoot;

      // Safety check for new pan values
      if (!isFinite(newPanX) || !isFinite(newPanY)) {
        wheelAccumulator = 0;
        return;
      }

      panX = newPanX;
      panY = newPanY;

      pixelsPerFoot = newPixelsPerFoot;

      document.getElementById('scaleMode').value = 'fit'; // Reset dropdown
      document.getElementById('zoomLevel').textContent = Math.round(pixelsPerFoot / 40 * 100) + '%';

      draw();
    }

    // Reset view to default pan and zoom
    function resetView() {
      panX = 50;
      panY = 50;
      pixelsPerFoot = 40;
      wheelAccumulator = 0;
      if (wheelTimeout) {
        clearTimeout(wheelTimeout);
        wheelTimeout = null;
      }
      document.getElementById('scaleMode').value = 'fit';
      document.getElementById('zoomLevel').textContent = '100%';
      draw();
      showSnapFeedback('View reset');
    }

    // ===== DRAG & DROP =====
    function onDrop(e) {
      e.preventDefault();
      const rect = canvas.getBoundingClientRect();
      const screenX = e.clientX - rect.left;
      const screenY = e.clientY - rect.top;
      const { x, y } = screenToWorld(screenX, screenY);

      console.log('onDrop called at', x, y);

      // Check for material swatch drag-and-drop
      const materialId = e.dataTransfer.getData('material-id');
      if (materialId) {
        const hitElement = [...elements].reverse().find(el => isPointInElement(x, y, el));
        if (hitElement) {
          // Select the material first (if not already)
          selectMaterial(materialId);
          const applied = applyMaterialToElement(hitElement);
          if (applied) {
            selectedElement = hitElement;
            updateProperties();
            draw();
          }
        }
        materialDropHighlight = null;
        draw();
        return;
      }

      // Check for element-type (sidebar elements)
      const type = e.dataTransfer.getData('element-type');
      if (type) {
        console.log('Creating element type:', type);
        createElement(type, x, y);
        return;
      }

      // Check for store product or other JSON data
      const jsonData = e.dataTransfer.getData('text/plain');
      console.log('JSON data from drop:', jsonData);
      if (jsonData) {
        try {
          const data = JSON.parse(jsonData);
          console.log('Parsed drop data:', data);
          if (data.type === 'store-product' && data.product) {
            console.log('Handling store product drop:', data.product.name);
            handleStoreProductDrop(data.product, x, y, e);
            return;
          }
        } catch (parseErr) {
          console.log('Not JSON data, ignoring');
        }
      }
    }

    // Handle dropping a store product onto the canvas or an element
    function handleStoreProductDrop(product, x, y, e) {
      console.log('handleStoreProductDrop called', { product: product.name, x, y });

      // Check if dropped on an existing element using world coordinates
      const hitElement = [...elements].reverse().find(el => isPointInElement(x, y, el));
      console.log('Hit element:', hitElement ? hitElement.type : 'none');

      if (hitElement) {
        // Apply product as material/texture to existing element
        console.log('Applying product to existing element');
        applyStoreProductToExistingElement(hitElement, product);
      } else {
        // Create a new element with the product
        console.log('Creating new element from product');
        createElementFromStoreProduct(product, x, y);
      }
    }

    // Apply store product to an existing element
    function applyStoreProductToExistingElement(element, product) {
      // Determine best element type match
      const productType = product.type?.toLowerCase() || '';

      // Check material type compatibility
      if (!canApplyMaterialToElement(productType, element)) {
        return false;
      }

      // Get image URL - prefer primaryImage, fall back to images array or image property
      const imageUrl = product.primaryImage || product.images?.[0] || product.image;

      // Store product info on element
      element.storeProduct = {
        name: product.name,
        slug: product.slug,
        brand: product.brand,
        sku: product.sku,
        price: product.price,
        image: imageUrl
      };

      // Also store on element for material panel reference
      element.materialId = product.slug;
      element.materialName = product.name;
      element.materialBrand = product.brand;

      // Apply as texture if product has image
      if (imageUrl) {
        element.texture = imageUrl;
        element.textureImg = null; // Force reload

        console.log('Applying texture to element:', element.type, 'URL:', imageUrl);

        // Load texture image
        const img = new Image();
        img.crossOrigin = 'anonymous';
        img.onload = () => {
          element.textureImg = img;
          console.log('Texture loaded successfully for', element.type);
          draw();
          if (currentView === '3d') {
            console.log('Updating 3D scene with new texture');
            update3DScene();
          }
        };
        img.onerror = (err) => {
          console.warn('Failed to load texture for', element.type, ':', imageUrl, err);
        };
        img.src = imageUrl;
      }

      // Update price if product has price
      if (product.price) {
        element.priceOverride = parseFloat(product.price);
        element.costPrice = parseFloat(product.price);
      }

      // Update label
      element.label = product.name || element.label;

      selectedElement = element;
      updateProperties();
      draw();
      calculateQuote();

      showToast(`Applied ${product.name} to ${element.type}`, 'success');
    }

    // Create new element from store product
    function createElementFromStoreProduct(product, x, y) {
      console.log('createElementFromStoreProduct called', { product: product.name, x, y });
      const productType = product.type?.toLowerCase() || '';
      console.log('Product type:', productType);

      // Map product types to element types
      let elementType = 'stove'; // default fallback (valid appliance type)
      let width = 2.5;
      let height = 2;
      let color = '#4a90d9';

      if (productType.includes('sink')) {
        elementType = 'sink';
        width = 2.75;
        height = 1.75;
      } else if (productType.includes('faucet')) {
        elementType = 'sink'; // Use sink type for faucets
        width = 0.75;
        height = 0.5;
      } else if (productType.includes('range') || productType.includes('stove')) {
        elementType = 'stove';
        width = 2.5;
        height = 2.5;
      } else if (productType.includes('refrigerator') || productType.includes('fridge')) {
        elementType = 'refrigerator';
        width = 3;
        height = 3;
      } else if (productType.includes('dishwasher')) {
        elementType = 'dishwasher';
        width = 2;
        height = 2;
      } else if (productType.includes('microwave')) {
        elementType = 'microwave';
        width = 2;
        height = 1;
      } else if (productType.includes('hood') || productType.includes('vent')) {
        elementType = 'range-hood';
        width = 2.5;
        height = 1.5;
      } else if (productType.includes('cabinet')) {
        elementType = 'base-cabinet';
        width = 3;
        height = 2;
      } else if (productType.includes('countertop') || productType.includes('granite') ||
                 productType.includes('quartz') || productType.includes('dekton') ||
                 productType.includes('marble') || productType.includes('quartzite') ||
                 productType.includes('soapstone') || productType.includes('porcelain') ||
                 productType.includes('sintered') || productType.includes('onyx') ||
                 productType.includes('travertine') || productType.includes('limestone')) {
        elementType = 'countertop';
        width = 4;
        height = 2;
      } else if (productType.includes('tile') || productType.includes('backsplash')) {
        elementType = 'backsplash';
        width = 4;
        height = 1.5;
      }

      // Find the color from ELEMENT_TYPES by searching all categories
      let foundColor = color;
      for (const category of Object.values(ELEMENT_TYPES)) {
        const found = category.find(e => e.type === elementType);
        if (found) {
          foundColor = found.color;
          break;
        }
      }

      const gridSnap = pixelsPerFoot / CONFIG.GRID_SUBDIVISIONS;
      const element = {
        id: Date.now() + Math.random(),
        type: elementType,
        x: Math.round(x / gridSnap) * gridSnap,
        y: Math.round(y / gridSnap) * gridSnap,
        width: width,
        height: height,
        color: foundColor,
        label: product.name || 'Store Product',
        rotation: 0,
        locked: false,
        roomId: currentRoom,
        storeProduct: {
          name: product.name,
          slug: product.slug,
          brand: product.brand,
          sku: product.sku,
          price: product.price,
          image: product.images?.[0] || product.image
        },
        priceOverride: product.price ? parseFloat(product.price) : null,
        costPrice: product.price ? parseFloat(product.price) : null,
        priceUnit: 'unit',
        marginPercent: null
      };

      // Apply texture from product image
      if (product.images?.[0] || product.image) {
        const imageUrl = product.images?.[0] || product.image;
        element.texture = imageUrl;

        const img = new Image();
        img.crossOrigin = 'anonymous';
        img.onload = () => {
          element.textureImg = img;
          draw();
          if (currentView === '3d') update3DScene();
        };
        img.src = imageUrl;
      }

      elements.push(element);
      console.log('Element created and added:', element);
      console.log('Total elements now:', elements.length);

      selectedElement = element;
      updateProperties();
      draw();
      calculateQuote();
      saveUndoState();

      showToast(`Added ${product.name} to design`, 'success');
    }

    function createElement(type, x, y) {
      let defaults = null;
      Object.values(ELEMENT_TYPES).forEach(cat => {
        const found = cat.find(el => el.type === type);
        if (found) defaults = found;
      });

      if (!defaults) return;

      const gridSnap = pixelsPerFoot / CONFIG.GRID_SUBDIVISIONS;
      // All cabinet types that should receive cabinet settings (construction, doorStyle, etc.)
      const CABINET_TYPES = ['base-cabinet', 'wall-cabinet', 'tall-cabinet', 'corner-cabinet',
                             'drawer-base', 'sink-base', 'lazy-susan', 'blind-corner', 'island',
                             'microwave-cabinet', 'above-microwave-cabinet', 'fridge-cabinet',
                             'single-oven-cabinet', 'tall-oven', 'double-oven-cabinet', 'laundry-cabinet'];
      const isCabinet = CABINET_TYPES.includes(type);
      const isCountertop = type === 'countertop' || type === 'countertop-l' || type === 'countertop-u';

      // For countertops, check if dropping on/near a cabinet to auto-fit
      let finalX = Math.round(x / gridSnap) * gridSnap;
      let finalY = Math.round(y / gridSnap) * gridSnap;
      let finalWidth = defaults.width;
      let finalHeight = defaults.height;
      let snappedToCabinet = null;

      if (isCountertop) {
        // Find cabinet under or near drop point
        const baseCabinetTypes = ['base-cabinet', 'drawer-base', 'sink-base', 'corner-cabinet', 'lazy-susan', 'island'];
        const snapDistance = pixelsPerFoot * 1; // 1 foot snap zone

        // Check each cabinet to find the best match
        let bestCabinet = null;
        let bestDistance = Infinity;

        elements.forEach(el => {
          if (!baseCabinetTypes.includes(el.type)) return;

          const cabCenterX = el.x + (el.width * pixelsPerFoot) / 2;
          const cabCenterY = el.y + ((el.height || el.depth || 2) * pixelsPerFoot) / 2;
          const distance = Math.sqrt(Math.pow(x - cabCenterX, 2) + Math.pow(y - cabCenterY, 2));

          if (distance < snapDistance && distance < bestDistance) {
            bestDistance = distance;
            bestCabinet = el;
          }
        });

        if (bestCabinet) {
          // Snap countertop to fit on cabinet with 1.5" overhang
          const overhangFeet = 0.125; // 1.5 inches in feet
          const overhangPx = overhangFeet * pixelsPerFoot;

          finalX = bestCabinet.x - overhangPx;
          finalY = bestCabinet.y - overhangPx;
          finalWidth = bestCabinet.width + (overhangFeet * 2);
          finalHeight = (bestCabinet.height || bestCabinet.depth || 2) + (overhangFeet * 2);
          snappedToCabinet = bestCabinet;
        }
      }

      // Check if this is a sink type
      const isSink = type === 'sink' || type === 'sink-double' || type === 'sink-farmhouse';

      const element = {
        id: Date.now() + Math.random(),
        type: type,
        x: finalX,
        y: finalY,
        width: finalWidth,
        height: finalHeight,
        color: defaults.color,
        label: defaults.label,
        rotation: snappedToCabinet ? (snappedToCabinet.rotation || 0) : 0,
        locked: false,
        roomId: currentRoom,
        texture: elementTextures[type] || null,
        textureImg: null,
        floorLevel: cabinetSettings.currentFloor,
        // Wall-specific settings (pony walls, knee walls, etc.)
        wallHeight: defaults.wallHeight || undefined,
        // Cabinet-specific settings
        construction: isCabinet ? cabinetSettings.construction : undefined,
        doorStyle: isCabinet ? cabinetSettings.doorStyle : undefined,
        doorOverlay: isCabinet ? cabinetSettings.doorOverlay : undefined,
        cabinetFinish: isCabinet ? cabinetSettings.cabinetFinish : undefined,
        grainType: isCabinet ? cabinetSettings.grainType : undefined,
        // Sink-specific settings
        mountType: isSink ? (defaults.mountType || 'undermount') : undefined,
        sinkColor: isSink ? 'stainless' : undefined,
        // Countertop-specific settings - 2" front overhang covers cabinet door faces
        overhangFront: isCountertop ? 0.167 : undefined, // 2" front overhang
        overhangBack: isCountertop ? 0 : undefined,       // 0" back (against wall)
        overhangLeft: isCountertop ? 0.125 : undefined,   // 1.5" sides
        overhangRight: isCountertop ? 0.125 : undefined,  // 1.5" sides
        edgeProfile: isCountertop ? 'eased' : undefined,
        thickness: isCountertop ? '3cm' : undefined,
        // Pricing fields
        priceOverride: null,
        priceUnit: 'sqft',
        marginPercent: null,
        costPrice: null,
        retailPrice: null
      };

      // Load texture if exists
      if (element.texture) {
        const img = new Image();
        img.onload = () => {
          element.textureImg = img;
          draw();
        };
        img.src = element.texture;
      }

      elements.push(element);
      selectedElement = element;
      updateProperties();
      calculateQuote();
      saveUndoState();
      draw();

      // Show feedback if snapped to cabinet
      if (snappedToCabinet) {
        showSnapFeedback('Countertop fitted to cabinet with 1.5" overhang');
      }
    }

    function duplicateElement(el) {
      const gridSnap = pixelsPerFoot / CONFIG.GRID_SUBDIVISIONS;
      const newEl = {
        ...el,
        id: Date.now() + Math.random(),
        x: el.x + gridSnap * 2,
        y: el.y + gridSnap * 2,
        locked: false
      };
      elements.push(newEl);
      selectedElement = newEl;
      updateProperties();
      calculateQuote();
      saveUndoState();
      draw();
    }

    // Quick action wrapper functions
    function duplicateSelectedElement() {
      if (selectedElement && !selectedElement.locked) {
        duplicateElement(selectedElement);
        showSnapFeedback('Element duplicated');
      }
    }

    function rotateSelectedElement(degrees) {
      if (selectedElement && !selectedElement.locked) {
        selectedElement.rotation = ((selectedElement.rotation || 0) + degrees) % 360;
        updateProperties();
        saveUndoState();
        draw();
        update3DScene();
        showSnapFeedback(`Rotated ${degrees}`);
      }
    }

    function flipSelectedElement(axis) {
      if (selectedElement && !selectedElement.locked) {
        // Flip by swapping width/height for some types or adjusting position
        if (axis === 'h') {
          // Horizontal flip - mirror position relative to room center
          const centerX = roomWidth * pixelsPerFoot / 2;
          const elCenterX = selectedElement.x + (selectedElement.width * pixelsPerFoot) / 2;
          const newCenterX = centerX + (centerX - elCenterX);
          selectedElement.x = newCenterX - (selectedElement.width * pixelsPerFoot) / 2;
        } else {
          // Vertical flip
          const centerY = roomDepth * pixelsPerFoot / 2;
          const elCenterY = selectedElement.y + (selectedElement.height * pixelsPerFoot) / 2;
          const newCenterY = centerY + (centerY - elCenterY);
          selectedElement.y = newCenterY - (selectedElement.height * pixelsPerFoot) / 2;
        }
        saveUndoState();
        draw();
        update3DScene();
        showSnapFeedback(`Flipped ${axis === 'h' ? 'horizontally' : 'vertically'}`);
      }
    }

    function bringToFront() {
      if (selectedElement) {
        // Move element to end of array (renders on top in both 2D and 3D)
        const idx = elements.indexOf(selectedElement);
        if (idx !== -1 && idx < elements.length - 1) {
          elements.splice(idx, 1);
          elements.push(selectedElement);
        }
        // Also adjust zIndexOffset for 2D canvas layering within same render order
        selectedElement.zIndexOffset = (selectedElement.zIndexOffset || 0) + 100;
        saveUndoState();
        draw();
        update3DScene();
        showSnapFeedback('Brought to front');
      }
    }

    function sendToBack() {
      if (selectedElement) {
        // Move element to beginning of array (renders behind others in both 2D and 3D)
        const idx = elements.indexOf(selectedElement);
        if (idx !== -1 && idx > 0) {
          elements.splice(idx, 1);
          elements.unshift(selectedElement);
        }
        // Also adjust zIndexOffset for 2D canvas layering
        selectedElement.zIndexOffset = (selectedElement.zIndexOffset || 0) - 100;
        saveUndoState();
        draw();
        update3DScene();
        showSnapFeedback('Sent to back');
      }
    }

    function resetLayering() {
      if (selectedElement) {
        selectedElement.zIndexOffset = 0;
        // Note: Array position stays the same - only resets zIndex offset
        saveUndoState();
        draw();
        update3DScene();
        showSnapFeedback('Layering reset');
      }
    }

    // ===== ELEMENT LOCKING (Simple grouping) =====

    // Lock mode state
    let lockMode = false;
    let lockSourceElement = null;

    // Start lock mode - next clicked element will be locked with current selection
    function lockElementsTogether() {
      if (!selectedElement) {
        showToast('Select an element first', 'warning', 2000);
        return;
      }

      lockMode = true;
      lockSourceElement = selectedElement;

      const btn = document.getElementById('lockTogetherBtn');
      if (btn) {
        btn.style.background = 'rgba(99, 102, 241, 0.8)';
      }

      showSnapFeedback('Click another element to lock together');
    }

    // Complete the lock - lock clicked element with source
    function completeLock(targetElement) {
      if (!lockSourceElement || !targetElement || lockSourceElement === targetElement) {
        cancelLockMode();
        return;
      }

      // Use source's groupId or create new one
      let groupId = lockSourceElement.groupId;
      if (!groupId) {
        groupId = 'group-' + nextGroupId++;
        lockSourceElement.groupId = groupId;
      }

      // Add target to the same group
      targetElement.groupId = groupId;

      saveUndoState();
      cancelLockMode();
      draw();

      const groupSize = elements.filter(el => el.groupId === groupId).length;
      showSnapFeedback(`Locked! ${groupSize} elements move together`);
    }

    // Cancel lock mode
    function cancelLockMode() {
      lockMode = false;
      lockSourceElement = null;

      const btn = document.getElementById('lockTogetherBtn');
      if (btn) {
        btn.style.background = 'rgba(99, 102, 241, 0.3)';
      }
    }

    // Unlock element from its group
    function unlockElement() {
      if (!selectedElement || !selectedElement.groupId) {
        showToast('Element is not locked', 'warning', 2000);
        return;
      }

      const groupId = selectedElement.groupId;

      // Remove this element from group
      delete selectedElement.groupId;

      // Check if any elements remain in the group
      const remaining = elements.filter(el => el.groupId === groupId);
      if (remaining.length === 1) {
        // Only one left, remove its groupId too
        delete remaining[0].groupId;
      }

      saveUndoState();
      updateLockUI();
      draw();
      showSnapFeedback('Element unlocked');
    }

    // Get all elements in the same group as the given element
    function getGroupMembers(element) {
      if (!element || !element.groupId) return [element];
      return elements.filter(el => el.groupId === element.groupId);
    }

    // Move all locked elements together
    function moveGroupedElements(primaryElement, dx, dy) {
      if (!primaryElement) return;

      const members = getGroupMembers(primaryElement);
      members.forEach(el => {
        if (el !== primaryElement) {
          el.x += dx;
          el.y += dy;
        }
      });
    }

    // Update lock-related UI (show/hide unlock button, update badge)
    function updateLockUI() {
      const unlockBtn = document.getElementById('unlockBtn');
      const selectionCount = document.getElementById('selectionCount');
      const selectionType = document.getElementById('selectionType');

      // Show unlock button if selected element is locked with others
      if (unlockBtn) {
        unlockBtn.style.display = (selectedElement && selectedElement.groupId) ? 'flex' : 'none';
      }

      // Update selection badge
      if (selectionCount && selectedElement) {
        if (selectedElement.groupId) {
          const groupSize = getGroupMembers(selectedElement).length;
          selectionCount.textContent = groupSize;
          selectionType.textContent = 'Locked';
        } else {
          selectionCount.textContent = '1';
          selectionType.textContent = 'Selected';
        }
      }
    }

    // ===== ITEM PICKER / QUOTE LIST =====
    let itemPickerFilter = 'all';
    let selectedItems = new Set(); // Track multi-selected items for bulk operations

    function updateItemPicker() {
      const listContainer = document.getElementById('itemPickerList');
      const totalDisplay = document.getElementById('itemPickerTotal');
      const itemCountDisplay = document.getElementById('itemCount');
      const subtotalDisplay = document.getElementById('itemSubtotal');

      if (!listContainer) return;

      // Filter elements based on current filter
      const filteredElements = elements.filter(el => {
        if (itemPickerFilter === 'all') return true;
        const category = getElementCategory(el.type);
        return category === itemPickerFilter;
      });

      // Calculate totals by category (only if pricing access)
      const canShowPricing = PRICING_ACCESS.canViewPricing;
      let totalPrice = 0;
      const categoryTotals = {
        cabinets: { count: 0, total: 0 },
        countertops: { count: 0, sqft: 0, total: 0 },
        appliances: { count: 0, total: 0 },
        fixtures: { count: 0, total: 0 },
        flooring: { count: 0, sqft: 0, total: 0 },
        other: { count: 0, total: 0 }
      };

      elements.forEach(el => {
        const price = canShowPricing ? calculateElementPrice(el) : 0;
        totalPrice += price;

        const cat = getElementCategory(el.type);
        const catKey = cat === 'countertops' || cat === 'flooring' ? cat :
                       cat === 'cabinets' ? 'cabinets' :
                       cat === 'appliances' ? 'appliances' :
                       cat === 'fixtures' || cat === 'bathroom' ? 'fixtures' : 'other';

        if (categoryTotals[catKey]) {
          categoryTotals[catKey].count++;
          categoryTotals[catKey].total += price;
          if (catKey === 'countertops' || catKey === 'flooring') {
            categoryTotals[catKey].sqft += getElementSqft(el);
          }
        }
      });

      // Update displays (show prices only if pricing access)
      if (totalDisplay) totalDisplay.textContent = canShowPricing ? formatCurrency(totalPrice) : '--';
      if (itemCountDisplay) itemCountDisplay.textContent = elements.length;
      if (subtotalDisplay) subtotalDisplay.textContent = canShowPricing ? formatCurrency(totalPrice) : '--';

      // Update category summary (show prices only if pricing access)
      const categorySummary = document.getElementById('itemCategorySummary');
      if (categorySummary) {
        let summaryHtml = '';
        if (categoryTotals.cabinets.count > 0) {
          summaryHtml += `<div class="summary-row"><span>Cabinets (${categoryTotals.cabinets.count})</span><span>${canShowPricing ? formatCurrency(categoryTotals.cabinets.total) : '--'}</span></div>`;
        }
        if (categoryTotals.countertops.count > 0) {
          summaryHtml += `<div class="summary-row"><span>Countertops (${categoryTotals.countertops.sqft.toFixed(1)} sqft)</span><span>${canShowPricing ? formatCurrency(categoryTotals.countertops.total) : '--'}</span></div>`;
        }
        if (categoryTotals.appliances.count > 0) {
          summaryHtml += `<div class="summary-row"><span>Appliances (${categoryTotals.appliances.count})</span><span>${canShowPricing ? formatCurrency(categoryTotals.appliances.total) : '--'}</span></div>`;
        }
        if (categoryTotals.fixtures.count > 0) {
          summaryHtml += `<div class="summary-row"><span>Fixtures (${categoryTotals.fixtures.count})</span><span>${canShowPricing ? formatCurrency(categoryTotals.fixtures.total) : '--'}</span></div>`;
        }
        if (categoryTotals.flooring.count > 0) {
          summaryHtml += `<div class="summary-row"><span>Flooring (${categoryTotals.flooring.sqft.toFixed(1)} sqft)</span><span>${canShowPricing ? formatCurrency(categoryTotals.flooring.total) : '--'}</span></div>`;
        }
        if (categoryTotals.other.count > 0) {
          summaryHtml += `<div class="summary-row"><span>Other (${categoryTotals.other.count})</span><span>${canShowPricing ? formatCurrency(categoryTotals.other.total) : '--'}</span></div>`;
        }
        categorySummary.innerHTML = summaryHtml;
      }

      // Build list HTML
      if (filteredElements.length === 0) {
        listContainer.innerHTML = `<div class="item-picker-empty">
          ${elements.length === 0 ? 'No items on canvas yet.<br>Drag elements from the left panel.' : 'No items match the filter.'}
        </div>`;
        return;
      }

      const canShowPrice = PRICING_ACCESS.canViewPricing;
      let html = '';
      filteredElements.forEach((el, idx) => {
        const isSelected = el === selectedElement;
        const isChecked = selectedItems.has(String(el.id));
        const typeName = formatElementType(el.type);
        const icon = getElementIcon(el.type);
        const price = canShowPrice ? calculateElementPrice(el) : 0;
        const dims = `${el.width.toFixed(1)}'  ${el.height.toFixed(1)}'`;
        const area = getElementSqft(el).toFixed(1);
        const material = el.materialName || el.storeProduct?.name || '';
        const realIdx = elements.indexOf(el);

        // Get additional info for different element types
        const areaTypes = ['countertop', 'backsplash', 'flooring', 'tile', 'wall-tile', 'bar-top', 'wall-cap'];
        const cabinetTypes = ['base-cabinet', 'wall-cabinet', 'tall-cabinet', 'corner-cabinet', 'island', 'drawer-base', 'sink-base', 'lazy-susan'];

        let detailLine = '';
        if (cabinetTypes.includes(el.type)) {
          // Show SKU and catalog for cabinets
          if (el.sku) {
            detailLine = `<span class="item-sku">${el.sku}</span>`;
            if (el.catalog) {
              const catalogName = el.catalog.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
              detailLine += ` <span class="item-catalog">(${catalogName})</span>`;
            }
          }
        } else if (areaTypes.includes(el.type)) {
          // Show sqft and unit price for area-based items (only if pricing access)
          let unitPrice = 0;
          if (canShowPrice) {
            if (el.priceOverride) unitPrice = el.priceOverride;
            else if (el.storeProduct?.price) unitPrice = el.storeProduct.price;
            else if (el.materialId && typeof MATERIALS !== 'undefined') {
              for (const cat in MATERIALS) {
                const mat = MATERIALS[cat].find(m => m.id === el.materialId);
                if (mat && (mat.price || mat.pricePerSqFt)) { unitPrice = mat.price || mat.pricePerSqFt; break; }
              }
            }
            else if (typeof CONFIG !== 'undefined') unitPrice = CONFIG.PRICING?.[el.type] || 0;
          }

          detailLine = `<span class="item-sqft">${area} sqft</span>`;
          if (canShowPrice && unitPrice > 0) detailLine += ` <span class="item-rate">@ $${unitPrice.toFixed(2)}/sqft</span>`;
        }

        html += `
          <div class="item-picker-item ${isSelected ? 'selected' : ''}"
               onclick="selectItemFromPicker(${realIdx})"
               data-id="${el.id}">
            <div class="item-row-main">
              <input type="checkbox" class="item-checkbox"
                     ${isChecked ? 'checked' : ''}
                     onclick="event.stopPropagation(); toggleItemSelection('${el.id}')">
              <div class="item-icon">${icon}</div>
              <div class="item-details">
                <div class="item-name">${el.label || typeName}</div>
                <div class="item-meta">
                  <span>${dims}</span>
                  ${!areaTypes.includes(el.type) ? `<span>${area} sq ft</span>` : ''}
                </div>
                ${detailLine ? `<div class="item-detail-line">${detailLine}</div>` : ''}
              </div>
              <div class="item-price">${price > 0 ? formatCurrency(price) : '--'}</div>
            </div>
            ${material ? `<div class="item-row-secondary">
              <span class="item-material">${material}</span>
              <span class="item-dims">Layer ${realIdx + 1}</span>
            </div>` : ''}
          </div>
        `;
      });

      listContainer.innerHTML = html;
    }

    // getElementCategory is defined earlier at line ~21225 (visibility toggles)

    function getElementIcon(type) {
      const icons = {
        // Cabinets
        'base-cabinet': '',
        'wall-cabinet': '',
        'tall-cabinet': '',
        'fridge-cabinet': '',
        'corner-cabinet': '',
        'island': '',
        'drawer-base': '',
        'sink-base': '',
        'lazy-susan': '',
        'blind-corner': '',
        'single-oven-cabinet': '',
        'tall-oven': '',
        'double-oven-cabinet': '',
        'microwave-cabinet': '',
        'above-microwave-cabinet': '',
        // Surfaces
        'countertop': '',
        'countertop-corner': '',
        'backsplash': '',
        'bar-top': '',
        'wall-cap': '',
        // Sinks
        'sink': '',
        'sink-double': '',
        'sink-farmhouse': '',
        // Appliances
        'stove': '',
        'range': '',
        'cooktop': '',
        'slide-in-range': '',
        'refrigerator': '',
        'dishwasher': '',
        'microwave': '',
        'oven': '',
        'wall-oven-double': '',
        'range-hood': '',
        // Flooring
        'flooring': '',
        'tile': '',
        'shower-pan': '',
        // Windows/Doors
        'window': '',
        'window-large': '',
        'window-bay': '',
        'bay-window': '',
        'picture-window': '',
        'door': '',
        'double-door': '',
        'sliding-door': '',
        'french-door': '',
        'glass-door': '',
        // Walls
        'wall': '',
        'pony-wall': '',
        'pony-wall-bar': '',
        'knee-wall': '',
        'accent-wall': '',
        'wall-tile': '',
        'shower-wall': '',
        // Bathroom
        'toilet': '',
        'bathtub': '',
        'bathtub-freestanding': '',
        'bathtub-corner': '',
        'bathtub-walk-in': '',
        'shower': '',
        'shower-base-36': '',
        'shower-base-48': '',
        'shower-base-60': '',
        'shower-bench': '',
        'towel-warmer': '',
        'grab-bar': '',
        'grab-bar-24': '',
        'grab-bar-36': '',
        'grab-bar-42': '',
        'toilet-round': '',
        'toilet-wall': '',
        'bidet': '',
        'vanity': '',
        'vanity-24': '',
        'vanity-30': '',
        'vanity-36': '',
        'vanity-48': '',
        'vanity-60': '',
        'vanity-72': '',
        // Laundry
        'washer': '',
        'dryer': '',
        'washer-dryer-stack': '',
        'laundry-cabinet': '',
        'ironing-board': '',
        'utility-sink': '',
        'laundry-sink': '',
        'drying-rack': '',
        // Closet
        'closet-rod': '',
        'closet-shelf': '',
        'drawer-unit': '',
        'closet-drawers': '',
        'shoe-rack': '',
        'closet-island': '',
        'jewelry-cabinet': '',
        'jewelry-drawer': '',
        'tie-rack': '',
        'full-mirror': '',
        // Niches
        'wall-niche': '',
        'shower-niche': '',
        'fireplace-niche': '',
        'tv-niche': '',
        'niche-surround': '',
        'fireplace-surround': '',
        'mantel': '',
        'fireplace-hearth': '',
        // Structural
        'steel-beam': '',
        'wood-beam': '',
        'concrete-beam': '',
        'header': '',
        'lvl-beam': '',
        'steel-column': '',
        'wood-post': '',
        'concrete-column': ''
      };
      return icons[type] || '';
    }

    function calculateElementPrice(el) {
      // Use the comprehensive getElementPrice function (defined later in file)
      // This function is called after all main functions are defined

      // Get price info using the comprehensive pricing system
      let priceInfo = { price: 0, source: 'default' };

      // 1) Manual override takes highest priority
      if (el.priceOverride !== null && el.priceOverride !== undefined) {
        priceInfo = { price: el.priceOverride, source: 'override' };
      }
      // 2) Check for cabinet catalog pricing (by SKU)
      else if (el.sku && el.catalog && typeof CABINET_CATALOGS !== 'undefined') {
        const catalog = CABINET_CATALOGS[el.catalog];
        if (catalog) {
          for (const category of Object.values(catalog.cabinets)) {
            const cab = category.find(c => c.sku === el.sku);
            if (cab && cab.price) {
              priceInfo = { price: cab.price, source: 'catalog' };
              break;
            }
          }
        }
      }
      // 3) Check store product price
      else if (el.storeProduct?.price) {
        priceInfo = { price: el.storeProduct.price, source: 'product' };
      }
      // 4) Check for material-specific pricing
      else if (el.materialId && typeof MATERIALS !== 'undefined') {
        for (const category in MATERIALS) {
          const mat = MATERIALS[category].find(m => m.id === el.materialId);
          if (mat && (mat.price || mat.pricePerSqFt)) {
            priceInfo = { price: mat.price || mat.pricePerSqFt, source: 'material' };
            break;
          }
        }
      }
      // 5) Check element's own pricePerSqFt
      else if (el.pricePerSqFt) {
        priceInfo = { price: el.pricePerSqFt, source: 'element' };
      }
      // 6) Check element's own price property
      else if (el.price) {
        priceInfo = { price: el.price, source: 'element' };
      }
      // 7) Check custom prices from Excel import
      else if (el.materialId && typeof PRICING_STATE !== 'undefined' && PRICING_STATE.customPrices?.[el.materialId]) {
        priceInfo = { price: PRICING_STATE.customPrices[el.materialId], source: 'pricelist' };
      }
      // 8) Fall back to default type pricing
      else if (typeof CONFIG !== 'undefined' && CONFIG.PRICING?.[el.type]) {
        priceInfo = { price: CONFIG.PRICING[el.type], source: 'default' };
      }

      let baseCost = priceInfo.price;

      // Calculate based on area for surface elements
      const areaTypes = ['countertop', 'countertop-corner', 'countertop-l', 'countertop-u', 'backsplash', 'flooring', 'tile', 'wall-tile', 'bar-top', 'wall-cap'];
      if (areaTypes.includes(el.type)) {
        const area = getElementSqft(el);
        baseCost = area * priceInfo.price;
      }

      // Get margin for retail pricing
      let margin = 30; // Default margin
      if (typeof PRICING_STATE !== 'undefined') {
        if (el.marginPercent !== null && el.marginPercent !== undefined) {
          margin = el.marginPercent;
        } else {
          // Get category-specific margin
          const cat = getElementCategory(el.type);
          const catMargins = { cabinets: 25, countertops: 35, appliances: 15, flooring: 30 };
          margin = PRICING_STATE.categoryMargins?.[cat] || catMargins[cat] || PRICING_STATE.globalMargin || 30;
        }
      }

      // Return retail price (cost + margin)
      return baseCost * (1 + margin / 100);
    }

    function formatCurrency(amount) {
      return '$' + amount.toFixed(2).replace(/\B(?=(\d{3})+(?!\d))/g, ',');
    }

    function selectItemFromPicker(idx) {
      if (idx >= 0 && idx < elements.length) {
        selectedElement = elements[idx];
        expandedElementType = selectedElement.type;
        updateProperties();
        updateElementSelector();
        updateItemPicker();
        draw();
      }
    }

    function toggleItemSelection(id) {
      // Convert to string for consistent comparison
      const strId = String(id);
      if (selectedItems.has(strId)) {
        selectedItems.delete(strId);
      } else {
        selectedItems.add(strId);
      }
      updateItemPicker();
    }

    function selectAllItems() {
      elements.forEach(el => selectedItems.add(String(el.id)));
      updateItemPicker();
    }

    function deselectAllItems() {
      selectedItems.clear();
      updateItemPicker();
    }

    function deleteSelectedItems() {
      if (selectedItems.size === 0) {
        showToast('No items selected', 'warning');
        return;
      }

      const count = selectedItems.size;
      elements = elements.filter(el => !selectedItems.has(String(el.id)));
      selectedItems.clear();
      selectedElement = null;

      saveUndoState();
      updateProperties();
      updateElementList();
      updateItemPicker();
      draw();
      showToast(`Deleted ${count} item${count > 1 ? 's' : ''}`, 'success');
    }

    function filterItemList() {
      const filterSelect = document.getElementById('itemFilterType');
      itemPickerFilter = filterSelect ? filterSelect.value : 'all';
      updateItemPicker();
    }

    // Update element layer list panel
    function updateElementList() {
      const listContainer = document.getElementById('elementLayerList');
      const countDisplay = document.getElementById('elementCountDisplay');
      if (!listContainer) return;

      // Update count
      if (countDisplay) countDisplay.textContent = elements.length;

      // Also update the element selector dropdown and item picker
      updateElementSelector();
      updateItemPicker();

      // Build list HTML
      if (elements.length === 0) {
        listContainer.innerHTML = '<div style="color: #888; padding: 8px; text-align: center;">No elements yet</div>';
        return;
      }

      // Sort by z-order for display
      const sortedElements = [...elements].sort((a, b) => {
        const aZ = (a.zIndexOffset || 0);
        const bZ = (b.zIndexOffset || 0);
        return bZ - aZ; // Higher z-index first
      });

      let html = '';
      sortedElements.forEach((el, idx) => {
        const isSelected = el === selectedElement;
        const label = el.label || el.materialName || formatElementType(el.type);
        const truncatedLabel = label.length > 20 ? label.substring(0, 18) + '...' : label;
        const layerNum = elements.length - idx;

        html += `
          <div class="element-layer-item ${isSelected ? 'selected' : ''}"
               onclick="selectElementFromList(${elements.indexOf(el)})"
               ondblclick="centerOnElement(${elements.indexOf(el)})"
               style="
                 display: flex;
                 align-items: center;
                 padding: 4px 8px;
                 cursor: pointer;
                 border-radius: 4px;
                 margin-bottom: 2px;
                 background: ${isSelected ? 'var(--gold)' : 'rgba(255,255,255,0.05)'};
                 color: ${isSelected ? '#000' : 'inherit'};
               ">
            <span style="
              width: 12px;
              height: 12px;
              border-radius: 2px;
              background: ${el.color || '#808080'};
              margin-right: 6px;
              flex-shrink: 0;
            "></span>
            <span style="flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">
              ${truncatedLabel}
            </span>
            <span style="font-size: 9px; color: ${isSelected ? '#333' : '#666'}; margin-left: 4px;">
              ${el.hidden ? '' : ''}
            </span>
          </div>
        `;
      });

      listContainer.innerHTML = html;
    }

    // Format element type for display
    function formatElementType(type) {
      return type.split('-').map(word =>
        word.charAt(0).toUpperCase() + word.slice(1)
      ).join(' ');
    }

    // Select element from the list
    function selectElementFromList(index) {
      if (index >= 0 && index < elements.length) {
        selectedElement = elements[index];
        updateProperties();
        updateElementList();
        updateElementSelector();
        draw();
      }
    }

    // Update the element selector dropdown in the right panel
    // Track which element type is currently expanded in the selector
    let expandedElementType = null;

    function updateElementSelector() {
      const flatList = document.getElementById('elementFlatList');
      const totalCount = document.getElementById('elementTotalCount');
      const actions = document.getElementById('elementSelectorActions');
      const filterSelect = document.getElementById('elementListFilter');

      if (!flatList) return;

      // Update total count
      if (totalCount) totalCount.textContent = elements.length;

      // Get current filter
      const filter = filterSelect ? filterSelect.value : 'all';

      // Filter elements
      const filteredElements = elements.filter(el => {
        if (filter === 'all') return true;
        const cat = getElementCategory(el.type);
        if (filter === 'cabinets') return cat === 'cabinets';
        if (filter === 'countertops') return cat === 'countertops';
        if (filter === 'appliances') return cat === 'appliances';
        if (filter === 'fixtures') return ['fixtures', 'bathroom'].includes(cat);
        return !['cabinets', 'countertops', 'appliances', 'fixtures', 'bathroom'].includes(cat);
      });

      // Build flat list
      if (elements.length === 0) {
        flatList.innerHTML = '<div class="no-elements-msg">No elements on canvas.<br>Drag items from the left panel.</div>';
        if (actions) actions.style.display = 'none';
        return;
      }

      if (filteredElements.length === 0) {
        flatList.innerHTML = '<div class="no-elements-msg">No elements match filter.</div>';
        if (actions) actions.style.display = 'none';
        return;
      }

      let html = '';
      filteredElements.forEach((el) => {
        const realIdx = elements.indexOf(el);
        const isSelected = selectedElement && selectedElement.id === el.id;
        const icon = getElementIcon(el.type);
        const typeName = el.type.replace(/-/g, ' ').replace(/\b\w/g, c => c.toUpperCase());
        const label = el.label || el.sku || typeName;
        const dims = `${el.width.toFixed(1)}'  ${el.height.toFixed(1)}'`;
        const material = el.materialName || '';

        html += `
          <div class="element-list-item ${isSelected ? 'selected' : ''}"
               onclick="selectAndFocusElement(${realIdx})"
               ondblclick="centerOnElement(${realIdx})"
               data-idx="${realIdx}">
            <span class="element-list-icon">${icon}</span>
            <div class="element-list-info">
              <div class="element-list-name">${label}</div>
              <div class="element-list-meta">${dims}${material ? '  ' + material : ''}</div>
            </div>
          </div>
        `;
      });

      flatList.innerHTML = html;

      // Show/hide actions based on selection
      if (actions) {
        actions.style.display = selectedElement ? 'flex' : 'none';
      }

      // Scroll selected element into view
      if (selectedElement) {
        const selectedItem = flatList.querySelector('.element-list-item.selected');
        if (selectedItem) {
          selectedItem.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }
      }
    }

    // Toggle element type expansion
    function toggleElementType(type) {
      if (expandedElementType === type) {
        // Collapse if already expanded
        expandedElementType = null;
      } else {
        // Expand this type
        expandedElementType = type;

        // Auto-select first element of this type if nothing selected
        const firstOfType = elements.find(el => el.type === type);
        if (firstOfType && (!selectedElement || selectedElement.type !== type)) {
          selectedElement = firstOfType;
          updateProperties();
          draw();
        }
      }
      updateElementSelector();
    }

    // Select element by index
    function selectElementByIndex(idx) {
      if (idx >= 0 && idx < elements.length) {
        selectedElement = elements[idx];
        expandedElementType = selectedElement.type;
        updateProperties();
        updateElementList();
        updateElementSelector();
        draw();
      }
    }

    // Select element and focus on it - called from element list
    function selectAndFocusElement(idx) {
      if (idx >= 0 && idx < elements.length) {
        selectedElement = elements[idx];
        expandedElementType = selectedElement.type;

        // Update UI
        updateProperties();
        updateElementList();
        updateElementSelector();
        updateItemPicker();
        draw();

        // Show a brief highlight effect on the canvas
        showSnapFeedback(`Selected: ${formatElementType(selectedElement.type)}`);
      }
    }

    // Handle selection from dropdown (legacy - keeping for compatibility)
    function selectElementFromDropdown() {
      // This function is now replaced by the type selector
      // Keeping for backward compatibility
      if (!selectedElement) return;
      updateProperties();
      updateElementList();
      draw();
    }

    // Focus/center view on selected element
    function focusSelectedElement() {
      if (!selectedElement) return;
      const idx = elements.indexOf(selectedElement);
      if (idx >= 0) {
        centerOnElement(idx);
      }
    }

    // Duplicate selected element
    // NOTE: duplicateSelectedElement and deleteSelectedElement are defined earlier
    // with proper locked status checks and 3D scene updates

    // Center view on element
    function centerOnElement(index) {
      if (index >= 0 && index < elements.length) {
        const el = elements[index];
        // Calculate center of element
        const centerX = el.x + (el.width * pixelsPerFoot) / 2;
        const centerY = el.y + (el.height * pixelsPerFoot) / 2;

        // Scroll canvas to center on element (if canvas is scrollable)
        const canvas = document.getElementById('canvas');
        if (canvas) {
          const container = canvas.parentElement;
          if (container) {
            container.scrollLeft = centerX - container.clientWidth / 2;
            container.scrollTop = centerY - container.clientHeight / 2;
          }
        }

        selectElementFromList(index);
        showSnapFeedback(`Centered on ${formatElementType(el.type)}`);
      }
    }

    // Move selected element up in layer order (higher z-index)
    function moveLayerUp() {
      if (selectedElement) {
        selectedElement.zIndexOffset = (selectedElement.zIndexOffset || 0) + 10;
        saveUndoState();
        draw();
        update3DScene();
        updateElementList();
        showSnapFeedback('Moved layer up');
      }
    }

    // Move selected element down in layer order (lower z-index)
    function moveLayerDown() {
      if (selectedElement) {
        selectedElement.zIndexOffset = (selectedElement.zIndexOffset || 0) - 10;
        saveUndoState();
        draw();
        update3DScene();
        updateElementList();
        showSnapFeedback('Moved layer down');
      }
    }

    function deleteSelectedElement() {
      if (selectedElement && !selectedElement.locked) {
        elements = elements.filter(el => el !== selectedElement);
        selectedElement = null;
        updateProperties();
        calculateQuote();
        saveUndoState();
        draw();
        update3DScene();
        showSnapFeedback('Element deleted');
      }
    }

    // ===== CONTEXT MENU =====
    const CABINET_TYPES_FOR_MENU = ['base-cabinet', 'wall-cabinet', 'tall-cabinet', 'corner-cabinet',
                                     'drawer-base', 'sink-base', 'lazy-susan', 'blind-corner', 'island',
                                     'microwave-cabinet', 'above-microwave-cabinet', 'fridge-cabinet',
                                     'single-oven-cabinet', 'tall-oven', 'double-oven-cabinet', 'laundry-cabinet'];

    function showContextMenu(x, y, element) {
      const menu = document.getElementById('contextMenu');
      menu.style.display = 'block';
      menu.style.left = x + 'px';
      menu.style.top = y + 'px';

      document.getElementById('contextMenuLabel').textContent = element.label;
      document.getElementById('lockText').textContent = element.locked ? 'Unlock' : 'Lock';

      // Show/hide cabinet-specific options
      const isCabinet = CABINET_TYPES_FOR_MENU.includes(element.type);
      const replaceItem = document.getElementById('replaceMenuItem');
      const resizeItem = document.getElementById('resizeMenuItem');
      if (replaceItem) replaceItem.style.display = isCabinet ? 'flex' : 'none';
      if (resizeItem) resizeItem.style.display = isCabinet ? 'flex' : 'none';
    }

    function hideContextMenu() {
      document.getElementById('contextMenu').style.display = 'none';
      contextMenuElement = null;
    }

    function contextAction(action) {
      if (!contextMenuElement) return;

      switch(action) {
        case 'rotate':
          if (!contextMenuElement.locked) {
            contextMenuElement.rotation = ((contextMenuElement.rotation || 0) + 90) % 360;
          }
          break;
        case 'duplicate':
          duplicateElement(contextMenuElement);
          break;
        case 'texture':
          selectedElement = contextMenuElement;
          openMaterialPicker();
          break;
        case 'lock':
          contextMenuElement.locked = !contextMenuElement.locked;
          break;
        case 'front':
          elements = elements.filter(el => el !== contextMenuElement);
          elements.push(contextMenuElement);
          break;
        case 'back':
          elements = elements.filter(el => el !== contextMenuElement);
          elements.unshift(contextMenuElement);
          break;
        case 'delete':
          if (!contextMenuElement.locked) {
            elements = elements.filter(el => el !== contextMenuElement);
            if (selectedElement === contextMenuElement) {
              selectedElement = null;
              updateProperties();
            }
          }
          break;
        case 'replace':
          openReplaceCabinetModal(contextMenuElement);
          break;
        case 'resize':
          openResizeCabinetModal(contextMenuElement);
          break;
      }

      hideContextMenu();
      draw();
    }

    // ===== CABINET REPLACE/RESIZE MODALS =====
    let cabinetToReplace = null;
    let cabinetToResize = null;

    function openReplaceCabinetModal(element) {
      cabinetToReplace = element;
      const modal = document.getElementById('replaceCabinetModal');
      const typeSelect = document.getElementById('replaceCabinetType');
      const widthSelect = document.getElementById('replaceCabinetWidth');

      // Pre-select current type if available
      if (typeSelect) {
        const currentType = element.type;
        const options = typeSelect.options;
        for (let i = 0; i < options.length; i++) {
          if (options[i].value === currentType) {
            typeSelect.selectedIndex = i;
            break;
          }
        }
      }

      // Pre-select current width
      if (widthSelect) {
        const currentWidth = element.width || 2;
        const options = widthSelect.options;
        let closestIndex = 0;
        let closestDiff = Infinity;
        for (let i = 0; i < options.length; i++) {
          const diff = Math.abs(parseFloat(options[i].value) - currentWidth);
          if (diff < closestDiff) {
            closestDiff = diff;
            closestIndex = i;
          }
        }
        widthSelect.selectedIndex = closestIndex;
      }

      if (modal) modal.style.display = 'flex';
    }

    function closeReplaceCabinetModal() {
      const modal = document.getElementById('replaceCabinetModal');
      if (modal) modal.style.display = 'none';
      cabinetToReplace = null;
    }

    function applyReplaceCabinet() {
      if (!cabinetToReplace) return;

      const typeSelect = document.getElementById('replaceCabinetType');
      const widthSelect = document.getElementById('replaceCabinetWidth');
      const newType = typeSelect ? typeSelect.value : 'base-cabinet';
      const newWidth = widthSelect ? parseFloat(widthSelect.value) : 2;

      // Handle filler types specially
      let actualType = newType;
      let isFiller = false;
      if (newType === 'filler-3') {
        actualType = 'base-cabinet';
        isFiller = true;
        cabinetToReplace.width = 0.25; // 3"
      } else if (newType === 'filler-6') {
        actualType = 'base-cabinet';
        isFiller = true;
        cabinetToReplace.width = 0.5; // 6"
      } else {
        cabinetToReplace.width = newWidth;
      }

      // Get cabinet style info
      const widthInches = Math.round(cabinetToReplace.width * 12);
      const styles = {
        'base-cabinet': { color: '#8B4513', label: `Base ${widthInches}"` },
        'drawer-base': { color: '#8B5A2B', label: `Drawer ${widthInches}"` },
        'sink-base': { color: '#6B4423', label: `Sink Base ${widthInches}"` },
        'corner-cabinet': { color: '#A0522D', label: 'Corner 36"' },
        'lazy-susan': { color: '#A0522D', label: 'Lazy Susan' },
        'blind-corner': { color: '#7B5513', label: 'Blind Corner' },
        'wall-cabinet': { color: '#D2691E', label: `Wall ${widthInches}"` },
        'tall-cabinet': { color: '#5D4037', label: `Tall ${widthInches}"` },
        'fridge-cabinet': { color: '#5D4037', label: 'Fridge Cab' },
        'single-oven-cabinet': { color: '#5D4037', label: 'Oven Cab' },
        'tall-oven': { color: '#5D4037', label: 'Tall Oven' },
        'double-oven-cabinet': { color: '#5D4037', label: 'Dbl Oven Cab' },
        'dishwasher': { color: '#607D8B', label: 'Dishwasher' },
        'range': { color: '#455A64', label: 'Range' },
        'microwave-cabinet': { color: '#5D4037', label: 'Microwave Cab' }
      };

      const style = isFiller ? { color: '#654321', label: `Filler ${widthInches}"` } : (styles[actualType] || { color: '#8B4513', label: `${widthInches}"` });

      // Update the cabinet
      cabinetToReplace.type = actualType;
      cabinetToReplace.color = style.color;
      cabinetToReplace.label = style.label;
      cabinetToReplace.isFiller = isFiller;

      // Update depth based on type
      if (actualType === 'wall-cabinet') {
        cabinetToReplace.height = 1; // 12" depth
      } else if (actualType === 'corner-cabinet' || actualType === 'lazy-susan') {
        cabinetToReplace.width = 3; // 36" square
        cabinetToReplace.height = 3;
      } else if (actualType === 'tall-cabinet' || actualType === 'fridge-cabinet' || actualType === 'single-oven-cabinet' || actualType === 'tall-oven' || actualType === 'double-oven-cabinet') {
        cabinetToReplace.height = 2; // 24" depth
      }

      saveUndoState();
      closeReplaceCabinetModal();
      draw();
      update3DScene();
      showSnapFeedback(`Replaced with ${style.label}`);
    }

    function openResizeCabinetModal(element) {
      cabinetToResize = element;
      const modal = document.getElementById('resizeCabinetModal');
      const widthSelect = document.getElementById('resizeCabinetWidth');

      // Pre-select current width
      if (widthSelect) {
        const currentWidth = element.width || 2;
        const options = widthSelect.options;
        let closestIndex = 0;
        let closestDiff = Infinity;
        for (let i = 0; i < options.length; i++) {
          const diff = Math.abs(parseFloat(options[i].value) - currentWidth);
          if (diff < closestDiff) {
            closestDiff = diff;
            closestIndex = i;
          }
        }
        widthSelect.selectedIndex = closestIndex;
      }

      if (modal) modal.style.display = 'flex';
    }

    function closeResizeCabinetModal() {
      const modal = document.getElementById('resizeCabinetModal');
      if (modal) modal.style.display = 'none';
      cabinetToResize = null;
    }

    function applyResizeCabinet() {
      if (!cabinetToResize) return;

      const widthSelect = document.getElementById('resizeCabinetWidth');
      const newWidth = widthSelect ? parseFloat(widthSelect.value) : 2;
      const widthInches = Math.round(newWidth * 12);

      cabinetToResize.width = newWidth;

      // Update label to reflect new size
      const typeLabel = cabinetToResize.type.replace(/-/g, ' ').replace(/\b\w/g, c => c.toUpperCase()).replace('Cabinet', '').trim();
      cabinetToResize.label = `${typeLabel} ${widthInches}"`;

      saveUndoState();
      closeResizeCabinetModal();
      draw();
      update3DScene();
      showSnapFeedback(`Resized to ${widthInches}"`);
    }

    // ===== TOOLS =====
    function setTool(tool) {
      try {
        currentTool = tool;
        document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('active'));
        const btn = document.getElementById('tool' + tool.charAt(0).toUpperCase() + tool.slice(1));
        if (btn) btn.classList.add('active');

        // Show/hide layout options panel
        const layoutPanel = document.getElementById('layoutOptionsPanel');
        if (layoutPanel) {
          layoutPanel.style.display = tool === 'layout' ? 'block' : 'none';
        }

        // Reset layout mode when switching tools
        if (tool !== 'layout') {
          resetLayoutMode();
        }

        canvas.style.cursor = (tool === 'wall' || tool === 'countertop' || tool === 'layout') ? 'crosshair' : (tool === 'pan' ? 'grab' : 'default');
        draw();
      } catch (err) {
        console.error('setTool error:', err);
        currentTool = 'select';
      }
    }

    // Layout tool option handlers
    function updateLayoutElementType() {
      const select = document.getElementById('layoutElementType');
      layoutMode.cabinetType = select.value;

      // Auto-adjust depth based on element type
      const depthSelect = document.getElementById('layoutDepth');
      switch (select.value) {
        // Wall cabinets - 12" deep
        case 'wall-cabinet':
        case 'wall-corner':
          depthSelect.value = '1';
          layoutMode.cabinetDepth = 1;
          break;

        // Base cabinets - 24" deep
        case 'base-cabinet':
        case 'drawer-base':
        case 'sink-base':
        case 'corner-cabinet':
        case 'lazy-susan':
        case 'blind-corner':
          depthSelect.value = '2';
          layoutMode.cabinetDepth = 2;
          break;

        // Tall cabinets - 24" deep
        case 'tall-cabinet':
        case 'tall-oven':
        case 'fridge-cabinet':
          depthSelect.value = '2';
          layoutMode.cabinetDepth = 2;
          break;

        // Islands - 24-36" deep
        case 'island':
          depthSelect.value = '2';
          layoutMode.cabinetDepth = 2;
          break;

        // Walls - 6" thick
        case 'pony-wall':
        case 'pony-wall-bar':
        case 'knee-wall':
        case 'wall':
          depthSelect.value = '0.5';
          layoutMode.cabinetDepth = 0.5;
          // Add wall thickness option if not present
          if (!depthSelect.querySelector('option[value="0.5"]')) {
            const opt = document.createElement('option');
            opt.value = '0.5';
            opt.textContent = '6" (Wall)';
            depthSelect.insertBefore(opt, depthSelect.firstChild);
          }
          break;

        // Countertops - match cabinet depth (26" with overhang)
        case 'countertop':
        case 'countertop-corner':
          depthSelect.value = '2';
          layoutMode.cabinetDepth = 2.17; // 26" = 25" cabinet + 1" overhang
          break;

        // Backsplash - thin
        case 'backsplash':
          depthSelect.value = '1';
          layoutMode.cabinetDepth = 0.08; // Very thin for backsplash
          break;
      }

      // Disable "Draw Both Levels" if not a base cabinet type
      const bothLevelsCheckbox = document.getElementById('layoutBothLevels');
      const isBaseCabinet = ['base-cabinet', 'drawer-base', 'sink-base', 'corner-cabinet', 'lazy-susan', 'blind-corner'].includes(select.value);
      if (bothLevelsCheckbox && !isBaseCabinet && layoutMode.drawBothLevels) {
        bothLevelsCheckbox.checked = false;
        layoutMode.drawBothLevels = false;
      }

      showSnapFeedback(`Layout: ${select.options[select.selectedIndex].text}`);
    }

    function updateLayoutDepth() {
      const select = document.getElementById('layoutDepth');
      layoutMode.cabinetDepth = parseFloat(select.value);
      showSnapFeedback(`Depth: ${Math.round(layoutMode.cabinetDepth * 12)}"`);
    }

    function updateLayoutCountertop() {
      const checkbox = document.getElementById('layoutAddCountertop');
      layoutMode.addCountertop = checkbox.checked;
    }

    function updateLayoutWallSnap() {
      const checkbox = document.getElementById('layoutSnapToWalls');
      layoutMode.snapToWalls = checkbox.checked;
    }

    function updateLayoutBothLevels() {
      const checkbox = document.getElementById('layoutBothLevels');
      layoutMode.drawBothLevels = checkbox.checked;

      // When enabled, force base cabinet type and standard depth
      if (checkbox.checked) {
        const typeSelect = document.getElementById('layoutElementType');
        const depthSelect = document.getElementById('layoutDepth');
        if (typeSelect) {
          typeSelect.value = 'base-cabinet';
          layoutMode.cabinetType = 'base-cabinet';
        }
        if (depthSelect) {
          depthSelect.value = '2';
          layoutMode.cabinetDepth = 2;
        }
        showSnapFeedback('Drawing upper + lower cabinets together');
      } else {
        showSnapFeedback('Drawing single level cabinets');
      }
    }

    function updateLayoutCornerType() {
      const select = document.getElementById('layoutCornerType');
      layoutMode.cornerType = select.value;
      showSnapFeedback(`Corner: ${select.options[select.selectedIndex].text}`);
    }

    // ===== CABINET LAYOUT TOOL =====
    // ===== DRAFTING-STYLE LAYOUT BRUSH =====
    // Click-drag to draw straight orthogonal cabinet runs
    // Automatically creates corners when direction changes significantly
    const layoutMode = {
      isDrawing: false,     // Currently dragging
      corners: [],          // Corner points (where direction changes)
      currentEnd: null,     // Current endpoint (snapped to orthogonal)
      currentDirection: null, // 'horizontal' or 'vertical'
      points: [],           // Legacy array for backward compatibility
      active: false,        // Legacy flag
      cabinetType: 'base-cabinet',
      cabinetDepth: 2,      // 24" depth (standard base cabinet)
      cornerType: 'corner-cabinet', // How to handle corners
      addCountertop: false, // Don't auto-add countertop - user can add separately
      snapToWalls: true,    // Auto-snap to walls and room boundaries
      gridSnap: 0.5,        // Snap to 6" grid
      turnThreshold: 1.5,   // Feet of movement in perpendicular direction to trigger turn
      minRunLength: 1,      // Minimum 1 foot run
      // Upper + Lower cabinet pairing
      drawBothLevels: true,    // Draw wall cabinets above base cabinets
      wallCabinetDepth: 1,     // 12" depth for wall cabinets
      // Standard cabinet widths (in feet): 36", 33", 30", 27", 24", 21", 18", 15", 12", 9"
      standardWidths: [3, 2.75, 2.5, 2.25, 2, 1.75, 1.5, 1.25, 1, 0.75],
      // Filler widths for gaps (in feet): 6", 3"
      fillerWidths: [0.5, 0.25]
    };

    // Snap a value to the grid
    function snapToGrid(val) {
      return Math.round(val / layoutMode.gridSnap) * layoutMode.gridSnap;
    }

    // Snap to walls - find nearest wall edge and snap to it if within threshold
    function snapToWalls(worldX, worldY, direction) {
      const snapThreshold = 1.0; // 1 foot snap threshold
      const depth = layoutMode.cabinetDepth || 2;
      let snappedX = worldX;
      let snappedY = worldY;
      let snappedToWall = null;

      // Get all wall-like elements (including room boundaries)
      const wallElements = elements.filter(el =>
        el.type === 'wall' ||
        el.type === 'pony-wall' ||
        el.type === 'knee-wall' ||
        el.type === 'pony-wall-bar'
      );

      // Also consider room boundaries as virtual walls
      const roomWalls = [
        { edge: 'top', y: 0, isHorizontal: true },
        { edge: 'bottom', y: roomDepth, isHorizontal: true },
        { edge: 'left', x: 0, isHorizontal: false },
        { edge: 'right', x: roomWidth, isHorizontal: false }
      ];

      // Check room boundaries first
      roomWalls.forEach(rw => {
        if (rw.isHorizontal) {
          // Top/bottom walls - snap Y position
          const distToWall = Math.abs(worldY - rw.y);
          const distWithDepth = Math.abs(worldY - depth/2 - rw.y);
          const distWithDepthOther = Math.abs(worldY + depth/2 - rw.y);

          if (distToWall < snapThreshold) {
            // Snap cabinet to be against this wall
            snappedY = rw.edge === 'top' ? depth/2 : rw.y - depth/2;
            snappedToWall = rw.edge + ' wall';
          } else if (distWithDepth < snapThreshold || distWithDepthOther < snapThreshold) {
            snappedY = rw.edge === 'top' ? depth/2 : rw.y - depth/2;
            snappedToWall = rw.edge + ' wall';
          }
        } else {
          // Left/right walls - snap X position
          const distToWall = Math.abs(worldX - rw.x);

          if (distToWall < snapThreshold) {
            snappedX = rw.edge === 'left' ? depth/2 : rw.x - depth/2;
            snappedToWall = rw.edge + ' wall';
          }
        }
      });

      // Check drawn walls
      wallElements.forEach(wall => {
        const wallX = wall.x / pixelsPerFoot;
        const wallY = wall.y / pixelsPerFoot;
        const wallW = wall.width;
        const wallH = wall.height;
        const wallCenterX = wallX + wallW/2;
        const wallCenterY = wallY + wallH/2;

        // Determine if wall is horizontal or vertical
        const wallIsHorizontal = wallW > wallH;

        if (wallIsHorizontal) {
          // Check if we're near the top or bottom edge of this horizontal wall
          const topEdge = wallY;
          const bottomEdge = wallY + wallH;

          // Snap to top edge (place cabinets above wall)
          if (Math.abs(worldY - topEdge) < snapThreshold) {
            snappedY = topEdge - depth/2;
            snappedToWall = wall.label || 'wall';
          }
          // Snap to bottom edge (place cabinets below wall)
          else if (Math.abs(worldY - bottomEdge) < snapThreshold) {
            snappedY = bottomEdge + depth/2;
            snappedToWall = wall.label || 'wall';
          }
        } else {
          // Check if we're near the left or right edge of this vertical wall
          const leftEdge = wallX;
          const rightEdge = wallX + wallW;

          // Snap to left edge
          if (Math.abs(worldX - leftEdge) < snapThreshold) {
            snappedX = leftEdge - depth/2;
            snappedToWall = wall.label || 'wall';
          }
          // Snap to right edge
          else if (Math.abs(worldX - rightEdge) < snapThreshold) {
            snappedX = rightEdge + depth/2;
            snappedToWall = wall.label || 'wall';
          }
        }
      });

      return {
        x: snapToGrid(snappedX),
        y: snapToGrid(snappedY),
        snappedTo: snappedToWall
      };
    }

    // Start drawing layout path on mouse down
    function startLayoutDraw(screenX, screenY) {
      try {
        const rawX = screenX / pixelsPerFoot;
        const rawY = screenY / pixelsPerFoot;

        let worldX, worldY;

        // Try to snap to nearby walls if enabled
        if (layoutMode.snapToWalls) {
          const snapped = snapToWalls(rawX, rawY, null);
          worldX = snapped.x;
          worldY = snapped.y;

          if (snapped.snappedTo) {
            showSnapFeedback(`Snapped to ${snapped.snappedTo}`);
          }
        } else {
          worldX = snapToGrid(rawX);
          worldY = snapToGrid(rawY);
        }

        layoutMode.isDrawing = true;
        layoutMode.corners = [{ x: worldX, y: worldY }];
        layoutMode.currentEnd = { x: worldX, y: worldY };
        layoutMode.currentDirection = null;

        canvas.style.cursor = 'crosshair';
        draw();
      } catch (err) {
        console.error('Layout startDraw error:', err);
        resetLayoutMode();
      }
    }

    // Reset layout mode to clean state
    function resetLayoutMode() {
      layoutMode.isDrawing = false;
      layoutMode.corners = [];
      layoutMode.currentEnd = null;
      layoutMode.currentDirection = null;
      layoutMode.active = false;
      layoutMode.points = [];
      canvas.style.cursor = currentTool === 'layout' ? 'crosshair' : 'default';
    }

    // Continue drawing layout path on mouse move
    function continueLayoutDraw(screenX, screenY) {
      try {
        if (!layoutMode.isDrawing) return;
        if (!layoutMode.corners || layoutMode.corners.length === 0) {
          resetLayoutMode();
          return;
        }

        const worldX = screenX / pixelsPerFoot;
        const worldY = screenY / pixelsPerFoot;

        const lastCorner = layoutMode.corners[layoutMode.corners.length - 1];
        if (!lastCorner) {
          resetLayoutMode();
          return;
        }

        const dx = worldX - lastCorner.x;
        const dy = worldY - lastCorner.y;
        const absDx = Math.abs(dx);
        const absDy = Math.abs(dy);

        // Determine if we should be drawing horizontal or vertical
        if (layoutMode.currentDirection === null) {
          // First movement - determine direction based on which axis has more movement
          if (absDx > 0.5 || absDy > 0.5) {
            layoutMode.currentDirection = absDx > absDy ? 'horizontal' : 'vertical';
          }
        }

        // Check if user is trying to turn (significant movement in perpendicular direction)
        if (layoutMode.currentDirection === 'horizontal' && absDy > layoutMode.turnThreshold && absDx > layoutMode.minRunLength) {
          // User wants to turn from horizontal to vertical
          // First, finalize the horizontal segment
          const endX = snapToGrid(worldX);
          layoutMode.corners.push({ x: endX, y: lastCorner.y });
          layoutMode.currentDirection = 'vertical';
        } else if (layoutMode.currentDirection === 'vertical' && absDx > layoutMode.turnThreshold && absDy > layoutMode.minRunLength) {
          // User wants to turn from vertical to horizontal
          const endY = snapToGrid(worldY);
          layoutMode.corners.push({ x: lastCorner.x, y: endY });
          layoutMode.currentDirection = 'horizontal';
        }

        // Update current end point (constrained to current direction)
        const currentCorner = layoutMode.corners[layoutMode.corners.length - 1];
        if (!currentCorner) {
          resetLayoutMode();
          return;
        }

        if (layoutMode.currentDirection === 'horizontal') {
          layoutMode.currentEnd = {
            x: snapToGrid(worldX),
            y: currentCorner.y
          };
        } else if (layoutMode.currentDirection === 'vertical') {
          layoutMode.currentEnd = {
            x: currentCorner.x,
            y: snapToGrid(worldY)
          };
        } else {
          // No direction yet - show preview in dominant direction
          layoutMode.currentEnd = {
            x: absDx > absDy ? snapToGrid(worldX) : currentCorner.x,
            y: absDy > absDx ? snapToGrid(worldY) : currentCorner.y
          };
        }

        draw();
      } catch (err) {
        console.error('Layout continueDraw error:', err);
        resetLayoutMode();
      }
    }

    // Finish drawing and generate cabinets on mouse up
    function finishLayoutDraw() {
      try {
        if (!layoutMode.isDrawing) return;
        layoutMode.isDrawing = false;

        // Safety check
        if (!layoutMode.corners || layoutMode.corners.length === 0) {
          resetLayoutMode();
          draw();
          return;
        }

        // Add the current end as the final point
        const lastCorner = layoutMode.corners[layoutMode.corners.length - 1];
        if (lastCorner && layoutMode.currentEnd &&
            (layoutMode.currentEnd.x !== lastCorner.x || layoutMode.currentEnd.y !== lastCorner.y)) {
          layoutMode.corners.push({ ...layoutMode.currentEnd });
        }

        // Need at least 2 points to make a run
        if (layoutMode.corners.length < 2) {
          showSnapFeedback('Drag to create a cabinet run');
          resetLayoutMode();
          draw();
          return;
        }

        // Check total path length
        let totalLength = 0;
        for (let i = 0; i < layoutMode.corners.length - 1; i++) {
          const p1 = layoutMode.corners[i];
          const p2 = layoutMode.corners[i + 1];
          if (p1 && p2) {
            totalLength += Math.abs(p2.x - p1.x) + Math.abs(p2.y - p1.y);
          }
        }

        if (totalLength < layoutMode.minRunLength) {
          showSnapFeedback('Drag further to create a cabinet run');
          resetLayoutMode();
          draw();
          return;
        }

        // Generate cabinets along the path
        const newElements = generateCabinetsAlongPath(layoutMode.corners);

        if (!newElements || newElements.length === 0) {
          showSnapFeedback('Could not place cabinets');
          resetLayoutMode();
          draw();
          return;
        }

        // Add elements to canvas
        newElements.forEach(el => elements.push(el));

        // Generate wall cabinets above base cabinets if "Draw Both Levels" is enabled
        let wallCabinets = [];
        if (layoutMode.drawBothLevels && newElements.length > 0) {
          wallCabinets = generateWallCabinetsForRun(newElements);
          wallCabinets.forEach(el => elements.push(el));
        }

        // Add countertop
        if (layoutMode.addCountertop && newElements.length > 0) {
          const countertop = generateCountertopForRun(newElements);
          if (countertop) elements.push(countertop);
        }

        const cornerCount = layoutMode.corners.length - 1;
        const shapeDesc = cornerCount === 1 ? 'straight run' :
                          cornerCount === 2 ? 'L-shape' :
                          cornerCount === 3 ? 'U-shape' : `${cornerCount}-turn layout`;
        const counterMsg = layoutMode.addCountertop ? ' + countertop' : '';
        const wallMsg = wallCabinets.length > 0 ? ` + ${wallCabinets.length} wall cabs` : '';
        const typeLabel = document.getElementById('layoutElementType')?.options[document.getElementById('layoutElementType')?.selectedIndex]?.text || 'elements';
        showSnapFeedback(`Added ${newElements.length} ${typeLabel} (${shapeDesc})${counterMsg}${wallMsg}`);
        saveUndoState();

        // Reset
        resetLayoutMode();
        draw();
        update3DScene();
      } catch (err) {
        console.error('Layout finishDraw error:', err);
        resetLayoutMode();
        draw();
      }
    }

    // Legacy function for compatibility
    function handleLayoutClick(screenX, screenY) {
      startLayoutDraw(screenX, screenY);
    }

    function finalizeLayoutRun() {
      finishLayoutDraw();
    }

    // Determine which wall an element is against based on position
    // Returns wall info with suggested rotation for cabinet fronts to face into room
    function getWallOrientation(element) {
      const elX = element.x / pixelsPerFoot;
      const elY = element.y / pixelsPerFoot;
      const elWidth = element.width || 2;
      const elHeight = element.height || 2;
      const threshold = 1.5; // Within 1.5 feet of wall

      // Check which wall this element is closest to
      const distToBack = elY;                           // Distance to Y=0 (back wall)
      const distToFront = roomDepth - (elY + elHeight); // Distance to Y=max (front wall)
      const distToLeft = elX;                           // Distance to X=0 (left wall)
      const distToRight = roomWidth - (elX + elWidth);  // Distance to X=max (right wall)

      // Find minimum distance
      const minDist = Math.min(distToBack, distToFront, distToLeft, distToRight);

      // If not near any wall, it's likely an island
      if (minDist > threshold) {
        return { wall: null, rotation: 0, facingDirection: 'south', isIsland: true };
      }

      // Determine which wall based on minimum distance
      if (minDist === distToBack && distToBack <= threshold) {
        return { wall: 'back', rotation: 0, facingDirection: 'south', isIsland: false };
      }
      if (minDist === distToFront && distToFront <= threshold) {
        return { wall: 'front', rotation: 180, facingDirection: 'north', isIsland: false };
      }
      if (minDist === distToLeft && distToLeft <= threshold) {
        return { wall: 'left', rotation: 270, facingDirection: 'east', isIsland: false };
      }
      if (minDist === distToRight && distToRight <= threshold) {
        return { wall: 'right', rotation: 90, facingDirection: 'west', isIsland: false };
      }

      // Default to back wall
      return { wall: 'back', rotation: 0, facingDirection: 'south', isIsland: false };
    }

    // Generate wall cabinets above a run of base cabinets
    // Used when "Draw Upper + Lower Together" is enabled
    function generateWallCabinetsForRun(baseCabinets) {
      const wallCabs = [];
      const baseTypes = ['base-cabinet', 'drawer-base', 'sink-base'];
      const wallCabDepth = layoutMode.wallCabinetDepth || 1; // 12" depth

      baseCabinets.forEach(base => {
        // Only create wall cabs for regular base cabinets
        if (!baseTypes.includes(base.type)) return;

        // Skip corner cabinets - they need special handling
        if (base.type === 'corner-cabinet' || base.type === 'lazy-susan') return;

        // Skip fillers - no wall cabinet above filler pieces
        if (base.isFiller) return;

        // Skip sink bases - typically no wall cabinet above sink (window)
        // User can manually add if needed
        if (base.type === 'sink-base') return;

        // Get cabinet width - handle both horizontal and vertical orientations
        const rotation = base.rotation || 0;
        const isVertical = rotation === 90 || rotation === 270;
        const cabinetWidth = isVertical ? base.height : base.width;
        const widthInches = Math.round(cabinetWidth * 12);

        // Create wall cabinet with same position and width
        // In 2D, position is the same - 3D handles vertical placement
        const wallCab = {
          type: 'wall-cabinet',
          x: base.x,
          y: base.y,
          width: base.width,
          height: wallCabDepth,  // 12" depth (2D depth = 3D depth)
          rotation: rotation,
          color: '#D2691E',      // Lighter brown for wall cabs
          label: `Wall ${widthInches}"`,
          id: generateId(),
          roomId: currentRoom,
          // Copy cabinet settings from base cabinet
          construction: base.construction || cabinetSettings.construction,
          doorStyle: base.doorStyle || cabinetSettings.doorStyle,
          doorOverlay: base.doorOverlay || cabinetSettings.doorOverlay,
          cabinetFinish: base.cabinetFinish || cabinetSettings.cabinetFinish,
          grainType: base.grainType || cabinetSettings.grainType,
          floorLevel: base.floorLevel || cabinetSettings.currentFloor
        };

        // Adjust position based on wall orientation
        // Wall cabinets are shallower, so position closer to wall
        const baseDepth = isVertical ? base.width : base.height;
        const depthDiff = baseDepth - wallCabDepth;

        if (rotation === 0) {
          // Back wall - wall cabinet flush with back, adjust width to match base
          wallCab.y = base.y;
          wallCab.height = wallCabDepth;
          wallCab.width = base.width;
        } else if (rotation === 90) {
          // Right wall - wall cabinet flush with right
          wallCab.x = base.x + depthDiff * pixelsPerFoot;
          wallCab.width = wallCabDepth;
          wallCab.height = base.height;
        } else if (rotation === 180) {
          // Front wall - wall cabinet flush with front
          wallCab.y = base.y + depthDiff * pixelsPerFoot;
          wallCab.height = wallCabDepth;
          wallCab.width = base.width;
        } else if (rotation === 270) {
          // Left wall - wall cabinet flush with left
          wallCab.x = base.x;
          wallCab.width = wallCabDepth;
          wallCab.height = base.height;
        }

        wallCabs.push(wallCab);
      });

      // Also generate wall cabinet fillers to match base fillers for continuity
      baseCabinets.forEach(base => {
        if (!base.isFiller) return;

        const rotation = base.rotation || 0;
        const isVertical = rotation === 90 || rotation === 270;
        const fillerWidth = isVertical ? base.height : base.width;
        const widthInches = Math.round(fillerWidth * 12);
        const baseDepth = isVertical ? base.width : base.height;
        const depthDiff = baseDepth - wallCabDepth;

        const wallFiller = {
          type: 'wall-cabinet',
          x: base.x,
          y: base.y,
          width: base.width,
          height: wallCabDepth,
          rotation: rotation,
          color: '#654321',
          label: `Wall Filler ${widthInches}"`,
          id: generateId(),
          isFiller: true,
          roomId: currentRoom,
          construction: base.construction || cabinetSettings.construction,
          doorStyle: 'flat',
          doorOverlay: base.doorOverlay || cabinetSettings.doorOverlay,
          cabinetFinish: base.cabinetFinish || cabinetSettings.cabinetFinish,
          grainType: base.grainType || cabinetSettings.grainType,
          floorLevel: base.floorLevel || cabinetSettings.currentFloor
        };

        // Adjust position based on rotation
        if (rotation === 0) {
          wallFiller.height = wallCabDepth;
          wallFiller.width = base.width;
        } else if (rotation === 90) {
          wallFiller.x = base.x + depthDiff * pixelsPerFoot;
          wallFiller.width = wallCabDepth;
          wallFiller.height = base.height;
        } else if (rotation === 180) {
          wallFiller.y = base.y + depthDiff * pixelsPerFoot;
          wallFiller.height = wallCabDepth;
          wallFiller.width = base.width;
        } else if (rotation === 270) {
          wallFiller.width = wallCabDepth;
          wallFiller.height = base.height;
        }

        wallCabs.push(wallFiller);
      });

      return wallCabs;
    }

    // Generate elements along a path of orthogonal points
    // Handles corners properly with corner cabinets or fillers
    function generateCabinetsAlongPath(points) {
      try {
        if (!points || points.length < 2) return [];

        const elements = [];
        // Standard cabinet widths (in feet): 36", 33", 30", 27", 24", 21", 18", 15", 12", 9"
        const cabinetWidths = layoutMode.standardWidths || [3, 2.75, 2.5, 2.25, 2, 1.75, 1.5, 1.25, 1, 0.75];
        // Filler widths for small gaps (in feet): 6", 3"
        const fillerWidths = layoutMode.fillerWidths || [0.5, 0.25];
        const depth = layoutMode.cabinetDepth || 2;
        const elType = layoutMode.cabinetType || 'base-cabinet';
        const cornerSize = 3; // 36" corner cabinet
        let globalIndex = 0;

      // Get color and label prefix based on element type
      function getElementStyle(type, widthInches) {
        const styles = {
          'base-cabinet': { color: '#8B4513', label: `Base ${widthInches}"` },
          'drawer-base': { color: '#8B5A2B', label: `Drawer ${widthInches}"` },
          'sink-base': { color: '#6B4423', label: `Sink Base ${widthInches}"` },
          'corner-cabinet': { color: '#A0522D', label: 'Corner 36"' },
          'lazy-susan': { color: '#A0522D', label: 'Lazy Susan' },
          'wall-cabinet': { color: '#D2691E', label: `Wall ${widthInches}"` },
          'tall-cabinet': { color: '#5D4037', label: `Tall ${widthInches}"` },
          'pony-wall': { color: '#9E9E9E', label: 'Pony Wall' },
          'knee-wall': { color: '#757575', label: 'Knee Wall' },
          'wall': { color: '#616161', label: 'Wall' },
          'countertop': { color: '#2F4F4F', label: 'Counter' },
          'backsplash': { color: '#708090', label: 'Backsplash' }
        };
        return styles[type] || { color: '#8B4513', label: `${widthInches}"` };
      }

      // Analyze corners - find where we need corner cabinets
      const corners = [];
      for (let i = 1; i < points.length - 1; i++) {
        const prev = points[i - 1];
        const curr = points[i];
        const next = points[i + 1];

        // Determine directions
        const dir1Horiz = Math.abs(curr.x - prev.x) > Math.abs(curr.y - prev.y);
        const dir2Horiz = Math.abs(next.x - curr.x) > Math.abs(next.y - curr.y);

        // If direction changes, it's a corner
        if (dir1Horiz !== dir2Horiz) {
          // Determine corner type based on which quadrant it opens to
          const fromRight = prev.x > curr.x;
          const fromLeft = prev.x < curr.x;
          const fromTop = prev.y < curr.y;
          const fromBottom = prev.y > curr.y;
          const toRight = next.x > curr.x;
          const toLeft = next.x < curr.x;
          const toTop = next.y < curr.y;
          const toBottom = next.y > curr.y;

          corners.push({
            index: i,
            point: curr,
            fromHoriz: dir1Horiz,
            // Determine which way the corner "opens" (where the toe kick faces)
            opensRight: (fromTop && toRight) || (fromBottom && toRight) || (fromLeft && toBottom) || (fromLeft && toTop),
            opensLeft: (fromTop && toLeft) || (fromBottom && toLeft) || (fromRight && toBottom) || (fromRight && toTop),
            opensUp: (fromLeft && toTop) || (fromRight && toTop),
            opensDown: (fromLeft && toBottom) || (fromRight && toBottom)
          });
        }
      }

      // For walls and continuous elements, create one element for the whole segment
      const isContinuous = ['wall', 'pony-wall', 'knee-wall', 'countertop', 'backsplash'].includes(elType);
      const isCabinet = ['base-cabinet', 'drawer-base', 'sink-base', 'wall-cabinet', 'tall-cabinet', 'corner-cabinet',
                         'lazy-susan', 'blind-corner', 'island', 'microwave-cabinet', 'above-microwave-cabinet',
                         'fridge-cabinet', 'single-oven-cabinet', 'tall-oven', 'double-oven-cabinet', 'laundry-cabinet'].includes(elType);

      // Process each segment
      for (let segIdx = 0; segIdx < points.length - 1; segIdx++) {
        const p1 = points[segIdx];
        const p2 = points[segIdx + 1];

        // Check if this segment starts or ends at a corner
        const startsAtCorner = corners.find(c => c.index === segIdx);
        const endsAtCorner = corners.find(c => c.index === segIdx + 1);

        // Determine if segment is horizontal or vertical
        const isHorizontal = Math.abs(p2.x - p1.x) > Math.abs(p2.y - p1.y);

        // Calculate run direction and bounds
        const goingRight = p2.x > p1.x;
        const goingDown = p2.y > p1.y;

        // Calculate run length
        let runLength = isHorizontal ? Math.abs(p2.x - p1.x) : Math.abs(p2.y - p1.y);

        // Adjust for corner cabinets at each end
        let startOffset = 0;
        let endOffset = 0;

        if (isCabinet && startsAtCorner) {
          startOffset = cornerSize - depth; // Leave room for corner cabinet
        }
        if (isCabinet && endsAtCorner) {
          endOffset = cornerSize - depth;
        }

        const effectiveLength = runLength - startOffset - endOffset;
        if (effectiveLength < 0.5) continue;

        // Starting position
        let startX, startY;
        if (isHorizontal) {
          startX = goingRight ? p1.x + startOffset : p2.x + endOffset;
          startY = p1.y;
        } else {
          startX = p1.x;
          startY = goingDown ? p1.y + startOffset : p2.y + endOffset;
        }

        if (isContinuous) {
          // Single continuous element
          const style = getElementStyle(elType, Math.round(effectiveLength * 12));
          const el = {
            id: 'el-' + Date.now() + '-' + globalIndex++,
            type: elType,
            x: isHorizontal ? startX * pixelsPerFoot : (startX - depth / 2) * pixelsPerFoot,
            y: isHorizontal ? (startY - depth / 2) * pixelsPerFoot : startY * pixelsPerFoot,
            width: isHorizontal ? effectiveLength : depth,
            height: isHorizontal ? depth : effectiveLength,
            rotation: 0,
            color: style.color,
            label: style.label,
            roomId: currentRoom,
            // Cabinet settings from global settings
            construction: isCabinet ? cabinetSettings.construction : undefined,
            doorStyle: isCabinet ? cabinetSettings.doorStyle : undefined,
            doorOverlay: isCabinet ? cabinetSettings.doorOverlay : undefined,
            cabinetFinish: isCabinet ? cabinetSettings.cabinetFinish : undefined,
            grainType: isCabinet ? cabinetSettings.grainType : undefined,
            floorLevel: cabinetSettings.currentFloor
          };
          elements.push(el);
        } else {
          // Fill with individual cabinets using standard sizes
          // Smart algorithm: try to fill optimally with standard widths, use fillers for gaps
          let filled = 0;
          const minCabinetWidth = cabinetWidths[cabinetWidths.length - 1]; // 9" = 0.75ft
          const minFillerWidth = fillerWidths[fillerWidths.length - 1]; // 3" = 0.25ft

          // Calculate optimal cabinet arrangement
          function findBestCabinetWidth(remaining) {
            // Try each standard width
            for (const w of cabinetWidths) {
              if (w <= remaining + 0.02) {
                // Check if the leftover can be filled with another cabinet or filler
                const leftover = remaining - w;
                if (leftover < 0.02) return w; // Perfect fit
                if (leftover >= minCabinetWidth) return w; // Can fit another cabinet
                // Check if leftover fits a filler
                for (const fw of fillerWidths) {
                  if (Math.abs(leftover - fw) < 0.02) return w; // Exact filler fit
                }
                // Try smaller cabinet to see if combo works better
                continue;
              }
            }
            // Return smallest that fits
            for (let i = cabinetWidths.length - 1; i >= 0; i--) {
              if (cabinetWidths[i] <= remaining + 0.02) return cabinetWidths[i];
            }
            return null; // Need a filler instead
          }

          while (filled < effectiveLength - 0.02) {
            const remaining = effectiveLength - filled;

            // Try to fit a standard cabinet
            let bestWidth = findBestCabinetWidth(remaining);
            let isFiller = false;

            if (bestWidth === null || remaining < minCabinetWidth) {
              // Need a filler piece for the gap
              // Find best filler size
              isFiller = true;
              bestWidth = null;
              for (const fw of fillerWidths) {
                if (fw <= remaining + 0.02) {
                  bestWidth = fw;
                  break;
                }
              }
              // If even smallest filler is too big, use remaining width as custom filler
              if (bestWidth === null) {
                bestWidth = remaining;
              }
            }

            // Calculate position with proper orientation
            // Toe kick should face outward (into the room)
            let elX, elY, rotation = 0;

            if (isHorizontal) {
              elX = (startX + filled) * pixelsPerFoot;
              elY = (startY - depth / 2) * pixelsPerFoot;
              // No rotation needed for horizontal runs
            } else {
              elX = (startX - depth / 2) * pixelsPerFoot;
              elY = (startY + filled) * pixelsPerFoot;
              // No rotation - width/height swap handles orientation
            }

            const widthInches = Math.round(bestWidth * 12);
            let style, currentType;

            if (isFiller) {
              // Create a filler piece
              style = { color: '#654321', label: `Filler ${widthInches}"` };
              currentType = 'filler';
            } else {
              style = getElementStyle(elType, widthInches);
              currentType = elType;
            }

            const el = {
              id: 'el-' + Date.now() + '-' + globalIndex++,
              type: isFiller ? 'base-cabinet' : elType, // Fillers are rendered as slim cabinets
              x: elX,
              y: elY,
              width: isHorizontal ? bestWidth : depth,
              height: isHorizontal ? depth : bestWidth,
              rotation: rotation,
              color: style.color,
              label: style.label,
              isFiller: isFiller,
              roomId: currentRoom,
              // Cabinet settings from global settings
              construction: isCabinet ? cabinetSettings.construction : undefined,
              doorStyle: isFiller ? 'flat' : (isCabinet ? cabinetSettings.doorStyle : undefined),
              doorOverlay: isCabinet ? cabinetSettings.doorOverlay : undefined,
              cabinetFinish: isCabinet ? cabinetSettings.cabinetFinish : undefined,
              grainType: isCabinet ? cabinetSettings.grainType : undefined,
              floorLevel: cabinetSettings.currentFloor
            };

            // Auto-detect wall orientation and set proper rotation
            // so cabinet fronts face into the room
            const wallInfo = getWallOrientation(el);
            if (!wallInfo.isIsland && isCabinet) {
              el.rotation = wallInfo.rotation;
            }

            elements.push(el);
            filled += bestWidth;
          }
        }

        // Add corner element at end of this segment if there's a corner
        if (isCabinet && endsAtCorner && layoutMode.cornerType !== 'none') {
          const corner = endsAtCorner;
          const cornerPoint = corner.point;

          // Position corner element at the corner junction
          const cornerX = (cornerPoint.x - cornerSize / 2) * pixelsPerFoot;
          const cornerY = (cornerPoint.y - cornerSize / 2) * pixelsPerFoot;

          // Determine corner element based on setting
          let cornerElType = layoutMode.cornerType;
          let cornerLabel = 'Corner 36"';
          let cornerColor = '#A0522D';

          if (cornerElType === 'lazy-susan') {
            cornerLabel = 'Lazy Susan';
            cornerColor = '#8B6914';
          } else if (cornerElType === 'blind-corner') {
            cornerLabel = 'Blind Corner';
            cornerColor = '#7B5513';
          } else if (cornerElType === 'filler') {
            cornerLabel = 'Filler';
            cornerColor = '#654321';
          }

          // Calculate corner cabinet rotation based on which room corner it's in
          // The L-shaped cabinet should have arms against the walls and door facing into room
          // Default model has arms at -X (left) and -Z (back), door faces +X,+Z (front-right)
          let cornerRotation = 0;
          const cornerWorldX = cornerPoint.x;
          const cornerWorldY = cornerPoint.y;
          const nearBackWall = cornerWorldY < roomDepth / 2;
          const nearLeftWall = cornerWorldX < roomWidth / 2;

          if (nearBackWall && nearLeftWall) {
            // Back-left corner: door faces front-right (+X, +Z into room)
            cornerRotation = 0;
          } else if (nearBackWall && !nearLeftWall) {
            // Back-right corner: door faces front-left (-X, +Z into room)
            cornerRotation = 90;
          } else if (!nearBackWall && nearLeftWall) {
            // Front-left corner: door faces back-right (+X, -Z into room)
            cornerRotation = 270;
          } else {
            // Front-right corner: door faces back-left (-X, -Z into room)
            cornerRotation = 180;
          }

          const cornerEl = {
            id: 'el-' + Date.now() + '-corner-' + corner.index,
            type: cornerElType === 'filler' ? 'base-cabinet' : cornerElType,
            x: cornerX,
            y: cornerY,
            width: cornerSize,
            height: cornerSize,
            rotation: cornerRotation,
            color: cornerColor,
            label: cornerLabel,
            isCorner: true,
            roomId: currentRoom,
            // Cabinet settings from global settings
            construction: cabinetSettings.construction,
            doorStyle: cabinetSettings.doorStyle,
            doorOverlay: cabinetSettings.doorOverlay,
            cabinetFinish: cabinetSettings.cabinetFinish,
            grainType: cabinetSettings.grainType,
            floorLevel: cabinetSettings.currentFloor
          };

          // Only add if we haven't already added this corner
          if (!elements.find(e => e.isCorner && Math.abs(e.x - cornerX) < 10 && Math.abs(e.y - cornerY) < 10)) {
            elements.push(cornerEl);
          }
        }
      }

      return elements;
      } catch (err) {
        console.error('generateCabinetsAlongPath error:', err);
        return [];
      }
    }

    // Generate countertop to cover cabinet run
    function generateCountertopForRun(cabinets) {
      if (!cabinets || cabinets.length === 0) return null;

      // Find bounding box of all cabinets
      let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;

      cabinets.forEach(cab => {
        minX = Math.min(minX, cab.x);
        minY = Math.min(minY, cab.y);
        maxX = Math.max(maxX, cab.x + cab.width * pixelsPerFoot);
        maxY = Math.max(maxY, cab.y + cab.height * pixelsPerFoot);
      });

      // Add overhang (1.5" = 0.125 ft)
      const overhang = 0.125 * pixelsPerFoot;

      return {
        id: 'el-' + Date.now() + '-counter',
        type: 'countertop',
        x: minX - overhang,
        y: minY - overhang,
        width: (maxX - minX + overhang * 2) / pixelsPerFoot,
        height: (maxY - minY + overhang * 2) / pixelsPerFoot,
        rotation: 0,
        color: '#2F4F4F',
        label: 'Countertop',
        material: 'granite',
        roomId: currentRoom,
        edgeProfile: 'eased'
      };
    }

    // Draw the layout tool preview on canvas - drafting style
    function drawLayoutToolPreview() {
      try {
        if (currentTool !== 'layout') return;
        if (!layoutMode.isDrawing && (!layoutMode.corners || layoutMode.corners.length === 0)) return;

      // Build the complete path including current endpoint
      const allPoints = [...layoutMode.corners];
      if (layoutMode.isDrawing && layoutMode.currentEnd) {
        allPoints.push(layoutMode.currentEnd);
      }

      if (allPoints.length === 0) return;

      const depth = layoutMode.cabinetDepth;

      // Draw the center line path (straight orthogonal lines)
      ctx.strokeStyle = '#FF9800';
      ctx.lineWidth = 3;
      ctx.lineCap = 'square';
      ctx.lineJoin = 'miter';
      ctx.setLineDash([]);

      ctx.beginPath();
      allPoints.forEach((p, i) => {
        const screenX = p.x * pixelsPerFoot;
        const screenY = p.y * pixelsPerFoot;
        if (i === 0) {
          ctx.moveTo(screenX, screenY);
        } else {
          ctx.lineTo(screenX, screenY);
        }
      });
      ctx.stroke();

      // Draw cabinet outline preview for each segment
      ctx.strokeStyle = 'rgba(139, 69, 19, 0.9)';
      ctx.fillStyle = 'rgba(139, 69, 19, 0.25)';
      ctx.lineWidth = 2;

      for (let i = 0; i < allPoints.length - 1; i++) {
        const p1 = allPoints[i];
        const p2 = allPoints[i + 1];

        // Determine if horizontal or vertical segment
        const isHorizontal = Math.abs(p2.x - p1.x) > Math.abs(p2.y - p1.y);

        let rect;
        if (isHorizontal) {
          // Horizontal run - depth goes up/down
          const minX = Math.min(p1.x, p2.x);
          const maxX = Math.max(p1.x, p2.x);
          rect = {
            x: minX * pixelsPerFoot,
            y: (p1.y - depth / 2) * pixelsPerFoot,
            w: (maxX - minX) * pixelsPerFoot,
            h: depth * pixelsPerFoot
          };
        } else {
          // Vertical run - depth goes left/right
          const minY = Math.min(p1.y, p2.y);
          const maxY = Math.max(p1.y, p2.y);
          rect = {
            x: (p1.x - depth / 2) * pixelsPerFoot,
            y: minY * pixelsPerFoot,
            w: depth * pixelsPerFoot,
            h: (maxY - minY) * pixelsPerFoot
          };
        }

        // Draw the cabinet rectangle
        ctx.fillRect(rect.x, rect.y, rect.w, rect.h);
        ctx.strokeRect(rect.x, rect.y, rect.w, rect.h);

        // Draw dimension label for this segment
        const segmentLength = isHorizontal ?
          Math.abs(p2.x - p1.x) :
          Math.abs(p2.y - p1.y);

        if (segmentLength >= 1) {
          const midX = ((p1.x + p2.x) / 2) * pixelsPerFoot;
          const midY = ((p1.y + p2.y) / 2) * pixelsPerFoot;

          ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
          ctx.font = 'bold 11px Inter';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';

          // Background for text
          const dimText = formatDimension(segmentLength);
          const textMetrics = ctx.measureText(dimText);
          ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
          ctx.fillRect(midX - textMetrics.width / 2 - 4, midY - 8, textMetrics.width + 8, 16);

          ctx.fillStyle = '#fff';
          ctx.fillText(dimText, midX, midY);
        }

        // Reset fill for next iteration
        ctx.fillStyle = 'rgba(139, 69, 19, 0.25)';
      }

      // Draw corner markers
      allPoints.forEach((p, i) => {
        const screenX = p.x * pixelsPerFoot;
        const screenY = p.y * pixelsPerFoot;

        // Corner square
        ctx.fillStyle = i === 0 ? '#4CAF50' : (i === allPoints.length - 1 && layoutMode.isDrawing ? '#FF5722' : '#2196F3');
        ctx.fillRect(screenX - 6, screenY - 6, 12, 12);

        // Corner border
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.strokeRect(screenX - 6, screenY - 6, 12, 12);

        // Corner number
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 10px Inter';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(i === 0 ? 'S' : (i === allPoints.length - 1 ? 'E' : String(i)), screenX, screenY);
      });

      // Draw direction indicator at current end
      if (layoutMode.isDrawing && layoutMode.currentDirection) {
        const endPoint = allPoints[allPoints.length - 1];
        const endX = endPoint.x * pixelsPerFoot;
        const endY = endPoint.y * pixelsPerFoot;

        ctx.strokeStyle = '#FF9800';
        ctx.lineWidth = 2;
        ctx.setLineDash([4, 4]);

        // Show constraint direction
        ctx.beginPath();
        if (layoutMode.currentDirection === 'horizontal') {
          ctx.moveTo(endX - 30, endY);
          ctx.lineTo(endX + 30, endY);
        } else {
          ctx.moveTo(endX, endY - 30);
          ctx.lineTo(endX, endY + 30);
        }
        ctx.stroke();
        ctx.setLineDash([]);
      }

      // Instructions overlay
      ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
      const boxHeight = layoutMode.isDrawing ? 65 : 45;
      ctx.fillRect(10, 10, 300, boxHeight);

      ctx.fillStyle = '#fff';
      ctx.font = '12px Inter';
      ctx.textAlign = 'left';

      if (layoutMode.isDrawing) {
        ctx.fillText(' Drafting cabinet run...', 20, 28);
        const dirText = layoutMode.currentDirection ?
          `Direction: ${layoutMode.currentDirection.toUpperCase()}` :
          'Move to set direction';
        ctx.fillText(dirText, 20, 44);
        ctx.fillText('Turn: move perpendicular  Release: place', 20, 60);
      } else {
        ctx.fillText(' Layout Tool - Click & drag to draw', 20, 28);
        ctx.fillText('Straight lines snap to H/V  Auto-turns at corners', 20, 44);
      }
      } catch (err) {
        console.error('drawLayoutToolPreview error:', err);
        // Don't break the draw loop - just skip the preview
      }
    }

    // Fill room with flooring
    function fillRoomWithFlooring() {
      // Check if flooring already exists
      const existingFlooring = elements.find(el => el.type === 'flooring' && el.width >= roomWidth * 0.9 && el.height >= roomDepth * 0.9);
      if (existingFlooring) {
        // Select existing flooring so user can modify it
        selectedElement = existingFlooring;
        updateProperties();
        showSnapFeedback('Room already has flooring - selected for editing');
        draw();
        return;
      }

      // Create flooring that fills the entire room
      const flooring = {
        id: 'floor-' + Date.now(),
        type: 'flooring',
        x: 0,
        y: 0,
        width: roomWidth,
        height: roomDepth,
        color: '#D2B48C',
        label: 'Room Flooring',
        rotation: 0,
        locked: false,
        roomId: currentRoom,
        grainDirection: 0, // 0 = horizontal, 90 = vertical
        floorLevel: cabinetSettings.currentFloor || 1,
        zIndexOffset: -100 // Keep flooring behind other elements
      };

      // Find flooring color from ELEMENT_TYPES
      const flooringDef = ELEMENT_TYPES.surfaces?.find(e => e.type === 'flooring');
      if (flooringDef) {
        flooring.color = flooringDef.color;
      }

      elements.push(flooring);
      selectedElement = flooring;
      updateProperties();
      saveUndoState();
      draw();
      update3DScene();
      showSnapFeedback('Flooring added - select material in properties');
    }

    // Auto-generate countertops over base cabinets and wall caps over walls
    function generateCountertopsOverCabinets() {
      // Types that can receive countertops/caps
      const baseCabinetTypes = ['base-cabinet', 'drawer-base', 'sink-base', 'corner-cabinet', 'lazy-susan', 'island'];
      const wallTypes = ['pony-wall', 'pony-wall-bar', 'knee-wall', 'wall', 'wall-block', 'wall-concrete', 'wall-brick'];

      const baseCabinets = elements.filter(el => baseCabinetTypes.includes(el.type));
      const capableWalls = elements.filter(el => wallTypes.includes(el.type) &&
        // Only half-height walls get caps (not full walls unless selected)
        (['pony-wall', 'pony-wall-bar', 'knee-wall'].includes(el.type) ||
         (el === selectedElement && wallTypes.includes(el.type)))
      );

      if (baseCabinets.length === 0 && capableWalls.length === 0) {
        showSnapFeedback('No base cabinets or walls found to cover');
        return;
      }

      // Also generate caps for walls
      let wallCapsCreated = generateWallCaps(capableWalls);

      // Group cabinets by their Y position (row) - with 0.5ft tolerance
      const rows = [];
      baseCabinets.forEach(cab => {
        const cabCenterY = cab.y + (cab.height * pixelsPerFoot) / 2;
        let foundRow = rows.find(row => Math.abs(row.y - cabCenterY) < pixelsPerFoot * 0.5);
        if (foundRow) {
          foundRow.cabinets.push(cab);
        } else {
          rows.push({ y: cabCenterY, cabinets: [cab] });
        }
      });

      let countersCreated = 0;

      rows.forEach(row => {
        // Sort cabinets by X position
        row.cabinets.sort((a, b) => a.x - b.x);

        // Find contiguous runs of cabinets
        const runs = [];
        let currentRun = [row.cabinets[0]];

        for (let i = 1; i < row.cabinets.length; i++) {
          const prev = row.cabinets[i - 1];
          const curr = row.cabinets[i];
          const prevRight = prev.x + prev.width * pixelsPerFoot;
          const currLeft = curr.x;
          const gap = currLeft - prevRight;

          // If gap is small (< 6 inches), consider them adjacent
          if (gap < pixelsPerFoot * 0.5) {
            currentRun.push(curr);
          } else {
            runs.push(currentRun);
            currentRun = [curr];
          }
        }
        runs.push(currentRun);

        // Create a countertop for each run
        runs.forEach(run => {
          const leftCab = run[0];
          const rightCab = run[run.length - 1];

          // Calculate bounds with 1.5" overhang
          const overhang = 0.125; // 1.5 inches in feet
          const leftX = leftCab.x / pixelsPerFoot - overhang;
          const rightX = (rightCab.x + rightCab.width * pixelsPerFoot) / pixelsPerFoot + overhang;

          // Find the max depth in the run
          let maxDepth = 0;
          let frontY = Infinity;
          run.forEach(cab => {
            maxDepth = Math.max(maxDepth, cab.height);
            frontY = Math.min(frontY, cab.y / pixelsPerFoot);
          });

          // Countertop positioned to align with cabinet fronts with overhang
          const counterWidth = rightX - leftX;
          const counterDepth = maxDepth + overhang * 2;
          const counterY = frontY - overhang;

          // Check if countertop already exists at this location
          const existingCounter = elements.find(el =>
            el.type === 'countertop' &&
            Math.abs(el.x / pixelsPerFoot - leftX) < 0.5 &&
            Math.abs(el.y / pixelsPerFoot - counterY) < 0.5 &&
            Math.abs(el.width - counterWidth) < 0.5
          );

          if (!existingCounter) {
            const counter = {
              id: Date.now() + Math.random(),
              type: 'countertop',
              x: leftX * pixelsPerFoot,
              y: counterY * pixelsPerFoot,
              width: counterWidth,
              height: counterDepth,
              color: '#708090',
              rotation: 0,
              roomId: currentRoom,
              edgeProfile: 'eased',
              finishedEnds: ['left', 'right']
            };
            elements.push(counter);
            countersCreated++;
          }
        });
      });

      const totalCreated = countersCreated + wallCapsCreated;
      if (totalCreated > 0) {
        saveUndoState();
        draw();
        update3DScene();
        let msg = '';
        if (countersCreated > 0) msg += `${countersCreated} countertop${countersCreated > 1 ? 's' : ''}`;
        if (wallCapsCreated > 0) {
          if (msg) msg += ', ';
          msg += `${wallCapsCreated} wall cap${wallCapsCreated > 1 ? 's' : ''}`;
        }
        showSnapFeedback(`Generated ${msg}`);
      } else {
        showSnapFeedback('Countertops/caps already exist');
      }
    }

    // Generate wall caps over pony walls, knee walls, bar walls, etc.
    function generateWallCaps(walls) {
      if (!walls || walls.length === 0) return 0;

      let capsCreated = 0;
      const overhang = 0.0833; // 1 inch overhang in feet
      const capThickness = 0.125; // 1.5" cap thickness in feet

      walls.forEach(wall => {
        // Get wall dimensions and position
        const wallX = wall.x / pixelsPerFoot;
        const wallY = wall.y / pixelsPerFoot;
        const wallW = wall.width;
        const wallD = wall.height;
        const rotation = wall.rotation || 0;

        // Check if cap already exists at this location
        const existingCap = elements.find(el =>
          (el.type === 'wall-cap' || el.type === 'countertop' || el.type === 'bar-top') &&
          Math.abs(el.x / pixelsPerFoot - (wallX - overhang)) < 0.3 &&
          Math.abs(el.y / pixelsPerFoot - (wallY - overhang)) < 0.3 &&
          Math.abs(el.width - (wallW + overhang * 2)) < 0.3
        );

        if (!existingCap) {
          // Determine cap type based on wall type
          let capType = 'wall-cap';
          let capColor = '#708090';
          if (wall.type === 'pony-wall-bar') {
            capType = 'bar-top';
            capColor = '#8B4513';
          }

          // Get wall height for positioning the cap in 3D
          const wallHeight = wall.wallHeight || (wall.type === 'knee-wall' ? 2 : 3.5);

          const cap = {
            id: Date.now() + Math.random() + capsCreated,
            type: capType,
            x: (wallX - overhang) * pixelsPerFoot,
            y: (wallY - overhang) * pixelsPerFoot,
            width: wallW + overhang * 2,
            height: wallD + overhang * 2,
            color: capColor,
            rotation: rotation,
            roomId: currentRoom,
            edgeProfile: 'eased',
            finishedEnds: ['left', 'right', 'front', 'back'],
            capHeight: wallHeight,          // Height where cap sits
            thickness: capThickness,        // Cap thickness
            parentWallId: wall.id           // Link to parent wall
          };
          elements.push(cap);
          capsCreated++;
        }
      });

      return capsCreated;
    }

    // Generate cap/top for a single selected element (wall, cabinet, etc.)
    function generateCapForSelected() {
      if (!selectedElement) {
        showSnapFeedback('Select an element first');
        return;
      }

      const wallTypes = ['pony-wall', 'pony-wall-bar', 'knee-wall', 'wall', 'wall-block', 'wall-concrete', 'wall-brick'];
      const cabinetTypes = ['base-cabinet', 'drawer-base', 'sink-base', 'corner-cabinet', 'lazy-susan', 'island'];

      if (wallTypes.includes(selectedElement.type)) {
        const created = generateWallCaps([selectedElement]);
        if (created > 0) {
          saveUndoState();
          draw();
          update3DScene();
          showSnapFeedback('Wall cap added');
        } else {
          showSnapFeedback('Cap already exists on this wall');
        }
      } else if (cabinetTypes.includes(selectedElement.type)) {
        // Generate countertop just for this cabinet
        const counter = generateCountertopForRun([selectedElement]);
        if (counter) {
          elements.push(counter);
          saveUndoState();
          draw();
          update3DScene();
          showSnapFeedback('Countertop added');
        }
      } else {
        showSnapFeedback('Select a wall or cabinet first');
      }
    }

    // Alignment menu for selected elements
    function showAlignMenu() {
      // Create a simple dropdown menu for alignment options
      const menu = document.createElement('div');
      menu.id = 'alignMenu';
      menu.className = 'context-menu';
      menu.style.cssText = `
        position: fixed;
        background: rgba(30, 30, 40, 0.95);
        backdrop-filter: blur(20px);
        -webkit-backdrop-filter: blur(20px);
        border: 1px solid rgba(255, 255, 255, 0.15);
        border-radius: 12px;
        padding: 8px 0;
        box-shadow: 0 8px 32px rgba(0,0,0,0.5);
        z-index: 9999;
        min-width: 180px;
      `;

      const options = [
        { label: 'Align Left', icon: '', action: () => alignElements('left') },
        { label: 'Align Center', icon: '', action: () => alignElements('center') },
        { label: 'Align Right', icon: '', action: () => alignElements('right') },
        { label: 'Align Top', icon: '', action: () => alignElements('top') },
        { label: 'Align Middle', icon: '', action: () => alignElements('middle') },
        { label: 'Align Bottom', icon: '', action: () => alignElements('bottom') },
        { divider: true },
        { label: 'Distribute Horizontal', icon: '', action: () => distributeElements('horizontal') },
        { label: 'Distribute Vertical', icon: '', action: () => distributeElements('vertical') },
        { divider: true },
        { label: 'Snap to Wall', icon: '', action: () => snapSelectionToWall() }
      ];

      options.forEach(opt => {
        if (opt.divider) {
          const div = document.createElement('div');
          div.style.cssText = 'height: 1px; background: rgba(255, 255, 255, 0.1); margin: 6px 8px;';
          menu.appendChild(div);
        } else {
          const item = document.createElement('div');
          item.style.cssText = `
            padding: 10px 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 13px;
            color: #e0e0e0;
            transition: all 0.15s ease;
            margin: 2px 6px;
            border-radius: 6px;
          `;
          item.innerHTML = `<span style="width: 18px; text-align: center; font-size: 14px;">${opt.icon}</span>${opt.label}`;
          item.onmouseenter = () => {
            item.style.background = 'rgba(255, 255, 255, 0.1)';
            item.style.color = '#ffffff';
          };
          item.onmouseleave = () => {
            item.style.background = 'transparent';
            item.style.color = '#e0e0e0';
          };
          item.onclick = () => {
            opt.action();
            menu.remove();
          };
          menu.appendChild(item);
        }
      });

      // Position near the Align button
      const btn = document.getElementById('toolAlign');
      const rect = btn.getBoundingClientRect();
      menu.style.left = rect.right + 5 + 'px';
      menu.style.top = rect.top + 'px';

      document.body.appendChild(menu);

      // Close on click outside
      setTimeout(() => {
        document.addEventListener('click', function closeMenu(e) {
          if (!menu.contains(e.target)) {
            menu.remove();
            document.removeEventListener('click', closeMenu);
          }
        });
      }, 10);
    }

    // Align multiple selected elements (or all cabinets if none selected)
    function alignElements(alignment) {
      const cabinetTypes = ['base-cabinet', 'wall-cabinet', 'tall-cabinet', 'corner-cabinet', 'drawer-base', 'sink-base', 'lazy-susan', 'island'];
      const targets = elements.filter(el => cabinetTypes.includes(el.type));

      if (targets.length < 2) {
        showSnapFeedback('Need at least 2 cabinets to align');
        return;
      }

      // Find the reference point based on alignment
      let refValue;
      switch (alignment) {
        case 'left':
          refValue = Math.min(...targets.map(el => el.x));
          targets.forEach(el => el.x = refValue);
          break;
        case 'right':
          refValue = Math.max(...targets.map(el => el.x + el.width * pixelsPerFoot));
          targets.forEach(el => el.x = refValue - el.width * pixelsPerFoot);
          break;
        case 'center':
          const avgX = targets.reduce((sum, el) => sum + el.x + (el.width * pixelsPerFoot) / 2, 0) / targets.length;
          targets.forEach(el => el.x = avgX - (el.width * pixelsPerFoot) / 2);
          break;
        case 'top':
          refValue = Math.min(...targets.map(el => el.y));
          targets.forEach(el => el.y = refValue);
          break;
        case 'bottom':
          refValue = Math.max(...targets.map(el => el.y + el.height * pixelsPerFoot));
          targets.forEach(el => el.y = refValue - el.height * pixelsPerFoot);
          break;
        case 'middle':
          const avgY = targets.reduce((sum, el) => sum + el.y + (el.height * pixelsPerFoot) / 2, 0) / targets.length;
          targets.forEach(el => el.y = avgY - (el.height * pixelsPerFoot) / 2);
          break;
      }

      saveUndoState();
      draw();
      update3DScene();
      showSnapFeedback(`Aligned ${targets.length} elements`);
    }

    // Distribute elements evenly
    function distributeElements(direction) {
      const cabinetTypes = ['base-cabinet', 'wall-cabinet', 'tall-cabinet', 'corner-cabinet', 'drawer-base', 'sink-base', 'lazy-susan', 'island'];
      const targets = elements.filter(el => cabinetTypes.includes(el.type));

      if (targets.length < 3) {
        showSnapFeedback('Need at least 3 cabinets to distribute');
        return;
      }

      if (direction === 'horizontal') {
        targets.sort((a, b) => a.x - b.x);
        const first = targets[0];
        const last = targets[targets.length - 1];
        const totalWidth = targets.reduce((sum, el) => sum + el.width * pixelsPerFoot, 0);
        const availableSpace = (last.x + last.width * pixelsPerFoot) - first.x - totalWidth;
        const gap = availableSpace / (targets.length - 1);

        let currentX = first.x;
        targets.forEach(el => {
          el.x = currentX;
          currentX += el.width * pixelsPerFoot + gap;
        });
      } else {
        targets.sort((a, b) => a.y - b.y);
        const first = targets[0];
        const last = targets[targets.length - 1];
        const totalHeight = targets.reduce((sum, el) => sum + el.height * pixelsPerFoot, 0);
        const availableSpace = (last.y + last.height * pixelsPerFoot) - first.y - totalHeight;
        const gap = availableSpace / (targets.length - 1);

        let currentY = first.y;
        targets.forEach(el => {
          el.y = currentY;
          currentY += el.height * pixelsPerFoot + gap;
        });
      }

      saveUndoState();
      draw();
      update3DScene();
      showSnapFeedback(`Distributed ${targets.length} elements ${direction}ly`);
    }

    // Snap selection to nearest wall
    function snapSelectionToWall() {
      if (!selectedElement) {
        showSnapFeedback('Select an element first');
        return;
      }

      const el = selectedElement;
      const elLeft = el.x / pixelsPerFoot;
      const elRight = elLeft + el.width;
      const elTop = el.y / pixelsPerFoot;
      const elBottom = elTop + el.height;

      // Check distances to room walls
      const distToLeft = elLeft;
      const distToRight = roomWidth - elRight;
      const distToTop = elTop;
      const distToBottom = roomDepth - elBottom;

      // Find minimum distance
      const min = Math.min(distToLeft, distToRight, distToTop, distToBottom);

      if (min === distToLeft) {
        el.x = 0;
      } else if (min === distToRight) {
        el.x = (roomWidth - el.width) * pixelsPerFoot;
      } else if (min === distToTop) {
        el.y = 0;
      } else {
        el.y = (roomDepth - el.height) * pixelsPerFoot;
      }

      saveUndoState();
      draw();
      update3DScene();
      showSnapFeedback('Snapped to wall');
    }

    function toggleSection(header) {
      // Find the sidebar-content, skipping over any tooltip elements
      const section = header.parentElement;
      const content = section.querySelector('.sidebar-content');
      const toggle = header.querySelector('.sidebar-toggle');
      if (content) {
        const isCollapsing = !content.classList.contains('collapsed');
        content.classList.toggle('collapsed');
        section.classList.toggle('expanded', !isCollapsing);
        toggle.textContent = isCollapsing ? '' : '';
      }
    }

    function togglePanelSectionOld(header) {
      // Toggle collapsible panel sections in the right panel (legacy)
      const section = header.parentElement;
      const content = section.querySelector('.panel-content');
      const toggle = header.querySelector('.panel-toggle');
      if (content) {
        content.classList.toggle('collapsed');
        toggle.textContent = content.classList.contains('collapsed') ? '' : '';
      }
    }

    // ===== VIEW =====
    function setView(view) {
      currentView = view;
      document.getElementById('view2D').classList.toggle('active', view === '2d');
      document.getElementById('view3D').classList.toggle('active', view === '3d');

      const canvasWrapper = document.getElementById('canvasWrapper');
      const threeContainer = document.getElementById('three-container');

      // Cancel any existing animation when switching views
      if (animationId) {
        cancelAnimationFrame(animationId);
        animationId = null;
      }

      if (view === '3d') {
        canvasWrapper.style.display = 'none';
        threeContainer.classList.add('active');

        // Wait for layout to compute before initializing 3D
        // This ensures container has proper dimensions
        requestAnimationFrame(() => {
          init3D();

          // Update renderer size in case container size changed
          if (renderer) {
            const w = threeContainer.clientWidth || window.innerWidth * 0.6;
            const h = threeContainer.clientHeight || window.innerHeight - 150;
            if (w > 0 && h > 0) {
              renderer.setSize(w, h);
              camera.aspect = w / h;
              camera.updateProjectionMatrix();
            }
          }

          render3D();
        });
      } else {
        // Cleanup 3D resources when switching to 2D
        cleanup3D();
        canvasWrapper.style.display = 'block';
        threeContainer.classList.remove('active');
        // Redraw 2D canvas after switching from 3D
        requestAnimationFrame(() => draw());
      }
    }

    // Helper function to check if 3D mode is active
    function get3DMode() {
      return currentView === '3d';
    }

    // Expose is3DMode as a getter
    Object.defineProperty(window, 'is3DMode', {
      get: function() { return currentView === '3d'; }
    });

    // Toggle between 2D and 3D views
    function toggle3DView() {
      if (currentView === '3d') {
        setView('2d');
      } else {
        setView('3d');
      }
      // Update button text in review room if present
      const toggle3DBtn = document.getElementById('toggle3DBtn');
      if (toggle3DBtn) {
        toggle3DBtn.textContent = currentView === '3d' ? '2D View' : '3D View';
      }
    }

    // Alias for update3DScene - rebuilds the 3D scene with current elements
    function update3DScene() {
      if (currentView === '3d') {
        init3D();
        render3D();
      }
    }

    // ===== 3D VIEW =====
    function cleanup3D() {
      if (animationId) {
        cancelAnimationFrame(animationId);
        animationId = null;
      }

      if (scene) {
        // Dispose all objects in scene
        scene.traverse(obj => {
          if (obj.geometry) obj.geometry.dispose();
          if (obj.material) {
            if (Array.isArray(obj.material)) {
              obj.material.forEach(m => {
                // Dispose material textures
                if (m.map) m.map.dispose();
                if (m.normalMap) m.normalMap.dispose();
                if (m.roughnessMap) m.roughnessMap.dispose();
                m.dispose();
              });
            } else {
              // Dispose material textures
              if (obj.material.map) obj.material.map.dispose();
              if (obj.material.normalMap) obj.material.normalMap.dispose();
              if (obj.material.roughnessMap) obj.material.roughnessMap.dispose();
              obj.material.dispose();
            }
          }
        });
        scene.clear();
        scene = null;
      }

      // Clear texture cache to free memory (uses LRU cache cleanup)
      if (typeof clearTextureCache === 'function') {
        clearTextureCache();
      }

      // Clear geometry pool
      if (typeof clearGeometryPool === 'function') {
        clearGeometryPool();
      }

      // Clear incremental update caches
      clearAll3DCaches();

      if (renderer) {
        renderer.dispose();
        renderer = null;
      }

      if (controls) {
        controls.dispose();
        controls = null;
      }

      // Cleanup axis indicator
      if (window._axisIndicator) {
        const axis = window._axisIndicator;
        if (axis.renderer) axis.renderer.dispose();
        if (axis.scene) axis.scene.clear();
        if (axis.container && axis.container.parentNode) {
          axis.container.parentNode.removeChild(axis.container);
        }
        window._axisIndicator = null;
      }

      const container = document.getElementById('three-container');
      if (container) container.innerHTML = '';
    }

    function init3D() {
      console.log('=== init3D called ===');

      // Clean up existing 3D resources first
      cleanup3D();

      // Preload textures before building scene
      preload3DTextures();

      const container = document.getElementById('three-container');
      if (!container) {
        console.error('init3D: three-container not found!');
        return;
      }

      let width = container.clientWidth;
      let height = container.clientHeight;

      console.log('init3D: container dimensions:', width, 'x', height);

      // If container has no size, try to get size from parent or use fallback
      if (width === 0 || height === 0) {
        const parent = container.parentElement;
        if (parent) {
          width = parent.clientWidth || window.innerWidth * 0.6;
          height = parent.clientHeight || window.innerHeight - 150;
          console.log('init3D: using parent/fallback dimensions:', width, 'x', height);
        }
      }

      // Final fallback
      if (width === 0) width = 800;
      if (height === 0) height = 600;

      // Get current theme for background
      const timeOfDay = sceneSettings?.timeOfDay || 'noon';
      const bgColors = {
        morning: 0xFFF8E7,   // Warm cream
        noon: 0xF5F8FA,      // Bright neutral
        evening: 0xFFE8D6,   // Sunset warm
        night: 0x1E2A3A      // Dark blue-gray
      };

      scene = new THREE.Scene();
      scene.background = new THREE.Color(bgColors[timeOfDay] || 0xF5F8FA);

      // Camera - positioned for optimal room viewing
      camera = new THREE.PerspectiveCamera(50, width / height, 0.5, 150);
      const roomDiag = Math.sqrt(roomWidth * roomWidth + roomDepth * roomDepth);
      const camDist = Math.max(roomDiag * 0.8, 10);
      const camHeight = Math.max(6, (roomHeight || 8) * 0.7);
      camera.position.set(roomWidth / 2 + camDist * 0.7, camHeight, roomDepth / 2 + camDist * 0.7);
      camera.lookAt(roomWidth / 2, 3, roomDepth / 2);

      // Renderer with enhanced quality for better texture visibility
      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setSize(width, height);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      renderer.shadowMap.autoUpdate = true;
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 1.15; // Balanced exposure for realistic look
      renderer.physicallyCorrectLights = true; // More realistic light falloff
      renderer.outputEncoding = THREE.sRGBEncoding; // Proper color encoding (r128 API)
      container.appendChild(renderer.domElement);

      // Orbit controls with smooth zoom - allows close-up inspection
      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.08;
      controls.target.set(roomWidth / 2, 1.5, roomDepth / 2);
      controls.maxPolarAngle = Math.PI / 2.05;
      controls.minPolarAngle = Math.PI / 12; // Allow flatter angles for detail viewing
      controls.minDistance = 0.5;  // Allow very close zoom for detail inspection (0.5 ft / 6 inches)
      controls.maxDistance = 150; // Allow zooming out much further for large rooms and overview

      // Moderate zoom sensitivity for fine control
      controls.zoomSpeed = 0.4;

      // Reduce pan sensitivity
      controls.panSpeed = 0.3;

      // Reduce rotation sensitivity
      controls.rotateSpeed = 0.35;

      // Disable right-click completely - only left-click rotates, middle zooms
      // Shift+Left or middle mouse for panning
      controls.mouseButtons = {
        LEFT: THREE.MOUSE.ROTATE,
        MIDDLE: THREE.MOUSE.DOLLY,
        RIGHT: THREE.MOUSE.PAN  // Allow right-click for panning instead of disabling
      };

      // Handle trackpad pinch-to-zoom more smoothly
      controls.enableZoom = true;
      controls.screenSpacePanning = true;  // Pan in screen space for more intuitive control

      // Enable keyboard controls for panning (arrow keys)
      controls.enableKeys = true;
      controls.keys = {
        LEFT: 37,  // left arrow
        UP: 38,    // up arrow
        RIGHT: 39, // right arrow
        BOTTOM: 40 // down arrow
      };

      // Store initial camera state for reset
      const initialCameraPosition = camera.position.clone();
      const initialTarget = controls.target.clone();

      controls.update();

      // ===== POST-PROCESSING EFFECTS =====
      // Setup EffectComposer for enhanced visuals
      try {
        composer = new THREE.EffectComposer(renderer);

        // Render pass - renders the scene normally first
        const renderPass = new THREE.RenderPass(scene, camera);
        composer.addPass(renderPass);

        // SAO (Scalable Ambient Obscurance) for realistic ambient occlusion - optional
        let saoPass = null;
        try {
          if (THREE.SAOPass && THREE.SAOShader) {
            saoPass = new THREE.SAOPass(scene, camera, false, true);
            saoPass.params.saoBias = 0.5;
            saoPass.params.saoIntensity = 0.002;
            saoPass.params.saoScale = 10;
            saoPass.params.saoKernelRadius = 30;
            saoPass.params.saoMinResolution = 0;
            saoPass.params.saoBlur = true;
            saoPass.params.saoBlurRadius = 12;
            saoPass.params.saoBlurStdDev = 6;
            saoPass.params.saoBlurDepthCutoff = 0.01;
            composer.addPass(saoPass);
            console.log('SAO pass initialized');
          } else {
            console.warn('SAOPass or SAOShader not available, skipping ambient occlusion');
          }
        } catch (saoErr) {
          console.warn('SAO pass failed to initialize:', saoErr.message);
        }

        // Bloom pass for subtle glow on bright/reflective surfaces
        const bloomPass = new THREE.UnrealBloomPass(
          new THREE.Vector2(width, height),
          0.15,   // strength - subtle glow
          0.5,    // radius
          0.85    // threshold - only very bright areas bloom
        );
        composer.addPass(bloomPass);

        // FXAA anti-aliasing pass for smoother edges
        const fxaaPass = new THREE.ShaderPass(THREE.FXAAShader);
        const pixelRatio = renderer.getPixelRatio();
        fxaaPass.material.uniforms['resolution'].value.x = 1 / (width * pixelRatio);
        fxaaPass.material.uniforms['resolution'].value.y = 1 / (height * pixelRatio);
        composer.addPass(fxaaPass);

        // Store passes for dynamic adjustment
        window._postProcessing = {
          composer,
          saoPass,
          bloomPass,
          fxaaPass,
          enabled: true
        };

        console.log('Post-processing initialized: Bloom + FXAA' + (saoPass ? ' + SAO' : ''));
      } catch (e) {
        console.warn('Post-processing not available, using standard rendering:', e);
        composer = null;
        postProcessingEnabled = false;
      }

      // Prevent context menu on 3D view
      container.addEventListener('contextmenu', (e) => e.preventDefault());

      // ===== 3D AXIS INDICATOR (Orientation Key) =====
      // Create axis indicator scene, camera, and renderer
      const axisScene = new THREE.Scene();
      const axisCamera = new THREE.PerspectiveCamera(50, 1, 0.1, 100);
      axisCamera.position.set(0, 0, 3);
      axisCamera.lookAt(0, 0, 0);

      const axisRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      axisRenderer.setSize(100, 100);
      axisRenderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      axisRenderer.setClearColor(0x000000, 0);

      // Create axis container and add to DOM
      const axisContainer = document.createElement('div');
      axisContainer.className = 'axis-indicator-container';
      axisContainer.appendChild(axisRenderer.domElement);
      container.appendChild(axisContainer);

      // Create colored axis arrows
      const axisLength = 0.8;
      const arrowHeadLength = 0.2;
      const arrowHeadWidth = 0.1;

      // X axis (Red) - Right direction
      const xDir = new THREE.Vector3(1, 0, 0);
      const xArrow = new THREE.ArrowHelper(xDir, new THREE.Vector3(0, 0, 0), axisLength, 0xff4444, arrowHeadLength, arrowHeadWidth);
      axisScene.add(xArrow);

      // Y axis (Green) - Up direction
      const yDir = new THREE.Vector3(0, 1, 0);
      const yArrow = new THREE.ArrowHelper(yDir, new THREE.Vector3(0, 0, 0), axisLength, 0x44ff44, arrowHeadLength, arrowHeadWidth);
      axisScene.add(yArrow);

      // Z axis (Blue) - Forward direction
      const zDir = new THREE.Vector3(0, 0, 1);
      const zArrow = new THREE.ArrowHelper(zDir, new THREE.Vector3(0, 0, 0), axisLength, 0x4488ff, arrowHeadLength, arrowHeadWidth);
      axisScene.add(zArrow);

      // Add axis labels
      function createAxisLabels() {
        const labelX = document.createElement('div');
        labelX.className = 'axis-label axis-label-x';
        labelX.textContent = 'X';
        labelX.style.cssText = 'right: 8px; top: 50%; transform: translateY(-50%);';
        axisContainer.appendChild(labelX);

        const labelY = document.createElement('div');
        labelY.className = 'axis-label axis-label-y';
        labelY.textContent = 'Y';
        labelY.style.cssText = 'left: 50%; top: 8px; transform: translateX(-50%);';
        axisContainer.appendChild(labelY);

        const labelZ = document.createElement('div');
        labelZ.className = 'axis-label axis-label-z';
        labelZ.textContent = 'Z';
        labelZ.style.cssText = 'left: 8px; bottom: 8px;';
        axisContainer.appendChild(labelZ);
      }
      createAxisLabels();

      // Add soft ambient light to axis indicator
      const axisAmbient = new THREE.AmbientLight(0xffffff, 1);
      axisScene.add(axisAmbient);

      // Store axis components for animation loop access
      window._axisIndicator = {
        scene: axisScene,
        camera: axisCamera,
        renderer: axisRenderer,
        container: axisContainer
      };

      // Add reset view function to window scope
      window.reset3DView = function() {
        camera.position.copy(initialCameraPosition);
        controls.target.copy(initialTarget);
        controls.update();
      };

      // Preset view angles
      window.set3DViewAngle = function(angle) {
        const centerX = roomWidth / 2;
        const centerZ = roomDepth / 2;
        const distance = Math.max(roomWidth, roomDepth) * 1.2;

        switch(angle) {
          case 'top':
            // Bird's eye view - straight down
            camera.position.set(centerX, distance + 8, centerZ + 0.1);
            controls.target.set(centerX, 0, centerZ);
            break;
          case 'front':
            // Front elevation view
            camera.position.set(centerX, 5, roomDepth + distance * 0.8);
            controls.target.set(centerX, 3, centerZ);
            break;
          case 'side':
            // Side elevation view
            camera.position.set(roomWidth + distance * 0.8, 5, centerZ);
            controls.target.set(centerX, 3, centerZ);
            break;
          case 'counter':
            // Counter-level view - eye height looking at countertop
            // Position camera at human eye level (5.5ft) looking at counter height (3ft)
            camera.position.set(centerX, 5.5, roomDepth * 0.8);
            controls.target.set(centerX, 3, centerZ * 0.5);
            break;
          case 'corner':
            // Corner view - diagonal across room for best overall view
            camera.position.set(-2, 6, roomDepth + 2);
            controls.target.set(centerX, 2.5, centerZ);
            break;
          case 'closeup':
            // Close-up of cabinets/counters
            camera.position.set(centerX, 4, roomDepth * 0.3);
            controls.target.set(centerX, 3, 2);
            break;
          default:
            camera.position.copy(initialCameraPosition);
            controls.target.copy(initialTarget);
        }

        controls.update();
      };

      // Cabinet focus mode - hides walls, windows, doors for clear cabinet view
      let cabinetFocusMode = false;
      window.toggleCabinetFocus = function() {
        cabinetFocusMode = !cabinetFocusMode;
        const btn = document.getElementById('focusCabinetsBtn');

        if (cabinetFocusMode) {
          // Hide structural elements, show only cabinets/counters/appliances
          hiddenCategories['walls'] = true;
          hiddenCategories['windows'] = true;
          hiddenCategories['doors'] = true;
          hiddenCategories['niches'] = true;
          hiddenCategories['decorative'] = true;

          // Update UI checkboxes
          document.querySelectorAll('.visibility-toggle input').forEach(cb => {
            const cat = cb.getAttribute('onchange')?.match(/'(\w+)'/)?.[1];
            if (['walls', 'windows', 'doors', 'niches', 'decorative'].includes(cat)) {
              cb.checked = false;
            }
          });

          if (btn) {
            btn.style.background = 'var(--accent-color)';
            btn.style.color = 'white';
          }

          // Set a good view angle for cabinets
          set3DViewAngle('corner');

          showToast('Focus mode: Showing cabinets & countertops only', 'info');
        } else {
          // Restore all visibility
          delete hiddenCategories['walls'];
          delete hiddenCategories['windows'];
          delete hiddenCategories['doors'];
          delete hiddenCategories['niches'];
          delete hiddenCategories['decorative'];

          // Update UI checkboxes
          document.querySelectorAll('.visibility-toggle input').forEach(cb => {
            const cat = cb.getAttribute('onchange')?.match(/'(\w+)'/)?.[1];
            if (['walls', 'windows', 'doors', 'niches', 'decorative'].includes(cat)) {
              cb.checked = true;
            }
          });

          if (btn) {
            btn.style.background = '';
            btn.style.color = '';
          }

          showToast('Showing all elements', 'info');
        }

        // Refresh the view
        draw();
        if (currentView === '3d') update3DScene();
      };

      // === WALKTHROUGH / FIRST-PERSON MODE ===
      let walkthroughMode = false;
      let walkthroughKeys = { w: false, a: false, s: false, d: false, q: false, e: false };
      let walkthroughMoveSpeed = 0.15;
      let walkthroughLookSpeed = 0.002;
      let walkthroughYaw = 0;
      let walkthroughPitch = 0;
      let walkthroughAnimationId = null;

      window.toggleWalkthroughMode = function() {
        walkthroughMode = !walkthroughMode;
        const btn = document.getElementById('walkthroughBtn');
        const normalHint = document.getElementById('threeHint');
        const walkHint = document.getElementById('walkthroughHint');
        const threeContainer = document.getElementById('three-container');

        if (walkthroughMode) {
          // Enter walkthrough mode
          controls.enabled = false;

          // Position camera at eye level (5.5ft) at entrance
          camera.position.set(roomWidth / 2, 5.5, roomDepth - 2);
          walkthroughYaw = 0;
          walkthroughPitch = 0;

          // Show/hide hints
          if (normalHint) normalHint.style.display = 'none';
          if (walkHint) walkHint.style.display = 'flex';

          // Style button
          if (btn) {
            btn.style.background = 'var(--accent-color)';
            btn.style.color = 'white';
          }

          // Enable pointer lock for mouse look
          threeContainer.addEventListener('click', requestPointerLock);
          document.addEventListener('pointerlockchange', onPointerLockChange);
          document.addEventListener('mousemove', onWalkthroughMouseMove);
          document.addEventListener('keydown', onWalkthroughKeyDown);
          document.addEventListener('keyup', onWalkthroughKeyUp);

          // Start animation loop
          walkthroughAnimate();

          showToast('Walkthrough mode: Click to enable mouse look, WASD to move', 'info');
        } else {
          // Exit walkthrough mode
          exitWalkthroughMode();
        }
      };

      function exitWalkthroughMode() {
        walkthroughMode = false;
        controls.enabled = true;

        const btn = document.getElementById('walkthroughBtn');
        const normalHint = document.getElementById('threeHint');
        const walkHint = document.getElementById('walkthroughHint');
        const threeContainer = document.getElementById('three-container');

        if (normalHint) normalHint.style.display = 'flex';
        if (walkHint) walkHint.style.display = 'none';

        if (btn) {
          btn.style.background = '';
          btn.style.color = '';
        }

        // Exit pointer lock
        if (document.pointerLockElement) {
          document.exitPointerLock();
        }

        // Remove event listeners
        threeContainer?.removeEventListener('click', requestPointerLock);
        document.removeEventListener('pointerlockchange', onPointerLockChange);
        document.removeEventListener('mousemove', onWalkthroughMouseMove);
        document.removeEventListener('keydown', onWalkthroughKeyDown);
        document.removeEventListener('keyup', onWalkthroughKeyUp);

        // Stop animation
        if (walkthroughAnimationId) {
          cancelAnimationFrame(walkthroughAnimationId);
          walkthroughAnimationId = null;
        }

        // Reset controls target
        controls.target.set(roomWidth / 2, 2, roomDepth / 2);
        controls.update();

        showToast('Exited walkthrough mode', 'info');
      }

      // === POST-PROCESSING TOGGLE ===
      window.togglePostProcessing = function() {
        if (!window._postProcessing) {
          showToast('Post-processing not available', 'warning');
          return;
        }

        window._postProcessing.enabled = !window._postProcessing.enabled;
        postProcessingEnabled = window._postProcessing.enabled;

        const btn = document.getElementById('postProcessingBtn');
        if (btn) {
          if (window._postProcessing.enabled) {
            btn.classList.add('active');
            btn.style.background = 'linear-gradient(135deg, #6366f1, #8b5cf6)';
            btn.style.color = '#fff';
            showToast('Enhanced graphics ON (Bloom + AO)', 'success');
          } else {
            btn.classList.remove('active');
            btn.style.background = '';
            btn.style.color = '';
            showToast('Enhanced graphics OFF (faster rendering)', 'info');
          }
        }
      };

      // Adjust post-processing quality
      window.setPostProcessingQuality = function(quality) {
        if (!window._postProcessing) return;

        const { saoPass, bloomPass } = window._postProcessing;

        switch (quality) {
          case 'high':
            if (saoPass) {
              saoPass.params.saoIntensity = 0.003;
              saoPass.params.saoKernelRadius = 50;
              saoPass.params.saoBlurRadius = 16;
            }
            if (bloomPass) {
              bloomPass.strength = 0.2;
              bloomPass.threshold = 0.8;
            }
            break;
          case 'medium':
            if (saoPass) {
              saoPass.params.saoIntensity = 0.002;
              saoPass.params.saoKernelRadius = 30;
              saoPass.params.saoBlurRadius = 12;
            }
            if (bloomPass) {
              bloomPass.strength = 0.15;
              bloomPass.threshold = 0.85;
            }
            break;
          case 'low':
            if (saoPass) {
              saoPass.params.saoIntensity = 0.001;
              saoPass.params.saoKernelRadius = 15;
              saoPass.params.saoBlurRadius = 8;
            }
            if (bloomPass) {
              bloomPass.strength = 0.1;
              bloomPass.threshold = 0.9;
            }
            break;
        }
      };

      function requestPointerLock() {
        const threeContainer = document.getElementById('three-container');
        threeContainer?.requestPointerLock();
      }

      function onPointerLockChange() {
        if (!document.pointerLockElement && walkthroughMode) {
          // Still in walkthrough mode but pointer unlocked - show hint
          showToast('Click 3D view to re-enable mouse look', 'info');
        }
      }

      function onWalkthroughMouseMove(e) {
        if (!walkthroughMode || !document.pointerLockElement) return;

        walkthroughYaw -= e.movementX * walkthroughLookSpeed;
        walkthroughPitch -= e.movementY * walkthroughLookSpeed;

        // Clamp pitch to prevent flipping
        walkthroughPitch = Math.max(-Math.PI / 2 + 0.1, Math.min(Math.PI / 2 - 0.1, walkthroughPitch));
      }

      function onWalkthroughKeyDown(e) {
        if (!walkthroughMode) return;

        const key = e.key.toLowerCase();
        if (key === 'w') walkthroughKeys.w = true;
        if (key === 'a') walkthroughKeys.a = true;
        if (key === 's') walkthroughKeys.s = true;
        if (key === 'd') walkthroughKeys.d = true;
        if (key === 'q') walkthroughKeys.q = true;
        if (key === 'e') walkthroughKeys.e = true;
        if (key === 'escape') exitWalkthroughMode();
        if (key === 'shift') walkthroughMoveSpeed = 0.3; // Sprint
      }

      function onWalkthroughKeyUp(e) {
        if (!walkthroughMode) return;

        const key = e.key.toLowerCase();
        if (key === 'w') walkthroughKeys.w = false;
        if (key === 'a') walkthroughKeys.a = false;
        if (key === 's') walkthroughKeys.s = false;
        if (key === 'd') walkthroughKeys.d = false;
        if (key === 'q') walkthroughKeys.q = false;
        if (key === 'e') walkthroughKeys.e = false;
        if (key === 'shift') walkthroughMoveSpeed = 0.15; // Normal speed
      }

      function walkthroughAnimate() {
        if (!walkthroughMode) return;

        walkthroughAnimationId = requestAnimationFrame(walkthroughAnimate);

        // Calculate forward/right vectors based on yaw
        const forward = new THREE.Vector3(
          Math.sin(walkthroughYaw),
          0,
          Math.cos(walkthroughYaw)
        );
        const right = new THREE.Vector3(
          Math.sin(walkthroughYaw + Math.PI / 2),
          0,
          Math.cos(walkthroughYaw + Math.PI / 2)
        );

        // Apply movement
        if (walkthroughKeys.w) {
          camera.position.add(forward.clone().multiplyScalar(-walkthroughMoveSpeed));
        }
        if (walkthroughKeys.s) {
          camera.position.add(forward.clone().multiplyScalar(walkthroughMoveSpeed));
        }
        if (walkthroughKeys.a) {
          camera.position.add(right.clone().multiplyScalar(-walkthroughMoveSpeed));
        }
        if (walkthroughKeys.d) {
          camera.position.add(right.clone().multiplyScalar(walkthroughMoveSpeed));
        }
        if (walkthroughKeys.q) {
          camera.position.y -= walkthroughMoveSpeed * 0.5;
        }
        if (walkthroughKeys.e) {
          camera.position.y += walkthroughMoveSpeed * 0.5;
        }

        // Keep camera within reasonable bounds
        camera.position.x = Math.max(-5, Math.min(roomWidth + 5, camera.position.x));
        camera.position.y = Math.max(1, Math.min(12, camera.position.y));
        camera.position.z = Math.max(-5, Math.min(roomDepth + 5, camera.position.z));

        // Update camera look direction
        const lookTarget = new THREE.Vector3(
          camera.position.x + Math.sin(walkthroughYaw) * Math.cos(walkthroughPitch),
          camera.position.y + Math.sin(walkthroughPitch),
          camera.position.z + Math.cos(walkthroughYaw) * Math.cos(walkthroughPitch)
        );
        camera.lookAt(lookTarget);

        // Render
        renderer.render(scene, camera);
      }

      // === LIGHTING ===
      // === BALANCED LIGHTING SYSTEM ===
      // Reduced intensity for realistic indoor lighting that preserves material colors
      // Goal: Dark colors stay dark, light colors stay visible without washing out
      const lightingPresets = {
        morning: {
          ambient: { color: 0xFFF8F0, intensity: 0.35 },
          hemisphere: { sky: 0xFFE4C4, ground: 0x8B7355, intensity: 0.25 },
          sun: { color: 0xFFE4B5, intensity: 0.6, pos: [25, 12, 15] },
          fill: { color: 0xFFE8D6, intensity: 0.2 },
          exposure: 0.9
        },
        noon: {
          ambient: { color: 0xFFFFFF, intensity: 0.4 },
          hemisphere: { sky: 0xE0F0FF, ground: 0x8B7355, intensity: 0.3 },
          sun: { color: 0xFFFFF8, intensity: 0.7, pos: [15, 25, 15] },
          fill: { color: 0xFFFFFF, intensity: 0.25 },
          exposure: 0.95
        },
        evening: {
          ambient: { color: 0xFFE0C0, intensity: 0.3 },
          hemisphere: { sky: 0xFFA07A, ground: 0x6B4423, intensity: 0.2 },
          sun: { color: 0xFF8C00, intensity: 0.5, pos: [-20, 8, 10] },
          fill: { color: 0xFFD4B8, intensity: 0.25 },
          exposure: 0.85
        },
        night: {
          ambient: { color: 0xC0C8D8, intensity: 0.25 },
          hemisphere: { sky: 0x4169E1, ground: 0x2F3F4F, intensity: 0.15 },
          sun: { color: 0xB0C4DE, intensity: 0.15, pos: [-15, 20, 10] },
          fill: { color: 0xFFF8E0, intensity: 0.35 }, // Interior lights
          exposure: 0.75
        },
        // SHOWROOM: Optimized for showcasing countertop colors accurately
        // Bright, neutral white lighting with minimal color cast
        showroom: {
          ambient: { color: 0xFFFFFF, intensity: 0.55 },
          hemisphere: { sky: 0xFFFFFF, ground: 0xF0F0F0, intensity: 0.35 },
          sun: { color: 0xFFFFFF, intensity: 0.85, pos: [10, 20, 10] },
          fill: { color: 0xFFFFFF, intensity: 0.4 },
          exposure: 1.1
        }
      };

      const preset = lightingPresets[timeOfDay] || lightingPresets.noon;

      // Apply exposure setting - controls overall brightness
      renderer.toneMappingExposure = preset.exposure;

      // Ambient light - soft overall illumination (reduced to preserve color contrast)
      const ambient = new THREE.AmbientLight(preset.ambient.color, preset.ambient.intensity);
      ambient.name = 'ambientLight';
      scene.add(ambient);

      // Hemisphere light (subtle sky/ground gradient for natural feel)
      const hemi = new THREE.HemisphereLight(preset.hemisphere.sky, preset.hemisphere.ground, preset.hemisphere.intensity);
      hemi.name = 'hemisphereLight';
      scene.add(hemi);

      // Main directional (sun/moon) with shadows - primary light source
      // Enhanced shadow quality for realistic rendering
      const sun = new THREE.DirectionalLight(preset.sun.color, preset.sun.intensity);
      sun.name = 'sunLight';
      sun.position.set(...preset.sun.pos);
      sun.castShadow = true;
      sun.shadow.mapSize.width = 4096;  // Higher resolution shadows
      sun.shadow.mapSize.height = 4096;
      sun.shadow.camera.near = 0.5;
      sun.shadow.camera.far = 60;
      sun.shadow.camera.left = -30;
      sun.shadow.camera.right = 30;
      sun.shadow.camera.top = 30;
      sun.shadow.camera.bottom = -30;
      sun.shadow.bias = -0.0001;  // Reduced bias for sharper shadows
      sun.shadow.normalBias = 0.02;  // Helps with shadow acne on curved surfaces
      sun.shadow.radius = 1.5;  // Soft shadow edges
      scene.add(sun);

      // Fill light - softens shadows, subtle
      const fill = new THREE.DirectionalLight(preset.fill.color, preset.fill.intensity);
      fill.name = 'fillLight';
      fill.position.set(-roomWidth, 12, roomDepth);
      scene.add(fill);

      // Enhanced countertop showcase lighting system
      // Multiple soft spotlights positioned to highlight stone colors and textures

      // Primary countertop spotlight - centered, warm white for color accuracy
      const countertopSpot1 = new THREE.SpotLight(0xFFFAF0, 0.55);
      countertopSpot1.name = 'countertopSpot1';
      countertopSpot1.position.set(roomWidth / 2, 8, roomDepth / 3);
      countertopSpot1.target.position.set(roomWidth / 2, 3, roomDepth / 3);
      countertopSpot1.angle = Math.PI / 4;
      countertopSpot1.penumbra = 0.6;
      countertopSpot1.decay = 1.5;
      countertopSpot1.distance = 15;
      scene.add(countertopSpot1);
      scene.add(countertopSpot1.target);

      // Secondary countertop spotlight - back wall coverage
      const countertopSpot2 = new THREE.SpotLight(0xFFFAF0, 0.45);
      countertopSpot2.name = 'countertopSpot2';
      countertopSpot2.position.set(roomWidth / 3, 8, 2);
      countertopSpot2.target.position.set(roomWidth / 3, 3, 1);
      countertopSpot2.angle = Math.PI / 5;
      countertopSpot2.penumbra = 0.5;
      countertopSpot2.decay = 1.5;
      countertopSpot2.distance = 12;
      scene.add(countertopSpot2);
      scene.add(countertopSpot2.target);

      // Third spotlight for island/peninsula if room is large enough
      if (roomWidth > 10 || roomDepth > 10) {
        const countertopSpot3 = new THREE.SpotLight(0xFFFAF0, 0.4);
        countertopSpot3.name = 'countertopSpot3';
        countertopSpot3.position.set(roomWidth * 0.6, 8, roomDepth * 0.6);
        countertopSpot3.target.position.set(roomWidth * 0.6, 3, roomDepth * 0.6);
        countertopSpot3.angle = Math.PI / 4;
        countertopSpot3.penumbra = 0.6;
        countertopSpot3.decay = 1.5;
        countertopSpot3.distance = 12;
        scene.add(countertopSpot3);
        scene.add(countertopSpot3.target);
      }

      // Subtle surface light for overall countertop visibility
      const surfaceLight = new THREE.DirectionalLight(0xFFFFFF, 0.18);
      surfaceLight.name = 'surfaceLight';
      surfaceLight.position.set(roomWidth / 2, 12, roomDepth / 2);
      surfaceLight.target.position.set(roomWidth / 2, 0, roomDepth / 2);
      scene.add(surfaceLight);
      scene.add(surfaceLight.target);

      // Subtle rim light for depth separation
      const back = new THREE.DirectionalLight(0xE8F0FF, 0.12);
      back.name = 'backLight';
      back.position.set(roomWidth / 2, 5, -10);
      scene.add(back);

      // Edge accent light - highlights countertop edges and profiles
      // Enhanced for better definition on white/light countertops
      const edgeLight = new THREE.DirectionalLight(0xF0F8FF, 0.15);
      edgeLight.name = 'edgeLight';
      edgeLight.position.set(-5, 4, roomDepth / 2);
      scene.add(edgeLight);

      // === ENHANCED WHITE SURFACE DEFINITION ===
      // Additional lighting for light-colored/white countertops visibility
      // Low-angle light creates subtle shadows on edges for definition
      const contrastLight = new THREE.DirectionalLight(0xE8E8F0, 0.12);
      contrastLight.name = 'contrastLight';
      contrastLight.position.set(roomWidth * 0.8, 3.5, -3);
      contrastLight.castShadow = true;
      contrastLight.shadow.mapSize.width = 2048;
      contrastLight.shadow.mapSize.height = 2048;
      contrastLight.shadow.camera.near = 0.1;
      contrastLight.shadow.camera.far = 25;
      contrastLight.shadow.bias = -0.0003;
      scene.add(contrastLight);

      // Side definition light - grazing angle for edge highlight on white surfaces
      const sideDefinition = new THREE.DirectionalLight(0xFFF8F0, 0.08);
      sideDefinition.name = 'sideDefinition';
      sideDefinition.position.set(roomWidth + 5, 4, roomDepth / 2);
      scene.add(sideDefinition);

      // Under-cabinet subtle shadow light for countertop edge definition
      const underCabinetShadow = new THREE.DirectionalLight(0xF5F5FF, 0.06);
      underCabinetShadow.name = 'underCabinetShadow';
      underCabinetShadow.position.set(roomWidth / 2, 5, roomDepth + 3);
      scene.add(underCabinetShadow);

      // === ENHANCED ENVIRONMENT MAP FOR REALISTIC REFLECTIONS ===
      // High-quality HDR-like environment for polished stone and metallic surfaces
      const pmremGenerator = new THREE.PMREMGenerator(renderer);
      pmremGenerator.compileEquirectangularShader();

      // Environment colors based on time of day - enhanced for better reflections
      const envColors = {
        morning: {
          sky: '#FFE4B5', skyDark: '#DEC99A',
          horizon: '#FFF8DC',
          ground: '#D2B48C', groundDark: '#A08060',
          sunColor: '#FFE5A0', sunIntensity: 0.9
        },
        noon: {
          sky: '#A8CCE8', skyDark: '#7BA8D0',
          horizon: '#F0F4F8',
          ground: '#D4C4B0', groundDark: '#A09080',
          sunColor: '#FFFEF0', sunIntensity: 1.0
        },
        evening: {
          sky: '#FFA07A', skyDark: '#E08050',
          horizon: '#FFE4C4',
          ground: '#8B6545', groundDark: '#5A4030',
          sunColor: '#FFC080', sunIntensity: 0.7
        },
        night: {
          sky: '#1A2840', skyDark: '#0F1A28',
          horizon: '#2A3A50',
          ground: '#1A2030', groundDark: '#101520',
          sunColor: '#6080A0', sunIntensity: 0.2
        }
      };

      const envCol = envColors[timeOfDay] || envColors.noon;

      // Create high-resolution environment map canvas
      const envCanvas = document.createElement('canvas');
      envCanvas.width = 1024;  // Higher resolution for better reflections
      envCanvas.height = 512;
      const envCtx = envCanvas.getContext('2d');

      // Create detailed vertical gradient (sky to ground)
      const mainGradient = envCtx.createLinearGradient(0, 0, 0, 512);
      mainGradient.addColorStop(0, envCol.skyDark);
      mainGradient.addColorStop(0.15, envCol.sky);
      mainGradient.addColorStop(0.4, envCol.horizon);
      mainGradient.addColorStop(0.5, envCol.horizon);
      mainGradient.addColorStop(0.6, envCol.ground);
      mainGradient.addColorStop(1, envCol.groundDark);
      envCtx.fillStyle = mainGradient;
      envCtx.fillRect(0, 0, 1024, 512);

      // Add soft ambient light variations for more natural reflections
      if (timeOfDay !== 'night') {
        // Subtle sun/bright area simulation
        const sunX = timeOfDay === 'morning' ? 200 : (timeOfDay === 'evening' ? 800 : 512);
        const sunY = timeOfDay === 'noon' ? 120 : 160;

        // Sun glow (softer, more realistic)
        const sunGradient = envCtx.createRadialGradient(sunX, sunY, 0, sunX, sunY, 150);
        sunGradient.addColorStop(0, `rgba(255, 255, 240, ${envCol.sunIntensity * 0.5})`);
        sunGradient.addColorStop(0.3, `rgba(255, 250, 220, ${envCol.sunIntensity * 0.3})`);
        sunGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
        envCtx.fillStyle = sunGradient;
        envCtx.fillRect(0, 0, 1024, 512);

        // Soft cloud/light variations for more interesting reflections
        envCtx.fillStyle = 'rgba(255, 255, 255, 0.08)';
        envCtx.fillRect(150, 140, 200, 40);
        envCtx.fillRect(400, 160, 150, 35);
        envCtx.fillRect(700, 150, 180, 38);

        // Ground reflections (floor/counter bounce light)
        envCtx.fillStyle = 'rgba(255, 248, 240, 0.06)';
        envCtx.fillRect(0, 350, 1024, 80);
      } else {
        // Night: subtle window/artificial light reflections
        envCtx.fillStyle = 'rgba(180, 200, 220, 0.1)';
        envCtx.fillRect(100, 200, 80, 60);
        envCtx.fillRect(300, 190, 100, 70);
        envCtx.fillRect(600, 195, 90, 65);
        envCtx.fillRect(850, 200, 70, 55);
      }

      // Add subtle horizontal bands for indoor lighting simulation
      for (let y = 180; y < 280; y += 40) {
        envCtx.fillStyle = `rgba(255, 255, 255, ${timeOfDay === 'night' ? 0.02 : 0.04})`;
        envCtx.fillRect(0, y, 1024, 15);
      }

      const envTexture = new THREE.CanvasTexture(envCanvas);
      envTexture.mapping = THREE.EquirectangularReflectionMapping;
      envTexture.encoding = THREE.sRGBEncoding;

      // Generate environment map with higher quality
      const envMap = pmremGenerator.fromEquirectangular(envTexture).texture;
      scene.environment = envMap;

      // Store for use in materials
      window.roomEnvMap = envMap;

      // Cleanup
      pmremGenerator.dispose();
      envTexture.dispose();

      // Note: Background is already set above based on time of day

      // Resize handler
      window.addEventListener('resize', () => {
        if (!renderer || !camera || !container) return;
        const w = container.clientWidth;
        const h = container.clientHeight;
        if (w > 0 && h > 0) {
          camera.aspect = w / h;
          camera.updateProjectionMatrix();
          renderer.setSize(w, h);

          // Update post-processing composer on resize
          if (composer) {
            composer.setSize(w, h);
            // Update FXAA resolution
            if (window._postProcessing?.fxaaPass) {
              const pixelRatio = renderer.getPixelRatio();
              window._postProcessing.fxaaPass.material.uniforms['resolution'].value.x = 1 / (w * pixelRatio);
              window._postProcessing.fxaaPass.material.uniforms['resolution'].value.y = 1 / (h * pixelRatio);
            }
            // Update bloom resolution
            if (window._postProcessing?.bloomPass) {
              window._postProcessing.bloomPass.resolution.set(w, h);
            }
          }
        }
      });
    }

    // Get proper 3D height for element types
    // Can accept element object to use custom heights
    function get3DHeight(typeOrElement) {
      const type = typeof typeOrElement === 'string' ? typeOrElement : typeOrElement?.type;
      const el = typeof typeOrElement === 'object' ? typeOrElement : null;

      // Validate input
      if (!type) {
        console.warn('get3DHeight: No type provided', typeOrElement);
        return 1; // Default 1 foot
      }

      // Check for custom 3D height override on the element
      if (el?.height3D !== undefined) {
        return el.height3D;
      }

      // Window-specific height override
      if (el?.windowHeight !== undefined && (type === 'window' || type === 'window-large' || type === 'window-bay' || type === 'bay-window' || type === 'picture-window')) {
        return el.windowHeight;
      }

      // Full-height wall types use room ceiling height
      const fullHeightTypes = [
        'wall', 'wall-block', 'wall-concrete', 'wall-framed',
        'wall-wood-2x4', 'wall-wood-2x6', 'wall-brick'
      ];
      if (fullHeightTypes.includes(type)) {
        // Use element's wallHeight if set, otherwise room ceiling height
        return el?.wallHeight || roomHeight || 8;
      }

      const heights = {
        'base-cabinet': 2.9,      // 35 inches standard
        'drawer-base': 2.9,       // 35 inches (same as base)
        'sink-base': 2.9,         // 35 inches (same as base)
        'wall-cabinet': 2.5,      // 30 inches
        'tall-cabinet': 7,        // 84 inches
        'corner-cabinet': 2.9,
        'lazy-susan': 2.9,        // 35 inches (corner base)
        'island': 3,              // 36 inches with countertop
        'countertop': 0.12,       // 1.5 inch thick
        'backsplash': 1.5,        // 18 inches
        'flooring': 0.05,         // Very thin
        'tile': 0.05,
        'shower-pan': 0.08,       // Shower pan thickness
        'shower-curb': 0.5,       // 6" high curb
        'shower-wall': el?.wallHeight || 7, // Full shower height
        'wall-tile': el?.wallHeight || 8,   // Full wall height
        'accent-wall': el?.wallHeight || 8, // Full wall height
        'sink': 0.3,              // Recessed
        'stove': 3,               // Full range height
        'range': 3,               // Full range height
        'cooktop': 0.2,           // Cooktop inset into counter (~2.5" thick)
        'refrigerator': 5.8,      // 70 inches
        'dishwasher': 2.8,        // 34 inches
        'microwave': 1.25,        // 15 inches (typical OTR microwave)
        'range-hood': 1.5,        // 18 inches tall
        'oven': 2.4,              // 29 inches
        'wall-oven-double': 4.5,  // 54 inches (double wall oven)
        'slide-in-range': 3,      // 36 inches (same as range)
        'microwave-cabinet': 1.5, // 18 inches (open shelf for microwave)
        'above-microwave-cabinet': 1.25, // 15 inches (cabinet above microwave, matches wall cab alignment)
        'single-oven-cabinet': 7, // 84 inches (standard tall oven cabinet)
        'tall-oven': 7, // 84 inches (alias for single oven cabinet)
        'double-oven-cabinet': 8, // 96 inches (tall cabinet with double oven)
        'fridge-cabinet': 7,      // 84 inches (surrounds refrigerator)
        'blind-corner': 2.9,      // 35 inches (same as base cabinet)
        'door': 6.8,              // 82 inches
        'double-door': 6.8,       // 82 inches
        'sliding-door': 6.8,      // 82 inches
        'french-door': 6.8,       // 82 inches
        'glass-door': 6.8,        // 82 inches
        'entry-archway': 7,       // 84 inches (arched opening)
        'garage-door': 7,         // 84 inches
        'window': 4.5,            // 54 inches - standard double-hung (IRC)
        'window-large': 5,        // 60 inches (picture)
        'window-bay': 4,          // 48 inches (bay)
        'bay-window': 4,          // 48 inches
        'picture-window': 5,      // 60 inches
        // Niches - these are the opening heights
        'wall-niche': 3,          // 36 inches
        'fireplace-niche': 2.5,   // 30 inches
        'tv-niche': 2.5,          // 30 inches (for TV)
        'shower-niche': 1.5,      // 18 inches (small)
        // ADA grab bars
        'grab-bar': 0.25,         // 3 inches diameter
        'grab-bar-24': 0.25,      // 3 inches diameter (24" length)
        'grab-bar-36': 0.25,      // 3 inches diameter (36" length)
        'grab-bar-42': 0.25,      // 3 inches diameter (42" length)
        // Pony walls (use element's wallHeight if set)
        'pony-wall': el?.wallHeight || 3.5,         // 42 inches
        'pony-wall-bar': el?.wallHeight || 3.5,     // 42 inches
        'knee-wall': el?.wallHeight || 2.5,         // 30 inches

        // Stone caps and ledges
        'wall-cap': el?.thickness || 0.1,           // 1.25" cap thickness
        'bar-top': el?.thickness || 0.125,          // 1.5" bar top thickness
        'window-sill': el?.stoneThickness || 0.06,  // 3/4" sill
        'threshold': el?.stoneThickness || 0.04,    // 1/2" threshold
        'mantel': el?.stoneThickness || 0.1,        // Mantel shelf thickness
        'fireplace-hearth': el?.stoneThickness || 0.125, // Hearth slab
        'fireplace-surround': el?.surroundWidth || 0.67, // Surround width as height
        'niche-surround': el?.surroundWidth || 0.5, // Niche surround

        // Work surfaces (countertop-like materials)
        'surface-stainless': 0.1,       // 1.2" stainless steel work surface
        'surface-solid': 0.1,           // 1.2" solid surface (Corian)
        'surface-laminate': 0.125,      // 1.5" laminate on substrate
        'surface-butcherblock': 0.125,  // 1.5" butcher block
        'surface-concrete': 0.15,       // 1.8" concrete countertop (thicker)

        // Structural elements - beams and columns
        'steel-beam': el?.beamDepth || 0.67,        // 8" I-beam depth (W8 section)
        'steel-column': el?.columnHeight || 8,      // Full height (floor to ceiling)
        'wood-beam': el?.beamDepth || 0.5,          // 6" beam depth
        'wood-post': el?.columnHeight || 8,         // Full height post
        'concrete-beam': el?.beamDepth || 0.83,     // 10" concrete beam
        'concrete-column': el?.columnHeight || 8,   // Full height column
        'header': el?.beamDepth || 0.33,            // 4" header/lintel
        'lvl-beam': el?.beamDepth || 0.92           // 11" LVL beam
      };
      return heights[type] || 1;
    }

    // Get Y position (elevation) for element types
    function get3DYPosition(el, height) {
      // Validate inputs to prevent NaN propagation
      if (!el || typeof el.type === 'undefined') {
        console.warn('get3DYPosition: Invalid element', el);
        return (height || 1) / 2; // Default: floor level
      }
      if (typeof height !== 'number' || isNaN(height)) {
        height = 1; // Default 1 foot
      }

      // Proper stacking heights for kitchen elements
      // All heights in feet, Y = center of object
      const type = el.type;

      switch(type) {
        // Ground level surfaces (below everything)
        case 'flooring':
        case 'tile':
        case 'shower-pan':
          return 0.025; // Just above floor plane

        case 'shower-curb':
          return height / 2; // Sits on floor

        case 'shower-wall':
        case 'wall-tile':
        case 'accent-wall':
          return height / 2; // Wall panels sit on floor

        // Base level (on floor)
        case 'base-cabinet':
        case 'drawer-base':
        case 'sink-base':
        case 'corner-cabinet':
        case 'lazy-susan':
        case 'island':
          return height / 2; // Base sits on floor

        // Counter height items (on top of base cabinets at ~35")
        case 'countertop':
        case 'countertop-l':
        case 'countertop-corner':
        case 'countertop-u': {
          // Smart stacking: detect what's beneath this countertop and sit ON TOP of it
          const ctopCenterX = el.x / pixelsPerFoot + el.width / 2;
          const ctopCenterY = el.y / pixelsPerFoot + el.height / 2;
          const ctopLeft = el.x / pixelsPerFoot;
          const ctopRight = ctopLeft + el.width;
          const ctopTop = el.y / pixelsPerFoot;
          const ctopBottom = ctopTop + el.height;

          // Types of elements countertops can sit on
          const ponyWallTypes = ['pony-wall', 'pony-wall-bar', 'knee-wall'];
          const cabinetTypes = ['base-cabinet', 'drawer-base', 'sink-base', 'corner-cabinet',
                                'lazy-susan', 'island', 'tall-cabinet'];

          // Find any element that this countertop overlaps with
          let bestMatch = null;
          let bestHeight = 0;

          elements.forEach(other => {
            if (other.id === el.id) return;

            // Calculate other element bounds
            const otherLeft = other.x / pixelsPerFoot;
            const otherRight = otherLeft + other.width;
            const otherTop = other.y / pixelsPerFoot;
            const otherBottom = otherTop + other.height;

            // Check for overlap (countertop should overlap at least 50% with the element below)
            const overlapX = Math.max(0, Math.min(ctopRight, otherRight) - Math.max(ctopLeft, otherLeft));
            const overlapY = Math.max(0, Math.min(ctopBottom, otherBottom) - Math.max(ctopTop, otherTop));
            const overlapArea = overlapX * overlapY;
            const ctopArea = el.width * el.height;

            // Need at least 20% overlap to consider sitting on it
            if (overlapArea / ctopArea < 0.2) return;

            if (ponyWallTypes.includes(other.type)) {
              const wallHeight = other.wallHeight || (other.type === 'knee-wall' ? 2.5 : 3.5);
              if (wallHeight > bestHeight) {
                bestHeight = wallHeight;
                bestMatch = other;
              }
            } else if (cabinetTypes.includes(other.type)) {
              // Get the cabinet's height (top surface)
              const cabHeight = other.type === 'tall-cabinet' ? (other.cabinetHeight || 7) :
                               (other.cabinetHeight || 2.9);
              if (cabHeight > bestHeight) {
                bestHeight = cabHeight;
                bestMatch = other;
              }
            }
          });

          if (bestMatch) {
            // Position countertop on top of the detected element
            return bestHeight + height / 2;
          }

          // Default: Base cabinet is 2.9ft (34.8"), counter sits directly on top
          return 2.9 + height / 2;
        }

        case 'sink':
        case 'sink-double':
        case 'sink-farmhouse': {
          // Smart stacking: sink sits IN/ON countertop surface
          const sinkLeft = el.x / pixelsPerFoot;
          const sinkRight = sinkLeft + el.width;
          const sinkTop = el.y / pixelsPerFoot;
          const sinkBottom = sinkTop + el.height;

          // Find countertop that this sink is in
          let counterSurface = 3.02; // Default: 2.9 cabinet + 0.12 counter

          elements.forEach(other => {
            if (other.id === el.id) return;
            if (other.type !== 'countertop') return;

            const otherLeft = other.x / pixelsPerFoot;
            const otherRight = otherLeft + other.width;
            const otherTop = other.y / pixelsPerFoot;
            const otherBottom = otherTop + other.height;

            // Check if sink overlaps with countertop
            const overlapX = Math.max(0, Math.min(sinkRight, otherRight) - Math.max(sinkLeft, otherLeft));
            const overlapY = Math.max(0, Math.min(sinkBottom, otherBottom) - Math.max(sinkTop, otherTop));

            if (overlapX > 0.1 && overlapY > 0.1) {
              // Found a countertop - calculate its surface height
              counterSurface = 2.9 + 0.12; // Standard cabinet + counter
            }
          });

          // Farmhouse sinks show apron, position slightly lower
          if (el.type === 'sink-farmhouse' || el.mountType === 'farmhouse') {
            return counterSurface - 0.1;
          }
          // Top mount sinks - rim sits ON the countertop surface
          if (el.mountType === 'topmount') {
            return counterSurface;
          }
          // Undermount sinks - the sink origin is at countertop level
          // The basin extends DOWN into the cabinet from here
          // The "hole" elements extend UP to cover the countertop
          return counterSurface;
        }

        case 'cooktop': {
          // Cooktop sits IN countertop, flush with surface
          const ctLeft = el.x / pixelsPerFoot;
          const ctRight = ctLeft + el.width;
          const ctTop = el.y / pixelsPerFoot;
          const ctBottom = ctTop + el.height;

          let counterSurface = 3.02;

          elements.forEach(other => {
            if (other.id === el.id) return;
            if (other.type !== 'countertop') return;

            const otherLeft = other.x / pixelsPerFoot;
            const otherRight = otherLeft + other.width;
            const otherTop = other.y / pixelsPerFoot;
            const otherBottom = otherTop + other.height;

            const overlapX = Math.max(0, Math.min(ctRight, otherRight) - Math.max(ctLeft, otherLeft));
            const overlapY = Math.max(0, Math.min(ctBottom, otherBottom) - Math.max(ctTop, otherTop));

            if (overlapX > 0.1 && overlapY > 0.1) {
              counterSurface = 2.9 + 0.12;
            }
          });

          // Cooktop surface is flush with countertop
          return counterSurface;
        }

        case 'stove':
        case 'range':
        case 'dishwasher':
        case 'oven':
          return height / 2; // These are floor-standing appliances

        case 'refrigerator':
          return height / 2; // Floor standing, tall

        // Wall mounted (54" from floor is typical bottom edge)
        case 'wall-cabinet': {
          // Smart stacking: wall cabinet sits above backsplash/countertop with 18" clearance
          const wcLeft = el.x / pixelsPerFoot;
          const wcRight = wcLeft + el.width;
          const wcTop = el.y / pixelsPerFoot;
          const wcBottom = wcTop + el.height;

          // Find backsplash or countertop beneath this wall cabinet
          let surfaceBelowTop = 3.02; // Default counter surface

          elements.forEach(other => {
            if (other.id === el.id) return;

            const otherLeft = other.x / pixelsPerFoot;
            const otherRight = otherLeft + other.width;
            const otherTop = other.y / pixelsPerFoot;
            const otherBottom = otherTop + other.height;

            // Check for horizontal overlap
            const overlapX = Math.max(0, Math.min(wcRight, otherRight) - Math.max(wcLeft, otherLeft));
            if (overlapX < 0.1) return;

            // Check for overlap or adjacency in Y
            const overlapY = Math.max(0, Math.min(wcBottom, otherBottom) - Math.max(wcTop, otherTop));
            const adjacentY = Math.abs(wcBottom - otherTop) < 1 || Math.abs(wcTop - otherBottom) < 1;
            if (overlapY < 0.1 && !adjacentY) return;

            if (other.type === 'backsplash') {
              // Get backsplash top - sits on counter surface (3.02) + backsplash height
              const bsHeight = other.wallHeight || 1.5; // Default 18" backsplash
              const bsTop = 3.02 + bsHeight;
              if (bsTop > surfaceBelowTop) {
                surfaceBelowTop = bsTop;
              }
            } else if (other.type === 'countertop') {
              const counterTop = 3.02;
              if (counterTop > surfaceBelowTop) {
                surfaceBelowTop = counterTop;
              }
            }
          });

          // Wall cabinet sits 1.5 feet (18") above the surface below
          return surfaceBelowTop + 1.5 + height / 2;
        }

        case 'above-microwave-cabinet': {
          // Combined unit: cabinet with microwave below (rendered as one piece)
          // Aligns with wall cabinets: bottom at 4.5ft (54"), top at 7ft (84")
          // Total height: cabinet (1.25ft/15") + microwave (1.25ft/15") = 2.5ft (30") = wall cabinet height
          //
          // Wall cabinet: bottom 4.5ft, top 7ft, center at 5.75ft
          // This unit: microwave bottom at 4.5ft, cabinet top at 7ft
          //   - Microwave: 4.5ft to 5.75ft
          //   - Cabinet: 5.75ft to 7ft (with small gap)

          const mwHeightIn3D = 1.25; // Microwave portion height (15 inches)
          const wallCabinetBottom = 4.5; // 54 inches from floor (aligns with wall cabs)

          // Cabinet center position: microwave bottom + microwave height + gap + cabinet height/2
          return wallCabinetBottom + mwHeightIn3D + 0.02 + height/2;
        }

        case 'backsplash': {
          // Smart stacking: backsplash sits ON TOP of countertop surface
          const bsLeft = el.x / pixelsPerFoot;
          const bsRight = bsLeft + el.width;
          const bsTop = el.y / pixelsPerFoot;
          const bsBottom = bsTop + el.height;

          // Find countertop beneath this backsplash
          let counterSurfaceHeight = 0;

          elements.forEach(other => {
            if (other.id === el.id) return;
            if (other.type !== 'countertop') return;

            // Calculate other element bounds
            const otherLeft = other.x / pixelsPerFoot;
            const otherRight = otherLeft + other.width;
            const otherTop = other.y / pixelsPerFoot;
            const otherBottom = otherTop + other.height;

            // Check if backsplash is adjacent to or overlapping with countertop
            const overlapX = Math.max(0, Math.min(bsRight, otherRight) - Math.max(bsLeft, otherLeft));
            const adjacentY = Math.abs(bsBottom - otherTop) < 0.5 || Math.abs(bsTop - otherBottom) < 0.5;
            const overlapY = Math.max(0, Math.min(bsBottom, otherBottom) - Math.max(bsTop, otherTop));

            // Consider if there's any horizontal overlap and they're close in Y
            if (overlapX > 0.1 && (overlapY > 0 || adjacentY)) {
              // Calculate countertop's top surface directly (avoid recursive call)
              // Countertop thickness is typically 0.12 ft (1.44 inches)
              const counterThickness = 0.12;
              // Countertop base position is 2.9 ft (on cabinet), or on detected element
              const counterBaseHeight = 2.9; // Standard cabinet height
              const counterSurface = counterBaseHeight + counterThickness;
              if (counterSurface > counterSurfaceHeight) {
                counterSurfaceHeight = counterSurface;
              }
            }
          });

          // Use verticalHeight for actual backsplash height in 3D
          const bsVertHeight = el.verticalHeight || 1.5;

          if (counterSurfaceHeight > 0) {
            // Backsplash sits directly on top of countertop surface
            return counterSurfaceHeight + bsVertHeight / 2;
          }

          // Default: Standard counter surface (2.9 + 0.12 thick counter) + backsplash
          return 3.02 + bsVertHeight / 2;
        }

        case 'range-hood': {
          // Smart stacking: range hood sits above stove/range/cooktop
          const rhLeft = el.x / pixelsPerFoot;
          const rhRight = rhLeft + el.width;
          const rhTop = el.y / pixelsPerFoot;
          const rhBottom = rhTop + el.height;

          // Find stove/range/cooktop beneath this hood
          let applianceTopHeight = 3; // Default: top of stove surface

          elements.forEach(other => {
            if (other.id === el.id) return;

            const stoveTypes = ['stove', 'range', 'cooktop'];
            if (!stoveTypes.includes(other.type)) return;

            const otherLeft = other.x / pixelsPerFoot;
            const otherRight = otherLeft + other.width;
            const otherTop = other.y / pixelsPerFoot;
            const otherBottom = otherTop + other.height;

            // Check for overlap
            const overlapX = Math.max(0, Math.min(rhRight, otherRight) - Math.max(rhLeft, otherLeft));
            const overlapY = Math.max(0, Math.min(rhBottom, otherBottom) - Math.max(rhTop, otherTop));

            if (overlapX > 0.1 && overlapY > 0.1) {
              // Get the top of the appliance
              const appHeight = other.type === 'cooktop' ? 0.1 : 3; // Cooktop is thin, range is tall
              const appTop = other.type === 'cooktop' ? 3.02 + 0.05 : appHeight;
              if (appTop > applianceTopHeight) {
                applianceTopHeight = appTop;
              }
            }
          });

          // Range hood bottom is typically 24-30" above cooktop surface
          // Position hood 2 feet (24") above the cooking surface
          return applianceTopHeight + 2 + height / 2;
        }

        case 'microwave': {
          // Microwave positioned at wall cabinet height
          // Bottom aligns with wall cabinet bottoms at 54" (4.5 feet) from floor
          // This allows room for above-microwave-cabinet above it
          // Standard: wall cabinet bottom = 54", microwave fits below wall cabs
          // Wall cabinet height = 30-36", so tops at 84-90" (7-7.5 feet)
          // Microwave height typically 12-15" (1-1.25 feet)
          // Position bottom at 4.5 feet to align with wall cabinet bottoms

          const wallCabinetBottomHeight = 4.5; // 54 inches from floor (standard)

          // Return center position: bottom at 4.5ft + half the microwave height
          return wallCabinetBottomHeight + height / 2;
        }

        // Windows - use sillHeight property, fall back to construction standard
        case 'window':
        case 'window-large':
        case 'window-bay':
        case 'bay-window':
        case 'picture-window': {
          // sillHeight is the bottom edge from floor (in feet)
          const sillHeight = el.sillHeight !== undefined ? el.sillHeight : getDefaultSillHeight(type);
          return sillHeight + height / 2; // Position center based on sill
        }

        // Doors and archways - sill at floor level
        case 'door':
        case 'double-door':
        case 'sliding-door':
        case 'french-door':
        case 'glass-door':
        case 'entry-archway':
        case 'garage-door': {
          const doorSillHeight = el.sillHeight !== undefined ? el.sillHeight : getDefaultSillHeight(type);
          return doorSillHeight + height / 2;
        }

        case 'wall':
          return height / 2; // Wall sits on floor

        case 'tall-cabinet':
        case 'fridge-cabinet':
          return height / 2; // Tall cabinets and fridge cabinets sit on floor

        // Pony walls / half walls
        case 'pony-wall':
        case 'pony-wall-bar':
        case 'knee-wall':
          return height / 2; // Sits on floor

        // Niches (typically mounted in wall, use height property)
        case 'wall-niche':
        case 'shower-niche': {
          // Shower niches typically at eye level (~4-5ft)
          return el.nicheFloorHeight !== undefined ? el.nicheFloorHeight + height / 2 : 4 + height / 2;
        }
        case 'fireplace-niche':
        case 'tv-niche': {
          // Fireplace/TV at comfortable viewing height
          return el.nicheFloorHeight !== undefined ? el.nicheFloorHeight + height / 2 : 2 + height / 2;
        }

        // Stone surfaces
        case 'wall-cap':
        case 'bar-top': {
          // Position cap at top of wall it sits on
          // If capHeight is not set, try to find a nearby pony wall to match its height
          let capHeight = el.capHeight;
          if (capHeight === undefined) {
            // Look for overlapping pony wall to inherit height from
            const ponyWallTypes = ['pony-wall', 'pony-wall-bar', 'knee-wall'];
            const capCenterX = el.x / pixelsPerFoot + el.width / 2;
            const capCenterY = el.y / pixelsPerFoot + el.height / 2;

            const nearbyWall = elements.find(other => {
              if (!ponyWallTypes.includes(other.type)) return false;
              const wallCenterX = other.x / pixelsPerFoot + other.width / 2;
              const wallCenterY = other.y / pixelsPerFoot + other.height / 2;
              const distX = Math.abs(capCenterX - wallCenterX);
              const distY = Math.abs(capCenterY - wallCenterY);
              // Check if cap overlaps with wall (within 1 foot tolerance)
              return distX < (el.width + other.width) / 2 + 0.5 &&
                     distY < (el.height + other.height) / 2 + 0.5;
            });

            if (nearbyWall) {
              capHeight = nearbyWall.wallHeight || (nearbyWall.type === 'knee-wall' ? 2.5 : 3.5);
            } else {
              // Default to standard pony wall height (3.5 ft = 42 inches)
              capHeight = 3.5;
            }
          }
          return capHeight + height / 2;
        }

        // Work surfaces (countertop alternatives) - positioned at counter height
        case 'surface-stainless':
        case 'surface-solid':
        case 'surface-laminate':
        case 'surface-butcherblock':
        case 'surface-concrete':
          // These sit at standard counter height (on top of base cabinets)
          return 2.9 + height / 2;

        case 'fireplace-hearth':
        case 'threshold':
          return height / 2; // Floor level
        case 'window-sill': {
          // Window sill follows window sillHeight
          const windowSill = el.sillHeight !== undefined ? el.sillHeight : 2;
          return windowSill;
        }
        case 'mantel':
          return 4 + height / 2; // Above fireplace opening
        case 'fireplace-surround':
        case 'niche-surround':
          return 2.5 + height / 2; // Centered around opening

        // ADA grab bars (33-36" from floor per ADA guidelines)
        case 'grab-bar':
          return el.mountHeight !== undefined ? el.mountHeight + height / 2 : 2.875 + height / 2;

        // Structural beams - positioned at ceiling level (bottom of beam touches ceiling)
        case 'steel-beam':
        case 'wood-beam':
        case 'concrete-beam':
        case 'header':
        case 'lvl-beam': {
          // Beams hang from ceiling - use beamElevation if set, otherwise at ceiling
          const ceilingHeight = roomHeight || 8;
          const beamElevation = el.beamElevation !== undefined ? el.beamElevation : ceilingHeight;
          return beamElevation - height / 2; // Bottom of beam at elevation
        }

        // Structural columns - floor to ceiling
        case 'steel-column':
        case 'wood-post':
        case 'concrete-column':
          return height / 2; // Column sits on floor

        // Bathroom elements - floor standing
        case 'toilet':
        case 'bathtub':
        case 'bathtub-freestanding':
        case 'vanity-24':
        case 'vanity-30':
        case 'vanity-36':
        case 'vanity-48':
        case 'vanity-60':
        case 'vanity-72':
        case 'shower-bench':
          return height / 2; // Floor standing

        case 'towel-warmer':
          return el.mountHeight !== undefined ? el.mountHeight + height / 2 : 3 + height / 2; // Wall mounted ~36" up

        // Laundry elements - floor standing
        case 'washer':
        case 'dryer':
        case 'utility-sink':
        case 'laundry-sink':
        case 'drying-rack':
          return height / 2; // Floor standing

        // Closet elements
        case 'closet-rod':
        case 'tie-rack':
          return el.mountHeight !== undefined ? el.mountHeight + height / 2 : 5.5 + height / 2; // ~66" from floor

        case 'closet-shelf':
          return el.mountHeight !== undefined ? el.mountHeight + height / 2 : 6 + height / 2; // Above rod

        case 'full-mirror':
          return el.mountHeight !== undefined ? el.mountHeight + height / 2 : 3 + height / 2; // Center at ~36" from floor

        case 'drawer-unit':
        case 'closet-drawers':
        case 'shoe-rack':
        case 'closet-island':
        case 'jewelry-cabinet':
        case 'jewelry-drawer':
          return height / 2; // Floor standing

        // Bathroom accessories - wall mounted
        case 'mirror':
          return el.mountHeight !== undefined ? el.mountHeight + height / 2 : 4.5 + height / 2; // ~54" from floor (eye level)

        case 'medicine-cabinet':
          return el.mountHeight !== undefined ? el.mountHeight + height / 2 : 4.5 + height / 2; // ~54" from floor

        case 'towel-bar':
          return el.mountHeight !== undefined ? el.mountHeight + height / 2 : 4 + height / 2; // ~48" from floor

        case 'grab-bar-24':
        case 'grab-bar-36':
        case 'grab-bar-42':
          // ADA grab bars - typically 33-36" from floor for toilet, higher for shower
          return el.mountHeight !== undefined ? el.mountHeight + height / 2 : 2.8 + height / 2; // ~33" from floor

        case 'toilet-paper':
          return el.mountHeight !== undefined ? el.mountHeight + height / 2 : 2.2 + height / 2; // ~26" from floor (seated reach)

        case 'shower-glass':
        case 'shower-door':
          return height / 2; // Floor standing (full height panels)

        case 'microwave-cabinet':
          // Wall-mounted microwave cabinet - bottom typically at counter height (~3ft)
          return el.mountHeight !== undefined ? el.mountHeight + height / 2 : 3 + height / 2;

        default:
          return height / 2; // Default: bottom on floor
      }
    }

    // ===== LRU TEXTURE CACHE WITH GARBAGE COLLECTION =====
    // Configuration
    const TEXTURE_CACHE_MAX_SIZE = 100; // Maximum textures to keep
    const TEXTURE_CACHE_CLEANUP_SIZE = 20; // Remove this many when full

    // LRU Cache for loaded 3D textures
    const textureCache3D = {};
    const textureCacheOrder = []; // Track access order for LRU
    let textureCacheStats = { hits: 0, misses: 0, evictions: 0 };

    /**
     * Get texture from cache (updates LRU order)
     */
    function getTextureFromCache(url) {
      if (textureCache3D[url]) {
        textureCacheStats.hits++;
        // Move to end of LRU order (most recently used)
        const idx = textureCacheOrder.indexOf(url);
        if (idx > -1) {
          textureCacheOrder.splice(idx, 1);
          textureCacheOrder.push(url);
        }
        return textureCache3D[url];
      }
      textureCacheStats.misses++;
      return null;
    }

    /**
     * Add texture to cache with LRU eviction
     */
    function addTextureToCache(url, texture) {
      // Check if we need to evict old textures
      if (textureCacheOrder.length >= TEXTURE_CACHE_MAX_SIZE) {
        evictOldTextures();
      }

      // Add to cache
      textureCache3D[url] = texture;
      textureCacheOrder.push(url);
    }

    /**
     * Evict least recently used textures
     */
    function evictOldTextures() {
      const toRemove = Math.min(TEXTURE_CACHE_CLEANUP_SIZE, textureCacheOrder.length);

      for (let i = 0; i < toRemove; i++) {
        const url = textureCacheOrder.shift();
        if (url && textureCache3D[url]) {
          // Dispose the texture to free GPU memory
          if (textureCache3D[url].dispose) {
            textureCache3D[url].dispose();
          }
          delete textureCache3D[url];
          textureCacheStats.evictions++;
        }
      }

      console.log(`Texture cache GC: evicted ${toRemove} textures. Stats:`, textureCacheStats);
    }

    /**
     * Clear entire texture cache
     */
    function clearTextureCache() {
      textureCacheOrder.forEach(url => {
        if (textureCache3D[url] && textureCache3D[url].dispose) {
          textureCache3D[url].dispose();
        }
        delete textureCache3D[url];
      });
      textureCacheOrder.length = 0;
      textureCacheStats = { hits: 0, misses: 0, evictions: 0 };
    }

    /**
     * Get cache statistics
     */
    function getTextureCacheStats() {
      return {
        ...textureCacheStats,
        size: textureCacheOrder.length,
        maxSize: TEXTURE_CACHE_MAX_SIZE,
        hitRate: textureCacheStats.hits / (textureCacheStats.hits + textureCacheStats.misses) || 0
      };
    }

    // ===== GEOMETRY POOLING FOR PERFORMANCE =====
    // Reuses geometries for elements with same dimensions
    const geometryPool = new Map();
    let geometryPoolStats = { hits: 0, misses: 0, poolSize: 0 };

    /**
     * Get or create a BoxGeometry from the pool
     * @param {number} width - Box width
     * @param {number} height - Box height
     * @param {number} depth - Box depth
     * @returns {THREE.BoxGeometry} Cached or new geometry
     */
    function getPooledBoxGeometry(width, height, depth) {
      // Round to 2 decimal places for consistent keys
      const w = Math.round(width * 100) / 100;
      const h = Math.round(height * 100) / 100;
      const d = Math.round(depth * 100) / 100;
      const key = `box_${w}_${h}_${d}`;

      if (geometryPool.has(key)) {
        geometryPoolStats.hits++;
        return geometryPool.get(key);
      }

      // Create new geometry and cache it
      const geometry = new THREE.BoxGeometry(w, h, d);
      geometryPool.set(key, geometry);
      geometryPoolStats.misses++;
      geometryPoolStats.poolSize = geometryPool.size;

      return geometry;
    }

    /**
     * Get or create a PlaneGeometry from the pool
     */
    function getPooledPlaneGeometry(width, height) {
      const w = Math.round(width * 100) / 100;
      const h = Math.round(height * 100) / 100;
      const key = `plane_${w}_${h}`;

      if (geometryPool.has(key)) {
        geometryPoolStats.hits++;
        return geometryPool.get(key);
      }

      const geometry = new THREE.PlaneGeometry(w, h);
      geometryPool.set(key, geometry);
      geometryPoolStats.misses++;
      geometryPoolStats.poolSize = geometryPool.size;

      return geometry;
    }

    /**
     * Get geometry pool statistics
     */
    function getGeometryPoolStats() {
      return {
        ...geometryPoolStats,
        hitRate: geometryPoolStats.hits / (geometryPoolStats.hits + geometryPoolStats.misses) || 0
      };
    }

    /**
     * Clear geometry pool (call on cleanup)
     */
    function clearGeometryPool() {
      geometryPool.forEach(geometry => {
        if (geometry.dispose) geometry.dispose();
      });
      geometryPool.clear();
      geometryPoolStats = { hits: 0, misses: 0, poolSize: 0 };
    }

    const textureLoader = new THREE.TextureLoader();
    textureLoader.setCrossOrigin('anonymous');

    // Helper to adjust color brightness (works with numeric colors)
    // Moved to module level for performance - used frequently in 3D rendering
    function adjustColorBrightness(col, amount) {
      const r = Math.max(0, Math.min(255, ((col >> 16) & 0xFF) + amount));
      const g = Math.max(0, Math.min(255, ((col >> 8) & 0xFF) + amount));
      const b = Math.max(0, Math.min(255, (col & 0xFF) + amount));
      return (r << 16) | (g << 8) | b;
    }

    // Cache for 2D-rendered textures
    const texture2DCache = {};

    /**
     * Render a 2D element view to a canvas texture for use in 3D
     * This allows using the cleaner 2D appearance in the 3D view
     * @param {Object} el - The element to render
     * @param {number} canvasWidth - Canvas width in pixels
     * @param {number} canvasHeight - Canvas height in pixels
     * @returns {THREE.CanvasTexture} The texture for use in 3D materials
     */
    function render2DElementToTexture(el, canvasWidth = 256, canvasHeight = 256) {
      // Use cached texture if available
      const cacheKey = `${el.id}_${el.type}_${canvasWidth}x${canvasHeight}`;
      if (texture2DCache[cacheKey]) {
        return texture2DCache[cacheKey];
      }

      // Create offscreen canvas
      const canvas = document.createElement('canvas');
      canvas.width = canvasWidth;
      canvas.height = canvasHeight;
      const ctx = canvas.getContext('2d');

      // Set up drawing context
      ctx.fillStyle = el.color || '#808080';
      ctx.strokeStyle = '#333';
      ctx.lineWidth = 2;

      const x = 0;
      const y = 0;
      const w = canvasWidth;
      const h = canvasHeight;
      const padding = Math.min(w, h) * 0.08;

      // Fill background
      ctx.fillRect(x, y, w, h);

      // Draw element-specific details based on type
      switch (el.type) {
        case 'sink':
        case 'sink-double':
        case 'sink-farmhouse': {
          const isDouble = el.type === 'sink-double';
          const isFarmhouse = el.type === 'sink-farmhouse';
          const basinPadding = Math.min(w, h) * 0.12;

          // Background - sink body color
          ctx.fillStyle = isFarmhouse ? '#F5F5DC' : '#C0C0C0';
          ctx.fillRect(x, y, w, h);

          // Outer rim
          ctx.strokeStyle = isFarmhouse ? 'rgba(200,180,140,0.9)' : 'rgba(180,180,180,0.9)';
          ctx.lineWidth = isFarmhouse ? 6 : 3;
          ctx.strokeRect(x + basinPadding/2, y + basinPadding/2, w - basinPadding, h - basinPadding);

          if (isDouble) {
            // Double basin
            const basinW = (w - basinPadding * 2 - 8) / 2;
            // Left basin
            ctx.fillStyle = 'rgba(50,50,50,0.5)';
            ctx.fillRect(x + basinPadding, y + basinPadding, basinW, h - basinPadding * 2);
            // Right basin
            ctx.fillRect(x + basinPadding + basinW + 8, y + basinPadding, basinW, h - basinPadding * 2);
            // Divider
            ctx.fillStyle = 'rgba(180,180,180,0.7)';
            ctx.fillRect(x + w/2 - 4, y + basinPadding, 8, h - basinPadding * 2);
            // Drains
            ctx.fillStyle = 'rgba(40,40,40,0.8)';
            ctx.beginPath();
            ctx.arc(x + basinPadding + basinW/2, y + h/2, Math.min(w, h) * 0.06, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x + w - basinPadding - basinW/2, y + h/2, Math.min(w, h) * 0.06, 0, Math.PI * 2);
            ctx.fill();
          } else {
            // Single basin
            ctx.fillStyle = isFarmhouse ? 'rgba(245,245,220,0.6)' : 'rgba(50,50,50,0.5)';
            ctx.fillRect(x + basinPadding, y + basinPadding, w - basinPadding * 2, h - basinPadding * 2);
            // Inner basin shadow
            ctx.fillStyle = isFarmhouse ? 'rgba(200,180,140,0.35)' : 'rgba(30,30,30,0.35)';
            ctx.fillRect(x + basinPadding + 6, y + basinPadding + 6, w - basinPadding * 2 - 12, h - basinPadding * 2 - 12);
            // Drain
            ctx.fillStyle = 'rgba(40,40,40,0.8)';
            ctx.beginPath();
            ctx.arc(x + w/2, y + h/2 + 8, Math.min(w, h) * 0.07, 0, Math.PI * 2);
            ctx.fill();
          }

          // Faucet (centered at back)
          ctx.fillStyle = 'rgba(210,210,210,0.95)';
          ctx.fillRect(x + w/2 - 12, y + basinPadding/2 - 8, 24, 12);
          // Faucet spout
          ctx.beginPath();
          ctx.arc(x + w/2, y + basinPadding/2 - 8, 12, Math.PI, 0);
          ctx.fill();
          // Handles
          ctx.fillStyle = 'rgba(190,190,190,0.9)';
          ctx.beginPath();
          ctx.arc(x + w/2 - 30, y + basinPadding/2, 7, 0, Math.PI * 2);
          ctx.fill();
          ctx.beginPath();
          ctx.arc(x + w/2 + 30, y + basinPadding/2, 7, 0, Math.PI * 2);
          ctx.fill();
          break;
        }

        case 'stove':
        case 'range':
        case 'cooktop': {
          // Background - stove surface
          ctx.fillStyle = '#2a2a2a';
          ctx.fillRect(x, y, w, h);

          // Draw stove burners
          ctx.strokeStyle = 'rgba(60,60,60,0.9)';
          ctx.lineWidth = 3;
          const burnerRadius = Math.min(w, h) * 0.16;
          const positions = [
            [x + w * 0.3, y + h * 0.38],
            [x + w * 0.7, y + h * 0.38],
            [x + w * 0.3, y + h * 0.72],
            [x + w * 0.7, y + h * 0.72]
          ];
          positions.forEach(([bx, by]) => {
            // Outer ring
            ctx.beginPath();
            ctx.arc(bx, by, burnerRadius, 0, Math.PI * 2);
            ctx.stroke();
            // Inner ring
            ctx.beginPath();
            ctx.arc(bx, by, burnerRadius * 0.6, 0, Math.PI * 2);
            ctx.stroke();
            // Grate lines
            ctx.beginPath();
            ctx.moveTo(bx - burnerRadius, by);
            ctx.lineTo(bx + burnerRadius, by);
            ctx.moveTo(bx, by - burnerRadius);
            ctx.lineTo(bx, by + burnerRadius);
            ctx.stroke();
          });
          // Control panel area
          ctx.fillStyle = 'rgba(50,50,50,0.7)';
          ctx.fillRect(x + padding, y + padding, w - padding * 2, h * 0.12);
          break;
        }

        case 'refrigerator': {
          // Background
          ctx.fillStyle = '#D0D0D0';
          ctx.fillRect(x, y, w, h);

          ctx.strokeStyle = 'rgba(150,150,150,0.6)';
          ctx.lineWidth = 3;
          const fridgeMid = y + h * 0.65;
          // Upper section (freezer)
          ctx.strokeRect(x + padding, y + padding, w - padding * 2, fridgeMid - y - padding * 1.5);
          // Lower section (fridge)
          ctx.strokeRect(x + padding, fridgeMid, w - padding * 2, y + h - fridgeMid - padding);
          // Handles
          ctx.fillStyle = 'rgba(200,200,200,0.7)';
          ctx.fillRect(x + w - padding - 8, y + (fridgeMid - y) / 2 - 15, 4, 30);
          ctx.fillRect(x + w - padding - 8, fridgeMid + (y + h - fridgeMid) / 2 - 18, 4, 36);
          break;
        }

        case 'dishwasher': {
          ctx.fillStyle = '#E0E0E0';
          ctx.fillRect(x, y, w, h);
          ctx.strokeStyle = 'rgba(150,150,150,0.6)';
          ctx.lineWidth = 2;
          ctx.strokeRect(x + padding, y + padding, w - padding * 2, h - padding * 2);
          // Handle
          ctx.fillStyle = 'rgba(180,180,180,0.8)';
          ctx.fillRect(x + w * 0.2, y + padding + 5, w * 0.6, 6);
          break;
        }

        default:
          // Default: just fill with color
          ctx.fillStyle = el.color || '#808080';
          ctx.fillRect(x, y, w, h);
      }

      // Create Three.js texture from canvas
      const texture = new THREE.CanvasTexture(canvas);
      texture.wrapS = THREE.ClampToEdgeWrapping;
      texture.wrapT = THREE.ClampToEdgeWrapping;
      texture.encoding = THREE.sRGBEncoding;
      texture.needsUpdate = true;

      // Cache the texture
      texture2DCache[cacheKey] = texture;

      return texture;
    }

    /**
     * Create a 3D element using 2D texture rendering (simpler, cleaner look)
     * @param {Object} el - The element to create
     * @param {number} w - Width in feet
     * @param {number} h - 3D height in feet
     * @param {number} d - Depth in feet
     * @returns {THREE.Group} The 3D group containing the element
     */
    function create3DElementWith2DTexture(el, w, h, d) {
      const group = new THREE.Group();

      // Render 2D appearance to texture (higher res for quality)
      const textureSize = 512;
      const texture = render2DElementToTexture(el, textureSize, textureSize);

      // Get base color for sides
      let sideColor = 0x808080;
      const typeColors = {
        'sink': 0xC0C0C0,
        'sink-double': 0xC0C0C0,
        'sink-farmhouse': 0xF5F5DC,
        'stove': 0x2a2a2a,
        'range': 0x2a2a2a,
        'cooktop': 0x2a2a2a,
        'refrigerator': 0xD0D0D0,
        'dishwasher': 0xE0E0E0
      };
      sideColor = typeColors[el.type] || sideColor;

      // Create material with the 2D texture for top face
      const topMaterial = new THREE.MeshStandardMaterial({
        map: texture,
        roughness: 0.5,
        metalness: 0.15
      });

      // Create material for sides (solid color matching the element type)
      const sideMaterial = new THREE.MeshStandardMaterial({
        color: sideColor,
        roughness: 0.6,
        metalness: 0.1
      });

      // Materials array: [right, left, top, bottom, front, back]
      // For a countertop-level element, the TOP (index 2) shows the 2D texture
      const materials = [
        sideMaterial,  // right (+X)
        sideMaterial,  // left (-X)
        topMaterial,   // top (+Y) - this shows the 2D appearance
        sideMaterial,  // bottom (-Y)
        sideMaterial,  // front (+Z)
        sideMaterial   // back (-Z)
      ];

      // Create the main box geometry
      const boxGeo = new THREE.BoxGeometry(w, h, d);

      // Create mesh with multi-material
      const mesh = new THREE.Mesh(boxGeo, materials);
      mesh.castShadow = true;
      mesh.receiveShadow = true;
      group.add(mesh);

      return group;
    }

    // Configuration for which elements should use 2D-style 3D rendering
    const use2DStyleFor3D = {
      // Sinks removed - use detailed 3D rendering for undermount/topmount toggle
      'stove': true,
      'range': true,
      'cooktop': true,
      'refrigerator': true,
      'dishwasher': true
    };

    // Preload textures for elements that have them
    function preload3DTextures() {
      const textureUrls = new Set();
      elements.forEach(el => {
        if (el.texture) textureUrls.add(el.texture);
        if (el.storeProduct?.image) textureUrls.add(el.storeProduct.image);
      });

      textureUrls.forEach(url => {
        if (!getTextureFromCache(url)) {
          console.log('Preloading texture:', url.substring(0, 50) + '...');
          textureLoader.load(url, (texture) => {
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.encoding = THREE.sRGBEncoding;
            addTextureToCache(url, texture);
            console.log('Preloaded texture successfully:', url.substring(0, 50) + '...');
          }, undefined, (err) => {
            console.warn('Failed to preload texture:', url, err);
          });
        }
      });
    }

    function create3DElement(el) {
      const w = el.width;
      const d = el.height; // In 2D, height is depth in 3D
      const h = get3DHeight(el);

      // Parse color
      let color = el.color || '#808080';
      if (typeof color === 'string') {
        if (color.startsWith('#')) {
          color = parseInt(color.replace('#', ''), 16);
        } else if (color.startsWith('rgb')) {
          const match = color.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
          if (match) {
            color = (parseInt(match[1]) << 16) | (parseInt(match[2]) << 8) | parseInt(match[3]);
          } else {
            color = 0x808080;
          }
        } else {
          color = parseInt(color, 16) || 0x808080;
        }
      }

      const group = new THREE.Group();

      // Check if this element should use 2D-style 3D rendering
      // This provides cleaner visuals matching the 2D view
      if (use2DStyleFor3D[el.type] && !el.use3DDetailedRender) {
        const texturedGroup = create3DElementWith2DTexture(el, w, h, d);
        // Position the group correctly
        if (texturedGroup && texturedGroup.children) {
          texturedGroup.children.forEach(child => {
            child.position.y = h / 2; // Lift so bottom is at y=0
          });
        }
        // Return in the expected { group, height } format
        return { group: texturedGroup || group, height: h };
      }

      // Helper to create high-quality metallic hardware materials (handles, knobs, faucets)
      // Uses proper environment mapping for realistic reflections
      function createMetalMaterial(finish = 'brushed-nickel') {
        const metalFinishes = {
          'chrome': { color: 0xE8E8E8, roughness: 0.05, metalness: 0.98, envIntensity: 1.8 },
          'polished-chrome': { color: 0xF5F5F5, roughness: 0.02, metalness: 1.0, envIntensity: 2.0 },
          'brushed-nickel': { color: 0xC0C0C0, roughness: 0.2, metalness: 0.9, envIntensity: 1.2 },
          'satin-nickel': { color: 0xB8B8B8, roughness: 0.25, metalness: 0.85, envIntensity: 1.0 },
          'stainless': { color: 0xD0D0D0, roughness: 0.15, metalness: 0.92, envIntensity: 1.4 },
          'matte-black': { color: 0x2A2A2A, roughness: 0.4, metalness: 0.7, envIntensity: 0.5 },
          'oil-rubbed-bronze': { color: 0x3D2B1F, roughness: 0.35, metalness: 0.6, envIntensity: 0.6 },
          'antique-brass': { color: 0xB5A642, roughness: 0.3, metalness: 0.75, envIntensity: 0.8 },
          'polished-brass': { color: 0xD4AF37, roughness: 0.1, metalness: 0.9, envIntensity: 1.5 },
          'gold': { color: 0xFFD700, roughness: 0.08, metalness: 0.95, envIntensity: 1.6 },
          'copper': { color: 0xB87333, roughness: 0.2, metalness: 0.85, envIntensity: 1.2 }
        };

        const config = metalFinishes[finish] || metalFinishes['brushed-nickel'];

        const material = new THREE.MeshStandardMaterial({
          color: config.color,
          roughness: config.roughness,
          metalness: config.metalness,
          envMap: window.roomEnvMap || null,
          envMapIntensity: config.envIntensity
        });

        return material;
      }

      // Helper to create realistic edge profile geometry for countertops
      function createEdgeProfile(width, thickness, profile = 'eased') {
        const profiles = {
          'eased': { bevel: 0.02, rounded: true },
          'bullnose': { bevel: thickness / 2, rounded: true },
          'half-bullnose': { bevel: thickness / 3, rounded: true },
          'ogee': { bevel: 0.04, curved: true },
          'bevel': { bevel: 0.03, angled: true },
          'dupont': { bevel: 0.025, curved: true },
          'waterfall': { bevel: 0, rounded: false }, // Perfect 90 corner - NO bevel for waterfall
          'square': { bevel: 0, rounded: false }
        };

        const p = profiles[profile] || profiles['eased'];
        const shape = new THREE.Shape();

        // Create edge profile shape
        if (p.rounded && p.bevel > 0) {
          // Rounded edge (bullnose, eased)
          shape.moveTo(0, 0);
          shape.lineTo(width, 0);
          shape.lineTo(width, thickness - p.bevel);
          shape.quadraticCurveTo(width, thickness, width - p.bevel, thickness);
          shape.lineTo(p.bevel, thickness);
          shape.quadraticCurveTo(0, thickness, 0, thickness - p.bevel);
          shape.lineTo(0, 0);
        } else if (p.angled && p.bevel > 0) {
          // Beveled edge (chamfer)
          shape.moveTo(0, p.bevel);
          shape.lineTo(p.bevel, 0);
          shape.lineTo(width - p.bevel, 0);
          shape.lineTo(width, p.bevel);
          shape.lineTo(width, thickness);
          shape.lineTo(0, thickness);
          shape.lineTo(0, p.bevel);
        } else {
          // Square edge
          shape.moveTo(0, 0);
          shape.lineTo(width, 0);
          shape.lineTo(width, thickness);
          shape.lineTo(0, thickness);
          shape.lineTo(0, 0);
        }

        return shape;
      }

      // Load and apply texture to countertop material with enhanced quality settings
      function loadCountertopTexture(material, textureUrl, options, hdMode = false) {
        // Resolve relative URLs to absolute
        let fullUrl = textureUrl;
        if (textureUrl.startsWith('/') && !textureUrl.startsWith('//')) {
          fullUrl = window.location.origin + textureUrl;
        } else if (!textureUrl.startsWith('http') && !textureUrl.startsWith('data:')) {
          fullUrl = window.location.origin + '/' + textureUrl;
        }

        // Standard granite/quartz slab: 120" x 60" = 10ft x 5ft
        const slabWidthFt = 10;
        const slabDepthFt = 5;

        // Calculate texture repeat based on countertop dimensions
        let repeatX = 1, repeatY = 1;
        if (options.width && options.depth) {
          repeatX = options.width / slabWidthFt;
          repeatY = options.depth / slabDepthFt;
          repeatX = Math.max(0.3, repeatX);
          repeatY = Math.max(0.3, repeatY);
        }

        // Check texture cache (uses LRU cache)
        const cachedTexture = getTextureFromCache(fullUrl) || getTextureFromCache(textureUrl);

        const applyTexture = (texture) => {
          texture.wrapS = THREE.RepeatWrapping;
          texture.wrapT = THREE.RepeatWrapping;
          texture.repeat.set(repeatX, repeatY);
          texture.colorSpace = THREE.SRGBColorSpace; // Updated for Three.js r152+
          // Maximum anisotropy for sharp textures at viewing angles
          texture.anisotropy = renderer ? renderer.capabilities.getMaxAnisotropy() : 16;
          texture.minFilter = THREE.LinearMipmapLinearFilter;
          texture.magFilter = THREE.LinearFilter;
          texture.generateMipmaps = true;

          material.map = texture;
          material.color.setHex(0xFFFFFF); // Pure white base for accurate texture colors

          // Normal map from texture for realistic surface depth
          // Use bumpMap instead of normalMap to avoid shader issues
          if (options.enableBumpMap !== false) {
            material.bumpMap = texture;
            material.bumpScale = 0.02; // Subtle depth effect
          }

          // In HD mode, also add roughness variation
          if (hdMode && material.roughnessMap !== undefined) {
            material.roughnessMap = texture;
            material.roughness = Math.max(0.05, material.roughness);
          }

          material.needsUpdate = true;

          // Re-render will happen in animation loop, don't call directly here
          // to avoid WebGL context issues
        };

        if (cachedTexture) {
          const clonedTexture = cachedTexture.clone();
          clonedTexture.needsUpdate = true;
          applyTexture(clonedTexture);
        } else {
          textureLoader.load(fullUrl, (texture) => {
            // Cache texture using LRU cache
            addTextureToCache(fullUrl, texture);
            if (textureUrl !== fullUrl) {
              addTextureToCache(textureUrl, texture);
            }
            applyTexture(texture);
          },
          undefined,
          (err) => {
            console.warn('Countertop texture load failed:', textureUrl);
            material.color.setHex(options.baseColor || 0x808080);
            material.needsUpdate = true;
          });
        }
      }

      // Helper to create material with optional texture
      function createTexturedMaterial(baseColor, textureUrl, options = {}) {
        // Material settings optimized for accurate color reproduction
        // Uses MeshPhysicalMaterial for countertops (clearcoat, sheen) for realistic stone

        // Determine material type for optimal settings
        const isStone = options.isStone || options.materialType === 'stone';
        const isPolished = options.finish === 'polished' || options.roughness < 0.3;
        const isCountertop = options.isCountertop || false;
        const hdMode = window.hdRenderMode || false; // High-definition mode toggle

        // Detect if this is a light/white colored surface for enhanced definition
        const colorHex = typeof baseColor === 'number' ? baseColor : parseInt(baseColor.replace('#', ''), 16);
        const r = (colorHex >> 16) & 255;
        const g = (colorHex >> 8) & 255;
        const b = colorHex & 255;
        const brightness = (r + g + b) / 3;
        const isLightColored = brightness > 180;
        const isDarkColored = brightness < 80;

        // Finish-specific settings for realistic stone appearance
        const finishSettings = {
          polished: { roughness: 0.08, clearcoat: 0.2, clearcoatRoughness: 0.2, sheen: 0.3 },
          honed: { roughness: 0.45, clearcoat: 0.1, clearcoatRoughness: 0.6, sheen: 0.1 },
          leathered: { roughness: 0.7, clearcoat: 0.05, clearcoatRoughness: 0.8, sheen: 0.5 },
          brushed: { roughness: 0.55, clearcoat: 0.08, clearcoatRoughness: 0.7, sheen: 0.2 },
          flamed: { roughness: 0.8, clearcoat: 0, clearcoatRoughness: 1, sheen: 0 },
          natural: { roughness: 0.6, clearcoat: 0.05, clearcoatRoughness: 0.9, sheen: 0.1 },
          matte: { roughness: 0.5, clearcoat: 0.02, clearcoatRoughness: 0.9, sheen: 0.05 }
        };

        const finish = options.finish || 'polished';
        const settings = finishSettings[finish] || finishSettings.polished;

        // Adjust for light/dark colors
        let adjustedRoughness = settings.roughness;
        if (isLightColored) adjustedRoughness = Math.min(settings.roughness + 0.05, 0.5);
        if (isDarkColored) adjustedRoughness = Math.max(settings.roughness - 0.02, 0.05);

        // Use MeshPhysicalMaterial for countertops - supports clearcoat for sealed stone look
        if (isCountertop) {
          try {
            const physicalMatOptions = {
              color: textureUrl ? 0xFFFFFF : baseColor,
              roughness: options.roughness !== undefined ? options.roughness : adjustedRoughness,
              metalness: 0.0, // Stone is not metallic
              clearcoat: settings.clearcoat,
              clearcoatRoughness: settings.clearcoatRoughness,
              side: options.side || THREE.FrontSide,
              flatShading: false
            };

            if (options.transparent) physicalMatOptions.transparent = options.transparent;
            if (options.opacity !== undefined) physicalMatOptions.opacity = options.opacity;

            const material = new THREE.MeshPhysicalMaterial(physicalMatOptions);

          // Environment map for reflections
          if (window.roomEnvMap) {
            material.envMap = window.roomEnvMap;
            // Adjust reflection based on finish and color
            if (finish === 'polished') {
              material.envMapIntensity = isLightColored ? 0.35 : 0.55;
            } else if (finish === 'honed') {
              material.envMapIntensity = 0.15;
            } else if (finish === 'leathered') {
              material.envMapIntensity = 0.08;
            } else {
              material.envMapIntensity = 0.25;
            }
          }

          // Texture loading for countertops
          if (textureUrl) {
            loadCountertopTexture(material, textureUrl, options, hdMode);
          }

          return material;
          } catch (physicalMatError) {
            console.warn('MeshPhysicalMaterial failed, falling back to standard:', physicalMatError);
            // Fall through to standard material below
          }
        }

        // Standard material for non-countertop elements (also used as fallback)
        // Apply finish-based roughness if a finish is specified and no explicit roughness given
        const finishRoughness = (options.finish && options.roughness === undefined) ? adjustedRoughness : undefined;
        const matOptions = {
          color: textureUrl ? 0xFFFFFF : baseColor,
          roughness: options.roughness !== undefined ? options.roughness : (finishRoughness !== undefined ? finishRoughness : 0.45),
          metalness: options.metalness !== undefined ? options.metalness : 0.02,
          side: options.side || THREE.FrontSide,
          flatShading: false
        };

        if (options.transparent) matOptions.transparent = options.transparent;
        if (options.opacity !== undefined) matOptions.opacity = options.opacity;

        const material = new THREE.MeshStandardMaterial(matOptions);

        // Apply environment reflection based on finish
        if (window.roomEnvMap) {
          if (options.finish) {
            material.envMap = window.roomEnvMap;
            material.envMapIntensity = finish === 'polished' ? 0.35 : (finish === 'honed' ? 0.12 : 0.08);
          } else if (isPolished) {
            material.envMap = window.roomEnvMap;
            material.envMapIntensity = 0.35;
          }
        }

        // Apply environment map for metallic surfaces
        if (window.roomEnvMap && matOptions.metalness > 0.3) {
          material.envMap = window.roomEnvMap;
          material.envMapIntensity = Math.min(0.8, matOptions.metalness * 1.0);
        }

        // Load texture if available
        if (textureUrl) {
          // Resolve relative URLs to absolute
          let fullUrl = textureUrl;
          if (textureUrl.startsWith('/') && !textureUrl.startsWith('//')) {
            fullUrl = window.location.origin + textureUrl;
          } else if (!textureUrl.startsWith('http') && !textureUrl.startsWith('data:')) {
            fullUrl = window.location.origin + '/' + textureUrl;
          }

          // Get texture dimensions for proper scaling (stone slabs are typically ~10ft x 5ft)
          // Standard granite/quartz slab: 120" x 60" = 10ft x 5ft
          const slabWidthFt = 10;
          const slabDepthFt = 5;

          // Calculate texture repeat based on countertop dimensions
          let repeatX = 1, repeatY = 1;
          if (options.width && options.depth && isCountertop) {
            // Scale texture to realistic stone pattern size
            repeatX = options.width / slabWidthFt;
            repeatY = options.depth / slabDepthFt;
            // Ensure minimum repeat for small surfaces (avoid stretched look)
            repeatX = Math.max(0.3, repeatX);
            repeatY = Math.max(0.3, repeatY);
          }

          // Check LRU cache with both URL variants
          const cachedTexture = getTextureFromCache(fullUrl) || getTextureFromCache(textureUrl);

          if (cachedTexture) {
            material.map = cachedTexture.clone();
            material.map.wrapS = THREE.RepeatWrapping;
            material.map.wrapT = THREE.RepeatWrapping;
            material.map.repeat.set(repeatX, repeatY);
            material.map.needsUpdate = true;
            material.color.setHex(0xFFFFFF);
            material.needsUpdate = true;

            // Generate bump map from texture for depth perception
            if (isCountertop && options.enableBumpMap !== false) {
              material.bumpMap = material.map;
              material.bumpScale = 0.015; // Subtle depth for stone grain
            }
          } else {
            // Load texture with optimized settings for maximum quality
            textureLoader.load(fullUrl, (texture) => {
              texture.wrapS = THREE.RepeatWrapping;
              texture.wrapT = THREE.RepeatWrapping;
              texture.repeat.set(repeatX, repeatY);
              texture.encoding = THREE.sRGBEncoding;
              // Maximum anisotropy for sharpest textures at angles
              texture.anisotropy = renderer ? renderer.capabilities.getMaxAnisotropy() : 16;
              // Use trilinear filtering for best quality
              texture.minFilter = THREE.LinearMipmapLinearFilter;
              texture.magFilter = THREE.LinearFilter;
              texture.generateMipmaps = true;

              // Cache using LRU cache
              addTextureToCache(fullUrl, texture);
              if (textureUrl !== fullUrl) {
                addTextureToCache(textureUrl, texture);
              }

              material.map = texture;
              material.color.setHex(0xFFFFFF);

              // Generate bump map from texture for depth perception on countertops
              if (isCountertop && options.enableBumpMap !== false) {
                material.bumpMap = texture;
                material.bumpScale = 0.015; // Subtle depth for stone grain
              }

              material.needsUpdate = true;

              // Re-render to show texture
              if (renderer && scene && camera) {
                renderer.render(scene, camera);
              }
            },
            undefined,
            (err) => {
              console.warn('Texture load failed:', textureUrl);
              // Keep the base color as fallback
              material.color.setHex(baseColor || 0x808080);
              material.needsUpdate = true;
              // Show subtle toast for texture loading issues
              if (typeof showToast === 'function') {
                showToast('Some textures may not display correctly', 'warning');
              }
            });
          }
        }

        return material;
      }

      // Get texture URL from element - check multiple sources
      let textureUrl = null;
      if (el.texture) {
        textureUrl = el.texture;
      } else if (el.textureImg && el.textureImg.src) {
        textureUrl = el.textureImg.src;
      } else if (el.storeProduct && el.storeProduct.image) {
        textureUrl = el.storeProduct.image;
      } else if (el.materialId && el.materialName) {
        // Try to find from store products
        const product = storeProducts.find(p => p.slug === el.materialId);
        if (product && product.primaryImage) {
          textureUrl = product.primaryImage;
          el.texture = textureUrl; // Cache for next time
        }
      } else if (elementTextures && elementTextures[el.type]) {
        textureUrl = elementTextures[el.type];
      }

      // Log texture status for debugging
      if (textureUrl) {
        console.log(`Element ${el.type} (${el.label || 'unnamed'}) has texture:`, textureUrl.substring(0, 60) + '...');
      }

      // === WOOD GRAIN TEXTURE GENERATOR ===
      // Creates procedural wood grain texture for cabinet materials
      // grainType: 'oak', 'walnut', 'cherry', 'maple', 'hickory', 'flat' (no grain)
      function createWoodGrainTexture(baseColor, grainIntensity = 0.15, grainType = 'oak') {
        const canvas = document.createElement('canvas');
        canvas.width = 1024;  // Higher resolution
        canvas.height = 1024;
        const ctx = canvas.getContext('2d');
        const size = 1024;

        // Parse base color to RGB
        const tempColor = new THREE.Color(baseColor);
        const r = Math.floor(tempColor.r * 255);
        const g = Math.floor(tempColor.g * 255);
        const b = Math.floor(tempColor.b * 255);

        // Fill with base color
        ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
        ctx.fillRect(0, 0, size, size);

        // FLAT/NO GRAIN - for painted finishes
        if (grainType === 'flat' || grainType === 'none' || grainType === 'painted') {
          // Just add subtle surface texture for painted look
          ctx.globalAlpha = 0.015;
          for (let i = 0; i < 3000; i++) {
            const nx = Math.random() * size;
            const ny = Math.random() * size;
            const shade = Math.random() > 0.5 ? 255 : 0;
            ctx.fillStyle = `rgb(${shade}, ${shade}, ${shade})`;
            ctx.fillRect(nx, ny, 1, 1);
          }
          // Add very subtle gradient for depth
          ctx.globalAlpha = 0.02;
          const paintGrad = ctx.createLinearGradient(0, 0, size, size);
          paintGrad.addColorStop(0, `rgba(255, 255, 255, 1)`);
          paintGrad.addColorStop(0.5, 'transparent');
          paintGrad.addColorStop(1, `rgba(0, 0, 0, 1)`);
          ctx.fillStyle = paintGrad;
          ctx.fillRect(0, 0, size, size);
          ctx.globalAlpha = 1;

          const texture = new THREE.CanvasTexture(canvas);
          texture.wrapS = THREE.RepeatWrapping;
          texture.wrapT = THREE.RepeatWrapping;
          texture.repeat.set(1, 1);
          texture.anisotropy = 16;
          texture.encoding = THREE.sRGBEncoding;
          texture.needsUpdate = true;
          return texture;
        }

        // Grain type configurations
        const grainConfigs = {
          oak: {
            lineCount: 100,
            lineThicknessMin: 1.0,
            lineThicknessMax: 3.5,
            waveFreqMin: 0.006,
            waveFreqMax: 0.012,
            waveAmpMin: 3,
            waveAmpMax: 10,
            secondaryLines: 50,
            knots: 2,
            colorVariation: 35,
            spacing: 'medium'
          },
          walnut: {
            lineCount: 150,
            lineThicknessMin: 0.5,
            lineThicknessMax: 2.0,
            waveFreqMin: 0.002,
            waveFreqMax: 0.005,
            waveAmpMin: 1,
            waveAmpMax: 3,
            secondaryLines: 80,
            knots: 1,
            colorVariation: 45,
            spacing: 'tight'
          },
          cherry: {
            lineCount: 80,
            lineThicknessMin: 0.3,
            lineThicknessMax: 1.5,
            waveFreqMin: 0.004,
            waveFreqMax: 0.008,
            waveAmpMin: 1,
            waveAmpMax: 4,
            secondaryLines: 40,
            knots: 0,
            colorVariation: 25,
            spacing: 'fine'
          },
          maple: {
            lineCount: 60,
            lineThicknessMin: 0.2,
            lineThicknessMax: 0.8,
            waveFreqMin: 0.003,
            waveFreqMax: 0.006,
            waveAmpMin: 0.5,
            waveAmpMax: 2,
            secondaryLines: 30,
            knots: 0,
            colorVariation: 15,
            spacing: 'very-fine'
          },
          hickory: {
            lineCount: 120,
            lineThicknessMin: 1.5,
            lineThicknessMax: 4.5,
            waveFreqMin: 0.008,
            waveFreqMax: 0.018,
            waveAmpMin: 5,
            waveAmpMax: 15,
            secondaryLines: 70,
            knots: 4,
            colorVariation: 55,
            spacing: 'dramatic'
          }
        };

        const config = grainConfigs[grainType] || grainConfigs.oak;

        // Add subtle base noise for texture
        ctx.globalAlpha = 0.03;
        for (let i = 0; i < 5000; i++) {
          const nx = Math.random() * size;
          const ny = Math.random() * size;
          const shade = Math.random() > 0.5 ? 255 : 0;
          ctx.fillStyle = `rgb(${shade}, ${shade}, ${shade})`;
          ctx.fillRect(nx, ny, 1, 1);
        }

        // Add primary wood grain lines (horizontal)
        ctx.globalAlpha = grainIntensity;
        for (let i = 0; i < config.lineCount; i++) {
          const y = (i / config.lineCount) * size + (Math.random() - 0.5) * 20;
          const thickness = config.lineThicknessMin + Math.random() * (config.lineThicknessMax - config.lineThicknessMin);
          const variation = (Math.random() - 0.5) * config.colorVariation;

          // Grain color - varied between lighter and darker
          const lightness = Math.random() > 0.6 ? 1 : -1;
          const grainR = Math.max(0, Math.min(255, r + (lightness * 15) + variation));
          const grainG = Math.max(0, Math.min(255, g + (lightness * 12) + variation));
          const grainB = Math.max(0, Math.min(255, b + (lightness * 8) + variation));

          ctx.strokeStyle = `rgb(${grainR}, ${grainG}, ${grainB})`;
          ctx.lineWidth = thickness;
          ctx.beginPath();

          // Organic wavy grain line with more natural curvature
          ctx.moveTo(0, y);
          const waveFreq = config.waveFreqMin + Math.random() * (config.waveFreqMax - config.waveFreqMin);
          const waveAmp = config.waveAmpMin + Math.random() * (config.waveAmpMax - config.waveAmpMin);

          // Different wave patterns per grain type
          for (let x = 0; x < size; x += 8) {
            let waveY;
            if (grainType === 'walnut') {
              // Walnut: straighter, tighter lines
              waveY = y + Math.sin(x * waveFreq + i * 0.3) * waveAmp * 0.5;
            } else if (grainType === 'hickory') {
              // Hickory: dramatic, irregular waves
              waveY = y + Math.sin(x * waveFreq + i * 0.7) * waveAmp +
                      Math.sin(x * 0.005 + i) * 5 +
                      (Math.random() - 0.5) * 3;
            } else if (grainType === 'cherry') {
              // Cherry: subtle, smooth waves
              waveY = y + Math.sin(x * waveFreq + i * 0.4) * waveAmp * 0.7;
            } else if (grainType === 'maple') {
              // Maple: very subtle, almost straight
              waveY = y + Math.sin(x * waveFreq + i * 0.2) * waveAmp * 0.3;
            } else {
              // Oak: classic wavy grain
              waveY = y + Math.sin(x * waveFreq + i * 0.5) * waveAmp + Math.sin(x * 0.003) * 3;
            }
            ctx.lineTo(x, waveY);
          }
          ctx.stroke();
        }

        // Add secondary finer grain lines
        ctx.globalAlpha = grainIntensity * 0.4;
        for (let i = 0; i < config.secondaryLines; i++) {
          const y = Math.random() * size;
          ctx.strokeStyle = `rgba(${Math.max(0, r - 30)}, ${Math.max(0, g - 25)}, ${Math.max(0, b - 20)}, 0.5)`;
          ctx.lineWidth = 0.5;
          ctx.beginPath();
          ctx.moveTo(0, y);
          for (let x = 0; x < size; x += 15) {
            const waveY = y + Math.sin(x * 0.015 + i) * 2;
            ctx.lineTo(x, waveY);
          }
          ctx.stroke();
        }

        // Add knots based on grain type
        if (config.knots > 0) {
          ctx.globalAlpha = grainIntensity * 0.6;
          for (let i = 0; i < config.knots; i++) {
            const kx = 100 + Math.random() * (size - 200);
            const ky = 100 + Math.random() * (size - 200);
            const kr = (grainType === 'hickory' ? 18 : 12) + Math.random() * 20;

            // Concentric rings for knot
            for (let ring = 0; ring < 5; ring++) {
              const ringR = kr - ring * 3;
              if (ringR < 2) break;
              ctx.strokeStyle = `rgba(${Math.max(0, r - 45 + ring * 5)}, ${Math.max(0, g - 40 + ring * 5)}, ${Math.max(0, b - 35 + ring * 5)}, ${0.4 - ring * 0.06})`;
              ctx.lineWidth = 1.5;
              ctx.beginPath();
              ctx.arc(kx, ky, ringR, 0, Math.PI * 2);
              ctx.stroke();
            }

            // Dark center
            const gradient = ctx.createRadialGradient(kx, ky, 0, kx, ky, kr * 0.3);
            gradient.addColorStop(0, `rgba(${Math.max(0, r - 60)}, ${Math.max(0, g - 55)}, ${Math.max(0, b - 50)}, 0.7)`);
            gradient.addColorStop(1, 'transparent');
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(kx, ky, kr * 0.3, 0, Math.PI * 2);
            ctx.fill();
          }
        }

        // Add subtle color variation (slightly warmer/cooler areas)
        ctx.globalAlpha = 0.04;
        const colorGrad = ctx.createLinearGradient(0, 0, size, size);
        colorGrad.addColorStop(0, `rgba(${Math.min(255, r + 15)}, ${Math.min(255, g + 10)}, ${b}, 1)`);
        colorGrad.addColorStop(0.5, 'transparent');
        colorGrad.addColorStop(1, `rgba(${Math.max(0, r - 10)}, ${Math.max(0, g - 5)}, ${Math.min(255, b + 5)}, 1)`);
        ctx.fillStyle = colorGrad;
        ctx.fillRect(0, 0, size, size);

        ctx.globalAlpha = 1;

        const texture = new THREE.CanvasTexture(canvas);
        texture.wrapS = THREE.RepeatWrapping;
        texture.wrapT = THREE.RepeatWrapping;
        // Adjust repeat based on grain type
        const repeatVal = grainType === 'maple' ? 1.2 : (grainType === 'hickory' ? 1.8 : 1.5);
        texture.repeat.set(repeatVal, repeatVal);
        texture.anisotropy = 16;  // Better quality at angles
        texture.encoding = THREE.sRGBEncoding;  // Correct color encoding for r128
        texture.needsUpdate = true;  // Ensure texture is uploaded to GPU
        return texture;
      }

      // === MODERN BAR HANDLE CREATOR ===
      // Creates realistic cabinet pull with standoffs - enhanced for better visibility
      function createModernBarHandle(length = 0.25, finish = 'brushed-nickel') {
        const handleGroup = new THREE.Group();

        // Handle finishes with enhanced metallic properties
        const finishes = {
          'brushed-nickel': { color: 0xB8B8B8, metalness: 0.92, roughness: 0.18 },
          'matte-black': { color: 0x1a1a1a, metalness: 0.75, roughness: 0.35 },
          'polished-chrome': { color: 0xE8E8E8, metalness: 0.98, roughness: 0.05 },
          'brass': { color: 0xD4AF37, metalness: 0.92, roughness: 0.15 },
          'oil-rubbed-bronze': { color: 0x3D2B1F, metalness: 0.80, roughness: 0.28 },
          'satin-gold': { color: 0xCFB53B, metalness: 0.88, roughness: 0.22 }
        };

        const mat = finishes[finish] || finishes['brushed-nickel'];
        const handleMat = new THREE.MeshStandardMaterial({
          color: mat.color,
          metalness: mat.metalness,
          roughness: mat.roughness,
          envMap: window.roomEnvMap || null,
          envMapIntensity: 1.5
        });

        // Main bar - THICKER for better visibility
        const barRadius = 0.016;  // Increased from 0.012
        const barLength = length;
        const barGeo = new THREE.CylinderGeometry(barRadius, barRadius, barLength, 20);
        const bar = new THREE.Mesh(barGeo, handleMat);
        bar.rotation.z = Math.PI / 2; // Horizontal
        bar.castShadow = true;
        bar.receiveShadow = true;
        handleGroup.add(bar);

        // Standoffs (mounting posts) - LARGER
        const standoffHeight = 0.032;  // Increased from 0.025
        const standoffRadius = 0.018;  // Increased from 0.015
        const standoffSpacing = barLength * 0.72;

        // Left standoff
        const standoffGeo = new THREE.CylinderGeometry(standoffRadius, standoffRadius * 0.9, standoffHeight, 16);
        const leftStandoff = new THREE.Mesh(standoffGeo, handleMat);
        leftStandoff.position.set(-standoffSpacing / 2, 0, -standoffHeight / 2);
        leftStandoff.rotation.x = Math.PI / 2;
        leftStandoff.castShadow = true;
        handleGroup.add(leftStandoff);

        // Right standoff
        const rightStandoff = new THREE.Mesh(standoffGeo, handleMat);
        rightStandoff.position.set(standoffSpacing / 2, 0, -standoffHeight / 2);
        rightStandoff.rotation.x = Math.PI / 2;
        rightStandoff.castShadow = true;
        handleGroup.add(rightStandoff);

        // Mounting plates (decorative) - LARGER
        const plateGeo = new THREE.CylinderGeometry(standoffRadius * 1.4, standoffRadius * 1.4, 0.006, 20);
        const leftPlate = new THREE.Mesh(plateGeo, handleMat);
        leftPlate.position.set(-standoffSpacing / 2, 0, -standoffHeight - 0.003);
        leftPlate.rotation.x = Math.PI / 2;
        leftPlate.castShadow = true;
        handleGroup.add(leftPlate);

        const rightPlate = new THREE.Mesh(plateGeo, handleMat);
        rightPlate.position.set(standoffSpacing / 2, 0, -standoffHeight - 0.003);
        rightPlate.rotation.x = Math.PI / 2;
        rightPlate.castShadow = true;
        handleGroup.add(rightPlate);

        // Add subtle highlight on bar top for depth
        const highlightMat = new THREE.MeshBasicMaterial({
          color: 0xffffff,
          transparent: true,
          opacity: 0.08
        });
        const highlightGeo = new THREE.PlaneGeometry(barLength, barRadius * 0.5);
        const highlight = new THREE.Mesh(highlightGeo, highlightMat);
        highlight.position.set(0, barRadius * 0.95, 0);
        highlight.rotation.x = -Math.PI / 2;
        handleGroup.add(highlight);

        return handleGroup;
      }

      // Helper to create cabinet with doors
      function createCabinet(width, height, depth, cabinetColor, isWallCab, doorStyle, construction, overlay, finish, elementId, customTextureUrl, grainType) {
        const cabGroup = new THREE.Group();
        cabGroup.userData.doors = []; // Track door groups for animation

        // Construction affects door gaps
        // Frameless: minimal gaps, doors cover most of face (full overlay default)
        // Framed: visible face frame, doors reveal frame edges
        const isFramed = construction === 'framed';
        const overlayType = overlay || 'full';
        const cabinetFinish = finish || 'wood-grain';
        const woodGrainType = grainType || 'oak'; // Default to oak grain pattern

        // Gap based on overlay type
        let gap;
        if (isFramed) {
          gap = overlayType === 'inset' ? 0.08 : (overlayType === 'partial' ? 0.06 : 0.04);
        } else {
          gap = overlayType === 'inset' ? 0.06 : 0.02; // Frameless has smaller gaps
        }

        // Cabinet body - interior with darker finish (using pooled geometry)
        const bodyMat = new THREE.MeshStandardMaterial({
          color: 0x1a1a1a,
          roughness: 0.9,
          metalness: 0.0
        });
        const bodyGeometry = getPooledBoxGeometry(width - 0.1, height - 0.1, depth - 0.1);
        const body = new THREE.Mesh(bodyGeometry, bodyMat);
        body.position.z = -0.02;
        body.castShadow = true;
        body.receiveShadow = true;
        cabGroup.add(body);

        // Create texture and material based on finish type
        let woodTexture = null;
        let baseRoughness, baseMetalness;

        // Check for custom uploaded texture first
        if (customTextureUrl) {
          // Load custom texture image
          const textureLoader = new THREE.TextureLoader();
          try {
            woodTexture = textureLoader.load(customTextureUrl, (texture) => {
              texture.wrapS = THREE.RepeatWrapping;
              texture.wrapT = THREE.RepeatWrapping;
              texture.repeat.set(2, 2);
              // Update all materials that use this texture
              cabGroup.traverse(child => {
                if (child.material && child.material.map === woodTexture) {
                  child.material.needsUpdate = true;
                }
              });
              if (renderer && scene && camera) {
                renderer.render(scene, camera);
              }
            });
            woodTexture.wrapS = THREE.RepeatWrapping;
            woodTexture.wrapT = THREE.RepeatWrapping;
            woodTexture.repeat.set(2, 2);
          } catch (e) {
            console.warn('Failed to load custom cabinet texture:', e);
            woodTexture = createWoodGrainTexture(cabinetColor, 0.12, woodGrainType);
          }
          baseRoughness = 0.3;
          baseMetalness = 0.02;
        } else if (cabinetFinish === 'wood-grain') {
          woodTexture = createWoodGrainTexture(cabinetColor, 0.12, woodGrainType);
          baseRoughness = 0.3;
          baseMetalness = 0.02;
        } else if (cabinetFinish === 'painted') {
          // Smooth painted finish - use flat texture for subtle surface variation
          woodTexture = createWoodGrainTexture(cabinetColor, 0.05, 'flat');
          baseRoughness = 0.4;
          baseMetalness = 0.01;
        } else if (cabinetFinish === 'matte') {
          // Matte laminate - use flat texture
          woodTexture = createWoodGrainTexture(cabinetColor, 0.03, 'flat');
          baseRoughness = 0.7;
          baseMetalness = 0.0;
        } else if (cabinetFinish === 'gloss') {
          // High gloss - use flat texture with minimal variation
          woodTexture = createWoodGrainTexture(cabinetColor, 0.02, 'flat');
          baseRoughness = 0.1;
          baseMetalness = 0.05;
        } else {
          woodTexture = createWoodGrainTexture(cabinetColor, 0.12, woodGrainType);
          baseRoughness = 0.3;
          baseMetalness = 0.02;
        }

        // Face frame for framed cabinets
        if (isFramed) {
          const frameMat = new THREE.MeshStandardMaterial({
            color: cabinetColor,
            map: woodTexture,
            roughness: baseRoughness + 0.05,
            metalness: baseMetalness,
            bumpScale: woodTexture ? 0.002 : 0
          });
          const frameW = 0.06; // 1.5" face frame

          // Top rail
          const topFrame = new THREE.Mesh(new THREE.BoxGeometry(width, frameW, 0.04), frameMat);
          topFrame.position.set(0, height/2 - frameW/2 - 0.01, depth/2 - 0.01);
          topFrame.castShadow = true;
          cabGroup.add(topFrame);

          // Bottom rail
          const botFrame = new THREE.Mesh(new THREE.BoxGeometry(width, frameW, 0.04), frameMat);
          botFrame.position.set(0, -height/2 + frameW/2 + 0.01, depth/2 - 0.01);
          botFrame.castShadow = true;
          cabGroup.add(botFrame);

          // Left stile
          const leftFrame = new THREE.Mesh(new THREE.BoxGeometry(frameW, height - frameW*2, 0.04), frameMat);
          leftFrame.position.set(-width/2 + frameW/2 + 0.01, 0, depth/2 - 0.01);
          leftFrame.castShadow = true;
          cabGroup.add(leftFrame);

          // Right stile
          const rightFrame = new THREE.Mesh(new THREE.BoxGeometry(frameW, height - frameW*2, 0.04), frameMat);
          rightFrame.position.set(width/2 - frameW/2 - 0.01, 0, depth/2 - 0.01);
          rightFrame.castShadow = true;
          cabGroup.add(rightFrame);
        }

        // Face material - with or without wood grain based on finish
        const faceMat = new THREE.MeshStandardMaterial({
          color: cabinetColor,
          map: woodTexture,
          roughness: baseRoughness,
          metalness: baseMetalness,
          bumpScale: woodTexture ? 0.002 : 0
        });

        // Door(s) - each door is a Group with pivot at hinge edge for proper animation
        const numDoors = Math.max(1, Math.round(width / 1.5));
        const doorW = (width - gap * (numDoors + 1)) / numDoors;
        const doorH = height - gap * 2;

        const style = doorStyle || 'shaker';

        // Door style details - material matches finish type
        const doorFrameMat = new THREE.MeshStandardMaterial({
          color: cabinetColor,
          map: woodTexture,
          roughness: baseRoughness - 0.02,
          metalness: baseMetalness
        });

        for (let i = 0; i < numDoors; i++) {
          // Door group - positioned at hinge edge for proper pivot rotation
          const doorGroup = new THREE.Group();

          // Determine hinge side: left doors hinge left, right doors hinge right
          const hingeOnLeft = i < numDoors / 2;
          const hingeOffset = hingeOnLeft ? -doorW / 2 : doorW / 2;

          // Position door group at the hinge location
          const doorCenterX = -width/2 + gap + doorW/2 + i * (doorW + gap);
          doorGroup.position.set(doorCenterX + hingeOffset, 0, depth/2);

          // Door mesh offset from group origin (which is at hinge)
          const doorMeshOffset = hingeOnLeft ? doorW / 2 : -doorW / 2;

          // Main door panel - offset from pivot point
          const door = new THREE.Mesh(new THREE.BoxGeometry(doorW, doorH, 0.06), faceMat);
          door.position.set(doorMeshOffset, 0, 0);
          door.castShadow = true;
          door.receiveShadow = true;
          doorGroup.add(door);

          if (style === 'shaker' || style === 'shaker-beaded') {
            // Shaker: flat center panel with raised frame
            const fw = 0.08;

            // Top rail
            const top = new THREE.Mesh(new THREE.BoxGeometry(doorW - 0.02, fw, 0.02), doorFrameMat);
            top.position.set(doorMeshOffset, doorH/2 - fw/2 - 0.01, 0.04);
            top.castShadow = true;
            doorGroup.add(top);

            // Bottom rail
            const bot = new THREE.Mesh(new THREE.BoxGeometry(doorW - 0.02, fw, 0.02), doorFrameMat);
            bot.position.set(doorMeshOffset, -doorH/2 + fw/2 + 0.01, 0.04);
            bot.castShadow = true;
            doorGroup.add(bot);

            // Left stile
            const left = new THREE.Mesh(new THREE.BoxGeometry(fw, doorH - fw*2, 0.02), doorFrameMat);
            left.position.set(doorMeshOffset - doorW/2 + fw/2 + 0.01, 0, 0.04);
            left.castShadow = true;
            doorGroup.add(left);

            // Right stile
            const right = new THREE.Mesh(new THREE.BoxGeometry(fw, doorH - fw*2, 0.02), doorFrameMat);
            right.position.set(doorMeshOffset + doorW/2 - fw/2 - 0.01, 0, 0.04);
            right.castShadow = true;
            doorGroup.add(right);

            // Beaded detail for shaker-beaded style
            if (style === 'shaker-beaded') {
              const beadMat = new THREE.MeshStandardMaterial({
                color: cabinetColor,
                roughness: baseRoughness - 0.1,
                metalness: baseMetalness + 0.02
              });
              const beadRadius = 0.008;
              const beadGeo = new THREE.CylinderGeometry(beadRadius, beadRadius, doorW - fw * 2 - 0.04, 8);

              // Top bead (horizontal)
              const topBead = new THREE.Mesh(beadGeo, beadMat);
              topBead.rotation.z = Math.PI / 2;
              topBead.position.set(doorMeshOffset, doorH/2 - fw - 0.02, 0.05);
              doorGroup.add(topBead);

              // Bottom bead (horizontal)
              const botBead = new THREE.Mesh(beadGeo, beadMat);
              botBead.rotation.z = Math.PI / 2;
              botBead.position.set(doorMeshOffset, -doorH/2 + fw + 0.02, 0.05);
              doorGroup.add(botBead);

              // Side beads (vertical)
              const sideBeadGeo = new THREE.CylinderGeometry(beadRadius, beadRadius, doorH - fw * 2 - 0.04, 8);

              const leftBead = new THREE.Mesh(sideBeadGeo, beadMat);
              leftBead.position.set(doorMeshOffset - doorW/2 + fw + 0.02, 0, 0.05);
              doorGroup.add(leftBead);

              const rightBead = new THREE.Mesh(sideBeadGeo, beadMat);
              rightBead.position.set(doorMeshOffset + doorW/2 - fw - 0.02, 0, 0.05);
              doorGroup.add(rightBead);
            }
          } else if (style === 'raised') {
            // Raised panel: outer frame with raised center
            const fw = 0.1;

            // Frame pieces
            const top = new THREE.Mesh(new THREE.BoxGeometry(doorW - 0.02, fw, 0.02), doorFrameMat);
            top.position.set(doorMeshOffset, doorH/2 - fw/2 - 0.01, 0.04);
            top.castShadow = true;
            doorGroup.add(top);

            const bot = new THREE.Mesh(new THREE.BoxGeometry(doorW - 0.02, fw, 0.02), doorFrameMat);
            bot.position.set(doorMeshOffset, -doorH/2 + fw/2 + 0.01, 0.04);
            bot.castShadow = true;
            doorGroup.add(bot);

            const left = new THREE.Mesh(new THREE.BoxGeometry(fw, doorH - fw*2, 0.02), doorFrameMat);
            left.position.set(doorMeshOffset - doorW/2 + fw/2 + 0.01, 0, 0.04);
            left.castShadow = true;
            doorGroup.add(left);

            const right = new THREE.Mesh(new THREE.BoxGeometry(fw, doorH - fw*2, 0.02), doorFrameMat);
            right.position.set(doorMeshOffset + doorW/2 - fw/2 - 0.01, 0, 0.04);
            right.castShadow = true;
            doorGroup.add(right);

            // Raised center panel - matches cabinet finish
            const raisedW = doorW - fw * 2 - 0.06;
            const raisedH = doorH - fw * 2 - 0.06;
            const raisedMat = new THREE.MeshStandardMaterial({
              color: cabinetColor,
              map: woodTexture,
              roughness: baseRoughness - 0.08,
              metalness: baseMetalness
            });
            const raised = new THREE.Mesh(new THREE.BoxGeometry(raisedW, raisedH, 0.04), raisedMat);
            raised.position.set(doorMeshOffset, 0, 0.06);
            raised.castShadow = true;
            doorGroup.add(raised);
          } else if (style === 'flat') {
            // Flat panel: minimal detail, recessed center
            const grooveMat = new THREE.MeshStandardMaterial({
              color: new THREE.Color(cabinetColor).multiplyScalar(0.85),
              roughness: 0.5
            });
            const groove = new THREE.Mesh(new THREE.BoxGeometry(doorW - 0.1, doorH - 0.1, 0.015), grooveMat);
            groove.position.set(doorMeshOffset, 0, 0.025);
            doorGroup.add(groove);
          }
          // 'slab' style = no detail, just plain door with wood grain

          // Modern Bar Handle with standoffs
          const handleLength = Math.min(doorW * 0.6, 0.3);
          const handleFinish = 'brushed-nickel';
          const handle = createModernBarHandle(handleLength, handleFinish);

          // Position handle - vertical for tall handles, horizontal positioning
          const handleY = isWallCab ? -doorH * 0.28 : doorH * 0.28;
          const handleX = hingeOnLeft ? doorW/2 - 0.15 : -doorW/2 + 0.15;

          handle.position.set(doorMeshOffset + handleX, handleY, 0.085);
          handle.rotation.z = Math.PI / 2; // Vertical orientation
          doorGroup.add(handle);

          // Add userData for click detection and animation
          doorGroup.userData = {
            partType: 'door',
            elementId: elementId,
            doorIndex: i,
            hingeOnLeft: hingeOnLeft,
            isOpen: false,
            openAngle: hingeOnLeft ? Math.PI / 2 : -Math.PI / 2 // Direction to swing
          };

          // Make all children clickable with same userData
          doorGroup.traverse(child => {
            if (child.isMesh) {
              child.userData.partType = 'door';
              child.userData.elementId = elementId;
              child.userData.doorGroup = doorGroup;
            }
          });

          cabGroup.add(doorGroup);
          cabGroup.userData.doors.push(doorGroup);
        }

        return cabGroup;
      }

      // === CREATE DETAILED 3D MODELS ===
      switch(el.type) {
        case 'base-cabinet':
        case 'wall-cabinet': {
          const isBaseCab = el.type === 'base-cabinet';

          // Toe kick dimensions (4" tall, 3" recessed)
          const toeKickHeight = isBaseCab ? 0.33 : 0;
          const toeKickRecess = isBaseCab ? 0.25 : 0;

          // Cabinet body height (minus toe kick for base cabinets)
          const bodyHeight = h - toeKickHeight;

          // Create cabinet body at reduced height for base cabinets
          const cab = createCabinet(w, bodyHeight, d, color, !isBaseCab, el.doorStyle, el.construction, el.doorOverlay, el.cabinetFinish, el.id, textureUrl);

          // Position cabinet body above toe kick
          if (isBaseCab) {
            cab.position.y = toeKickHeight / 2;
          }
          group.add(cab);

          // Create toe kick for base cabinets - proper recessed void
          if (isBaseCab) {
            // Toe kick back panel (visible back of recess)
            const tkBackMat = new THREE.MeshStandardMaterial({ color: 0x0a0a0a, roughness: 0.95 });
            const tkBack = new THREE.Mesh(
              new THREE.BoxGeometry(w - 0.1, toeKickHeight - 0.02, 0.02),
              tkBackMat
            );
            tkBack.position.set(0, -h/2 + toeKickHeight/2, d/2 - toeKickRecess);
            group.add(tkBack);

            // Toe kick bottom (floor of recess)
            const tkBottom = new THREE.Mesh(
              new THREE.BoxGeometry(w - 0.1, 0.02, toeKickRecess - 0.02),
              tkBackMat
            );
            tkBottom.position.set(0, -h/2 + 0.01, d/2 - toeKickRecess/2);
            group.add(tkBottom);

            // Left side panel of toe kick recess
            const tkLeft = new THREE.Mesh(
              new THREE.BoxGeometry(0.02, toeKickHeight - 0.02, toeKickRecess),
              tkBackMat
            );
            tkLeft.position.set(-w/2 + 0.05, -h/2 + toeKickHeight/2, d/2 - toeKickRecess/2);
            group.add(tkLeft);

            // Right side panel of toe kick recess
            const tkRight = new THREE.Mesh(
              new THREE.BoxGeometry(0.02, toeKickHeight - 0.02, toeKickRecess),
              tkBackMat
            );
            tkRight.position.set(w/2 - 0.05, -h/2 + toeKickHeight/2, d/2 - toeKickRecess/2);
            group.add(tkRight);

            // Cabinet overhang lip (bottom edge of cabinet above toe kick)
            const lipMat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.4 });
            const lip = new THREE.Mesh(
              new THREE.BoxGeometry(w, 0.03, 0.04),
              lipMat
            );
            lip.position.set(0, -h/2 + toeKickHeight + 0.015, d/2 - 0.02);
            group.add(lip);
          }
          break;
        }

        case 'microwave-cabinet': {
          // Simple open box shelf with microwave inside
          // No doors - just an open cabinet frame with microwave face visible
          const mwcCabinetMat = new THREE.MeshStandardMaterial({
            color: color,
            roughness: 0.5
          });
          const mwcDarkMat = new THREE.MeshStandardMaterial({
            color: 0x1a1a1a,
            roughness: 0.8
          });
          const mwcMicrowaveMat = new THREE.MeshStandardMaterial({
            color: 0x2a2a2a,
            roughness: 0.3,
            metalness: 0.3
          });
          const mwcHandleMat = new THREE.MeshStandardMaterial({
            color: 0xB0B0B0,
            roughness: 0.2,
            metalness: 0.85
          });

          const panelThickness = 0.05; // ~0.6" thick panels

          // Back panel
          const backPanel = new THREE.Mesh(
            new THREE.BoxGeometry(w, h, panelThickness),
            mwcCabinetMat
          );
          backPanel.position.set(0, 0, -d/2 + panelThickness/2);
          group.add(backPanel);

          // Side panels (left and right)
          [-1, 1].forEach(side => {
            const sidePanel = new THREE.Mesh(
              new THREE.BoxGeometry(panelThickness, h, d - panelThickness),
              mwcCabinetMat
            );
            sidePanel.position.set(side * (w/2 - panelThickness/2), 0, panelThickness/2);
            group.add(sidePanel);
          });

          // Top panel
          const topPanel = new THREE.Mesh(
            new THREE.BoxGeometry(w - panelThickness * 2, panelThickness, d - panelThickness),
            mwcCabinetMat
          );
          topPanel.position.set(0, h/2 - panelThickness/2, panelThickness/2);
          group.add(topPanel);

          // Bottom panel
          const bottomPanel = new THREE.Mesh(
            new THREE.BoxGeometry(w - panelThickness * 2, panelThickness, d - panelThickness),
            mwcCabinetMat
          );
          bottomPanel.position.set(0, -h/2 + panelThickness/2, panelThickness/2);
          group.add(bottomPanel);

          // Dark interior
          const interiorBack = new THREE.Mesh(
            new THREE.BoxGeometry(w - panelThickness * 2 - 0.02, h - panelThickness * 2 - 0.02, 0.01),
            mwcDarkMat
          );
          interiorBack.position.set(0, 0, -d/2 + panelThickness + 0.01);
          group.add(interiorBack);

          // Microwave body
          const mwWidth = w * 0.9;
          const mwHeight = h * 0.8;
          const mwDepth = d * 0.85;

          const microwaveBody = new THREE.Mesh(
            new THREE.BoxGeometry(mwWidth, mwHeight, mwDepth),
            mwcMicrowaveMat
          );
          microwaveBody.position.set(0, 0, d/2 - mwDepth/2 - panelThickness);
          group.add(microwaveBody);

          // Microwave glass door (left side)
          const mwGlass = new THREE.Mesh(
            new THREE.BoxGeometry(mwWidth * 0.6, mwHeight * 0.8, 0.02),
            new THREE.MeshStandardMaterial({
              color: 0x111111,
              transparent: true,
              opacity: 0.85,
              roughness: 0.1
            })
          );
          mwGlass.position.set(-mwWidth * 0.15, 0, d/2 - 0.01);
          group.add(mwGlass);

          // Control panel (right side)
          const controlPanel = new THREE.Mesh(
            new THREE.BoxGeometry(mwWidth * 0.28, mwHeight * 0.8, 0.02),
            new THREE.MeshStandardMaterial({ color: 0x3a3a3a, roughness: 0.4 })
          );
          controlPanel.position.set(mwWidth * 0.3, 0, d/2 - 0.01);
          group.add(controlPanel);

          // Buttons on control panel
          for (let row = 0; row < 3; row++) {
            for (let col = 0; col < 3; col++) {
              const btn = new THREE.Mesh(
                new THREE.BoxGeometry(0.03, 0.025, 0.01),
                new THREE.MeshStandardMaterial({ color: 0x5a5a5a })
              );
              btn.position.set(
                mwWidth * 0.22 + col * 0.045,
                0.1 - row * 0.045,
                d/2
              );
              group.add(btn);
            }
          }

          // Door handle (vertical bar on left of glass)
          const doorHandle = new THREE.Mesh(
            new THREE.BoxGeometry(0.02, mwHeight * 0.4, 0.03),
            mwcHandleMat
          );
          doorHandle.position.set(-mwWidth/2 + 0.08, 0, d/2 + 0.01);
          group.add(doorHandle);

          break;
        }

        case 'drawer-base': {
          // Drawer base cabinet with 3-4 stacked drawer fronts
          const dbToeKickHeight = 0.33;
          const dbToeKickRecess = 0.25;
          const dbBodyHeight = h - dbToeKickHeight;
          const dbIsFramed = el.construction === 'framed';

          // Use wood grain texture like other cabinets for consistency
          const dbCabinetFinish = el.cabinetFinish || 'wood-grain';
          const dbGrainType = el.grainType || 'oak';
          let dbWoodTexture = null;
          let dbBaseRoughness = 0.35;
          let dbBaseMetalness = 0.02;

          // Check for custom texture first
          if (textureUrl) {
            const textureLoader = new THREE.TextureLoader();
            try {
              dbWoodTexture = textureLoader.load(textureUrl);
              dbWoodTexture.wrapS = THREE.RepeatWrapping;
              dbWoodTexture.wrapT = THREE.RepeatWrapping;
              dbWoodTexture.repeat.set(2, 2);
            } catch (e) {
              dbWoodTexture = createWoodGrainTexture(color, 0.12, dbGrainType);
            }
            dbBaseRoughness = 0.3;
            dbBaseMetalness = 0.02;
          } else if (dbCabinetFinish === 'wood-grain') {
            dbWoodTexture = createWoodGrainTexture(color, 0.12, dbGrainType);
            dbBaseRoughness = 0.3;
            dbBaseMetalness = 0.02;
          } else if (dbCabinetFinish === 'painted') {
            dbWoodTexture = createWoodGrainTexture(color, 0.05, 'flat');
            dbBaseRoughness = 0.4;
            dbBaseMetalness = 0.01;
          } else if (dbCabinetFinish === 'matte') {
            dbWoodTexture = createWoodGrainTexture(color, 0.03, 'flat');
            dbBaseRoughness = 0.7;
            dbBaseMetalness = 0.0;
          } else if (dbCabinetFinish === 'gloss') {
            dbWoodTexture = createWoodGrainTexture(color, 0.02, 'flat');
            dbBaseRoughness = 0.1;
            dbBaseMetalness = 0.05;
          }

          const cabinetMat = new THREE.MeshStandardMaterial({
            color: color,
            map: dbWoodTexture,
            roughness: dbBaseRoughness,
            metalness: dbBaseMetalness,
            bumpScale: dbWoodTexture ? 0.002 : 0
          });
          const bodyMat = new THREE.MeshStandardMaterial({ color: 0x2a2a2a, roughness: 0.8 });
          const handleMat = new THREE.MeshStandardMaterial({ color: 0xaaaaaa, metalness: 0.9, roughness: 0.15 });

          // Face frame for framed construction
          if (dbIsFramed) {
            const frameW = 0.06;
            // Top rail
            const topFrame = new THREE.Mesh(new THREE.BoxGeometry(w, frameW, 0.04), cabinetMat);
            topFrame.position.set(0, dbToeKickHeight/2 + dbBodyHeight/2 - frameW/2, d/2 - 0.01);
            group.add(topFrame);
            // Bottom rail
            const botFrame = new THREE.Mesh(new THREE.BoxGeometry(w, frameW, 0.04), cabinetMat);
            botFrame.position.set(0, dbToeKickHeight/2 - dbBodyHeight/2 + frameW/2, d/2 - 0.01);
            group.add(botFrame);
            // Left stile
            const leftFrame = new THREE.Mesh(new THREE.BoxGeometry(frameW, dbBodyHeight - frameW*2, 0.04), cabinetMat);
            leftFrame.position.set(-w/2 + frameW/2, dbToeKickHeight/2, d/2 - 0.01);
            group.add(leftFrame);
            // Right stile
            const rightFrame = new THREE.Mesh(new THREE.BoxGeometry(frameW, dbBodyHeight - frameW*2, 0.04), cabinetMat);
            rightFrame.position.set(w/2 - frameW/2, dbToeKickHeight/2, d/2 - 0.01);
            group.add(rightFrame);
          }

          // Cabinet body (sides, top, back)
          // Back panel
          const back = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.04, dbBodyHeight - 0.04, 0.03),
            bodyMat
          );
          back.position.set(0, dbToeKickHeight/2, -d/2 + 0.02);
          group.add(back);

          // Left side
          const leftSide = new THREE.Mesh(
            new THREE.BoxGeometry(0.04, dbBodyHeight, d),
            cabinetMat
          );
          leftSide.position.set(-w/2 + 0.02, dbToeKickHeight/2, 0);
          group.add(leftSide);

          // Right side
          const rightSide = new THREE.Mesh(
            new THREE.BoxGeometry(0.04, dbBodyHeight, d),
            cabinetMat
          );
          rightSide.position.set(w/2 - 0.02, dbToeKickHeight/2, 0);
          group.add(rightSide);

          // Top
          const topPanel = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.08, 0.04, d - 0.02),
            cabinetMat
          );
          topPanel.position.set(0, dbToeKickHeight/2 + dbBodyHeight/2 - 0.02, 0);
          group.add(topPanel);

          // Draw stacked drawers (3-4 based on width)
          const numDrawers = w > 1.5 ? 4 : 3;
          const drawerGap = 0.02;
          const totalGapHeight = drawerGap * (numDrawers - 1);
          const drawerHeight = (dbBodyHeight - 0.08 - totalGapHeight) / numDrawers;

          // Get door style from element or default
          const dbDoorStyle = el.doorStyle || 'shaker';

          for (let i = 0; i < numDrawers; i++) {
            // Create a drawer group for interactive animation
            const drawerGroup = new THREE.Group();
            const drawerY = dbToeKickHeight/2 + dbBodyHeight/2 - 0.04 - drawerHeight/2 - i * (drawerHeight + drawerGap);

            // Position the drawer group
            drawerGroup.position.set(0, drawerY, d/2);

            // === ENHANCED DRAWER BOX (visible when open) ===
            const drawerBoxMat = new THREE.MeshStandardMaterial({
              color: 0x4a3828,
              roughness: 0.55,
              metalness: 0.02
            });
            const drawerBox = new THREE.Mesh(
              new THREE.BoxGeometry(w - 0.12, drawerHeight - 0.06, d * 0.7),
              drawerBoxMat
            );
            drawerBox.position.set(0, 0, -d * 0.35 + 0.04);
            drawerBox.castShadow = true;
            drawerBox.receiveShadow = true;
            drawerGroup.add(drawerBox);

            // === DRAWER FRONT FACE WITH BETTER CONTRAST ===
            // Use polygon offset to prevent z-fighting
            const drawerFrontMat = new THREE.MeshStandardMaterial({
              color: color,
              map: dbWoodTexture,
              roughness: dbBaseRoughness - 0.05,
              metalness: dbBaseMetalness,
              polygonOffset: true,
              polygonOffsetFactor: -1,
              polygonOffsetUnits: -1
            });
            const drawerFront = new THREE.Mesh(
              new THREE.BoxGeometry(w - 0.05, drawerHeight - 0.015, 0.045),
              drawerFrontMat
            );
            drawerFront.position.set(0, 0, 0.023);
            drawerFront.castShadow = true;
            drawerFront.receiveShadow = true;
            drawerGroup.add(drawerFront);

            // === SHADOW LINE ABOVE DRAWER (creates separation) ===
            const shadowLineMat = new THREE.MeshBasicMaterial({
              color: 0x000000,
              transparent: true,
              opacity: 0.4
            });
            const shadowLine = new THREE.Mesh(
              new THREE.BoxGeometry(w - 0.04, 0.008, 0.05),
              shadowLineMat
            );
            shadowLine.position.set(0, drawerHeight/2 - 0.002, 0.05);
            drawerGroup.add(shadowLine);

            // === DRAWER DETAIL BASED ON DOOR STYLE ===
            // Enhanced frame material with better contrast
            const frameMat = new THREE.MeshStandardMaterial({
              color: new THREE.Color(color).multiplyScalar(1.05),
              map: dbWoodTexture,
              roughness: dbBaseRoughness - 0.08,
              metalness: dbBaseMetalness + 0.01,
              polygonOffset: true,
              polygonOffsetFactor: -2,
              polygonOffsetUnits: -2
            });

            if (dbDoorStyle === 'shaker' || dbDoorStyle === 'shaker-beaded') {
              // Shaker: recessed panel with raised frame
              const frameWidth = 0.075;

              // Dark recessed shadow channel
              const recessedMat = new THREE.MeshStandardMaterial({
                color: 0x0a0a0a,
                roughness: 0.9,
                metalness: 0.0
              });
              const recess = new THREE.Mesh(
                new THREE.BoxGeometry(w - 0.05 - frameWidth * 2 + 0.015, drawerHeight - 0.015 - frameWidth * 2 + 0.015, 0.012),
                recessedMat
              );
              recess.position.set(0, 0, 0.035);
              drawerGroup.add(recess);

              // Raised inner panel with wood texture
              const innerPanel = new THREE.Mesh(
                new THREE.BoxGeometry(w - 0.05 - frameWidth * 2 - 0.01, drawerHeight - 0.015 - frameWidth * 2 - 0.01, 0.025),
                frameMat
              );
              innerPanel.position.set(0, 0, 0.055);
              innerPanel.castShadow = true;
              drawerGroup.add(innerPanel);

              // Edge highlight lines for depth
              const highlightMat = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.15
              });

              // Top edge highlight
              const topHighlight = new THREE.Mesh(
                new THREE.BoxGeometry(w - 0.05 - frameWidth * 2, 0.004, 0.004),
                highlightMat
              );
              topHighlight.position.set(0, (drawerHeight - 0.015)/2 - frameWidth - 0.002, 0.068);
              drawerGroup.add(topHighlight);

            } else if (dbDoorStyle === 'raised') {
              // Raised panel: beveled center with enhanced depth
              const frameWidth = 0.09;

              // Shadow channel
              const shadowMat = new THREE.MeshStandardMaterial({
                color: 0x151515,
                roughness: 0.85
              });
              const shadowChannel = new THREE.Mesh(
                new THREE.BoxGeometry(w - 0.05 - frameWidth * 2 + 0.02, drawerHeight - 0.015 - frameWidth * 2 + 0.02, 0.01),
                shadowMat
              );
              shadowChannel.position.set(0, 0, 0.038);
              drawerGroup.add(shadowChannel);

              // Raised center panel
              const raisedMat = new THREE.MeshStandardMaterial({
                color: new THREE.Color(color).multiplyScalar(1.08),
                map: dbWoodTexture,
                roughness: 0.22,
                metalness: dbBaseMetalness + 0.02
              });
              const raised = new THREE.Mesh(
                new THREE.BoxGeometry(w - 0.05 - frameWidth * 2, drawerHeight - 0.015 - frameWidth * 2, 0.045),
                raisedMat
              );
              raised.position.set(0, 0, 0.065);
              raised.castShadow = true;
              drawerGroup.add(raised);

            } else if (dbDoorStyle === 'flat') {
              // Flat panel: subtle groove line
              const grooveMat = new THREE.MeshStandardMaterial({
                color: new THREE.Color(color).multiplyScalar(0.85),
                roughness: 0.5
              });
              const groove = new THREE.Mesh(
                new THREE.BoxGeometry(w - 0.12, drawerHeight - 0.08, 0.008),
                grooveMat
              );
              groove.position.set(0, 0, 0.035);
              drawerGroup.add(groove);
            }
            // 'slab' style = no additional detail, just plain front

            // === MODERN BAR PULL HANDLE ===
            const handleLen = Math.min(w * 0.5, 0.4);
            const handleFinish = el.handleFinish || 'brushed-nickel';
            const handle = createModernBarHandle(handleLen, handleFinish);
            handle.position.set(0, 0, 0.09);
            drawerGroup.add(handle);

            // Add userData for click detection and animation
            drawerGroup.userData = {
              partType: 'drawer',
              elementId: el.id,
              drawerIndex: i,
              isOpen: false,
              slideDistance: d * 0.6 // How far drawer slides out
            };

            // Make all children clickable with same userData
            drawerGroup.traverse(child => {
              if (child.isMesh) {
                child.userData.partType = 'drawer';
                child.userData.elementId = el.id;
                child.userData.doorGroup = drawerGroup; // Use doorGroup for compatibility
              }
            });

            group.add(drawerGroup);
          }

          // Toe kick
          const tkBackMat = new THREE.MeshStandardMaterial({ color: 0x0a0a0a, roughness: 0.95 });
          const tkBack = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.1, dbToeKickHeight - 0.02, 0.02),
            tkBackMat
          );
          tkBack.position.set(0, -h/2 + dbToeKickHeight/2, d/2 - dbToeKickRecess);
          group.add(tkBack);

          const tkFloor = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.1, 0.02, dbToeKickRecess - 0.02),
            tkBackMat
          );
          tkFloor.position.set(0, -h/2 + 0.01, d/2 - dbToeKickRecess/2);
          group.add(tkFloor);

          break;
        }

        case 'sink-base': {
          // Sink base cabinet - false drawer front + double doors, open interior
          const sbToeKickHeight = 0.33;
          const sbToeKickRecess = 0.25;
          const sbBodyHeight = h - sbToeKickHeight;
          const sbIsFramed = el.construction === 'framed';
          const sbDoorStyle = el.doorStyle || 'shaker';

          // Use wood grain texture like other cabinets for consistency
          const sbCabinetFinish = el.cabinetFinish || 'wood-grain';
          const sbGrainType = el.grainType || 'oak';
          let sbWoodTexture = null;
          let sbBaseRoughness = 0.35;
          let sbBaseMetalness = 0.02;

          // Check for custom texture first
          if (textureUrl) {
            const textureLoader = new THREE.TextureLoader();
            try {
              sbWoodTexture = textureLoader.load(textureUrl);
              sbWoodTexture.wrapS = THREE.RepeatWrapping;
              sbWoodTexture.wrapT = THREE.RepeatWrapping;
              sbWoodTexture.repeat.set(2, 2);
            } catch (e) {
              sbWoodTexture = createWoodGrainTexture(color, 0.12, sbGrainType);
            }
            sbBaseRoughness = 0.3;
            sbBaseMetalness = 0.02;
          } else if (sbCabinetFinish === 'wood-grain') {
            sbWoodTexture = createWoodGrainTexture(color, 0.12, sbGrainType);
            sbBaseRoughness = 0.3;
            sbBaseMetalness = 0.02;
          } else if (sbCabinetFinish === 'painted') {
            sbWoodTexture = createWoodGrainTexture(color, 0.05, 'flat');
            sbBaseRoughness = 0.4;
            sbBaseMetalness = 0.01;
          } else if (sbCabinetFinish === 'matte') {
            sbWoodTexture = createWoodGrainTexture(color, 0.03, 'flat');
            sbBaseRoughness = 0.7;
            sbBaseMetalness = 0.0;
          } else if (sbCabinetFinish === 'gloss') {
            sbWoodTexture = createWoodGrainTexture(color, 0.02, 'flat');
            sbBaseRoughness = 0.1;
            sbBaseMetalness = 0.05;
          }

          const cabinetMat = new THREE.MeshStandardMaterial({
            color: color,
            map: sbWoodTexture,
            roughness: sbBaseRoughness,
            metalness: sbBaseMetalness,
            bumpScale: sbWoodTexture ? 0.002 : 0
          });
          const bodyMat = new THREE.MeshStandardMaterial({ color: 0x2a2a2a, roughness: 0.8 });
          const handleMat = new THREE.MeshStandardMaterial({ color: 0xaaaaaa, metalness: 0.9, roughness: 0.15 });

          // Face frame for framed construction
          if (sbIsFramed) {
            const frameW = 0.06;
            const topFrame = new THREE.Mesh(new THREE.BoxGeometry(w, frameW, 0.04), cabinetMat);
            topFrame.position.set(0, sbToeKickHeight/2 + sbBodyHeight/2 - frameW/2, d/2 - 0.01);
            group.add(topFrame);
            const botFrame = new THREE.Mesh(new THREE.BoxGeometry(w, frameW, 0.04), cabinetMat);
            botFrame.position.set(0, sbToeKickHeight/2 - sbBodyHeight/2 + frameW/2, d/2 - 0.01);
            group.add(botFrame);
            const leftFrame = new THREE.Mesh(new THREE.BoxGeometry(frameW, sbBodyHeight - frameW*2, 0.04), cabinetMat);
            leftFrame.position.set(-w/2 + frameW/2, sbToeKickHeight/2, d/2 - 0.01);
            group.add(leftFrame);
            const rightFrame = new THREE.Mesh(new THREE.BoxGeometry(frameW, sbBodyHeight - frameW*2, 0.04), cabinetMat);
            rightFrame.position.set(w/2 - frameW/2, sbToeKickHeight/2, d/2 - 0.01);
            group.add(rightFrame);
            // Center stile for double door
            const centerFrame = new THREE.Mesh(new THREE.BoxGeometry(frameW, sbBodyHeight - frameW*2 - 0.2, 0.04), cabinetMat);
            centerFrame.position.set(0, sbToeKickHeight/2 - 0.1, d/2 - 0.01);
            group.add(centerFrame);
          }

          // Cabinet body - open interior for plumbing
          // Back panel (partial - allows plumbing access)
          const back = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.04, sbBodyHeight * 0.6, 0.03),
            bodyMat
          );
          back.position.set(0, sbToeKickHeight/2 - sbBodyHeight * 0.2, -d/2 + 0.02);
          group.add(back);

          // Left side
          const leftSide = new THREE.Mesh(
            new THREE.BoxGeometry(0.04, sbBodyHeight, d),
            cabinetMat
          );
          leftSide.position.set(-w/2 + 0.02, sbToeKickHeight/2, 0);
          group.add(leftSide);

          // Right side
          const rightSide = new THREE.Mesh(
            new THREE.BoxGeometry(0.04, sbBodyHeight, d),
            cabinetMat
          );
          rightSide.position.set(w/2 - 0.02, sbToeKickHeight/2, 0);
          group.add(rightSide);

          // False drawer front (top, non-functional) - at front face
          const falseDrawerH = 0.2;
          const falseDrawer = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.06, falseDrawerH, 0.04),
            cabinetMat
          );
          falseDrawer.position.set(0, sbToeKickHeight/2 + sbBodyHeight/2 - falseDrawerH/2 - 0.02, d/2 + 0.02);
          group.add(falseDrawer);

          // False drawer shaker detail
          if (sbDoorStyle === 'shaker') {
            const recessMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.8 });
            const fdRecess = new THREE.Mesh(
              new THREE.BoxGeometry(w - 0.16, falseDrawerH - 0.06, 0.01),
              recessMat
            );
            fdRecess.position.set(0, sbToeKickHeight/2 + sbBodyHeight/2 - falseDrawerH/2 - 0.02, d/2 + 0.03);
            group.add(fdRecess);
          }

          // False drawer - modern bar handle
          const fdHandleLen = Math.min(w * 0.4, 0.3);
          const fdHandleFinish = el.handleFinish || 'brushed-nickel';
          const fdHandle = createModernBarHandle(fdHandleLen, fdHandleFinish);
          fdHandle.position.set(0, sbToeKickHeight/2 + sbBodyHeight/2 - falseDrawerH/2 - 0.02, d/2 + 0.085);
          group.add(fdHandle);

          // Double doors below false drawer
          const doorsHeight = sbBodyHeight - falseDrawerH - 0.08;
          const doorsY = sbToeKickHeight/2 - 0.02;
          const doorW = (w - 0.1) / 2;
          const doorGap = 0.02;

          for (let i = 0; i < 2; i++) {
            const doorX = i === 0 ? -doorW/2 - doorGap/2 : doorW/2 + doorGap/2;

            // Door face - at front
            const door = new THREE.Mesh(
              new THREE.BoxGeometry(doorW, doorsHeight, 0.04),
              cabinetMat
            );
            door.position.set(doorX, doorsY, d/2 + 0.02);
            group.add(door);

            // Door detail based on style - use wood texture
            const frameMat = new THREE.MeshStandardMaterial({
              color: color,
              map: sbWoodTexture,
              roughness: sbBaseRoughness,
              metalness: sbBaseMetalness
            });
            if (sbDoorStyle === 'shaker') {
              const frameInset = 0.1;
              const recessMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.8 });
              const recess = new THREE.Mesh(
                new THREE.BoxGeometry(doorW - frameInset * 2 + 0.02, doorsHeight - frameInset * 2 + 0.02, 0.01),
                recessMat
              );
              recess.position.set(doorX, doorsY, d/2 + 0.03);
              group.add(recess);
              const frame = new THREE.Mesh(
                new THREE.BoxGeometry(doorW - frameInset * 2, doorsHeight - frameInset * 2, 0.02),
                frameMat
              );
              frame.position.set(doorX, doorsY, d/2 + 0.05);
              group.add(frame);
            } else if (sbDoorStyle === 'raised') {
              const frameInset = 0.1;
              const raisedMat = new THREE.MeshStandardMaterial({
                color: color,
                map: sbWoodTexture,
                roughness: 0.25,
                metalness: sbBaseMetalness
              });
              const raised = new THREE.Mesh(
                new THREE.BoxGeometry(doorW - frameInset * 2, doorsHeight - frameInset * 2, 0.04),
                raisedMat
              );
              raised.position.set(doorX, doorsY, d/2 + 0.06);
              group.add(raised);
            }
            // flat/slab = no detail

            // Modern bar handle for door
            const doorHandleLen = Math.min(doorsHeight * 0.35, 0.25);
            const doorHandleFinish = el.handleFinish || 'brushed-nickel';
            const doorHandle = createModernBarHandle(doorHandleLen, doorHandleFinish);
            const handleX = i === 0 ? doorX + doorW/2 - 0.12 : doorX - doorW/2 + 0.12;
            doorHandle.position.set(handleX, doorsY, d/2 + 0.085);
            doorHandle.rotation.z = Math.PI / 2; // Vertical orientation
            group.add(doorHandle);
          }

          // Toe kick
          const tkMat = new THREE.MeshStandardMaterial({ color: 0x0a0a0a, roughness: 0.95 });
          const tkBack = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.1, sbToeKickHeight - 0.02, 0.02),
            tkMat
          );
          tkBack.position.set(0, -h/2 + sbToeKickHeight/2, d/2 - sbToeKickRecess);
          group.add(tkBack);

          const tkFloor = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.1, 0.02, sbToeKickRecess - 0.02),
            tkMat
          );
          tkFloor.position.set(0, -h/2 + 0.01, d/2 - sbToeKickRecess/2);
          group.add(tkFloor);

          break;
        }

        case 'lazy-susan': {
          // LAZY SUSAN CORNER CABINET - L-shaped with rotating shelves inside
          // Similar to corner cabinet but with bi-fold doors revealing lazy susan mechanism

          // Use wood grain texture like other cabinets for consistency
          const lsCabinetFinish = el.cabinetFinish || 'wood-grain';
          const lsGrainType = el.grainType || 'oak';
          let lsWoodTexture = null;
          let lsBaseRoughness = 0.35;
          let lsBaseMetalness = 0.02;

          // Check for custom texture first
          if (textureUrl) {
            const textureLoader = new THREE.TextureLoader();
            try {
              lsWoodTexture = textureLoader.load(textureUrl);
              lsWoodTexture.wrapS = THREE.RepeatWrapping;
              lsWoodTexture.wrapT = THREE.RepeatWrapping;
              lsWoodTexture.repeat.set(2, 2);
            } catch (e) {
              lsWoodTexture = createWoodGrainTexture(color, 0.12, lsGrainType);
            }
            lsBaseRoughness = 0.3;
            lsBaseMetalness = 0.02;
          } else if (lsCabinetFinish === 'wood-grain') {
            lsWoodTexture = createWoodGrainTexture(color, 0.12, lsGrainType);
            lsBaseRoughness = 0.3;
            lsBaseMetalness = 0.02;
          } else if (lsCabinetFinish === 'painted') {
            lsWoodTexture = createWoodGrainTexture(color, 0.05, 'flat');
            lsBaseRoughness = 0.4;
            lsBaseMetalness = 0.01;
          } else if (lsCabinetFinish === 'matte') {
            lsWoodTexture = createWoodGrainTexture(color, 0.03, 'flat');
            lsBaseRoughness = 0.7;
            lsBaseMetalness = 0.0;
          } else if (lsCabinetFinish === 'gloss') {
            lsWoodTexture = createWoodGrainTexture(color, 0.02, 'flat');
            lsBaseRoughness = 0.1;
            lsBaseMetalness = 0.05;
          }

          const cabinetMat = new THREE.MeshStandardMaterial({
            color: color,
            map: lsWoodTexture,
            roughness: lsBaseRoughness,
            metalness: lsBaseMetalness,
            bumpScale: lsWoodTexture ? 0.002 : 0
          });
          const bodyMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.9 });
          const handleMat = new THREE.MeshStandardMaterial({ color: 0xc0c0c0, metalness: 0.8, roughness: 0.2 });
          const shelfMat = new THREE.MeshStandardMaterial({ color: 0x8B7355, roughness: 0.5 }); // Wood colored shelves
          const doorMat = new THREE.MeshStandardMaterial({
            color: color,
            map: lsWoodTexture,
            roughness: lsBaseRoughness,
            metalness: lsBaseMetalness,
            bumpScale: lsWoodTexture ? 0.002 : 0
          });

          // Cabinet dimensions
          const toeKickHeight = 0.33;
          const toeKickRecess = 0.25;
          const cabinetBodyHeight = h - toeKickHeight;
          const armDepth = 2; // Standard 24" arm depth
          const panelThickness = 0.06;

          const bodyYOffset = toeKickHeight / 2;

          // Create L-shaped cabinet body using THREE.Shape
          const lsShape = new THREE.Shape();
          lsShape.moveTo(-w/2, -d/2);
          lsShape.lineTo(-w/2, -d/2 + armDepth);
          lsShape.lineTo(-w/2 + armDepth, -d/2 + armDepth);
          lsShape.lineTo(-w/2 + armDepth, d/2);
          lsShape.lineTo(w/2, d/2);
          lsShape.lineTo(w/2, -d/2);
          lsShape.closePath();

          const lsExtrudeSettings = { depth: cabinetBodyHeight, bevelEnabled: false };
          const lsGeometry = new THREE.ExtrudeGeometry(lsShape, lsExtrudeSettings);
          lsGeometry.rotateX(-Math.PI / 2);
          lsGeometry.translate(0, -cabinetBodyHeight/2, 0);

          const cabinetBody = new THREE.Mesh(lsGeometry, cabinetMat);
          cabinetBody.position.y = bodyYOffset;
          group.add(cabinetBody);

          // Dark interior panels
          const backPanel = new THREE.Mesh(
            new THREE.BoxGeometry(w - armDepth - 0.1, cabinetBodyHeight - 0.1, panelThickness),
            bodyMat
          );
          backPanel.position.set(armDepth/2, bodyYOffset, -d/2 + armDepth - panelThickness/2);
          group.add(backPanel);

          const sidePanel = new THREE.Mesh(
            new THREE.BoxGeometry(panelThickness, cabinetBodyHeight - 0.1, d - armDepth - 0.1),
            bodyMat
          );
          sidePanel.position.set(-w/2 + armDepth - panelThickness/2, bodyYOffset, armDepth/2);
          group.add(sidePanel);

          // LAZY SUSAN ROTATING SHELVES - visible through diagonal opening
          const shelfRadius = Math.min(w, d) * 0.42;
          const shelfCenterX = 0;  // Center of cabinet opening
          const shelfCenterZ = 0;
          const numShelves = 2;

          // Center pole (chrome/metal)
          const poleMat = new THREE.MeshStandardMaterial({ color: 0x888888, metalness: 0.7, roughness: 0.3 });
          const centerPole = new THREE.Mesh(
            new THREE.CylinderGeometry(0.025, 0.025, cabinetBodyHeight - 0.2, 16),
            poleMat
          );
          centerPole.position.set(shelfCenterX, bodyYOffset, shelfCenterZ);
          group.add(centerPole);

          // Create kidney/pie-shaped lazy susan shelves
          for (let s = 0; s < numShelves; s++) {
            const shelfY = bodyYOffset - cabinetBodyHeight/2 + 0.5 + s * (cabinetBodyHeight * 0.4);

            // Create pie-shaped shelf (270 degrees)
            const pieShape = new THREE.Shape();
            const pieAngleStart = Math.PI * 0.75;  // Start at back-left
            const pieAngleEnd = Math.PI * 2.25;    // 270 degrees
            const segments = 32;

            pieShape.moveTo(0, 0);
            for (let i = 0; i <= segments; i++) {
              const angle = pieAngleStart + (pieAngleEnd - pieAngleStart) * (i / segments);
              pieShape.lineTo(Math.cos(angle) * shelfRadius, Math.sin(angle) * shelfRadius);
            }
            pieShape.lineTo(0, 0);

            const shelfGeom = new THREE.ExtrudeGeometry(pieShape, { depth: 0.025, bevelEnabled: false });
            shelfGeom.rotateX(-Math.PI / 2);

            const shelf = new THREE.Mesh(shelfGeom, shelfMat);
            shelf.position.set(shelfCenterX, shelfY, shelfCenterZ);
            shelf.rotation.y = Math.PI / 4; // Rotate to face opening
            group.add(shelf);

            // Shelf rim (edge)
            const rimMat = new THREE.MeshStandardMaterial({ color: 0x665544, roughness: 0.6 });
            const rimCurve = new THREE.EllipseCurve(0, 0, shelfRadius, shelfRadius, pieAngleStart, pieAngleEnd, false);
            const rimPoints = rimCurve.getPoints(32);
            const rimGeom = new THREE.BufferGeometry().setFromPoints(
              rimPoints.map(p => new THREE.Vector3(p.x, 0, p.y))
            );
            const rim = new THREE.Line(rimGeom, new THREE.LineBasicMaterial({ color: 0x444444 }));
            rim.position.set(shelfCenterX, shelfY + 0.015, shelfCenterZ);
            rim.rotation.y = Math.PI / 4;
            group.add(rim);
          }

          // DIAGONAL BI-FOLD DOORS (characteristic of lazy susan cabinets)
          const diagP1 = { x: -w/2 + armDepth, z: d/2 };
          const diagP2 = { x: w/2, z: -d/2 + armDepth };
          const diagDoorWidth = Math.sqrt(Math.pow(diagP2.x - diagP1.x, 2) + Math.pow(diagP1.z - diagP2.z, 2));
          const doorHeight = cabinetBodyHeight - 0.15;
          const halfDoorWidth = (diagDoorWidth - 0.1) / 2;

          const diagCenterX = (diagP1.x + diagP2.x) / 2;
          const diagCenterZ = (diagP1.z + diagP2.z) / 2;

          // Create two doors (bi-fold style)
          for (let doorIdx = 0; doorIdx < 2; doorIdx++) {
            const doorGroup = new THREE.Group();

            // Door panel
            const doorPanel = new THREE.Mesh(
              new THREE.BoxGeometry(halfDoorWidth, doorHeight, panelThickness),
              doorMat
            );
            doorGroup.add(doorPanel);

            // Shaker inset
            const insetW = halfDoorWidth - 0.15;
            const insetH = doorHeight - 0.2;
            const inset = new THREE.Mesh(
              new THREE.BoxGeometry(insetW, insetH, 0.02),
              new THREE.MeshStandardMaterial({ color: adjustColorBrightness(color, -10), roughness: 0.5 })
            );
            inset.position.z = panelThickness/2 + 0.01;
            doorGroup.add(inset);

            // Modern bar handle
            const handleLen = Math.min(doorHeight * 0.3, 0.2);
            const lsHandleFinish = el.handleFinish || 'brushed-nickel';
            const handle = createModernBarHandle(handleLen, lsHandleFinish);
            const handleXPos = doorIdx === 0 ? halfDoorWidth/2 - 0.1 : -halfDoorWidth/2 + 0.1;
            handle.position.set(handleXPos, 0, panelThickness/2 + 0.04);
            handle.rotation.z = Math.PI / 2; // Vertical
            doorGroup.add(handle);

            // Position door
            const doorXOffset = doorIdx === 0 ? -halfDoorWidth/2 - 0.02 : halfDoorWidth/2 + 0.02;
            doorGroup.rotation.y = Math.PI / 4;

            // Calculate position along diagonal
            const offsetDir = doorIdx === 0 ? -1 : 1;
            const offsetAmount = halfDoorWidth/2 + 0.02;
            doorGroup.position.set(
              diagCenterX + offsetDir * offsetAmount * Math.cos(Math.PI/4) * 0.5,
              bodyYOffset,
              diagCenterZ + offsetDir * offsetAmount * Math.sin(Math.PI/4) * 0.5
            );
            group.add(doorGroup);
          }

          // TOE KICK
          const tkMat = new THREE.MeshStandardMaterial({ color: 0x080808, roughness: 0.95 });
          const tkHeight = toeKickHeight - 0.02;

          const tkShape = new THREE.Shape();
          tkShape.moveTo(-w/2 + toeKickRecess, -d/2 + toeKickRecess);
          tkShape.lineTo(-w/2 + toeKickRecess, -d/2 + armDepth - toeKickRecess);
          tkShape.lineTo(-w/2 + armDepth - toeKickRecess, -d/2 + armDepth - toeKickRecess);
          tkShape.lineTo(-w/2 + armDepth - toeKickRecess, d/2 - toeKickRecess);
          tkShape.lineTo(w/2 - toeKickRecess, d/2 - toeKickRecess);
          tkShape.lineTo(w/2 - toeKickRecess, -d/2 + toeKickRecess);
          tkShape.closePath();

          const tkExtrudeSettings = { depth: tkHeight, bevelEnabled: false };
          const tkGeometry = new THREE.ExtrudeGeometry(tkShape, tkExtrudeSettings);
          tkGeometry.rotateX(-Math.PI / 2);
          tkGeometry.translate(0, -h/2 + tkHeight/2, 0);

          const toeKick = new THREE.Mesh(tkGeometry, tkMat);
          group.add(toeKick);

          // Floor shadow
          const tkFloor = new THREE.Mesh(
            new THREE.PlaneGeometry(w, d),
            new THREE.MeshStandardMaterial({ color: 0x0a0a0a, roughness: 1 })
          );
          tkFloor.rotation.x = -Math.PI / 2;
          tkFloor.position.y = -h/2 + 0.01;
          group.add(tkFloor);

          break;
        }

        case 'corner-cabinet': {
          // L-SHAPED CORNER CABINET - Sits in corner with diagonal door
          // Standard corner cabinet: 36" x 36" footprint, arms are 24" deep
          // Cabinet sits in back-left corner with diagonal door facing front-right

          // Use wood grain texture like other cabinets for consistency
          const ccCabinetFinish = el.cabinetFinish || 'wood-grain';
          const ccGrainType = el.grainType || 'oak';
          let ccWoodTexture = null;
          let ccBaseRoughness = 0.35;
          let ccBaseMetalness = 0.02;

          // Check for custom texture first
          if (textureUrl) {
            const textureLoader = new THREE.TextureLoader();
            try {
              ccWoodTexture = textureLoader.load(textureUrl);
              ccWoodTexture.wrapS = THREE.RepeatWrapping;
              ccWoodTexture.wrapT = THREE.RepeatWrapping;
              ccWoodTexture.repeat.set(2, 2);
            } catch (e) {
              ccWoodTexture = createWoodGrainTexture(color, 0.12, ccGrainType);
            }
            ccBaseRoughness = 0.3;
            ccBaseMetalness = 0.02;
          } else if (ccCabinetFinish === 'wood-grain') {
            ccWoodTexture = createWoodGrainTexture(color, 0.12, ccGrainType);
            ccBaseRoughness = 0.3;
            ccBaseMetalness = 0.02;
          } else if (ccCabinetFinish === 'painted') {
            ccWoodTexture = createWoodGrainTexture(color, 0.05, 'flat');
            ccBaseRoughness = 0.4;
            ccBaseMetalness = 0.01;
          } else if (ccCabinetFinish === 'matte') {
            ccWoodTexture = createWoodGrainTexture(color, 0.03, 'flat');
            ccBaseRoughness = 0.7;
            ccBaseMetalness = 0.0;
          } else if (ccCabinetFinish === 'gloss') {
            ccWoodTexture = createWoodGrainTexture(color, 0.02, 'flat');
            ccBaseRoughness = 0.1;
            ccBaseMetalness = 0.05;
          }

          const cabinetMat = new THREE.MeshStandardMaterial({
            color: color,
            map: ccWoodTexture,
            roughness: ccBaseRoughness,
            metalness: ccBaseMetalness,
            bumpScale: ccWoodTexture ? 0.002 : 0
          });
          const bodyMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.9 });
          const handleMat = new THREE.MeshStandardMaterial({ color: 0xc0c0c0, metalness: 0.8, roughness: 0.2 });
          const doorMat = new THREE.MeshStandardMaterial({
            color: color,
            map: ccWoodTexture,
            roughness: ccBaseRoughness,
            metalness: ccBaseMetalness,
            bumpScale: ccWoodTexture ? 0.002 : 0
          });
          const frameMat = new THREE.MeshStandardMaterial({ color: adjustColorBrightness(color, -15), roughness: 0.45 });

          // Cabinet dimensions
          const toeKickHeight = 0.33; // 4" toe kick
          const toeKickRecess = 0.25; // 3" recess
          const cabinetBodyHeight = h - toeKickHeight;
          const armDepth = 2; // Standard 24" arm depth
          const panelThickness = 0.06; // 3/4" panels

          // Y offset for body (centered on cabinet body, not including toe kick)
          const bodyYOffset = toeKickHeight / 2;

          // Create L-shaped cabinet using THREE.Shape for proper geometry
          const lShape = new THREE.Shape();
          // Start at back-left corner and trace L-shape clockwise
          // In local coords: back is -Z, left is -X, front is +Z, right is +X
          lShape.moveTo(-w/2, -d/2);                    // Back-left corner (into walls)
          lShape.lineTo(-w/2, -d/2 + armDepth);         // Along left wall
          lShape.lineTo(-w/2 + armDepth, -d/2 + armDepth); // Turn at inside corner
          lShape.lineTo(-w/2 + armDepth, d/2);          // Forward along inside of left arm
          lShape.lineTo(w/2, d/2);                      // Across front (this is where diagonal will be)
          lShape.lineTo(w/2, -d/2);                     // Along right edge to back wall
          lShape.lineTo(-w/2, -d/2);                    // Close back to start

          // Extrude L-shape for cabinet body
          const extrudeSettings = {
            depth: cabinetBodyHeight,
            bevelEnabled: false
          };
          const lGeometry = new THREE.ExtrudeGeometry(lShape, extrudeSettings);
          lGeometry.rotateX(-Math.PI / 2); // Rotate to stand upright
          lGeometry.translate(0, -cabinetBodyHeight/2, 0); // Center vertically

          const cabinetBody = new THREE.Mesh(lGeometry, cabinetMat);
          cabinetBody.position.y = bodyYOffset;
          group.add(cabinetBody);

          // Dark interior back panels (visible through diagonal opening)
          // Back panel
          const backPanel = new THREE.Mesh(
            new THREE.BoxGeometry(w - armDepth - 0.1, cabinetBodyHeight - 0.1, panelThickness),
            bodyMat
          );
          backPanel.position.set(armDepth/2, bodyYOffset, -d/2 + armDepth - panelThickness/2);
          group.add(backPanel);

          // Side interior panel
          const sidePanel = new THREE.Mesh(
            new THREE.BoxGeometry(panelThickness, cabinetBodyHeight - 0.1, d - armDepth - 0.1),
            bodyMat
          );
          sidePanel.position.set(-w/2 + armDepth - panelThickness/2, bodyYOffset, armDepth/2);
          group.add(sidePanel);

          // DIAGONAL DOOR - angled at 45 across the open corner
          // Door spans from inside corner to the front edges of both arms
          const diagP1 = { x: -w/2 + armDepth, z: d/2 };  // End of left arm (front-left)
          const diagP2 = { x: w/2, z: -d/2 + armDepth };  // End of back arm (back-right)

          // Door dimensions
          const diagDoorWidth = Math.sqrt(Math.pow(diagP2.x - diagP1.x, 2) + Math.pow(diagP1.z - diagP2.z, 2));
          const doorHeight = cabinetBodyHeight - 0.15;

          // Create door with shaker-style panel
          const doorGroup = new THREE.Group();

          // Door frame/face
          const doorFace = new THREE.Mesh(
            new THREE.BoxGeometry(diagDoorWidth - 0.08, doorHeight, panelThickness),
            doorMat
          );
          doorGroup.add(doorFace);

          // Shaker inset panel (recessed center)
          const insetWidth = diagDoorWidth - 0.35;
          const insetHeight = doorHeight - 0.25;
          const inset = new THREE.Mesh(
            new THREE.BoxGeometry(insetWidth, insetHeight, 0.02),
            new THREE.MeshStandardMaterial({ color: adjustColorBrightness(color, -8), roughness: 0.5 })
          );
          inset.position.z = panelThickness/2 + 0.01;
          doorGroup.add(inset);

          // Shaker frame lines (grooves)
          const grooveMat = new THREE.MeshStandardMaterial({ color: 0x000000, transparent: true, opacity: 0.15 });
          const grooveDepth = 0.005;
          // Top groove
          const topGroove = new THREE.Mesh(new THREE.BoxGeometry(insetWidth + 0.02, 0.02, grooveDepth), grooveMat);
          topGroove.position.set(0, insetHeight/2 + 0.01, panelThickness/2 + 0.015);
          doorGroup.add(topGroove);
          // Bottom groove
          const botGroove = new THREE.Mesh(new THREE.BoxGeometry(insetWidth + 0.02, 0.02, grooveDepth), grooveMat);
          botGroove.position.set(0, -insetHeight/2 - 0.01, panelThickness/2 + 0.015);
          doorGroup.add(botGroove);
          // Left groove
          const leftGroove = new THREE.Mesh(new THREE.BoxGeometry(0.02, insetHeight + 0.02, grooveDepth), grooveMat);
          leftGroove.position.set(-insetWidth/2 - 0.01, 0, panelThickness/2 + 0.015);
          doorGroup.add(leftGroove);
          // Right groove
          const rightGroove = new THREE.Mesh(new THREE.BoxGeometry(0.02, insetHeight + 0.02, grooveDepth), grooveMat);
          rightGroove.position.set(insetWidth/2 + 0.01, 0, panelThickness/2 + 0.015);
          doorGroup.add(rightGroove);

          // Modern bar handle with standoffs
          const cornerHandleLen = 0.22;
          const cornerHandleFinish = el.handleFinish || 'brushed-nickel';
          const handle = createModernBarHandle(cornerHandleLen, cornerHandleFinish);
          handle.position.set(diagDoorWidth/2 - 0.18, 0, panelThickness/2 + 0.05);
          handle.rotation.z = Math.PI / 2; // Vertical orientation
          doorGroup.add(handle);

          // Position and rotate door group
          const diagCenterX = (diagP1.x + diagP2.x) / 2;
          const diagCenterZ = (diagP1.z + diagP2.z) / 2;
          doorGroup.rotation.y = Math.PI / 4; // 45 degree angle (door faces front-right)
          doorGroup.position.set(diagCenterX, bodyYOffset, diagCenterZ);
          group.add(doorGroup);

          // TOE KICK - L-shaped recessed base
          const tkMat = new THREE.MeshStandardMaterial({ color: 0x080808, roughness: 0.95 });
          const tkHeight = toeKickHeight - 0.02;

          // Create L-shaped toe kick using shape (smaller than cabinet by recess amount)
          const tkShape = new THREE.Shape();
          tkShape.moveTo(-w/2 + toeKickRecess, -d/2 + toeKickRecess);
          tkShape.lineTo(-w/2 + toeKickRecess, -d/2 + armDepth - toeKickRecess);
          tkShape.lineTo(-w/2 + armDepth - toeKickRecess, -d/2 + armDepth - toeKickRecess);
          tkShape.lineTo(-w/2 + armDepth - toeKickRecess, d/2 - toeKickRecess);
          tkShape.lineTo(w/2 - toeKickRecess, d/2 - toeKickRecess);
          tkShape.lineTo(w/2 - toeKickRecess, -d/2 + toeKickRecess);
          tkShape.closePath();

          const tkExtrudeSettings = { depth: tkHeight, bevelEnabled: false };
          const tkGeometry = new THREE.ExtrudeGeometry(tkShape, tkExtrudeSettings);
          tkGeometry.rotateX(-Math.PI / 2);
          tkGeometry.translate(0, -h/2 + tkHeight/2, 0);

          const toeKick = new THREE.Mesh(tkGeometry, tkMat);
          group.add(toeKick);

          // Floor under toe kick (visible shadow catcher)
          const tkFloor = new THREE.Mesh(
            new THREE.PlaneGeometry(w, d),
            new THREE.MeshStandardMaterial({ color: 0x0a0a0a, roughness: 1 })
          );
          tkFloor.rotation.x = -Math.PI / 2;
          tkFloor.position.y = -h/2 + 0.01;
          group.add(tkFloor);

          break;
        }

        case 'tall-cabinet': {
          // Tall pantry cabinet with two door sections
          // Use wood grain texture like other cabinets for consistency
          const tallCabinetFinish = el.cabinetFinish || 'wood-grain';
          const tallGrainType = el.grainType || 'oak';
          let tallWoodTexture = null;
          let tallBaseRoughness = 0.35;
          let tallBaseMetalness = 0.02;

          // Check for custom texture first
          if (textureUrl) {
            const textureLoader = new THREE.TextureLoader();
            try {
              tallWoodTexture = textureLoader.load(textureUrl);
              tallWoodTexture.wrapS = THREE.RepeatWrapping;
              tallWoodTexture.wrapT = THREE.RepeatWrapping;
              tallWoodTexture.repeat.set(2, 2);
            } catch (e) {
              tallWoodTexture = createWoodGrainTexture(color, 0.12, tallGrainType);
            }
            tallBaseRoughness = 0.3;
            tallBaseMetalness = 0.02;
          } else if (tallCabinetFinish === 'wood-grain') {
            tallWoodTexture = createWoodGrainTexture(color, 0.12, tallGrainType);
            tallBaseRoughness = 0.3;
            tallBaseMetalness = 0.02;
          } else if (tallCabinetFinish === 'painted') {
            tallWoodTexture = createWoodGrainTexture(color, 0.05, 'flat');
            tallBaseRoughness = 0.4;
            tallBaseMetalness = 0.01;
          } else if (tallCabinetFinish === 'matte') {
            tallWoodTexture = createWoodGrainTexture(color, 0.03, 'flat');
            tallBaseRoughness = 0.7;
            tallBaseMetalness = 0.0;
          } else if (tallCabinetFinish === 'gloss') {
            tallWoodTexture = createWoodGrainTexture(color, 0.02, 'flat');
            tallBaseRoughness = 0.1;
            tallBaseMetalness = 0.05;
          }

          // Main cabinet body (dark interior)
          const bodyMat = new THREE.MeshStandardMaterial({
            color: 0x2a2a2a,
            roughness: 0.8
          });
          const body = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.08, h - 0.08, d - 0.1),
            bodyMat
          );
          body.position.z = -0.02;
          group.add(body);

          // Cabinet face material with wood grain texture
          const faceMat = new THREE.MeshStandardMaterial({
            color: color,
            map: tallWoodTexture,
            roughness: tallBaseRoughness,
            metalness: tallBaseMetalness,
            bumpScale: tallWoodTexture ? 0.002 : 0
          });

          // Door calculation
          const numDoors = Math.max(1, Math.round(w / 1.5));
          const doorGap = 0.03;
          const totalGaps = doorGap * (numDoors + 1);
          const doorWidth = (w - totalGaps) / numDoors;
          const doorHeight = h - doorGap * 2;

          for (let i = 0; i < numDoors; i++) {
            // Door panel (main)
            const door = new THREE.Mesh(
              new THREE.BoxGeometry(doorWidth, doorHeight, 0.06),
              faceMat
            );
            const doorX = -w/2 + doorGap + doorWidth/2 + i * (doorWidth + doorGap);
            door.position.set(doorX, 0, d/2);
            group.add(door);

            // SHAKER FRAME DETAIL
            const frameW = 0.1;
            const frameD = 0.02;
            const frameMat = new THREE.MeshStandardMaterial({
              color: color,
              roughness: 0.3,
              metalness: 0.01
            });

            // Top rail
            const topRail = new THREE.Mesh(
              new THREE.BoxGeometry(doorWidth - 0.04, frameW, frameD),
              frameMat
            );
            topRail.position.set(doorX, doorHeight/2 - frameW/2 - 0.02, d/2 + 0.04);
            group.add(topRail);

            // Bottom rail
            const bottomRail = new THREE.Mesh(
              new THREE.BoxGeometry(doorWidth - 0.04, frameW, frameD),
              frameMat
            );
            bottomRail.position.set(doorX, -doorHeight/2 + frameW/2 + 0.02, d/2 + 0.04);
            group.add(bottomRail);

            // Left stile
            const leftStile = new THREE.Mesh(
              new THREE.BoxGeometry(frameW, doorHeight - frameW * 2 - 0.04, frameD),
              frameMat
            );
            leftStile.position.set(doorX - doorWidth/2 + frameW/2 + 0.02, 0, d/2 + 0.04);
            group.add(leftStile);

            // Right stile
            const rightStile = new THREE.Mesh(
              new THREE.BoxGeometry(frameW, doorHeight - frameW * 2 - 0.04, frameD),
              frameMat
            );
            rightStile.position.set(doorX + doorWidth/2 - frameW/2 - 0.02, 0, d/2 + 0.04);
            group.add(rightStile);

            // Recessed center panel
            const panelMat = new THREE.MeshStandardMaterial({
              color: color,
              roughness: 0.45
            });
            const panelWidth = doorWidth - frameW * 2 - 0.08;
            const panelHeight = doorHeight - frameW * 2 - 0.08;
            const centerPanel = new THREE.Mesh(
              new THREE.BoxGeometry(panelWidth, panelHeight, 0.015),
              panelMat
            );
            centerPanel.position.set(doorX, 0, d/2 + 0.02);
            group.add(centerPanel);

            // Modern bar handle with standoffs
            const handleY = el.type === 'wall-cabinet' ? -doorHeight * 0.25 : doorHeight * 0.25;
            const handleSide = (i < numDoors / 2) ? 1 : -1;
            const handleX = doorX + handleSide * (doorWidth/2 - 0.15);

            const tallHandleLen = Math.min(doorHeight * 0.2, 0.35);
            const tallHandleFinish = el.handleFinish || 'brushed-nickel';
            const pull = createModernBarHandle(tallHandleLen, tallHandleFinish);
            pull.position.set(handleX, handleY, d/2 + 0.095);
            pull.rotation.z = Math.PI / 2; // Vertical orientation
            group.add(pull);
          }

          // Toe kick for tall cabinet - proper recessed void
          const toeKickHeight = 0.33;
          const toeKickRecess = 0.25;

          // Toe kick back panel (visible back of recess)
          const tkBackMat = new THREE.MeshStandardMaterial({ color: 0x0a0a0a, roughness: 0.95 });
          const tkBack = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.1, toeKickHeight - 0.02, 0.02),
            tkBackMat
          );
          tkBack.position.set(0, -h/2 + toeKickHeight/2, d/2 - toeKickRecess);
          group.add(tkBack);

          // Toe kick bottom (floor of recess)
          const tkBottom = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.1, 0.02, toeKickRecess - 0.02),
            tkBackMat
          );
          tkBottom.position.set(0, -h/2 + 0.01, d/2 - toeKickRecess/2);
          group.add(tkBottom);

          // Left side panel of toe kick recess
          const tkLeft = new THREE.Mesh(
            new THREE.BoxGeometry(0.02, toeKickHeight - 0.02, toeKickRecess),
            tkBackMat
          );
          tkLeft.position.set(-w/2 + 0.05, -h/2 + toeKickHeight/2, d/2 - toeKickRecess/2);
          group.add(tkLeft);

          // Right side panel of toe kick recess
          const tkRight = new THREE.Mesh(
            new THREE.BoxGeometry(0.02, toeKickHeight - 0.02, toeKickRecess),
            tkBackMat
          );
          tkRight.position.set(w/2 - 0.05, -h/2 + toeKickHeight/2, d/2 - toeKickRecess/2);
          group.add(tkRight);

          // Cabinet overhang lip (bottom edge of cabinet above toe kick)
          const lipMat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.4 });
          const lip = new THREE.Mesh(
            new THREE.BoxGeometry(w, 0.03, 0.04),
            lipMat
          );
          lip.position.set(0, -h/2 + toeKickHeight + 0.015, d/2 - 0.02);
          group.add(lip);
          break;
        }

        case 'fridge-cabinet': {
          // Fridge cabinet - enclosure that goes up and over refrigerator
          // Standard dimensions: 84" tall (7ft), with 12" cabinet above, ~68" fridge opening, 4" toe kick
          // The fridge cabinet includes an integrated refrigerator in the opening

          // Use wood grain texture for cabinet parts
          const fcCabinetFinish = el.cabinetFinish || 'wood-grain';
          const fcGrainType = el.grainType || 'oak';
          let fcWoodTexture = null;
          let fcBaseRoughness = 0.35;

          // Check for custom texture first
          if (textureUrl) {
            const textureLoader = new THREE.TextureLoader();
            try {
              fcWoodTexture = textureLoader.load(textureUrl);
              fcWoodTexture.wrapS = THREE.RepeatWrapping;
              fcWoodTexture.wrapT = THREE.RepeatWrapping;
              fcWoodTexture.repeat.set(2, 2);
            } catch (e) {
              fcWoodTexture = createWoodGrainTexture(color, 0.12, fcGrainType);
            }
            fcBaseRoughness = 0.3;
          } else if (fcCabinetFinish === 'wood-grain') {
            fcWoodTexture = createWoodGrainTexture(color, 0.12, fcGrainType);
            fcBaseRoughness = 0.3;
          } else if (fcCabinetFinish === 'painted' || fcCabinetFinish === 'matte' || fcCabinetFinish === 'gloss') {
            fcWoodTexture = createWoodGrainTexture(color, 0.03, 'flat');
            fcBaseRoughness = fcCabinetFinish === 'gloss' ? 0.1 : (fcCabinetFinish === 'matte' ? 0.7 : 0.4);
          }

          const fridgeCabMat = new THREE.MeshStandardMaterial({
            color: color,
            map: fcWoodTexture,
            roughness: fcBaseRoughness,
            metalness: 0.02,
            bumpScale: fcWoodTexture ? 0.002 : 0
          });

          // Dimensions - use standard building proportions
          const panelWidth = 0.125;  // 1.5" side panel thickness
          const toeKickHeight = 0.33;  // 4" toe kick (standard)
          const topCabinetH = 1.0;  // 12" cabinet above fridge (fixed size)
          const fridgeOpeningH = h - topCabinetH - toeKickHeight;  // Remaining height for fridge
          const fridgeOpeningW = w - panelWidth * 2;  // Width of fridge opening

          // Dark interior material for opening
          const interiorMat = new THREE.MeshStandardMaterial({
            color: 0x1a1a1a,
            roughness: 0.9
          });

          // === LEFT SIDE PANEL ===
          const leftPanel = new THREE.Mesh(
            new THREE.BoxGeometry(panelWidth, h - toeKickHeight, d),
            fridgeCabMat
          );
          leftPanel.position.set(-w/2 + panelWidth/2, toeKickHeight/2, 0);
          group.add(leftPanel);

          // === RIGHT SIDE PANEL ===
          const rightPanel = new THREE.Mesh(
            new THREE.BoxGeometry(panelWidth, h - toeKickHeight, d),
            fridgeCabMat
          );
          rightPanel.position.set(w/2 - panelWidth/2, toeKickHeight/2, 0);
          group.add(rightPanel);

          // === TOP CABINET SECTION (above fridge opening) ===
          const topCabinet = new THREE.Mesh(
            new THREE.BoxGeometry(fridgeOpeningW, topCabinetH, d),
            fridgeCabMat
          );
          topCabinet.position.set(0, h/2 - topCabinetH/2, 0);
          group.add(topCabinet);

          // === CABINET DOOR ON TOP SECTION ===
          const doorMat = new THREE.MeshStandardMaterial({
            color: color,
            map: fcWoodTexture,
            roughness: fcBaseRoughness,
            metalness: 0.02
          });

          const doorGap = 0.03;
          const doorW = fridgeOpeningW - doorGap * 2;
          const doorH = topCabinetH - doorGap * 2;

          // Door panel
          const topDoor = new THREE.Mesh(
            new THREE.BoxGeometry(doorW, doorH, 0.06),
            doorMat
          );
          topDoor.position.set(0, h/2 - topCabinetH/2, d/2);
          group.add(topDoor);

          // Shaker frame detail on door
          const frameW = 0.08;
          const frameD = 0.02;
          const frameMat = new THREE.MeshStandardMaterial({
            color: color,
            map: fcWoodTexture,
            roughness: fcBaseRoughness - 0.02,
            metalness: 0.01
          });

          // Top rail
          const topRail = new THREE.Mesh(
            new THREE.BoxGeometry(doorW - 0.04, frameW, frameD),
            frameMat
          );
          topRail.position.set(0, h/2 - doorGap - frameW/2 - 0.02, d/2 + 0.04);
          group.add(topRail);

          // Bottom rail
          const bottomRail = new THREE.Mesh(
            new THREE.BoxGeometry(doorW - 0.04, frameW, frameD),
            frameMat
          );
          bottomRail.position.set(0, h/2 - topCabinetH + doorGap + frameW/2 + 0.02, d/2 + 0.04);
          group.add(bottomRail);

          // Left stile
          const leftStile = new THREE.Mesh(
            new THREE.BoxGeometry(frameW, doorH - frameW * 2 - 0.04, frameD),
            frameMat
          );
          leftStile.position.set(-doorW/2 + frameW/2 + 0.02, h/2 - topCabinetH/2, d/2 + 0.04);
          group.add(leftStile);

          // Right stile
          const rightStile = new THREE.Mesh(
            new THREE.BoxGeometry(frameW, doorH - frameW * 2 - 0.04, frameD),
            frameMat
          );
          rightStile.position.set(doorW/2 - frameW/2 - 0.02, h/2 - topCabinetH/2, d/2 + 0.04);
          group.add(rightStile);

          // Door handle (centered, horizontal bar)
          const handleMat = new THREE.MeshStandardMaterial({
            color: 0xAAAAAA,
            roughness: 0.15,
            metalness: 0.9
          });
          const handleLength = Math.min(0.3, doorW * 0.6);
          const handle = new THREE.Mesh(
            new THREE.CylinderGeometry(0.012, 0.012, handleLength, 8),
            handleMat
          );
          handle.rotation.z = Math.PI / 2;  // Horizontal
          handle.position.set(0, h/2 - topCabinetH + doorGap + doorH * 0.3, d/2 + 0.1);
          group.add(handle);

          // Handle standoffs
          const standoffMat = new THREE.MeshStandardMaterial({
            color: 0x888888,
            roughness: 0.2,
            metalness: 0.85
          });
          [-handleLength/2 + 0.04, handleLength/2 - 0.04].forEach(xOffset => {
            const standoff = new THREE.Mesh(
              new THREE.CylinderGeometry(0.015, 0.015, 0.035, 8),
              standoffMat
            );
            standoff.rotation.x = Math.PI / 2;
            standoff.position.set(xOffset, h/2 - topCabinetH + doorGap + doorH * 0.3, d/2 + 0.08);
            group.add(standoff);
          });

          // === FRIDGE OPENING (dark recess) ===
          // Back panel of fridge space
          const fridgeBack = new THREE.Mesh(
            new THREE.BoxGeometry(fridgeOpeningW - 0.02, fridgeOpeningH, 0.02),
            interiorMat
          );
          fridgeBack.position.set(0, -h/2 + toeKickHeight + fridgeOpeningH/2, -d/2 + 0.02);
          group.add(fridgeBack);

          // Bottom of fridge space (above toe kick)
          const fridgeBottom = new THREE.Mesh(
            new THREE.BoxGeometry(fridgeOpeningW - 0.02, 0.02, d - 0.1),
            interiorMat
          );
          fridgeBottom.position.set(0, -h/2 + toeKickHeight + 0.01, 0);
          group.add(fridgeBottom);

          // === INTEGRATED REFRIGERATOR IN OPENING ===
          // Render a built-in refrigerator inside the cabinet opening
          const fridgeW = fridgeOpeningW - 0.1;  // Slightly smaller than opening
          const fridgeH = fridgeOpeningH - 0.1;  // Slightly smaller than opening
          const fridgeD = d - 0.15;  // Leave small gap at back

          const fridgeMat = new THREE.MeshStandardMaterial({
            color: 0xD5D5D5,
            roughness: 0.25,
            metalness: 0.55
          });

          // Main fridge body
          const fridgeBody = new THREE.Mesh(
            new THREE.BoxGeometry(fridgeW, fridgeH, fridgeD),
            fridgeMat
          );
          fridgeBody.position.set(0, -h/2 + toeKickHeight + fridgeOpeningH/2, 0.05);
          group.add(fridgeBody);

          // Upper doors (French style - two doors) - 65% of fridge height
          const fridgeDoorMat = new THREE.MeshStandardMaterial({
            color: 0xE0E0E0,
            roughness: 0.2,
            metalness: 0.6
          });

          const upperDoorH = fridgeH * 0.65;
          const fridgeDoorW = (fridgeW - 0.08) / 2;
          const fridgeCenterY = -h/2 + toeKickHeight + fridgeOpeningH/2;

          // Left upper door
          const leftFridgeDoor = new THREE.Mesh(
            new THREE.BoxGeometry(fridgeDoorW, upperDoorH, 0.04),
            fridgeDoorMat
          );
          leftFridgeDoor.position.set(-fridgeDoorW/2 - 0.02, fridgeCenterY + fridgeH * 0.15, fridgeD/2 + 0.07);
          group.add(leftFridgeDoor);

          // Right upper door
          const rightFridgeDoor = new THREE.Mesh(
            new THREE.BoxGeometry(fridgeDoorW, upperDoorH, 0.04),
            fridgeDoorMat
          );
          rightFridgeDoor.position.set(fridgeDoorW/2 + 0.02, fridgeCenterY + fridgeH * 0.15, fridgeD/2 + 0.07);
          group.add(rightFridgeDoor);

          // Freezer drawer - 28% of fridge height
          const freezerDrawer = new THREE.Mesh(
            new THREE.BoxGeometry(fridgeW - 0.08, fridgeH * 0.28, 0.04),
            fridgeDoorMat
          );
          freezerDrawer.position.set(0, fridgeCenterY - fridgeH * 0.33, fridgeD/2 + 0.07);
          group.add(freezerDrawer);

          // Fridge handles
          const fridgeHandleMat = new THREE.MeshStandardMaterial({
            color: 0xA0A0A0,
            roughness: 0.15,
            metalness: 0.9
          });

          // Left handle
          const leftFridgeHandle = new THREE.Mesh(
            new THREE.BoxGeometry(0.035, upperDoorH * 0.5, 0.05),
            fridgeHandleMat
          );
          leftFridgeHandle.position.set(-0.06, fridgeCenterY + fridgeH * 0.15, fridgeD/2 + 0.12);
          group.add(leftFridgeHandle);

          // Right handle
          const rightFridgeHandle = new THREE.Mesh(
            new THREE.BoxGeometry(0.035, upperDoorH * 0.5, 0.05),
            fridgeHandleMat
          );
          rightFridgeHandle.position.set(0.06, fridgeCenterY + fridgeH * 0.15, fridgeD/2 + 0.12);
          group.add(rightFridgeHandle);

          // Freezer handle
          const freezerFridgeHandle = new THREE.Mesh(
            new THREE.BoxGeometry(fridgeW * 0.5, 0.035, 0.05),
            fridgeHandleMat
          );
          freezerFridgeHandle.position.set(0, fridgeCenterY - fridgeH * 0.22, fridgeD/2 + 0.12);
          group.add(freezerFridgeHandle);

          // Water/ice dispenser
          const dispenserMat = new THREE.MeshStandardMaterial({
            color: 0x2a2a2a,
            roughness: 0.3
          });
          const dispenser = new THREE.Mesh(
            new THREE.BoxGeometry(0.25, 0.2, 0.02),
            dispenserMat
          );
          dispenser.position.set(0, fridgeCenterY + fridgeH * 0.25, fridgeD/2 + 0.1);
          group.add(dispenser);

          // === TOE KICK ===
          const tkMat = new THREE.MeshStandardMaterial({ color: 0x0a0a0a, roughness: 0.95 });
          const toeKickRecess = 0.2;

          // Toe kick back
          const tkBack = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.1, toeKickHeight - 0.02, 0.02),
            tkMat
          );
          tkBack.position.set(0, -h/2 + toeKickHeight/2, d/2 - toeKickRecess);
          group.add(tkBack);

          // Toe kick bottom
          const tkBottom = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.1, 0.02, toeKickRecess - 0.02),
            tkMat
          );
          tkBottom.position.set(0, -h/2 + 0.01, d/2 - toeKickRecess/2);
          group.add(tkBottom);

          // Left toe kick side
          const tkLeft = new THREE.Mesh(
            new THREE.BoxGeometry(0.02, toeKickHeight - 0.02, toeKickRecess),
            tkMat
          );
          tkLeft.position.set(-w/2 + 0.05, -h/2 + toeKickHeight/2, d/2 - toeKickRecess/2);
          group.add(tkLeft);

          // Right toe kick side
          const tkRight = new THREE.Mesh(
            new THREE.BoxGeometry(0.02, toeKickHeight - 0.02, toeKickRecess),
            tkMat
          );
          tkRight.position.set(w/2 - 0.05, -h/2 + toeKickHeight/2, d/2 - toeKickRecess/2);
          group.add(tkRight);

          // Lip above toe kick
          const lipMat = new THREE.MeshStandardMaterial({
            color: color,
            map: fcWoodTexture,
            roughness: fcBaseRoughness
          });
          const lip = new THREE.Mesh(
            new THREE.BoxGeometry(w, 0.03, 0.04),
            lipMat
          );
          lip.position.set(0, -h/2 + toeKickHeight + 0.015, d/2 - 0.02);
          group.add(lip);

          break;
        }

        case 'island': {
          // Kitchen island with overhang and proper toe kick
          const baseMat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.4 });

          // Toe kick dimensions
          const toeKickHeight = 0.33;
          const toeKickRecess = 0.25;
          const bodyHeight = h - toeKickHeight - 0.12; // Minus toe kick and countertop

          // Base cabinet portion (raised above toe kick)
          const base = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.4, bodyHeight, d - 0.4),
            baseMat
          );
          base.position.y = -h/2 + toeKickHeight + bodyHeight/2;
          group.add(base);

          // Countertop with overhang
          const counterMat = new THREE.MeshStandardMaterial({
            color: 0x4a4a4a,
            roughness: 0.15,
            metalness: 0.1
          });
          const counter = new THREE.Mesh(
            new THREE.BoxGeometry(w, 0.12, d),
            counterMat
          );
          counter.position.y = h/2 - 0.06;
          group.add(counter);

          // Add door details on front (adjusted for toe kick)
          const doorMat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.35 });
          const numDoors = Math.round(w / 2);
          const doorW = (w - 0.5) / numDoors - 0.05;
          const doorH = bodyHeight - 0.1;
          for (let i = 0; i < numDoors; i++) {
            const door = new THREE.Mesh(
              new THREE.BoxGeometry(doorW, doorH, 0.05),
              doorMat
            );
            door.position.set(-w/2 + 0.25 + doorW/2 + i * (doorW + 0.05), -h/2 + toeKickHeight + bodyHeight/2, d/2 - 0.2);
            group.add(door);
          }

          // Toe kick void on all four sides (island is free-standing)
          const tkBackMat = new THREE.MeshStandardMaterial({ color: 0x0a0a0a, roughness: 0.95 });

          // Front toe kick
          const tkFront = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.5, toeKickHeight - 0.02, 0.02),
            tkBackMat
          );
          tkFront.position.set(0, -h/2 + toeKickHeight/2, d/2 - 0.2 - toeKickRecess);
          group.add(tkFront);

          // Back toe kick
          const tkBackPanel = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.5, toeKickHeight - 0.02, 0.02),
            tkBackMat
          );
          tkBackPanel.position.set(0, -h/2 + toeKickHeight/2, -d/2 + 0.2 + toeKickRecess);
          group.add(tkBackPanel);

          // Left toe kick
          const tkLeftPanel = new THREE.Mesh(
            new THREE.BoxGeometry(0.02, toeKickHeight - 0.02, d - 0.5),
            tkBackMat
          );
          tkLeftPanel.position.set(-w/2 + 0.2 + toeKickRecess, -h/2 + toeKickHeight/2, 0);
          group.add(tkLeftPanel);

          // Right toe kick
          const tkRightPanel = new THREE.Mesh(
            new THREE.BoxGeometry(0.02, toeKickHeight - 0.02, d - 0.5),
            tkBackMat
          );
          tkRightPanel.position.set(w/2 - 0.2 - toeKickRecess, -h/2 + toeKickHeight/2, 0);
          group.add(tkRightPanel);

          // Toe kick floor
          const tkFloor = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.5, 0.02, d - 0.5),
            tkBackMat
          );
          tkFloor.position.set(0, -h/2 + 0.01, 0);
          group.add(tkFloor);

          // Cabinet overhang lip (all around)
          const lipMat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.4 });

          // Front lip
          const lipFront = new THREE.Mesh(new THREE.BoxGeometry(w - 0.4, 0.03, 0.04), lipMat);
          lipFront.position.set(0, -h/2 + toeKickHeight + 0.015, d/2 - 0.2);
          group.add(lipFront);

          // Back lip
          const lipBack = new THREE.Mesh(new THREE.BoxGeometry(w - 0.4, 0.03, 0.04), lipMat);
          lipBack.position.set(0, -h/2 + toeKickHeight + 0.015, -d/2 + 0.2);
          group.add(lipBack);

          // Left lip
          const lipLeft = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.03, d - 0.4), lipMat);
          lipLeft.position.set(-w/2 + 0.2, -h/2 + toeKickHeight + 0.015, 0);
          group.add(lipLeft);

          // Right lip
          const lipRight = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.03, d - 0.4), lipMat);
          lipRight.position.set(w/2 - 0.2, -h/2 + toeKickHeight + 0.015, 0);
          group.add(lipRight);

          break;
        }

        case 'countertop': {
          // Realistic countertop with texture support and detailed edge profiles
          // Thickness handling: 2cm vs 3cm
          const thickness = el.thickness || '3cm';
          const is2cm = thickness === '2cm';
          const edgeBuildStyle = el.edgeBuildStyle || 'mitered';

          // Slab thickness in feet: 3cm = ~0.1 ft (1.2"), 2cm = ~0.065 ft (0.78")
          const slabThickness = is2cm ? 0.065 : 0.1;
          // For 2cm counters, add plywood and drop edge to create full thickness appearance
          const totalVisibleHeight = is2cm ? 0.1 : slabThickness; // 2cm appears same as 3cm with buildup

          // Seam gap for clean butting between adjacent countertops
          const seamGap = 0.01;

          // WATERFALL SIDES: NO overhang on waterfall sides
          // The countertop edge must be flush with the waterfall panel (perfect 90 corner)
          const waterfallSides = el.waterfallSides || [];
          const hasLeftWaterfall = waterfallSides.includes('left');
          const hasRightWaterfall = waterfallSides.includes('right');
          const hasFrontWaterfall = waterfallSides.includes('front');
          const hasBackWaterfall = waterfallSides.includes('back');

          // WATERFALL EDGES: For waterfalls, the countertop maintains its full dimensions
          // The waterfall drops from the countertop's outer edge (including overhang)
          // No overhang reduction needed - the waterfall IS the edge, it just goes vertical

          // Slab dimensions - full width/depth with small seam gap
          const slabW = w - seamGap;
          const slabD = d - seamGap;
          const slabOffsetX = 0;
          const slabOffsetZ = 0;

          const edgeProfile = el.edgeProfile || 'eased';

          // Create countertop material with proper texture scaling based on dimensions
          // Roughness is controlled by finish settings (polished=0.08, honed=0.45, etc.)
          // Do NOT pass explicit roughness  it overrides finish-based values
          const ctopMat = createTexturedMaterial(color, textureUrl, {
            isCountertop: true,
            width: w,
            depth: d,
            finish: el.finish || 'polished'
          });

          // For 2cm counters: add plywood underlayment
          // Skip on waterfall sides - waterfall handles the edge
          if (is2cm && !hasFrontWaterfall) {
            const plywoodMat = new THREE.MeshStandardMaterial({
              color: 0xD4A76A, // Plywood color
              roughness: 0.8,
              metalness: 0
            });

            // Plywood thickness (3/4" = 0.0625 ft)
            const plywoodThickness = 0.0625;

            // Calculate plywood dimensions - shorten for waterfall corners
            const wfT = 0.065; // 2cm waterfall thickness
            let plywoodW = slabW - 0.1;
            let plywoodPosX = slabOffsetX;
            if (hasLeftWaterfall) {
              plywoodW -= wfT;
              plywoodPosX += wfT / 2;
            }
            if (hasRightWaterfall) {
              plywoodW -= wfT;
              plywoodPosX -= wfT / 2;
            }

            // Plywood sheet under the stone (visible from below/back)
            const plywood = new THREE.Mesh(
              new THREE.BoxGeometry(plywoodW, plywoodThickness, slabD - 0.3),
              plywoodMat
            );
            plywood.position.set(plywoodPosX, -slabThickness/2 - plywoodThickness/2 + 0.02, -0.1 + slabOffsetZ);
            group.add(plywood);

            // Drop edge strips (laminated, mitered, or stacked)
            // These go on front edge only - shorten for L/R waterfalls
            let dropEdgeW = slabW;
            let dropEdgePosX = slabOffsetX;
            if (hasLeftWaterfall) {
              dropEdgeW -= wfT;
              dropEdgePosX += wfT / 2;
            }
            if (hasRightWaterfall) {
              dropEdgeW -= wfT;
              dropEdgePosX -= wfT / 2;
            }

            const dropEdgeMat = createTexturedMaterial(color, textureUrl, {
              isCountertop: true,
              width: dropEdgeW,
              depth: 0.06,
              finish: el.finish || 'polished',
              enableBumpMap: false // No bump on thin edge strips
            });

            // Drop height creates appearance of 4cm (1.5") thick stone
            const dropHeight = 0.035; // ~0.4" additional drop for 4cm look

            if (edgeBuildStyle === 'laminated') {
              // Laminated edge - seamless 4cm look, no visible joint
              const lamEdge = new THREE.Mesh(
                new THREE.BoxGeometry(dropEdgeW, dropHeight, 0.06),
                dropEdgeMat
              );
              lamEdge.position.set(dropEdgePosX, -slabThickness/2 - dropHeight/2, slabD/2 - 0.03 + slabOffsetZ);
              group.add(lamEdge);

            } else if (edgeBuildStyle === 'mitered') {
              // Mitered edge - 45 angled seam, nearly invisible
              const miterEdge = new THREE.Mesh(
                new THREE.BoxGeometry(dropEdgeW, dropHeight, 0.05),
                dropEdgeMat
              );
              miterEdge.position.set(dropEdgePosX, -slabThickness/2 - dropHeight/2, slabD/2 - 0.025 + slabOffsetZ);
              group.add(miterEdge);

              // Subtle 45 seam line (barely visible)
              const miterSeamMat = new THREE.MeshStandardMaterial({ color: 0x555555, roughness: 0.4, transparent: true, opacity: 0.6 });
              const miterSeam = new THREE.Mesh(
                new THREE.BoxGeometry(dropEdgeW + 0.005, 0.002, 0.055),
                miterSeamMat
              );
              miterSeam.rotation.x = Math.PI * 0.25;
              miterSeam.position.set(dropEdgePosX, -slabThickness/2 - 0.002, slabD/2 - 0.015 + slabOffsetZ);
              group.add(miterSeam);

            } else {
              // Stacked edge - vertical seam visible at joint
              const stackedEdge = new THREE.Mesh(
                new THREE.BoxGeometry(dropEdgeW, dropHeight, 0.06),
                dropEdgeMat
              );
              stackedEdge.position.set(dropEdgePosX, -slabThickness/2 - dropHeight/2, slabD/2 - 0.03 + slabOffsetZ);
              group.add(stackedEdge);

              // Visible horizontal seam line (vertical cut joint)
              const seamMat = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.6 });
              const seam = new THREE.Mesh(
                new THREE.BoxGeometry(dropEdgeW + 0.01, 0.004, 0.065),
                seamMat
              );
              seam.position.set(dropEdgePosX, -slabThickness/2 + 0.002, slabD/2 - 0.03 + slabOffsetZ);
              group.add(seam);
            }
          }

          // Adjust h to use actual slab thickness for edge profile calculations
          const effectiveH = slabThickness;

          // Create edge profile geometry based on type
          function createEdgeGeometry(profile, length) {
            const shape = new THREE.Shape();
            const t = effectiveH; // Use actual slab thickness (accounts for 2cm vs 3cm)

            switch(profile) {
              case 'flat-polish':
              case 'square':
                // Perfectly square polished edge - no rounding
                shape.moveTo(0, 0);
                shape.lineTo(t, 0);
                shape.lineTo(t, t);
                shape.lineTo(0, t);
                shape.lineTo(0, 0);
                break;

              case 'pencil':
                // Pencil round - small rounded top, eased bottom
                shape.moveTo(0, 0);
                shape.lineTo(t, 0);
                shape.lineTo(t, t * 0.75);
                shape.quadraticCurveTo(t, t, t * 0.85, t);
                shape.lineTo(0, t);
                shape.lineTo(0, 0);
                break;

              case 'quarter-round':
                // Quarter round - larger radius than pencil
                shape.moveTo(0, 0);
                shape.lineTo(t, 0);
                shape.lineTo(t, t * 0.5);
                shape.quadraticCurveTo(t, t, t * 0.5, t);
                shape.lineTo(0, t);
                shape.lineTo(0, 0);
                break;

              case 'half-bullnose':
                // Rounded top edge, square bottom
                shape.moveTo(0, 0);
                shape.lineTo(t, 0);
                shape.lineTo(t, t * 0.6);
                shape.quadraticCurveTo(t, t, t * 0.6, t);
                shape.lineTo(0, t);
                shape.lineTo(0, 0);
                break;

              case 'full-bullnose':
                // Fully rounded edge
                shape.moveTo(t * 0.3, 0);
                shape.lineTo(t * 0.7, 0);
                shape.quadraticCurveTo(t, 0, t, t * 0.3);
                shape.lineTo(t, t * 0.7);
                shape.quadraticCurveTo(t, t, t * 0.7, t);
                shape.lineTo(t * 0.3, t);
                shape.quadraticCurveTo(0, t, 0, t * 0.7);
                shape.lineTo(0, t * 0.3);
                shape.quadraticCurveTo(0, 0, t * 0.3, 0);
                break;

              case 'ogee':
                // S-curve profile
                shape.moveTo(0, 0);
                shape.lineTo(t, 0);
                shape.lineTo(t, t * 0.5);
                shape.bezierCurveTo(t, t * 0.7, t * 0.8, t * 0.8, t * 0.6, t * 0.85);
                shape.bezierCurveTo(t * 0.4, t * 0.9, t * 0.2, t, 0, t);
                shape.lineTo(0, 0);
                break;

              case 'double-ogee':
                // Double S-curve profile
                shape.moveTo(0, 0);
                shape.lineTo(t, 0);
                shape.lineTo(t, t * 0.3);
                shape.bezierCurveTo(t, t * 0.4, t * 0.85, t * 0.45, t * 0.7, t * 0.5);
                shape.bezierCurveTo(t * 0.55, t * 0.55, t * 0.55, t * 0.65, t * 0.7, t * 0.7);
                shape.bezierCurveTo(t * 0.85, t * 0.75, t * 0.9, t * 0.85, t * 0.6, t * 0.9);
                shape.bezierCurveTo(t * 0.3, t * 0.95, t * 0.1, t, 0, t);
                shape.lineTo(0, 0);
                break;

              case 'cove':
                // Inward concave curve
                shape.moveTo(0, 0);
                shape.lineTo(t, 0);
                shape.lineTo(t, t * 0.7);
                shape.quadraticCurveTo(t * 0.7, t, 0, t);
                shape.lineTo(0, 0);
                break;

              case 'mitered':
                // 45-degree mitered edge (creates thicker appearance)
                shape.moveTo(0, 0);
                shape.lineTo(t, 0);
                shape.lineTo(t, t * 0.85);
                shape.lineTo(t * 0.85, t);
                shape.lineTo(0, t);
                shape.lineTo(0, 0);
                break;

              case 'bevel':
              case 'quarter-bevel':
                // 45-degree bevel
                shape.moveTo(0, 0);
                shape.lineTo(t, 0);
                shape.lineTo(t, t * 0.7);
                shape.lineTo(t * 0.7, t);
                shape.lineTo(0, t);
                shape.lineTo(0, 0);
                break;

              case 'dupont':
                // Complex multi-step profile
                shape.moveTo(0, 0);
                shape.lineTo(t, 0);
                shape.lineTo(t, t * 0.4);
                shape.lineTo(t * 0.85, t * 0.5);
                shape.quadraticCurveTo(t * 0.7, t * 0.6, t * 0.7, t * 0.75);
                shape.lineTo(t * 0.7, t);
                shape.lineTo(0, t);
                shape.lineTo(0, 0);
                break;

              case 'chiseled':
                // Rough-hewn textured edge appearance
                shape.moveTo(0, 0);
                shape.lineTo(t * 0.95, 0);
                shape.lineTo(t, t * 0.1);
                shape.lineTo(t * 0.92, t * 0.25);
                shape.lineTo(t * 1.02, t * 0.4);
                shape.lineTo(t * 0.95, t * 0.55);
                shape.lineTo(t * 1.03, t * 0.7);
                shape.lineTo(t * 0.94, t * 0.85);
                shape.lineTo(t * 0.98, t);
                shape.lineTo(0, t);
                shape.lineTo(0, 0);
                break;

              case 'waterfall':
                // Waterfall edge - clean square profile for seamless miter joint
                // The waterfall vertical panel creates the visual interest, edge stays flat
                shape.moveTo(0, 0);
                shape.lineTo(t, 0);
                shape.lineTo(t, t);
                shape.lineTo(0, t);
                shape.lineTo(0, 0);
                break;

              case 'eased':
              default:
                // Simple eased/softened corners
                shape.moveTo(0, 0);
                shape.lineTo(t, 0);
                shape.lineTo(t, t * 0.9);
                shape.quadraticCurveTo(t, t, t * 0.9, t);
                shape.lineTo(0, t);
                shape.lineTo(0, 0);
                break;
            }

            const extrudeSettings = {
              steps: 1,
              depth: length,
              bevelEnabled: false
            };

            return new THREE.ExtrudeGeometry(shape, extrudeSettings);
          }

          // Main slab body - full size, no inset to avoid visible seams
          // Edge profiles are rendered as decorative overlays on the front face

          // Find sinks that overlap with this countertop to create cutouts
          const sinkCutouts = [];
          const ctopLeftFt = el.x / pixelsPerFoot;
          const ctopTopFt = el.y / pixelsPerFoot;
          const ctopRightFt = ctopLeftFt + w;
          const ctopBottomFt = ctopTopFt + d;

          elements.forEach(other => {
            if (other.id === el.id) return;
            if (!['sink', 'sink-double', 'sink-farmhouse'].includes(other.type)) return;

            // Get sink bounds - x/y are pixels, width/height are already in feet
            const sinkLeftFt = other.x / pixelsPerFoot;
            const sinkTopFt = other.y / pixelsPerFoot;
            const sinkWFt = other.width;  // Already in feet
            const sinkDFt = other.height; // Already in feet
            const sinkRightFt = sinkLeftFt + sinkWFt;
            const sinkBottomFt = sinkTopFt + sinkDFt;

            // Check overlap
            if (sinkRightFt > ctopLeftFt && sinkLeftFt < ctopRightFt &&
                sinkBottomFt > ctopTopFt && sinkTopFt < ctopBottomFt) {
              // Calculate sink position relative to countertop center
              const relX = (sinkLeftFt + sinkWFt/2) - (ctopLeftFt + w/2);
              const relZ = (sinkTopFt + sinkDFt/2) - (ctopTopFt + d/2);
              sinkCutouts.push({ x: relX, z: relZ, w: sinkWFt, d: sinkDFt });
            }
          });

          // Determine if edge profile needs separate geometry
          // Skip flat/square/eased edges - main body geometry handles these
          const skipEdgeProfile = ['flat-polish', 'square', 'eased'].includes(edgeProfile);

          // For decorative edges, inset the main body front by the full slab thickness
          // so the edge profile geometry fills the gap exactly (no overlap)
          const edgeInset = skipEdgeProfile ? 0 : effectiveH;

          // Main slab body - full size for flat/square/eased, or front-inset for decorative edges
          // Skip when sinks present (use ExtrudeGeometry with cutouts instead)
          if (sinkCutouts.length === 0) {
            const bodyDepth = slabD - (hasFrontWaterfall ? 0 : edgeInset);
            const bodyOffsetZ = (hasFrontWaterfall ? 0 : -edgeInset / 2);
            const mainBody = new THREE.Mesh(
              new THREE.BoxGeometry(slabW, effectiveH, bodyDepth),
              ctopMat
            );
            mainBody.position.set(slabOffsetX, 0, slabOffsetZ + bodyOffsetZ);
            mainBody.castShadow = true;
            mainBody.receiveShadow = true;
            group.add(mainBody);
          }

          // Edge rendering - decorative profile geometry fills the front face gap
          // Same material as body, DoubleSide for correct visibility after rotation
          const frontEdgeMat = ctopMat.clone();
          frontEdgeMat.side = THREE.DoubleSide;

          // Front edge - SKIP if front has waterfall (waterfall replaces the edge)
          // Also skip for flat/square/eased edges (main body handles these)
          // Also shorten front edge if left/right waterfalls exist (they handle the corners)
          if (!hasFrontWaterfall && !skipEdgeProfile) {
            const wfThicknessForEdge = is2cm ? 0.065 : 0.1;
            let frontEdgeLen = slabW;
            let frontEdgePosX = slabOffsetX;
            if (hasLeftWaterfall) {
              frontEdgeLen -= wfThicknessForEdge;
              frontEdgePosX += wfThicknessForEdge / 2;
            }
            if (hasRightWaterfall) {
              frontEdgeLen -= wfThicknessForEdge;
              frontEdgePosX -= wfThicknessForEdge / 2;
            }
            try {
              const frontEdgeGeo = createEdgeGeometry(edgeProfile, frontEdgeLen);
              const frontEdge = new THREE.Mesh(frontEdgeGeo, frontEdgeMat);
              // Single rotation: extrusion (Z)  runs along X (counter width)
              // Shape X (profile depth)  Z (toward viewer), Y (height)  Y (vertical)
              frontEdge.rotation.y = -Math.PI / 2;
              // Position: edge back (shape x=0) at body front, edge front (shape x=t) at slab front
              frontEdge.position.set(
                frontEdgeLen / 2 + frontEdgePosX,
                -effectiveH / 2,
                slabD / 2 - effectiveH + slabOffsetZ
              );
              frontEdge.castShadow = true;
              group.add(frontEdge);
            } catch(e) {
              // Fallback: thin decorative strip on front face
              const edgeDepth = 0.02;
              const frontEdge = new THREE.Mesh(
                new THREE.BoxGeometry(frontEdgeLen, effectiveH * 0.9, edgeDepth),
                frontEdgeMat
              );
              frontEdge.position.set(frontEdgePosX, 0, slabD/2 + edgeDepth/2 + slabOffsetZ);
              group.add(frontEdge);
            }
          }

          // Side edges for finished ends  thin decorative strips
          // IMPORTANT: Do NOT render on waterfall sides - the waterfall IS the edge
          // Skip for flat/square/eased edges (main body handles these)
          if (el.finishedEnds && !skipEdgeProfile) {
            const sideEdgeDepth = 0.015;
            // Left finished end
            if (el.finishedEnds.includes('left') && !hasLeftWaterfall) {
              const leftEdge = new THREE.Mesh(
                new THREE.BoxGeometry(sideEdgeDepth, effectiveH * 0.95, slabD),
                frontEdgeMat
              );
              leftEdge.position.set(-slabW/2 - sideEdgeDepth/2 + slabOffsetX, 0, slabOffsetZ);
              group.add(leftEdge);
            }
            // Right finished end
            if (el.finishedEnds.includes('right') && !hasRightWaterfall) {
              const rightEdge = new THREE.Mesh(
                new THREE.BoxGeometry(sideEdgeDepth, effectiveH * 0.95, slabD),
                frontEdgeMat
              );
              rightEdge.position.set(slabW/2 + sideEdgeDepth/2 + slabOffsetX, 0, slabOffsetZ);
              group.add(rightEdge);
            }
          }

          // Back edge removed - it's against the wall and not visible
          // The main body is now full-size so no separate back edge needed

          // Countertop with sink cutouts  uses ExtrudeGeometry with holes
          if (sinkCutouts.length > 0) {
            // Create full-thickness countertop with sink holes using ExtrudeGeometry
            const topShape = new THREE.Shape();
            const topHalfW = slabW / 2;
            const topHalfD = slabD / 2;

            // Outer rectangle (CCW when viewed from above)
            topShape.moveTo(-topHalfW, -topHalfD);
            topShape.lineTo(topHalfW, -topHalfD);
            topShape.lineTo(topHalfW, topHalfD);
            topShape.lineTo(-topHalfW, topHalfD);
            topShape.lineTo(-topHalfW, -topHalfD);

            // Add sink holes (CW for holes - clockwise when viewed from above)
            sinkCutouts.forEach(sink => {
              // Use basin size with small reveal for the hole
              const holeW = sink.w * 0.85;
              const holeD = sink.d * 0.85;

              const hole = new THREE.Path();
              // CW winding: start bottom-left, go left to top-left, then top-right, etc.
              hole.moveTo(sink.x - holeW/2, sink.z - holeD/2);
              hole.lineTo(sink.x - holeW/2, sink.z + holeD/2);
              hole.lineTo(sink.x + holeW/2, sink.z + holeD/2);
              hole.lineTo(sink.x + holeW/2, sink.z - holeD/2);
              hole.lineTo(sink.x - holeW/2, sink.z - holeD/2);
              topShape.holes.push(hole);
            });

            // Extrude with full countertop thickness
            const extrudeSettings = {
              depth: effectiveH,
              bevelEnabled: false
            };
            const topGeo = new THREE.ExtrudeGeometry(topShape, extrudeSettings);
            topGeo.rotateX(-Math.PI / 2);
            const countertopWithHole = new THREE.Mesh(topGeo, ctopMat);
            countertopWithHole.position.set(slabOffsetX, -effectiveH/2, slabOffsetZ);
            group.add(countertopWithHole);
          }
          // NOTE: Removed separate top surface mesh - was causing visible seam/cut line
          // The main body already has the textured top face from ctopMat

          // Render seams as subtle grooves in the countertop
          if (el.seams && el.seams.length > 0) {
            const seamMat = new THREE.MeshStandardMaterial({
              color: 0x333333,
              roughness: 0.9,
              metalness: 0
            });

            el.seams.forEach(seam => {
              const seamX = -slabW/2 + slabW * seam.position + slabOffsetX;
              const seamGroove = new THREE.Mesh(
                new THREE.BoxGeometry(0.008, effectiveH + 0.01, slabD),
                seamMat
              );
              seamGroove.position.set(seamX, 0, slabOffsetZ);
              group.add(seamGroove);
            });
          }

          // Render backsplash if enabled
          if (el.backsplash && el.backsplash.height > 0) {
            const bsHeight = el.backsplash.height / 12; // Convert inches to feet
            const bsThickness = 0.04; // ~0.5 inch thick

            // Use same texture as countertop or a different material
            const bsMat = createTexturedMaterial(color, textureUrl, {
              isCountertop: true,
              width: slabW,
              depth: bsThickness,
              finish: el.finish || 'polished'
            });

            // Main backsplash panel - sits behind countertop, on top of counter surface
            const bsPanel = new THREE.Mesh(
              new THREE.BoxGeometry(slabW, bsHeight, bsThickness),
              bsMat
            );
            // Position: centered on counter width, height starts at top of counter, against back wall
            bsPanel.position.set(slabOffsetX, h/2 + bsHeight/2, -slabD/2 + bsThickness/2 + slabOffsetZ);
            group.add(bsPanel);

            // Top edge detail (eased edge on backsplash)
            const bsTopEdge = new THREE.Mesh(
              new THREE.BoxGeometry(slabW + 0.01, 0.015, bsThickness + 0.02),
              createTexturedMaterial(color, textureUrl, { isCountertop: true, finish: el.finish || 'polished' })
            );
            bsTopEdge.position.set(slabOffsetX, h/2 + bsHeight - 0.0075, -slabD/2 + bsThickness/2 + slabOffsetZ);
            group.add(bsTopEdge);

            // Side returns if finished ends are enabled
            if (el.finishedEnds) {
              if (el.finishedEnds.includes('left')) {
                const leftReturn = new THREE.Mesh(
                  new THREE.BoxGeometry(bsThickness, bsHeight, 0.15),
                  bsMat
                );
                leftReturn.position.set(-slabW/2 + bsThickness/2 + slabOffsetX, h/2 + bsHeight/2, -slabD/2 + 0.075 + slabOffsetZ);
                group.add(leftReturn);
              }
              if (el.finishedEnds.includes('right')) {
                const rightReturn = new THREE.Mesh(
                  new THREE.BoxGeometry(bsThickness, bsHeight, 0.15),
                  bsMat
                );
                rightReturn.position.set(slabW/2 - bsThickness/2 + slabOffsetX, h/2 + bsHeight/2, -slabD/2 + 0.075 + slabOffsetZ);
                group.add(rightReturn);
              }
            }
          }

          // Render waterfall edges (vertical stone panels dropping down from countertop)
          // Waterfalls render regardless of edge profile - user can add to any countertop
          if (el.waterfallSides && el.waterfallSides.length > 0) {
            const waterfallMat = createTexturedMaterial(color, textureUrl, {
              isCountertop: true,
              width: w,
              depth: d,
              finish: el.finish || 'polished'
            });

            // Waterfall drop height (default to floor = counter height)
            const dropHeight = el.waterfallDropFeet || 2.9; // Default counter height from floor

            // For 2cm stone, waterfall gets laminated edges on all visible sides
            const wfThickness = is2cm ? 0.065 : slabThickness;
            const wfEdgeThickness = is2cm ? 0.035 : 0; // Laminated edge build for 2cm

            el.waterfallSides.forEach(side => {
              let wfW, wfD, wfPosX, wfPosZ;

              // WATERFALL: Perfect 90 turn - NO overhang, NO lip
              // The waterfall outer face must be FLUSH with countertop edge
              // Position waterfall so its INNER face is at the adjusted slab edge
              // This way the countertop ends right where the waterfall begins

              switch(side) {
                case 'left':
                  // LEFT waterfall - outer face flush with countertop left edge
                  wfW = wfThickness;
                  wfD = d - seamGap;
                  // Outer face at slab left edge: -slabW/2 + slabOffsetX
                  // Center = outer face + thickness/2
                  wfPosX = (-slabW/2 + slabOffsetX) + wfThickness/2;
                  wfPosZ = 0;
                  break;
                case 'right':
                  // RIGHT waterfall - outer face flush with countertop right edge
                  wfW = wfThickness;
                  wfD = d - seamGap;
                  // Outer face at slab right edge: slabW/2 + slabOffsetX
                  // Center = outer face - thickness/2
                  wfPosX = (slabW/2 + slabOffsetX) - wfThickness/2;
                  wfPosZ = 0;
                  break;
                case 'front':
                  // FRONT waterfall - outer face flush with countertop front edge
                  wfW = w - seamGap;
                  wfD = wfThickness;
                  wfPosX = 0;
                  // Outer face at slab front edge: slabD/2 + slabOffsetZ
                  // Center = outer face - thickness/2
                  wfPosZ = (slabD/2 + slabOffsetZ) - wfThickness/2;
                  break;
                case 'back':
                  // BACK waterfall - outer face flush with countertop back edge
                  wfW = w - seamGap;
                  wfD = wfThickness;
                  wfPosX = 0;
                  // Outer face at slab back edge: -slabD/2 + slabOffsetZ
                  // Center = outer face + thickness/2
                  wfPosZ = (-slabD/2 + slabOffsetZ) + wfThickness/2;
                  break;
              }

              // Main waterfall panel - drops from countertop TOP level
              // TOP of waterfall at TOP of countertop = continuous surface turning 90
              const wfPanel = new THREE.Mesh(
                new THREE.BoxGeometry(wfW, dropHeight, wfD),
                waterfallMat
              );
              // Y position: panel top at countertop top (slabThickness/2 above countertop center)
              wfPanel.position.set(wfPosX, slabThickness/2 - dropHeight/2, wfPosZ);
              wfPanel.castShadow = true;
              wfPanel.receiveShadow = true;
              group.add(wfPanel);

              // For 2cm stone, add laminated edge on the INNER visible face (faces cabinet)
              // The outer face is continuous with countertop - no lamination needed there
              if (is2cm && wfEdgeThickness > 0) {
                const lamStripMat = createTexturedMaterial(color, textureUrl, {
                  roughness: 0.1,
                  metalness: 0.08
                });
                const yPos = slabThickness/2 - dropHeight/2; // Match waterfall Y position

                if (side === 'left') {
                  // Inner face (right side of left waterfall)
                  const innerStrip = new THREE.Mesh(
                    new THREE.BoxGeometry(wfEdgeThickness, dropHeight, slabD),
                    lamStripMat
                  );
                  innerStrip.position.set(wfPosX + wfThickness/2 + wfEdgeThickness/2, yPos, slabOffsetZ);
                  group.add(innerStrip);
                } else if (side === 'right') {
                  // Inner face (left side of right waterfall)
                  const innerStrip = new THREE.Mesh(
                    new THREE.BoxGeometry(wfEdgeThickness, dropHeight, slabD),
                    lamStripMat
                  );
                  innerStrip.position.set(wfPosX - wfThickness/2 - wfEdgeThickness/2, yPos, slabOffsetZ);
                  group.add(innerStrip);
                } else if (side === 'front') {
                  // Inner face (back of front waterfall)
                  const innerStrip = new THREE.Mesh(
                    new THREE.BoxGeometry(wfW, dropHeight, wfEdgeThickness),
                    lamStripMat
                  );
                  innerStrip.position.set(wfPosX, yPos, wfPosZ - wfThickness/2 - wfEdgeThickness/2);
                  group.add(innerStrip);
                } else if (side === 'back') {
                  // Inner face (front of back waterfall)
                  const innerStrip = new THREE.Mesh(
                    new THREE.BoxGeometry(wfW, dropHeight, wfEdgeThickness),
                    lamStripMat
                  );
                  innerStrip.position.set(wfPosX, yPos, wfPosZ + wfThickness/2 + wfEdgeThickness/2);
                  group.add(innerStrip);
                }
              }
              // No visible seam - mitered joint is polished smooth to appear seamless
            });
          }
          break;
        }

        case 'countertop-l': {
          // L-shaped countertop - two separate runs meeting at 90 degrees
          // Like real fabrication: horizontal run along X, perpendicular run along Z
          const lMat = createTexturedMaterial(color, textureUrl, {
            roughness: 0.1,
            metalness: 0.08,
            finish: el.finish || 'polished'
          });
          const thickness = 0.1; // 3cm thickness (1.2")

          // Arm depth is standard countertop depth: 26" = 2.17ft
          const armDepth = el.armWidth || 2.17;

          // HORIZONTAL ARM: runs along X-axis (full width w, depth = armDepth)
          // Positioned at front (positive Z side)
          const horizArm = new THREE.Mesh(
            new THREE.BoxGeometry(w, thickness, armDepth),
            lMat
          );
          // Position at front edge of the L footprint
          horizArm.position.set(0, 0, d/2 - armDepth/2);
          group.add(horizArm);

          // PERPENDICULAR ARM: runs along Z-axis (width = armDepth, extends back)
          // Positioned at left side (negative X), extending back from horizontal arm
          // This creates the perpendicular leg of the L
          const perpLength = d - armDepth; // Length extends back from horizontal arm
          if (perpLength > 0.1) {
            const perpArm = new THREE.Mesh(
              new THREE.BoxGeometry(armDepth, thickness, perpLength),
              lMat
            );
            // Position: left edge of footprint, centered behind horizontal arm
            // X: left side (-w/2 + armDepth/2 centers the arm at left edge)
            // Z: front edge of perpArm meets back edge of horizArm at z = d/2 - armDepth
            //    So center = (d/2 - armDepth) - perpLength/2 = -armDepth/2 when simplified
            const perpZ = (d/2 - armDepth) - perpLength/2;
            perpArm.position.set(-w/2 + armDepth/2, 0, perpZ);
            group.add(perpArm);

            // Add seam line where the two arms meet (realistic fabrication detail)
            const seamMat = new THREE.MeshBasicMaterial({ color: 0x333333 });
            const seamLine = new THREE.Mesh(
              new THREE.BoxGeometry(armDepth, thickness + 0.002, 0.01),
              seamMat
            );
            // Seam is at the junction: z = d/2 - armDepth (back of horiz, front of perp)
            seamLine.position.set(-w/2 + armDepth/2, 0.001, d/2 - armDepth);
            group.add(seamLine);

            // Top polish highlight for perpendicular arm
            const topPerpMat = createTexturedMaterial(color, textureUrl, {
              roughness: 0.05,
              metalness: 0.15
            });
            const topPerp = new THREE.Mesh(
              new THREE.BoxGeometry(armDepth - 0.02, 0.005, perpLength - 0.02),
              topPerpMat
            );
            topPerp.position.set(-w/2 + armDepth/2, thickness/2, perpZ);
            group.add(topPerp);
          }

          // Top polish highlight for horizontal arm
          const topMat = createTexturedMaterial(color, textureUrl, {
            roughness: 0.05,
            metalness: 0.15
          });
          const topHoriz = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.02, 0.005, armDepth - 0.02),
            topMat
          );
          topHoriz.position.set(0, thickness/2, d/2 - armDepth/2);
          group.add(topHoriz);
          break;
        }

        case 'countertop-corner': {
          // Corner countertop - simple square slab for corner transitions
          const cornerMat = createTexturedMaterial(color, textureUrl, {
            roughness: 0.1,
            metalness: 0.08,
            finish: el.finish || 'polished'
          });
          const thickness = 0.1; // 3cm thickness

          // Simple square slab
          const cornerSlab = new THREE.Mesh(
            new THREE.BoxGeometry(w, thickness, d),
            cornerMat
          );
          group.add(cornerSlab);

          // Top polish highlight
          const cornerTop = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.02, 0.005, d - 0.02),
            createTexturedMaterial(color, textureUrl, { roughness: 0.05, metalness: 0.15 })
          );
          cornerTop.position.set(0, thickness/2, 0);
          group.add(cornerTop);
          break;
        }

        case 'countertop-u': {
          // U-shaped countertop
          const uMat = createTexturedMaterial(color, textureUrl, {
            roughness: 0.1,
            metalness: 0.08,
            finish: el.finish || 'polished'
          });
          const thickness = 0.1; // 3cm thickness

          // U-shape: back arm full width, two side arms
          const armDepth = d * 0.3; // Back arm depth
          const sideWidth = w * 0.25; // Side arm width

          // Back arm (full width, partial depth)
          const backArm = new THREE.Mesh(
            new THREE.BoxGeometry(w, thickness, armDepth),
            uMat
          );
          backArm.position.set(0, 0, -d/2 + armDepth/2);
          group.add(backArm);

          // Left side arm
          const leftArm = new THREE.Mesh(
            new THREE.BoxGeometry(sideWidth, thickness, d - armDepth),
            uMat
          );
          leftArm.position.set(-w/2 + sideWidth/2, 0, armDepth/2);
          group.add(leftArm);

          // Right side arm
          const rightArm = new THREE.Mesh(
            new THREE.BoxGeometry(sideWidth, thickness, d - armDepth),
            uMat
          );
          rightArm.position.set(w/2 - sideWidth/2, 0, armDepth/2);
          group.add(rightArm);

          // Top highlights
          const topMat = createTexturedMaterial(color, textureUrl, {
            roughness: 0.05,
            metalness: 0.15
          });
          const topBack = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.02, 0.005, armDepth - 0.02),
            topMat
          );
          topBack.position.set(0, thickness/2, -d/2 + armDepth/2);
          group.add(topBack);

          const topLeft = new THREE.Mesh(
            new THREE.BoxGeometry(sideWidth - 0.02, 0.005, d - armDepth - 0.02),
            topMat
          );
          topLeft.position.set(-w/2 + sideWidth/2, thickness/2, armDepth/2);
          group.add(topLeft);

          const topRight = new THREE.Mesh(
            new THREE.BoxGeometry(sideWidth - 0.02, 0.005, d - armDepth - 0.02),
            topMat
          );
          topRight.position.set(w/2 - sideWidth/2, thickness/2, armDepth/2);
          group.add(topRight);
          break;
        }

        case 'surface-stainless': {
          // Stainless steel work surface with realistic reflections
          const ssMat = new THREE.MeshStandardMaterial({
            color: 0xD8D8D8,
            roughness: 0.15,
            metalness: 0.9,
            envMap: window.roomEnvMap || null,
            envMapIntensity: 1.2
          });
          const ssTop = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), ssMat);
          group.add(ssTop);

          // Add subtle brushed texture lines
          const lineMat = new THREE.MeshStandardMaterial({
            color: 0xC0C0C0,
            roughness: 0.3,
            metalness: 0.85,
            envMap: window.roomEnvMap || null,
            envMapIntensity: 0.8
          });
          for (let lz = -d/2 + 0.15; lz < d/2; lz += 0.15) {
            const brushLine = new THREE.Mesh(new THREE.BoxGeometry(w - 0.05, h + 0.002, 0.01), lineMat);
            brushLine.position.set(0, 0.001, lz);
            group.add(brushLine);
          }

          // Welded edge (slightly raised rim)
          const rimMat = new THREE.MeshStandardMaterial({
            color: 0xE0E0E0,
            roughness: 0.2,
            metalness: 0.85,
            envMap: window.roomEnvMap || null,
            envMapIntensity: 1.0
          });
          const frontRim = new THREE.Mesh(new THREE.BoxGeometry(w, h + 0.02, 0.02), rimMat);
          frontRim.position.set(0, 0.01, d/2);
          group.add(frontRim);
          break;
        }

        case 'surface-solid': {
          // Solid surface (Corian-style) - matte, seamless look
          const solidMat = createTexturedMaterial(color, textureUrl, {
            roughness: 0.4,
            metalness: 0.02
          });
          const solidTop = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), solidMat);
          group.add(solidTop);

          // Integrated edge (slightly rounded)
          const edgeMat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.35, metalness: 0.01 });
          const frontEdge = new THREE.Mesh(new THREE.BoxGeometry(w - 0.02, h, 0.03), edgeMat);
          frontEdge.position.set(0, 0, d/2 + 0.01);
          group.add(frontEdge);
          break;
        }

        case 'surface-laminate': {
          // Laminate/Formica - thin top layer on substrate
          // Substrate (particle board)
          const substrateMat = new THREE.MeshStandardMaterial({ color: 0xC4A76C, roughness: 0.8 });
          const substrate = new THREE.Mesh(new THREE.BoxGeometry(w, h * 0.85, d), substrateMat);
          substrate.position.y = -h * 0.075;
          group.add(substrate);

          // Laminate top
          const lamMat = createTexturedMaterial(color, textureUrl, {
            roughness: 0.25,
            metalness: 0.05
          });
          const lamTop = new THREE.Mesh(new THREE.BoxGeometry(w + 0.01, h * 0.15, d + 0.01), lamMat);
          lamTop.position.y = h * 0.425;
          group.add(lamTop);

          // Edge banding
          const edgeBandMat = new THREE.MeshStandardMaterial({ color: 0x4A4A4A, roughness: 0.3 });
          const frontBand = new THREE.Mesh(new THREE.BoxGeometry(w + 0.01, h, 0.02), edgeBandMat);
          frontBand.position.set(0, 0, d/2 + 0.01);
          group.add(frontBand);
          break;
        }

        case 'surface-butcherblock': {
          // Butcher block - wood strips
          const bbMat = createTexturedMaterial(color, textureUrl, {
            roughness: 0.55,
            metalness: 0.0
          });
          const bbTop = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), bbMat);
          group.add(bbTop);

          // Wood strip lines (end grain or edge grain pattern)
          const stripMat = new THREE.MeshStandardMaterial({ color: 0x8B6914, roughness: 0.7 });
          const stripWidth = 0.15;
          for (let sx = -w/2 + stripWidth; sx < w/2; sx += stripWidth) {
            const strip = new THREE.Mesh(new THREE.BoxGeometry(0.005, h + 0.002, d - 0.02), stripMat);
            strip.position.set(sx, 0.001, 0);
            group.add(strip);
          }
          break;
        }

        case 'surface-concrete': {
          // Concrete countertop - industrial look
          const concMat = createTexturedMaterial(color, textureUrl, {
            roughness: 0.7,
            metalness: 0.05
          });
          const concTop = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), concMat);
          group.add(concTop);

          // Add subtle aggregate texture spots
          const aggMat = new THREE.MeshStandardMaterial({ color: 0x909090, roughness: 0.8 });
          for (let i = 0; i < 15; i++) {
            const agg = new THREE.Mesh(new THREE.SphereGeometry(0.02 + Math.random() * 0.02, 6, 6), aggMat);
            agg.position.set(
              (Math.random() - 0.5) * (w - 0.1),
              h/2 + 0.01,
              (Math.random() - 0.5) * (d - 0.1)
            );
            agg.scale.y = 0.3;
            group.add(agg);
          }
          break;
        }

        case 'backsplash': {
          // Tile backsplash - vertical against wall
          // verticalHeight is the actual height (18" typical), h (depth) is thin (~1")
          const bsVerticalHeight = el.verticalHeight || 1.5; // Default 18" backsplash
          const bsThickness = d > 0.2 ? 0.08 : d; // Use thin depth for thickness

          const bsMat = createTexturedMaterial(color, textureUrl, {
            roughness: 0.25,
            metalness: 0.02
          });
          const bs = new THREE.Mesh(
            new THREE.BoxGeometry(w, bsVerticalHeight, bsThickness),
            bsMat
          );
          group.add(bs);

          // Subtle grout lines
          const groutMat = new THREE.MeshStandardMaterial({ color: 0xCCCCCC, roughness: 0.9 });
          const tileSize = 0.5;
          for (let bx = -w/2 + tileSize; bx < w/2; bx += tileSize) {
            const vGrout = new THREE.Mesh(
              new THREE.BoxGeometry(0.01, bsVerticalHeight - 0.1, 0.01),
              groutMat
            );
            vGrout.position.set(bx, 0, bsThickness/2 + 0.01);
            group.add(vGrout);
          }
          break;
        }

        case 'flooring': {
          // Wood plank flooring with texture support and grain direction
          const floorGrainDir = el.grainDirection || 0;
          const plankMat = createTexturedMaterial(color, textureUrl, {
            roughness: 0.6,
            metalness: 0.0
          });

          // Apply texture rotation based on grain direction
          if (plankMat.map) {
            plankMat.map.rotation = floorGrainDir * Math.PI / 180;
            plankMat.map.center.set(0.5, 0.5);
          }

          const floorBase = new THREE.Mesh(
            new THREE.BoxGeometry(w, h, d),
            plankMat
          );
          group.add(floorBase);

          // Plank grooves - adjust based on grain direction
          const grooveMat = new THREE.MeshStandardMaterial({ color: 0x3a2a1a, roughness: 0.9 });
          const plankW = 0.5;

          if (floorGrainDir === 90) {
            // Vertical planks - grooves run along Z axis
            for (let pz = -d/2 + plankW; pz < d/2; pz += plankW) {
              const groove = new THREE.Mesh(
                new THREE.BoxGeometry(w + 0.01, h + 0.01, 0.008),
                grooveMat
              );
              groove.position.set(0, 0.002, pz);
              group.add(groove);
            }
          } else if (floorGrainDir === 45 || floorGrainDir === 135) {
            // Diagonal planks
            const angle = floorGrainDir * Math.PI / 180;
            const diagonal = Math.sqrt(w * w + d * d);
            for (let p = -diagonal/2 + plankW; p < diagonal/2; p += plankW) {
              const groove = new THREE.Mesh(
                new THREE.BoxGeometry(diagonal, h + 0.01, 0.008),
                grooveMat
              );
              groove.rotation.y = -angle;
              groove.position.set(
                p * Math.sin(angle),
                0.002,
                p * Math.cos(angle)
              );
              group.add(groove);
            }
          } else {
            // Horizontal planks (default) - grooves run along X axis
            for (let px = -w/2 + plankW; px < w/2; px += plankW) {
              const groove = new THREE.Mesh(
                new THREE.BoxGeometry(0.008, h + 0.01, d + 0.01),
                grooveMat
              );
              groove.position.set(px, 0.002, 0);
              group.add(groove);
            }
          }
          break;
        }

        case 'tile': {
          // Tile floor/surface with texture support and direction
          const tileDir = el.grainDirection || 0;
          const tileMat = createTexturedMaterial(color, textureUrl, {
            roughness: 0.3,
            metalness: 0.05,
            finish: el.finish || 'polished'
          });

          // Apply texture rotation based on tile direction
          if (tileMat.map) {
            tileMat.map.rotation = tileDir * Math.PI / 180;
            tileMat.map.center.set(0.5, 0.5);
          }

          const tileBase = new THREE.Mesh(
            new THREE.BoxGeometry(w, h, d),
            tileMat
          );
          group.add(tileBase);

          // Grout lines - create a group that can be rotated
          const groutGroup = new THREE.Group();
          const tileGroutMat = new THREE.MeshStandardMaterial({ color: 0x888888, roughness: 0.9 });
          const tileSz = 0.5;

          // Grout line dimensions: thin strips sitting ON the tile surface
          const groutH = 0.008; // Thin grout strip
          const groutY = h / 2;  // Position at tile top surface

          if (tileDir === 45 || tileDir === 135) {
            // Diagonal tiles - rotate grout lines
            const diagonal = Math.sqrt(w * w + d * d);
            for (let t = -diagonal/2 + tileSz; t < diagonal/2; t += tileSz) {
              const line1 = new THREE.Mesh(
                new THREE.BoxGeometry(0.015, groutH, diagonal + 0.5),
                tileGroutMat
              );
              line1.position.set(t, groutY, 0);
              groutGroup.add(line1);

              const line2 = new THREE.Mesh(
                new THREE.BoxGeometry(diagonal + 0.5, groutH, 0.015),
                tileGroutMat
              );
              line2.position.set(0, groutY, t);
              groutGroup.add(line2);
            }
            groutGroup.rotation.y = tileDir * Math.PI / 180;
          } else {
            // Standard grid pattern
            for (let tx = -w/2 + tileSz; tx < w/2; tx += tileSz) {
              const vLine = new THREE.Mesh(
                new THREE.BoxGeometry(0.015, groutH, d + 0.005),
                tileGroutMat
              );
              vLine.position.set(tx, groutY, 0);
              groutGroup.add(vLine);
            }
            for (let tz = -d/2 + tileSz; tz < d/2; tz += tileSz) {
              const hLine = new THREE.Mesh(
                new THREE.BoxGeometry(w + 0.005, groutH, 0.015),
                tileGroutMat
              );
              hLine.position.set(0, groutY, tz);
              groutGroup.add(hLine);
            }
          }
          group.add(groutGroup);
          break;
        }

        // ===== SHOWER COMPONENTS =====
        case 'shower-pan': {
          // Shower pan/base with slope and drain
          const panMat = createTexturedMaterial(color, textureUrl, {
            roughness: 0.6,
            metalness: 0.1,
            finish: el.finish || 'polished'
          });

          // Main pan surface (slightly recessed in center for slope)
          const panBase = new THREE.Mesh(
            new THREE.BoxGeometry(w, 0.08, d),
            panMat
          );
          panBase.receiveShadow = true;
          group.add(panBase);

          // Drain in center
          const drainMat = new THREE.MeshStandardMaterial({
            color: 0x666666,
            roughness: 0.3,
            metalness: 0.8
          });
          const drain = new THREE.Mesh(
            new THREE.CylinderGeometry(0.15, 0.15, 0.02, 16),
            drainMat
          );
          drain.rotation.x = Math.PI / 2;
          drain.position.set(0, 0.05, 0);
          group.add(drain);

          // Drain grate
          const grateMat = new THREE.MeshStandardMaterial({ color: 0x888888, metalness: 0.7 });
          for (let gi = -2; gi <= 2; gi++) {
            const grate = new THREE.Mesh(
              new THREE.BoxGeometry(0.25, 0.01, 0.015),
              grateMat
            );
            grate.position.set(0, 0.055, gi * 0.04);
            group.add(grate);
          }
          break;
        }

        case 'shower-curb': {
          // Shower curb/threshold
          const curbMat = createTexturedMaterial(color, textureUrl, {
            roughness: 0.5,
            metalness: 0.05
          });

          // Main curb body
          const curb = new THREE.Mesh(
            new THREE.BoxGeometry(w, 0.5, d),  // 6" high curb
            curbMat
          );
          curb.castShadow = true;
          curb.receiveShadow = true;
          group.add(curb);

          // Rounded top edge
          const edgeRadius = 0.05;
          const edgeShape = new THREE.Shape();
          edgeShape.absarc(0, 0, edgeRadius, 0, Math.PI, false);
          const edgeGeom = new THREE.ExtrudeGeometry(edgeShape, { steps: 1, depth: w, bevelEnabled: false });
          const edge = new THREE.Mesh(edgeGeom, curbMat);
          edge.rotation.y = Math.PI / 2;
          edge.position.set(w/2, 0.25 - edgeRadius, d/2);
          group.add(edge);
          break;
        }

        case 'shower-wall':
        case 'wall-tile':
        case 'accent-wall': {
          // Vertical wall panel with tile texture
          const isShower = el.type === 'shower-wall';
          const panelThickness = isShower ? 0.05 : 0.04;

          const panelMat = createTexturedMaterial(color, textureUrl, {
            roughness: isShower ? 0.15 : 0.3,
            metalness: isShower ? 0.1 : 0.05,
            finish: el.finish || 'polished'
          });

          // Main panel (vertical orientation)
          const panelHeight = el.wallHeight || (isShower ? 7 : 8);
          const panel = new THREE.Mesh(
            new THREE.BoxGeometry(w, panelHeight, panelThickness),
            panelMat
          );
          panel.position.y = panelHeight / 2 - h / 2;
          panel.castShadow = true;
          panel.receiveShadow = true;
          group.add(panel);

          // Add grout lines for tile look
          if (el.showGrout !== false) {
            const groutMat = new THREE.MeshStandardMaterial({ color: 0x9a9a9a, roughness: 0.9 });
            const tileSz = el.tileSize || 0.5;

            // Vertical grout lines
            for (let tx = -w/2 + tileSz; tx < w/2; tx += tileSz) {
              const vGrout = new THREE.Mesh(
                new THREE.BoxGeometry(0.01, panelHeight - 0.1, 0.005),
                groutMat
              );
              vGrout.position.set(tx, panelHeight/2 - h/2, panelThickness/2 + 0.003);
              group.add(vGrout);
            }

            // Horizontal grout lines
            for (let ty = tileSz; ty < panelHeight; ty += tileSz) {
              const hGrout = new THREE.Mesh(
                new THREE.BoxGeometry(w - 0.05, 0.01, 0.005),
                groutMat
              );
              hGrout.position.set(0, ty - h/2, panelThickness/2 + 0.003);
              group.add(hGrout);
            }
          }

          // Add trim for shower walls
          if (isShower) {
            const trimMat = new THREE.MeshStandardMaterial({ color: 0xC0C0C0, roughness: 0.3, metalness: 0.5 });

            // Top trim/cap
            const topTrim = new THREE.Mesh(
              new THREE.BoxGeometry(w + 0.02, 0.02, panelThickness + 0.02),
              trimMat
            );
            topTrim.position.set(0, panelHeight - h/2, 0);
            group.add(topTrim);

            // Side trims
            [-1, 1].forEach(side => {
              const sideTrim = new THREE.Mesh(
                new THREE.BoxGeometry(0.02, panelHeight, panelThickness + 0.02),
                trimMat
              );
              sideTrim.position.set(side * (w/2 + 0.01), panelHeight/2 - h/2, 0);
              group.add(sideTrim);
            });
          }
          break;
        }

        // ===== STONE CAPS & LEDGES =====
        case 'wall-cap':
        case 'bar-top': {
          // Stone cap/ledge for pony walls, bars, entryways
          // Enhanced rendering with visible overhang and edge profiles
          const isBarTop = el.type === 'bar-top';
          const capThickness = el.thickness || el.stoneThickness || (isBarTop ? 0.125 : 0.1);
          const overhang = el.overhang || (isBarTop ? 0.12 : 0.06); // How much cap extends beyond wall

          // Material with accurate color/texture display
          const capMat = createTexturedMaterial(color, textureUrl, {
            roughness: 0.35,
            metalness: 0.03,
            finish: el.finish || 'polished'
          });

          // Main cap surface with overhang on all visible sides
          const capWidth = w + overhang * 2;
          const capDepth = d + overhang;
          const cap = new THREE.Mesh(
            new THREE.BoxGeometry(capWidth, capThickness, capDepth),
            capMat
          );
          cap.position.set(0, 0, overhang / 2);
          cap.castShadow = true;
          cap.receiveShadow = true;
          group.add(cap);

          // Edge profile
          const edgeProfile = el.edgeProfile || 'eased';
          const edgeRadius = capThickness * 0.4;

          if (edgeProfile === 'bullnose' || edgeProfile === 'half-bullnose' || edgeProfile === 'full-bullnose') {
            // Front bullnose edge - rounded profile at TOP of front edge
            const frontEdge = new THREE.Mesh(
              new THREE.CylinderGeometry(edgeRadius, edgeRadius, capWidth, 16, 1, false, 0, Math.PI),
              capMat
            );
            frontEdge.rotation.x = Math.PI / 2;
            frontEdge.rotation.z = Math.PI / 2;
            // Position at TOP of edge (positive Y), not bottom
            frontEdge.position.set(0, capThickness / 2 - edgeRadius * 0.3, d / 2 + overhang);
            frontEdge.castShadow = true;
            group.add(frontEdge);

            // Side bullnose edges (left and right) - also at TOP
            [-1, 1].forEach(side => {
              const sideEdge = new THREE.Mesh(
                new THREE.CylinderGeometry(edgeRadius * 0.8, edgeRadius * 0.8, capDepth - 0.04, 12, 1, false, 0, Math.PI),
                capMat
              );
              sideEdge.rotation.x = 0;
              sideEdge.rotation.z = side * Math.PI / 2;
              // Position at TOP of edge
              sideEdge.position.set(side * (capWidth / 2 - edgeRadius * 0.3), capThickness / 2 - edgeRadius * 0.3, overhang / 2);
              group.add(sideEdge);
            });
          } else if (edgeProfile === 'ogee') {
            // Ogee profile - decorative S-curve with bulge at TOP of edge
            // Upper decorative bulge (convex portion - visible from top)
            const ogeeBulge = new THREE.Mesh(
              new THREE.BoxGeometry(capWidth - 0.02, capThickness * 0.2, 0.025),
              capMat
            );
            ogeeBulge.position.set(0, capThickness * 0.15, d / 2 + overhang + 0.015);
            ogeeBulge.castShadow = true;
            group.add(ogeeBulge);

            // Middle concave suggestion (step back creates shadow line)
            const ogeeMiddle = new THREE.Mesh(
              new THREE.BoxGeometry(capWidth - 0.04, capThickness * 0.15, 0.012),
              capMat
            );
            ogeeMiddle.position.set(0, -capThickness * 0.1, d / 2 + overhang + 0.005);
            group.add(ogeeMiddle);

            // Lower portion - flat face leading to underside
            const ogeeLower = new THREE.Mesh(
              new THREE.BoxGeometry(capWidth - 0.02, capThickness * 0.2, 0.015),
              capMat
            );
            ogeeLower.position.set(0, -capThickness * 0.35, d / 2 + overhang + 0.008);
            group.add(ogeeLower);
          } else if (edgeProfile === 'double-ogee') {
            // Double ogee - two S-curves stacked with bulges at top of each
            // Upper S-curve bulge
            const dblOgeeTop = new THREE.Mesh(
              new THREE.BoxGeometry(capWidth - 0.02, capThickness * 0.15, 0.02),
              capMat
            );
            dblOgeeTop.position.set(0, capThickness * 0.2, d / 2 + overhang + 0.012);
            dblOgeeTop.castShadow = true;
            group.add(dblOgeeTop);

            // Upper concave
            const dblOgeeUpperMid = new THREE.Mesh(
              new THREE.BoxGeometry(capWidth - 0.04, capThickness * 0.1, 0.008),
              capMat
            );
            dblOgeeUpperMid.position.set(0, capThickness * 0.05, d / 2 + overhang + 0.003);
            group.add(dblOgeeUpperMid);

            // Lower S-curve bulge
            const dblOgeeLowerBulge = new THREE.Mesh(
              new THREE.BoxGeometry(capWidth - 0.02, capThickness * 0.12, 0.018),
              capMat
            );
            dblOgeeLowerBulge.position.set(0, -capThickness * 0.15, d / 2 + overhang + 0.01);
            group.add(dblOgeeLowerBulge);

            // Lower portion
            const dblOgeeLower = new THREE.Mesh(
              new THREE.BoxGeometry(capWidth - 0.04, capThickness * 0.15, 0.012),
              capMat
            );
            dblOgeeLower.position.set(0, -capThickness * 0.35, d / 2 + overhang + 0.005);
            group.add(dblOgeeLower);
          } else if (edgeProfile === 'dupont') {
            // Dupont - stepped profile with rounded top
            // Rounded top portion (bullnose-like)
            const dupontTop = new THREE.Mesh(
              new THREE.CylinderGeometry(capThickness * 0.2, capThickness * 0.2, capWidth - 0.02, 12, 1, false, 0, Math.PI),
              capMat
            );
            dupontTop.rotation.x = Math.PI / 2;
            dupontTop.rotation.z = Math.PI / 2;
            dupontTop.position.set(0, capThickness * 0.15, d / 2 + overhang + 0.01);
            dupontTop.castShadow = true;
            group.add(dupontTop);

            // Middle step (the characteristic dupont ledge)
            const dupontLedge = new THREE.Mesh(
              new THREE.BoxGeometry(capWidth - 0.04, capThickness * 0.12, 0.03),
              capMat
            );
            dupontLedge.position.set(0, -capThickness * 0.1, d / 2 + overhang - 0.005);
            group.add(dupontLedge);

            // Lower flat portion
            const dupontLower = new THREE.Mesh(
              new THREE.BoxGeometry(capWidth - 0.02, capThickness * 0.25, 0.015),
              capMat
            );
            dupontLower.position.set(0, -capThickness * 0.35, d / 2 + overhang + 0.008);
            group.add(dupontLower);
          } else {
            // Eased edge - subtle chamfer
            const easedEdge = new THREE.Mesh(
              new THREE.BoxGeometry(capWidth, capThickness * 0.2, 0.015),
              capMat
            );
            easedEdge.rotation.x = Math.PI / 6;
            easedEdge.position.set(0, -capThickness * 0.42, d / 2 + overhang + 0.008);
            group.add(easedEdge);
          }

          // Underside detail for depth and shadow
          const undersideMat = new THREE.MeshStandardMaterial({
            color: adjustColorBrightness(color, -35),
            roughness: 0.65
          });

          // Front underside reveal
          const frontReveal = new THREE.Mesh(
            new THREE.BoxGeometry(capWidth - 0.04, 0.025, 0.025),
            undersideMat
          );
          frontReveal.position.set(0, -capThickness / 2 - 0.012, d / 2 + overhang - 0.012);
          group.add(frontReveal);

          // Side reveals for depth
          [-1, 1].forEach(side => {
            const sideReveal = new THREE.Mesh(
              new THREE.BoxGeometry(0.025, 0.02, capDepth - 0.06),
              undersideMat
            );
            sideReveal.position.set(side * (capWidth / 2 - 0.015), -capThickness / 2 - 0.01, overhang / 2);
            group.add(sideReveal);
          });

          break;
        }

        case 'window-sill':
        case 'threshold': {
          // Window sill or door threshold - with visible depth and edge profile
          const isWindowSill = el.type === 'window-sill';
          const slabThickness = el.stoneThickness || (isWindowSill ? 0.08 : 0.04);
          const overhang = isWindowSill ? 0.08 : 0.02; // How much sill sticks out from wall

          const slabMat = createTexturedMaterial(color, textureUrl, {
            roughness: 0.35,
            metalness: 0.05,
            finish: el.finish || 'polished'
          });

          // Main slab with overhang for visibility
          const slab = new THREE.Mesh(
            new THREE.BoxGeometry(w + (isWindowSill ? 0.1 : 0), slabThickness, d + overhang),
            slabMat
          );
          slab.position.set(0, 0, overhang / 2);
          slab.castShadow = true;
          slab.receiveShadow = true;
          group.add(slab);

          // Edge profile based on type
          const edgeProfile = el.edgeProfile || 'eased';
          const edgeRadius = slabThickness * 0.4;

          if (edgeProfile === 'bullnose' || edgeProfile === 'half-bullnose') {
            // Bullnose front edge
            const frontEdge = new THREE.Mesh(
              new THREE.CylinderGeometry(edgeRadius, edgeRadius, w + (isWindowSill ? 0.1 : 0), 12, 1, false, 0, Math.PI),
              slabMat
            );
            frontEdge.rotation.x = Math.PI / 2;
            frontEdge.rotation.z = Math.PI / 2;
            frontEdge.position.set(0, -slabThickness / 2 + edgeRadius * 0.5, d / 2 + overhang);
            group.add(frontEdge);
          } else {
            // Eased edge (chamfer)
            const easedEdge = new THREE.Mesh(
              new THREE.BoxGeometry(w + (isWindowSill ? 0.08 : 0), slabThickness * 0.25, 0.015),
              slabMat
            );
            easedEdge.rotation.x = Math.PI / 6; // Slight angle
            easedEdge.position.set(0, -slabThickness * 0.4, d / 2 + overhang + 0.008);
            group.add(easedEdge);
          }

          // For window sill, add subtle return sides for depth
          if (isWindowSill && d > 0.2) {
            const returnDepth = 0.06;
            // Left return
            const leftReturn = new THREE.Mesh(
              new THREE.BoxGeometry(returnDepth, slabThickness, d * 0.8),
              slabMat
            );
            leftReturn.position.set(-w / 2 - returnDepth / 2 + 0.02, 0, -d * 0.1);
            group.add(leftReturn);

            // Right return
            const rightReturn = new THREE.Mesh(
              new THREE.BoxGeometry(returnDepth, slabThickness, d * 0.8),
              slabMat
            );
            rightReturn.position.set(w / 2 + returnDepth / 2 - 0.02, 0, -d * 0.1);
            group.add(rightReturn);
          }

          // Underside shadow detail for depth
          const undersideMat = new THREE.MeshStandardMaterial({
            color: adjustColorBrightness(color, -40),
            roughness: 0.7
          });
          const underside = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.02, 0.01, 0.03),
            undersideMat
          );
          underside.position.set(0, -slabThickness / 2 - 0.005, d / 2 + overhang - 0.015);
          group.add(underside);

          break;
        }

        case 'mantel': {
          // Fireplace mantel/shelf
          const mantelThickness = el.stoneThickness || 0.1;
          const mantelMat = createTexturedMaterial(color, textureUrl, {
            roughness: 0.5,
            metalness: 0,
            finish: el.finish || 'polished'
          });

          // Main mantel shelf
          const mantelShelf = new THREE.Mesh(
            new THREE.BoxGeometry(w, mantelThickness, d),
            mantelMat
          );
          group.add(mantelShelf);

          // Corbels/brackets on each end
          const corbelMat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.6 });
          const leftCorbel = new THREE.Mesh(
            new THREE.BoxGeometry(0.15, 0.25, d * 0.8),
            corbelMat
          );
          leftCorbel.position.set(-w / 2 + 0.1, -0.175, 0);
          group.add(leftCorbel);

          const rightCorbel = new THREE.Mesh(
            new THREE.BoxGeometry(0.15, 0.25, d * 0.8),
            corbelMat
          );
          rightCorbel.position.set(w / 2 - 0.1, -0.175, 0);
          group.add(rightCorbel);
          break;
        }

        // ===== STONE SURROUNDS WITH RECESSED VOID =====
        case 'niche-surround':
        case 'fireplace-surround': {
          // Stone surround with proper recessed dark void and stone ledges wrapping into the recess
          const isFireplace = el.type === 'fireplace-surround';
          const frameW = el.frameWidth || 0.15; // ~2" frame width on face
          const frameD = el.stoneThickness || 0.1; // Stone face thickness
          const recessDepth = el.nicheDepth || (isFireplace ? 1.0 : 0.5); // Depth of void (6" standard, 12" fireplace)

          // Opening dimensions (inside the frame)
          const openingW = w - frameW * 2;
          const openingH = h - frameW * 2;

          // Stone material with texture
          const surroundMat = createTexturedMaterial(color, textureUrl, {
            roughness: 0.35,
            metalness: 0.08,
            finish: el.finish || 'polished'
          });

          // Darker interior material for the void
          const voidMat = new THREE.MeshStandardMaterial({
            color: 0x0a0a0a,
            roughness: 0.95,
            metalness: 0
          });

          // === RECESSED VOID (dark box behind the frame) ===
          // Back wall of void
          const backWall = new THREE.Mesh(
            new THREE.PlaneGeometry(openingW, openingH),
            voidMat
          );
          backWall.position.set(0, 0, -recessDepth);
          group.add(backWall);

          // Left void wall
          const leftVoid = new THREE.Mesh(
            new THREE.PlaneGeometry(recessDepth, openingH),
            voidMat
          );
          leftVoid.rotation.y = Math.PI / 2;
          leftVoid.position.set(-openingW / 2, 0, -recessDepth / 2);
          group.add(leftVoid);

          // Right void wall
          const rightVoid = new THREE.Mesh(
            new THREE.PlaneGeometry(recessDepth, openingH),
            voidMat
          );
          rightVoid.rotation.y = -Math.PI / 2;
          rightVoid.position.set(openingW / 2, 0, -recessDepth / 2);
          group.add(rightVoid);

          // Top void ceiling
          const topVoid = new THREE.Mesh(
            new THREE.PlaneGeometry(openingW, recessDepth),
            voidMat
          );
          topVoid.rotation.x = Math.PI / 2;
          topVoid.position.set(0, openingH / 2, -recessDepth / 2);
          group.add(topVoid);

          // Bottom void floor
          const bottomVoid = new THREE.Mesh(
            new THREE.PlaneGeometry(openingW, recessDepth),
            voidMat
          );
          bottomVoid.rotation.x = -Math.PI / 2;
          bottomVoid.position.set(0, -openingH / 2, -recessDepth / 2);
          group.add(bottomVoid);

          // === STONE FRAME (Front Face) ===
          // Top stone piece (face)
          const topFace = new THREE.Mesh(
            new THREE.BoxGeometry(w, frameW, frameD),
            surroundMat
          );
          topFace.position.set(0, h / 2 - frameW / 2, frameD / 2);
          topFace.castShadow = true;
          group.add(topFace);

          // Bottom stone piece (face) - wider for fireplace hearth ledge
          const bottomFaceH = isFireplace ? frameW * 1.5 : frameW;
          const bottomFace = new THREE.Mesh(
            new THREE.BoxGeometry(w, bottomFaceH, isFireplace ? frameD * 1.5 : frameD),
            surroundMat
          );
          bottomFace.position.set(0, -h / 2 + bottomFaceH / 2, isFireplace ? frameD * 0.75 : frameD / 2);
          bottomFace.castShadow = true;
          group.add(bottomFace);

          // Left stone piece (face)
          const leftFace = new THREE.Mesh(
            new THREE.BoxGeometry(frameW, openingH, frameD),
            surroundMat
          );
          leftFace.position.set(-w / 2 + frameW / 2, 0, frameD / 2);
          leftFace.castShadow = true;
          group.add(leftFace);

          // Right stone piece (face)
          const rightFace = new THREE.Mesh(
            new THREE.BoxGeometry(frameW, openingH, frameD),
            surroundMat
          );
          rightFace.position.set(w / 2 - frameW / 2, 0, frameD / 2);
          rightFace.castShadow = true;
          group.add(rightFace);

          // === STONE LEDGES (Returns into the recess - visible from front) ===
          const ledgeDepth = Math.min(recessDepth * 0.3, 0.25); // How far ledges go into void

          // Top ledge (stone sill at top of opening, goes into void)
          const topLedge = new THREE.Mesh(
            new THREE.BoxGeometry(openingW, frameD * 0.6, ledgeDepth),
            surroundMat
          );
          topLedge.position.set(0, openingH / 2 - frameD * 0.3, -ledgeDepth / 2);
          topLedge.castShadow = true;
          topLedge.receiveShadow = true;
          group.add(topLedge);

          // Bottom ledge/sill (most visible - like a window sill)
          const sillThickness = frameD * 0.8;
          const sillDepth = ledgeDepth * 1.2;
          const bottomSill = new THREE.Mesh(
            new THREE.BoxGeometry(openingW + 0.02, sillThickness, sillDepth),
            surroundMat
          );
          bottomSill.position.set(0, -openingH / 2 + sillThickness / 2, -sillDepth / 2 + 0.01);
          bottomSill.castShadow = true;
          bottomSill.receiveShadow = true;
          group.add(bottomSill);

          // Left inside ledge (return into void)
          const leftLedge = new THREE.Mesh(
            new THREE.BoxGeometry(frameD * 0.5, openingH - sillThickness * 2, ledgeDepth),
            surroundMat
          );
          leftLedge.position.set(-openingW / 2 + frameD * 0.25, 0, -ledgeDepth / 2);
          leftLedge.castShadow = true;
          group.add(leftLedge);

          // Right inside ledge (return into void)
          const rightLedge = new THREE.Mesh(
            new THREE.BoxGeometry(frameD * 0.5, openingH - sillThickness * 2, ledgeDepth),
            surroundMat
          );
          rightLedge.position.set(openingW / 2 - frameD * 0.25, 0, -ledgeDepth / 2);
          rightLedge.castShadow = true;
          group.add(rightLedge);

          // === EDGE DETAIL (Eased edge on front of sill) ===
          const edgeProfile = el.edgeProfile || 'eased';
          if (edgeProfile !== 'square' && edgeProfile !== 'flat') {
            const edgeRadius = sillThickness * 0.4;
            // Small rounded edge on the front of bottom sill
            const sillEdge = new THREE.Mesh(
              new THREE.CylinderGeometry(edgeRadius * 0.3, edgeRadius * 0.3, openingW, 8, 1, false, 0, Math.PI),
              surroundMat
            );
            sillEdge.rotation.x = Math.PI / 2;
            sillEdge.rotation.z = Math.PI / 2;
            sillEdge.position.set(0, -openingH / 2 + sillThickness * 0.15, frameD * 0.3);
            group.add(sillEdge);
          }

          break;
        }

        case 'fireplace-hearth': {
          // Hearth stone (floor piece in front of fireplace)
          const hearthThickness = el.stoneThickness || 0.08;
          const hearthMat = createTexturedMaterial(color, textureUrl, {
            roughness: 0.35,
            metalness: 0.05,
            finish: el.finish || 'polished'
          });

          // Main hearth slab
          const hearth = new THREE.Mesh(
            new THREE.BoxGeometry(w, hearthThickness, d),
            hearthMat
          );
          group.add(hearth);

          // Raised edge at back
          const backEdge = new THREE.Mesh(
            new THREE.BoxGeometry(w, 0.15, hearthThickness),
            hearthMat
          );
          backEdge.position.set(0, 0.035, -d / 2 + hearthThickness / 2);
          group.add(backEdge);

          // Bullnose front edge
          const edgeRadius = hearthThickness / 2;
          const frontEdge = new THREE.Mesh(
            new THREE.CylinderGeometry(edgeRadius, edgeRadius, w, 12, 1, false, 0, Math.PI),
            hearthMat
          );
          frontEdge.rotation.z = Math.PI / 2;
          frontEdge.rotation.y = Math.PI / 2;
          frontEdge.position.set(0, 0, d / 2);
          group.add(frontEdge);
          break;
        }

        case 'sink':
        case 'sink-double':
        case 'sink-farmhouse': {
          // Determine sink style
          const isDouble = el.type === 'sink-double';
          const isFarmhouse = el.type === 'sink-farmhouse' || el.mountType === 'farmhouse';
          const isTopmount = el.mountType === 'topmount';
          const isUndermount = el.mountType === 'undermount' || (!isTopmount && !isFarmhouse);

          // Debug logging
          console.log('Sink render:', el.type, 'mountType:', el.mountType, 'isTopmount:', isTopmount, 'isUndermount:', isUndermount);

          // Get sink color/finish from element property
          const sinkFinish = el.sinkColor || (isFarmhouse ? 'white' : 'stainless');

          // Sink finish color configurations
          const sinkFinishes = {
            stainless: { color: 0xD8D8D8, roughness: 0.25, metalness: 0.85, basinColor: 0x3a3a3a, basinMetal: 0.6 },
            black: { color: 0x2A2A2A, roughness: 0.35, metalness: 0.4, basinColor: 0x1a1a1a, basinMetal: 0.3 },
            white: { color: 0xFFFEF7, roughness: 0.6, metalness: 0.05, basinColor: 0xF8F8F0, basinMetal: 0 },
            graphite: { color: 0x4A4A4A, roughness: 0.4, metalness: 0.3, basinColor: 0x2a2a2a, basinMetal: 0.2 },
            bisque: { color: 0xF5E6D3, roughness: 0.5, metalness: 0.05, basinColor: 0xE8D8C8, basinMetal: 0 },
            bronze: { color: 0x5C4033, roughness: 0.35, metalness: 0.7, basinColor: 0x3a2a20, basinMetal: 0.5 }
          };

          const finish = sinkFinishes[sinkFinish] || sinkFinishes.stainless;

          // Materials based on selected finish with environment maps for reflections
          const sinkMat = new THREE.MeshStandardMaterial({
            color: finish.color,
            roughness: finish.roughness,
            metalness: finish.metalness,
            envMap: finish.metalness > 0.3 ? window.roomEnvMap : null,
            envMapIntensity: finish.metalness > 0.5 ? 1.0 : 0.5
          });

          const basinMat = new THREE.MeshStandardMaterial({
            color: finish.basinColor,
            roughness: finish.roughness + 0.1,
            metalness: finish.basinMetal,
            envMap: finish.basinMetal > 0.3 ? window.roomEnvMap : null,
            envMapIntensity: 0.6
          });

          // Chrome for faucets - adjust based on sink finish
          const chromeFinishes = {
            stainless: { color: 0xE0E0E0, metalness: 0.95 },
            black: { color: 0x1a1a1a, metalness: 0.7 },
            white: { color: 0xE0E0E0, metalness: 0.95 },
            graphite: { color: 0x3a3a3a, metalness: 0.8 },
            bisque: { color: 0xE0E0E0, metalness: 0.95 },
            bronze: { color: 0x5C4033, metalness: 0.8 }
          };
          const chromeConfig = chromeFinishes[sinkFinish] || chromeFinishes.stainless;

          const chromeMat = new THREE.MeshStandardMaterial({
            color: chromeConfig.color,
            roughness: 0.05,
            metalness: chromeConfig.metalness,
            envMap: window.roomEnvMap || null,
            envMapIntensity: 1.5 // Chrome is highly reflective
          });

          // Sink depth (how deep the basin goes)
          const basinDepth = isFarmhouse ? 0.75 : 0.6;

          if (isFarmhouse) {
            // Farmhouse/Apron sink - visible front face
            // Outer shell
            const shell = new THREE.Mesh(
              new THREE.BoxGeometry(w, basinDepth, d),
              sinkMat
            );
            shell.position.y = -basinDepth/2 + 0.05;
            group.add(shell);

            // Apron front (visible below counter)
            const apron = new THREE.Mesh(
              new THREE.BoxGeometry(w + 0.02, basinDepth + 0.1, 0.08),
              sinkMat
            );
            apron.position.set(0, -basinDepth/2, d/2);
            group.add(apron);

            // Inner basin
            const innerBasin = new THREE.Mesh(
              new THREE.BoxGeometry(w - 0.12, basinDepth - 0.1, d - 0.12),
              basinMat
            );
            innerBasin.position.y = -basinDepth/2 + 0.02;
            group.add(innerBasin);

            // Drain
            const drain = new THREE.Mesh(
              new THREE.CylinderGeometry(0.04, 0.04, 0.05, 16),
              chromeMat
            );
            drain.position.set(0, -basinDepth + 0.1, 0);
            group.add(drain);

          } else if (isDouble) {
            // Double basin sink
            const rimThickness = 0.06;
            const dividerWidth = 0.08;

            // Outer rim
            const rim = new THREE.Mesh(
              new THREE.BoxGeometry(w, rimThickness, d),
              sinkMat
            );
            rim.position.y = rimThickness/2;
            group.add(rim);

            // Left basin
            const leftBasinW = (w - dividerWidth) / 2 - 0.08;
            const leftBasin = new THREE.Mesh(
              new THREE.BoxGeometry(leftBasinW, basinDepth, d - 0.12),
              basinMat
            );
            leftBasin.position.set(-w/4 - dividerWidth/4, -basinDepth/2 + rimThickness, 0);
            group.add(leftBasin);

            // Right basin
            const rightBasin = new THREE.Mesh(
              new THREE.BoxGeometry(leftBasinW, basinDepth, d - 0.12),
              basinMat
            );
            rightBasin.position.set(w/4 + dividerWidth/4, -basinDepth/2 + rimThickness, 0);
            group.add(rightBasin);

            // Center divider
            const divider = new THREE.Mesh(
              new THREE.BoxGeometry(dividerWidth, basinDepth * 0.8, d - 0.15),
              sinkMat
            );
            divider.position.set(0, -basinDepth/2 + rimThickness + 0.05, 0);
            group.add(divider);

            // Drains
            const leftDrain = new THREE.Mesh(
              new THREE.CylinderGeometry(0.03, 0.03, 0.04, 16),
              chromeMat
            );
            leftDrain.position.set(-w/4 - dividerWidth/4, -basinDepth + rimThickness + 0.05, 0);
            group.add(leftDrain);

            const rightDrain = new THREE.Mesh(
              new THREE.CylinderGeometry(0.03, 0.03, 0.04, 16),
              chromeMat
            );
            rightDrain.position.set(w/4 + dividerWidth/4, -basinDepth + rimThickness + 0.05, 0);
            group.add(rightDrain);

          } else {
            // ================================================================
            // SINGLE BASIN SINK - Realistic undermount or top-mount design
            // Based on actual sink construction: 16-gauge stainless steel,
            // 10" deep basin, tight radius corners, 3.5" drain opening
            // ================================================================

            // Sink dimensions (realistic proportions)
            const sinkDepth = 0.83; // 10 inches deep (standard kitchen sink)
            const wallThickness = 0.025; // 16-gauge stainless (~1/16")
            const cornerRadius = 0.08; // Tight radius corners
            const countertopThick = 0.1; // 1.2" countertop thickness

            // Basin interior dimensions
            const basinW = w - wallThickness * 2;
            const basinD = d - wallThickness * 2;

            // Stainless steel material for sink body
            const stainlessMat = new THREE.MeshStandardMaterial({
              color: finish.color,
              roughness: finish.roughness,
              metalness: finish.metalness,
              envMap: window.roomEnvMap || null,
              envMapIntensity: 1.2,
              side: THREE.DoubleSide
            });

            // Darker interior for depth perception - use DoubleSide to ensure visibility
            const interiorMat = new THREE.MeshStandardMaterial({
              color: new THREE.Color(finish.basinColor).multiplyScalar(0.7),
              roughness: 0.35,
              metalness: finish.basinMetal + 0.2,
              envMap: window.roomEnvMap || null,
              envMapIntensity: 0.5,
              side: THREE.DoubleSide
            });

            // Very dark bottom - also use DoubleSide
            const bottomMat = new THREE.MeshStandardMaterial({
              color: new THREE.Color(finish.basinColor).multiplyScalar(0.4),
              roughness: 0.4,
              metalness: finish.basinMetal + 0.3,
              side: THREE.DoubleSide
            });

            // === TOP MOUNT (Drop-in) - Visible rim on countertop ===
            if (isTopmount) {
              const rimWidth = 0.05; // 5/8" rim flange
              const rimHeight = 0.025;

              // Rim flange (sits on countertop)
              const rimGeo = new THREE.BoxGeometry(w + rimWidth * 2, rimHeight, d + rimWidth * 2);
              const rim = new THREE.Mesh(rimGeo, stainlessMat);
              rim.position.y = rimHeight / 2;
              group.add(rim);

              // Rim lip edge (slight raised edge)
              const lipHeight = 0.015;
              const lip = new THREE.Mesh(
                new THREE.BoxGeometry(w + rimWidth * 2 + 0.01, lipHeight, d + rimWidth * 2 + 0.01),
                stainlessMat
              );
              lip.position.y = rimHeight + lipHeight / 2;
              group.add(lip);
            }

            // === UNDERMOUNT - Basin visible through countertop cutout ===
            // For undermount sinks, the countertop has a hole cut out and the basin
            // is attached underneath. The countertop ShapeGeometry with holes provides
            // the visible edge - no additional geometry needed here.

            // === SINK BASIN (the actual stainless steel bowl) ===
            // Basin starts below countertop surface
            // For undermount: basin top is at countertop bottom (negative reveal - slight countertop overhang)
            // For top mount: basin starts at rim level
            const basinTop = isUndermount ? -0.10 : 0; // Undermount: at countertop bottom (1.2" thick countertop)

            // Basin wall thickness (stainless steel gauge)
            const wallThick = 0.025; // ~0.3 inches thick for visibility
            const btmY = basinTop - sinkDepth;
            const basinHeight = sinkDepth; // Total depth of basin

            // Use BoxGeometry for solid 3D walls that render from all angles
            // Front wall (facing into room)
            const frontWallMesh = new THREE.Mesh(
              new THREE.BoxGeometry(basinW, basinHeight, wallThick),
              interiorMat
            );
            frontWallMesh.position.set(0, basinTop - basinHeight/2, basinD/2 - wallThick/2);
            group.add(frontWallMesh);

            // Back wall
            const backWallMesh = new THREE.Mesh(
              new THREE.BoxGeometry(basinW, basinHeight, wallThick),
              interiorMat
            );
            backWallMesh.position.set(0, basinTop - basinHeight/2, -basinD/2 + wallThick/2);
            group.add(backWallMesh);

            // Left wall
            const leftWallMesh = new THREE.Mesh(
              new THREE.BoxGeometry(wallThick, basinHeight, basinD - wallThick * 2),
              interiorMat
            );
            leftWallMesh.position.set(-basinW/2 + wallThick/2, basinTop - basinHeight/2, 0);
            group.add(leftWallMesh);

            // Right wall
            const rightWallMesh = new THREE.Mesh(
              new THREE.BoxGeometry(wallThick, basinHeight, basinD - wallThick * 2),
              interiorMat
            );
            rightWallMesh.position.set(basinW/2 - wallThick/2, basinTop - basinHeight/2, 0);
            group.add(rightWallMesh);

            // Basin bottom - solid box for better visibility
            const bottomMesh = new THREE.Mesh(
              new THREE.BoxGeometry(basinW - wallThick * 2, wallThick, basinD - wallThick * 2),
              bottomMat
            );
            bottomMesh.position.set(0, btmY + wallThick/2, 0);
            group.add(bottomMesh);

            // === DRAIN ASSEMBLY (3.5" standard) ===
            const drainRadius = 0.145; // 3.5" diameter / 2

            // Drain flange (chrome ring flush with basin bottom)
            const flangeMat = new THREE.MeshStandardMaterial({
              color: 0xCCCCCC,
              roughness: 0.1,
              metalness: 0.9,
              envMap: window.roomEnvMap || null
            });

            const flange = new THREE.Mesh(
              new THREE.RingGeometry(drainRadius - 0.02, drainRadius, 24),
              flangeMat
            );
            flange.rotation.x = -Math.PI / 2;
            flange.position.y = btmY + 0.01;
            group.add(flange);

            // Drain basket/strainer
            const strainerMat = new THREE.MeshStandardMaterial({
              color: 0x888888,
              roughness: 0.2,
              metalness: 0.85
            });

            // Strainer cross bars
            const crossBar1 = new THREE.Mesh(
              new THREE.BoxGeometry(drainRadius * 1.6, 0.008, 0.015),
              strainerMat
            );
            crossBar1.position.y = btmY + 0.015;
            group.add(crossBar1);

            const crossBar2 = new THREE.Mesh(
              new THREE.BoxGeometry(0.015, 0.008, drainRadius * 1.6),
              strainerMat
            );
            crossBar2.position.y = btmY + 0.015;
            group.add(crossBar2);

            // Center drain hole (dark)
            const drainHole = new THREE.Mesh(
              new THREE.CircleGeometry(drainRadius - 0.03, 24),
              new THREE.MeshBasicMaterial({ color: 0x000000 })
            );
            drainHole.rotation.x = -Math.PI / 2;
            drainHole.position.y = btmY + 0.008;
            group.add(drainHole);
          }

          // === PROFESSIONAL GOOSENECK FAUCET ===
          // Large, bold commercial-style kitchen faucet with realistic proportions

          // Enhanced chrome material for faucet with high reflectivity
          const faucetChromeMat = new THREE.MeshStandardMaterial({
            color: chromeConfig.color,
            roughness: 0.03,
            metalness: 0.98,
            envMap: window.roomEnvMap || null,
            envMapIntensity: 2.0
          });

          // Base deck plate/escutcheon - larger and more detailed
          const deckPlate = new THREE.Mesh(
            new THREE.CylinderGeometry(0.08, 0.09, 0.02, 24),
            faucetChromeMat
          );
          deckPlate.position.set(0, 0.05, -d/2 + 0.15);
          deckPlate.castShadow = true;
          deckPlate.receiveShadow = true;
          group.add(deckPlate);

          // Faucet body base - thicker column
          const faucetBodyBase = new THREE.Mesh(
            new THREE.CylinderGeometry(0.035, 0.045, 0.12, 20),
            faucetChromeMat
          );
          faucetBodyBase.position.set(0, 0.12, -d/2 + 0.15);
          faucetBodyBase.castShadow = true;
          group.add(faucetBodyBase);

          // Create dramatic gooseneck curve - BIGGER and BOLDER
          // Professional kitchen faucet stands about 16-18 inches tall
          const gooseneckPoints = [
            new THREE.Vector3(0, 0.18, -d/2 + 0.15),      // Start at body top
            new THREE.Vector3(0, 0.35, -d/2 + 0.15),      // Rise straight up
            new THREE.Vector3(0, 0.55, -d/2 + 0.16),      // Continue rising
            new THREE.Vector3(0, 0.72, -d/2 + 0.20),      // Start curving forward
            new THREE.Vector3(0, 0.82, -d/2 + 0.30),      // Peak of gooseneck curve
            new THREE.Vector3(0, 0.80, -d/2 + 0.45),      // Curve over
            new THREE.Vector3(0, 0.70, -d/2 + 0.55),      // Descend towards sink
            new THREE.Vector3(0, 0.58, -d/2 + 0.60),      // Spout pointing down
          ];

          const gooseneckCurve = new THREE.CatmullRomCurve3(gooseneckPoints);

          // Thicker tube radius for bold appearance
          const faucetTubeRadius = 0.028;
          const faucetTubeGeo = new THREE.TubeGeometry(
            gooseneckCurve,
            48,  // More segments for smoother curve
            faucetTubeRadius,
            16,  // More radial segments for rounder tube
            false
          );

          const faucetNeck = new THREE.Mesh(faucetTubeGeo, faucetChromeMat);
          faucetNeck.castShadow = true;
          faucetNeck.receiveShadow = true;
          group.add(faucetNeck);

          // Spout tip with aerator detail
          const spoutOuter = new THREE.Mesh(
            new THREE.CylinderGeometry(0.032, 0.028, 0.06, 16),
            faucetChromeMat
          );
          spoutOuter.position.set(0, 0.55, -d/2 + 0.62);
          spoutOuter.rotation.x = Math.PI / 4; // Angled down
          spoutOuter.castShadow = true;
          group.add(spoutOuter);

          // Aerator insert (dark)
          const aeratorMat = new THREE.MeshStandardMaterial({
            color: 0x2a2a2a,
            roughness: 0.6,
            metalness: 0.3
          });
          const aerator = new THREE.Mesh(
            new THREE.CylinderGeometry(0.018, 0.018, 0.02, 12),
            aeratorMat
          );
          aerator.position.set(0, 0.52, -d/2 + 0.64);
          aerator.rotation.x = Math.PI / 4;
          group.add(aerator);

          // Single-handle lever (modern style) - more substantial
          const leverBaseMat = new THREE.MeshStandardMaterial({
            color: chromeConfig.color,
            roughness: 0.05,
            metalness: 0.95,
            envMap: window.roomEnvMap || null,
            envMapIntensity: 1.8
          });

          // Lever pivot base
          const leverPivot = new THREE.Mesh(
            new THREE.CylinderGeometry(0.04, 0.04, 0.04, 16),
            leverBaseMat
          );
          leverPivot.position.set(0, 0.20, -d/2 + 0.15);
          leverPivot.castShadow = true;
          group.add(leverPivot);

          // Lever arm - sleek modern handle
          const leverArm = new THREE.Mesh(
            new THREE.BoxGeometry(0.16, 0.025, 0.035),
            leverBaseMat
          );
          leverArm.position.set(0.06, 0.23, -d/2 + 0.15);
          leverArm.rotation.z = -0.15; // Slight angle
          leverArm.castShadow = true;
          group.add(leverArm);

          // Lever end cap
          const leverEnd = new THREE.Mesh(
            new THREE.SphereGeometry(0.022, 12, 12),
            leverBaseMat
          );
          leverEnd.position.set(0.14, 0.21, -d/2 + 0.15);
          leverEnd.castShadow = true;
          group.add(leverEnd);

          break;
        }

        case 'stove':
        case 'range':
        case 'cooktop': {
          // Professional range/stove/cooktop
          const stoveMat = new THREE.MeshStandardMaterial({
            color: 0x2a2a2a,
            roughness: 0.3,
            metalness: 0.5
          });

          // Main body
          const stoveBody = new THREE.Mesh(
            new THREE.BoxGeometry(w, h, d),
            stoveMat
          );
          group.add(stoveBody);

          // Cooktop surface (glass or steel)
          const cooktopMat = new THREE.MeshStandardMaterial({
            color: 0x1a1a1a,
            roughness: 0.1,
            metalness: 0.4
          });
          const cooktop = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.08, 0.04, d - 0.15),
            cooktopMat
          );
          cooktop.position.y = h/2 - 0.02;
          group.add(cooktop);

          // Burner grates
          const grateMat = new THREE.MeshStandardMaterial({
            color: 0x1a1a1a,
            roughness: 0.6,
            metalness: 0.3
          });

          const burnerLayout = [
            [-w * 0.25, -d * 0.2], [w * 0.25, -d * 0.2],
            [-w * 0.25, d * 0.2], [w * 0.25, d * 0.2]
          ];

          burnerLayout.forEach(([bx, bz]) => {
            // Grate
            const grate = new THREE.Mesh(
              new THREE.BoxGeometry(0.5, 0.04, 0.5),
              grateMat
            );
            grate.position.set(bx, h/2 + 0.02, bz);
            group.add(grate);

            // Burner ring
            const ringMat = new THREE.MeshStandardMaterial({
              color: 0x333333,
              roughness: 0.5,
              metalness: 0.4
            });
            const ring = new THREE.Mesh(
              new THREE.TorusGeometry(0.15, 0.02, 8, 24),
              ringMat
            );
            ring.rotation.x = Math.PI / 2;
            ring.position.set(bx, h/2, bz);
            group.add(ring);
          });

          // Control knobs
          const knobMat = new THREE.MeshStandardMaterial({
            color: 0x3a3a3a,
            roughness: 0.4,
            metalness: 0.3
          });
          for (let i = 0; i < 5; i++) {
            const knob = new THREE.Mesh(
              new THREE.CylinderGeometry(0.04, 0.04, 0.03, 16),
              knobMat
            );
            knob.rotation.x = Math.PI / 2;
            knob.position.set(-w/2 + 0.2 + i * 0.18, h/2 - 0.3, d/2 + 0.02);
            group.add(knob);
          }

          // Oven door
          const ovenDoorMat = new THREE.MeshStandardMaterial({
            color: 0x2a2a2a,
            roughness: 0.25,
            metalness: 0.45
          });
          const ovenDoor = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.15, h * 0.5, 0.05),
            ovenDoorMat
          );
          ovenDoor.position.set(0, -h * 0.15, d/2);
          group.add(ovenDoor);

          // Oven window
          const glassMat = new THREE.MeshStandardMaterial({
            color: 0x111111,
            roughness: 0.05,
            metalness: 0.1,
            transparent: true,
            opacity: 0.85
          });
          const ovenWindow = new THREE.Mesh(
            new THREE.BoxGeometry(w * 0.6, h * 0.35, 0.02),
            glassMat
          );
          ovenWindow.position.set(0, -h * 0.15, d/2 + 0.04);
          group.add(ovenWindow);

          // Oven handle
          const handleMat = new THREE.MeshStandardMaterial({
            color: 0xB0B0B0,
            roughness: 0.15,
            metalness: 0.85
          });
          const ovenHandle = new THREE.Mesh(
            new THREE.CylinderGeometry(0.02, 0.02, w * 0.7, 12),
            handleMat
          );
          ovenHandle.rotation.z = Math.PI / 2;
          ovenHandle.position.set(0, h * 0.12, d/2 + 0.08);
          group.add(ovenHandle);
          break;
        }

        case 'slide-in-range': {
          // Slide-in range - no side panels, fits between cabinets
          // Controls on front face, continuous cooktop surface
          const slideRangeMat = new THREE.MeshStandardMaterial({
            color: 0x303030,
            roughness: 0.3,
            metalness: 0.5
          });

          // Main body (recessed sides to fit between cabinets)
          const rangeBody = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.08, h - 0.1, d - 0.08),
            slideRangeMat
          );
          rangeBody.position.y = 0.05;
          group.add(rangeBody);

          // Cooktop surface extends slightly over countertop
          const cooktopMat = new THREE.MeshStandardMaterial({
            color: 0x1a1a1a,
            roughness: 0.1,
            metalness: 0.4
          });
          const slideCooktop = new THREE.Mesh(
            new THREE.BoxGeometry(w, 0.05, d - 0.1),
            cooktopMat
          );
          slideCooktop.position.y = h/2 + 0.02;
          group.add(slideCooktop);

          // Burner grates
          const slideGrateMat = new THREE.MeshStandardMaterial({
            color: 0x1a1a1a,
            roughness: 0.6,
            metalness: 0.3
          });

          const slideBurnerLayout = [
            [-w * 0.25, -d * 0.15], [w * 0.25, -d * 0.15],
            [-w * 0.25, d * 0.15], [w * 0.25, d * 0.15]
          ];

          slideBurnerLayout.forEach(([bx, bz]) => {
            const grate = new THREE.Mesh(
              new THREE.BoxGeometry(0.45, 0.04, 0.45),
              slideGrateMat
            );
            grate.position.set(bx, h/2 + 0.05, bz);
            group.add(grate);

            const ringMat = new THREE.MeshStandardMaterial({
              color: 0x333333,
              roughness: 0.5,
              metalness: 0.4
            });
            const ring = new THREE.Mesh(
              new THREE.TorusGeometry(0.13, 0.02, 8, 24),
              ringMat
            );
            ring.rotation.x = Math.PI / 2;
            ring.position.set(bx, h/2 + 0.02, bz);
            group.add(ring);
          });

          // Front control panel (distinctive slide-in feature)
          const controlPanelMat = new THREE.MeshStandardMaterial({
            color: 0x404040,
            roughness: 0.2,
            metalness: 0.6
          });
          const controlPanel = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.04, 0.25, 0.03),
            controlPanelMat
          );
          controlPanel.position.set(0, h/2 - 0.15, d/2 + 0.02);
          group.add(controlPanel);

          // Front knobs
          const slideKnobMat = new THREE.MeshStandardMaterial({
            color: 0xC0C0C0,
            roughness: 0.2,
            metalness: 0.8
          });
          for (let i = 0; i < 5; i++) {
            const knob = new THREE.Mesh(
              new THREE.CylinderGeometry(0.035, 0.035, 0.02, 16),
              slideKnobMat
            );
            knob.rotation.x = Math.PI / 2;
            knob.position.set(-w/2 + 0.25 + i * (w - 0.5) / 4, h/2 - 0.15, d/2 + 0.05);
            group.add(knob);
          }

          // Oven door
          const slideOvenDoorMat = new THREE.MeshStandardMaterial({
            color: 0x2a2a2a,
            roughness: 0.25,
            metalness: 0.45
          });
          const slideOvenDoor = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.15, h * 0.55, 0.05),
            slideOvenDoorMat
          );
          slideOvenDoor.position.set(0, -h * 0.2, d/2);
          group.add(slideOvenDoor);

          // Oven window
          const slideGlassMat = new THREE.MeshStandardMaterial({
            color: 0x111111,
            roughness: 0.05,
            metalness: 0.1,
            transparent: true,
            opacity: 0.85
          });
          const slideOvenWindow = new THREE.Mesh(
            new THREE.BoxGeometry(w * 0.55, h * 0.35, 0.02),
            slideGlassMat
          );
          slideOvenWindow.position.set(0, -h * 0.2, d/2 + 0.04);
          group.add(slideOvenWindow);

          // Oven handle
          const slideHandleMat = new THREE.MeshStandardMaterial({
            color: 0xB0B0B0,
            roughness: 0.15,
            metalness: 0.85
          });
          const slideOvenHandle = new THREE.Mesh(
            new THREE.CylinderGeometry(0.02, 0.02, w * 0.65, 12),
            slideHandleMat
          );
          slideOvenHandle.rotation.z = Math.PI / 2;
          slideOvenHandle.position.set(0, h * 0.1, d/2 + 0.08);
          group.add(slideOvenHandle);

          break;
        }

        case 'single-oven-cabinet':
        case 'tall-oven':
        case 'double-oven-cabinet': {
          // Wall oven cabinet - tall cabinet with built-in oven(s)
          // Layout for 84" single oven cabinet:
          //   - Top cabinet door: ~24" (storage)
          //   - Oven: ~30"
          //   - Bottom drawer: ~12"
          //   - Toe kick: ~4" (built into base)
          // Layout for 96" double oven cabinet:
          //   - Top oven: ~30"
          //   - Bottom oven: ~30"
          //   - Storage drawer: ~12"

          const isDouble = el.type === 'double-oven-cabinet';
          const ovenCabinetFinish = el.cabinetFinish || 'wood-grain';
          const ovenCabGrainType = el.grainType || 'oak';
          let ovenCabWoodTexture = null;
          let ovenCabBaseRoughness = 0.35;

          // Check for custom texture first
          if (textureUrl) {
            const textureLoader = new THREE.TextureLoader();
            try {
              ovenCabWoodTexture = textureLoader.load(textureUrl);
              ovenCabWoodTexture.wrapS = THREE.RepeatWrapping;
              ovenCabWoodTexture.wrapT = THREE.RepeatWrapping;
              ovenCabWoodTexture.repeat.set(2, 2);
            } catch (e) {
              ovenCabWoodTexture = createWoodGrainTexture(color, 0.12, ovenCabGrainType);
            }
            ovenCabBaseRoughness = 0.3;
          } else if (ovenCabinetFinish === 'wood-grain') {
            ovenCabWoodTexture = createWoodGrainTexture(color, 0.12, ovenCabGrainType);
            ovenCabBaseRoughness = 0.3;
          } else if (ovenCabinetFinish === 'painted' || ovenCabinetFinish === 'matte' || ovenCabinetFinish === 'gloss') {
            ovenCabWoodTexture = createWoodGrainTexture(color, 0.03, 'flat');
            ovenCabBaseRoughness = ovenCabinetFinish === 'gloss' ? 0.1 : (ovenCabinetFinish === 'matte' ? 0.7 : 0.4);
          }

          // Cabinet wood material
          const ovenCabMat = new THREE.MeshStandardMaterial({
            color: color,
            map: ovenCabWoodTexture,
            roughness: ovenCabBaseRoughness,
            metalness: 0.02
          });

          // Darker interior material
          const interiorMat = new THREE.MeshStandardMaterial({
            color: 0x1a1a1a,
            roughness: 0.9
          });

          const panelThick = 0.05;
          const doorThick = 0.06;
          const doorGap = 0.02;

          // === CABINET BOX (sides, top, bottom, back) ===

          // Left side panel (full height)
          const leftPanel = new THREE.Mesh(
            new THREE.BoxGeometry(panelThick, h, d),
            ovenCabMat
          );
          leftPanel.position.set(-w/2 + panelThick/2, 0, 0);
          group.add(leftPanel);

          // Right side panel (full height)
          const rightPanel = new THREE.Mesh(
            new THREE.BoxGeometry(panelThick, h, d),
            ovenCabMat
          );
          rightPanel.position.set(w/2 - panelThick/2, 0, 0);
          group.add(rightPanel);

          // Top panel
          const topPanel = new THREE.Mesh(
            new THREE.BoxGeometry(w, panelThick, d),
            ovenCabMat
          );
          topPanel.position.set(0, h/2 - panelThick/2, 0);
          group.add(topPanel);

          // Back panel
          const backPanel = new THREE.Mesh(
            new THREE.BoxGeometry(w - panelThick * 2, h, panelThick),
            interiorMat
          );
          backPanel.position.set(0, 0, -d/2 + panelThick/2);
          group.add(backPanel);

          // === LAYOUT CALCULATIONS ===
          const toeKickH = 0.35;  // 4"
          const drawerH = 1.0;    // 12" drawer
          const ovenH = 2.5;      // 30" oven
          const midDrawerH = 0.65; // ~8" drawer/spacer between ovens (double only)
          const topFillerH = isDouble ? 1.0 : 0;  // ~12" filler/door at top for double
          const topCabH = isDouble ? 0 : (h - toeKickH - drawerH - ovenH);  // Remaining space for single

          // Y positions (from bottom up)
          const toeKickY = -h/2 + toeKickH/2;
          const drawerY = -h/2 + toeKickH + drawerH/2;
          const oven1Y = isDouble
            ? (-h/2 + toeKickH + drawerH + ovenH/2)  // Bottom oven for double
            : (drawerY + drawerH/2 + ovenH/2);       // Single oven above drawer
          const midDrawerY = oven1Y + ovenH/2 + midDrawerH/2;  // Between ovens (double only)
          const oven2Y = midDrawerY + midDrawerH/2 + ovenH/2;  // Top oven for double
          const topFillerY = oven2Y + ovenH/2 + topFillerH/2;  // Top filler position
          const topCabY = h/2 - topCabH/2;

          // === TOE KICK (recessed) ===
          const toeKick = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.2, toeKickH, d * 0.6),
            interiorMat
          );
          toeKick.position.set(0, toeKickY, -d * 0.15);
          group.add(toeKick);

          // === BOTTOM DRAWER ===
          // Drawer front
          const drawerFront = new THREE.Mesh(
            new THREE.BoxGeometry(w - doorGap * 2, drawerH - doorGap * 2, doorThick),
            ovenCabMat
          );
          drawerFront.position.set(0, drawerY, d/2 - doorThick/2);
          group.add(drawerFront);

          // Drawer shaker frame
          const frameW = 0.08;
          const drawerFrameMat = new THREE.MeshStandardMaterial({
            color: color,
            map: ovenCabWoodTexture,
            roughness: ovenCabBaseRoughness - 0.05,
            metalness: 0.02
          });

          // Top frame
          const drawerFrameTop = new THREE.Mesh(
            new THREE.BoxGeometry(w - doorGap * 2, frameW, 0.02),
            drawerFrameMat
          );
          drawerFrameTop.position.set(0, drawerY + drawerH/2 - frameW/2 - doorGap, d/2 + 0.01);
          group.add(drawerFrameTop);

          // Bottom frame
          const drawerFrameBot = new THREE.Mesh(
            new THREE.BoxGeometry(w - doorGap * 2, frameW, 0.02),
            drawerFrameMat
          );
          drawerFrameBot.position.set(0, drawerY - drawerH/2 + frameW/2 + doorGap, d/2 + 0.01);
          group.add(drawerFrameBot);

          // Drawer handle
          const drawerHandle = createModernBarHandle(0.3, 'brushed-nickel');
          drawerHandle.position.set(0, drawerY, d/2 + 0.06);
          group.add(drawerHandle);

          // === OVEN(S) ===
          const ovenPositions = isDouble ? [oven1Y, oven2Y] : [oven1Y];

          ovenPositions.forEach((ovenY, idx) => {
            const ovenW = w - 0.15;

            // Oven housing (stainless steel frame)
            const ovenFrameMat = new THREE.MeshStandardMaterial({
              color: 0x4a4a4a,
              roughness: 0.3,
              metalness: 0.7
            });

            // Oven outer frame
            const ovenFrame = new THREE.Mesh(
              new THREE.BoxGeometry(ovenW, ovenH - 0.05, 0.08),
              ovenFrameMat
            );
            ovenFrame.position.set(0, ovenY, d/2 - 0.04);
            group.add(ovenFrame);

            // Oven door (black glass with stainless trim)
            const ovenDoorMat = new THREE.MeshStandardMaterial({
              color: 0x1a1a1a,
              roughness: 0.15,
              metalness: 0.3
            });
            const ovenDoor = new THREE.Mesh(
              new THREE.BoxGeometry(ovenW - 0.08, ovenH - 0.15, 0.04),
              ovenDoorMat
            );
            ovenDoor.position.set(0, ovenY - 0.1, d/2);
            group.add(ovenDoor);

            // Oven window (dark glass, slightly reflective)
            const ovenGlassMat = new THREE.MeshStandardMaterial({
              color: 0x0a0a0a,
              roughness: 0.02,
              metalness: 0.15,
              transparent: true,
              opacity: 0.9
            });
            const windowH = ovenH * 0.55;
            const ovenWindow = new THREE.Mesh(
              new THREE.BoxGeometry(ovenW - 0.2, windowH, 0.01),
              ovenGlassMat
            );
            ovenWindow.position.set(0, ovenY - 0.15, d/2 + 0.025);
            group.add(ovenWindow);

            // Control panel (above oven door)
            const controlMat = new THREE.MeshStandardMaterial({
              color: 0x2a2a2a,
              roughness: 0.2,
              metalness: 0.5
            });
            const controlPanel = new THREE.Mesh(
              new THREE.BoxGeometry(ovenW - 0.08, 0.35, 0.03),
              controlMat
            );
            controlPanel.position.set(0, ovenY + ovenH/2 - 0.25, d/2 + 0.01);
            group.add(controlPanel);

            // Control knobs
            const knobMat = new THREE.MeshStandardMaterial({
              color: 0x888888,
              roughness: 0.2,
              metalness: 0.8
            });
            for (let k = 0; k < 4; k++) {
              const knob = new THREE.Mesh(
                new THREE.CylinderGeometry(0.04, 0.04, 0.03, 16),
                knobMat
              );
              knob.rotation.x = Math.PI / 2;
              knob.position.set(-0.25 + k * 0.17, ovenY + ovenH/2 - 0.25, d/2 + 0.04);
              group.add(knob);
            }

            // Oven handle (horizontal bar)
            const handleMat = new THREE.MeshStandardMaterial({
              color: 0xc0c0c0,
              roughness: 0.15,
              metalness: 0.9
            });
            const ovenHandle = new THREE.Mesh(
              new THREE.CylinderGeometry(0.025, 0.025, ovenW * 0.7, 12),
              handleMat
            );
            ovenHandle.rotation.z = Math.PI / 2;
            ovenHandle.position.set(0, ovenY + ovenH/2 - 0.55, d/2 + 0.07);
            group.add(ovenHandle);

            // Handle mounts
            const mountMat = new THREE.MeshStandardMaterial({
              color: 0xa0a0a0,
              roughness: 0.2,
              metalness: 0.85
            });
            [-ovenW * 0.3, ovenW * 0.3].forEach(xPos => {
              const mount = new THREE.Mesh(
                new THREE.BoxGeometry(0.04, 0.06, 0.08),
                mountMat
              );
              mount.position.set(xPos, ovenY + ovenH/2 - 0.55, d/2 + 0.04);
              group.add(mount);
            });
          });

          // === MID-DRAWER (spacer between ovens for double oven) ===
          if (isDouble) {
            // Mid drawer front (between the two ovens)
            const midDrawerFront = new THREE.Mesh(
              new THREE.BoxGeometry(w - doorGap * 2, midDrawerH - doorGap * 2, doorThick),
              ovenCabMat
            );
            midDrawerFront.position.set(0, midDrawerY, d/2 - doorThick/2);
            group.add(midDrawerFront);

            // Mid drawer shaker frame - top rail
            const midFrameTop = new THREE.Mesh(
              new THREE.BoxGeometry(w - doorGap * 2, frameW * 0.7, 0.02),
              drawerFrameMat
            );
            midFrameTop.position.set(0, midDrawerY + midDrawerH/2 - frameW/2 - doorGap, d/2 + 0.01);
            group.add(midFrameTop);

            // Mid drawer shaker frame - bottom rail
            const midFrameBot = new THREE.Mesh(
              new THREE.BoxGeometry(w - doorGap * 2, frameW * 0.7, 0.02),
              drawerFrameMat
            );
            midFrameBot.position.set(0, midDrawerY - midDrawerH/2 + frameW/2 + doorGap, d/2 + 0.01);
            group.add(midFrameBot);

            // Mid drawer handle
            const midHandle = createModernBarHandle(0.25, 'brushed-nickel');
            midHandle.position.set(0, midDrawerY, d/2 + 0.06);
            group.add(midHandle);
          }

          // === TOP FILLER PANEL (for double oven) ===
          if (isDouble && topFillerH > 0.2) {
            // Top filler/cabinet door
            const topFillerDoor = new THREE.Mesh(
              new THREE.BoxGeometry(w - doorGap * 2, topFillerH - doorGap * 2, doorThick),
              ovenCabMat
            );
            topFillerDoor.position.set(0, topFillerY, d/2 - doorThick/2);
            group.add(topFillerDoor);

            // Shaker frame for top filler - top rail
            const topFillerRailTop = new THREE.Mesh(
              new THREE.BoxGeometry(w - doorGap * 2, frameW, 0.02),
              drawerFrameMat
            );
            topFillerRailTop.position.set(0, topFillerY + topFillerH/2 - frameW/2 - doorGap, d/2 + 0.01);
            group.add(topFillerRailTop);

            // Bottom rail
            const topFillerRailBot = new THREE.Mesh(
              new THREE.BoxGeometry(w - doorGap * 2, frameW, 0.02),
              drawerFrameMat
            );
            topFillerRailBot.position.set(0, topFillerY - topFillerH/2 + frameW/2 + doorGap, d/2 + 0.01);
            group.add(topFillerRailBot);

            // Left stile
            const topFillerStileL = new THREE.Mesh(
              new THREE.BoxGeometry(frameW, topFillerH - doorGap * 2, 0.02),
              drawerFrameMat
            );
            topFillerStileL.position.set(-w/2 + frameW/2 + doorGap, topFillerY, d/2 + 0.01);
            group.add(topFillerStileL);

            // Right stile
            const topFillerStileR = new THREE.Mesh(
              new THREE.BoxGeometry(frameW, topFillerH - doorGap * 2, 0.02),
              drawerFrameMat
            );
            topFillerStileR.position.set(w/2 - frameW/2 - doorGap, topFillerY, d/2 + 0.01);
            group.add(topFillerStileR);

            // Top filler handle (small knob or bar)
            const topFillerHandle = createModernBarHandle(0.15, 'brushed-nickel');
            topFillerHandle.position.set(0, topFillerY, d/2 + 0.06);
            group.add(topFillerHandle);
          }

          // === TOP CABINET DOOR (for single oven only) ===
          if (!isDouble && topCabH > 0.3) {
            // Cabinet door
            const topDoor = new THREE.Mesh(
              new THREE.BoxGeometry(w - doorGap * 2, topCabH - doorGap * 2, doorThick),
              ovenCabMat
            );
            topDoor.position.set(0, topCabY, d/2 - doorThick/2);
            group.add(topDoor);

            // Shaker frame for top door
            // Top rail
            const topRail = new THREE.Mesh(
              new THREE.BoxGeometry(w - doorGap * 2, frameW, 0.02),
              drawerFrameMat
            );
            topRail.position.set(0, topCabY + topCabH/2 - frameW/2 - doorGap, d/2 + 0.01);
            group.add(topRail);

            // Bottom rail
            const botRail = new THREE.Mesh(
              new THREE.BoxGeometry(w - doorGap * 2, frameW, 0.02),
              drawerFrameMat
            );
            botRail.position.set(0, topCabY - topCabH/2 + frameW/2 + doorGap, d/2 + 0.01);
            group.add(botRail);

            // Left stile
            const leftStile = new THREE.Mesh(
              new THREE.BoxGeometry(frameW, topCabH - doorGap * 2, 0.02),
              drawerFrameMat
            );
            leftStile.position.set(-w/2 + frameW/2 + doorGap, topCabY, d/2 + 0.01);
            group.add(leftStile);

            // Right stile
            const rightStile = new THREE.Mesh(
              new THREE.BoxGeometry(frameW, topCabH - doorGap * 2, 0.02),
              drawerFrameMat
            );
            rightStile.position.set(w/2 - frameW/2 - doorGap, topCabY, d/2 + 0.01);
            group.add(rightStile);

            // Top cabinet handle
            const topHandle = createModernBarHandle(0.2, 'brushed-nickel');
            topHandle.position.set(0, topCabY - topCabH/4, d/2 + 0.06);
            group.add(topHandle);
          }

          break;
        }

        case 'above-microwave-cabinet': {
          // Combined unit: Short wall cabinet with microwave below
          const aboveMwFinish = el.cabinetFinish || 'wood-grain';
          const aboveMwGrainType = el.grainType || 'oak';
          let aboveMwWoodTexture = null;
          let aboveMwBaseRoughness = 0.35;

          // Check for custom texture first
          if (textureUrl) {
            const textureLoader = new THREE.TextureLoader();
            try {
              aboveMwWoodTexture = textureLoader.load(textureUrl);
              aboveMwWoodTexture.wrapS = THREE.RepeatWrapping;
              aboveMwWoodTexture.wrapT = THREE.RepeatWrapping;
              aboveMwWoodTexture.repeat.set(2, 2);
            } catch (e) {
              aboveMwWoodTexture = createWoodGrainTexture(color, 0.12, aboveMwGrainType);
            }
            aboveMwBaseRoughness = 0.3;
          } else if (aboveMwFinish === 'wood-grain') {
            aboveMwWoodTexture = createWoodGrainTexture(color, 0.12, aboveMwGrainType);
            aboveMwBaseRoughness = 0.3;
          } else if (aboveMwFinish === 'painted' || aboveMwFinish === 'matte' || aboveMwFinish === 'gloss') {
            aboveMwWoodTexture = createWoodGrainTexture(color, 0.03, 'flat');
            aboveMwBaseRoughness = aboveMwFinish === 'gloss' ? 0.1 : (aboveMwFinish === 'matte' ? 0.7 : 0.4);
          }

          const aboveMwMat = new THREE.MeshStandardMaterial({
            color: color,
            map: aboveMwWoodTexture,
            roughness: aboveMwBaseRoughness,
            metalness: 0.02,
            bumpScale: aboveMwWoodTexture ? 0.002 : 0
          });

          // Microwave dimensions (below the cabinet)
          const mwHeight = 1.25; // 15 inches
          const mwDepth = d * 1.2; // Microwave slightly deeper than cabinet
          const mwYOffset = -(h / 2) - (mwHeight / 2) - 0.02; // Position below cabinet

          // === CABINET SECTION (top) ===
          // Cabinet body
          const bodyMat = new THREE.MeshStandardMaterial({ color: 0x2a2a2a, roughness: 0.8 });
          const body = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.08, h - 0.08, d - 0.08),
            bodyMat
          );
          body.position.z = -0.02;
          group.add(body);

          // Door
          const doorGap = 0.02;
          const door = new THREE.Mesh(
            new THREE.BoxGeometry(w - doorGap * 2, h - doorGap * 2, 0.05),
            aboveMwMat
          );
          door.position.set(0, 0, d/2);
          group.add(door);

          // Shaker style frame
          const frameW = 0.06;
          const frameMat = new THREE.MeshStandardMaterial({
            color: color,
            map: aboveMwWoodTexture,
            roughness: aboveMwBaseRoughness - 0.02,
            metalness: 0.02
          });

          // Top rail
          const topFrame = new THREE.Mesh(new THREE.BoxGeometry(w - doorGap * 2 - 0.04, frameW, 0.02), frameMat);
          topFrame.position.set(0, (h - doorGap * 2)/2 - frameW/2 - 0.02, d/2 + 0.03);
          group.add(topFrame);

          // Bottom rail
          const botFrame = new THREE.Mesh(new THREE.BoxGeometry(w - doorGap * 2 - 0.04, frameW, 0.02), frameMat);
          botFrame.position.set(0, -(h - doorGap * 2)/2 + frameW/2 + 0.02, d/2 + 0.03);
          group.add(botFrame);

          // Stiles
          const leftStile = new THREE.Mesh(new THREE.BoxGeometry(frameW, h - doorGap * 2 - frameW * 2, 0.02), frameMat);
          leftStile.position.set(-(w - doorGap * 2)/2 + frameW/2 + 0.02, 0, d/2 + 0.03);
          group.add(leftStile);

          const rightStile = new THREE.Mesh(new THREE.BoxGeometry(frameW, h - doorGap * 2 - frameW * 2, 0.02), frameMat);
          rightStile.position.set((w - doorGap * 2)/2 - frameW/2 - 0.02, 0, d/2 + 0.03);
          group.add(rightStile);

          // Cabinet Handle
          const cabHandle = createModernBarHandle(0.2, 'brushed-nickel');
          cabHandle.position.set(0, -(h - doorGap * 2) * 0.25, d/2 + 0.08);
          cabHandle.rotation.z = Math.PI / 2;
          group.add(cabHandle);

          // === MICROWAVE SECTION (below cabinet) ===
          // Microwave body
          const mwMat = new THREE.MeshStandardMaterial({ color: 0x3a3a3a, roughness: 0.4, metalness: 0.3 });
          const mwBody = new THREE.Mesh(new THREE.BoxGeometry(w, mwHeight, mwDepth), mwMat);
          mwBody.position.set(0, mwYOffset, mwDepth/2 - d/2);
          group.add(mwBody);

          // Glass door window
          const mwGlass = new THREE.Mesh(
            new THREE.BoxGeometry(w * 0.55, mwHeight - 0.15, 0.02),
            new THREE.MeshStandardMaterial({ color: 0x111111, transparent: true, opacity: 0.85, roughness: 0.1 })
          );
          mwGlass.position.set(-w * 0.15, mwYOffset, mwDepth + 0.02 - d/2);
          group.add(mwGlass);

          // Control panel
          const mwCtrlMat = new THREE.MeshStandardMaterial({ color: 0x2a2a2a, roughness: 0.3, metalness: 0.2 });
          const mwCtrl = new THREE.Mesh(
            new THREE.BoxGeometry(w * 0.25, mwHeight - 0.15, 0.02),
            mwCtrlMat
          );
          mwCtrl.position.set(w * 0.32, mwYOffset, mwDepth + 0.02 - d/2);
          group.add(mwCtrl);

          // Control buttons (3x3 grid)
          const mwBtnMat = new THREE.MeshStandardMaterial({ color: 0x555555, roughness: 0.5 });
          for (let i = 0; i < 3; i++) {
            for (let j = 0; j < 3; j++) {
              const btn = new THREE.Mesh(
                new THREE.BoxGeometry(0.04, 0.04, 0.01),
                mwBtnMat
              );
              btn.position.set(
                w * 0.28 + j * 0.06,
                mwYOffset + mwHeight * 0.15 - i * 0.08,
                mwDepth + 0.04 - d/2
              );
              group.add(btn);
            }
          }

          // Digital display (glowing green)
          const mwDisplayMat = new THREE.MeshStandardMaterial({
            color: 0x00ff00,
            emissive: 0x00ff00,
            emissiveIntensity: 0.3,
            roughness: 0.2
          });
          const mwDisplay = new THREE.Mesh(
            new THREE.BoxGeometry(0.12, 0.04, 0.01),
            mwDisplayMat
          );
          mwDisplay.position.set(w * 0.32, mwYOffset + mwHeight * 0.35, mwDepth + 0.04 - d/2);
          group.add(mwDisplay);

          // Handle
          const mwHandleMat = new THREE.MeshStandardMaterial({ color: 0x888888, metalness: 0.8, roughness: 0.2 });
          const mwHandle = new THREE.Mesh(
            new THREE.BoxGeometry(0.03, mwHeight * 0.4, 0.03),
            mwHandleMat
          );
          mwHandle.position.set(-w * 0.42, mwYOffset, mwDepth + 0.06 - d/2);
          group.add(mwHandle);

          // Bottom vent (over-the-range microwave feature)
          const mwVentMat = new THREE.MeshStandardMaterial({ color: 0x4a4a4a, roughness: 0.6 });
          const mwVent = new THREE.Mesh(
            new THREE.BoxGeometry(w * 0.8, 0.05, mwDepth * 0.5),
            mwVentMat
          );
          mwVent.position.set(0, mwYOffset - mwHeight/2 - 0.03, mwDepth/2 - d/2);
          group.add(mwVent);

          // Vent grille lines
          for (let i = 0; i < 6; i++) {
            const grilleLine = new THREE.Mesh(
              new THREE.BoxGeometry(w * 0.7, 0.01, 0.01),
              mwVentMat
            );
            grilleLine.position.set(0, mwYOffset - mwHeight/2 - 0.01, mwDepth * 0.2 + i * (mwDepth * 0.4 / 6) - d/2);
            group.add(grilleLine);
          }

          // Light under microwave (illuminates cooktop below)
          const lightMat = new THREE.MeshStandardMaterial({
            color: 0xffffcc,
            emissive: 0xffffaa,
            emissiveIntensity: 0.2,
            transparent: true,
            opacity: 0.8
          });
          const mwLight = new THREE.Mesh(
            new THREE.BoxGeometry(w * 0.5, 0.02, 0.15),
            lightMat
          );
          mwLight.position.set(0, mwYOffset - mwHeight/2 - 0.06, mwDepth * 0.3 - d/2);
          group.add(mwLight);

          break;
        }

        case 'refrigerator': {
          // French door refrigerator
          const fridgeMat = new THREE.MeshStandardMaterial({
            color: 0xD5D5D5,
            roughness: 0.25,
            metalness: 0.55
          });

          // Main body
          const fridgeBody = new THREE.Mesh(
            new THREE.BoxGeometry(w, h, d),
            fridgeMat
          );
          group.add(fridgeBody);

          // Upper doors (French style - two doors)
          const doorMat = new THREE.MeshStandardMaterial({
            color: 0xE0E0E0,
            roughness: 0.2,
            metalness: 0.6
          });

          const upperDoorH = h * 0.65;
          const doorW = (w - 0.15) / 2;

          // Left upper door
          const leftDoor = new THREE.Mesh(
            new THREE.BoxGeometry(doorW, upperDoorH, 0.04),
            doorMat
          );
          leftDoor.position.set(-doorW/2 - 0.02, h * 0.15, d/2 + 0.02);
          group.add(leftDoor);

          // Right upper door
          const rightDoor = new THREE.Mesh(
            new THREE.BoxGeometry(doorW, upperDoorH, 0.04),
            doorMat
          );
          rightDoor.position.set(doorW/2 + 0.02, h * 0.15, d/2 + 0.02);
          group.add(rightDoor);

          // Freezer drawer
          const freezerDrawer = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.12, h * 0.28, 0.04),
            doorMat
          );
          freezerDrawer.position.set(0, -h * 0.33, d/2 + 0.02);
          group.add(freezerDrawer);

          // Handles
          const handleMat = new THREE.MeshStandardMaterial({
            color: 0xA0A0A0,
            roughness: 0.15,
            metalness: 0.9
          });

          // Left handle
          const leftHandle = new THREE.Mesh(
            new THREE.BoxGeometry(0.04, 0.7, 0.06),
            handleMat
          );
          leftHandle.position.set(-0.08, h * 0.15, d/2 + 0.08);
          group.add(leftHandle);

          // Right handle
          const rightHandle = new THREE.Mesh(
            new THREE.BoxGeometry(0.04, 0.7, 0.06),
            handleMat
          );
          rightHandle.position.set(0.08, h * 0.15, d/2 + 0.08);
          group.add(rightHandle);

          // Freezer handle
          const freezerHandle = new THREE.Mesh(
            new THREE.BoxGeometry(w * 0.6, 0.04, 0.06),
            handleMat
          );
          freezerHandle.position.set(0, -h * 0.2, d/2 + 0.08);
          group.add(freezerHandle);

          // Water/ice dispenser
          const dispenserMat = new THREE.MeshStandardMaterial({
            color: 0x2a2a2a,
            roughness: 0.3
          });
          const dispenser = new THREE.Mesh(
            new THREE.BoxGeometry(0.3, 0.25, 0.02),
            dispenserMat
          );
          dispenser.position.set(0, h * 0.25, d/2 + 0.05);
          group.add(dispenser);
          break;
        }

        case 'dishwasher': {
          // Built-in dishwasher
          const dwMat = new THREE.MeshStandardMaterial({
            color: 0xD0D0D0,
            roughness: 0.25,
            metalness: 0.55
          });

          const dwBody = new THREE.Mesh(
            new THREE.BoxGeometry(w, h, d),
            dwMat
          );
          group.add(dwBody);

          // Control panel
          const dwPanel = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.1, 0.25, 0.02),
            new THREE.MeshStandardMaterial({ color: 0x404040 })
          );
          dwPanel.position.set(0, h/2 - 0.2, d/2 + 0.02);
          group.add(dwPanel);

          // Handle
          const dwHandle = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.4, 0.05, 0.08),
            new THREE.MeshStandardMaterial({ color: 0x808080, metalness: 0.8 })
          );
          dwHandle.position.set(0, h/2 - 0.45, d/2 + 0.06);
          group.add(dwHandle);
          break;
        }

        case 'microwave': {
          // Over-the-range microwave in open-face cabinet box
          // Cabinet box dimensions slightly larger than microwave
          const mwCabinetPadding = 0.05; // 0.6" padding around microwave
          const mwCabinetW = w + mwCabinetPadding * 2;
          const mwCabinetH = h + mwCabinetPadding;
          const mwCabinetD = d + mwCabinetPadding;

          // Get wood texture for cabinet box
          const mwCabFinish = el.cabinetFinish || 'wood-grain';
          const mwCabGrainType = el.grainType || 'oak';
          let mwCabTexture = null;
          let mwCabRoughness = 0.35;

          // Check for custom texture first
          if (textureUrl) {
            const textureLoader = new THREE.TextureLoader();
            try {
              mwCabTexture = textureLoader.load(textureUrl);
              mwCabTexture.wrapS = THREE.RepeatWrapping;
              mwCabTexture.wrapT = THREE.RepeatWrapping;
              mwCabTexture.repeat.set(2, 2);
            } catch (e) {
              mwCabTexture = createWoodGrainTexture(color, 0.12, mwCabGrainType);
            }
            mwCabRoughness = 0.3;
          } else if (mwCabFinish === 'wood-grain') {
            mwCabTexture = createWoodGrainTexture(color, 0.12, mwCabGrainType);
            mwCabRoughness = 0.3;
          } else if (mwCabFinish === 'painted' || mwCabFinish === 'matte' || mwCabFinish === 'gloss') {
            mwCabTexture = createWoodGrainTexture(color, 0.03, 'flat');
            mwCabRoughness = mwCabFinish === 'gloss' ? 0.1 : (mwCabFinish === 'matte' ? 0.7 : 0.4);
          }

          const mwCabMat = new THREE.MeshStandardMaterial({
            color: color,
            map: mwCabTexture,
            roughness: mwCabRoughness,
            metalness: 0.02
          });

          const mwBodyMat = new THREE.MeshStandardMaterial({ color: 0x2a2a2a, roughness: 0.8 });

          // Cabinet box - open front (no door)
          // Top panel
          const mwCabTop = new THREE.Mesh(
            new THREE.BoxGeometry(mwCabinetW, 0.04, mwCabinetD),
            mwCabMat
          );
          mwCabTop.position.set(0, mwCabinetH / 2 - 0.02, 0);
          group.add(mwCabTop);

          // Bottom panel
          const mwCabBottom = new THREE.Mesh(
            new THREE.BoxGeometry(mwCabinetW, 0.04, mwCabinetD),
            mwCabMat
          );
          mwCabBottom.position.set(0, -mwCabinetH / 2 + 0.02, 0);
          group.add(mwCabBottom);

          // Left side panel
          const mwCabLeft = new THREE.Mesh(
            new THREE.BoxGeometry(0.04, mwCabinetH, mwCabinetD),
            mwCabMat
          );
          mwCabLeft.position.set(-mwCabinetW / 2 + 0.02, 0, 0);
          group.add(mwCabLeft);

          // Right side panel
          const mwCabRight = new THREE.Mesh(
            new THREE.BoxGeometry(0.04, mwCabinetH, mwCabinetD),
            mwCabMat
          );
          mwCabRight.position.set(mwCabinetW / 2 - 0.02, 0, 0);
          group.add(mwCabRight);

          // Back panel
          const mwCabBack = new THREE.Mesh(
            new THREE.BoxGeometry(mwCabinetW - 0.08, mwCabinetH - 0.08, 0.03),
            mwBodyMat
          );
          mwCabBack.position.set(0, 0, -mwCabinetD / 2 + 0.02);
          group.add(mwCabBack);

          // Microwave body (inside cabinet)
          const mwMat = new THREE.MeshStandardMaterial({ color: 0x3a3a3a, roughness: 0.4, metalness: 0.3 });
          const mwBody = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), mwMat);
          mwBody.position.set(0, -mwCabinetPadding / 2, mwCabinetPadding / 2);
          group.add(mwBody);

          // Glass door
          const mwGlass = new THREE.Mesh(
            new THREE.BoxGeometry(w * 0.6, h - 0.15, 0.02),
            new THREE.MeshStandardMaterial({ color: 0x111111, transparent: true, opacity: 0.8, roughness: 0.1 })
          );
          mwGlass.position.set(-w * 0.15, -mwCabinetPadding / 2, d / 2 + 0.02 + mwCabinetPadding / 2);
          group.add(mwGlass);

          // Control panel
          const mwCtrlMat = new THREE.MeshStandardMaterial({ color: 0x2a2a2a, roughness: 0.3, metalness: 0.2 });
          const mwCtrl = new THREE.Mesh(
            new THREE.BoxGeometry(w * 0.25, h - 0.15, 0.02),
            mwCtrlMat
          );
          mwCtrl.position.set(w * 0.32, -mwCabinetPadding / 2, d / 2 + 0.02 + mwCabinetPadding / 2);
          group.add(mwCtrl);

          // Control buttons
          const mwBtnMat = new THREE.MeshStandardMaterial({ color: 0x555555, roughness: 0.5 });
          for (let i = 0; i < 3; i++) {
            for (let j = 0; j < 3; j++) {
              const btn = new THREE.Mesh(
                new THREE.BoxGeometry(0.04, 0.04, 0.01),
                mwBtnMat
              );
              btn.position.set(
                w * 0.28 + j * 0.06,
                h * 0.2 - i * 0.08 - mwCabinetPadding / 2,
                d / 2 + 0.04 + mwCabinetPadding / 2
              );
              group.add(btn);
            }
          }

          // Digital display
          const mwDisplayMat = new THREE.MeshStandardMaterial({
            color: 0x00ff00,
            emissive: 0x00ff00,
            emissiveIntensity: 0.3,
            roughness: 0.2
          });
          const mwDisplay = new THREE.Mesh(
            new THREE.BoxGeometry(0.12, 0.04, 0.01),
            mwDisplayMat
          );
          mwDisplay.position.set(w * 0.32, h * 0.35 - mwCabinetPadding / 2, d / 2 + 0.04 + mwCabinetPadding / 2);
          group.add(mwDisplay);

          // Handle
          const mwHandleMat = new THREE.MeshStandardMaterial({ color: 0x888888, metalness: 0.8, roughness: 0.2 });
          const mwHandle = new THREE.Mesh(
            new THREE.BoxGeometry(0.03, h * 0.4, 0.03),
            mwHandleMat
          );
          mwHandle.position.set(-w * 0.42, -mwCabinetPadding / 2, d / 2 + 0.06 + mwCabinetPadding / 2);
          group.add(mwHandle);

          // Vent at bottom (over-the-range feature)
          const mwVentMat = new THREE.MeshStandardMaterial({ color: 0x4a4a4a, roughness: 0.6 });
          const mwVent = new THREE.Mesh(
            new THREE.BoxGeometry(w * 0.8, 0.05, d * 0.6),
            mwVentMat
          );
          mwVent.position.set(0, -h / 2 - 0.03 - mwCabinetPadding / 2, 0);
          group.add(mwVent);

          // Vent grille lines
          for (let i = 0; i < 8; i++) {
            const grilleLine = new THREE.Mesh(
              new THREE.BoxGeometry(w * 0.7, 0.01, 0.01),
              mwVentMat
            );
            grilleLine.position.set(0, -h / 2 - 0.01 - mwCabinetPadding / 2, -d * 0.25 + i * (d * 0.5 / 8));
            group.add(grilleLine);
          }
          break;
        }

        case 'range-hood':
          // Trapezoidal range hood
          const hoodMat = new THREE.MeshStandardMaterial({ color: 0x808080, metalness: 0.6, roughness: 0.3 });
          const hoodShape = new THREE.Shape();
          hoodShape.moveTo(-w/2, 0);
          hoodShape.lineTo(-w/3, h);
          hoodShape.lineTo(w/3, h);
          hoodShape.lineTo(w/2, 0);
          hoodShape.closePath();

          const extrudeSettings = { depth: d, bevelEnabled: false };
          const hoodGeom = new THREE.ExtrudeGeometry(hoodShape, extrudeSettings);
          hoodGeom.rotateX(Math.PI / 2);
          hoodGeom.translate(0, h/2, -d/2);
          const hood = new THREE.Mesh(hoodGeom, hoodMat);
          group.add(hood);
          break;

        case 'oven':
          const ovenMat = new THREE.MeshStandardMaterial({ color: 0x2a2a2a, roughness: 0.3, metalness: 0.4 });
          const ovenBody = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), ovenMat);
          group.add(ovenBody);

          // Glass door
          const ovenGlass = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.2, h * 0.6, 0.02),
            new THREE.MeshStandardMaterial({ color: 0x1a1a1a, transparent: true, opacity: 0.7 })
          );
          ovenGlass.position.set(0, -h * 0.1, d/2 + 0.02);
          group.add(ovenGlass);

          // Handle
          const ovenHandle = new THREE.Mesh(
            new THREE.BoxGeometry(w * 0.6, 0.05, 0.1),
            new THREE.MeshStandardMaterial({ color: 0xA0A0A0, metalness: 0.7 })
          );
          ovenHandle.position.set(0, h * 0.3, d/2 + 0.08);
          group.add(ovenHandle);
          break;

        case 'door': {
          // Standard interior/exterior door with full frame
          // Construction-standard dimensions
          const doorColor = el.color ? parseInt(el.color.replace('#', ''), 16) : 0xDEB887;
          const doorMat2 = new THREE.MeshStandardMaterial({ color: doorColor, roughness: 0.6 });
          const doorFrameMat = new THREE.MeshStandardMaterial({ color: 0xF5F5F0, roughness: 0.45 });
          const dFrameW = 0.17;  // ~2" casing face width
          const dFrameD = 0.33;  // ~4" frame depth (wall depth)
          const dPanelD = 0.15;  // ~1.75" door slab thickness

          // Door panel (slab)
          const doorPanel = new THREE.Mesh(
            new THREE.BoxGeometry(w - dFrameW * 2, h - dFrameW, dPanelD),
            doorMat2
          );
          doorPanel.position.set(0, -dFrameW / 2, 0);
          doorPanel.castShadow = true;
          group.add(doorPanel);

          // Door panel detail (raised panel effect)
          const panelDetailMat = new THREE.MeshStandardMaterial({
            color: adjustColorBrightness(doorColor, -20),
            roughness: 0.5
          });
          const panelInset = new THREE.Mesh(
            new THREE.BoxGeometry(w * 0.55, h * 0.33, 0.02),
            panelDetailMat
          );
          panelInset.position.set(0, h * 0.15, dPanelD / 2 + 0.01);
          group.add(panelInset);

          const panelInset2 = new THREE.Mesh(
            new THREE.BoxGeometry(w * 0.55, h * 0.33, 0.02),
            panelDetailMat
          );
          panelInset2.position.set(0, -h * 0.25, dPanelD / 2 + 0.01);
          group.add(panelInset2);

          // Frame - head (top casing)
          const frameTop = new THREE.Mesh(
            new THREE.BoxGeometry(w + dFrameW * 2, dFrameW, dFrameD),
            doorFrameMat
          );
          frameTop.position.set(0, h / 2, 0);
          frameTop.castShadow = true;
          group.add(frameTop);

          // Frame - left jamb
          const frameLeft = new THREE.Mesh(
            new THREE.BoxGeometry(dFrameW, h, dFrameD),
            doorFrameMat
          );
          frameLeft.position.set(-w / 2 - dFrameW / 2, 0, 0);
          frameLeft.castShadow = true;
          group.add(frameLeft);

          // Frame - right jamb
          const frameRight = new THREE.Mesh(
            new THREE.BoxGeometry(dFrameW, h, dFrameD),
            doorFrameMat
          );
          frameRight.position.set(w / 2 + dFrameW / 2, 0, 0);
          frameRight.castShadow = true;
          group.add(frameRight);

          // Threshold
          const thresholdMat = new THREE.MeshStandardMaterial({ color: 0x8B7355, roughness: 0.6 });
          const threshold = new THREE.Mesh(
            new THREE.BoxGeometry(w, 0.06, dFrameD + 0.05),
            thresholdMat
          );
          threshold.position.set(0, -h / 2 + 0.03, 0.025);
          group.add(threshold);

          // Door handle (lever style)
          const handleMat = new THREE.MeshStandardMaterial({
            color: 0xC0C0C0,
            metalness: 0.8,
            roughness: 0.2
          });

          // Handle plate (escutcheon)
          const handlePlate = new THREE.Mesh(
            new THREE.BoxGeometry(0.06, 0.18, 0.02),
            handleMat
          );
          handlePlate.position.set(w / 2 - 0.2, 0, dPanelD / 2 + 0.02);
          group.add(handlePlate);

          // Handle lever
          const handleLever = new THREE.Mesh(
            new THREE.BoxGeometry(0.14, 0.035, 0.035),
            handleMat
          );
          handleLever.position.set(w / 2 - 0.15, 0, dPanelD / 2 + 0.04);
          group.add(handleLever);

          break;
        }

        case 'window':
        case 'window-large':
        case 'bay-window':
        case 'picture-window': {
          // Professional Window with proper architectural details
          // Note: window-bay handled separately below with angled bay projection geometry
          // Supports: double-hung, single-hung, casement, sliding, fixed, picture
          // Picture windows and window-large default to fixed (single pane, no sashes)
          const isPictureType = el.type === 'picture-window' || el.type === 'window-large';
          const windowStyle = el.windowStyle || (isPictureType ? 'fixed' : 'double-hung');
          const mullionPattern = el.mullionPattern || (isPictureType ? 'none' : 'standard');
          const frameColor = el.frameColor ? parseInt(el.frameColor.replace('#', ''), 16) : 0x3D2B1F;

          // Standard window dimensions (IRC / AAMA construction standards)
          const frameThickness = 0.25; // ~3" frame depth (proper wall depth)
          const frameWidth = 0.2; // ~2.4" frame face width
          const sashWidth = 0.10; // ~1.2" sash profile
          const muntinWidth = 0.04; // ~0.5" muntin (grille) bars

          // Materials
          const frameMat = new THREE.MeshStandardMaterial({
            color: frameColor,
            roughness: 0.35,
            metalness: 0.15
          });
          const sashMat = new THREE.MeshStandardMaterial({
            color: frameColor,
            roughness: 0.4,
            metalness: 0.1
          });
          const muntinMat = new THREE.MeshStandardMaterial({
            color: frameColor,
            roughness: 0.45,
            metalness: 0.05
          });
          const hardwareMat = new THREE.MeshStandardMaterial({
            color: 0xC0C0C0,
            roughness: 0.2,
            metalness: 0.9
          });
          const weatherstripMat = new THREE.MeshStandardMaterial({
            color: 0x333333,
            roughness: 0.8
          });

          // === MAIN FRAME (Jamb, Head, Sill) ===
          // Head (top jamb)
          const headJamb = new THREE.Mesh(
            new THREE.BoxGeometry(w + 0.05, frameWidth, frameThickness),
            frameMat
          );
          headJamb.position.set(0, h/2 - frameWidth/2, 0);
          headJamb.castShadow = true;
          group.add(headJamb);

          // Side jambs
          [-1, 1].forEach(side => {
            const sideJamb = new THREE.Mesh(
              new THREE.BoxGeometry(frameWidth, h - frameWidth, frameThickness),
              frameMat
            );
            sideJamb.position.set(side * (w/2 - frameWidth/2), -frameWidth/2, 0);
            sideJamb.castShadow = true;
            group.add(sideJamb);
          });

          // Sill (sloped for water drainage)
          const sillHeight = frameWidth * 1.2;
          const sillDepth = frameThickness + 0.15;
          const sillMat = new THREE.MeshStandardMaterial({ color: 0xF5F5F0, roughness: 0.45 });
          const sill = new THREE.Mesh(
            new THREE.BoxGeometry(w + 0.2, sillHeight, sillDepth),
            sillMat
          );
          sill.position.set(0, -h/2 + sillHeight/2, sillDepth/2 - frameThickness/2);
          sill.castShadow = true;
          group.add(sill);

          // Sill nose (drip edge)
          const sillNose = new THREE.Mesh(
            new THREE.BoxGeometry(w + 0.22, 0.02, 0.03),
            sillMat
          );
          sillNose.position.set(0, -h/2 + 0.02, sillDepth - frameThickness/2 + 0.01);
          group.add(sillNose);

          // Calculate glass/sash area
          const openingWidth = w - frameWidth * 2;
          const openingHeight = h - frameWidth - sillHeight;
          const outdoorZ = -frameThickness/2 + 0.01;

          // === OUTDOOR VIEW ===
          const outdoorPalette = OUTDOOR_COLORS[sceneSettings.timeOfDay] || OUTDOOR_COLORS.noon;

          if (textureUrl) {
            const viewMat = createTexturedMaterial(0xFFFFFF, textureUrl, {
              roughness: 0.1,
              side: THREE.DoubleSide
            });
            const viewPane = new THREE.Mesh(
              new THREE.PlaneGeometry(openingWidth - 0.1, openingHeight - 0.1),
              viewMat
            );
            viewPane.position.set(0, (openingHeight - h)/2 + sillHeight/2, outdoorZ);
            group.add(viewPane);
          } else {
            // Sky
            const skyMat = new THREE.MeshBasicMaterial({ color: outdoorPalette.sky, side: THREE.DoubleSide });
            const skyPane = new THREE.Mesh(
              new THREE.PlaneGeometry(openingWidth - 0.05, openingHeight - 0.05),
              skyMat
            );
            skyPane.position.set(0, (openingHeight - h)/2 + sillHeight/2, outdoorZ);
            group.add(skyPane);

            // Horizon
            const horizonMat = new THREE.MeshBasicMaterial({ color: outdoorPalette.horizon });
            const horizonPane = new THREE.Mesh(
              new THREE.PlaneGeometry(openingWidth - 0.05, openingHeight * 0.35),
              horizonMat
            );
            horizonPane.position.set(0, -h/2 + sillHeight + openingHeight * 0.17, outdoorZ + 0.002);
            group.add(horizonPane);

            // Trees and sky elements
            if (sceneSettings.timeOfDay !== 'night') {
              const treeMat = new THREE.MeshBasicMaterial({ color: 0x228B22 });
              for (let t = 0; t < 3; t++) {
                const treeSize = 0.12 + Math.random() * 0.12;
                const tree = new THREE.Mesh(new THREE.ConeGeometry(treeSize, treeSize * 2, 6), treeMat);
                tree.position.set((t - 1) * openingWidth * 0.3, -h/2 + sillHeight + openingHeight * 0.25, outdoorZ + 0.005);
                group.add(tree);
              }
              if (sceneSettings.timeOfDay === 'noon') {
                const sunMat = new THREE.MeshBasicMaterial({ color: 0xFFFF99 });
                const sun = new THREE.Mesh(new THREE.CircleGeometry(0.12, 16), sunMat);
                sun.position.set(openingWidth * 0.25, h/2 - frameWidth - openingHeight * 0.25, outdoorZ + 0.003);
                group.add(sun);
              }
            } else {
              const starMat = new THREE.MeshBasicMaterial({ color: 0xFFFFFF });
              for (let i = 0; i < 10; i++) {
                const star = new THREE.Mesh(new THREE.SphereGeometry(0.015, 4, 4), starMat);
                star.position.set(
                  (Math.random() - 0.5) * openingWidth * 0.8,
                  h/2 - frameWidth - openingHeight * 0.3 - Math.random() * openingHeight * 0.4,
                  outdoorZ + 0.003
                );
                group.add(star);
              }
              const moonMat = new THREE.MeshBasicMaterial({ color: 0xFFFACD });
              const moon = new THREE.Mesh(new THREE.CircleGeometry(0.1, 16), moonMat);
              moon.position.set(openingWidth * 0.3, h/2 - frameWidth - openingHeight * 0.25, outdoorZ + 0.004);
              group.add(moon);
            }
          }

          // === SASH AND GLASS based on window style ===
          const glassColor = sceneSettings.timeOfDay === 'night' ? 0x2a3a5a : 0xADD8E6;
          const glassMat = new THREE.MeshStandardMaterial({
            color: glassColor,
            transparent: true,
            opacity: 0.12,
            roughness: 0.02,
            metalness: 0.35
          });

          // Function to create muntin/grille pattern
          const createMuntinPattern = (sashW, sashH, centerX, centerY, zPos) => {
            if (mullionPattern === 'none' || el.type === 'picture-window') return;

            const muntinGroup = new THREE.Group();

            if (mullionPattern === 'colonial') {
              // Colonial: 6 over 6 or 4 over 4 pattern
              const cols = sashW > 1.5 ? 3 : 2;
              const rows = sashH > 1.5 ? 3 : 2;

              // Vertical muntins
              for (let c = 1; c < cols; c++) {
                const vMuntin = new THREE.Mesh(
                  new THREE.BoxGeometry(muntinWidth, sashH - sashWidth * 2, muntinWidth),
                  muntinMat
                );
                vMuntin.position.set(centerX - sashW/2 + sashWidth + c * (sashW - sashWidth * 2) / cols, centerY, zPos + 0.02);
                muntinGroup.add(vMuntin);
              }

              // Horizontal muntins
              for (let r = 1; r < rows; r++) {
                const hMuntin = new THREE.Mesh(
                  new THREE.BoxGeometry(sashW - sashWidth * 2, muntinWidth, muntinWidth),
                  muntinMat
                );
                hMuntin.position.set(centerX, centerY - sashH/2 + sashWidth + r * (sashH - sashWidth * 2) / rows, zPos + 0.02);
                muntinGroup.add(hMuntin);
              }
            } else if (mullionPattern === 'prairie') {
              // Prairie: border pattern with clear center
              const borderInset = Math.min(sashW, sashH) * 0.2;

              // Inner frame
              const borderW = sashW - sashWidth * 2 - borderInset * 2;
              const borderH = sashH - sashWidth * 2 - borderInset * 2;

              // Top border line
              const topBorder = new THREE.Mesh(
                new THREE.BoxGeometry(sashW - sashWidth * 2, muntinWidth, muntinWidth),
                muntinMat
              );
              topBorder.position.set(centerX, centerY + borderH/2 + borderInset/2, zPos + 0.02);
              muntinGroup.add(topBorder);

              // Bottom border line
              const botBorder = new THREE.Mesh(
                new THREE.BoxGeometry(sashW - sashWidth * 2, muntinWidth, muntinWidth),
                muntinMat
              );
              botBorder.position.set(centerX, centerY - borderH/2 - borderInset/2, zPos + 0.02);
              muntinGroup.add(botBorder);

              // Side border lines
              [-1, 1].forEach(side => {
                const sideBorder = new THREE.Mesh(
                  new THREE.BoxGeometry(muntinWidth, sashH - sashWidth * 2, muntinWidth),
                  muntinMat
                );
                sideBorder.position.set(centerX + side * (borderW/2 + borderInset/2), centerY, zPos + 0.02);
                muntinGroup.add(sideBorder);
              });
            } else {
              // Standard: single cross divider
              const vMuntin = new THREE.Mesh(
                new THREE.BoxGeometry(muntinWidth * 1.5, sashH - sashWidth * 2, muntinWidth * 1.5),
                muntinMat
              );
              vMuntin.position.set(centerX, centerY, zPos + 0.02);
              muntinGroup.add(vMuntin);
            }

            group.add(muntinGroup);
          };

          if (windowStyle === 'double-hung' || windowStyle === 'single-hung') {
            // Two sashes - upper and lower
            const sashH = (openingHeight - 0.02) / 2;
            const upperSashY = h/2 - frameWidth - sashH/2;
            const lowerSashY = -h/2 + sillHeight + sashH/2;

            // Upper sash (fixed in single-hung, operable in double-hung)
            const upperSashGroup = new THREE.Group();

            // Upper sash frame
            const upperTop = new THREE.Mesh(new THREE.BoxGeometry(openingWidth, sashWidth, frameThickness * 0.6), sashMat);
            upperTop.position.set(0, sashH/2 - sashWidth/2, 0);
            upperSashGroup.add(upperTop);

            const upperBot = new THREE.Mesh(new THREE.BoxGeometry(openingWidth, sashWidth, frameThickness * 0.6), sashMat);
            upperBot.position.set(0, -sashH/2 + sashWidth/2, 0);
            upperSashGroup.add(upperBot);

            [-1, 1].forEach(side => {
              const upperSide = new THREE.Mesh(new THREE.BoxGeometry(sashWidth, sashH, frameThickness * 0.6), sashMat);
              upperSide.position.set(side * (openingWidth/2 - sashWidth/2), 0, 0);
              upperSashGroup.add(upperSide);
            });

            // Upper glass
            const upperGlass = new THREE.Mesh(
              new THREE.PlaneGeometry(openingWidth - sashWidth * 2 - 0.02, sashH - sashWidth * 2 - 0.02),
              glassMat
            );
            upperGlass.position.z = 0.02;
            upperSashGroup.add(upperGlass);

            upperSashGroup.position.set(0, upperSashY, -0.01);
            group.add(upperSashGroup);
            createMuntinPattern(openingWidth, sashH, 0, upperSashY, -0.01);

            // Lower sash (always operable)
            const lowerSashGroup = new THREE.Group();

            const lowerTop = new THREE.Mesh(new THREE.BoxGeometry(openingWidth, sashWidth, frameThickness * 0.6), sashMat);
            lowerTop.position.set(0, sashH/2 - sashWidth/2, 0);
            lowerSashGroup.add(lowerTop);

            const lowerBot = new THREE.Mesh(new THREE.BoxGeometry(openingWidth, sashWidth, frameThickness * 0.6), sashMat);
            lowerBot.position.set(0, -sashH/2 + sashWidth/2, 0);
            lowerSashGroup.add(lowerBot);

            [-1, 1].forEach(side => {
              const lowerSide = new THREE.Mesh(new THREE.BoxGeometry(sashWidth, sashH, frameThickness * 0.6), sashMat);
              lowerSide.position.set(side * (openingWidth/2 - sashWidth/2), 0, 0);
              lowerSashGroup.add(lowerSide);
            });

            // Lower glass
            const lowerGlass = new THREE.Mesh(
              new THREE.PlaneGeometry(openingWidth - sashWidth * 2 - 0.02, sashH - sashWidth * 2 - 0.02),
              glassMat
            );
            lowerGlass.position.z = 0.02;
            lowerSashGroup.add(lowerGlass);

            lowerSashGroup.position.set(0, lowerSashY, 0.02);
            group.add(lowerSashGroup);
            createMuntinPattern(openingWidth, sashH, 0, lowerSashY, 0.02);

            // Meeting rail (where sashes overlap)
            const meetingRail = new THREE.Mesh(
              new THREE.BoxGeometry(openingWidth, sashWidth * 0.6, frameThickness * 0.3),
              sashMat
            );
            meetingRail.position.set(0, (upperSashY + lowerSashY) / 2, 0.02);
            group.add(meetingRail);

            // Window lock (at meeting rail)
            const lockBase = new THREE.Mesh(
              new THREE.BoxGeometry(0.04, 0.025, 0.015),
              hardwareMat
            );
            lockBase.position.set(0, (upperSashY + lowerSashY) / 2 + 0.03, frameThickness/2 + 0.02);
            group.add(lockBase);

            const lockLever = new THREE.Mesh(
              new THREE.BoxGeometry(0.05, 0.015, 0.01),
              hardwareMat
            );
            lockLever.position.set(0.02, (upperSashY + lowerSashY) / 2 + 0.035, frameThickness/2 + 0.03);
            group.add(lockLever);

          } else if (windowStyle === 'casement') {
            // Side-hinged window with crank operator
            const sashGroup = new THREE.Group();

            // Sash frame (all 4 sides)
            const sashInnerW = openingWidth - 0.02;
            const sashInnerH = openingHeight - 0.02;

            const sTop = new THREE.Mesh(new THREE.BoxGeometry(sashInnerW, sashWidth, frameThickness * 0.5), sashMat);
            sTop.position.set(0, sashInnerH/2 - sashWidth/2, 0);
            sashGroup.add(sTop);

            const sBot = new THREE.Mesh(new THREE.BoxGeometry(sashInnerW, sashWidth, frameThickness * 0.5), sashMat);
            sBot.position.set(0, -sashInnerH/2 + sashWidth/2, 0);
            sashGroup.add(sBot);

            [-1, 1].forEach(side => {
              const sSide = new THREE.Mesh(new THREE.BoxGeometry(sashWidth, sashInnerH, frameThickness * 0.5), sashMat);
              sSide.position.set(side * (sashInnerW/2 - sashWidth/2), 0, 0);
              sashGroup.add(sSide);
            });

            // Glass
            const casementGlass = new THREE.Mesh(
              new THREE.PlaneGeometry(sashInnerW - sashWidth * 2 - 0.02, sashInnerH - sashWidth * 2 - 0.02),
              glassMat
            );
            casementGlass.position.z = 0.01;
            sashGroup.add(casementGlass);

            sashGroup.position.set(0, (openingHeight - h)/2 + sillHeight/2, 0.01);
            group.add(sashGroup);

            createMuntinPattern(sashInnerW, sashInnerH, 0, (openingHeight - h)/2 + sillHeight/2, 0.01);

            // Hinges (on one side)
            [0.25, 0.75].forEach(hPos => {
              const hinge = new THREE.Mesh(
                new THREE.BoxGeometry(0.02, 0.08, 0.025),
                hardwareMat
              );
              hinge.position.set(-openingWidth/2 + 0.02, -h/2 + sillHeight + openingHeight * hPos, frameThickness/2);
              group.add(hinge);
            });

            // Crank operator (at bottom)
            const crankBase = new THREE.Mesh(
              new THREE.BoxGeometry(0.06, 0.03, 0.02),
              hardwareMat
            );
            crankBase.position.set(openingWidth/4, -h/2 + sillHeight + 0.15, frameThickness/2 + 0.02);
            group.add(crankBase);

            const crankHandle = new THREE.Mesh(
              new THREE.CylinderGeometry(0.008, 0.008, 0.08, 8),
              hardwareMat
            );
            crankHandle.rotation.z = Math.PI / 2;
            crankHandle.position.set(openingWidth/4 + 0.04, -h/2 + sillHeight + 0.15, frameThickness/2 + 0.03);
            group.add(crankHandle);

          } else if (windowStyle === 'sliding') {
            // Two panels, one slides horizontally
            const panelW = (openingWidth + 0.02) / 2;

            // Fixed panel (left)
            const fixedPanel = new THREE.Group();

            const fTop = new THREE.Mesh(new THREE.BoxGeometry(panelW, sashWidth, frameThickness * 0.5), sashMat);
            fTop.position.set(0, openingHeight/2 - sashWidth/2, 0);
            fixedPanel.add(fTop);

            const fBot = new THREE.Mesh(new THREE.BoxGeometry(panelW, sashWidth, frameThickness * 0.5), sashMat);
            fBot.position.set(0, -openingHeight/2 + sashWidth/2, 0);
            fixedPanel.add(fBot);

            [-1, 1].forEach(side => {
              const fSide = new THREE.Mesh(new THREE.BoxGeometry(sashWidth, openingHeight, frameThickness * 0.5), sashMat);
              fSide.position.set(side * (panelW/2 - sashWidth/2), 0, 0);
              fixedPanel.add(fSide);
            });

            const fGlass = new THREE.Mesh(
              new THREE.PlaneGeometry(panelW - sashWidth * 2 - 0.02, openingHeight - sashWidth * 2 - 0.02),
              glassMat
            );
            fGlass.position.z = 0.01;
            fixedPanel.add(fGlass);

            fixedPanel.position.set(-panelW/2 + 0.01, (openingHeight - h)/2 + sillHeight/2, -0.01);
            group.add(fixedPanel);

            // Sliding panel (right, in front)
            const slidePanel = new THREE.Group();

            const sTop = new THREE.Mesh(new THREE.BoxGeometry(panelW, sashWidth, frameThickness * 0.5), sashMat);
            sTop.position.set(0, openingHeight/2 - sashWidth/2, 0);
            slidePanel.add(sTop);

            const sBot = new THREE.Mesh(new THREE.BoxGeometry(panelW, sashWidth, frameThickness * 0.5), sashMat);
            sBot.position.set(0, -openingHeight/2 + sashWidth/2, 0);
            slidePanel.add(sBot);

            [-1, 1].forEach(side => {
              const sSide = new THREE.Mesh(new THREE.BoxGeometry(sashWidth, openingHeight, frameThickness * 0.5), sashMat);
              sSide.position.set(side * (panelW/2 - sashWidth/2), 0, 0);
              slidePanel.add(sSide);
            });

            const sGlass = new THREE.Mesh(
              new THREE.PlaneGeometry(panelW - sashWidth * 2 - 0.02, openingHeight - sashWidth * 2 - 0.02),
              glassMat
            );
            sGlass.position.z = 0.01;
            slidePanel.add(sGlass);

            slidePanel.position.set(panelW/2 - 0.01, (openingHeight - h)/2 + sillHeight/2, 0.02);
            group.add(slidePanel);

            // Track (top and bottom)
            const trackMat = new THREE.MeshStandardMaterial({ color: 0x666666, roughness: 0.4, metalness: 0.5 });

            const topTrack = new THREE.Mesh(
              new THREE.BoxGeometry(openingWidth, 0.02, frameThickness * 0.4),
              trackMat
            );
            topTrack.position.set(0, h/2 - frameWidth - 0.01, 0);
            group.add(topTrack);

            const botTrack = new THREE.Mesh(
              new THREE.BoxGeometry(openingWidth, 0.02, frameThickness * 0.4),
              trackMat
            );
            botTrack.position.set(0, -h/2 + sillHeight + 0.01, 0);
            group.add(botTrack);

            // Sliding latch
            const latch = new THREE.Mesh(
              new THREE.BoxGeometry(0.04, 0.06, 0.015),
              hardwareMat
            );
            latch.position.set(panelW - sashWidth, (openingHeight - h)/2 + sillHeight/2, frameThickness/2 + 0.02);
            group.add(latch);

          } else {
            // Fixed/picture window - single pane, no operable hardware
            const fixedGlass = new THREE.Mesh(
              new THREE.PlaneGeometry(openingWidth - 0.05, openingHeight - 0.05),
              glassMat
            );
            fixedGlass.position.set(0, (openingHeight - h)/2 + sillHeight/2, 0.01);
            group.add(fixedGlass);

            // Simple glazing bead around glass
            const beadMat = new THREE.MeshStandardMaterial({ color: frameColor, roughness: 0.5 });
            const beadW = 0.025;

            const topBead = new THREE.Mesh(new THREE.BoxGeometry(openingWidth, beadW, beadW), beadMat);
            topBead.position.set(0, h/2 - frameWidth - beadW/2, 0.02);
            group.add(topBead);

            const botBead = new THREE.Mesh(new THREE.BoxGeometry(openingWidth, beadW, beadW), beadMat);
            botBead.position.set(0, -h/2 + sillHeight + beadW/2, 0.02);
            group.add(botBead);

            [-1, 1].forEach(side => {
              const sideBead = new THREE.Mesh(new THREE.BoxGeometry(beadW, openingHeight, beadW), beadMat);
              sideBead.position.set(side * (openingWidth/2 - beadW/2), (openingHeight - h)/2 + sillHeight/2, 0.02);
              group.add(sideBead);
            });
          }

          // === INTERIOR TRIM (Casing) ===
          const trimMat = new THREE.MeshStandardMaterial({ color: 0xF0EDE8, roughness: 0.55 });
          const casingWidth = 0.09; // 2.25" trim
          const casingThick = 0.02; // 1/2" proud of wall

          // Head casing (with decorative profile)
          const headCasing = new THREE.Mesh(
            new THREE.BoxGeometry(w + casingWidth * 2, casingWidth, casingThick),
            trimMat
          );
          headCasing.position.set(0, h/2 + casingWidth/2, frameThickness/2 + casingThick/2);
          group.add(headCasing);

          // Head casing cap (crown detail)
          const headCap = new THREE.Mesh(
            new THREE.BoxGeometry(w + casingWidth * 2 + 0.02, 0.015, casingThick + 0.01),
            trimMat
          );
          headCap.position.set(0, h/2 + casingWidth, frameThickness/2 + casingThick/2);
          group.add(headCap);

          // Side casings
          [-1, 1].forEach(side => {
            const sideCasing = new THREE.Mesh(
              new THREE.BoxGeometry(casingWidth, h + casingWidth, casingThick),
              trimMat
            );
            sideCasing.position.set(side * (w/2 + casingWidth/2), -casingWidth/2, frameThickness/2 + casingThick/2);
            group.add(sideCasing);
          });

          // Stool (interior sill extension)
          const stoolMat = new THREE.MeshStandardMaterial({ color: 0xFAF8F5, roughness: 0.4 });
          const stool = new THREE.Mesh(
            new THREE.BoxGeometry(w + casingWidth * 2 + 0.05, 0.025, 0.12),
            stoolMat
          );
          stool.position.set(0, -h/2 + sillHeight * 0.5, frameThickness/2 + 0.05);
          group.add(stool);

          // Apron (trim below stool)
          const apron = new THREE.Mesh(
            new THREE.BoxGeometry(w + casingWidth * 2, casingWidth * 0.6, casingThick),
            trimMat
          );
          apron.position.set(0, -h/2 + sillHeight * 0.5 - casingWidth * 0.35, frameThickness/2 + casingThick/2);
          group.add(apron);

          break;
        }

        case 'wall': {
          // Wall segment (drywall)
          // In 2D: width is the thin dimension (thickness), height is the long dimension (length)
          // Need to handle both horizontal and vertical walls
          const rotation = el.rotation || 0;
          const isVertical = rotation === 90 || rotation === 270 || rotation === -90;

          // Determine wall dimensions based on orientation
          let wallLength, wallThickness;
          if (isVertical) {
            // Wall runs along Z axis (top-to-bottom in 2D = into room in 3D)
            wallLength = d;  // The 2D height = wall length
            wallThickness = Math.max(w, 0.35);
          } else {
            // Wall runs along X axis (left-to-right in 2D)
            wallLength = w > d ? w : d;  // Use larger dimension as length
            wallThickness = Math.max(w < d ? w : d, 0.35);
          }

          const wallMat = new THREE.MeshStandardMaterial({
            color: el.color ? parseInt(el.color.replace('#', '0x')) : 0xF5F5DC,
            roughness: 0.8,
            side: THREE.DoubleSide
          });

          // Create wall mesh - length along X, height along Y, thickness along Z
          const wallMesh = new THREE.Mesh(
            new THREE.BoxGeometry(wallLength, h, wallThickness),
            wallMat
          );
          wallMesh.castShadow = true;
          wallMesh.receiveShadow = true;

          // Rotate for vertical walls
          if (isVertical) {
            wallMesh.rotation.y = Math.PI / 2;
          }

          group.add(wallMesh);
          break;
        }

        case 'wall-wood-2x4':
        case 'wall-wood-2x6': {
          // Wood framed wall
          const woodColor = el.type.includes('2x4') ? 0xDEB887 : 0xCD853F;
          const studWidth = el.type.includes('2x4') ? 0.1 : 0.15;
          const woodMat = new THREE.MeshStandardMaterial({ color: woodColor, roughness: 0.7 });

          // Studs (vertical)
          const studSpacing = 1.33; // 16" on center
          for (let sx = -w/2 + studSpacing/2; sx <= w/2; sx += studSpacing) {
            const stud = new THREE.Mesh(
              new THREE.BoxGeometry(studWidth, h - 0.2, d * 0.8),
              woodMat
            );
            stud.position.set(sx, 0, 0);
            group.add(stud);
          }

          // Top and bottom plates
          const plateMat = new THREE.MeshStandardMaterial({ color: woodColor, roughness: 0.6 });
          const topPlate = new THREE.Mesh(new THREE.BoxGeometry(w, 0.1, d * 0.8), plateMat);
          topPlate.position.y = h/2 - 0.05;
          group.add(topPlate);

          const botPlate = new THREE.Mesh(new THREE.BoxGeometry(w, 0.1, d * 0.8), plateMat);
          botPlate.position.y = -h/2 + 0.05;
          group.add(botPlate);
          break;
        }

        case 'wall-steel':
        case 'wall-aluminum': {
          // Metal stud wall
          const metalColor = el.type.includes('steel') ? 0x708090 : 0xC0C0C0;
          const metalMat = new THREE.MeshStandardMaterial({
            color: metalColor,
            roughness: 0.3,
            metalness: 0.7
          });

          // C-channel studs
          const studSpacing = 1.33;
          for (let sx = -w/2 + studSpacing/2; sx <= w/2; sx += studSpacing) {
            const stud = new THREE.Mesh(
              new THREE.BoxGeometry(0.05, h - 0.15, d * 0.7),
              metalMat
            );
            stud.position.set(sx, 0, 0);
            group.add(stud);
          }

          // Track (top and bottom)
          const trackMat = new THREE.MeshStandardMaterial({
            color: metalColor,
            roughness: 0.25,
            metalness: 0.8
          });
          const topTrack = new THREE.Mesh(new THREE.BoxGeometry(w, 0.08, d * 0.8), trackMat);
          topTrack.position.y = h/2 - 0.04;
          group.add(topTrack);

          const botTrack = new THREE.Mesh(new THREE.BoxGeometry(w, 0.08, d * 0.8), trackMat);
          botTrack.position.y = -h/2 + 0.04;
          group.add(botTrack);
          break;
        }

        case 'wall-concrete': {
          // Poured Concrete Wall with realistic form details
          // Features: form tie holes, construction joints, panel lines

          const concreteColor = el.color ? parseInt(el.color.replace('#', ''), 16) : 0x8C8C8C;

          // Main concrete material with slight roughness variation
          const concreteMat = new THREE.MeshStandardMaterial({
            color: concreteColor,
            roughness: 0.92,
            metalness: 0.02
          });

          // Darker concrete for recesses
          const concreteRecessMat = new THREE.MeshStandardMaterial({
            color: adjustColorBrightness(concreteColor, -20),
            roughness: 0.95,
            metalness: 0
          });

          // Form tie hole material (rust-stained)
          const tieHoleMat = new THREE.MeshStandardMaterial({
            color: 0x5C4033,
            roughness: 0.85,
            metalness: 0.1
          });

          // Base concrete wall
          const concreteWall = new THREE.Mesh(
            new THREE.BoxGeometry(w, h, d),
            concreteMat
          );
          concreteWall.castShadow = true;
          concreteWall.receiveShadow = true;
          group.add(concreteWall);

          // Form panel lines (typical 4' x 8' panels)
          const panelWidth = 4;  // 4 feet wide panels
          const panelHeight = 8; // 8 feet tall panels

          // Vertical panel joints
          const jointMat = new THREE.MeshStandardMaterial({
            color: adjustColorBrightness(concreteColor, -15),
            roughness: 0.9
          });

          for (let px = -w/2 + panelWidth; px < w/2; px += panelWidth) {
            const vJoint = new THREE.Mesh(
              new THREE.BoxGeometry(0.015, h, 0.02),
              jointMat
            );
            vJoint.position.set(px, 0, d/2 + 0.008);
            group.add(vJoint);
          }

          // Horizontal pour joints (every 8-10 feet typically)
          for (let py = -h/2 + panelHeight; py < h/2; py += panelHeight) {
            const hJoint = new THREE.Mesh(
              new THREE.BoxGeometry(w + 0.01, 0.02, 0.015),
              jointMat
            );
            hJoint.position.set(0, py, d/2 + 0.008);
            group.add(hJoint);
          }

          // Form tie holes - grid pattern (typically 2' horizontal x 2' vertical spacing)
          const tieSpacingH = 2;  // 2 feet horizontal
          const tieSpacingV = 2;  // 2 feet vertical
          const tieHoleRadius = 0.02; // ~1/2" diameter

          for (let ty = -h/2 + 1; ty < h/2 - 0.5; ty += tieSpacingV) {
            for (let tx = -w/2 + 1; tx < w/2 - 0.5; tx += tieSpacingH) {
              // Circular tie hole depression
              const tieHole = new THREE.Mesh(
                new THREE.CylinderGeometry(tieHoleRadius, tieHoleRadius, 0.03, 8),
                tieHoleMat
              );
              tieHole.rotation.x = Math.PI / 2;
              tieHole.position.set(tx, ty, d/2 + 0.01);
              group.add(tieHole);

              // Rust stain below tie hole
              const rustStain = new THREE.Mesh(
                new THREE.BoxGeometry(0.015, 0.08, 0.005),
                new THREE.MeshStandardMaterial({
                  color: 0x6B4423,
                  transparent: true,
                  opacity: 0.4,
                  roughness: 1
                })
              );
              rustStain.position.set(tx, ty - 0.06, d/2 + 0.005);
              group.add(rustStain);
            }
          }

          // Subtle surface texture variation (aggregate shadow)
          const textureMat = new THREE.MeshStandardMaterial({
            color: adjustColorBrightness(concreteColor, -8),
            transparent: true,
            opacity: 0.3,
            roughness: 1
          });

          // Random aggregate spots
          for (let i = 0; i < Math.min(w * h * 2, 50); i++) {
            const spotX = (Math.random() - 0.5) * w * 0.9;
            const spotY = (Math.random() - 0.5) * h * 0.9;
            const spotSize = 0.02 + Math.random() * 0.03;

            const spot = new THREE.Mesh(
              new THREE.CircleGeometry(spotSize, 6),
              textureMat
            );
            spot.position.set(spotX, spotY, d/2 + 0.003);
            group.add(spot);
          }

          break;
        }

        case 'wall-brick': {
          // Brick Wall with realistic running bond pattern
          // Standard brick: 2.25" x 3.625" x 8" (0.1875' x 0.3' x 0.67')
          // With 3/8" mortar joints

          const brickHeight = 0.1875 + 0.03;  // 2.25" + mortar = ~3" courses
          const brickWidth = 0.67;             // 8" brick length
          const mortarJoint = 0.03;            // 3/8" mortar

          // Brick colors with variation for realism
          const brickBaseColor = el.color ? parseInt(el.color.replace('#', ''), 16) : 0xB22222;
          const brickColors = [
            brickBaseColor,
            adjustColorBrightness(brickBaseColor, 10),
            adjustColorBrightness(brickBaseColor, -10),
            adjustColorBrightness(brickBaseColor, 5),
            adjustColorBrightness(brickBaseColor, -15)
          ];

          // Create materials for each color variation
          const brickMats = brickColors.map(c => new THREE.MeshStandardMaterial({
            color: c,
            roughness: 0.88,
            metalness: 0.02
          }));

          // Mortar material
          const mortarMat = new THREE.MeshStandardMaterial({
            color: 0xC8C8C8,
            roughness: 0.85,
            metalness: 0
          });

          // Base wall (mortar color background)
          const baseWall = new THREE.Mesh(
            new THREE.BoxGeometry(w, h, d),
            mortarMat
          );
          group.add(baseWall);

          // Calculate courses and bricks
          const numCourses = Math.ceil(h / brickHeight);
          const bricksPerRow = Math.ceil(w / brickWidth);

          // Individual brick dimensions
          const singleBrickW = brickWidth - mortarJoint;
          const singleBrickH = brickHeight - mortarJoint;
          const singleBrickD = d - mortarJoint * 2;

          // Create individual bricks with running bond
          for (let row = 0; row < numCourses; row++) {
            // Running bond offset
            const rowOffset = (row % 2) * (brickWidth / 2);
            const brickY = -h/2 + brickHeight/2 + row * brickHeight;

            if (brickY - singleBrickH/2 > h/2) continue;

            for (let col = -1; col <= bricksPerRow; col++) {
              const brickX = -w/2 + brickWidth/2 + col * brickWidth - rowOffset;

              // Skip bricks outside bounds
              if (brickX + singleBrickW/2 < -w/2 || brickX - singleBrickW/2 > w/2) continue;

              // Calculate clipped dimensions
              let actualW = singleBrickW;
              let actualX = brickX;
              let actualH = singleBrickH;
              let actualY = brickY;

              // Clip edges
              if (brickX - singleBrickW/2 < -w/2) {
                const clip = (-w/2) - (brickX - singleBrickW/2);
                actualW -= clip;
                actualX += clip / 2;
              }
              if (brickX + singleBrickW/2 > w/2) {
                const clip = (brickX + singleBrickW/2) - (w/2);
                actualW -= clip;
                actualX -= clip / 2;
              }
              if (brickY + singleBrickH/2 > h/2) {
                const clip = (brickY + singleBrickH/2) - (h/2);
                actualH -= clip;
                actualY -= clip / 2;
              }

              if (actualW < 0.05 || actualH < 0.03) continue;

              // Random color variation for natural look
              const colorIdx = (row * 7 + col * 3) % brickMats.length;
              const brick = new THREE.Mesh(
                new THREE.BoxGeometry(actualW, actualH, singleBrickD),
                brickMats[colorIdx]
              );
              brick.position.set(actualX, actualY, 0);
              brick.castShadow = true;
              brick.receiveShadow = true;
              group.add(brick);
            }
          }

          // Visible mortar lines on front face
          // Horizontal bed joints
          for (let row = 1; row < numCourses; row++) {
            const jointY = -h/2 + row * brickHeight;
            if (jointY > h/2) continue;

            const hJoint = new THREE.Mesh(
              new THREE.BoxGeometry(w + 0.01, mortarJoint * 1.5, 0.01),
              mortarMat
            );
            hJoint.position.set(0, jointY, d/2 + 0.002);
            group.add(hJoint);
          }

          // Vertical head joints
          for (let row = 0; row < numCourses; row++) {
            const rowOffset = (row % 2) * (brickWidth / 2);
            const jointY = -h/2 + brickHeight/2 + row * brickHeight;

            for (let col = 0; col <= bricksPerRow; col++) {
              const jointX = -w/2 + col * brickWidth - rowOffset;
              if (jointX < -w/2 || jointX > w/2) continue;

              const vJoint = new THREE.Mesh(
                new THREE.BoxGeometry(mortarJoint * 1.5, singleBrickH + 0.01, 0.01),
                mortarMat
              );
              vJoint.position.set(jointX, jointY, d/2 + 0.002);
              group.add(vJoint);
            }
          }

          break;
        }

        case 'wall-block': {
          // CMU (Concrete Masonry Unit) Block Wall
          // Standard CMU: 8" x 8" x 16" nominal (0.67' x 0.67' x 1.33')
          // Actual: 7.625" x 7.625" x 15.625" with 3/8" mortar joints

          const cmuHeight = 0.67;  // 8" in feet
          const cmuWidth = 1.33;   // 16" in feet
          const mortarJoint = 0.03; // 3/8" mortar joint

          // CMU concrete colors with slight variation for realism
          const cmuBaseColor = el.color ? parseInt(el.color.replace('#', ''), 16) : 0x808080;
          const cmuMat = new THREE.MeshStandardMaterial({
            color: cmuBaseColor,
            roughness: 0.92,
            metalness: 0.02
          });

          // Slightly darker color for depth/shadow blocks
          const cmuDarkMat = new THREE.MeshStandardMaterial({
            color: adjustColorBrightness(cmuBaseColor, -15),
            roughness: 0.95,
            metalness: 0.02
          });

          // Mortar material (light gray cement)
          const mortarMat = new THREE.MeshStandardMaterial({
            color: 0xB8B8B8,
            roughness: 0.85,
            metalness: 0
          });

          // Calculate number of courses (rows) and blocks per row
          const numCourses = Math.ceil(h / cmuHeight);
          const blocksPerRow = Math.ceil(w / cmuWidth);

          // Create the base wall with mortar color (visible in joints)
          const baseWall = new THREE.Mesh(
            new THREE.BoxGeometry(w, h, d),
            mortarMat
          );
          group.add(baseWall);

          // Individual block dimensions (slightly smaller than nominal for mortar gaps)
          const blockW = cmuWidth - mortarJoint;
          const blockH = cmuHeight - mortarJoint;
          const blockD = d - mortarJoint * 2;

          // Create individual CMU blocks with running bond pattern
          for (let row = 0; row < numCourses; row++) {
            // Running bond: offset every other row by half block
            const rowOffset = (row % 2) * (cmuWidth / 2);
            const blockY = -h/2 + cmuHeight/2 + row * cmuHeight;

            // Skip if block would be above wall height
            if (blockY - blockH/2 > h/2) continue;

            for (let col = -1; col <= blocksPerRow; col++) {
              const blockX = -w/2 + cmuWidth/2 + col * cmuWidth - rowOffset;

              // Skip blocks that are completely outside the wall width
              if (blockX + blockW/2 < -w/2 || blockX - blockW/2 > w/2) continue;

              // Calculate clipped block dimensions for edge blocks
              let actualBlockW = blockW;
              let actualBlockX = blockX;

              // Clip left edge
              if (blockX - blockW/2 < -w/2) {
                const clipAmount = (-w/2) - (blockX - blockW/2);
                actualBlockW -= clipAmount;
                actualBlockX += clipAmount / 2;
              }

              // Clip right edge
              if (blockX + blockW/2 > w/2) {
                const clipAmount = (blockX + blockW/2) - (w/2);
                actualBlockW -= clipAmount;
                actualBlockX -= clipAmount / 2;
              }

              // Clip top edge
              let actualBlockH = blockH;
              let actualBlockY = blockY;
              if (blockY + blockH/2 > h/2) {
                const clipAmount = (blockY + blockH/2) - (h/2);
                actualBlockH -= clipAmount;
                actualBlockY -= clipAmount / 2;
              }

              // Skip very small fragments
              if (actualBlockW < 0.1 || actualBlockH < 0.1) continue;

              // Alternate between normal and slightly darker blocks for texture
              const useDark = (row + col) % 7 === 0 || (row + col) % 11 === 0;
              const blockMaterial = useDark ? cmuDarkMat : cmuMat;

              // Main block face (front)
              const block = new THREE.Mesh(
                new THREE.BoxGeometry(actualBlockW, actualBlockH, blockD),
                blockMaterial
              );
              block.position.set(actualBlockX, actualBlockY, 0);
              block.castShadow = true;
              block.receiveShadow = true;
              group.add(block);

              // Add subtle face texture - horizontal score line typical in CMU
              if (actualBlockW > 0.5) {
                const scoreMat = new THREE.MeshStandardMaterial({
                  color: adjustColorBrightness(cmuBaseColor, -25),
                  roughness: 1
                });
                const scoreLine = new THREE.Mesh(
                  new THREE.BoxGeometry(actualBlockW - 0.08, 0.01, 0.005),
                  scoreMat
                );
                scoreLine.position.set(actualBlockX, actualBlockY, blockD/2 + 0.003);
                group.add(scoreLine);
              }
            }
          }

          // Add exposed mortar joint lines on front face for better visibility
          // Horizontal joints
          for (let row = 1; row < numCourses; row++) {
            const jointY = -h/2 + row * cmuHeight;
            if (jointY > h/2) continue;

            const hJoint = new THREE.Mesh(
              new THREE.BoxGeometry(w + 0.01, mortarJoint * 1.2, 0.01),
              mortarMat
            );
            hJoint.position.set(0, jointY, d/2 + 0.002);
            group.add(hJoint);
          }

          // Vertical joints (staggered for running bond)
          for (let row = 0; row < numCourses; row++) {
            const rowOffset = (row % 2) * (cmuWidth / 2);
            const jointY = -h/2 + cmuHeight/2 + row * cmuHeight;

            for (let col = 0; col <= blocksPerRow; col++) {
              const jointX = -w/2 + col * cmuWidth - rowOffset;

              // Skip joints outside wall bounds
              if (jointX < -w/2 || jointX > w/2) continue;

              const jointH = Math.min(cmuHeight - mortarJoint, (h/2 - (jointY - cmuHeight/2)) + cmuHeight);
              if (jointH < 0.1) continue;

              const vJoint = new THREE.Mesh(
                new THREE.BoxGeometry(mortarJoint * 1.2, jointH, 0.01),
                mortarMat
              );
              vJoint.position.set(jointX, jointY, d/2 + 0.002);
              group.add(vJoint);
            }
          }

          // Add end cap detail showing hollow cores (if wall depth allows)
          if (d >= 0.5) {
            const endCapMat = new THREE.MeshStandardMaterial({
              color: adjustColorBrightness(cmuBaseColor, -10),
              roughness: 0.9
            });

            // Left end cap with core holes
            const leftEndCap = new THREE.Mesh(
              new THREE.BoxGeometry(0.02, h, d - mortarJoint * 2),
              endCapMat
            );
            leftEndCap.position.set(-w/2 - 0.01, 0, 0);
            group.add(leftEndCap);

            // Right end cap
            const rightEndCap = new THREE.Mesh(
              new THREE.BoxGeometry(0.02, h, d - mortarJoint * 2),
              endCapMat
            );
            rightEndCap.position.set(w/2 + 0.01, 0, 0);
            group.add(rightEndCap);

            // Add hollow core indicators on ends (visible from side)
            const coreMat = new THREE.MeshStandardMaterial({
              color: 0x4a4a4a,
              roughness: 1
            });

            for (let row = 0; row < numCourses; row++) {
              const coreY = -h/2 + cmuHeight/2 + row * cmuHeight;
              if (coreY + cmuHeight/2 > h/2) continue;

              // Two cores per block (typical 2-core CMU)
              for (let coreOffset of [-0.18, 0.18]) {
                // Left side cores
                const leftCore = new THREE.Mesh(
                  new THREE.BoxGeometry(0.015, cmuHeight - 0.15, 0.25),
                  coreMat
                );
                leftCore.position.set(-w/2 - 0.005, coreY, coreOffset);
                group.add(leftCore);

                // Right side cores
                const rightCore = new THREE.Mesh(
                  new THREE.BoxGeometry(0.015, cmuHeight - 0.15, 0.25),
                  coreMat
                );
                rightCore.position.set(w/2 + 0.005, coreY, coreOffset);
                group.add(rightCore);
              }
            }
          }

          break;
        }

        // ===== STRUCTURAL ELEMENTS - BEAMS & COLUMNS =====
        case 'steel-beam': {
          // Steel I-Beam (Wide Flange)
          // Standard beam oriented horizontally, spanning across room
          const beamColor = el.color ? parseInt(el.color.replace('#', ''), 16) : 0x4A4A4A;
          const steelMat = new THREE.MeshStandardMaterial({
            color: beamColor,
            roughness: 0.4,
            metalness: 0.85
          });

          // I-beam dimensions (W8x31 typical)
          const flangeWidth = d;              // Flange width (depth in 2D)
          const webHeight = h * 0.7;          // Web height
          const flangeThickness = h * 0.15;   // Flange thickness
          const webThickness = 0.03;          // Web thickness (~3/8")

          // Top flange
          const topFlange = new THREE.Mesh(
            new THREE.BoxGeometry(w, flangeThickness, flangeWidth),
            steelMat
          );
          topFlange.position.y = h/2 - flangeThickness/2;
          topFlange.castShadow = true;
          group.add(topFlange);

          // Bottom flange
          const botFlange = new THREE.Mesh(
            new THREE.BoxGeometry(w, flangeThickness, flangeWidth),
            steelMat
          );
          botFlange.position.y = -h/2 + flangeThickness/2;
          botFlange.castShadow = true;
          group.add(botFlange);

          // Web (vertical center piece)
          const web = new THREE.Mesh(
            new THREE.BoxGeometry(w, webHeight, webThickness),
            steelMat
          );
          web.castShadow = true;
          group.add(web);

          // Edge highlights (subtle rust/weathering)
          const rustMat = new THREE.MeshStandardMaterial({
            color: 0x5C4033,
            roughness: 0.9,
            transparent: true,
            opacity: 0.2
          });
          const rustEdge = new THREE.Mesh(
            new THREE.BoxGeometry(w, 0.01, flangeWidth),
            rustMat
          );
          rustEdge.position.y = h/2 + 0.005;
          group.add(rustEdge);

          break;
        }

        case 'steel-column': {
          // Steel Box Column (HSS - Hollow Structural Section)
          const columnColor = el.color ? parseInt(el.color.replace('#', ''), 16) : 0x4A4A4A;
          const steelMat = new THREE.MeshStandardMaterial({
            color: columnColor,
            roughness: 0.4,
            metalness: 0.85
          });

          // Square HSS column
          const wallThickness = 0.02; // ~1/4" wall

          // Outer shell
          const outer = new THREE.Mesh(
            new THREE.BoxGeometry(w, h, d),
            steelMat
          );
          outer.castShadow = true;
          outer.receiveShadow = true;
          group.add(outer);

          // Hollow interior (dark)
          const innerMat = new THREE.MeshStandardMaterial({
            color: 0x1a1a1a,
            roughness: 0.9
          });

          // Top opening showing hollow
          const topHole = new THREE.Mesh(
            new THREE.BoxGeometry(w - wallThickness*4, 0.01, d - wallThickness*4),
            innerMat
          );
          topHole.position.y = h/2;
          group.add(topHole);

          // Base plate
          const basePlate = new THREE.Mesh(
            new THREE.BoxGeometry(w * 1.3, 0.04, d * 1.3),
            steelMat
          );
          basePlate.position.y = -h/2 - 0.02;
          basePlate.castShadow = true;
          group.add(basePlate);

          break;
        }

        case 'wood-beam': {
          // Solid Wood Beam (Glulam or Solid Timber)
          const woodColor = el.color ? parseInt(el.color.replace('#', ''), 16) : 0x8B6914;
          const woodMat = createTexturedMaterial(woodColor, textureUrl, {
            roughness: 0.7,
            metalness: 0
          });

          // Main beam body
          const beam = new THREE.Mesh(
            new THREE.BoxGeometry(w, h, d),
            woodMat
          );
          beam.castShadow = true;
          beam.receiveShadow = true;
          group.add(beam);

          // Wood grain lines (darker grooves)
          const grainMat = new THREE.MeshStandardMaterial({
            color: adjustColorBrightness(woodColor, -30),
            roughness: 0.9
          });

          // Horizontal grain lines on bottom face
          const grainSpacing = 0.15;
          for (let gz = -d/2 + grainSpacing; gz < d/2; gz += grainSpacing + Math.random() * 0.1) {
            const grain = new THREE.Mesh(
              new THREE.BoxGeometry(w - 0.05, 0.005, 0.008),
              grainMat
            );
            grain.position.set(0, -h/2 - 0.002, gz);
            group.add(grain);
          }

          // End grain (visible at beam ends)
          const endGrainMat = new THREE.MeshStandardMaterial({
            color: adjustColorBrightness(woodColor, 10),
            roughness: 0.6
          });

          // Left end
          const leftEnd = new THREE.Mesh(
            new THREE.BoxGeometry(0.01, h - 0.02, d - 0.02),
            endGrainMat
          );
          leftEnd.position.x = -w/2 - 0.005;
          group.add(leftEnd);

          // Right end
          const rightEnd = new THREE.Mesh(
            new THREE.BoxGeometry(0.01, h - 0.02, d - 0.02),
            endGrainMat
          );
          rightEnd.position.x = w/2 + 0.005;
          group.add(rightEnd);

          break;
        }

        case 'wood-post': {
          // Wood Post (4x4, 6x6)
          const woodColor = el.color ? parseInt(el.color.replace('#', ''), 16) : 0x8B6914;
          const woodMat = createTexturedMaterial(woodColor, textureUrl, {
            roughness: 0.7,
            metalness: 0
          });

          // Main post body
          const post = new THREE.Mesh(
            new THREE.BoxGeometry(w, h, d),
            woodMat
          );
          post.castShadow = true;
          post.receiveShadow = true;
          group.add(post);

          // Vertical grain lines
          const grainMat = new THREE.MeshStandardMaterial({
            color: adjustColorBrightness(woodColor, -25),
            roughness: 0.9
          });

          for (let side = 0; side < 4; side++) {
            const rotation = side * Math.PI / 2;
            const offsetX = side === 1 ? w/2 + 0.002 : (side === 3 ? -w/2 - 0.002 : 0);
            const offsetZ = side === 0 ? d/2 + 0.002 : (side === 2 ? -d/2 - 0.002 : 0);

            for (let i = 0; i < 3; i++) {
              const grain = new THREE.Mesh(
                new THREE.BoxGeometry(0.005, h - 0.1, 0.005),
                grainMat
              );
              const offset = (i - 1) * (side % 2 === 0 ? w : d) * 0.25;
              grain.position.set(
                offsetX + (side % 2 === 0 ? offset : 0),
                0,
                offsetZ + (side % 2 === 1 ? offset : 0)
              );
              group.add(grain);
            }
          }

          break;
        }

        case 'concrete-beam': {
          // Reinforced Concrete Beam
          const concreteColor = el.color ? parseInt(el.color.replace('#', ''), 16) : 0x707070;
          const concreteMat = new THREE.MeshStandardMaterial({
            color: concreteColor,
            roughness: 0.9,
            metalness: 0.02
          });

          // Main beam body
          const beam = new THREE.Mesh(
            new THREE.BoxGeometry(w, h, d),
            concreteMat
          );
          beam.castShadow = true;
          beam.receiveShadow = true;
          group.add(beam);

          // Form lines (horizontal pour joints)
          const formMat = new THREE.MeshStandardMaterial({
            color: adjustColorBrightness(concreteColor, -15),
            roughness: 0.95
          });

          const formLine = new THREE.Mesh(
            new THREE.BoxGeometry(w + 0.01, 0.01, d + 0.01),
            formMat
          );
          formLine.position.y = 0;
          group.add(formLine);

          // Aggregate texture spots
          const spotMat = new THREE.MeshStandardMaterial({
            color: adjustColorBrightness(concreteColor, -10),
            roughness: 1
          });

          for (let i = 0; i < Math.min(w * 8, 20); i++) {
            const spotX = (Math.random() - 0.5) * w * 0.9;
            const spotY = (Math.random() - 0.5) * h * 0.8;
            const spot = new THREE.Mesh(
              new THREE.SphereGeometry(0.015 + Math.random() * 0.01, 6, 6),
              spotMat
            );
            spot.position.set(spotX, spotY, d/2 + 0.005);
            group.add(spot);
          }

          break;
        }

        case 'concrete-column': {
          // Reinforced Concrete Column
          const concreteColor = el.color ? parseInt(el.color.replace('#', ''), 16) : 0x707070;
          const concreteMat = new THREE.MeshStandardMaterial({
            color: concreteColor,
            roughness: 0.9,
            metalness: 0.02
          });

          // Square or rectangular column
          const column = new THREE.Mesh(
            new THREE.BoxGeometry(w, h, d),
            concreteMat
          );
          column.castShadow = true;
          column.receiveShadow = true;
          group.add(column);

          // Chamfered edges (typical on concrete columns)
          const chamferMat = new THREE.MeshStandardMaterial({
            color: adjustColorBrightness(concreteColor, -10),
            roughness: 0.85
          });

          const chamferSize = 0.02;
          const edges = [
            { pos: [-w/2, 0, -d/2], rot: [0, Math.PI/4, 0] },
            { pos: [w/2, 0, -d/2], rot: [0, -Math.PI/4, 0] },
            { pos: [-w/2, 0, d/2], rot: [0, -Math.PI/4, 0] },
            { pos: [w/2, 0, d/2], rot: [0, Math.PI/4, 0] }
          ];

          edges.forEach(edge => {
            const chamfer = new THREE.Mesh(
              new THREE.BoxGeometry(chamferSize, h - 0.1, chamferSize),
              chamferMat
            );
            chamfer.position.set(...edge.pos);
            chamfer.rotation.set(...edge.rot);
            group.add(chamfer);
          });

          break;
        }

        case 'header':
        case 'lvl-beam': {
          // Header/Lintel or LVL (Laminated Veneer Lumber) Beam
          const isLVL = el.type === 'lvl-beam';
          const woodColor = el.color ? parseInt(el.color.replace('#', ''), 16) : (isLVL ? 0xDEB887 : 0xCD853F);
          const woodMat = createTexturedMaterial(woodColor, textureUrl, {
            roughness: 0.65,
            metalness: 0
          });

          // Main beam body
          const beam = new THREE.Mesh(
            new THREE.BoxGeometry(w, h, d),
            woodMat
          );
          beam.castShadow = true;
          beam.receiveShadow = true;
          group.add(beam);

          if (isLVL) {
            // LVL lamination lines (horizontal layers)
            const lamMat = new THREE.MeshStandardMaterial({
              color: adjustColorBrightness(woodColor, -20),
              roughness: 0.8
            });

            const layerHeight = 0.06; // ~3/4" layers
            for (let ly = -h/2 + layerHeight; ly < h/2; ly += layerHeight) {
              const lamLine = new THREE.Mesh(
                new THREE.BoxGeometry(w + 0.01, 0.005, d + 0.01),
                lamMat
              );
              lamLine.position.y = ly;
              group.add(lamLine);
            }
          } else {
            // Regular header - single piece with grain
            const grainMat = new THREE.MeshStandardMaterial({
              color: adjustColorBrightness(woodColor, -25),
              roughness: 0.9
            });

            // Horizontal grain line
            const grain = new THREE.Mesh(
              new THREE.BoxGeometry(w - 0.05, 0.01, 0.005),
              grainMat
            );
            grain.position.set(0, 0, d/2 + 0.002);
            group.add(grain);
          }

          // End grain
          const endMat = new THREE.MeshStandardMaterial({
            color: adjustColorBrightness(woodColor, 15),
            roughness: 0.55
          });

          const leftEnd = new THREE.Mesh(
            new THREE.BoxGeometry(0.01, h - 0.02, d - 0.02),
            endMat
          );
          leftEnd.position.x = -w/2 - 0.005;
          group.add(leftEnd);

          const rightEnd = new THREE.Mesh(
            new THREE.BoxGeometry(0.01, h - 0.02, d - 0.02),
            endMat
          );
          rightEnd.position.x = w/2 + 0.005;
          group.add(rightEnd);

          break;
        }

        // ===== PONY WALLS & HALF WALLS =====
        case 'pony-wall':
        case 'pony-wall-bar':
        case 'knee-wall': {
          // Half-height wall with proper framing construction
          // Shows: drywall both sides, visible studs at ends, top/bottom plates
          const ponyHeight = el.wallHeight || (el.type === 'knee-wall' ? 2.5 : 3.5);
          const ponyDepth = d || 0.5;
          const isBarHeight = el.type === 'pony-wall-bar';
          const baseY = -h / 2;

          // Construction dimensions (standard framing)
          const studWidth = 0.125; // 1.5" stud face
          const studDepth = ponyDepth - 0.08; // Stud depth (leave room for drywall both sides)
          const plateHeight = 0.125; // 1.5" plate thickness
          const drywallThickness = 0.04; // ~1/2" drywall

          // Materials - use applied color if a material is set, otherwise default drywall
          const hasAppliedMaterial = textureUrl || el.materialId;
          const drywallColor = hasAppliedMaterial ? color : (el.materialColor || 0xF5F5F0);
          const drywallMat = createTexturedMaterial(drywallColor, textureUrl, {
            roughness: hasAppliedMaterial ? 0.35 : 0.85
          });
          const drywallTopMat = new THREE.MeshStandardMaterial({
            color: 0xE0E0E0,
            roughness: 0.9
          });
          const studMat = new THREE.MeshStandardMaterial({
            color: 0xD4B896, // Wood color
            roughness: 0.75
          });
          const cornerBeadMat = new THREE.MeshStandardMaterial({
            color: 0xDDDDDD,
            roughness: 0.6,
            metalness: 0.1
          });

          // === FRAMING (visible at ends) ===
          // Bottom plate (sole plate)
          const bottomPlate = new THREE.Mesh(
            new THREE.BoxGeometry(w, plateHeight, studDepth),
            studMat
          );
          bottomPlate.position.set(0, baseY + plateHeight/2, 0);
          group.add(bottomPlate);

          // Top plate (double top plate is standard)
          const topPlate1 = new THREE.Mesh(
            new THREE.BoxGeometry(w, plateHeight, studDepth),
            studMat
          );
          topPlate1.position.set(0, baseY + ponyHeight - plateHeight * 1.5, 0);
          group.add(topPlate1);

          const topPlate2 = new THREE.Mesh(
            new THREE.BoxGeometry(w, plateHeight, studDepth),
            studMat
          );
          topPlate2.position.set(0, baseY + ponyHeight - plateHeight * 0.5, 0);
          group.add(topPlate2);

          // End studs (king studs at each end - visible from the side)
          const studHeight = ponyHeight - plateHeight * 3;
          [-1, 1].forEach(side => {
            const endStud = new THREE.Mesh(
              new THREE.BoxGeometry(studWidth, studHeight, studDepth),
              studMat
            );
            endStud.position.set(
              side * (w/2 - studWidth/2),
              baseY + plateHeight + studHeight/2,
              0
            );
            group.add(endStud);
          });

          // Interior studs (at 16" on center, partially visible through drywall texture)
          const studSpacing = 1.33; // 16" OC
          const numStuds = Math.floor((w - studWidth * 2) / studSpacing);
          for (let s = 1; s <= numStuds; s++) {
            const studX = -w/2 + studWidth + s * studSpacing;
            if (studX < w/2 - studWidth) {
              const interiorStud = new THREE.Mesh(
                new THREE.BoxGeometry(studWidth, studHeight, studDepth),
                studMat
              );
              interiorStud.position.set(studX, baseY + plateHeight + studHeight/2, 0);
              group.add(interiorStud);
            }
          }

          // === DRYWALL SHEATHING ===
          // Front drywall panel
          const frontDrywall = new THREE.Mesh(
            new THREE.BoxGeometry(w, ponyHeight - plateHeight, drywallThickness),
            drywallMat
          );
          frontDrywall.position.set(0, baseY + plateHeight + (ponyHeight - plateHeight)/2, ponyDepth/2 - drywallThickness/2);
          frontDrywall.castShadow = true;
          frontDrywall.receiveShadow = true;
          group.add(frontDrywall);

          // Back drywall panel
          const backDrywall = new THREE.Mesh(
            new THREE.BoxGeometry(w, ponyHeight - plateHeight, drywallThickness),
            drywallMat
          );
          backDrywall.position.set(0, baseY + plateHeight + (ponyHeight - plateHeight)/2, -ponyDepth/2 + drywallThickness/2);
          backDrywall.castShadow = true;
          backDrywall.receiveShadow = true;
          group.add(backDrywall);

          // === TOP SURFACE / CAP ===
          // If a countertop material is applied, show a proper stone cap
          // Otherwise show drywall finish ready for a separate cap element
          if (textureUrl || el.storeProduct || el.materialId) {
            // Stone cap with applied material
            const capThickness = el.capThickness || 0.1; // 1.25" default
            const capOverhang = 0.08; // 1" overhang on each side
            const capMat = createTexturedMaterial(color, textureUrl, {
              roughness: 0.35,
              metalness: 0.02,
              finish: el.finish || 'polished'
            });

            // Main cap surface
            const stoneCap = new THREE.Mesh(
              new THREE.BoxGeometry(w + capOverhang * 2, capThickness, ponyDepth + capOverhang * 2),
              capMat
            );
            stoneCap.position.set(0, baseY + ponyHeight + capThickness / 2, 0);
            stoneCap.castShadow = true;
            stoneCap.receiveShadow = true;
            group.add(stoneCap);

            // Front edge detail (slight lip/drip edge)
            const edgeMat = new THREE.MeshStandardMaterial({
              color: adjustColorBrightness(color, -20),
              roughness: 0.5
            });
            const frontEdge = new THREE.Mesh(
              new THREE.BoxGeometry(w + capOverhang * 2, 0.02, 0.02),
              edgeMat
            );
            frontEdge.position.set(0, baseY + ponyHeight + capThickness - 0.01, ponyDepth / 2 + capOverhang);
            group.add(frontEdge);
          } else {
            // Plain drywall top (no material applied yet)
            const topSurface = new THREE.Mesh(
              new THREE.BoxGeometry(w, 0.02, ponyDepth),
              drywallTopMat
            );
            topSurface.position.set(0, baseY + ponyHeight, 0);
            topSurface.receiveShadow = true;
            group.add(topSurface);
          }

          // === CORNER BEADS (metal edges at corners) ===
          const beadSize = 0.02;
          // Top front corner bead
          const topFrontBead = new THREE.Mesh(
            new THREE.BoxGeometry(w, beadSize, beadSize),
            cornerBeadMat
          );
          topFrontBead.position.set(0, baseY + ponyHeight - beadSize/2, ponyDepth/2 - beadSize/2);
          group.add(topFrontBead);

          // Top back corner bead
          const topBackBead = new THREE.Mesh(
            new THREE.BoxGeometry(w, beadSize, beadSize),
            cornerBeadMat
          );
          topBackBead.position.set(0, baseY + ponyHeight - beadSize/2, -ponyDepth/2 + beadSize/2);
          group.add(topBackBead);

          // Vertical corner beads at ends
          [-1, 1].forEach(side => {
            // Front vertical
            const frontVertBead = new THREE.Mesh(
              new THREE.BoxGeometry(beadSize, ponyHeight - plateHeight, beadSize),
              cornerBeadMat
            );
            frontVertBead.position.set(
              side * (w/2 - beadSize/2),
              baseY + plateHeight + (ponyHeight - plateHeight)/2,
              ponyDepth/2 - beadSize/2
            );
            group.add(frontVertBead);

            // Back vertical
            const backVertBead = new THREE.Mesh(
              new THREE.BoxGeometry(beadSize, ponyHeight - plateHeight, beadSize),
              cornerBeadMat
            );
            backVertBead.position.set(
              side * (w/2 - beadSize/2),
              baseY + plateHeight + (ponyHeight - plateHeight)/2,
              -ponyDepth/2 + beadSize/2
            );
            group.add(backVertBead);
          });

          // === END CAPS (close off the stud cavity at ends) ===
          [-1, 1].forEach(side => {
            const endCap = new THREE.Mesh(
              new THREE.BoxGeometry(drywallThickness, ponyHeight - plateHeight, ponyDepth - drywallThickness * 2),
              drywallMat
            );
            endCap.position.set(
              side * (w/2 + drywallThickness/2),
              baseY + plateHeight + (ponyHeight - plateHeight)/2,
              0
            );
            endCap.castShadow = true;
            group.add(endCap);
          });

          // === BASEBOARD (optional, at floor level) ===
          const baseboardMat = new THREE.MeshStandardMaterial({
            color: 0xFFFFFF,
            roughness: 0.5
          });
          const baseboardHeight = 0.25; // 3" baseboard
          // Front baseboard
          const frontBaseboard = new THREE.Mesh(
            new THREE.BoxGeometry(w + 0.02, baseboardHeight, 0.03),
            baseboardMat
          );
          frontBaseboard.position.set(0, baseY + baseboardHeight/2, ponyDepth/2 + 0.015);
          group.add(frontBaseboard);

          // Back baseboard
          const backBaseboard = new THREE.Mesh(
            new THREE.BoxGeometry(w + 0.02, baseboardHeight, 0.03),
            baseboardMat
          );
          backBaseboard.position.set(0, baseY + baseboardHeight/2, -ponyDepth/2 - 0.015);
          group.add(backBaseboard);

          break;
        }

        // ===== WALL NICHES & RECESSES =====
        case 'wall-niche':
        case 'fireplace-niche':
        case 'tv-niche':
        case 'shower-niche': {
          // Simple recessed niche - dark opening with depth
          const nicheDepth = el.nicheDepth || 0.5; // 6" default recess
          const isFireplace = el.type === 'fireplace-niche';
          const isTV = el.type === 'tv-niche';
          const isShower = el.type === 'shower-niche';

          // Interior colors - brighter to reflect interior lighting
          // TV niches stay dark for screen visibility, others are lighter
          const interiorColor = isFireplace ? 0x2A2A2A : (isTV ? 0x0A0A0A : (isShower ? 0x6A6A70 : 0x5A5A65));

          // Materials with better light reflection for interior illumination
          const interiorMat = new THREE.MeshStandardMaterial({
            color: interiorColor,
            roughness: isTV ? 0.95 : 0.7, // Less rough = better light reflection
            side: THREE.DoubleSide
          });
          const sideMat = new THREE.MeshStandardMaterial({
            color: adjustColorBrightness(interiorColor, 30),
            roughness: isTV ? 0.9 : 0.65,
            side: THREE.DoubleSide
          });

          // === RECESSED BOX INTERIOR ===
          // Back wall (the dark back of the niche)
          const backWall = new THREE.Mesh(
            new THREE.PlaneGeometry(w, h),
            interiorMat
          );
          backWall.position.set(0, 0, -nicheDepth);
          group.add(backWall);

          // Left side wall
          const leftWall = new THREE.Mesh(
            new THREE.PlaneGeometry(nicheDepth, h),
            sideMat
          );
          leftWall.rotation.y = Math.PI / 2;
          leftWall.position.set(-w/2, 0, -nicheDepth/2);
          group.add(leftWall);

          // Right side wall
          const rightWall = new THREE.Mesh(
            new THREE.PlaneGeometry(nicheDepth, h),
            sideMat
          );
          rightWall.rotation.y = -Math.PI / 2;
          rightWall.position.set(w/2, 0, -nicheDepth/2);
          group.add(rightWall);

          // Top wall (ceiling of niche)
          const topWall = new THREE.Mesh(
            new THREE.PlaneGeometry(w, nicheDepth),
            sideMat
          );
          topWall.rotation.x = Math.PI / 2;
          topWall.position.set(0, h/2, -nicheDepth/2);
          group.add(topWall);

          // Bottom wall (floor of niche)
          const bottomWall = new THREE.Mesh(
            new THREE.PlaneGeometry(w, nicheDepth),
            sideMat
          );
          bottomWall.rotation.x = -Math.PI / 2;
          bottomWall.position.set(0, -h/2, -nicheDepth/2);
          group.add(bottomWall);

          // === SIMPLE TRIM FRAME ===
          const trimWidth = 0.06;
          const trimDepth = 0.03;
          const trimMat = new THREE.MeshStandardMaterial({
            color: 0xF0F0F0,
            roughness: 0.4
          });

          // Top trim
          const topTrim = new THREE.Mesh(
            new THREE.BoxGeometry(w + trimWidth * 2, trimWidth, trimDepth),
            trimMat
          );
          topTrim.position.set(0, h/2 + trimWidth/2, trimDepth/2);
          group.add(topTrim);

          // Bottom trim
          const bottomTrim = new THREE.Mesh(
            new THREE.BoxGeometry(w + trimWidth * 2, trimWidth, trimDepth),
            trimMat
          );
          bottomTrim.position.set(0, -h/2 - trimWidth/2, trimDepth/2);
          group.add(bottomTrim);

          // Left trim
          const leftTrim = new THREE.Mesh(
            new THREE.BoxGeometry(trimWidth, h, trimDepth),
            trimMat
          );
          leftTrim.position.set(-w/2 - trimWidth/2, 0, trimDepth/2);
          group.add(leftTrim);

          // Right trim
          const rightTrim = new THREE.Mesh(
            new THREE.BoxGeometry(trimWidth, h, trimDepth),
            trimMat
          );
          rightTrim.position.set(w/2 + trimWidth/2, 0, trimDepth/2);
          group.add(rightTrim);

          // === TYPE-SPECIFIC SIMPLE ADDITIONS ===
          if (isFireplace) {
            // Fire glow at bottom
            const fireMat = new THREE.MeshBasicMaterial({
              color: 0xFF4500,
              transparent: true,
              opacity: 0.7
            });
            const fire = new THREE.Mesh(
              new THREE.SphereGeometry(0.2, 8, 8),
              fireMat
            );
            fire.scale.set(2, 0.8, 0.5);
            fire.position.set(0, -h/2 + 0.2, -nicheDepth * 0.6);
            group.add(fire);

          } else if (isTV) {
            // TV screen rectangle
            const screenMat = new THREE.MeshStandardMaterial({
              color: 0x050505,
              roughness: 0.05,
              metalness: 0.3
            });
            const tvW = w * 0.85;
            const tvH = tvW * 0.5625; // 16:9
            const screen = new THREE.Mesh(
              new THREE.BoxGeometry(tvW, tvH, 0.03),
              screenMat
            );
            screen.position.set(0, 0, -nicheDepth/2);
            group.add(screen);

          } else if (isShower) {
            // Simple shelf
            const shelfMat = new THREE.MeshStandardMaterial({
              color: 0x808080,
              roughness: 0.3
            });
            const shelf = new THREE.Mesh(
              new THREE.BoxGeometry(w - 0.04, 0.02, nicheDepth - 0.04),
              shelfMat
            );
            shelf.position.set(0, 0, -nicheDepth/2);
            group.add(shelf);
          }

          // === STONE SURROUND WITH INTERIOR LEDGES (if applied) ===
          if (el.surroundColor || el.hasStoneSurround || el.texture || el.storeProduct) {
            // Get material texture if available
            const stoneTextureUrl = el.texture || el.storeProduct?.image || null;
            const stoneColor = el.surroundColor || el.color || 0x708090;

            const surroundMat = stoneTextureUrl
              ? createTexturedMaterial(stoneColor, stoneTextureUrl, { roughness: 0.35, metalness: 0.05 })
              : new THREE.MeshStandardMaterial({
                  color: stoneColor,
                  roughness: 0.35,
                  metalness: 0.05
                });

            const surrW = 0.12; // Frame width (~1.5")
            const surrD = el.stoneThickness || 0.1; // Frame depth/thickness
            const returnDepth = Math.min(nicheDepth * 0.4, 0.3); // How far stone goes INTO recess

            // === STONE FACE FRAME ===
            // Top stone piece
            const topSurr = new THREE.Mesh(
              new THREE.BoxGeometry(w + surrW * 2 + trimWidth * 2, surrW, surrD),
              surroundMat
            );
            topSurr.position.set(0, h/2 + trimWidth + surrW/2, surrD/2);
            topSurr.castShadow = true;
            group.add(topSurr);

            // Bottom stone piece (wider for hearth/sill effect)
            const botHeight = isFireplace ? surrW * 1.5 : surrW;
            const botSurr = new THREE.Mesh(
              new THREE.BoxGeometry(w + surrW * 2 + trimWidth * 2, botHeight, isFireplace ? surrD * 2 : surrD),
              surroundMat
            );
            botSurr.position.set(0, -h/2 - trimWidth - botHeight/2, isFireplace ? surrD : surrD/2);
            botSurr.castShadow = true;
            group.add(botSurr);

            // Side stone pieces
            [-1, 1].forEach(side => {
              const sideSurr = new THREE.Mesh(
                new THREE.BoxGeometry(surrW, h + trimWidth * 2, surrD),
                surroundMat
              );
              sideSurr.position.set(side * (w/2 + trimWidth + surrW/2), 0, surrD/2);
              sideSurr.castShadow = true;
              group.add(sideSurr);
            });

            // === STONE RETURNS/LEDGES INTO RECESS ===
            // These wrap around the inside of the opening to show stone depth

            // Top inside ledge (header return)
            const topLedge = new THREE.Mesh(
              new THREE.BoxGeometry(w, surrD * 0.6, returnDepth),
              surroundMat
            );
            topLedge.position.set(0, h/2 - surrD * 0.3, -returnDepth/2);
            topLedge.castShadow = true;
            topLedge.receiveShadow = true;
            group.add(topLedge);

            // Bottom sill (most visible ledge - like a window sill)
            const sillThickness = surrD * 0.8;
            const sillReturn = returnDepth * 1.2;
            const bottomSill = new THREE.Mesh(
              new THREE.BoxGeometry(w + 0.02, sillThickness, sillReturn),
              surroundMat
            );
            bottomSill.position.set(0, -h/2 + sillThickness/2, -sillReturn/2 + 0.01);
            bottomSill.castShadow = true;
            bottomSill.receiveShadow = true;
            group.add(bottomSill);

            // Left side return
            const leftReturn = new THREE.Mesh(
              new THREE.BoxGeometry(surrD * 0.5, h - sillThickness * 2, returnDepth),
              surroundMat
            );
            leftReturn.position.set(-w/2 + surrD * 0.25, 0, -returnDepth/2);
            leftReturn.castShadow = true;
            group.add(leftReturn);

            // Right side return
            const rightReturn = new THREE.Mesh(
              new THREE.BoxGeometry(surrD * 0.5, h - sillThickness * 2, returnDepth),
              surroundMat
            );
            rightReturn.position.set(w/2 - surrD * 0.25, 0, -returnDepth/2);
            rightReturn.castShadow = true;
            group.add(rightReturn);

            // === EDGE DETAIL (Bullnose on sill) ===
            const edgeProfile = el.edgeProfile || 'eased';
            if (edgeProfile !== 'square') {
              const edgeRadius = sillThickness * 0.3;
              const sillEdge = new THREE.Mesh(
                new THREE.CylinderGeometry(edgeRadius, edgeRadius, w, 8, 1, false, 0, Math.PI),
                surroundMat
              );
              sillEdge.rotation.x = Math.PI / 2;
              sillEdge.rotation.z = Math.PI / 2;
              sillEdge.position.set(0, -h/2 + sillThickness * 0.2, surrD * 0.35);
              group.add(sillEdge);
            }
          }

          // === INTERIOR LIGHTING ===
          // Add soft interior light to illuminate the niche (prevents dark void appearance)
          if (!isTV) { // TV niche should stay dark for screen visibility
            // LED strip light at top of niche
            const ledStripMat = new THREE.MeshBasicMaterial({
              color: isFireplace ? 0xFFE4B5 : 0xFFF8F0, // Warm white for fireplace, cool white for others
              transparent: true,
              opacity: 0.9
            });
            const ledStripW = w - 0.1;
            const ledStrip = new THREE.Mesh(
              new THREE.BoxGeometry(ledStripW, 0.01, 0.03),
              ledStripMat
            );
            ledStrip.position.set(0, h/2 - 0.02, -0.08);
            group.add(ledStrip);

            // Add point light for soft interior illumination
            const nicheLight = new THREE.PointLight(
              isFireplace ? 0xFFAA55 : 0xFFFFEE, // Warm glow for fireplace
              isFireplace ? 0.8 : 0.5, // Intensity
              Math.max(w, h) * 1.5, // Range based on niche size
              2 // Decay
            );
            nicheLight.position.set(0, h * 0.3, -nicheDepth * 0.3);
            group.add(nicheLight);

            // For shower niches, add a second light at bottom for shelf visibility
            if (isShower) {
              const shelfLight = new THREE.PointLight(0xFFFFFF, 0.3, 1, 2);
              shelfLight.position.set(0, -h * 0.2, -nicheDepth * 0.4);
              group.add(shelfLight);
            }
          }

          break;
        }

        // ===== ADA GRAB BARS =====
        case 'grab-bar':
        case 'grab-bar-24':
        case 'grab-bar-36':
        case 'grab-bar-42': {
          // ADA compliant grab bar (stainless steel look)
          const barLength = w;
          const barRadius = 0.0625; // 1.5" diameter (ADA spec: 1.25-2")

          // Bar material - brushed stainless steel
          const barMat = new THREE.MeshStandardMaterial({
            color: 0xC0C0C0,
            metalness: 0.8,
            roughness: 0.3
          });

          // Main bar tube
          const barGeo = new THREE.CylinderGeometry(barRadius, barRadius, barLength - 0.2, 16);
          barGeo.rotateZ(Math.PI / 2); // Rotate to horizontal
          const bar = new THREE.Mesh(barGeo, barMat);
          bar.castShadow = true;
          group.add(bar);

          // Mounting flanges (ends)
          const flangeMat = new THREE.MeshStandardMaterial({
            color: 0x888888,
            metalness: 0.6,
            roughness: 0.4
          });

          // Left flange
          const leftFlange = new THREE.Mesh(
            new THREE.CylinderGeometry(barRadius * 2, barRadius * 2, 0.05, 16),
            flangeMat
          );
          leftFlange.rotateZ(Math.PI / 2);
          leftFlange.position.set(-barLength / 2 + 0.05, 0, 0);
          group.add(leftFlange);

          // Right flange
          const rightFlange = new THREE.Mesh(
            new THREE.CylinderGeometry(barRadius * 2, barRadius * 2, 0.05, 16),
            flangeMat
          );
          rightFlange.rotateZ(Math.PI / 2);
          rightFlange.position.set(barLength / 2 - 0.05, 0, 0);
          group.add(rightFlange);

          // Mounting plates (against wall)
          const plateMat = new THREE.MeshStandardMaterial({
            color: 0x666666,
            metalness: 0.5,
            roughness: 0.5
          });

          const leftPlate = new THREE.Mesh(
            new THREE.BoxGeometry(0.15, 0.15, 0.02),
            plateMat
          );
          leftPlate.position.set(-barLength / 2 + 0.1, 0, -barRadius - 0.01);
          group.add(leftPlate);

          const rightPlate = new THREE.Mesh(
            new THREE.BoxGeometry(0.15, 0.15, 0.02),
            plateMat
          );
          rightPlate.position.set(barLength / 2 - 0.1, 0, -barRadius - 0.01);
          group.add(rightPlate);

          break;
        }

        case 'double-door': {
          // Double door with full frame
          const doorColor = el.color ? parseInt(el.color.replace('#', ''), 16) : 0xDEB887;
          const doorMat = new THREE.MeshStandardMaterial({ color: doorColor, roughness: 0.6 });
          const dblFrameMat = new THREE.MeshStandardMaterial({ color: 0xFFFFFF, roughness: 0.5 });
          const frameWidth = 0.08;
          const frameDepth = 0.18;
          const doorGap = 0.03; // Gap between doors
          const doorW = (w - doorGap) / 2 - frameWidth;

          // Left door panel
          const leftDoor = new THREE.Mesh(
            new THREE.BoxGeometry(doorW, h - frameWidth, 0.08),
            doorMat
          );
          leftDoor.position.set(-doorW / 2 - doorGap / 2, -frameWidth / 2, 0);
          leftDoor.castShadow = true;
          group.add(leftDoor);

          // Right door panel
          const rightDoor = new THREE.Mesh(
            new THREE.BoxGeometry(doorW, h - frameWidth, 0.08),
            doorMat
          );
          rightDoor.position.set(doorW / 2 + doorGap / 2, -frameWidth / 2, 0);
          rightDoor.castShadow = true;
          group.add(rightDoor);

          // Panel details on each door
          const panelMat = new THREE.MeshStandardMaterial({
            color: adjustColorBrightness(doorColor, -20),
            roughness: 0.5
          });
          [-1, 1].forEach(side => {
            const panelTop = new THREE.Mesh(
              new THREE.BoxGeometry(doorW * 0.7, h * 0.3, 0.02),
              panelMat
            );
            panelTop.position.set(side * (doorW / 2 + doorGap / 2), h * 0.15, 0.05);
            group.add(panelTop);

            const panelBottom = new THREE.Mesh(
              new THREE.BoxGeometry(doorW * 0.7, h * 0.3, 0.02),
              panelMat
            );
            panelBottom.position.set(side * (doorW / 2 + doorGap / 2), -h * 0.25, 0.05);
            group.add(panelBottom);
          });

          // Frame - top
          const topFrame = new THREE.Mesh(
            new THREE.BoxGeometry(w + frameWidth * 2, frameWidth, frameDepth),
            dblFrameMat
          );
          topFrame.position.set(0, h / 2, 0);
          group.add(topFrame);

          // Frame - left
          const leftFrame = new THREE.Mesh(
            new THREE.BoxGeometry(frameWidth, h, frameDepth),
            dblFrameMat
          );
          leftFrame.position.set(-w / 2 - frameWidth / 2, 0, 0);
          group.add(leftFrame);

          // Frame - right
          const rightFrame = new THREE.Mesh(
            new THREE.BoxGeometry(frameWidth, h, frameDepth),
            dblFrameMat
          );
          rightFrame.position.set(w / 2 + frameWidth / 2, 0, 0);
          group.add(rightFrame);

          // Handles (lever style)
          const handleMat = new THREE.MeshStandardMaterial({
            color: 0xC0C0C0,
            metalness: 0.8,
            roughness: 0.2
          });

          // Left door handle
          const leftHandlePlate = new THREE.Mesh(
            new THREE.BoxGeometry(0.05, 0.12, 0.02),
            handleMat
          );
          leftHandlePlate.position.set(-doorGap / 2 - 0.08, 0, 0.06);
          group.add(leftHandlePlate);

          const leftLever = new THREE.Mesh(
            new THREE.BoxGeometry(0.1, 0.025, 0.025),
            handleMat
          );
          leftLever.position.set(-doorGap / 2 - 0.12, 0, 0.08);
          group.add(leftLever);

          // Right door handle
          const rightHandlePlate = new THREE.Mesh(
            new THREE.BoxGeometry(0.05, 0.12, 0.02),
            handleMat
          );
          rightHandlePlate.position.set(doorGap / 2 + 0.08, 0, 0.06);
          group.add(rightHandlePlate);

          const rightLever = new THREE.Mesh(
            new THREE.BoxGeometry(0.1, 0.025, 0.025),
            handleMat
          );
          rightLever.position.set(doorGap / 2 + 0.12, 0, 0.08);
          group.add(rightLever);

          break;
        }

        case 'sliding-door':
        case 'glass-door':
        case 'french-door': {
          // Professional door variants with proper architectural details
          const isSliding = el.type === 'sliding-door';
          const isFrench = el.type === 'french-door';

          // Materials based on door type
          const frameColor = isSliding ? 0x8A8A8A : (isFrench ? 0xF5F0E6 : 0xFFFFFF);
          const frameMat = new THREE.MeshStandardMaterial({
            color: frameColor,
            roughness: isSliding ? 0.3 : 0.45,
            metalness: isSliding ? 0.6 : 0.1
          });
          const hardwareMat = new THREE.MeshStandardMaterial({
            color: 0xC0C0C0,
            roughness: 0.15,
            metalness: 0.9
          });
          const rubberMat = new THREE.MeshStandardMaterial({
            color: 0x1a1a1a,
            roughness: 0.9
          });

          // Frame dimensions (construction standard)
          const frameDepth = 0.30; // ~3.6" frame depth (wall thickness)
          const frameWidth = isSliding ? 0.12 : 0.17; // Frame profile: sliding 1.5", french/glass 2"

          // Outdoor palette
          const outdoorPalette = OUTDOOR_COLORS[sceneSettings.timeOfDay] || OUTDOOR_COLORS.noon;

          // === OUTDOOR VIEW (behind door) ===
          const skyMat = new THREE.MeshBasicMaterial({ color: outdoorPalette.sky, side: THREE.DoubleSide });
          const skyPane = new THREE.Mesh(
            new THREE.PlaneGeometry(w - frameWidth * 2 - 0.1, h - frameWidth * 2),
            skyMat
          );
          skyPane.position.z = -frameDepth/2 + 0.01;
          group.add(skyPane);

          const horizonMat = new THREE.MeshBasicMaterial({ color: outdoorPalette.horizon });
          const horizonPane = new THREE.Mesh(
            new THREE.PlaneGeometry(w - frameWidth * 2 - 0.1, h * 0.35),
            horizonMat
          );
          horizonPane.position.set(0, -h * 0.32, -frameDepth/2 + 0.015);
          group.add(horizonPane);

          if (sceneSettings.timeOfDay !== 'night') {
            const treeMat = new THREE.MeshBasicMaterial({ color: 0x228B22 });
            for (let i = 0; i < 4; i++) {
              const treeH = 0.4 + Math.random() * 0.25;
              const tree = new THREE.Mesh(new THREE.ConeGeometry(treeH * 0.4, treeH, 6), treeMat);
              tree.position.set((i - 1.5) * w * 0.25, -h * 0.15 + Math.random() * 0.1, -frameDepth/2 + 0.02);
              group.add(tree);
            }
          } else {
            const starMat = new THREE.MeshBasicMaterial({ color: 0xFFFFFF });
            for (let i = 0; i < 12; i++) {
              const star = new THREE.Mesh(new THREE.SphereGeometry(0.015, 4, 4), starMat);
              star.position.set(
                (Math.random() - 0.5) * (w - 0.3),
                h * 0.1 + Math.random() * h * 0.35,
                -frameDepth/2 + 0.02
              );
              group.add(star);
            }
            const moonMat = new THREE.MeshBasicMaterial({ color: 0xFFFACD });
            const moon = new THREE.Mesh(new THREE.CircleGeometry(0.1, 16), moonMat);
            moon.position.set(w * 0.3, h * 0.3, -frameDepth/2 + 0.02);
            group.add(moon);
          }

          // Glass material
          const glassColor = sceneSettings.timeOfDay === 'night' ? 0x2a3a5a : 0xADD8E6;
          const glassMat = new THREE.MeshStandardMaterial({
            color: glassColor,
            transparent: true,
            opacity: 0.15,
            roughness: 0.02,
            metalness: 0.3
          });

          if (isSliding) {
            // === SLIDING PATIO DOOR ===
            // Aluminum frame system with tracks

            // Main frame (jambs, head, sill)
            // Head
            const head = new THREE.Mesh(
              new THREE.BoxGeometry(w, frameWidth, frameDepth),
              frameMat
            );
            head.position.set(0, h/2 - frameWidth/2, 0);
            head.castShadow = true;
            group.add(head);

            // Side jambs
            [-1, 1].forEach(side => {
              const jamb = new THREE.Mesh(
                new THREE.BoxGeometry(frameWidth, h - frameWidth, frameDepth),
                frameMat
              );
              jamb.position.set(side * (w/2 - frameWidth/2), -frameWidth/2, 0);
              jamb.castShadow = true;
              group.add(jamb);
            });

            // Sill/track assembly
            const sillMat = new THREE.MeshStandardMaterial({ color: 0x666666, roughness: 0.4, metalness: 0.5 });
            const sill = new THREE.Mesh(
              new THREE.BoxGeometry(w, 0.06, frameDepth + 0.1),
              sillMat
            );
            sill.position.set(0, -h/2 + 0.03, 0.05);
            group.add(sill);

            // Track channels in sill
            [-1, 1].forEach((track, idx) => {
              const trackChannel = new THREE.Mesh(
                new THREE.BoxGeometry(w - frameWidth * 2, 0.015, 0.025),
                new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.5 })
              );
              trackChannel.position.set(0, -h/2 + 0.045, track * 0.025);
              group.add(trackChannel);
            });

            // Panel dimensions
            const panelW = (w - frameWidth * 2) / 2 + 0.02;
            const panelH = h - frameWidth - 0.06;
            const stileWidth = 0.05; // Vertical frame members
            const railHeight = 0.06; // Horizontal frame members

            // Fixed panel (left/exterior)
            const fixedPanelGroup = new THREE.Group();

            // Stiles (vertical members)
            [-1, 1].forEach(side => {
              const stile = new THREE.Mesh(
                new THREE.BoxGeometry(stileWidth, panelH, 0.04),
                frameMat
              );
              stile.position.set(side * (panelW/2 - stileWidth/2), 0, 0);
              fixedPanelGroup.add(stile);
            });

            // Rails (horizontal members)
            [-1, 1].forEach(pos => {
              const rail = new THREE.Mesh(
                new THREE.BoxGeometry(panelW, railHeight, 0.04),
                frameMat
              );
              rail.position.set(0, pos * (panelH/2 - railHeight/2), 0);
              fixedPanelGroup.add(rail);
            });

            // Glass
            const fixedGlass = new THREE.Mesh(
              new THREE.PlaneGeometry(panelW - stileWidth * 2 - 0.02, panelH - railHeight * 2 - 0.02),
              glassMat
            );
            fixedGlass.position.z = 0.01;
            fixedPanelGroup.add(fixedGlass);

            fixedPanelGroup.position.set(-panelW/2 + 0.01, -frameWidth/2 - 0.03 + panelH/2, -0.025);
            group.add(fixedPanelGroup);

            // Sliding panel (right/interior) - slightly in front
            const slidePanelGroup = new THREE.Group();

            [-1, 1].forEach(side => {
              const stile = new THREE.Mesh(
                new THREE.BoxGeometry(stileWidth, panelH, 0.04),
                frameMat
              );
              stile.position.set(side * (panelW/2 - stileWidth/2), 0, 0);
              slidePanelGroup.add(stile);
            });

            [-1, 1].forEach(pos => {
              const rail = new THREE.Mesh(
                new THREE.BoxGeometry(panelW, railHeight, 0.04),
                frameMat
              );
              rail.position.set(0, pos * (panelH/2 - railHeight/2), 0);
              slidePanelGroup.add(rail);
            });

            const slideGlass = new THREE.Mesh(
              new THREE.PlaneGeometry(panelW - stileWidth * 2 - 0.02, panelH - railHeight * 2 - 0.02),
              glassMat
            );
            slideGlass.position.z = 0.01;
            slidePanelGroup.add(slideGlass);

            // Handle on sliding panel
            const handlePlate = new THREE.Mesh(
              new THREE.BoxGeometry(0.025, 0.2, 0.015),
              hardwareMat
            );
            handlePlate.position.set(-panelW/2 + stileWidth + 0.03, 0, 0.03);
            slidePanelGroup.add(handlePlate);

            const handleGrip = new THREE.Mesh(
              new THREE.BoxGeometry(0.02, 0.12, 0.025),
              hardwareMat
            );
            handleGrip.position.set(-panelW/2 + stileWidth + 0.045, 0, 0.04);
            slidePanelGroup.add(handleGrip);

            // Rollers (visible at bottom)
            [-0.15, 0.15].forEach(rx => {
              const roller = new THREE.Mesh(
                new THREE.CylinderGeometry(0.015, 0.015, 0.02, 12),
                new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.6 })
              );
              roller.rotation.x = Math.PI / 2;
              roller.position.set(rx * panelW, -panelH/2 + 0.01, 0.02);
              slidePanelGroup.add(roller);
            });

            slidePanelGroup.position.set(panelW/2 - 0.01, -frameWidth/2 - 0.03 + panelH/2, 0.025);
            group.add(slidePanelGroup);

            // Interlock (where panels meet)
            const interlock = new THREE.Mesh(
              new THREE.BoxGeometry(0.02, panelH - 0.1, 0.06),
              frameMat
            );
            interlock.position.set(0, -frameWidth/2 - 0.03 + panelH/2, 0);
            group.add(interlock);

            // Weather stripping
            const weatherStrip = new THREE.Mesh(
              new THREE.BoxGeometry(0.01, panelH, 0.02),
              rubberMat
            );
            weatherStrip.position.set(-w/2 + frameWidth + 0.005, -frameWidth/2 - 0.03 + panelH/2, 0);
            group.add(weatherStrip);

          } else if (isFrench) {
            // === FRENCH DOORS (Double doors with true divided lites) ===
            const doorColor = el.color ? parseInt(el.color.replace('#', ''), 16) : 0xF5F0E6;
            const doorMat = new THREE.MeshStandardMaterial({
              color: doorColor,
              roughness: 0.5
            });

            // Frame (jambs, head)
            const head = new THREE.Mesh(
              new THREE.BoxGeometry(w + 0.05, frameWidth, frameDepth),
              frameMat
            );
            head.position.set(0, h/2 - frameWidth/2, 0);
            head.castShadow = true;
            group.add(head);

            [-1, 1].forEach(side => {
              const jamb = new THREE.Mesh(
                new THREE.BoxGeometry(frameWidth, h, frameDepth),
                frameMat
              );
              jamb.position.set(side * (w/2 + frameWidth/2 - 0.025), 0, 0);
              jamb.castShadow = true;
              group.add(jamb);
            });

            // Threshold
            const thresholdMat = new THREE.MeshStandardMaterial({ color: 0x8B7355, roughness: 0.6 });
            const threshold = new THREE.Mesh(
              new THREE.BoxGeometry(w, 0.04, frameDepth + 0.08),
              thresholdMat
            );
            threshold.position.set(0, -h/2 + 0.02, 0.04);
            group.add(threshold);

            // Door panels (2)
            const panelW = (w - 0.08) / 2;
            const panelH = h - frameWidth - 0.04;
            const stileWidth = 0.06;
            const topRailH = 0.08;
            const botRailH = 0.25; // Larger bottom rail (kick area)
            const muntinW = 0.025;

            // Calculate lite (glass pane) grid - 10 lite pattern (2 cols x 5 rows)
            const liteCols = 2;
            const liteRows = 5;

            [-1, 1].forEach((side, doorIdx) => {
              const doorGroup = new THREE.Group();

              // Stiles (vertical members)
              [-1, 1].forEach(stSide => {
                const stile = new THREE.Mesh(
                  new THREE.BoxGeometry(stileWidth, panelH, 0.045),
                  doorMat
                );
                stile.position.set(stSide * (panelW/2 - stileWidth/2), 0, 0);
                stile.castShadow = true;
                doorGroup.add(stile);
              });

              // Top rail
              const topRail = new THREE.Mesh(
                new THREE.BoxGeometry(panelW, topRailH, 0.045),
                doorMat
              );
              topRail.position.set(0, panelH/2 - topRailH/2, 0);
              topRail.castShadow = true;
              doorGroup.add(topRail);

              // Bottom rail (kick panel)
              const botRail = new THREE.Mesh(
                new THREE.BoxGeometry(panelW, botRailH, 0.045),
                doorMat
              );
              botRail.position.set(0, -panelH/2 + botRailH/2, 0);
              botRail.castShadow = true;
              doorGroup.add(botRail);

              // Raised panel detail on bottom rail
              const kickPanel = new THREE.Mesh(
                new THREE.BoxGeometry(panelW - stileWidth * 2 - 0.04, botRailH - 0.06, 0.015),
                new THREE.MeshStandardMaterial({ color: adjustColorBrightness(doorColor, -15), roughness: 0.45 })
              );
              kickPanel.position.set(0, -panelH/2 + botRailH/2, 0.03);
              doorGroup.add(kickPanel);

              // Glass area
              const glassAreaW = panelW - stileWidth * 2;
              const glassAreaH = panelH - topRailH - botRailH;
              const glassAreaY = -botRailH/2 + topRailH/2;

              // Muntins (grille bars)
              // Vertical muntins
              for (let c = 1; c < liteCols; c++) {
                const vMuntin = new THREE.Mesh(
                  new THREE.BoxGeometry(muntinW, glassAreaH, muntinW),
                  doorMat
                );
                vMuntin.position.set(-glassAreaW/2 + c * glassAreaW/liteCols, glassAreaY, 0.02);
                doorGroup.add(vMuntin);
              }

              // Horizontal muntins
              for (let r = 1; r < liteRows; r++) {
                const hMuntin = new THREE.Mesh(
                  new THREE.BoxGeometry(glassAreaW, muntinW, muntinW),
                  doorMat
                );
                hMuntin.position.set(0, glassAreaY - glassAreaH/2 + r * glassAreaH/liteRows, 0.02);
                doorGroup.add(hMuntin);
              }

              // Glass panes (individual lites)
              const liteW = (glassAreaW - muntinW * (liteCols - 1)) / liteCols - 0.01;
              const liteH = (glassAreaH - muntinW * (liteRows - 1)) / liteRows - 0.01;

              for (let c = 0; c < liteCols; c++) {
                for (let r = 0; r < liteRows; r++) {
                  const lite = new THREE.Mesh(
                    new THREE.PlaneGeometry(liteW, liteH),
                    glassMat
                  );
                  const liteX = -glassAreaW/2 + liteW/2 + c * (liteW + muntinW) + 0.005;
                  const liteY = glassAreaY + glassAreaH/2 - liteH/2 - r * (liteH + muntinW) - 0.005;
                  lite.position.set(liteX, liteY, 0.01);
                  doorGroup.add(lite);
                }
              }

              // Hinges (3 per door)
              [0.85, 0, -0.85].forEach((hy, hi) => {
                const hinge = new THREE.Mesh(
                  new THREE.BoxGeometry(0.02, 0.1, 0.025),
                  hardwareMat
                );
                hinge.position.set(side * (panelW/2 - stileWidth/2), panelH * 0.4 * hy, 0.035);
                doorGroup.add(hinge);
              });

              // Handle (opposite side from hinges)
              if (doorIdx === 0) {
                // Active door - lever handle
                const handlePlate = new THREE.Mesh(
                  new THREE.BoxGeometry(0.045, 0.18, 0.015),
                  hardwareMat
                );
                handlePlate.position.set(panelW/2 - stileWidth - 0.05, 0, 0.035);
                doorGroup.add(handlePlate);

                const handleLever = new THREE.Mesh(
                  new THREE.CylinderGeometry(0.012, 0.012, 0.12, 8),
                  hardwareMat
                );
                handleLever.rotation.z = Math.PI / 2;
                handleLever.position.set(panelW/2 - stileWidth - 0.02, 0.02, 0.05);
                doorGroup.add(handleLever);

                // Deadbolt
                const deadbolt = new THREE.Mesh(
                  new THREE.CylinderGeometry(0.018, 0.018, 0.02, 12),
                  hardwareMat
                );
                deadbolt.rotation.x = Math.PI / 2;
                deadbolt.position.set(panelW/2 - stileWidth - 0.05, 0.15, 0.035);
                doorGroup.add(deadbolt);
              }

              doorGroup.position.set(side * (panelW/2 + 0.02), (panelH - h)/2 + frameWidth/2 + 0.02, 0.01);
              group.add(doorGroup);
            });

            // Astragal (center mullion where doors meet)
            const astragal = new THREE.Mesh(
              new THREE.BoxGeometry(0.04, h - frameWidth - 0.04, frameDepth * 0.6),
              frameMat
            );
            astragal.position.set(0, -frameWidth/2 - 0.02, frameDepth * 0.15);
            group.add(astragal);

          } else {
            // === SINGLE GLASS DOOR (Commercial style) ===
            // Aluminum storefront door with push bar

            // Frame
            const head = new THREE.Mesh(
              new THREE.BoxGeometry(w + 0.04, frameWidth, frameDepth),
              frameMat
            );
            head.position.set(0, h/2 - frameWidth/2, 0);
            head.castShadow = true;
            group.add(head);

            [-1, 1].forEach(side => {
              const jamb = new THREE.Mesh(
                new THREE.BoxGeometry(frameWidth, h, frameDepth),
                frameMat
              );
              jamb.position.set(side * (w/2 + frameWidth/2 - 0.02), 0, 0);
              jamb.castShadow = true;
              group.add(jamb);
            });

            // Threshold
            const thresholdMat = new THREE.MeshStandardMaterial({ color: 0x808080, roughness: 0.5, metalness: 0.3 });
            const threshold = new THREE.Mesh(
              new THREE.BoxGeometry(w, 0.03, frameDepth + 0.05),
              thresholdMat
            );
            threshold.position.set(0, -h/2 + 0.015, 0.025);
            group.add(threshold);

            // Door panel
            const doorPanelH = h - frameWidth - 0.03;
            const stileW = 0.06;
            const topRailH = 0.06;
            const botRailH = 0.35; // Kick plate area

            // Door frame (stiles and rails)
            [-1, 1].forEach(side => {
              const stile = new THREE.Mesh(
                new THREE.BoxGeometry(stileW, doorPanelH, 0.05),
                frameMat
              );
              stile.position.set(side * (w/2 - stileW/2), -frameWidth/2 - 0.015, 0.02);
              stile.castShadow = true;
              group.add(stile);
            });

            const topRail = new THREE.Mesh(
              new THREE.BoxGeometry(w, topRailH, 0.05),
              frameMat
            );
            topRail.position.set(0, h/2 - frameWidth - topRailH/2, 0.02);
            group.add(topRail);

            // Bottom rail / kick plate
            const kickPlateMat = new THREE.MeshStandardMaterial({ color: 0x888888, roughness: 0.35, metalness: 0.5 });
            const kickPlate = new THREE.Mesh(
              new THREE.BoxGeometry(w - stileW * 2, botRailH, 0.04),
              kickPlateMat
            );
            kickPlate.position.set(0, -h/2 + 0.03 + botRailH/2, 0.03);
            kickPlate.castShadow = true;
            group.add(kickPlate);

            // Main glass panel
            const glassH = doorPanelH - topRailH - botRailH;
            const glassPane = new THREE.Mesh(
              new THREE.PlaneGeometry(w - stileW * 2 - 0.02, glassH - 0.02),
              glassMat
            );
            glassPane.position.set(0, -h/2 + 0.03 + botRailH + glassH/2, 0.025);
            group.add(glassPane);

            // Push bar (panic bar style)
            const pushBarMat = new THREE.MeshStandardMaterial({ color: 0xC0C0C0, roughness: 0.2, metalness: 0.8 });

            // Bar housing
            const barHousing = new THREE.Mesh(
              new THREE.BoxGeometry(w * 0.7, 0.06, 0.04),
              pushBarMat
            );
            barHousing.position.set(0, 0, frameDepth/2 + 0.02);
            group.add(barHousing);

            // Push bar (touchpad)
            const pushBar = new THREE.Mesh(
              new THREE.BoxGeometry(w * 0.6, 0.04, 0.025),
              pushBarMat
            );
            pushBar.position.set(0, 0, frameDepth/2 + 0.055);
            group.add(pushBar);

            // End caps
            [-1, 1].forEach(side => {
              const endCap = new THREE.Mesh(
                new THREE.BoxGeometry(0.04, 0.08, 0.06),
                pushBarMat
              );
              endCap.position.set(side * w * 0.35, 0, frameDepth/2 + 0.03);
              group.add(endCap);
            });

            // Door closer (at top)
            const closerBody = new THREE.Mesh(
              new THREE.BoxGeometry(0.25, 0.06, 0.08),
              new THREE.MeshStandardMaterial({ color: 0x4a4a4a, roughness: 0.4, metalness: 0.3 })
            );
            closerBody.position.set(w * 0.2, h/2 - frameWidth - 0.08, frameDepth/2 + 0.04);
            group.add(closerBody);

            const closerArm = new THREE.Mesh(
              new THREE.BoxGeometry(0.2, 0.02, 0.025),
              hardwareMat
            );
            closerArm.position.set(w * 0.35, h/2 - frameWidth - 0.06, frameDepth/2 + 0.05);
            closerArm.rotation.z = -0.2;
            group.add(closerArm);

            // Pull handle (outside - cylinder style)
            const pullHandle = new THREE.Mesh(
              new THREE.CylinderGeometry(0.015, 0.015, 0.35, 12),
              hardwareMat
            );
            pullHandle.position.set(w/2 - stileW - 0.08, 0, -frameDepth/2 - 0.04);
            group.add(pullHandle);

            // Handle mounts
            [-1, 1].forEach(pos => {
              const mount = new THREE.Mesh(
                new THREE.CylinderGeometry(0.02, 0.02, 0.04, 12),
                hardwareMat
              );
              mount.rotation.x = Math.PI / 2;
              mount.position.set(w/2 - stileW - 0.08, pos * 0.15, -frameDepth/2 - 0.02);
              group.add(mount);
            });
          }

          break;
        }

        case 'window-bay': {
          // Bay window  clean 3-panel architectural window with square frame
          // No angled fins  proper rectangular frame with mullions, glass, bay shelf
          const bayFrameColor = el.frameColor ? parseInt(el.frameColor.replace('#', ''), 16) : 0x3D2B1F;
          const bayFrameMat = new THREE.MeshStandardMaterial({ color: bayFrameColor, roughness: 0.35, metalness: 0.1 });
          const bayGlassColor = sceneSettings.timeOfDay === 'night' ? 0x2a3a5a : 0xADD8E6;
          const bayGlassMat = new THREE.MeshStandardMaterial({
            color: bayGlassColor, transparent: true, opacity: 0.15,
            roughness: 0.02, metalness: 0.35, side: THREE.DoubleSide
          });
          const outdoorPaletteBay = OUTDOOR_COLORS[sceneSettings.timeOfDay] || OUTDOOR_COLORS.noon;

          // Construction-standard frame dimensions (in feet)
          const bfw = 0.25;   // 3" frame face width
          const bfd = 0.25;   // 3" frame depth
          const bmw = 0.20;   // 2.4" mullion width
          const bmun = 0.04;  // ~0.5" muntin bar

          // 3-panel layout: center 50%, each side 25%
          const bCenterW = w * 0.5;
          const bGlassH = h - bfw * 2;

          // Glass panel dimensions (computed from frame geometry)
          const bCGlassW = bCenterW - bmw;
          const bSGlassW = w / 2 - bfw - bCenterW / 2 - bmw / 2;
          const bSGlassX = (w / 2 - bfw + bCenterW / 2 + bmw / 2) / 2;
          const bGlassZ = -bfd / 2 + 0.02;

          // === OUTER FRAME (head, sill, jambs) ===
          const bHead = new THREE.Mesh(new THREE.BoxGeometry(w, bfw, bfd), bayFrameMat);
          bHead.position.set(0, h / 2 - bfw / 2, 0);
          bHead.castShadow = true;
          group.add(bHead);

          const bSillD = bfd + 0.15;
          const bSill = new THREE.Mesh(new THREE.BoxGeometry(w + 0.12, bfw * 1.1, bSillD), bayFrameMat);
          bSill.position.set(0, -h / 2 + bfw * 0.55, (bSillD - bfd) / 2);
          bSill.castShadow = true;
          group.add(bSill);

          [-1, 1].forEach(side => {
            const bJamb = new THREE.Mesh(new THREE.BoxGeometry(bfw, bGlassH, bfd), bayFrameMat);
            bJamb.position.set(side * (w / 2 - bfw / 2), 0, 0);
            bJamb.castShadow = true;
            group.add(bJamb);
          });

          // === MULLIONS (vertical dividers between 3 panels) ===
          [-1, 1].forEach(side => {
            const bMull = new THREE.Mesh(new THREE.BoxGeometry(bmw, bGlassH, bfd), bayFrameMat);
            bMull.position.set(side * bCenterW / 2, 0, 0);
            group.add(bMull);
          });

          // === MUNTINS (subdivide panes) ===
          // Center panel: cross pattern  4 panes
          const bCHMunt = new THREE.Mesh(new THREE.BoxGeometry(bCGlassW, bmun, bmun), bayFrameMat);
          bCHMunt.position.set(0, 0, bfd / 4);
          group.add(bCHMunt);
          const bCVMunt = new THREE.Mesh(new THREE.BoxGeometry(bmun, bGlassH, bmun), bayFrameMat);
          bCVMunt.position.set(0, 0, bfd / 4);
          group.add(bCVMunt);

          // Side panels: horizontal muntin  2 panes each
          [-1, 1].forEach(side => {
            const bSHMunt = new THREE.Mesh(new THREE.BoxGeometry(bSGlassW, bmun, bmun), bayFrameMat);
            bSHMunt.position.set(side * bSGlassX, 0, bfd / 4);
            group.add(bSHMunt);
          });

          // === GLASS PANELS ===
          const bCGlass = new THREE.Mesh(new THREE.PlaneGeometry(bCGlassW, bGlassH), bayGlassMat);
          bCGlass.position.set(0, 0, bGlassZ);
          group.add(bCGlass);

          [-1, 1].forEach(side => {
            const bSGlass = new THREE.Mesh(new THREE.PlaneGeometry(bSGlassW, bGlassH), bayGlassMat);
            bSGlass.position.set(side * bSGlassX, 0, bGlassZ);
            group.add(bSGlass);
          });

          // === OUTDOOR VIEW (sky + horizon behind glass) ===
          const bSkyMat = new THREE.MeshBasicMaterial({ color: outdoorPaletteBay.sky, side: THREE.DoubleSide });
          const bHorizMat = new THREE.MeshBasicMaterial({ color: outdoorPaletteBay.horizon || 0x87CEEB, side: THREE.DoubleSide });
          const bSkyH = bGlassH * 0.65;
          const bHorizH = bGlassH * 0.35;
          const bSkyZ = bGlassZ - 0.03;

          // Center sky + horizon
          const bCSky = new THREE.Mesh(new THREE.PlaneGeometry(bCGlassW, bSkyH), bSkyMat);
          bCSky.position.set(0, bGlassH * 0.175, bSkyZ);
          group.add(bCSky);
          const bCHoriz = new THREE.Mesh(new THREE.PlaneGeometry(bCGlassW, bHorizH), bHorizMat);
          bCHoriz.position.set(0, -bGlassH * 0.325, bSkyZ);
          group.add(bCHoriz);

          // Side sky + horizon
          [-1, 1].forEach(side => {
            const bSSky = new THREE.Mesh(new THREE.PlaneGeometry(bSGlassW, bSkyH), bSkyMat);
            bSSky.position.set(side * bSGlassX, bGlassH * 0.175, bSkyZ);
            group.add(bSSky);
            const bSHoriz = new THREE.Mesh(new THREE.PlaneGeometry(bSGlassW, bHorizH), bHorizMat);
            bSHoriz.position.set(side * bSGlassX, -bGlassH * 0.325, bSkyZ);
            group.add(bSHoriz);
          });

          // Trees
          if (sceneSettings.timeOfDay !== 'night') {
            const bTreeMat = new THREE.MeshBasicMaterial({ color: 0x228B22 });
            for (let t = 0; t < 3; t++) {
              const treeSize = 0.15 + Math.random() * 0.15;
              const bTree = new THREE.Mesh(new THREE.ConeGeometry(treeSize, treeSize * 2, 6), bTreeMat);
              bTree.position.set((t - 1) * bCGlassW * 0.3, -bGlassH * 0.15, bSkyZ - 0.01);
              group.add(bTree);
            }
          }

          // === BAY SHELF (projects into room as window seat) ===
          const bShelfDepth = 0.8;
          const bShelfMat = new THREE.MeshStandardMaterial({ color: bayFrameColor, roughness: 0.4, metalness: 0.05 });
          const bBayShelf = new THREE.Mesh(new THREE.BoxGeometry(w, 0.06, bShelfDepth), bShelfMat);
          bBayShelf.position.set(0, -h / 2 + bfw * 1.1 + 0.03, bfd / 2 + bShelfDepth / 2);
          bBayShelf.castShadow = true;
          group.add(bBayShelf);

          // === HEADER CROWN (trim above window) ===
          const bHeaderCap = new THREE.Mesh(new THREE.BoxGeometry(w + 0.06, 0.05, bfd + 0.06), bShelfMat);
          bHeaderCap.position.set(0, h / 2 + 0.025, 0.03);
          group.add(bHeaderCap);

          // === APRON (trim below sill, interior side) ===
          const bApron = new THREE.Mesh(new THREE.BoxGeometry(w - 0.1, 0.08, 0.04), bShelfMat);
          bApron.position.set(0, -h / 2 - 0.04, bfd / 2 + 0.02);
          group.add(bApron);

          break;
        }

        case 'window-large': {
          // Dead code  window-large is caught by the professional window case above.
          // Kept for fallback safety only.
          const wlFrameMat = new THREE.MeshStandardMaterial({ color: 0x3D2B1F, roughness: 0.35 });
          const wlOutdoor = OUTDOOR_COLORS[sceneSettings.timeOfDay] || OUTDOOR_COLORS.noon;

          const wlFrame = new THREE.Mesh(new THREE.BoxGeometry(w, h, 0.15), wlFrameMat);
          group.add(wlFrame);
          const wlSky = new THREE.Mesh(new THREE.BoxGeometry(w - 0.2, h - 0.2, 0.01), new THREE.MeshBasicMaterial({ color: wlOutdoor.sky }));
          wlSky.position.z = -0.05;
          group.add(wlSky);
          const wlGlass = new THREE.Mesh(new THREE.BoxGeometry(w - 0.15, h - 0.15, 0.02), new THREE.MeshStandardMaterial({
            color: 0xADD8E6, transparent: true, opacity: 0.15, roughness: 0.05
          }));
          wlGlass.position.z = 0.05;
          group.add(wlGlass);
          break;
        }

        case 'entry-archway': {
          // Simplified archway - dark recessed opening with arch trim
          const archStyle = el.archwayStyle || 'round';
          const archColor = el.color ? parseInt(el.color.replace('#', ''), 16) : 0xDAA520;
          const wallDepth = Math.max(0.5, d || 0.67);
          const archRadius = w / 2;

          // Materials
          const interiorMat = new THREE.MeshStandardMaterial({
            color: 0x1A1A1A,
            roughness: 0.9,
            side: THREE.DoubleSide
          });
          const sideMat = new THREE.MeshStandardMaterial({
            color: 0x2A2A2A,
            roughness: 0.85,
            side: THREE.DoubleSide
          });
          const trimMat = new THREE.MeshStandardMaterial({
            color: archColor,
            roughness: 0.5
          });
          const trimDarkMat = new THREE.MeshStandardMaterial({
            color: adjustColorBrightness(archColor, -30),
            roughness: 0.6
          });

          // === DARK INTERIOR OPENING ===
          // Create arch shape for back wall
          const archShape = new THREE.Shape();
          archShape.moveTo(-w/2, -h/2);
          archShape.lineTo(-w/2, h/2 - archRadius);
          // Arch curve at top
          if (archStyle === 'round') {
            archShape.absarc(0, h/2 - archRadius, archRadius, Math.PI, 0, true);
          } else if (archStyle === 'pointed') {
            // Gothic pointed arch
            archShape.quadraticCurveTo(-w/4, h/2 + archRadius * 0.3, 0, h/2 + archRadius * 0.2);
            archShape.quadraticCurveTo(w/4, h/2 + archRadius * 0.3, w/2, h/2 - archRadius);
          } else if (archStyle === 'elliptical') {
            // Segmental arch
            archShape.absellipse(0, h/2 - archRadius * 0.6, archRadius, archRadius * 0.6, Math.PI, 0, true);
          } else {
            // Flat opening
            archShape.lineTo(w/2, h/2 - archRadius);
            archShape.lineTo(w/2, h/2);
            archShape.lineTo(-w/2, h/2);
          }
          archShape.lineTo(w/2, h/2 - archRadius);
          archShape.lineTo(w/2, -h/2);
          archShape.lineTo(-w/2, -h/2);

          // Back wall (dark opening)
          const backGeom = new THREE.ShapeGeometry(archShape);
          const backWall = new THREE.Mesh(backGeom, interiorMat);
          backWall.position.set(0, 0, -wallDepth);
          group.add(backWall);

          // Side walls (reveals)
          // Left wall
          const leftWall = new THREE.Mesh(
            new THREE.PlaneGeometry(wallDepth, h),
            sideMat
          );
          leftWall.rotation.y = Math.PI / 2;
          leftWall.position.set(-w/2, 0, -wallDepth/2);
          group.add(leftWall);

          // Right wall
          const rightWall = new THREE.Mesh(
            new THREE.PlaneGeometry(wallDepth, h),
            sideMat
          );
          rightWall.rotation.y = -Math.PI / 2;
          rightWall.position.set(w/2, 0, -wallDepth/2);
          group.add(rightWall);

          // Floor of opening
          const floorWall = new THREE.Mesh(
            new THREE.PlaneGeometry(w, wallDepth),
            sideMat
          );
          floorWall.rotation.x = -Math.PI / 2;
          floorWall.position.set(0, -h/2, -wallDepth/2);
          group.add(floorWall);

          // === TRIM/CASING ===
          const trimWidth = 0.12;
          const trimDepth = 0.06;

          // Left trim
          const leftTrim = new THREE.Mesh(
            new THREE.BoxGeometry(trimWidth, h - archRadius, trimDepth),
            trimMat
          );
          leftTrim.position.set(-w/2 - trimWidth/2, -archRadius/2, trimDepth/2);
          group.add(leftTrim);

          // Right trim
          const rightTrim = new THREE.Mesh(
            new THREE.BoxGeometry(trimWidth, h - archRadius, trimDepth),
            trimMat
          );
          rightTrim.position.set(w/2 + trimWidth/2, -archRadius/2, trimDepth/2);
          group.add(rightTrim);

          // Arch curve trim (simplified as segments)
          if (archStyle === 'round' || archStyle === 'elliptical') {
            const numSegs = 12;
            for (let i = 0; i < numSegs; i++) {
              const a1 = Math.PI * (i / numSegs);
              const a2 = Math.PI * ((i + 1) / numSegs);
              const r = archRadius + trimWidth/2;

              const x1 = -Math.cos(a1) * r;
              const y1 = (h/2 - archRadius) + Math.sin(a1) * (archStyle === 'elliptical' ? archRadius * 0.6 : archRadius);
              const x2 = -Math.cos(a2) * r;
              const y2 = (h/2 - archRadius) + Math.sin(a2) * (archStyle === 'elliptical' ? archRadius * 0.6 : archRadius);

              const segLen = Math.sqrt((x2-x1)**2 + (y2-y1)**2);
              const segAng = Math.atan2(y2-y1, x2-x1);

              const archSeg = new THREE.Mesh(
                new THREE.BoxGeometry(segLen * 1.1, trimWidth, trimDepth),
                trimMat
              );
              archSeg.position.set((x1+x2)/2, (y1+y2)/2, trimDepth/2);
              archSeg.rotation.z = segAng;
              group.add(archSeg);
            }
          } else {
            // Flat header
            const headerTrim = new THREE.Mesh(
              new THREE.BoxGeometry(w + trimWidth * 2, trimWidth, trimDepth),
              trimMat
            );
            headerTrim.position.set(0, h/2 + trimWidth/2, trimDepth/2);
            group.add(headerTrim);
          }

          // Keystone (decorative center block at top)
          const keystoneMat = new THREE.MeshStandardMaterial({
            color: adjustColorBrightness(archColor, 15),
            roughness: 0.45
          });
          const keystone = new THREE.Mesh(
            new THREE.BoxGeometry(trimWidth * 1.5, trimWidth * 1.8, trimDepth * 1.2),
            keystoneMat
          );
          const keystoneY = archStyle === 'flat' ? h/2 + trimWidth/2 :
                           (archStyle === 'pointed' ? h/2 + archRadius * 0.2 : h/2);
          keystone.position.set(0, keystoneY, trimDepth * 0.6);
          group.add(keystone);

          // Base blocks (plinths at bottom of trim)
          [-1, 1].forEach(side => {
            const plinth = new THREE.Mesh(
              new THREE.BoxGeometry(trimWidth * 1.3, trimWidth * 0.8, trimDepth * 1.1),
              trimDarkMat
            );
            plinth.position.set(side * (w/2 + trimWidth/2), -h/2 + trimWidth * 0.4, trimDepth * 0.55);
            group.add(plinth);
          });

          break;
        }

        case 'garage-door': {
          // Garage door with proper sectional panel construction
          const doorColor = el.color ? parseInt(el.color.replace('#', ''), 16) : 0xD4D4D4;

          // Materials
          const doorMat = new THREE.MeshStandardMaterial({
            color: doorColor,
            roughness: 0.6,
            metalness: 0.1
          });
          const panelMat = new THREE.MeshStandardMaterial({
            color: adjustColorBrightness(doorColor, -15),
            roughness: 0.5
          });
          const recessMat = new THREE.MeshStandardMaterial({
            color: adjustColorBrightness(doorColor, -30),
            roughness: 0.7
          });
          const hardwareMat = new THREE.MeshStandardMaterial({
            color: 0x3A3A3A,
            roughness: 0.3,
            metalness: 0.7
          });
          const frameMat = new THREE.MeshStandardMaterial({
            color: 0x4A4A4A,
            roughness: 0.5
          });
          const weatherMat = new THREE.MeshStandardMaterial({
            color: 0x2A2A2A,
            roughness: 0.9
          });

          // Door dimensions
          const doorDepth = 0.08;
          const frameWidth = 0.15;
          const sections = 4; // Horizontal sections
          const panelsPerSection = 3; // Raised panels per section
          const sectionHeight = h / sections;
          const panelGap = 0.03;

          // === DOOR FRAME (trim around opening) ===
          // Top frame
          const topFrame = new THREE.Mesh(
            new THREE.BoxGeometry(w + frameWidth * 2, frameWidth, doorDepth + 0.1),
            frameMat
          );
          topFrame.position.set(0, h/2 + frameWidth/2, 0);
          topFrame.castShadow = true;
          group.add(topFrame);

          // Left frame
          const leftFrame = new THREE.Mesh(
            new THREE.BoxGeometry(frameWidth, h + frameWidth, doorDepth + 0.1),
            frameMat
          );
          leftFrame.position.set(-w/2 - frameWidth/2, frameWidth/2, 0);
          leftFrame.castShadow = true;
          group.add(leftFrame);

          // Right frame
          const rightFrame = new THREE.Mesh(
            new THREE.BoxGeometry(frameWidth, h + frameWidth, doorDepth + 0.1),
            frameMat
          );
          rightFrame.position.set(w/2 + frameWidth/2, frameWidth/2, 0);
          rightFrame.castShadow = true;
          group.add(rightFrame);

          // === DOOR SECTIONS (4 horizontal panels) ===
          for (let sec = 0; sec < sections; sec++) {
            const secY = h/2 - sectionHeight/2 - sec * sectionHeight;

            // Section base panel
            const sectionPanel = new THREE.Mesh(
              new THREE.BoxGeometry(w - panelGap, sectionHeight - panelGap, doorDepth),
              doorMat
            );
            sectionPanel.position.set(0, secY, 0);
            sectionPanel.castShadow = true;
            sectionPanel.receiveShadow = true;
            group.add(sectionPanel);

            // Raised panels within each section
            const panelWidth = (w - panelGap * 4) / panelsPerSection;
            const panelHeight = sectionHeight - panelGap * 2 - 0.06;

            for (let p = 0; p < panelsPerSection; p++) {
              const panelX = -w/2 + panelGap * 1.5 + panelWidth/2 + p * (panelWidth + panelGap);

              // Raised panel face
              const raisedPanel = new THREE.Mesh(
                new THREE.BoxGeometry(panelWidth - 0.04, panelHeight, 0.02),
                panelMat
              );
              raisedPanel.position.set(panelX, secY, doorDepth/2 + 0.01);
              group.add(raisedPanel);

              // Panel recess (shadow line around raised panel)
              const recessDepth = 0.015;
              // Top recess
              const topRecess = new THREE.Mesh(
                new THREE.BoxGeometry(panelWidth - 0.02, 0.02, recessDepth),
                recessMat
              );
              topRecess.position.set(panelX, secY + panelHeight/2 + 0.01, doorDepth/2 - recessDepth/2);
              group.add(topRecess);

              // Bottom recess
              const botRecess = new THREE.Mesh(
                new THREE.BoxGeometry(panelWidth - 0.02, 0.02, recessDepth),
                recessMat
              );
              botRecess.position.set(panelX, secY - panelHeight/2 - 0.01, doorDepth/2 - recessDepth/2);
              group.add(botRecess);
            }

            // Section joint line (horizontal gap between sections)
            if (sec < sections - 1) {
              const jointLine = new THREE.Mesh(
                new THREE.BoxGeometry(w, 0.01, 0.01),
                weatherMat
              );
              jointLine.position.set(0, secY - sectionHeight/2, doorDepth/2);
              group.add(jointLine);
            }

            // Hardware - Hinges (2 per section side)
            [-1, 1].forEach(side => {
              const hingeY = secY;
              const hinge = new THREE.Mesh(
                new THREE.BoxGeometry(0.05, 0.12, 0.03),
                hardwareMat
              );
              hinge.position.set(side * (w/2 - 0.06), hingeY, doorDepth/2 + 0.02);
              group.add(hinge);

              // Hinge roller bracket
              const bracket = new THREE.Mesh(
                new THREE.BoxGeometry(0.08, 0.04, 0.02),
                hardwareMat
              );
              bracket.position.set(side * (w/2 - 0.06), hingeY - 0.08, doorDepth/2 + 0.015);
              group.add(bracket);
            });
          }

          // === WINDOW PANELS (top section) ===
          const hasWindows = w > 7; // Windows only on wide doors
          if (hasWindows) {
            const windowGlassMat = new THREE.MeshStandardMaterial({
              color: 0x87CEEB,
              transparent: true,
              opacity: 0.3,
              roughness: 0.1
            });
            const windowFrameMat = new THREE.MeshStandardMaterial({
              color: 0x666666,
              roughness: 0.4
            });

            const windowsPerSection = Math.floor((w - 0.5) / 1.5);
            const windowWidth = 0.8;
            const windowHeight = sectionHeight * 0.6;
            const topSecY = h/2 - sectionHeight/2;

            for (let wn = 0; wn < windowsPerSection; wn++) {
              const wnX = -w/2 + 0.5 + windowWidth/2 + wn * (w - 0.5) / windowsPerSection;

              // Window frame
              const wnFrame = new THREE.Mesh(
                new THREE.BoxGeometry(windowWidth + 0.04, windowHeight + 0.04, 0.025),
                windowFrameMat
              );
              wnFrame.position.set(wnX, topSecY, doorDepth/2 + 0.02);
              group.add(wnFrame);

              // Window glass
              const wnGlass = new THREE.Mesh(
                new THREE.BoxGeometry(windowWidth, windowHeight, 0.01),
                windowGlassMat
              );
              wnGlass.position.set(wnX, topSecY, doorDepth/2 + 0.03);
              group.add(wnGlass);

              // Window muntins (cross pattern)
              const muntinMat = new THREE.MeshStandardMaterial({ color: 0x555555, roughness: 0.4 });
              const vMuntin = new THREE.Mesh(
                new THREE.BoxGeometry(0.02, windowHeight, 0.015),
                muntinMat
              );
              vMuntin.position.set(wnX, topSecY, doorDepth/2 + 0.035);
              group.add(vMuntin);

              const hMuntin = new THREE.Mesh(
                new THREE.BoxGeometry(windowWidth, 0.02, 0.015),
                muntinMat
              );
              hMuntin.position.set(wnX, topSecY, doorDepth/2 + 0.035);
              group.add(hMuntin);
            }
          }

          // === BOTTOM SEAL (weather stripping) ===
          const bottomSeal = new THREE.Mesh(
            new THREE.BoxGeometry(w, 0.04, 0.06),
            weatherMat
          );
          bottomSeal.position.set(0, -h/2 + 0.02, doorDepth/2);
          group.add(bottomSeal);

          // === HANDLE (lift handle at bottom) ===
          const handleBase = new THREE.Mesh(
            new THREE.BoxGeometry(0.35, 0.08, 0.04),
            hardwareMat
          );
          handleBase.position.set(0, -h/2 + sectionHeight/2, doorDepth/2 + 0.03);
          group.add(handleBase);

          const handleGrip = new THREE.Mesh(
            new THREE.BoxGeometry(0.25, 0.04, 0.08),
            hardwareMat
          );
          handleGrip.position.set(0, -h/2 + sectionHeight/2, doorDepth/2 + 0.08);
          group.add(handleGrip);

          break;
        }

        case 'crown-molding': {
          // Crown molding with ornate profile
          const moldColor = el.color ? parseInt(el.color.replace('#', '0x')) : 0xF5F5F5;
          const moldMat = new THREE.MeshStandardMaterial({ color: moldColor, roughness: 0.4 });

          // Create crown molding profile shape
          const crownShape = new THREE.Shape();
          const mh = 0.25; // molding height
          const md = 0.2;  // molding depth

          // Ornate crown profile
          crownShape.moveTo(0, 0);
          crownShape.lineTo(md, 0);
          crownShape.lineTo(md, mh * 0.1);
          crownShape.quadraticCurveTo(md * 0.9, mh * 0.2, md * 0.85, mh * 0.3);
          crownShape.quadraticCurveTo(md * 0.75, mh * 0.5, md * 0.6, mh * 0.6);
          crownShape.bezierCurveTo(md * 0.4, mh * 0.75, md * 0.2, mh * 0.9, 0, mh);
          crownShape.lineTo(0, 0);

          const extrudeSettings = { steps: 1, depth: w, bevelEnabled: false };
          const crownGeom = new THREE.ExtrudeGeometry(crownShape, extrudeSettings);
          crownGeom.rotateY(-Math.PI / 2);
          crownGeom.translate(w/2, 0, 0);

          const crown = new THREE.Mesh(crownGeom, moldMat);
          group.add(crown);

          // Shadow line detail
          const shadowMat = new THREE.MeshStandardMaterial({ color: 0xDDDDDD, roughness: 0.5 });
          const shadowLine = new THREE.Mesh(new THREE.BoxGeometry(w, 0.02, 0.02), shadowMat);
          shadowLine.position.set(0, mh * 0.3, md * 0.7);
          group.add(shadowLine);
          break;
        }

        case 'baseboard': {
          // Baseboard with stepped profile
          const bbColor = el.color ? parseInt(el.color.replace('#', '0x')) : 0xF5F5F5;
          const bbMat = new THREE.MeshStandardMaterial({ color: bbColor, roughness: 0.35 });

          // Create baseboard profile
          const bbShape = new THREE.Shape();
          const bbh = 0.5;  // baseboard height (6 inches)
          const bbd = 0.08; // baseboard depth

          bbShape.moveTo(0, 0);
          bbShape.lineTo(bbd, 0);
          bbShape.lineTo(bbd, bbh * 0.7);
          bbShape.lineTo(bbd * 0.7, bbh * 0.75);
          bbShape.lineTo(bbd * 0.7, bbh * 0.85);
          bbShape.lineTo(bbd * 0.5, bbh * 0.9);
          bbShape.lineTo(bbd * 0.5, bbh);
          bbShape.lineTo(0, bbh);
          bbShape.lineTo(0, 0);

          const bbExtrudeSettings = { steps: 1, depth: w, bevelEnabled: false };
          const bbGeom = new THREE.ExtrudeGeometry(bbShape, bbExtrudeSettings);
          bbGeom.rotateY(-Math.PI / 2);
          bbGeom.translate(w/2, -bbh/2, 0);

          const baseboard = new THREE.Mesh(bbGeom, bbMat);
          group.add(baseboard);
          break;
        }

        case 'chair-rail': {
          // Chair rail molding at mid-height
          const crColor = el.color ? parseInt(el.color.replace('#', '0x')) : 0xF5F5F5;
          const crMat = new THREE.MeshStandardMaterial({ color: crColor, roughness: 0.35 });

          // Create chair rail profile
          const crShape = new THREE.Shape();
          const crh = 0.2;  // chair rail height
          const crd = 0.1;  // chair rail depth

          crShape.moveTo(0, 0);
          crShape.lineTo(crd, 0);
          crShape.lineTo(crd, crh * 0.2);
          crShape.quadraticCurveTo(crd * 0.8, crh * 0.4, crd * 0.7, crh * 0.5);
          crShape.lineTo(crd * 0.7, crh * 0.6);
          crShape.quadraticCurveTo(crd * 0.5, crh * 0.8, 0, crh);
          crShape.lineTo(0, 0);

          const crExtrudeSettings = { steps: 1, depth: w, bevelEnabled: false };
          const crGeom = new THREE.ExtrudeGeometry(crShape, crExtrudeSettings);
          crGeom.rotateY(-Math.PI / 2);
          crGeom.translate(w/2, -crh/2, 0);

          const chairRail = new THREE.Mesh(crGeom, crMat);
          group.add(chairRail);
          break;
        }

        // ===== BATHROOM ELEMENTS =====
        case 'toilet': {
          // Elongated toilet with tank - properly positioned across depth
          const porcelainMat = new THREE.MeshStandardMaterial({
            color: 0xFFFFFF,
            roughness: 0.15,
            metalness: 0.05
          });
          const chromeMat = new THREE.MeshStandardMaterial({
            color: 0xC0C0C0,
            roughness: 0.1,
            metalness: 0.9
          });
          const seatMat = new THREE.MeshStandardMaterial({
            color: 0xF5F5F5,
            roughness: 0.3
          });

          // Calculate proper Z positions
          // Tank at back (-Z), bowl at front (+Z)
          const tankD = 0.6; // Tank depth ~7 inches
          const tankZ = -d / 2 + tankD / 2 + 0.05; // Tank flush with back + small gap
          const bowlZ = d * 0.15; // Bowl forward of center

          // Bowl base
          const bowlBaseH = 0.35;
          const bowlBase = new THREE.Mesh(
            new THREE.CylinderGeometry(w * 0.35, w * 0.4, bowlBaseH, 16),
            porcelainMat
          );
          bowlBase.position.set(0, bowlBaseH / 2 - h / 2, bowlZ);
          group.add(bowlBase);

          // Bowl (elongated shape)
          const bowlH = 0.5;
          const bowlGeom = new THREE.CylinderGeometry(w * 0.42, w * 0.35, bowlH, 16, 1, false);
          const bowl = new THREE.Mesh(bowlGeom, porcelainMat);
          bowl.position.set(0, bowlBaseH + bowlH / 2 - h / 2, bowlZ);
          group.add(bowl);

          // Inner bowl (dark)
          const innerBowlMat = new THREE.MeshStandardMaterial({ color: 0x4a6070, roughness: 0.3 });
          const innerBowl = new THREE.Mesh(
            new THREE.CylinderGeometry(w * 0.32, w * 0.28, 0.3, 16),
            innerBowlMat
          );
          innerBowl.position.set(0, bowlBaseH + bowlH - 0.1 - h / 2, bowlZ);
          group.add(innerBowl);

          // Seat
          const seatH = 0.05;
          const seat = new THREE.Mesh(
            new THREE.CylinderGeometry(w * 0.44, w * 0.44, seatH, 24),
            seatMat
          );
          seat.position.set(0, bowlBaseH + bowlH + seatH / 2 - h / 2, bowlZ);
          group.add(seat);

          // Tank
          const tankW = w * 0.7;
          const tankH = 1.1;
          const tank = new THREE.Mesh(
            new THREE.BoxGeometry(tankW, tankH, tankD),
            porcelainMat
          );
          tank.position.set(0, bowlBaseH + tankH / 2 - h / 2, tankZ);
          group.add(tank);

          // Tank lid
          const lidMat = new THREE.MeshStandardMaterial({ color: 0xF8F8F8, roughness: 0.2 });
          const tankLid = new THREE.Mesh(
            new THREE.BoxGeometry(tankW + 0.05, 0.08, tankD + 0.05),
            lidMat
          );
          tankLid.position.set(0, bowlBaseH + tankH + 0.04 - h / 2, tankZ);
          group.add(tankLid);

          // Flush handle
          const handle = new THREE.Mesh(
            new THREE.BoxGeometry(0.15, 0.04, 0.04),
            chromeMat
          );
          handle.position.set(-tankW / 2 - 0.05, bowlBaseH + tankH * 0.7 - h / 2, tankZ);
          group.add(handle);

          break;
        }

        case 'toilet-round': {
          // Round toilet (more compact bowl) - properly positioned across depth
          const porcelainMat = new THREE.MeshStandardMaterial({
            color: 0xFFFFFF,
            roughness: 0.15,
            metalness: 0.05
          });
          const chromeMat = new THREE.MeshStandardMaterial({
            color: 0xC0C0C0,
            roughness: 0.1,
            metalness: 0.9
          });

          // Calculate proper Z positions
          const tankD = 0.55;
          const tankZ = -d / 2 + tankD / 2 + 0.05; // Tank at back
          const bowlZ = d * 0.12; // Bowl forward of center (slightly less than elongated)

          // Bowl base (rounder)
          const bowlBaseH = 0.35;
          const bowlBase = new THREE.Mesh(
            new THREE.CylinderGeometry(w * 0.38, w * 0.42, bowlBaseH, 16),
            porcelainMat
          );
          bowlBase.position.set(0, bowlBaseH / 2 - h / 2, bowlZ);
          group.add(bowlBase);

          // Bowl (round shape)
          const bowlH = 0.45;
          const bowl = new THREE.Mesh(
            new THREE.SphereGeometry(w * 0.4, 16, 12, 0, Math.PI * 2, 0, Math.PI / 2),
            porcelainMat
          );
          bowl.rotation.x = Math.PI;
          bowl.position.set(0, bowlBaseH + bowlH / 2 - h / 2, bowlZ);
          group.add(bowl);

          // Seat
          const seatMat = new THREE.MeshStandardMaterial({ color: 0xF5F5F5, roughness: 0.3 });
          const seat = new THREE.Mesh(
            new THREE.TorusGeometry(w * 0.35, 0.04, 8, 24),
            seatMat
          );
          seat.rotation.x = Math.PI / 2;
          seat.position.set(0, bowlBaseH + bowlH - h / 2, bowlZ);
          group.add(seat);

          // Tank
          const tankW = w * 0.65;
          const tankH = 1.0;
          const tank = new THREE.Mesh(
            new THREE.BoxGeometry(tankW, tankH, tankD),
            porcelainMat
          );
          tank.position.set(0, bowlBaseH + tankH / 2 - h / 2, tankZ);
          group.add(tank);

          // Tank lid
          const tankLid = new THREE.Mesh(
            new THREE.BoxGeometry(tankW + 0.04, 0.06, tankD + 0.04),
            porcelainMat
          );
          tankLid.position.set(0, bowlBaseH + tankH + 0.03 - h / 2, tankZ);
          group.add(tankLid);

          // Flush handle
          const handleMesh = new THREE.Mesh(
            new THREE.BoxGeometry(0.12, 0.04, 0.04),
            chromeMat
          );
          handleMesh.position.set(-tankW / 2 - 0.04, bowlBaseH + tankH * 0.7 - h / 2, tankZ);
          group.add(handleMesh);

          break;
        }

        case 'toilet-wall': {
          // Wall-hung toilet (no visible tank, modern design)
          const porcelainMat = new THREE.MeshStandardMaterial({
            color: 0xFFFFFF,
            roughness: 0.12,
            metalness: 0.05
          });
          const chromeMat = new THREE.MeshStandardMaterial({
            color: 0xC0C0C0,
            roughness: 0.1,
            metalness: 0.9
          });

          // Wall mounting plate (hidden tank)
          const plateMat = new THREE.MeshStandardMaterial({ color: 0xD0D0D0, roughness: 0.3 });
          const plate = new THREE.Mesh(
            new THREE.BoxGeometry(w * 0.7, 0.8, 0.1),
            plateMat
          );
          plate.position.set(0, 0.2, -d / 2 + 0.05);
          group.add(plate);

          // Flush buttons
          const buttonMat = new THREE.MeshStandardMaterial({ color: 0xE0E0E0, roughness: 0.2 });
          const largeButton = new THREE.Mesh(
            new THREE.BoxGeometry(0.12, 0.08, 0.02),
            buttonMat
          );
          largeButton.position.set(-0.05, 0.5, -d / 2 + 0.11);
          group.add(largeButton);

          const smallButton = new THREE.Mesh(
            new THREE.BoxGeometry(0.08, 0.08, 0.02),
            buttonMat
          );
          smallButton.position.set(0.07, 0.5, -d / 2 + 0.11);
          group.add(smallButton);

          // Bowl (floating, elongated)
          const bowlH = 0.4;
          const bowl = new THREE.Mesh(
            new THREE.CylinderGeometry(w * 0.38, w * 0.35, bowlH, 16),
            porcelainMat
          );
          bowl.rotation.x = Math.PI / 12;
          bowl.position.set(0, -0.1, d * 0.15);
          group.add(bowl);

          // Rim
          const rimMat = new THREE.MeshStandardMaterial({ color: 0xFAFAFA, roughness: 0.1 });
          const rim = new THREE.Mesh(
            new THREE.TorusGeometry(w * 0.36, 0.03, 8, 24),
            rimMat
          );
          rim.rotation.x = Math.PI / 2;
          rim.position.set(0, 0.1, d * 0.15);
          group.add(rim);

          break;
        }

        case 'bidet': {
          // Bidet with spray feature
          const porcelainMat = new THREE.MeshStandardMaterial({
            color: 0xFFFFFF,
            roughness: 0.12,
            metalness: 0.05
          });
          const chromeMat = new THREE.MeshStandardMaterial({
            color: 0xC0C0C0,
            roughness: 0.1,
            metalness: 0.9
          });

          // Base
          const baseH = 0.35;
          const base = new THREE.Mesh(
            new THREE.CylinderGeometry(w * 0.4, w * 0.42, baseH, 16),
            porcelainMat
          );
          base.position.set(0, baseH / 2 - h / 2, 0);
          group.add(base);

          // Basin (oval shape)
          const basinH = 0.3;
          const basin = new THREE.Mesh(
            new THREE.CylinderGeometry(w * 0.42, w * 0.38, basinH, 16),
            porcelainMat
          );
          basin.position.set(0, baseH + basinH / 2 - h / 2, 0);
          group.add(basin);

          // Inner basin (recessed)
          const innerMat = new THREE.MeshStandardMaterial({ color: 0xE8F0F8, roughness: 0.2 });
          const innerBasin = new THREE.Mesh(
            new THREE.CylinderGeometry(w * 0.32, w * 0.28, 0.15, 16),
            innerMat
          );
          innerBasin.position.set(0, baseH + basinH - 0.05 - h / 2, 0);
          group.add(innerBasin);

          // Rim
          const rim = new THREE.Mesh(
            new THREE.TorusGeometry(w * 0.4, 0.03, 8, 24),
            porcelainMat
          );
          rim.rotation.x = Math.PI / 2;
          rim.position.set(0, baseH + basinH + 0.02 - h / 2, 0);
          group.add(rim);

          // Faucet
          const faucetBase = new THREE.Mesh(
            new THREE.CylinderGeometry(0.04, 0.05, 0.06, 12),
            chromeMat
          );
          faucetBase.position.set(0, baseH + basinH + 0.05 - h / 2, -d / 3);
          group.add(faucetBase);

          const spout = new THREE.Mesh(
            new THREE.CylinderGeometry(0.02, 0.02, 0.15, 8),
            chromeMat
          );
          spout.rotation.x = Math.PI / 3;
          spout.position.set(0, baseH + basinH + 0.12 - h / 2, -d / 4);
          group.add(spout);

          // Handles
          [-0.08, 0.08].forEach(offsetX => {
            const handleKnob = new THREE.Mesh(
              new THREE.SphereGeometry(0.025, 8, 8),
              chromeMat
            );
            handleKnob.position.set(offsetX, baseH + basinH + 0.08 - h / 2, -d / 3);
            group.add(handleKnob);
          });

          break;
        }

        case 'bathtub':
        case 'bathtub-freestanding': {
          // Alcove or freestanding bathtub
          const isFreestanding = el.type === 'bathtub-freestanding';
          const tubMat = new THREE.MeshStandardMaterial({
            color: 0xFFFFFF,
            roughness: 0.1,
            metalness: 0.05
          });
          const innerMat = new THREE.MeshStandardMaterial({
            color: 0xE8E8E8,
            roughness: 0.15
          });
          const chromeMat = new THREE.MeshStandardMaterial({
            color: 0xC0C0C0,
            roughness: 0.1,
            metalness: 0.9
          });

          const tubH = isFreestanding ? 1.8 : 1.5;
          const wallThickness = 0.08;

          // Outer tub shell
          const outerTub = new THREE.Mesh(
            new THREE.BoxGeometry(w, tubH, d),
            tubMat
          );
          outerTub.position.set(0, tubH / 2 - h / 2, 0);
          group.add(outerTub);

          // Inner basin (recessed)
          const innerW = w - wallThickness * 2;
          const innerH = tubH - 0.15;
          const innerD = d - wallThickness * 2;
          const innerTub = new THREE.Mesh(
            new THREE.BoxGeometry(innerW, innerH, innerD),
            innerMat
          );
          innerTub.position.set(0, (tubH - innerH) / 2 + tubH / 2 - h / 2, 0);
          group.add(innerTub);

          // Rim
          const rimMat = new THREE.MeshStandardMaterial({ color: 0xFAFAFA, roughness: 0.08 });
          const rim = new THREE.Mesh(
            new THREE.BoxGeometry(w + 0.02, 0.08, d + 0.02),
            rimMat
          );
          rim.position.set(0, tubH + 0.04 - h / 2, 0);
          group.add(rim);

          // Faucet
          const faucetBase = new THREE.Mesh(
            new THREE.CylinderGeometry(0.05, 0.06, 0.08, 16),
            chromeMat
          );
          faucetBase.position.set(0, tubH + 0.1 - h / 2, -d / 2 + 0.2);
          group.add(faucetBase);

          const spout = new THREE.Mesh(
            new THREE.CylinderGeometry(0.025, 0.025, 0.25, 12),
            chromeMat
          );
          spout.rotation.x = Math.PI / 2;
          spout.position.set(0, tubH + 0.15 - h / 2, -d / 2 + 0.32);
          group.add(spout);

          // Drain
          const drainMat = new THREE.MeshStandardMaterial({ color: 0x808080, metalness: 0.7, roughness: 0.3 });
          const drain = new THREE.Mesh(
            new THREE.CylinderGeometry(0.03, 0.03, 0.02, 16),
            drainMat
          );
          drain.position.set(0, 0.1 - h / 2, d / 4);
          group.add(drain);

          if (isFreestanding) {
            // Feet for freestanding tub
            const footMat = new THREE.MeshStandardMaterial({ color: 0xB8860B, roughness: 0.4, metalness: 0.5 });
            const footPositions = [[-w/2 + 0.15, -d/2 + 0.15], [-w/2 + 0.15, d/2 - 0.15], [w/2 - 0.15, -d/2 + 0.15], [w/2 - 0.15, d/2 - 0.15]];
            footPositions.forEach(([fx, fz]) => {
              const foot = new THREE.Mesh(new THREE.SphereGeometry(0.08, 12, 12), footMat);
              foot.position.set(fx, -h / 2 + 0.04, fz);
              group.add(foot);
            });
          }

          break;
        }

        case 'bathtub-corner': {
          // Corner bathtub (triangular/quarter-circle shape)
          const tubMat = new THREE.MeshStandardMaterial({
            color: 0xFFFFFF,
            roughness: 0.1,
            metalness: 0.05
          });
          const innerMat = new THREE.MeshStandardMaterial({
            color: 0xE8F0F8,
            roughness: 0.15
          });
          const chromeMat = new THREE.MeshStandardMaterial({
            color: 0xC0C0C0,
            roughness: 0.1,
            metalness: 0.9
          });

          const tubH = 1.5;
          const wallThickness = 0.08;

          // Create quarter-cylinder shape for corner tub
          const outerRadius = Math.min(w, d) / 2;
          const outerGeom = new THREE.CylinderGeometry(outerRadius, outerRadius, tubH, 16, 1, false, 0, Math.PI / 2);
          const outerTub = new THREE.Mesh(outerGeom, tubMat);
          outerTub.rotation.y = Math.PI;
          outerTub.position.set(-w / 2 + outerRadius, tubH / 2 - h / 2, d / 2 - outerRadius);
          group.add(outerTub);

          // Back walls (to fill the corner)
          const backWall1 = new THREE.Mesh(
            new THREE.BoxGeometry(wallThickness, tubH, d),
            tubMat
          );
          backWall1.position.set(-w / 2 + wallThickness / 2, tubH / 2 - h / 2, 0);
          group.add(backWall1);

          const backWall2 = new THREE.Mesh(
            new THREE.BoxGeometry(w, tubH, wallThickness),
            tubMat
          );
          backWall2.position.set(0, tubH / 2 - h / 2, d / 2 - wallThickness / 2);
          group.add(backWall2);

          // Rim
          const rimMat = new THREE.MeshStandardMaterial({ color: 0xFAFAFA, roughness: 0.08 });
          const rimGeom = new THREE.TorusGeometry(outerRadius - 0.05, 0.05, 8, 12, Math.PI / 2);
          const rim = new THREE.Mesh(rimGeom, rimMat);
          rim.rotation.x = Math.PI / 2;
          rim.rotation.z = Math.PI;
          rim.position.set(-w / 2 + outerRadius, tubH + 0.02 - h / 2, d / 2 - outerRadius);
          group.add(rim);

          // Drain
          const drainMat = new THREE.MeshStandardMaterial({ color: 0x808080, metalness: 0.7, roughness: 0.3 });
          const drain = new THREE.Mesh(
            new THREE.CylinderGeometry(0.04, 0.04, 0.02, 12),
            drainMat
          );
          drain.position.set(0, 0.1 - h / 2, 0);
          group.add(drain);

          // Faucet (corner position)
          const faucetBase = new THREE.Mesh(
            new THREE.CylinderGeometry(0.04, 0.05, 0.08, 12),
            chromeMat
          );
          faucetBase.position.set(-w / 2 + 0.3, tubH + 0.08 - h / 2, d / 2 - 0.3);
          group.add(faucetBase);

          break;
        }

        case 'bathtub-walk-in': {
          // Walk-in bathtub with door
          const tubMat = new THREE.MeshStandardMaterial({
            color: 0xF5F5F5,
            roughness: 0.15,
            metalness: 0.05
          });
          const innerMat = new THREE.MeshStandardMaterial({
            color: 0xE8E8E8,
            roughness: 0.2
          });
          const chromeMat = new THREE.MeshStandardMaterial({
            color: 0xC0C0C0,
            roughness: 0.1,
            metalness: 0.9
          });
          const seatMat = new THREE.MeshStandardMaterial({
            color: 0xF0F0F0,
            roughness: 0.25
          });

          const tubH = 2.8; // Higher walls for walk-in
          const wallThickness = 0.1;

          // Outer shell
          const outerTub = new THREE.Mesh(
            new THREE.BoxGeometry(w, tubH, d),
            tubMat
          );
          outerTub.position.set(0, tubH / 2 - h / 2, 0);
          group.add(outerTub);

          // Inner basin
          const innerW = w - wallThickness * 2;
          const innerH = tubH - 0.15;
          const innerD = d - wallThickness * 2;
          const innerTub = new THREE.Mesh(
            new THREE.BoxGeometry(innerW, innerH, innerD),
            innerMat
          );
          innerTub.position.set(0, (tubH - innerH) / 2 + tubH / 2 - h / 2, 0);
          group.add(innerTub);

          // Built-in seat
          const seatW = w * 0.4;
          const seatH = 1.2;
          const seatD = d - wallThickness * 2;
          const seat = new THREE.Mesh(
            new THREE.BoxGeometry(seatW, seatH, seatD),
            seatMat
          );
          seat.position.set(-w / 2 + wallThickness + seatW / 2, seatH / 2 - h / 2 + 0.1, 0);
          group.add(seat);

          // Door (on front side)
          const doorMat = new THREE.MeshStandardMaterial({
            color: 0xE0E0E0,
            roughness: 0.2,
            metalness: 0.1
          });
          const doorW = w * 0.5;
          const doorH = tubH * 0.85;
          const door = new THREE.Mesh(
            new THREE.BoxGeometry(doorW, doorH, 0.05),
            doorMat
          );
          door.position.set(w * 0.1, doorH / 2 - h / 2, d / 2);
          group.add(door);

          // Door frame
          const frameMat = new THREE.MeshStandardMaterial({ color: 0xA0A0A0, roughness: 0.3 });
          const doorFrame = new THREE.Mesh(
            new THREE.BoxGeometry(doorW + 0.08, doorH + 0.08, 0.03),
            frameMat
          );
          doorFrame.position.set(w * 0.1, doorH / 2 - h / 2, d / 2 + 0.04);
          group.add(doorFrame);

          // Door handle
          const handleMesh = new THREE.Mesh(
            new THREE.BoxGeometry(0.08, 0.2, 0.05),
            chromeMat
          );
          handleMesh.position.set(w * 0.1 + doorW / 3, tubH * 0.4 - h / 2, d / 2 + 0.08);
          group.add(handleMesh);

          // Rim
          const rim = new THREE.Mesh(
            new THREE.BoxGeometry(w + 0.02, 0.06, d + 0.02),
            tubMat
          );
          rim.position.set(0, tubH + 0.03 - h / 2, 0);
          group.add(rim);

          break;
        }

        case 'shower-base-36':
        case 'shower-base-48':
        case 'shower-base-60': {
          // Shower base/pan
          const baseMat = new THREE.MeshStandardMaterial({
            color: 0xE0E0E0,
            roughness: 0.35
          });
          const drainMat = new THREE.MeshStandardMaterial({
            color: 0x808080,
            roughness: 0.3,
            metalness: 0.6
          });

          const baseH = 0.12;
          const curbH = 0.15;

          // Main base
          const base = new THREE.Mesh(
            new THREE.BoxGeometry(w, baseH, d),
            baseMat
          );
          base.position.set(0, baseH / 2 - h / 2, 0);
          group.add(base);

          // Curb (threshold)
          const curb = new THREE.Mesh(
            new THREE.BoxGeometry(w, curbH, 0.1),
            baseMat
          );
          curb.position.set(0, curbH / 2 - h / 2, d / 2 - 0.05);
          group.add(curb);

          // Drain
          const isLarge = el.type === 'shower-base-48';
          const drainX = isLarge ? w * 0.2 : 0;
          const drain = new THREE.Mesh(
            new THREE.CylinderGeometry(0.05, 0.05, 0.02, 12),
            drainMat
          );
          drain.position.set(drainX, baseH + 0.01 - h / 2, 0);
          group.add(drain);

          // Drain grate
          const grateMat = new THREE.MeshStandardMaterial({ color: 0x606060, metalness: 0.7 });
          for (let i = -2; i <= 2; i++) {
            const grateBar = new THREE.Mesh(
              new THREE.BoxGeometry(0.005, 0.01, 0.08),
              grateMat
            );
            grateBar.position.set(drainX + i * 0.015, baseH + 0.02 - h / 2, 0);
            group.add(grateBar);
          }

          // Non-slip texture (subtle bumps)
          const bumpMat = new THREE.MeshStandardMaterial({ color: 0xD8D8D8, roughness: 0.5 });
          for (let bx = -w / 2 + 0.15; bx < w / 2 - 0.1; bx += 0.2) {
            for (let bz = -d / 2 + 0.15; bz < d / 2 - 0.15; bz += 0.2) {
              if (Math.abs(bx - drainX) > 0.1 || Math.abs(bz) > 0.1) {
                const bump = new THREE.Mesh(
                  new THREE.SphereGeometry(0.015, 6, 6),
                  bumpMat
                );
                bump.position.set(bx, baseH + 0.01 - h / 2, bz);
                group.add(bump);
              }
            }
          }

          break;
        }

        case 'vanity-24':
        case 'vanity-30':
        case 'vanity-36':
        case 'vanity-48':
        case 'vanity-60':
        case 'vanity-72': {
          // Bathroom vanity with sink and mirror
          const vanityMat = new THREE.MeshStandardMaterial({
            color: el.color ? parseInt(el.color.replace('#', ''), 16) : 0x8B7355,
            roughness: 0.6
          });
          const counterMat = new THREE.MeshStandardMaterial({
            color: 0xE8E0D8,
            roughness: 0.25
          });
          const sinkMat = new THREE.MeshStandardMaterial({
            color: 0xFFFFFF,
            roughness: 0.1
          });
          const chromeMat = new THREE.MeshStandardMaterial({
            color: 0xC0C0C0,
            roughness: 0.1,
            metalness: 0.9
          });

          const cabinetH = 2.5;
          const counterH = 0.1;
          const counterOverhang = 0.05;

          // Cabinet body
          const cabinet = new THREE.Mesh(
            new THREE.BoxGeometry(w, cabinetH, d),
            vanityMat
          );
          cabinet.position.set(0, cabinetH / 2 - h / 2, 0);
          group.add(cabinet);

          // Cabinet doors
          const doorMat = new THREE.MeshStandardMaterial({
            color: adjustColorBrightness(el.color ? parseInt(el.color.replace('#', ''), 16) : 0x8B7355, -15),
            roughness: 0.5
          });
          const numDoors = w > 4 ? Math.floor(w / 1.5) : (w > 2 ? 2 : 1);
          const doorW = (w - 0.1) / numDoors;
          for (let di = 0; di < numDoors; di++) {
            const door = new THREE.Mesh(
              new THREE.BoxGeometry(doorW - 0.04, cabinetH - 0.1, 0.03),
              doorMat
            );
            door.position.set(-w / 2 + doorW / 2 + di * doorW + 0.02, cabinetH / 2 - h / 2, d / 2 + 0.02);
            group.add(door);

            // Door handle
            const handleBar = new THREE.Mesh(
              new THREE.BoxGeometry(0.08, 0.02, 0.02),
              chromeMat
            );
            handleBar.position.set(-w / 2 + doorW / 2 + di * doorW + 0.02, cabinetH * 0.6 - h / 2, d / 2 + 0.05);
            group.add(handleBar);
          }

          // Countertop
          const counter = new THREE.Mesh(
            new THREE.BoxGeometry(w + counterOverhang * 2, counterH, d + counterOverhang),
            counterMat
          );
          counter.position.set(0, cabinetH + counterH / 2 - h / 2, counterOverhang / 2);
          group.add(counter);

          // Sink basin(s)
          const isDouble = w >= 5;
          const sinkW = isDouble ? w * 0.35 : w * 0.6;
          const sinkPositions = isDouble ? [-w / 4, w / 4] : [0];

          sinkPositions.forEach(sx => {
            // Basin
            const basin = new THREE.Mesh(
              new THREE.BoxGeometry(sinkW, 0.15, d * 0.5),
              sinkMat
            );
            basin.position.set(sx, cabinetH + 0.02 - h / 2, 0);
            group.add(basin);

            // Faucet
            const faucetBase = new THREE.Mesh(
              new THREE.CylinderGeometry(0.025, 0.03, 0.05, 12),
              chromeMat
            );
            faucetBase.position.set(sx, cabinetH + counterH + 0.03 - h / 2, -d / 4);
            group.add(faucetBase);

            const faucetArm = new THREE.Mesh(
              new THREE.CylinderGeometry(0.015, 0.015, 0.15, 8),
              chromeMat
            );
            faucetArm.position.set(sx, cabinetH + counterH + 0.1 - h / 2, -d / 4);
            group.add(faucetArm);

            const faucetSpout = new THREE.Mesh(
              new THREE.CylinderGeometry(0.012, 0.012, 0.12, 8),
              chromeMat
            );
            faucetSpout.rotation.x = Math.PI / 3;
            faucetSpout.position.set(sx, cabinetH + counterH + 0.16 - h / 2, -d / 4 + 0.06);
            group.add(faucetSpout);
          });

          break;
        }

        case 'shower-bench': {
          // Built-in shower bench
          const benchMat = new THREE.MeshStandardMaterial({
            color: el.color ? parseInt(el.color.replace('#', ''), 16) : 0xD4D4D4,
            roughness: 0.3
          });
          const legMat = new THREE.MeshStandardMaterial({
            color: 0xC0C0C0,
            roughness: 0.3,
            metalness: 0.4
          });

          const benchH = 1.3;
          const seatH = 0.12;
          const seatD = d;

          // Seat top
          const seat = new THREE.Mesh(
            new THREE.BoxGeometry(w, seatH, seatD),
            benchMat
          );
          seat.position.set(0, benchH - h / 2, 0);
          group.add(seat);

          // Support structure
          const supportH = benchH - seatH;
          const support = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.1, supportH, seatD - 0.1),
            benchMat
          );
          support.position.set(0, supportH / 2 - h / 2, 0);
          group.add(support);

          break;
        }

        case 'towel-warmer': {
          // Electric towel warmer rack
          const metalMat = new THREE.MeshStandardMaterial({
            color: 0xC0C0C0,
            roughness: 0.2,
            metalness: 0.85
          });

          const barSpacing = 0.25;
          const numBars = Math.floor((h - 0.3) / barSpacing);
          const barRadius = 0.02;

          // Side rails
          [-1, 1].forEach(side => {
            const rail = new THREE.Mesh(
              new THREE.CylinderGeometry(barRadius, barRadius, h - 0.1, 12),
              metalMat
            );
            rail.position.set(side * (w / 2 - barRadius * 2), 0, 0);
            group.add(rail);
          });

          // Horizontal bars
          for (let bi = 0; bi < numBars; bi++) {
            const barY = -h / 2 + 0.15 + bi * barSpacing;
            const bar = new THREE.Mesh(
              new THREE.CylinderGeometry(barRadius, barRadius, w - barRadius * 4, 12),
              metalMat
            );
            bar.rotation.z = Math.PI / 2;
            bar.position.set(0, barY, 0);
            group.add(bar);
          }

          // Mounting brackets
          const bracketMat = new THREE.MeshStandardMaterial({ color: 0x888888, roughness: 0.3, metalness: 0.6 });
          [-1, 1].forEach(side => {
            const bracket = new THREE.Mesh(
              new THREE.BoxGeometry(0.08, 0.08, 0.04),
              bracketMat
            );
            bracket.position.set(side * (w / 2 - 0.04), h / 3, -d / 2 - 0.01);
            group.add(bracket);
          });

          break;
        }

        // ===== LAUNDRY ELEMENTS =====
        case 'washer': {
          // Front-loading washing machine
          const bodyMat = new THREE.MeshStandardMaterial({
            color: 0xF0F0F0,
            roughness: 0.3,
            metalness: 0.1
          });
          const doorMat = new THREE.MeshStandardMaterial({
            color: 0xE0E0E0,
            roughness: 0.2,
            metalness: 0.15
          });
          const glassMat = new THREE.MeshStandardMaterial({
            color: 0x4a6080,
            transparent: true,
            opacity: 0.6,
            roughness: 0.1
          });
          const chromeMat = new THREE.MeshStandardMaterial({
            color: 0xC0C0C0,
            roughness: 0.1,
            metalness: 0.9
          });

          // Main body
          const body = new THREE.Mesh(
            new THREE.BoxGeometry(w, h, d),
            bodyMat
          );
          group.add(body);

          // Door frame (circle)
          const doorRadius = Math.min(w, h) * 0.35;
          const doorFrame = new THREE.Mesh(
            new THREE.TorusGeometry(doorRadius, 0.04, 12, 24),
            doorMat
          );
          doorFrame.position.set(0, -0.1, d / 2 + 0.01);
          group.add(doorFrame);

          // Door glass
          const glass = new THREE.Mesh(
            new THREE.CircleGeometry(doorRadius - 0.04, 24),
            glassMat
          );
          glass.position.set(0, -0.1, d / 2 + 0.02);
          group.add(glass);

          // Control panel (top)
          const panelMat = new THREE.MeshStandardMaterial({ color: 0x2a2a2a, roughness: 0.4 });
          const panel = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.1, 0.15, d * 0.5),
            panelMat
          );
          panel.position.set(0, h / 2 - 0.1, -d / 4);
          group.add(panel);

          // Dial
          const dial = new THREE.Mesh(
            new THREE.CylinderGeometry(0.06, 0.06, 0.03, 16),
            chromeMat
          );
          dial.rotation.x = Math.PI / 2;
          dial.position.set(-w / 4, h / 2 - 0.08, -d / 4 + d * 0.25 + 0.02);
          group.add(dial);

          // Display
          const displayMat = new THREE.MeshStandardMaterial({ color: 0x004400, emissive: 0x002200 });
          const display = new THREE.Mesh(
            new THREE.BoxGeometry(0.2, 0.06, 0.01),
            displayMat
          );
          display.position.set(w / 6, h / 2 - 0.08, -d / 4 + d * 0.25 + 0.02);
          group.add(display);

          // Door handle
          const handle = new THREE.Mesh(
            new THREE.BoxGeometry(0.08, 0.25, 0.04),
            chromeMat
          );
          handle.position.set(w / 2 - 0.15, -0.1, d / 2 + 0.03);
          group.add(handle);

          break;
        }

        case 'dryer': {
          // Front-loading dryer (similar to washer but with vent)
          const bodyMat = new THREE.MeshStandardMaterial({
            color: 0xE8E8E8,
            roughness: 0.3,
            metalness: 0.1
          });
          const doorMat = new THREE.MeshStandardMaterial({
            color: 0xD8D8D8,
            roughness: 0.2
          });
          const chromeMat = new THREE.MeshStandardMaterial({
            color: 0xC0C0C0,
            roughness: 0.1,
            metalness: 0.9
          });

          // Main body
          const body = new THREE.Mesh(
            new THREE.BoxGeometry(w, h, d),
            bodyMat
          );
          group.add(body);

          // Door (solid, not glass)
          const doorRadius = Math.min(w, h) * 0.35;
          const door = new THREE.Mesh(
            new THREE.CircleGeometry(doorRadius, 24),
            doorMat
          );
          door.position.set(0, -0.1, d / 2 + 0.01);
          group.add(door);

          // Door rim
          const doorRim = new THREE.Mesh(
            new THREE.TorusGeometry(doorRadius, 0.03, 12, 24),
            chromeMat
          );
          doorRim.position.set(0, -0.1, d / 2 + 0.02);
          group.add(doorRim);

          // Control panel
          const panelMat = new THREE.MeshStandardMaterial({ color: 0x3a3a3a, roughness: 0.4 });
          const panel = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.1, 0.15, d * 0.5),
            panelMat
          );
          panel.position.set(0, h / 2 - 0.1, -d / 4);
          group.add(panel);

          // Temperature dial
          const dial = new THREE.Mesh(
            new THREE.CylinderGeometry(0.06, 0.06, 0.03, 16),
            chromeMat
          );
          dial.rotation.x = Math.PI / 2;
          dial.position.set(-w / 4, h / 2 - 0.08, 0);
          group.add(dial);

          // Timer dial
          const timer = new THREE.Mesh(
            new THREE.CylinderGeometry(0.05, 0.05, 0.03, 16),
            chromeMat
          );
          timer.rotation.x = Math.PI / 2;
          timer.position.set(w / 4, h / 2 - 0.08, 0);
          group.add(timer);

          // Door handle
          const handle = new THREE.Mesh(
            new THREE.BoxGeometry(0.08, 0.25, 0.04),
            chromeMat
          );
          handle.position.set(-w / 2 + 0.15, -0.1, d / 2 + 0.03);
          group.add(handle);

          // Vent (back)
          const ventMat = new THREE.MeshStandardMaterial({ color: 0x808080, roughness: 0.5 });
          const vent = new THREE.Mesh(
            new THREE.CylinderGeometry(0.08, 0.08, 0.1, 12),
            ventMat
          );
          vent.rotation.x = Math.PI / 2;
          vent.position.set(0, -h / 3, -d / 2 - 0.05);
          group.add(vent);

          break;
        }

        case 'utility-sink':
        case 'laundry-sink': {
          // Deep utility sink for laundry
          const sinkMat = new THREE.MeshStandardMaterial({
            color: 0xF5F5F5,
            roughness: 0.2
          });
          const basinMat = new THREE.MeshStandardMaterial({
            color: 0xE8E8E8,
            roughness: 0.25
          });
          const legMat = new THREE.MeshStandardMaterial({
            color: 0xC0C0C0,
            roughness: 0.3,
            metalness: 0.6
          });
          const chromeMat = new THREE.MeshStandardMaterial({
            color: 0xB0B0B0,
            roughness: 0.1,
            metalness: 0.9
          });

          const sinkH = 2.9;
          const basinH = 0.8;
          const rimH = 0.08;
          const wallThick = 0.08;

          // Basin (deep tub shape)
          const basinOuter = new THREE.Mesh(
            new THREE.BoxGeometry(w, basinH + rimH, d),
            sinkMat
          );
          basinOuter.position.set(0, sinkH - basinH / 2 - h / 2, 0);
          group.add(basinOuter);

          // Inner basin
          const basinInner = new THREE.Mesh(
            new THREE.BoxGeometry(w - wallThick * 2, basinH, d - wallThick * 2),
            basinMat
          );
          basinInner.position.set(0, sinkH - basinH / 2 + rimH / 2 - h / 2, 0);
          group.add(basinInner);

          // Legs
          const legH = sinkH - basinH - rimH;
          [[-1, -1], [-1, 1], [1, -1], [1, 1]].forEach(([lx, lz]) => {
            const leg = new THREE.Mesh(
              new THREE.BoxGeometry(0.08, legH, 0.08),
              legMat
            );
            leg.position.set(lx * (w / 2 - 0.08), legH / 2 - h / 2, lz * (d / 2 - 0.08));
            group.add(leg);
          });

          // Faucet
          const faucetBase = new THREE.Mesh(
            new THREE.CylinderGeometry(0.04, 0.05, 0.08, 12),
            chromeMat
          );
          faucetBase.position.set(0, sinkH + 0.05 - h / 2, -d / 2 + 0.15);
          group.add(faucetBase);

          const faucetArm = new THREE.Mesh(
            new THREE.CylinderGeometry(0.025, 0.025, 0.35, 8),
            chromeMat
          );
          faucetArm.position.set(0, sinkH + 0.25 - h / 2, -d / 2 + 0.15);
          group.add(faucetArm);

          const spout = new THREE.Mesh(
            new THREE.CylinderGeometry(0.02, 0.02, 0.25, 8),
            chromeMat
          );
          spout.rotation.x = Math.PI / 2.5;
          spout.position.set(0, sinkH + 0.4 - h / 2, -d / 2 + 0.28);
          group.add(spout);

          break;
        }

        case 'drying-rack': {
          // Wall-mounted or freestanding drying rack
          const frameMat = new THREE.MeshStandardMaterial({
            color: 0xE0E0E0,
            roughness: 0.4,
            metalness: 0.3
          });
          const rodMat = new THREE.MeshStandardMaterial({
            color: 0xC0C0C0,
            roughness: 0.25,
            metalness: 0.5
          });

          const numRods = 6;
          const rodSpacing = (h - 0.3) / numRods;
          const rodRadius = 0.015;

          // Side frames
          [-1, 1].forEach(side => {
            const frame = new THREE.Mesh(
              new THREE.BoxGeometry(0.05, h, 0.05),
              frameMat
            );
            frame.position.set(side * (w / 2 - 0.025), 0, 0);
            group.add(frame);
          });

          // Top bar
          const topBar = new THREE.Mesh(
            new THREE.BoxGeometry(w, 0.05, 0.05),
            frameMat
          );
          topBar.position.set(0, h / 2 - 0.025, 0);
          group.add(topBar);

          // Drying rods
          for (let ri = 0; ri < numRods; ri++) {
            const rod = new THREE.Mesh(
              new THREE.CylinderGeometry(rodRadius, rodRadius, w - 0.1, 8),
              rodMat
            );
            rod.rotation.z = Math.PI / 2;
            rod.position.set(0, -h / 2 + 0.15 + ri * rodSpacing, 0);
            group.add(rod);
          }

          break;
        }

        case 'washer-dryer-stack': {
          // Stacked washer/dryer unit
          const bodyMat = new THREE.MeshStandardMaterial({
            color: 0xF0F0F0,
            roughness: 0.3,
            metalness: 0.1
          });
          const glassMat = new THREE.MeshStandardMaterial({
            color: 0x4a6080,
            transparent: true,
            opacity: 0.6,
            roughness: 0.1
          });
          const chromeMat = new THREE.MeshStandardMaterial({
            color: 0xC0C0C0,
            roughness: 0.1,
            metalness: 0.9
          });

          const unitH = h * 2; // Stacked units are taller
          const singleH = unitH / 2;

          // Main body (full height)
          const body = new THREE.Mesh(
            new THREE.BoxGeometry(w, unitH, d),
            bodyMat
          );
          body.position.set(0, unitH / 2 - h / 2, 0);
          group.add(body);

          // Divider line between units
          const dividerMat = new THREE.MeshStandardMaterial({ color: 0xB0B0B0, roughness: 0.4 });
          const divider = new THREE.Mesh(
            new THREE.BoxGeometry(w + 0.02, 0.03, d + 0.02),
            dividerMat
          );
          divider.position.set(0, singleH - h / 2, 0);
          group.add(divider);

          // Bottom unit (washer) - glass door
          const washerDoorRadius = Math.min(w, singleH) * 0.35;
          const washerDoorFrame = new THREE.Mesh(
            new THREE.TorusGeometry(washerDoorRadius, 0.04, 12, 24),
            chromeMat
          );
          washerDoorFrame.position.set(0, singleH / 2 - h / 2, d / 2 + 0.01);
          group.add(washerDoorFrame);

          const washerGlass = new THREE.Mesh(
            new THREE.CircleGeometry(washerDoorRadius - 0.04, 24),
            glassMat
          );
          washerGlass.position.set(0, singleH / 2 - h / 2, d / 2 + 0.02);
          group.add(washerGlass);

          // Top unit (dryer) - solid door
          const dryerDoorMat = new THREE.MeshStandardMaterial({ color: 0xE0E0E0, roughness: 0.2 });
          const dryerDoor = new THREE.Mesh(
            new THREE.CircleGeometry(washerDoorRadius, 24),
            dryerDoorMat
          );
          dryerDoor.position.set(0, singleH + singleH / 2 - h / 2, d / 2 + 0.01);
          group.add(dryerDoor);

          const dryerRim = new THREE.Mesh(
            new THREE.TorusGeometry(washerDoorRadius, 0.03, 12, 24),
            chromeMat
          );
          dryerRim.position.set(0, singleH + singleH / 2 - h / 2, d / 2 + 0.02);
          group.add(dryerRim);

          // Control panels
          const panelMat = new THREE.MeshStandardMaterial({ color: 0x2a2a2a, roughness: 0.4 });
          // Washer panel
          const washerPanel = new THREE.Mesh(
            new THREE.BoxGeometry(w * 0.5, 0.1, 0.02),
            panelMat
          );
          washerPanel.position.set(w * 0.2, singleH - 0.12 - h / 2, d / 2 + 0.02);
          group.add(washerPanel);

          // Dryer panel
          const dryerPanel = new THREE.Mesh(
            new THREE.BoxGeometry(w * 0.5, 0.1, 0.02),
            panelMat
          );
          dryerPanel.position.set(w * 0.2, unitH - 0.12 - h / 2, d / 2 + 0.02);
          group.add(dryerPanel);

          break;
        }

        case 'laundry-cabinet': {
          // Laundry room cabinet/storage
          const cabinetMat = new THREE.MeshStandardMaterial({
            color: el.color ? parseInt(el.color.replace('#', ''), 16) : 0x8B7355,
            roughness: 0.6
          });
          const counterMat = new THREE.MeshStandardMaterial({
            color: 0xE8E0D8,
            roughness: 0.25
          });
          const chromeMat = new THREE.MeshStandardMaterial({
            color: 0xC0C0C0,
            roughness: 0.15,
            metalness: 0.8
          });

          const cabinetH = 2.8;
          const counterH = 0.08;

          // Main cabinet body
          const cabinet = new THREE.Mesh(
            new THREE.BoxGeometry(w, cabinetH, d),
            cabinetMat
          );
          cabinet.position.set(0, cabinetH / 2 - h / 2, 0);
          group.add(cabinet);

          // Counter top
          const counter = new THREE.Mesh(
            new THREE.BoxGeometry(w + 0.04, counterH, d + 0.04),
            counterMat
          );
          counter.position.set(0, cabinetH + counterH / 2 - h / 2, 0);
          group.add(counter);

          // Door split (vertical line in front)
          const splitMat = new THREE.MeshStandardMaterial({ color: 0x5C4A3A, roughness: 0.5 });
          const split = new THREE.Mesh(
            new THREE.BoxGeometry(0.02, cabinetH - 0.1, 0.01),
            splitMat
          );
          split.position.set(0, cabinetH / 2 - h / 2, d / 2 + 0.01);
          group.add(split);

          // Handles
          [-1, 1].forEach(side => {
            const handle = new THREE.Mesh(
              new THREE.BoxGeometry(0.03, 0.15, 0.03),
              chromeMat
            );
            handle.position.set(side * 0.08, cabinetH / 2 - h / 2, d / 2 + 0.04);
            group.add(handle);
          });

          break;
        }

        case 'ironing-board': {
          // Freestanding ironing board
          const boardMat = new THREE.MeshStandardMaterial({
            color: 0xD0D0D0,
            roughness: 0.4
          });
          const legMat = new THREE.MeshStandardMaterial({
            color: 0x808080,
            roughness: 0.3,
            metalness: 0.5
          });
          const coverMat = new THREE.MeshStandardMaterial({
            color: 0xE8E8F0,
            roughness: 0.6
          });

          const boardH = 0.05;
          const boardY = 2.8; // Standard ironing height

          // Board surface (tapered shape - narrower at one end)
          const boardShape = new THREE.Shape();
          const narrowW = w * 0.35;
          const wideW = w * 0.9;
          boardShape.moveTo(-narrowW / 2, -d / 2);
          boardShape.lineTo(narrowW / 2, -d / 2);
          boardShape.lineTo(wideW / 2, d / 2);
          boardShape.lineTo(-wideW / 2, d / 2);
          boardShape.closePath();

          const extrudeSettings = { depth: boardH, bevelEnabled: false };
          const boardGeom = new THREE.ExtrudeGeometry(boardShape, extrudeSettings);
          const board = new THREE.Mesh(boardGeom, coverMat);
          board.rotation.x = -Math.PI / 2;
          board.position.set(0, boardY - h / 2, 0);
          group.add(board);

          // Legs (X-frame)
          const legRadius = 0.02;
          const legLength = boardY + 0.3;

          // Front legs (forming X)
          const leg1 = new THREE.Mesh(
            new THREE.CylinderGeometry(legRadius, legRadius, legLength, 8),
            legMat
          );
          leg1.rotation.z = 0.15;
          leg1.position.set(-w * 0.15, boardY / 2 - h / 2 - 0.1, d * 0.2);
          group.add(leg1);

          const leg2 = new THREE.Mesh(
            new THREE.CylinderGeometry(legRadius, legRadius, legLength, 8),
            legMat
          );
          leg2.rotation.z = -0.15;
          leg2.position.set(w * 0.15, boardY / 2 - h / 2 - 0.1, d * 0.2);
          group.add(leg2);

          // Cross brace
          const brace = new THREE.Mesh(
            new THREE.CylinderGeometry(legRadius * 0.8, legRadius * 0.8, w * 0.5, 8),
            legMat
          );
          brace.rotation.z = Math.PI / 2;
          brace.position.set(0, boardY * 0.4 - h / 2, d * 0.2);
          group.add(brace);

          // Iron rest (at narrow end)
          const restMat = new THREE.MeshStandardMaterial({ color: 0x606060, roughness: 0.4, metalness: 0.3 });
          const rest = new THREE.Mesh(
            new THREE.BoxGeometry(w * 0.25, 0.02, 0.15),
            restMat
          );
          rest.position.set(0, boardY + 0.04 - h / 2, -d / 2 + 0.1);
          group.add(rest);

          break;
        }

        // ===== CLOSET ELEMENTS =====
        case 'closet-rod': {
          // Clothing rod for hanging clothes
          const rodMat = new THREE.MeshStandardMaterial({
            color: 0xC0C0C0,
            roughness: 0.2,
            metalness: 0.8
          });
          const bracketMat = new THREE.MeshStandardMaterial({
            color: 0x808080,
            roughness: 0.3,
            metalness: 0.6
          });

          const rodRadius = 0.0625; // 1.5" diameter rod
          const bracketW = 0.12;

          // Main rod
          const rod = new THREE.Mesh(
            new THREE.CylinderGeometry(rodRadius, rodRadius, w, 16),
            rodMat
          );
          rod.rotation.z = Math.PI / 2;
          group.add(rod);

          // End brackets
          [-1, 1].forEach(side => {
            const bracket = new THREE.Mesh(
              new THREE.BoxGeometry(bracketW, 0.1, 0.08),
              bracketMat
            );
            bracket.position.set(side * (w / 2 - bracketW / 2), 0, -0.06);
            group.add(bracket);
          });

          break;
        }

        case 'closet-shelf': {
          // Wire or solid closet shelf
          const shelfMat = new THREE.MeshStandardMaterial({
            color: el.color ? parseInt(el.color.replace('#', ''), 16) : 0xE8E8E8,
            roughness: 0.4
          });

          const shelfH = 0.03; // Thin shelf

          // Solid shelf
          const shelf = new THREE.Mesh(
            new THREE.BoxGeometry(w, shelfH, d),
            shelfMat
          );
          group.add(shelf);

          // Front lip
          const lipMat = new THREE.MeshStandardMaterial({
            color: adjustColorBrightness(el.color ? parseInt(el.color.replace('#', ''), 16) : 0xE8E8E8, -10),
            roughness: 0.35
          });
          const lip = new THREE.Mesh(
            new THREE.BoxGeometry(w, 0.05, 0.02),
            lipMat
          );
          lip.position.set(0, -0.01, d / 2 + 0.01);
          group.add(lip);

          break;
        }

        case 'closet-drawers': // Alias for drawer-unit
        case 'drawer-unit': {
          // Multi-drawer storage unit for closets
          const bodyMat = new THREE.MeshStandardMaterial({
            color: el.color ? parseInt(el.color.replace('#', ''), 16) : 0xF5F0E6,
            roughness: 0.6
          });
          const drawerMat = new THREE.MeshStandardMaterial({
            color: adjustColorBrightness(el.color ? parseInt(el.color.replace('#', ''), 16) : 0xF5F0E6, -10),
            roughness: 0.5
          });
          const handleMat = new THREE.MeshStandardMaterial({
            color: 0xC0C0C0,
            roughness: 0.2,
            metalness: 0.7
          });

          const numDrawers = Math.max(3, Math.floor(h / 0.6));
          const drawerH = (h - 0.1) / numDrawers;
          const drawerGap = 0.02;

          // Body
          const body = new THREE.Mesh(
            new THREE.BoxGeometry(w, h, d),
            bodyMat
          );
          group.add(body);

          // Drawers
          for (let di = 0; di < numDrawers; di++) {
            const drawerY = h / 2 - drawerH / 2 - di * drawerH - 0.05;

            // Drawer front
            const drawer = new THREE.Mesh(
              new THREE.BoxGeometry(w - 0.04, drawerH - drawerGap, 0.03),
              drawerMat
            );
            drawer.position.set(0, drawerY, d / 2 + 0.02);
            group.add(drawer);

            // Handle
            const handle = new THREE.Mesh(
              new THREE.BoxGeometry(w * 0.3, 0.03, 0.03),
              handleMat
            );
            handle.position.set(0, drawerY, d / 2 + 0.05);
            group.add(handle);
          }

          break;
        }

        case 'shoe-rack': {
          // Angled shoe rack/cubby
          const frameMat = new THREE.MeshStandardMaterial({
            color: el.color ? parseInt(el.color.replace('#', ''), 16) : 0xDEB887,
            roughness: 0.6
          });
          const shelfMat = new THREE.MeshStandardMaterial({
            color: adjustColorBrightness(el.color ? parseInt(el.color.replace('#', ''), 16) : 0xDEB887, 10),
            roughness: 0.5
          });

          const numShelves = Math.max(3, Math.floor(h / 0.5));
          const shelfSpacing = h / numShelves;
          const shelfAngle = Math.PI / 12; // 15 degrees

          // Side panels
          [-1, 1].forEach(side => {
            const sidePanel = new THREE.Mesh(
              new THREE.BoxGeometry(0.03, h, d),
              frameMat
            );
            sidePanel.position.set(side * (w / 2 - 0.015), 0, 0);
            group.add(sidePanel);
          });

          // Angled shelves
          for (let si = 0; si < numShelves; si++) {
            const shelfY = -h / 2 + shelfSpacing * (si + 0.5);
            const shelf = new THREE.Mesh(
              new THREE.BoxGeometry(w - 0.08, 0.02, d - 0.05),
              shelfMat
            );
            shelf.position.set(0, shelfY, 0);
            shelf.rotation.x = -shelfAngle;
            group.add(shelf);

            // Front lip to keep shoes in place
            const lip = new THREE.Mesh(
              new THREE.BoxGeometry(w - 0.08, 0.04, 0.02),
              shelfMat
            );
            lip.position.set(0, shelfY - 0.05, d / 2 - 0.05);
            group.add(lip);
          }

          break;
        }

        case 'closet-island': {
          // Center island with drawers and top surface
          const bodyMat = new THREE.MeshStandardMaterial({
            color: el.color ? parseInt(el.color.replace('#', ''), 16) : 0xF5F0E6,
            roughness: 0.5
          });
          const topMat = new THREE.MeshStandardMaterial({
            color: 0xE8E0D8,
            roughness: 0.25
          });
          const drawerMat = new THREE.MeshStandardMaterial({
            color: adjustColorBrightness(el.color ? parseInt(el.color.replace('#', ''), 16) : 0xF5F0E6, -15),
            roughness: 0.45
          });
          const handleMat = new THREE.MeshStandardMaterial({
            color: 0xB8860B,
            roughness: 0.25,
            metalness: 0.6
          });

          const baseH = h - 0.12;
          const topH = 0.1;

          // Main body
          const body = new THREE.Mesh(
            new THREE.BoxGeometry(w, baseH, d),
            bodyMat
          );
          body.position.set(0, -topH / 2, 0);
          group.add(body);

          // Top surface
          const top = new THREE.Mesh(
            new THREE.BoxGeometry(w + 0.08, topH, d + 0.08),
            topMat
          );
          top.position.set(0, h / 2 - topH / 2, 0);
          group.add(top);

          // Drawers on all four sides
          const drawerH = baseH / 3 - 0.02;
          for (let di = 0; di < 3; di++) {
            const drawerY = h / 2 - topH - drawerH / 2 - di * (drawerH + 0.02) - 0.02;

            // Front drawers
            const frontDrawer = new THREE.Mesh(
              new THREE.BoxGeometry(w / 2 - 0.04, drawerH - 0.02, 0.03),
              drawerMat
            );
            frontDrawer.position.set(0, drawerY, d / 2 + 0.02);
            group.add(frontDrawer);

            // Front handle
            const frontHandle = new THREE.Mesh(
              new THREE.CylinderGeometry(0.015, 0.015, 0.1, 8),
              handleMat
            );
            frontHandle.rotation.z = Math.PI / 2;
            frontHandle.position.set(0, drawerY, d / 2 + 0.05);
            group.add(frontHandle);
          }

          break;
        }

        case 'jewelry-drawer': // Alias for jewelry-cabinet
        case 'jewelry-cabinet': {
          // Mirrored jewelry cabinet
          const bodyMat = new THREE.MeshStandardMaterial({
            color: el.color ? parseInt(el.color.replace('#', ''), 16) : 0xF5F0E6,
            roughness: 0.4
          });
          const mirrorMat = new THREE.MeshStandardMaterial({
            color: 0xE8F0F8,
            roughness: 0.05,
            metalness: 0.9
          });
          const frameMat = new THREE.MeshStandardMaterial({
            color: 0xB8860B,
            roughness: 0.3,
            metalness: 0.5
          });
          const velvetMat = new THREE.MeshStandardMaterial({
            color: 0x4a0020,
            roughness: 0.9
          });

          // Cabinet body
          const cabinet = new THREE.Mesh(
            new THREE.BoxGeometry(w, h, d),
            bodyMat
          );
          group.add(cabinet);

          // Mirror on front
          const mirrorH = h - 0.15;
          const mirrorW = w - 0.1;
          const mirror = new THREE.Mesh(
            new THREE.BoxGeometry(mirrorW, mirrorH, 0.02),
            mirrorMat
          );
          mirror.position.set(0, 0, d / 2 + 0.01);
          group.add(mirror);

          // Mirror frame
          const frameW = 0.04;
          // Top frame
          const topFrame = new THREE.Mesh(
            new THREE.BoxGeometry(mirrorW + frameW * 2, frameW, 0.03),
            frameMat
          );
          topFrame.position.set(0, mirrorH / 2, d / 2 + 0.02);
          group.add(topFrame);
          // Bottom frame
          const bottomFrame = new THREE.Mesh(
            new THREE.BoxGeometry(mirrorW + frameW * 2, frameW, 0.03),
            frameMat
          );
          bottomFrame.position.set(0, -mirrorH / 2, d / 2 + 0.02);
          group.add(bottomFrame);
          // Side frames
          [-1, 1].forEach(side => {
            const sideFrame = new THREE.Mesh(
              new THREE.BoxGeometry(frameW, mirrorH, 0.03),
              frameMat
            );
            sideFrame.position.set(side * (mirrorW / 2 + frameW / 2), 0, d / 2 + 0.02);
            group.add(sideFrame);
          });

          // Handle
          const handle = new THREE.Mesh(
            new THREE.BoxGeometry(0.04, 0.15, 0.04),
            frameMat
          );
          handle.position.set(w / 2 - 0.1, 0, d / 2 + 0.04);
          group.add(handle);

          break;
        }

        case 'tie-rack': {
          // Tie/belt rack with hooks and hanging items
          const barMat = new THREE.MeshStandardMaterial({
            color: 0xC0C0C0,
            roughness: 0.3,
            metalness: 0.6
          });
          const hookMat = new THREE.MeshStandardMaterial({
            color: 0x808080,
            roughness: 0.2,
            metalness: 0.8
          });

          // Main mounting bar
          const bar = new THREE.Mesh(
            new THREE.BoxGeometry(w, 0.08, 0.05),
            barMat
          );
          bar.position.set(0, h / 2 - 0.04, 0);
          group.add(bar);

          // Hooks
          const numHooks = Math.max(3, Math.floor(w / 0.15));
          const hookSpacing = w / (numHooks + 1);

          for (let hi = 1; hi <= numHooks; hi++) {
            const hookX = -w / 2 + hi * hookSpacing;

            // Hook cylinder
            const hook = new THREE.Mesh(
              new THREE.CylinderGeometry(0.015, 0.015, 0.12, 8),
              hookMat
            );
            hook.position.set(hookX, h / 2 - 0.1, 0.04);
            group.add(hook);

            // Hook end
            const hookEnd = new THREE.Mesh(
              new THREE.SphereGeometry(0.02, 8, 8),
              hookMat
            );
            hookEnd.position.set(hookX, h / 2 - 0.16, 0.04);
            group.add(hookEnd);

            // Add ties (decorative)
            if (hi <= 5) {
              const tieColors = [0x4169E1, 0xDC143C, 0x228B22, 0x8B4513, 0x4B0082];
              const tieMat = new THREE.MeshStandardMaterial({
                color: tieColors[(hi - 1) % 5],
                roughness: 0.7
              });

              // Tie shape (simplified as elongated box)
              const tie = new THREE.Mesh(
                new THREE.BoxGeometry(0.06, h - 0.25, 0.01),
                tieMat
              );
              tie.position.set(hookX, 0, 0.02);
              group.add(tie);

              // Tie knot
              const knot = new THREE.Mesh(
                new THREE.BoxGeometry(0.08, 0.06, 0.02),
                tieMat
              );
              knot.position.set(hookX, h / 2 - 0.2, 0.02);
              group.add(knot);
            }
          }

          break;
        }

        case 'full-mirror': {
          // Full-length standing mirror
          const frameMat = new THREE.MeshStandardMaterial({
            color: 0x8B7355,
            roughness: 0.5
          });
          const mirrorMat = new THREE.MeshStandardMaterial({
            color: 0xE8F0F8,
            roughness: 0.02,
            metalness: 0.95,
            envMapIntensity: 1.5
          });

          const frameThickness = 0.04;
          const mirrorDepth = 0.02;

          // Mirror surface
          const mirror = new THREE.Mesh(
            new THREE.BoxGeometry(w - frameThickness * 2, h - frameThickness * 2, mirrorDepth),
            mirrorMat
          );
          mirror.position.set(0, 0, d / 2 - mirrorDepth / 2);
          group.add(mirror);

          // Frame - top
          const topFrame = new THREE.Mesh(
            new THREE.BoxGeometry(w, frameThickness, d),
            frameMat
          );
          topFrame.position.set(0, h / 2 - frameThickness / 2, 0);
          group.add(topFrame);

          // Frame - bottom
          const bottomFrame = new THREE.Mesh(
            new THREE.BoxGeometry(w, frameThickness, d),
            frameMat
          );
          bottomFrame.position.set(0, -h / 2 + frameThickness / 2, 0);
          group.add(bottomFrame);

          // Frame - left
          const leftFrame = new THREE.Mesh(
            new THREE.BoxGeometry(frameThickness, h, d),
            frameMat
          );
          leftFrame.position.set(-w / 2 + frameThickness / 2, 0, 0);
          group.add(leftFrame);

          // Frame - right
          const rightFrame = new THREE.Mesh(
            new THREE.BoxGeometry(frameThickness, h, d),
            frameMat
          );
          rightFrame.position.set(w / 2 - frameThickness / 2, 0, 0);
          group.add(rightFrame);

          // Back panel
          const backMat = new THREE.MeshStandardMaterial({
            color: 0x4a4a4a,
            roughness: 0.8
          });
          const back = new THREE.Mesh(
            new THREE.BoxGeometry(w - frameThickness, h - frameThickness, 0.02),
            backMat
          );
          back.position.set(0, 0, -d / 2 + 0.01);
          group.add(back);

          break;
        }

        // ===== BATHROOM ACCESSORIES =====
        case 'shower-glass': {
          // Shower glass panel (fixed frameless glass)
          const glassMat = new THREE.MeshStandardMaterial({
            color: 0xE8F4FF,
            transparent: true,
            opacity: 0.3,
            roughness: 0.02,
            metalness: 0.1,
            side: THREE.DoubleSide
          });
          const frameMat = new THREE.MeshStandardMaterial({
            color: 0xC0C0C0,
            roughness: 0.2,
            metalness: 0.8
          });

          // Main glass panel
          const glassPanel = new THREE.Mesh(
            new THREE.BoxGeometry(w, h, 0.02),
            glassMat
          );
          group.add(glassPanel);

          // Top channel/rail
          const topRail = new THREE.Mesh(
            new THREE.BoxGeometry(w + 0.04, 0.04, 0.06),
            frameMat
          );
          topRail.position.set(0, h / 2, 0);
          group.add(topRail);

          // Bottom channel
          const bottomRail = new THREE.Mesh(
            new THREE.BoxGeometry(w + 0.04, 0.04, 0.06),
            frameMat
          );
          bottomRail.position.set(0, -h / 2, 0);
          group.add(bottomRail);

          break;
        }

        case 'shower-door': {
          // Hinged or sliding shower door
          const doorGlassMat = new THREE.MeshStandardMaterial({
            color: 0xE8F4FF,
            transparent: true,
            opacity: 0.35,
            roughness: 0.02,
            metalness: 0.1,
            side: THREE.DoubleSide
          });
          const doorFrameMat = new THREE.MeshStandardMaterial({
            color: 0xC0C0C0,
            roughness: 0.2,
            metalness: 0.8
          });

          // Glass door panel
          const doorPanel = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.08, h - 0.1, 0.02),
            doorGlassMat
          );
          group.add(doorPanel);

          // Door frame - vertical sides
          [-1, 1].forEach(side => {
            const frameBar = new THREE.Mesh(
              new THREE.BoxGeometry(0.04, h, 0.05),
              doorFrameMat
            );
            frameBar.position.set(side * (w / 2 - 0.02), 0, 0);
            group.add(frameBar);
          });

          // Frame - top and bottom
          [1, -1].forEach(pos => {
            const hBar = new THREE.Mesh(
              new THREE.BoxGeometry(w, 0.04, 0.05),
              doorFrameMat
            );
            hBar.position.set(0, pos * (h / 2 - 0.02), 0);
            group.add(hBar);
          });

          // Door handle
          const handleMat = new THREE.MeshStandardMaterial({ color: 0xA0A0A0, roughness: 0.2, metalness: 0.9 });
          const handle = new THREE.Mesh(
            new THREE.CylinderGeometry(0.015, 0.015, 0.3, 12),
            handleMat
          );
          handle.rotation.x = Math.PI / 2;
          handle.position.set(w / 2 - 0.1, 0, 0.04);
          group.add(handle);

          break;
        }

        case 'mirror': {
          // Wall-mounted bathroom mirror
          const mirrorSurfaceMat = new THREE.MeshStandardMaterial({
            color: 0xE8F0F8,
            roughness: 0.02,
            metalness: 0.95,
            envMapIntensity: 1.5
          });
          const mirrorFrameMat = new THREE.MeshStandardMaterial({
            color: 0xC0C0C0,
            roughness: 0.3,
            metalness: 0.5
          });

          const mFrameW = 0.03;

          // Mirror surface
          const mirrorSurface = new THREE.Mesh(
            new THREE.BoxGeometry(w - mFrameW * 2, h - mFrameW * 2, 0.01),
            mirrorSurfaceMat
          );
          mirrorSurface.position.set(0, 0, d / 2 - 0.005);
          group.add(mirrorSurface);

          // Frame pieces
          // Top
          const mFrameTop = new THREE.Mesh(new THREE.BoxGeometry(w, mFrameW, d), mirrorFrameMat);
          mFrameTop.position.set(0, h / 2 - mFrameW / 2, 0);
          group.add(mFrameTop);
          // Bottom
          const mFrameBottom = new THREE.Mesh(new THREE.BoxGeometry(w, mFrameW, d), mirrorFrameMat);
          mFrameBottom.position.set(0, -h / 2 + mFrameW / 2, 0);
          group.add(mFrameBottom);
          // Left
          const mFrameLeft = new THREE.Mesh(new THREE.BoxGeometry(mFrameW, h - mFrameW * 2, d), mirrorFrameMat);
          mFrameLeft.position.set(-w / 2 + mFrameW / 2, 0, 0);
          group.add(mFrameLeft);
          // Right
          const mFrameRight = new THREE.Mesh(new THREE.BoxGeometry(mFrameW, h - mFrameW * 2, d), mirrorFrameMat);
          mFrameRight.position.set(w / 2 - mFrameW / 2, 0, 0);
          group.add(mFrameRight);

          break;
        }

        case 'medicine-cabinet': {
          // Medicine cabinet with mirrored door
          const cabinetMat = new THREE.MeshStandardMaterial({
            color: 0xF5F5F5,
            roughness: 0.4
          });
          const medMirrorMat = new THREE.MeshStandardMaterial({
            color: 0xE8F0F8,
            roughness: 0.02,
            metalness: 0.95
          });
          const hingeMat = new THREE.MeshStandardMaterial({
            color: 0x808080,
            roughness: 0.3,
            metalness: 0.7
          });

          // Cabinet body
          const cabBody = new THREE.Mesh(
            new THREE.BoxGeometry(w, h, d),
            cabinetMat
          );
          group.add(cabBody);

          // Interior void
          const interior = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.06, h - 0.06, d - 0.04),
            new THREE.MeshStandardMaterial({ color: 0xE8E8E8, roughness: 0.6 })
          );
          interior.position.set(0, 0, 0.02);
          group.add(interior);

          // Mirrored door
          const doorMirror = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.02, h - 0.02, 0.02),
            medMirrorMat
          );
          doorMirror.position.set(0, 0, d / 2 + 0.01);
          group.add(doorMirror);

          // Door handle
          const doorHandle = new THREE.Mesh(
            new THREE.BoxGeometry(0.04, 0.15, 0.02),
            hingeMat
          );
          doorHandle.position.set(w / 2 - 0.1, 0, d / 2 + 0.03);
          group.add(doorHandle);

          // Hinges
          [-1, 1].forEach(pos => {
            const hinge = new THREE.Mesh(
              new THREE.CylinderGeometry(0.015, 0.015, 0.03, 8),
              hingeMat
            );
            hinge.position.set(-w / 2 + 0.02, pos * (h / 3), d / 2);
            group.add(hinge);
          });

          break;
        }

        case 'towel-bar': {
          // Wall-mounted towel bar
          const barMat = new THREE.MeshStandardMaterial({
            color: 0xC0C0C0,
            roughness: 0.2,
            metalness: 0.85
          });
          const bracketMat = new THREE.MeshStandardMaterial({
            color: 0xA0A0A0,
            roughness: 0.25,
            metalness: 0.8
          });

          const barRadius = 0.02;
          const bracketSize = 0.06;

          // Main bar
          const bar = new THREE.Mesh(
            new THREE.CylinderGeometry(barRadius, barRadius, w - bracketSize * 2, 16),
            barMat
          );
          bar.rotation.z = Math.PI / 2;
          bar.position.set(0, 0, barRadius + 0.02);
          group.add(bar);

          // End brackets
          [-1, 1].forEach(side => {
            // Bracket base
            const bracket = new THREE.Mesh(
              new THREE.CylinderGeometry(bracketSize / 2, bracketSize / 2, 0.03, 16),
              bracketMat
            );
            bracket.rotation.x = Math.PI / 2;
            bracket.position.set(side * (w / 2 - bracketSize / 2), 0, 0.015);
            group.add(bracket);

            // Bracket arm
            const arm = new THREE.Mesh(
              new THREE.CylinderGeometry(barRadius, barRadius, barRadius * 3, 12),
              barMat
            );
            arm.rotation.x = Math.PI / 2;
            arm.position.set(side * (w / 2 - bracketSize / 2), 0, barRadius + 0.02);
            group.add(arm);
          });

          break;
        }

        case 'grab-bar-24':
        case 'grab-bar-36':
        case 'grab-bar-42': {
          // ADA-compliant grab bars for bathrooms
          // Lengths: 24", 36", 42" (2ft, 3ft, 3.5ft)
          const grabBarMat = createMetalMaterial(el.finish || 'brushed-nickel');
          const flangeMat = new THREE.MeshStandardMaterial({
            color: 0xA0A0A0,
            roughness: 0.25,
            metalness: 0.8,
            envMap: window.roomEnvMap || null,
            envMapIntensity: 1.0
          });

          const barDiameter = 0.042; // 1.25" standard ADA diameter
          const flangeRadius = 0.05;
          const flangeDepth = 0.025;
          const standoffLength = 0.05;

          // Main grab bar
          const bar = new THREE.Mesh(
            new THREE.CylinderGeometry(barDiameter / 2, barDiameter / 2, w - flangeRadius * 4, 24),
            grabBarMat
          );
          bar.rotation.z = Math.PI / 2;
          bar.position.set(0, 0, standoffLength + barDiameter / 2);
          bar.castShadow = true;
          group.add(bar);

          // End flanges (mounting plates)
          [-1, 1].forEach(side => {
            // Wall flange (circular mounting plate)
            const flange = new THREE.Mesh(
              new THREE.CylinderGeometry(flangeRadius, flangeRadius, flangeDepth, 24),
              flangeMat
            );
            flange.rotation.x = Math.PI / 2;
            flange.position.set(side * (w / 2 - flangeRadius - 0.02), 0, flangeDepth / 2);
            flange.castShadow = true;
            group.add(flange);

            // Standoff (connection from flange to bar)
            const standoff = new THREE.Mesh(
              new THREE.CylinderGeometry(barDiameter / 2, barDiameter / 2, standoffLength, 16),
              grabBarMat
            );
            standoff.rotation.x = Math.PI / 2;
            standoff.position.set(side * (w / 2 - flangeRadius - 0.02), 0, flangeDepth + standoffLength / 2);
            standoff.castShadow = true;
            group.add(standoff);

            // 90-degree elbow (curved connection to horizontal bar)
            const elbowRadius = barDiameter;
            const elbow = new THREE.Mesh(
              new THREE.TorusGeometry(elbowRadius, barDiameter / 2, 12, 8, Math.PI / 2),
              grabBarMat
            );
            elbow.rotation.y = side === 1 ? 0 : Math.PI;
            elbow.rotation.z = Math.PI / 2;
            elbow.position.set(
              side * (w / 2 - flangeRadius - 0.02 - elbowRadius),
              0,
              standoffLength + barDiameter / 2
            );
            group.add(elbow);
          });

          // Add mounting screw indicators on flanges
          [-1, 1].forEach(side => {
            [[-0.025, 0.025], [0.025, 0.025], [-0.025, -0.025], [0.025, -0.025]].forEach(([ox, oy]) => {
              const screw = new THREE.Mesh(
                new THREE.CylinderGeometry(0.004, 0.004, 0.005, 8),
                new THREE.MeshStandardMaterial({ color: 0x606060, metalness: 0.9, roughness: 0.3 })
              );
              screw.rotation.x = Math.PI / 2;
              screw.position.set(side * (w / 2 - flangeRadius - 0.02) + ox, oy, 0.002);
              group.add(screw);
            });
          });

          break;
        }

        case 'toilet-paper': {
          // Toilet paper holder
          const holderMat = new THREE.MeshStandardMaterial({
            color: 0xC0C0C0,
            roughness: 0.2,
            metalness: 0.8
          });
          const paperMat = new THREE.MeshStandardMaterial({
            color: 0xFFFAF0,
            roughness: 0.7
          });

          // Back plate
          const backPlate = new THREE.Mesh(
            new THREE.BoxGeometry(0.08, 0.1, 0.015),
            holderMat
          );
          backPlate.position.set(-w / 4, 0, -d / 4);
          group.add(backPlate);

          // Holder arm
          const arm = new THREE.Mesh(
            new THREE.CylinderGeometry(0.012, 0.012, w * 0.8, 12),
            holderMat
          );
          arm.rotation.z = Math.PI / 2;
          arm.position.set(0, 0, 0);
          group.add(arm);

          // Paper roll
          const rollOuter = new THREE.Mesh(
            new THREE.CylinderGeometry(h * 0.4, h * 0.4, w * 0.6, 24),
            paperMat
          );
          rollOuter.rotation.z = Math.PI / 2;
          rollOuter.position.set(0, 0, 0);
          group.add(rollOuter);

          // Roll center (cardboard tube)
          const rollCenter = new THREE.Mesh(
            new THREE.CylinderGeometry(h * 0.12, h * 0.12, w * 0.65, 16),
            new THREE.MeshStandardMaterial({ color: 0xD4A76A, roughness: 0.8 })
          );
          rollCenter.rotation.z = Math.PI / 2;
          rollCenter.position.set(0, 0, 0);
          group.add(rollCenter);

          break;
        }

        case 'closet-drawers':
        case 'jewelry-drawer': {
          // Drawer unit for closets
          const drawerBodyMat = new THREE.MeshStandardMaterial({
            color: el.color ? parseInt(el.color.replace('#', ''), 16) : 0x8B7355,
            roughness: 0.5
          });
          const handleMat = new THREE.MeshStandardMaterial({
            color: 0xC0C0C0,
            roughness: 0.25,
            metalness: 0.7
          });

          // Main body
          const body = new THREE.Mesh(
            new THREE.BoxGeometry(w, h, d),
            drawerBodyMat
          );
          group.add(body);

          // Drawer fronts
          const numDrawers = el.type === 'jewelry-drawer' ? 2 : 4;
          const drawerH = (h - 0.05) / numDrawers;
          const gap = 0.01;

          for (let di = 0; di < numDrawers; di++) {
            const drawerY = -h / 2 + drawerH / 2 + di * drawerH + gap * di;

            // Drawer face
            const face = new THREE.Mesh(
              new THREE.BoxGeometry(w - 0.02, drawerH - gap, 0.03),
              drawerBodyMat
            );
            face.position.set(0, drawerY, d / 2 + 0.015);
            group.add(face);

            // Drawer handle
            const drawHandle = new THREE.Mesh(
              new THREE.BoxGeometry(w * 0.3, 0.02, 0.02),
              handleMat
            );
            drawHandle.position.set(0, drawerY, d / 2 + 0.04);
            group.add(drawHandle);
          }

          break;
        }

        default:
          // Default box
          const defaultMat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.5 });
          const defaultMesh = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), defaultMat);
          group.add(defaultMesh);
      }

      // Set shadows for all meshes in group
      group.traverse(child => {
        if (child.isMesh) {
          child.castShadow = true;
          child.receiveShadow = true;
        }
      });

      return { group, height: h };
    }

    /**
     * Build room structure (floor + walls) - cached for performance
     * Only rebuilds when room dimensions change
     */
    function buildRoomStructure() {
      const wallHeight = roomHeight || 8;

      // Check if we need to rebuild
      const dimensionsChanged =
        cachedRoomDimensions.width !== roomWidth ||
        cachedRoomDimensions.depth !== roomDepth ||
        cachedRoomDimensions.height !== wallHeight;

      if (cachedRoomStructure && !dimensionsChanged && !forceFullRebuild3D) {
        // Return cached structure
        return cachedRoomStructure;
      }

      // Remove old structure if it exists
      if (cachedRoomStructure) {
        cachedRoomStructure.forEach(mesh => {
          if (mesh.geometry) mesh.geometry.dispose();
          if (mesh.material) mesh.material.dispose();
          scene.remove(mesh);
        });
      }

      const structure = [];

      // Floor
      const floorMat = new THREE.MeshStandardMaterial({
        color: 0xD2B48C,
        roughness: 0.8
      });
      const floor = new THREE.Mesh(
        new THREE.PlaneGeometry(roomWidth + 4, roomDepth + 4),
        floorMat
      );
      floor.rotation.x = -Math.PI / 2;
      floor.position.set(roomWidth / 2, 0, roomDepth / 2);
      floor.receiveShadow = true;
      floor.userData.isRoomStructure = true;
      structure.push(floor);

      // Wall material
      const wallMat = new THREE.MeshStandardMaterial({
        color: 0xFFFAF0,
        roughness: 0.9,
        side: THREE.DoubleSide
      });

      // Back wall
      const backWall = new THREE.Mesh(
        new THREE.PlaneGeometry(roomWidth, wallHeight),
        wallMat.clone()
      );
      backWall.position.set(roomWidth / 2, wallHeight / 2, 0);
      backWall.receiveShadow = true;
      backWall.userData.isRoomStructure = true;
      structure.push(backWall);

      // Left wall
      const leftWall = new THREE.Mesh(
        new THREE.PlaneGeometry(roomDepth, wallHeight),
        wallMat.clone()
      );
      leftWall.rotation.y = Math.PI / 2;
      leftWall.position.set(0, wallHeight / 2, roomDepth / 2);
      leftWall.receiveShadow = true;
      leftWall.userData.isRoomStructure = true;
      structure.push(leftWall);

      // Right wall
      const rightWall = new THREE.Mesh(
        new THREE.PlaneGeometry(roomDepth, wallHeight),
        wallMat.clone()
      );
      rightWall.rotation.y = -Math.PI / 2;
      rightWall.position.set(roomWidth, wallHeight / 2, roomDepth / 2);
      rightWall.receiveShadow = true;
      rightWall.userData.isRoomStructure = true;
      structure.push(rightWall);

      // Front wall (optional)
      if (sceneSettings.showFrontWall) {
        const frontWallMat = new THREE.MeshStandardMaterial({
          color: 0xFFFAF0,
          roughness: 0.9,
          side: THREE.DoubleSide,
          transparent: true,
          opacity: sceneSettings.wallTransparency || 0.5
        });
        const frontWall = new THREE.Mesh(
          new THREE.PlaneGeometry(roomWidth, wallHeight),
          frontWallMat
        );
        frontWall.rotation.y = Math.PI;
        frontWall.position.set(roomWidth / 2, wallHeight / 2, roomDepth);
        frontWall.receiveShadow = true;
        frontWall.userData.isRoomStructure = true;
        structure.push(frontWall);
      }

      // Add all to scene
      structure.forEach(mesh => scene.add(mesh));

      // Cache
      cachedRoomStructure = structure;
      cachedRoomDimensions = { width: roomWidth, depth: roomDepth, height: wallHeight };

      return structure;
    }

    function render3D() {
      if (!scene || currentView !== '3d') return;

      try {
      // Check if we need full rebuild or incremental update
      const needsFullRebuild = forceFullRebuild3D || dirtyElements3D.size === 0;

      if (needsFullRebuild) {
        // Clear non-lights and non-room-structure elements
        scene.children = scene.children.filter(c =>
          c.type.includes('Light') || c.userData?.isRoomStructure
        );

        // Clear mesh cache for full rebuild
        meshCache3D.forEach((cached, id) => {
          if (cached && cached.group && scene) {
            scene.remove(cached.group);
          }
        });
        meshCache3D.clear();
      }

      // Build/get room structure (cached)
      buildRoomStructure();

      // Reset full rebuild flag
      forceFullRebuild3D = false;

      // Elements - filter out hidden ones AND filter by current room
      const activeRoomId = currentRoomId || currentRoom || 'default';

      const visibleElements3D = elements.filter(el => {
        if (el.hidden) return false;
        // Only show elements belonging to current room (check both room tracking systems)
        // If element has no roomId, show it (legacy element or shared design)
        if (el.roomId && el.roomId !== activeRoomId && el.roomId !== currentRoom) {
          return false;
        }
        const category = getElementCategory(el.type);
        return !hiddenCategories[category];
      });

      // Track which elements are currently visible (for cleanup)
      const visibleElementIds = new Set(visibleElements3D.map(el => el.id));

      // Remove meshes for elements that are no longer visible
      meshCache3D.forEach((cached, elementId) => {
        if (!visibleElementIds.has(elementId)) {
          if (cached && cached.group) {
            scene.remove(cached.group);
            // Dispose resources
            cached.group.traverse(obj => {
              if (obj.geometry) obj.geometry.dispose();
              if (obj.material) {
                if (Array.isArray(obj.material)) {
                  obj.material.forEach(m => m.dispose());
                } else {
                  obj.material.dispose();
                }
              }
            });
          }
          meshCache3D.delete(elementId);
        }
      });

      visibleElements3D.forEach(el => {
        // Check if we can skip this element (cached and not dirty)
        const cached = meshCache3D.get(el.id);
        const currentVersion = elementVersions.get(el.id) || 0;
        const isDirty = dirtyElements3D.has(el.id);

        // Skip if cached, not dirty, and version matches
        if (cached && !isDirty && !needsFullRebuild && cached.version === currentVersion) {
          return; // Skip - already rendered and unchanged
        }

        // Remove old mesh if it exists
        if (cached && cached.group) {
          scene.remove(cached.group);
          cached.group.traverse(obj => {
            if (obj.geometry) obj.geometry.dispose();
            if (obj.material) {
              if (Array.isArray(obj.material)) {
                obj.material.forEach(m => m.dispose());
              } else {
                obj.material.dispose();
              }
            }
          });
        }

        let group, height;
        try {
          const result = create3DElement(el);
          if (result && result.group) {
            group = result.group;
            height = result.height || 1;
          } else {
            throw new Error('create3DElement returned invalid result');
          }
        } catch (err) {
          console.error(`Error creating 3D element for ${el.type} (${el.label}):`, err);
          // Create a fallback simple box
          group = new THREE.Group();
          height = 1;
          const fallbackMat = new THREE.MeshStandardMaterial({ color: 0xff0000, wireframe: true });
          const fallbackBox = new THREE.Mesh(new THREE.BoxGeometry(el.width || 1, 1, el.height || 1), fallbackMat);
          group.add(fallbackBox);
        }

        // Skip if group is still somehow undefined
        if (!group) {
          console.warn(`Skipping element ${el.type} - no 3D group created`);
          return;
        }

        // Convert 2D position to 3D
        // In 2D: origin is top-left, Y goes down
        // In 3D: origin is corner, Z goes forward (into room)
        let xPos = (el.x / pixelsPerFoot) + el.width / 2;
        let zPos = (el.y / pixelsPerFoot) + el.height / 2;
        const yPos = get3DYPosition(el, height);

        // Windows and doors snap to wall surface
        const windowDoorTypes = [
          'window', 'window-large', 'window-bay', 'bay-window', 'picture-window',
          'door', 'double-door', 'sliding-door', 'french-door', 'glass-door',
          'entry-archway', 'garage-door'
        ];
        // Niches embed INTO the wall
        const nicheTypes = ['wall-niche', 'fireplace-niche', 'tv-niche', 'shower-niche'];
        const isNiche = nicheTypes.includes(el.type);
        const isWindowDoor = windowDoorTypes.includes(el.type);

        // Grab bars also mount to walls
        const grabBarTypes = ['grab-bar', 'grab-bar-24', 'grab-bar-36', 'grab-bar-42'];
        const isGrabBar = grabBarTypes.includes(el.type);

        // Backsplash mounts flat against walls (vertical panel)
        const isBacksplash = el.type === 'backsplash';

        // Wall-mounted shelves (mantel, closet-shelf, microwave-cabinet)
        const wallMountedShelfTypes = ['mantel', 'closet-shelf', 'microwave-cabinet'];
        const isWallMountedShelf = wallMountedShelfTypes.includes(el.type);

        // Wall-mounted bathroom/closet accessories (thin items that sit close to wall)
        const wallAccessoryTypes = [
          'mirror', 'medicine-cabinet', 'towel-bar', 'towel-warmer', 'toilet-paper',
          'closet-rod', 'tie-rack', 'full-mirror'
        ];
        const isWallAccessory = wallAccessoryTypes.includes(el.type);

        // Range hood mounts on wall above stove
        const isRangeHood = el.type === 'range-hood';

        // Cabinets and appliances that should auto-rotate when against side/front walls
        const cabinetApplianceTypes = [
          'base-cabinet', 'wall-cabinet', 'tall-cabinet', 'drawer-base', 'sink-base',
          'corner-cabinet', 'lazy-susan', 'fridge-cabinet',
          'refrigerator', 'range', 'dishwasher', 'oven', 'microwave', 'range-hood',
          'countertop'
        ];
        const isCabinetAppliance = cabinetApplianceTypes.includes(el.type);

        // Check if element is against a side or front wall (not back wall)
        const el2DX = el.x / pixelsPerFoot;
        const el2DY = el.y / pixelsPerFoot;
        const elRightEdge = el2DX + el.width;
        const elBottomEdge = el2DY + el.height;
        const wallThreshold = 0.5; // Within 0.5ft of wall

        // Detect which wall the element is against
        const isAgainstRightWall = (roomWidth - elRightEdge) < wallThreshold;
        const isAgainstLeftWall = el2DX < wallThreshold;
        const isAgainstFrontWall = (roomDepth - elBottomEdge) < wallThreshold;
        const isAgainstBackWall = el2DY < wallThreshold;

        // Auto-rotate cabinets/appliances based on wall position (only if no manual rotation set)
        // IMPORTANT: rotation=0 IS a valid manual rotation (back wall facing into room)
        // Only auto-rotate if rotation is truly undefined/null (not set at all)
        let autoRotated = false;
        const hasManualRotation = el.rotation !== undefined && el.rotation !== null;
        if (isCabinetAppliance && !hasManualRotation) {
          if (isAgainstRightWall && !isAgainstBackWall) {
            // Right wall - rotate to face left (into room)
            group.rotation.y = -Math.PI / 2;
            autoRotated = true;
            // When rotated -90, the element's 2D width becomes Z-depth, 2D height becomes X-width
            // Recalculate position: element's right edge should align with wall
            xPos = roomWidth - el.height / 2; // Position from right wall, use depth as offset
            zPos = (el.y / pixelsPerFoot) + el.width / 2; // Use width for Z extent
          } else if (isAgainstLeftWall && !isAgainstBackWall) {
            // Left wall - rotate to face right (into room)
            group.rotation.y = Math.PI / 2;
            autoRotated = true;
            // When rotated +90, similar swap
            xPos = el.height / 2; // Position from left wall
            zPos = (el.y / pixelsPerFoot) + el.width / 2;
          } else if (isAgainstFrontWall && !isAgainstBackWall) {
            // Front wall - rotate to face back (into room)
            group.rotation.y = Math.PI;
            autoRotated = true;
            // When rotated 180, dimensions stay same orientation but element faces opposite
            zPos = roomDepth - el.height / 2;
          }
          // Back wall elements keep default rotation (facing into room)
        }

        if (isWindowDoor || isNiche || isGrabBar || isBacksplash || isWallMountedShelf || isWallAccessory || isRangeHood) {
          // Determine which wall based on 2D position and rotation
          const rotation = (el.rotation || 0) % 360;
          const normalizedRotation = rotation < 0 ? rotation + 360 : rotation;
          const el2DY = el.y / pixelsPerFoot;
          const el2DX = el.x / pixelsPerFoot;
          const elCenterX = el2DX + el.width / 2;
          const elCenterY = el2DY + el.height / 2;

          // Calculate distances to each wall edge
          const distToBack = el2DY;                                    // Top wall (back in 3D)
          const distToFront = roomDepth - (el2DY + el.height);        // Bottom wall (front in 3D)
          const distToLeft = el2DX;                                    // Left wall
          const distToRight = roomWidth - (el2DX + el.width);         // Right wall

          // Wall detection threshold (how close to wall to snap)
          const threshold = 3;

          // Determine wall primarily by rotation, with position as tiebreaker
          let closestWall;

          // Rotation is the primary indicator of which wall the element faces
          if (normalizedRotation === 90) {
            closestWall = 'left';
          } else if (normalizedRotation === 270) {
            closestWall = 'right';
          } else if (normalizedRotation === 180) {
            closestWall = 'front';
          } else if (normalizedRotation === 0) {
            // No rotation - use position to determine wall
            // Find the wall this element is closest to
            const distances = [
              { wall: 'back', dist: distToBack },
              { wall: 'front', dist: distToFront },
              { wall: 'left', dist: distToLeft },
              { wall: 'right', dist: distToRight }
            ];

            // Sort by distance and pick closest within threshold
            distances.sort((a, b) => a.dist - b.dist);
            closestWall = distances[0].dist <= threshold ? distances[0].wall : 'back';
          } else {
            // Non-standard rotation - use closest wall by position
            const distances = [
              { wall: 'back', dist: distToBack },
              { wall: 'front', dist: distToFront },
              { wall: 'left', dist: distToLeft },
              { wall: 'right', dist: distToRight }
            ];
            distances.sort((a, b) => a.dist - b.dist);
            closestWall = distances[0].wall;
          }

          // Calculate wall offset based on element type
          // Niches embed into wall, backsplash sits thin against wall, shelves protrude from wall
          let wallOffset;
          if (isNiche) {
            wallOffset = 0; // Embedded in wall
          } else if (isBacksplash) {
            wallOffset = 0.04; // Thin, just off wall
          } else if (isWallAccessory) {
            wallOffset = 0.05; // Thin accessories (mirrors, towel bars) sit very close to wall
          } else if (isRangeHood) {
            wallOffset = el.height / 2; // Range hood protrudes from wall by its depth
          } else if (isWallMountedShelf) {
            wallOffset = el.height / 2; // Shelf protrudes from wall by its depth
          } else {
            wallOffset = 0.1; // Default offset for windows/doors
          }

          // Position based on closest wall
          switch (closestWall) {
            case 'back':
              zPos = wallOffset;
              group.rotation.y = 0;
              break;
            case 'front':
              zPos = roomDepth - wallOffset;
              group.rotation.y = Math.PI;
              break;
            case 'left':
              zPos = elCenterY;
              xPos = wallOffset;
              group.rotation.y = Math.PI / 2;
              break;
            case 'right':
              zPos = elCenterY;
              xPos = roomWidth - wallOffset;
              group.rotation.y = -Math.PI / 2;
              break;
          }
        } else if (!autoRotated) {
          // Only apply manual rotation if not auto-rotated
          group.rotation.y = -(el.rotation || 0) * Math.PI / 180;
        }

        group.position.set(xPos, yPos, zPos);

        // Store element data for tooltips
        group.userData.elementData = el;

        // Add to scene
        scene.add(group);

        // Cache the mesh for incremental updates
        meshCache3D.set(el.id, {
          group: group,
          version: currentVersion
        });

        // Clear dirty flag for this element
        dirtyElements3D.delete(el.id);
      });

      // Clear any remaining dirty flags (for elements that weren't visible)
      dirtyElements3D.clear();

      // Render custom walls from wall tool
      if (walls && walls.length > 0) {
        walls.filter(w => w.type === 'wall').forEach(wall => {
          // Convert pixel coordinates to feet
          const wallX = wall.x / pixelsPerFoot;
          const wallY = wall.y / pixelsPerFoot;
          const wallW = wall.width / pixelsPerFoot;
          const wallD = wall.height / pixelsPerFoot;
          const wallH = wall.wallHeight || 3.5; // Default 3.5 feet (42") for pony walls

          // Create wall material
          const wallColor = wall.color || '#444444';
          const customWallMat = new THREE.MeshStandardMaterial({
            color: new THREE.Color(wallColor),
            roughness: 0.8,
            metalness: 0.1
          });

          // Determine if horizontal or vertical wall based on aspect ratio
          const isVertical = wallD > wallW;

          // Create wall mesh - BoxGeometry(widthX, heightY, depthZ)
          const wallMesh = new THREE.Mesh(
            new THREE.BoxGeometry(wallW, wallH, wallD),
            customWallMat
          );

          // Position: center of the wall
          const xPos = wallX + wallW / 2;
          const yPos = wallH / 2; // Center vertically
          const zPos = wallY + wallD / 2;

          wallMesh.position.set(xPos, yPos, zPos);
          wallMesh.castShadow = true;
          wallMesh.receiveShadow = true;

          // Store wall data for tooltips
          wallMesh.userData.elementData = {
            type: 'custom-wall',
            width: wallW,
            height: wallD,
            wallHeight: wallH,
            label: `Wall ${Math.round(isVertical ? wallD * 12 : wallW * 12)}"  ${Math.round(wallH * 12)}"`
          };

          scene.add(wallMesh);
        });
      }

      // Update camera target - aim at center of room at counter height
      const centerX = roomWidth / 2;
      const centerZ = roomDepth / 2;
      const targetHeight = 3; // ~3 feet up (counter height view)
      controls.target.set(centerX, targetHeight, centerZ);

      // Position camera for optimal room view
      // Height should be eye level (~5.5 ft) plus some elevation for overview
      // Distance should scale with room size for good perspective
      const roomDiagonal = Math.sqrt(roomWidth * roomWidth + roomDepth * roomDepth);
      const cameraDistance = Math.max(roomDiagonal * 0.8, 10); // At least 10ft back
      const cameraHeight = Math.max(6, roomHeight * 0.7); // Eye level or 70% of room height

      // Position at corner angle for best 3D perspective
      camera.position.set(
        centerX + cameraDistance * 0.7,  // Offset right from center
        cameraHeight,                     // Eye level height
        centerZ + cameraDistance * 0.7   // Offset forward from center
      );
      controls.update();

      // Animation loop with proper ID tracking
      function animate() {
        if (currentView !== '3d') {
          animationId = null;
          return;
        }
        animationId = requestAnimationFrame(animate);
        controls.update();

        // Use post-processing composer if available, otherwise standard render
        if (composer && postProcessingEnabled && window._postProcessing?.enabled) {
          composer.render();
        } else {
          renderer.render(scene, camera);
        }

        // Update axis indicator to match main camera orientation
        if (window._axisIndicator) {
          const axis = window._axisIndicator;
          // Copy main camera quaternion to axis camera
          // Position axis camera at a fixed distance looking at origin
          const axisDistance = 3;
          axis.camera.position.copy(camera.position).sub(controls.target).normalize().multiplyScalar(axisDistance);
          axis.camera.lookAt(0, 0, 0);
          axis.camera.up.copy(camera.up);
          axis.renderer.render(axis.scene, axis.camera);
        }
      }
      animate();

      // Setup 3D tooltip raycasting
      setup3DTooltips();
      } catch (renderErr) {
        console.error('Error in 3D rendering:', renderErr);
        showSnapFeedback('3D rendering error - check console for details');
      }
    }

    // 3D Tooltip system with raycasting
    const raycaster3D = new THREE.Raycaster();
    const mouse3D = new THREE.Vector2();
    let hoveredObject3D = null;

    function setup3DTooltips() {
      const container = document.getElementById('three-container');
      if (!container) return;

      container.addEventListener('mousemove', on3DMouseMove);
      container.addEventListener('mouseleave', hide3DTooltip);
    }

    function on3DMouseMove(event) {
      if (!renderer || !camera || !scene || currentView !== '3d') return;

      const container = document.getElementById('three-container');
      const rect = container.getBoundingClientRect();

      mouse3D.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
      mouse3D.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

      raycaster3D.setFromCamera(mouse3D, camera);

      // Get all meshes in scene that have userData.elementData
      const intersects = raycaster3D.intersectObjects(scene.children, true);

      let foundElement = null;
      for (const intersect of intersects) {
        // Walk up to find group with element data
        let obj = intersect.object;
        while (obj && !obj.userData?.elementData) {
          obj = obj.parent;
        }
        if (obj?.userData?.elementData) {
          foundElement = obj.userData.elementData;
          break;
        }
      }

      if (foundElement) {
        show3DTooltip(foundElement, event.clientX, event.clientY);
        hoveredObject3D = foundElement;
      } else {
        hide3DTooltip();
        hoveredObject3D = null;
      }
    }

    function show3DTooltip(el, x, y) {
      const tooltip = document.getElementById('tooltip3D');
      const labelEl = document.getElementById('tooltip3DLabel');
      const sizeEl = document.getElementById('tooltip3DSize');

      if (!tooltip) return;

      labelEl.textContent = el.label || el.type;
      sizeEl.textContent = `${formatDimension(el.width)}  ${formatDimension(el.height)}`;

      tooltip.style.display = 'block';
      tooltip.style.left = (x + 15) + 'px';
      tooltip.style.top = (y + 15) + 'px';
    }

    function hide3DTooltip() {
      const tooltip = document.getElementById('tooltip3D');
      if (tooltip) tooltip.style.display = 'none';
    }

    // ===== 3D DIMENSION LABELS & MEASUREMENT TOOL =====
    let measurementMode = false;
    let measurementPoints = [];
    let measurementLine = null;
    let measurementLabels = [];
    let dimensionSprites = [];

    // Create text sprite for 3D labels
    // Helper: Draw rounded rectangle (polyfill for browsers without roundRect)
    function drawRoundedRect(ctx, x, y, width, height, radius) {
      if (typeof ctx.roundRect === 'function') {
        ctx.roundRect(x, y, width, height, radius);
      } else {
        // Fallback for browsers without roundRect support
        ctx.moveTo(x + radius, y);
        ctx.lineTo(x + width - radius, y);
        ctx.arcTo(x + width, y, x + width, y + radius, radius);
        ctx.lineTo(x + width, y + height - radius);
        ctx.arcTo(x + width, y + height, x + width - radius, y + height, radius);
        ctx.lineTo(x + radius, y + height);
        ctx.arcTo(x, y + height, x, y + height - radius, radius);
        ctx.lineTo(x, y + radius);
        ctx.arcTo(x, y, x + radius, y, radius);
        ctx.closePath();
      }
    }

    function createTextSprite(text, options = {}) {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      const fontSize = options.fontSize || 48;
      const padding = 12;

      ctx.font = `bold ${fontSize}px Inter, system-ui, sans-serif`;
      const textMetrics = ctx.measureText(text);
      const textWidth = textMetrics.width;

      canvas.width = textWidth + padding * 2;
      canvas.height = fontSize + padding * 2;

      // Background with rounded corners
      ctx.fillStyle = options.bgColor || 'rgba(30, 41, 59, 0.9)';
      const radius = 8;
      ctx.beginPath();
      drawRoundedRect(ctx, 0, 0, canvas.width, canvas.height, radius);
      ctx.fill();

      // Border
      ctx.strokeStyle = options.borderColor || 'rgba(99, 102, 241, 0.8)';
      ctx.lineWidth = 2;
      ctx.stroke();

      // Text
      ctx.font = `bold ${fontSize}px Inter, system-ui, sans-serif`;
      ctx.fillStyle = options.textColor || '#ffffff';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(text, canvas.width / 2, canvas.height / 2);

      const texture = new THREE.CanvasTexture(canvas);
      texture.minFilter = THREE.LinearFilter;
      texture.encoding = THREE.sRGBEncoding;

      const material = new THREE.SpriteMaterial({
        map: texture,
        transparent: true,
        depthTest: false,
        depthWrite: false
      });

      const sprite = new THREE.Sprite(material);
      const scale = options.scale || 0.015;
      sprite.scale.set(canvas.width * scale, canvas.height * scale, 1);

      return sprite;
    }

    // Show dimension labels for selected element in 3D
    function show3DDimensions(element) {
      clear3DDimensions();
      if (!element || !scene) return;

      const w = element.width;
      const h = element.height || element.depth;
      const d = element.depth || 0.5;
      const x = element.x + w / 2;
      const z = element.y + h / 2;
      const height3D = get3DHeight(element);

      // Width label (front edge)
      const widthLabel = createTextSprite(formatDimension(w), { bgColor: 'rgba(99, 102, 241, 0.9)' });
      widthLabel.position.set(x, height3D - 0.3, z + h / 2 + 0.5);
      scene.add(widthLabel);
      dimensionSprites.push(widthLabel);

      // Depth label (side edge)
      const depthLabel = createTextSprite(formatDimension(h), { bgColor: 'rgba(16, 185, 129, 0.9)' });
      depthLabel.position.set(x + w / 2 + 0.5, height3D - 0.3, z);
      scene.add(depthLabel);
      dimensionSprites.push(depthLabel);

      // Height label (vertical)
      if (height3D > 0.5) {
        const heightLabel = createTextSprite(formatDimension(get3DHeight(element) * 2), { bgColor: 'rgba(245, 158, 11, 0.9)' });
        heightLabel.position.set(x - w / 2 - 0.5, height3D / 2, z - h / 2 - 0.3);
        scene.add(heightLabel);
        dimensionSprites.push(heightLabel);
      }
    }

    // Clear dimension labels
    function clear3DDimensions() {
      if (scene) {
        dimensionSprites.forEach(sprite => {
          if (sprite.material.map) sprite.material.map.dispose();
          sprite.material.dispose();
          scene.remove(sprite);
        });
      }
      dimensionSprites = [];
    }

    // Toggle measurement mode
    window.toggleMeasurementMode = function() {
      measurementMode = !measurementMode;
      const btn = document.getElementById('measureBtn');

      if (measurementMode) {
        if (btn) {
          btn.classList.add('active');
          btn.style.background = 'linear-gradient(135deg, #10b981, #059669)';
          btn.style.color = '#fff';
        }
        showToast('Measurement mode ON - Click two points to measure distance', 'success');
        clearMeasurement();

        // Add click handler for measurement
        const container = document.getElementById('three-container');
        if (container) {
          container.style.cursor = 'crosshair';
          container.addEventListener('click', onMeasurementClick);
        }
      } else {
        if (btn) {
          btn.classList.remove('active');
          btn.style.background = '';
          btn.style.color = '';
        }
        showToast('Measurement mode OFF', 'info');
        clearMeasurement();

        const container = document.getElementById('three-container');
        if (container) {
          container.style.cursor = '';
          container.removeEventListener('click', onMeasurementClick);
        }
      }
    };

    function onMeasurementClick(event) {
      if (!measurementMode || !renderer || !camera || !scene) return;

      const container = document.getElementById('three-container');
      const rect = container.getBoundingClientRect();

      const mouse = new THREE.Vector2(
        ((event.clientX - rect.left) / rect.width) * 2 - 1,
        -((event.clientY - rect.top) / rect.height) * 2 + 1
      );

      const raycaster = new THREE.Raycaster();
      raycaster.setFromCamera(mouse, camera);

      // Get all meshes in the scene
      const meshes = [];
      scene.traverse(obj => {
        if (obj.isMesh) meshes.push(obj);
      });

      const intersects = raycaster.intersectObjects(meshes, false);

      if (intersects.length > 0) {
        const point = intersects[0].point.clone();
        measurementPoints.push(point);

        // Add point marker
        const markerGeom = new THREE.SphereGeometry(0.1, 16, 16);
        const markerMat = new THREE.MeshBasicMaterial({ color: 0x10b981 });
        const marker = new THREE.Mesh(markerGeom, markerMat);
        marker.position.copy(point);
        scene.add(marker);
        measurementLabels.push(marker);

        if (measurementPoints.length === 2) {
          // Calculate and show distance
          const distance = measurementPoints[0].distanceTo(measurementPoints[1]);

          // Create line between points
          const lineGeom = new THREE.BufferGeometry().setFromPoints(measurementPoints);
          const lineMat = new THREE.LineBasicMaterial({ color: 0x10b981, linewidth: 2 });
          measurementLine = new THREE.Line(lineGeom, lineMat);
          scene.add(measurementLine);

          // Create distance label at midpoint
          const midpoint = new THREE.Vector3().addVectors(measurementPoints[0], measurementPoints[1]).multiplyScalar(0.5);
          const distanceLabel = createTextSprite(formatDimension(distance), {
            bgColor: 'rgba(16, 185, 129, 0.95)',
            borderColor: 'rgba(255, 255, 255, 0.5)',
            fontSize: 56,
            scale: 0.018
          });
          distanceLabel.position.copy(midpoint);
          distanceLabel.position.y += 0.3;
          scene.add(distanceLabel);
          measurementLabels.push(distanceLabel);

          showToast(`Distance: ${formatDimension(distance)}`, 'success');

          // Reset for next measurement after a delay
          setTimeout(() => {
            measurementPoints = [];
          }, 100);
        }
      }
    }

    function clearMeasurement() {
      measurementPoints = [];

      if (measurementLine && scene) {
        scene.remove(measurementLine);
        measurementLine.geometry.dispose();
        measurementLine.material.dispose();
        measurementLine = null;
      }

      if (scene) {
        measurementLabels.forEach(obj => {
          scene.remove(obj);
          if (obj.geometry) obj.geometry.dispose();
          if (obj.material) {
            if (obj.material.map) obj.material.map.dispose();
            obj.material.dispose();
          }
        });
      }
      measurementLabels = [];
    }

    // Show room dimensions in 3D
    function showRoomDimensions() {
      const room = rooms[currentRoomIndex];
      if (!room || !scene) return;

      const w = room.width;
      const d = room.depth;
      const h = room.height || 9;

      // Width label (front wall)
      const widthLabel = createTextSprite(`${formatDimension(w)} wide`, {
        bgColor: 'rgba(99, 102, 241, 0.85)',
        fontSize: 52,
        scale: 0.02
      });
      widthLabel.position.set(w / 2, 0.3, d + 1);
      scene.add(widthLabel);
      dimensionSprites.push(widthLabel);

      // Depth label (side wall)
      const depthLabel = createTextSprite(`${formatDimension(d)} deep`, {
        bgColor: 'rgba(16, 185, 129, 0.85)',
        fontSize: 52,
        scale: 0.02
      });
      depthLabel.position.set(w + 1, 0.3, d / 2);
      scene.add(depthLabel);
      dimensionSprites.push(depthLabel);

      // Height label
      const heightLabel = createTextSprite(`${formatDimension(h)} ceiling`, {
        bgColor: 'rgba(245, 158, 11, 0.85)',
        fontSize: 52,
        scale: 0.02
      });
      heightLabel.position.set(-0.8, h / 2, 0);
      scene.add(heightLabel);
      dimensionSprites.push(heightLabel);
    }

    // Toggle room dimensions display
    window.toggleRoomDimensions = function() {
      if (dimensionSprites.length > 0) {
        clear3DDimensions();
        showToast('Room dimensions hidden', 'info');
      } else {
        showRoomDimensions();
        showToast('Room dimensions shown', 'success');
      }
    };

    // ===== LIGHTING CONTROLS =====
    let currentLightingPreset = 'noon';
    let baseLightIntensities = {};

    window.toggleLightingPanel = function() {
      const panel = document.getElementById('lightingPanel');
      const btn = document.getElementById('lightingBtn');
      if (panel) {
        const isVisible = panel.style.display !== 'none';
        panel.style.display = isVisible ? 'none' : 'block';
        if (btn) {
          btn.classList.toggle('active', !isVisible);
          if (!isVisible) {
            btn.style.background = 'linear-gradient(135deg, #f59e0b, #d97706)';
            btn.style.color = '#fff';
          } else {
            btn.style.background = '';
            btn.style.color = '';
          }
        }
      }
    };

    window.setLightingPreset = function(preset, buttonElement) {
      currentLightingPreset = preset;

      // Update preset buttons - find and highlight the correct one
      document.querySelectorAll('.preset-btn').forEach(btn => btn.classList.remove('active'));
      if (buttonElement) {
        buttonElement.classList.add('active');
      } else {
        // Find by preset name if button not passed
        const presetBtn = document.querySelector(`.preset-btn[title="${preset.charAt(0).toUpperCase() + preset.slice(1)}"]`);
        if (presetBtn) presetBtn.classList.add('active');
      }

      const presets = {
        morning: { ambient: 0.4, key: 0.9, fill: 0.3, exposure: 1.0, color: 0xFFF5E0 },
        noon: { ambient: 0.5, key: 1.2, fill: 0.4, exposure: 1.2, color: 0xFFFBF0 },
        evening: { ambient: 0.35, key: 0.7, fill: 0.25, exposure: 0.9, color: 0xFFD4A0 },
        night: { ambient: 0.2, key: 0.3, fill: 0.15, exposure: 0.6, color: 0xC0D0E0 },
        showroom: { ambient: 0.7, key: 1.5, fill: 0.6, exposure: 1.4, color: 0xFFFFFF }
      };

      const p = presets[preset] || presets.noon;

      // Apply lighting changes
      if (scene) {
        scene.traverse(obj => {
          if (obj.isAmbientLight) {
            obj.intensity = p.ambient;
          } else if (obj.isHemisphereLight) {
            obj.intensity = p.ambient * 0.8;
          } else if (obj.isDirectionalLight) {
            if (obj.name === 'keyLight' || obj.name === 'sunLight') {
              obj.intensity = p.key;
              obj.color.setHex(p.color);
            } else if (obj.name === 'fillLight') {
              obj.intensity = p.fill;
            }
          }
        });

        // Update exposure
        if (renderer) {
          renderer.toneMappingExposure = p.exposure;
        }
      }

      // Update sliders
      document.getElementById('brightnessSlider').value = p.key * 100;
      document.getElementById('brightnessValue').textContent = Math.round(p.key * 100) + '%';
      document.getElementById('ambientSlider').value = p.ambient * 100;
      document.getElementById('ambientValue').textContent = Math.round(p.ambient * 100) + '%';

      showToast(`Lighting: ${preset.charAt(0).toUpperCase() + preset.slice(1)}`, 'success');
    };

    window.adjustBrightness = function(value) {
      const intensity = value / 100;
      document.getElementById('brightnessValue').textContent = value + '%';

      if (scene) {
        scene.traverse(obj => {
          if (obj.isDirectionalLight && (obj.name === 'keyLight' || obj.name === 'sunLight')) {
            obj.intensity = intensity;
          }
        });
      }
    };

    window.adjustAmbient = function(value) {
      const intensity = value / 100;
      document.getElementById('ambientValue').textContent = value + '%';

      if (scene) {
        scene.traverse(obj => {
          if (obj.isAmbientLight) {
            obj.intensity = intensity;
          } else if (obj.isHemisphereLight) {
            obj.intensity = intensity * 0.8;
          }
        });
      }
    };

    window.adjustShadows = function(value) {
      document.getElementById('shadowValue').textContent = value + '%';

      if (scene) {
        scene.traverse(obj => {
          if (obj.isDirectionalLight && obj.castShadow) {
            obj.shadow.intensity = value / 100;
          }
        });
      }
    };

    window.toggleShadows = function(enabled) {
      if (renderer) {
        renderer.shadowMap.enabled = enabled;
      }
      if (scene) {
        scene.traverse(obj => {
          if (obj.isMesh) {
            obj.castShadow = enabled;
            obj.receiveShadow = enabled;
          }
        });
      }
      showToast(enabled ? 'Shadows enabled' : 'Shadows disabled', 'info');
    };

    // HD Mode - Enhanced rendering quality for countertop colors
    window.hdRenderMode = false;

    window.toggleHDMode = function(enabled) {
      window.hdRenderMode = enabled;

      if (renderer) {
        // Higher pixel ratio for sharper textures (careful with performance)
        renderer.setPixelRatio(enabled ? Math.min(window.devicePixelRatio * 1.5, 3) : window.devicePixelRatio);

        // Enhanced tone mapping for better color reproduction
        renderer.toneMapping = enabled ? THREE.ACESFilmicToneMapping : THREE.ReinhardToneMapping;
        renderer.toneMappingExposure = enabled ? 1.2 : 1.0;

        // Better shadow quality in HD mode
        if (enabled) {
          renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        }
      }

      // Update countertop materials with enhanced settings
      if (scene) {
        scene.traverse(obj => {
          if (obj.isMesh && obj.material && obj.material.isMeshPhysicalMaterial) {
            // Enhance clearcoat for HD mode
            if (enabled) {
              obj.material.clearcoat = Math.min(obj.material.clearcoat * 1.3, 1);
              obj.material.envMapIntensity = Math.min(obj.material.envMapIntensity * 1.2, 1.5);
            }
            obj.material.needsUpdate = true;
          }
        });
      }

      // Re-render to apply changes
      if (typeof render3D === 'function') {
        render3D();
      } else if (renderer && scene && camera) {
        renderer.render(scene, camera);
      }

      showToast(enabled ? 'HD Mode enabled - Enhanced countertop colors' : 'HD Mode disabled', 'info');
    };

    // ===== INTERACTIVE CABINET DOORS =====
    // Track cabinet door states and animations
    const cabinetDoorStates = new Map(); // elementId -> { doorIndex: isOpen }
    let interactiveModeEnabled = true;

    // Setup interactive cabinet click handler
    function setupCabinetInteraction() {
      const container = document.getElementById('three-container');
      if (!container) return;

      container.addEventListener('dblclick', onCabinetDoubleClick);
    }

    function onCabinetDoubleClick(event) {
      if (!interactiveModeEnabled || !renderer || !camera || !scene || currentView !== '3d') return;

      const container = document.getElementById('three-container');
      const rect = container.getBoundingClientRect();

      const mouse = new THREE.Vector2(
        ((event.clientX - rect.left) / rect.width) * 2 - 1,
        -((event.clientY - rect.top) / rect.height) * 2 + 1
      );

      const raycaster = new THREE.Raycaster();
      raycaster.setFromCamera(mouse, camera);

      // Get all meshes
      const meshes = [];
      scene.traverse(obj => {
        if (obj.isMesh && obj.userData.elementId) meshes.push(obj);
      });

      const intersects = raycaster.intersectObjects(meshes, false);

      if (intersects.length > 0) {
        const hitObject = intersects[0].object;
        const elementId = hitObject.userData.elementId;
        const partType = hitObject.userData.partType;

        // Check if it's a door or drawer
        if (partType === 'door' || partType === 'drawer') {
          toggleCabinetDoor(elementId, hitObject, partType);
        }
      }
    }

    function toggleCabinetDoor(elementId, doorMesh, partType) {
      // Get the door group (pivot point) from the mesh
      const doorGroup = doorMesh.userData.doorGroup || doorMesh;
      const doorId = doorGroup.uuid;

      if (!cabinetDoorStates.has(doorId)) {
        // Get hinge direction from userData
        const hingeOnLeft = doorGroup.userData?.hingeOnLeft ?? true;
        const openAngle = doorGroup.userData?.openAngle ?? (hingeOnLeft ? Math.PI / 2 : -Math.PI / 2);

        cabinetDoorStates.set(doorId, {
          isOpen: false,
          originalRotation: doorGroup.rotation.clone(),
          originalPosition: doorGroup.position.clone(),
          hingeOnLeft: hingeOnLeft,
          openAngle: openAngle
        });
      }

      const state = cabinetDoorStates.get(doorId);
      const targetOpen = !state.isOpen;

      // Animate the door/drawer
      animateCabinetPart(doorGroup, partType, targetOpen, state);

      state.isOpen = targetOpen;
      showToast(targetOpen ? 'Door opened' : 'Door closed', 'info');
    }

    function animateCabinetPart(obj, partType, opening, state) {
      const duration = 400; // ms
      const startTime = performance.now();

      const startRotation = obj.rotation.y;
      const startPosition = obj.position.z;

      // Target values based on door swing direction
      let targetRotation = startRotation;
      let targetPosition = startPosition;

      if (partType === 'door') {
        // Doors swing open - use the openAngle from state (accounts for hinge side)
        const openAngle = state.openAngle || Math.PI / 2;
        targetRotation = opening ? state.originalRotation.y + openAngle : state.originalRotation.y;
      } else if (partType === 'drawer') {
        // Drawers slide out - use slideDistance from userData or default
        const slideDistance = obj.userData?.slideDistance || 0.8;
        targetPosition = opening ? state.originalPosition.z + slideDistance : state.originalPosition.z;
      }

      function animate() {
        const elapsed = performance.now() - startTime;
        const progress = Math.min(elapsed / duration, 1);

        // Ease out cubic
        const eased = 1 - Math.pow(1 - progress, 3);

        if (partType === 'door') {
          obj.rotation.y = startRotation + (targetRotation - startRotation) * eased;
        } else if (partType === 'drawer') {
          obj.position.z = startPosition + (targetPosition - startPosition) * eased;
        }

        if (progress < 1) {
          requestAnimationFrame(animate);
        }

        // Re-render the scene
        if (renderer && scene && camera) {
          renderer.render(scene, camera);
        }
      }

      animate();
    }

    // Toggle interactive mode
    window.toggleInteractiveMode = function() {
      interactiveModeEnabled = !interactiveModeEnabled;
      showToast(interactiveModeEnabled ? 'Interactive mode ON - Double-click doors/drawers to open' : 'Interactive mode OFF', 'info');
    };

    // Initialize cabinet interaction when 3D view is set up
    setTimeout(setupCabinetInteraction, 1000);

    // ===== MATERIAL DRAG & DROP TO 3D VIEW =====
    let draggingMaterial = null;
    let dropPreviewMesh = null;

    function setup3DMaterialDrop() {
      const container = document.getElementById('three-container');
      if (!container) return;

      container.addEventListener('dragover', on3DDragOver);
      container.addEventListener('drop', on3DDrop);
      container.addEventListener('dragleave', on3DDragLeave);
    }

    function on3DDragOver(event) {
      event.preventDefault();
      event.dataTransfer.dropEffect = 'copy';

      if (!renderer || !camera || !scene || currentView !== '3d') return;

      const container = document.getElementById('three-container');
      const rect = container.getBoundingClientRect();

      const mouse = new THREE.Vector2(
        ((event.clientX - rect.left) / rect.width) * 2 - 1,
        -((event.clientY - rect.top) / rect.height) * 2 + 1
      );

      const raycaster = new THREE.Raycaster();
      raycaster.setFromCamera(mouse, camera);

      // Find element under cursor
      const meshes = [];
      scene.traverse(obj => {
        if (obj.isMesh && obj.userData.elementId) meshes.push(obj);
      });

      const intersects = raycaster.intersectObjects(meshes, false);

      // Clear previous highlight
      if (dropPreviewMesh && dropPreviewMesh !== intersects[0]?.object) {
        if (dropPreviewMesh.userData.originalEmissive !== undefined) {
          dropPreviewMesh.material.emissive?.setHex(dropPreviewMesh.userData.originalEmissive);
        }
        dropPreviewMesh = null;
      }

      // Highlight hovered element
      if (intersects.length > 0) {
        const mesh = intersects[0].object;
        if (mesh.material && mesh.material.emissive) {
          if (!dropPreviewMesh || dropPreviewMesh !== mesh) {
            mesh.userData.originalEmissive = mesh.material.emissive.getHex();
            mesh.material.emissive.setHex(0x333366);
            dropPreviewMesh = mesh;
          }
        }
      }
    }

    function on3DDragLeave(event) {
      // Clear highlight
      if (dropPreviewMesh) {
        if (dropPreviewMesh.userData.originalEmissive !== undefined) {
          dropPreviewMesh.material.emissive?.setHex(dropPreviewMesh.userData.originalEmissive);
        }
        dropPreviewMesh = null;
      }
    }

    function on3DDrop(event) {
      event.preventDefault();

      // Clear highlight
      if (dropPreviewMesh) {
        if (dropPreviewMesh.userData.originalEmissive !== undefined) {
          dropPreviewMesh.material.emissive?.setHex(dropPreviewMesh.userData.originalEmissive);
        }
      }

      if (!renderer || !camera || !scene || currentView !== '3d') return;

      // Get dropped material data
      const materialData = event.dataTransfer.getData('application/json');
      if (!materialData) {
        dropPreviewMesh = null;
        return;
      }

      try {
        const material = JSON.parse(materialData);

        const container = document.getElementById('three-container');
        const rect = container.getBoundingClientRect();

        const mouse = new THREE.Vector2(
          ((event.clientX - rect.left) / rect.width) * 2 - 1,
          -((event.clientY - rect.top) / rect.height) * 2 + 1
        );

        const raycaster = new THREE.Raycaster();
        raycaster.setFromCamera(mouse, camera);

        const meshes = [];
        scene.traverse(obj => {
          if (obj.isMesh && obj.userData.elementId) meshes.push(obj);
        });

        const intersects = raycaster.intersectObjects(meshes, false);

        if (intersects.length > 0) {
          const hitMesh = intersects[0].object;
          const elementId = hitMesh.userData.elementId;

          // Find the element in our data
          const room = rooms[currentRoomIndex];
          const element = room?.elements?.find(el => el.id === elementId);

          if (element) {
            // Check material type compatibility before applying
            const materialCategory = material.category || material.type || '';
            if (!canApplyMaterialToElement(materialCategory, element)) {
              dropPreviewMesh = null;
              return;
            }

            // Apply material to element
            element.material = material.name;
            element.materialId = material.id;
            element.texture = material.image || material.texture;
            element.color = material.color;

            // Update 3D view
            update3DScene();

            showToast(`Applied "${material.name}" to ${element.label || element.type}`, 'success');
          }
        }
      } catch (e) {
        console.error('Failed to parse dropped material:', e);
      }

      dropPreviewMesh = null;
    }

    // Make material cards draggable
    function enableMaterialDrag() {
      document.querySelectorAll('.material-card, .product-card').forEach(card => {
        card.draggable = true;
        card.addEventListener('dragstart', (e) => {
          // Try to determine material category from the id or data attributes
          let category = card.dataset.category || card.dataset.type || '';
          if (!category && card.dataset.id) {
            // Look up category from MATERIALS object
            for (const [cat, materials] of Object.entries(MATERIALS)) {
              if (materials.find(m => m.id === card.dataset.id)) {
                category = cat;
                break;
              }
            }
          }
          const materialData = {
            id: card.dataset.id,
            name: card.dataset.name || card.querySelector('.material-name, .product-name')?.textContent,
            image: card.dataset.image || card.querySelector('img')?.src,
            color: card.dataset.color,
            price: card.dataset.price,
            category: category,
            type: card.dataset.type || category
          };
          e.dataTransfer.setData('application/json', JSON.stringify(materialData));
          e.dataTransfer.effectAllowed = 'copy';
        });
      });
    }

    // Initialize drag-drop when ready
    setTimeout(() => {
      setup3DMaterialDrop();
      enableMaterialDrag();
    }, 2000);

    // Re-enable drag after material list updates
    const materialListObserver = new MutationObserver(() => {
      enableMaterialDrag();
    });

    setTimeout(() => {
      const materialContainer = document.querySelector('.material-grid, .product-grid');
      if (materialContainer) {
        materialListObserver.observe(materialContainer, { childList: true, subtree: true });
      }
    }, 3000);

    // ===== HIGH-RESOLUTION SCREENSHOT =====
    window.captureHighResScreenshot = function() {
      if (!renderer || !scene || !camera) {
        showToast('3D view not available', 'error');
        return;
      }

      showToast('Capturing high-resolution screenshot...', 'info');

      // Store original size
      const originalWidth = renderer.domElement.width;
      const originalHeight = renderer.domElement.height;
      const originalPixelRatio = renderer.getPixelRatio();

      // Set high resolution (4x for 4K-like output)
      const scale = 3;
      const newWidth = originalWidth * scale;
      const newHeight = originalHeight * scale;

      renderer.setSize(newWidth, newHeight, false);
      renderer.setPixelRatio(1);

      // Render at high resolution
      if (composer && postProcessingEnabled && window._postProcessing?.enabled) {
        composer.setSize(newWidth, newHeight);
        composer.render();
      } else {
        renderer.render(scene, camera);
      }

      // Capture image
      const dataUrl = renderer.domElement.toDataURL('image/png', 1.0);

      // Restore original size
      renderer.setSize(originalWidth, originalHeight, false);
      renderer.setPixelRatio(originalPixelRatio);
      if (composer) {
        composer.setSize(originalWidth, originalHeight);
      }

      // Create download link
      const link = document.createElement('a');
      const room = rooms[currentRoomIndex];
      const filename = `${room?.name || 'room'}-3d-${Date.now()}.png`;
      link.download = filename;
      link.href = dataUrl;
      link.click();

      showToast('Screenshot saved!', 'success');
    };

    // ===== ZOOM =====
    function zoomIn() {
      const wrapper = document.getElementById('canvasWrapper');
      const centerX = wrapper.clientWidth / 2;
      const centerY = wrapper.clientHeight / 2;

      const worldX = (centerX - panX) / pixelsPerFoot;
      const worldY = (centerY - panY) / pixelsPerFoot;

      pixelsPerFoot = Math.min(pixelsPerFoot * 1.2, 200); // Allow closer zoom (up to 500%)

      panX = centerX - worldX * pixelsPerFoot;
      panY = centerY - worldY * pixelsPerFoot;

      updateZoomDisplay();
      draw();
    }

    function zoomOut() {
      const wrapper = document.getElementById('canvasWrapper');
      const centerX = wrapper.clientWidth / 2;
      const centerY = wrapper.clientHeight / 2;

      const worldX = (centerX - panX) / pixelsPerFoot;
      const worldY = (centerY - panY) / pixelsPerFoot;

      pixelsPerFoot = Math.max(pixelsPerFoot / 1.2, 5); // Allow further zoom out (down to ~12%)

      panX = centerX - worldX * pixelsPerFoot;
      panY = centerY - worldY * pixelsPerFoot;

      updateZoomDisplay();
      draw();
    }

    function updateZoomDisplay() {
      const zoomPercent = Math.round(pixelsPerFoot / 40 * 100);
      document.getElementById('zoomLevel').textContent = zoomPercent + '%';
    }

    // Reset zoom to 100% and center the room
    function resetZoom() {
      const wrapper = document.getElementById('canvasWrapper');
      pixelsPerFoot = 40; // 100%

      // Center the room in the canvas
      panX = (wrapper.clientWidth - roomWidth * pixelsPerFoot) / 2;
      panY = (wrapper.clientHeight - roomDepth * pixelsPerFoot) / 2;

      updateZoomDisplay();
      draw();
      showSnapFeedback('Zoom reset to 100%');
    }

    function toggleViewLock() {
      viewLocked = !viewLocked;
      const btn = document.getElementById('lockViewBtn');
      const icon = document.getElementById('lockIcon');
      if (btn) {
        btn.title = viewLocked ? 'Unlock view (allow pan/zoom)' : 'Lock view (prevent pan/zoom)';
        btn.style.background = viewLocked ? 'rgba(249, 203, 0, 0.2)' : '';
        btn.style.borderColor = viewLocked ? 'var(--gold)' : '';
      }
      if (icon) {
        // Update lock icon - locked shows closed shackle
        const path = icon.querySelector('path');
        if (path) {
          path.setAttribute('d', viewLocked ? 'M7 11V7a5 5 0 0 1 10 0v4' : 'M7 11V7a5 5 0 0 1 9 0');
        }
        icon.style.stroke = viewLocked ? 'var(--gold)' : '';
      }
      showSnapFeedback(viewLocked ? 'View locked - pan/zoom disabled' : 'View unlocked');
    }

    // ===== ROOM =====
    function updateRoom() {
      roomWidth = parseInt(document.getElementById('roomWidth').value) || 20;
      roomDepth = parseInt(document.getElementById('roomDepth').value) || 16;

      if (document.getElementById('scaleMode').value === 'fit') {
        fitToScreen();
      } else {
        updateCanvasSize();
      }

      if (currentView === '3d') {
        init3D();
        render3D();
      }
    }

    // ===== ROOM TEMPLATES =====
    // Rotation guide (top-down view, doors/drawers face INTO room):
    //   Back wall (y=0):    rotation = 0   (faces down/south into room)
    //   Right wall (x=max): rotation = 90  (faces left/west into room)
    //   Front wall (y=max): rotation = 180 (faces up/north into room)
    //   Left wall (x=0):    rotation = 270 (faces right/east into room)
    const ROOM_TEMPLATES = {
      'kitchen-l': {
        name: 'L-Shaped Kitchen',
        roomType: 'kitchen',
        width: 12,
        depth: 10,
        elements: [
          // === BACK WALL (y=0) - faces into room (rotation: 0) ===
          // Work triangle: Fridge left, Sink center, Range on right wall
          { type: 'refrigerator', x: 0, y: 0, width: 3, height: 2.5, label: 'Fridge', rotation: 0 },
          { type: 'base-cabinet', x: 3, y: 0, width: 2, height: 2, label: 'Base 24"', rotation: 0 },
          { type: 'dishwasher', x: 5, y: 0, width: 2, height: 2, label: 'Dishwasher', rotation: 0 },
          { type: 'sink-base', x: 7, y: 0, width: 3, height: 2, label: 'Sink Base 36"', rotation: 0 },
          { type: 'base-cabinet', x: 10, y: 0, width: 2, height: 2, label: 'Base 24"', rotation: 0 },
          // Countertop: 2.17' depth (2' cabinet + 2" front overhang)
          { type: 'countertop', x: 2.88, y: -0.04, width: 9.29, height: 2.21, label: 'Counter', rotation: 0, overhangFront: 0.167, overhangBack: 0, overhangLeft: 0.125, overhangRight: 0.125 },
          { type: 'sink', x: 7.5, y: 0.25, width: 2, height: 1.5, label: 'Sink', rotation: 0 },
          // Upper cabinets on back wall
          { type: 'wall-cabinet', x: 3, y: 0, width: 4, height: 1, label: 'Upper 48"', rotation: 0 },
          { type: 'wall-cabinet', x: 7, y: 0, width: 3, height: 1, label: 'Upper 36"', rotation: 0 },
          { type: 'wall-cabinet', x: 10, y: 0, width: 2, height: 1, label: 'Upper 24"', rotation: 0 },

          // === RIGHT WALL (x=10) - faces into room (rotation: 90) ===
          // Range centered with cabinets on both sides
          { type: 'base-cabinet', x: 10, y: 2, width: 2, height: 2, label: 'Base 24"', rotation: 90 },
          { type: 'countertop', x: 9.83, y: 1.88, width: 2.17, height: 2.25, label: 'Counter', rotation: 0, overhangFront: 0.167, overhangBack: 0, overhangLeft: 0.125, overhangRight: 0.125 },
          { type: 'wall-cabinet', x: 10, y: 2, width: 1, height: 2, label: 'Upper', rotation: 90 },
          { type: 'range', x: 10, y: 4, width: 2.5, height: 2.5, label: 'Range 30"', rotation: 90 },
          { type: 'range-hood', x: 10, y: 4.25, width: 1, height: 2, label: 'Hood', rotation: 90 },
          { type: 'base-cabinet', x: 10, y: 6.5, width: 2, height: 2, label: 'Base 24"', rotation: 90 },
          { type: 'base-cabinet', x: 10, y: 8.5, width: 2, height: 1.5, label: 'Base 18"', rotation: 90 },
          { type: 'countertop', x: 9.83, y: 6.38, width: 2.17, height: 3.75, label: 'Counter', rotation: 0, overhangFront: 0.167, overhangBack: 0, overhangLeft: 0.125, overhangRight: 0.125 },
          { type: 'wall-cabinet', x: 10, y: 6.5, width: 1, height: 3.5, label: 'Uppers', rotation: 90 },

          // === BACKSPLASH ===
          { type: 'backsplash', x: 3, y: 0, width: 9, height: 0.08, label: 'Backsplash', rotation: 0 },
          { type: 'backsplash', x: 10, y: 2, width: 0.08, height: 8, label: 'Backsplash', rotation: 90 },

          // === ISLAND - faces seating side (rotation: 180) ===
          // Island with breakfast bar overhang on seating side, waterfalls on ends
          { type: 'base-cabinet', x: 2.5, y: 5, width: 5, height: 2, label: 'Island Base', rotation: 180 },
          { type: 'countertop', x: 2.33, y: 4.83, width: 5.33, height: 3.17, label: 'Island Top', rotation: 0, waterfallSides: ['left', 'right'], overhangFront: 0.167, overhangBack: 0.75, overhangLeft: 0.167, overhangRight: 0.167 },
        ]
      },
      'kitchen-galley': {
        name: 'Galley Kitchen',
        roomType: 'kitchen',
        width: 12,
        depth: 8,
        elements: [
          // === BACK WALL (y=0) - faces into room (rotation: 0) ===
          // Sink side with dishwasher
          { type: 'base-cabinet', x: 0, y: 0, width: 2, height: 2, label: 'Base 24"', rotation: 0 },
          { type: 'dishwasher', x: 2, y: 0, width: 2, height: 2, label: 'Dishwasher', rotation: 0 },
          { type: 'sink-base', x: 4, y: 0, width: 3, height: 2, label: 'Sink Base 36"', rotation: 0 },
          { type: 'base-cabinet', x: 7, y: 0, width: 2, height: 2, label: 'Base 24"', rotation: 0 },
          { type: 'base-cabinet', x: 9, y: 0, width: 3, height: 2, label: 'Base 36"', rotation: 0 },
          { type: 'countertop', x: -0.125, y: -0.04, width: 12.25, height: 2.21, label: 'Counter', rotation: 0, overhangFront: 0.167, overhangBack: 0, overhangLeft: 0.125, overhangRight: 0.125 },
          { type: 'sink', x: 4.5, y: 0.25, width: 2, height: 1.5, label: 'Sink', rotation: 0 },
          { type: 'wall-cabinet', x: 0, y: 0, width: 4, height: 1, label: 'Upper 48"', rotation: 0 },
          { type: 'wall-cabinet', x: 4, y: 0, width: 3, height: 1, label: 'Upper 36"', rotation: 0 },
          { type: 'wall-cabinet', x: 7, y: 0, width: 5, height: 1, label: 'Upper 60"', rotation: 0 },

          // === FRONT WALL (y=6) - faces into room (rotation: 180) ===
          // Range side with fridge
          { type: 'refrigerator', x: 0, y: 6, width: 3, height: 2.5, label: 'Fridge', rotation: 180 },
          { type: 'base-cabinet', x: 3, y: 6, width: 2, height: 2, label: 'Base 24"', rotation: 180 },
          { type: 'range', x: 5, y: 5.75, width: 2.5, height: 2.5, label: 'Range 30"', rotation: 180 },
          { type: 'range-hood', x: 5.25, y: 6, width: 2, height: 1, label: 'Hood', rotation: 180 },
          { type: 'base-cabinet', x: 7.5, y: 6, width: 2, height: 2, label: 'Base 24"', rotation: 180 },
          { type: 'base-cabinet', x: 9.5, y: 6, width: 2.5, height: 2, label: 'Base 30"', rotation: 180 },
          { type: 'countertop', x: 2.88, y: 5.79, width: 9.25, height: 2.21, label: 'Counter', rotation: 0, overhangFront: 0.167, overhangBack: 0, overhangLeft: 0.125, overhangRight: 0.125 },
          { type: 'wall-cabinet', x: 3, y: 7, width: 2, height: 1, label: 'Upper 24"', rotation: 180 },
          { type: 'wall-cabinet', x: 7.5, y: 7, width: 4.5, height: 1, label: 'Uppers', rotation: 180 },
          // === BACKSPLASH ===
          { type: 'backsplash', x: 0, y: 0, width: 12, height: 0.08, label: 'Backsplash', rotation: 0 },
          { type: 'backsplash', x: 3, y: 8, width: 9, height: 0.08, label: 'Backsplash', rotation: 180 },
        ]
      },
      'kitchen-u': {
        name: 'U-Shaped Kitchen',
        roomType: 'kitchen',
        width: 14,
        depth: 12,
        elements: [
          // === BACK WALL (y=0) - faces into room (rotation: 0) ===
          // Sink centered under window
          { type: 'base-cabinet', x: 2, y: 0, width: 2, height: 2, label: 'Base 24"', rotation: 0 },
          { type: 'dishwasher', x: 4, y: 0, width: 2, height: 2, label: 'Dishwasher', rotation: 0 },
          { type: 'sink-base', x: 6, y: 0, width: 3, height: 2, label: 'Sink Base 36"', rotation: 0 },
          { type: 'base-cabinet', x: 9, y: 0, width: 3, height: 2, label: 'Base 36"', rotation: 0 },
          { type: 'countertop', x: 1.88, y: -0.04, width: 10.25, height: 2.21, label: 'Counter', rotation: 0, overhangFront: 0.167, overhangBack: 0, overhangLeft: 0.125, overhangRight: 0.125 },
          { type: 'sink', x: 6.5, y: 0.25, width: 2, height: 1.5, label: 'Sink', rotation: 0 },
          { type: 'wall-cabinet', x: 2, y: 0, width: 4, height: 1, label: 'Upper 48"', rotation: 0 },
          { type: 'wall-cabinet', x: 6, y: 0, width: 3, height: 1, label: 'Upper 36"', rotation: 0 },
          { type: 'wall-cabinet', x: 9, y: 0, width: 3, height: 1, label: 'Upper 36"', rotation: 0 },

          // === LEFT WALL (x=0) - faces into room (rotation: 270) ===
          // Fridge at top, then pantry/storage
          { type: 'refrigerator', x: 0, y: 0, width: 2.5, height: 3, label: 'Fridge', rotation: 270 },
          { type: 'tall-cabinet', x: 0, y: 3, width: 2, height: 2, label: 'Pantry', rotation: 270 },
          { type: 'base-cabinet', x: 0, y: 5, width: 2, height: 2, label: 'Base 24"', rotation: 270 },
          { type: 'base-cabinet', x: 0, y: 7, width: 2, height: 2, label: 'Base 24"', rotation: 270 },
          { type: 'base-cabinet', x: 0, y: 9, width: 2, height: 2, label: 'Base 24"', rotation: 270 },
          { type: 'countertop', x: -0.04, y: 4.88, width: 2.21, height: 6.25, label: 'Counter', rotation: 0, overhangFront: 0.167, overhangBack: 0, overhangLeft: 0, overhangRight: 0.125 },
          { type: 'wall-cabinet', x: 0, y: 5, width: 1, height: 6, label: 'Uppers', rotation: 270 },

          // === RIGHT WALL (x=12) - faces into room (rotation: 90) ===
          // Range centered with cabinets on both sides
          { type: 'base-cabinet', x: 12, y: 0, width: 2, height: 2, label: 'Corner Base', rotation: 90 },
          { type: 'base-cabinet', x: 12, y: 2, width: 2, height: 2, label: 'Base 24"', rotation: 90 },
          { type: 'range', x: 12, y: 4, width: 2.5, height: 2.5, label: 'Range 30"', rotation: 90 },
          { type: 'range-hood', x: 12, y: 4.25, width: 1, height: 2, label: 'Hood', rotation: 90 },
          { type: 'base-cabinet', x: 12, y: 6.5, width: 2, height: 2, label: 'Base 24"', rotation: 90 },
          { type: 'base-cabinet', x: 12, y: 8.5, width: 2, height: 2.5, label: 'Base 30"', rotation: 90 },
          { type: 'countertop', x: 11.79, y: -0.125, width: 2.21, height: 4.25, label: 'Counter', rotation: 0, overhangFront: 0.167, overhangBack: 0, overhangLeft: 0.125, overhangRight: 0 },
          { type: 'countertop', x: 11.79, y: 6.38, width: 2.21, height: 4.75, label: 'Counter', rotation: 0, overhangFront: 0.167, overhangBack: 0, overhangLeft: 0.125, overhangRight: 0 },
          { type: 'wall-cabinet', x: 12, y: 0, width: 1, height: 4, label: 'Uppers', rotation: 90 },
          { type: 'wall-cabinet', x: 12, y: 6.5, width: 1, height: 4.5, label: 'Uppers', rotation: 90 },
        ]
      },
      'kitchen-single': {
        name: 'Single Wall Kitchen',
        roomType: 'kitchen',
        width: 14,
        depth: 8,
        elements: [
          // === SINGLE WALL (y=0) - compact kitchen on one wall ===
          // Layout: Fridge - Counter - Sink - Counter - Range - Counter
          { type: 'refrigerator', x: 0, y: 0, width: 3, height: 2.5, label: 'Fridge', rotation: 0 },
          { type: 'base-cabinet', x: 3, y: 0, width: 2, height: 2, label: 'Base 24"', rotation: 0 },
          { type: 'dishwasher', x: 5, y: 0, width: 2, height: 2, label: 'Dishwasher', rotation: 0 },
          { type: 'sink-base', x: 7, y: 0, width: 3, height: 2, label: 'Sink Base 36"', rotation: 0 },
          { type: 'base-cabinet', x: 10, y: 0, width: 1.5, height: 2, label: 'Base 18"', rotation: 0 },
          { type: 'range', x: 11.5, y: 0, width: 2.5, height: 2.5, label: 'Range 30"', rotation: 0 },
          { type: 'countertop', x: 2.88, y: -0.04, width: 8.75, height: 2.21, label: 'Counter', rotation: 0, overhangFront: 0.167, overhangBack: 0, overhangLeft: 0.125, overhangRight: 0.125 },
          { type: 'sink', x: 7.5, y: 0.25, width: 2, height: 1.5, label: 'Sink', rotation: 0 },
          { type: 'wall-cabinet', x: 3, y: 0, width: 4, height: 1, label: 'Upper 48"', rotation: 0 },
          { type: 'wall-cabinet', x: 7, y: 0, width: 3, height: 1, label: 'Upper 36"', rotation: 0 },
          { type: 'wall-cabinet', x: 10, y: 0, width: 1.5, height: 1, label: 'Upper 18"', rotation: 0 },
          { type: 'range-hood', x: 11.5, y: 0, width: 2.5, height: 1, label: 'Hood', rotation: 0 },

          // Optional island for extra prep space
          { type: 'base-cabinet', x: 4, y: 5, width: 6, height: 2, label: 'Island Base', rotation: 180 },
          { type: 'countertop', x: 3.83, y: 4.83, width: 6.33, height: 3.17, label: 'Island w/ Seating', rotation: 0, overhangFront: 0.167, overhangBack: 0.83, overhangLeft: 0.167, overhangRight: 0.167 },
        ]
      },
      'kitchen-peninsula': {
        name: 'Peninsula Kitchen',
        roomType: 'kitchen',
        width: 14,
        depth: 12,
        elements: [
          // === BACK WALL (y=0) - faces into room (rotation: 0) ===
          { type: 'refrigerator', x: 0, y: 0, width: 3, height: 2.5, label: 'Fridge', rotation: 0 },
          { type: 'base-cabinet', x: 3, y: 0, width: 2, height: 2, label: 'Base 24"', rotation: 0 },
          { type: 'dishwasher', x: 5, y: 0, width: 2, height: 2, label: 'Dishwasher', rotation: 0 },
          { type: 'sink-base', x: 7, y: 0, width: 3, height: 2, label: 'Sink Base 36"', rotation: 0 },
          { type: 'base-cabinet', x: 10, y: 0, width: 2, height: 2, label: 'Base 24"', rotation: 0 },
          { type: 'base-cabinet', x: 12, y: 0, width: 2, height: 2, label: 'Corner', rotation: 0 },
          { type: 'countertop', x: 2.88, y: -0.04, width: 11.25, height: 2.21, label: 'Counter', rotation: 0, overhangFront: 0.167, overhangBack: 0, overhangLeft: 0.125, overhangRight: 0.125 },
          { type: 'sink', x: 7.5, y: 0.25, width: 2, height: 1.5, label: 'Sink', rotation: 0 },
          { type: 'wall-cabinet', x: 3, y: 0, width: 4, height: 1, label: 'Upper 48"', rotation: 0 },
          { type: 'wall-cabinet', x: 7, y: 0, width: 3, height: 1, label: 'Upper 36"', rotation: 0 },
          { type: 'wall-cabinet', x: 10, y: 0, width: 4, height: 1, label: 'Uppers', rotation: 0 },

          // === RIGHT WALL (x=12) - faces into room (rotation: 90) ===
          { type: 'base-cabinet', x: 12, y: 2, width: 2, height: 2, label: 'Base 24"', rotation: 90 },
          { type: 'range', x: 12, y: 4, width: 2.5, height: 2.5, label: 'Range 30"', rotation: 90 },
          { type: 'range-hood', x: 12, y: 4.25, width: 1, height: 2, label: 'Hood', rotation: 90 },
          { type: 'base-cabinet', x: 12, y: 6.5, width: 2, height: 2, label: 'Base 24"', rotation: 90 },
          { type: 'countertop', x: 11.79, y: 1.88, width: 2.21, height: 2.25, label: 'Counter', rotation: 0, overhangFront: 0.167, overhangBack: 0, overhangLeft: 0.125, overhangRight: 0 },
          { type: 'countertop', x: 11.79, y: 6.38, width: 2.21, height: 2.25, label: 'Counter', rotation: 0, overhangFront: 0.167, overhangBack: 0, overhangLeft: 0.125, overhangRight: 0 },
          { type: 'wall-cabinet', x: 12, y: 2, width: 1, height: 2, label: 'Upper', rotation: 90 },
          { type: 'wall-cabinet', x: 12, y: 6.5, width: 1, height: 2, label: 'Upper', rotation: 90 },

          // === PENINSULA - attached to right wall, extends into room ===
          // Waterfall on end, breakfast bar overhang on open side
          { type: 'base-cabinet', x: 12, y: 8.5, width: 2, height: 3.5, label: 'Peninsula Base', rotation: 90 },
          { type: 'base-cabinet', x: 8, y: 10, width: 4, height: 2, label: 'Peninsula Base', rotation: 180 },
          { type: 'countertop', x: 7.83, y: 8.38, width: 6.21, height: 3.79, label: 'Peninsula Top', rotation: 0, waterfallSides: ['left'], overhangFront: 0.167, overhangBack: 0.83, overhangLeft: 0.167, overhangRight: 0 },
        ]
      },
      'bathroom-master': {
        name: 'Master Bathroom',
        roomType: 'bathroom',
        width: 12,
        depth: 10,
        elements: [
          // === BACK WALL (y=0) - Double vanity ===
          { type: 'base-cabinet', x: 0, y: 0, width: 2, height: 1.75, rotation: 0 },
          { type: 'base-cabinet', x: 2, y: 0, width: 2, height: 1.75, rotation: 0 },
          { type: 'base-cabinet', x: 4, y: 0, width: 2, height: 1.75, rotation: 0 },
          { type: 'countertop', x: -0.08, y: -0.04, width: 6.16, height: 2.02, color: '#d4a574', rotation: 0, overhangFront: 0.125, overhangBack: 0, overhangLeft: 0.08, overhangRight: 0.08 },
          { type: 'sink', x: 0.75, y: 0.2, width: 1.5, height: 1.2, rotation: 0 },
          { type: 'sink', x: 3.75, y: 0.2, width: 1.5, height: 1.2, rotation: 0 },
          // === RIGHT WALL (x=10) - Toilet faces left into room ===
          { type: 'toilet', x: 10, y: 4, width: 1.5, height: 2.3, rotation: 90 },
          // === LEFT WALL (x=0) - Bathtub ===
          { type: 'bathtub', x: 0, y: 5, width: 2.7, height: 5, rotation: 270 },
          // === RIGHT CORNER - Walk-in shower ===
          { type: 'shower-pan', x: 9, y: 0, width: 3, height: 3, rotation: 0 },
          { type: 'shower-wall', x: 9, y: 0, width: 0.3, height: 3, rotation: 0 },
          { type: 'shower-niche', x: 10.5, y: 0, width: 1.5, height: 0.5, rotation: 0 },
          // === BACK WALL - Linen closet ===
          { type: 'tall-cabinet', x: 7, y: 0, width: 2, height: 2, rotation: 0 },
        ]
      },
      'bathroom-half': {
        name: 'Half Bathroom',
        roomType: 'bathroom',
        width: 6,
        depth: 5,
        elements: [
          // === BACK WALL (y=0) - Vanity ===
          { type: 'base-cabinet', x: 0, y: 0, width: 2.5, height: 1.75, rotation: 0 },
          { type: 'countertop', x: -0.08, y: -0.04, width: 2.76, height: 1.92, color: '#d4a574', rotation: 0, overhangFront: 0.125, overhangBack: 0, overhangLeft: 0.08, overhangRight: 0.08 },
          { type: 'sink', x: 0.3, y: 0.2, width: 2, height: 1.3, rotation: 0 },
          // === RIGHT SIDE - Toilet faces into room ===
          { type: 'toilet', x: 4, y: 0.5, width: 1.5, height: 2.3, rotation: 0 },
        ]
      },
      'shower-walkin': {
        name: 'Walk-in Shower',
        roomType: 'shower',
        width: 6,
        depth: 5,
        elements: [
          // Shower pan
          { type: 'shower-pan', x: 0, y: 0, width: 6, height: 5 },
          // Shower walls with tile
          { type: 'shower-wall', x: 0, y: 0, width: 0.3, height: 5 },
          { type: 'shower-wall', x: 0, y: 0, width: 6, height: 0.3 },
          { type: 'shower-wall', x: 5.7, y: 0, width: 0.3, height: 5 },
          // Bench
          { type: 'shower-curb', x: 0.5, y: 3.5, width: 2, height: 1.2 },
          // Niches
          { type: 'shower-niche', x: 2, y: 1, width: 2, height: 0.5 },
          { type: 'shower-niche', x: 2, y: 2, width: 2, height: 0.5 },
          // Curb at entry
          { type: 'shower-curb', x: 0, y: 4.7, width: 3, height: 0.3 },
        ]
      },
      'closet-walkin': {
        name: 'Walk-in Closet',
        roomType: 'closet',
        width: 10,
        depth: 8,
        elements: [
          // === LEFT WALL (x=0) - Double hang, faces right into room ===
          { type: 'tall-cabinet', x: 0, y: 0, width: 1.5, height: 3, rotation: 270 },
          { type: 'tall-cabinet', x: 0, y: 3, width: 1.5, height: 2.5, rotation: 270 },
          { type: 'tall-cabinet', x: 0, y: 5.5, width: 1.5, height: 2.5, rotation: 270 },
          // === FRONT WALL (y=6.5) - Shelving and drawers, faces back into room ===
          { type: 'tall-cabinet', x: 2, y: 6.5, width: 2, height: 1.5, rotation: 180 },
          { type: 'drawer-base', x: 4, y: 6.5, width: 2, height: 1.5, rotation: 180 },
          { type: 'tall-cabinet', x: 6, y: 6.5, width: 2, height: 1.5, rotation: 180 },
          // === RIGHT WALL (x=8.5) - Long hang, faces left into room ===
          { type: 'tall-cabinet', x: 8.5, y: 0, width: 1.5, height: 4, rotation: 90 },
          { type: 'tall-cabinet', x: 8.5, y: 4, width: 1.5, height: 4, rotation: 90 },
          // === CENTER - Island/bench ===
          { type: 'island', x: 3.5, y: 2.5, width: 3, height: 2, rotation: 0 },
          { type: 'countertop', x: 3.33, y: 2.33, width: 3.33, height: 2.33, color: '#8B4513', rotation: 0, overhangFront: 0.167, overhangBack: 0.167, overhangLeft: 0.167, overhangRight: 0.167 },
        ]
      },
      'laundry-room': {
        name: 'Laundry Room',
        roomType: 'laundry',
        width: 10,
        depth: 8,
        elements: [
          // === BACK WALL (y=0) - Washer, dryer, and utility sink ===
          { type: 'dishwasher', x: 0, y: 0, width: 2.3, height: 2.3, label: 'Washer', rotation: 0 },
          { type: 'dishwasher', x: 2.5, y: 0, width: 2.3, height: 2.3, label: 'Dryer', rotation: 0 },
          // Upper cabinets above W/D
          { type: 'wall-cabinet', x: 0, y: 0, width: 2.5, height: 1, rotation: 0 },
          { type: 'wall-cabinet', x: 2.5, y: 0, width: 2.5, height: 1, rotation: 0 },
          // Utility sink area
          { type: 'base-cabinet', x: 5.5, y: 0, width: 2, height: 2, rotation: 0 },
          { type: 'sink-base', x: 7.5, y: 0, width: 2.5, height: 2, rotation: 0 },
          { type: 'countertop', x: 5.38, y: -0.04, width: 4.7, height: 2.21, color: '#708090', rotation: 0, overhangFront: 0.167, overhangBack: 0, overhangLeft: 0.125, overhangRight: 0.08 },
          { type: 'sink', x: 7.75, y: 0.25, width: 2, height: 1.5, rotation: 0 },
          // === FRONT WALL (y=6) - Folding counter, faces back into room ===
          { type: 'base-cabinet', x: 0, y: 6, width: 2, height: 2, rotation: 180 },
          { type: 'base-cabinet', x: 2, y: 6, width: 2, height: 2, rotation: 180 },
          { type: 'base-cabinet', x: 4, y: 6, width: 2, height: 2, rotation: 180 },
          { type: 'countertop', x: -0.08, y: 5.79, width: 6.16, height: 2.21, color: '#708090', rotation: 0, overhangFront: 0.167, overhangBack: 0, overhangLeft: 0.08, overhangRight: 0.08 },
          // Wall cabinets
          { type: 'wall-cabinet', x: 0, y: 7, width: 2, height: 1, rotation: 180 },
          { type: 'wall-cabinet', x: 2, y: 7, width: 2, height: 1, rotation: 180 },
          { type: 'wall-cabinet', x: 4, y: 7, width: 2, height: 1, rotation: 180 },
          // Tall storage
          { type: 'tall-cabinet', x: 8, y: 6, width: 2, height: 2, rotation: 180 },
        ]
      }
    };

    // Export current design as template code (for developers to copy)
    function exportAsTemplate() {
      const templateName = prompt('Enter a name for this template:', 'My Kitchen');
      if (!templateName) return;

      const templateId = templateName.toLowerCase().replace(/\s+/g, '-').replace(/[^a-z0-9-]/g, '');
      const roomType = document.getElementById('roomType')?.value || 'kitchen';

      // Convert elements to template format (positions in feet, not pixels)
      const templateElements = elements.map(el => {
        const elDef = {
          type: el.type,
          x: Math.round((el.x / pixelsPerFoot) * 100) / 100,
          y: Math.round((el.y / pixelsPerFoot) * 100) / 100,
          width: Math.round(el.width * 100) / 100,
          height: Math.round(el.height * 100) / 100
        };

        // Include optional properties if set
        if (el.label) elDef.label = el.label;
        if (el.rotation) elDef.rotation = el.rotation;
        if (el.color && el.color !== getDefaultColor(el.type)) elDef.color = el.color;
        if (el.waterfallSides && el.waterfallSides.length > 0) elDef.waterfallSides = el.waterfallSides;
        if (el.waterfallHeight) elDef.waterfallHeight = el.waterfallHeight;
        if (el.edgeProfile && el.edgeProfile !== 'eased') elDef.edgeProfile = el.edgeProfile;
        if (el.thickness && el.thickness !== '3cm') elDef.thickness = el.thickness;
        if (el.finishedEnds && el.finishedEnds.length > 0) elDef.finishedEnds = el.finishedEnds;

        return elDef;
      });

      // Generate template code
      const templateCode = `'${templateId}': {
  name: '${templateName}',
  roomType: '${roomType}',
  width: ${roomWidth},
  depth: ${roomDepth},
  elements: ${JSON.stringify(templateElements, null, 4).replace(/"([^"]+)":/g, '$1:')}
}`;

      // Show in a modal or copy to clipboard
      const modal = document.createElement('div');
      modal.style.cssText = 'position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.8);z-index:10000;display:flex;align-items:center;justify-content:center;';
      modal.innerHTML = `
        <div style="background:#1a1a2e;padding:24px;border-radius:12px;max-width:800px;max-height:80vh;overflow:auto;color:#fff;">
          <h3 style="margin:0 0 16px;">Template Code</h3>
          <p style="color:#888;margin-bottom:12px;">Copy this code and add it to ROOM_TEMPLATES in index.html:</p>
          <textarea id="templateCodeOutput" style="width:100%;height:400px;background:#0d0d15;color:#10b981;font-family:monospace;font-size:12px;padding:12px;border:1px solid #333;border-radius:8px;">${templateCode}</textarea>
          <div style="margin-top:16px;display:flex;gap:12px;">
            <button onclick="navigator.clipboard.writeText(document.getElementById('templateCodeOutput').value);this.textContent='Copied!'" style="padding:10px 20px;background:#6366f1;color:#fff;border:none;border-radius:6px;cursor:pointer;">Copy to Clipboard</button>
            <button onclick="this.closest('div').parentElement.remove()" style="padding:10px 20px;background:#333;color:#fff;border:none;border-radius:6px;cursor:pointer;">Close</button>
          </div>
        </div>
      `;
      document.body.appendChild(modal);
      document.getElementById('templateCodeOutput').select();

      console.log('Template exported:', templateCode);
    }

    function loadRoomTemplate(templateId) {
      const template = ROOM_TEMPLATES[templateId];
      if (!template) {
        showToast('Template not found', 'error');
        return;
      }

      // Confirm before clearing
      if (elements.length > 0) {
        if (!confirm(`Load "${template.name}" template? This will replace your current design.`)) {
          return;
        }
      }

      // Clear current elements
      elements.length = 0;
      selectedElement = null;

      // Set room dimensions FIRST
      roomWidth = template.width;
      roomDepth = template.depth;
      document.getElementById('roomWidth').value = roomWidth;
      document.getElementById('roomDepth').value = roomDepth;
      document.getElementById('roomType').value = template.roomType;

      // IMPORTANT: Fit to screen BEFORE adding elements
      // This sets pixelsPerFoot correctly for the new room size
      // Elements will use this scale when converting feet to pixels
      fitToScreen();

      // Add template elements (using the correct pixelsPerFoot set by fitToScreen)
      template.elements.forEach(elDef => {
        // Copy all properties from template, then override with converted/computed values
        const el = {
          ...elDef,  // Copy ALL template properties (waterfallSides, overhangs, finishedEnds, etc.)
          id: Date.now() + Math.random(),
          x: elDef.x * pixelsPerFoot,
          y: elDef.y * pixelsPerFoot,
          rotation: elDef.rotation || 0,
          color: elDef.color || getDefaultColor(elDef.type),
          category: getElementCategory(elDef.type),
          roomId: currentRoom
        };
        elements.push(el);
      });

      // Update everything (no need to call fitToScreen again)
      saveUndoState();
      updateProperties();
      updateElementList();
      updateItemPicker();
      draw();

      if (currentView === '3d') {
        init3D();
        render3D();
      }

      showToast(`Loaded "${template.name}" template`, 'success');
    }

    function getDefaultColor(type) {
      const colors = {
        'base-cabinet': '#8B7355',
        'wall-cabinet': '#8B7355',
        'tall-cabinet': '#8B7355',
        'fridge-cabinet': '#8B7355',
        'corner-cabinet': '#8B7355',
        'island': '#8B7355',
        'drawer-base': '#8B7355',
        'sink-base': '#8B7355',
        'countertop': '#708090',
        'backsplash': '#A0A0A0',
        'flooring': '#D2B48C',
        'tile': '#E8E8E8',
        'shower-pan': '#D0D0D0',
        'shower-wall': '#E0E0E0',
        'shower-curb': '#808080',
        'bathtub': '#F5F5F5',
        'toilet': '#FFFFFF',
        'sink': '#E8E8E8',
        'refrigerator': '#C0C0C0',
        'range': '#404040',
        'stove': '#404040',
        'dishwasher': '#C0C0C0',
        'range-hood': '#808080',
        'wall': '#E0D5C5',
        'window': '#87CEEB',
        'door': '#8B4513'
      };
      return colors[type] || '#808080';
    }

    function updateRoomHeight() {
      roomHeight = parseInt(document.getElementById('roomHeight').value) || 8;
      if (currentView === '3d') {
        init3D();
        render3D();
      }
    }

    // ===== CABINET SETTINGS =====
    function updateCabinetSettings() {
      // Get values from dropdowns
      cabinetSettings.construction = document.getElementById('cabinetConstruction').value;
      cabinetSettings.doorStyle = document.getElementById('doorStyle').value;
      cabinetSettings.doorOverlay = document.getElementById('doorOverlay').value;
      cabinetSettings.cabinetFinish = document.getElementById('cabinetFinish')?.value || 'wood-grain';

      // Cabinet types that use these settings
      const cabinetTypes = ['base-cabinet', 'wall-cabinet', 'tall-cabinet', 'corner-cabinet',
                           'drawer-base', 'sink-base', 'lazy-susan', 'blind-corner', 'island',
                           'microwave-cabinet', 'above-microwave-cabinet', 'fridge-cabinet',
                           'single-oven-cabinet', 'tall-oven', 'double-oven-cabinet', 'laundry-cabinet'];

      // Update any selected cabinet element with new settings
      if (selectedElement && cabinetTypes.includes(selectedElement.type)) {
        selectedElement.construction = cabinetSettings.construction;
        selectedElement.doorStyle = cabinetSettings.doorStyle;
        selectedElement.doorOverlay = cabinetSettings.doorOverlay;
        selectedElement.cabinetFinish = cabinetSettings.cabinetFinish;

        // Redraw - must reinitialize 3D to rebuild geometry
        if (currentView === '2d') {
          draw();
        } else {
          init3D(); // Rebuild 3D scene with new cabinet settings
        }
        saveUndoState();
      }

      // Show toast with current settings
      const constructionLabel = cabinetSettings.construction === 'frameless' ? 'Frameless (Euro)' : 'Framed (Face Frame)';
      const finishLabel = cabinetSettings.cabinetFinish === 'wood-grain' ? 'Wood Grain' :
                         cabinetSettings.cabinetFinish === 'painted' ? 'Painted' :
                         cabinetSettings.cabinetFinish === 'matte' ? 'Matte' : 'High Gloss';
      showToast(`Cabinet: ${cabinetSettings.doorStyle}, ${finishLabel}`);
    }

    function applySettingsToAllCabinets() {
      // Cabinet types that use these settings
      const cabinetTypes = ['base-cabinet', 'wall-cabinet', 'tall-cabinet', 'corner-cabinet',
                           'drawer-base', 'sink-base', 'lazy-susan', 'blind-corner', 'island',
                           'microwave-cabinet', 'above-microwave-cabinet', 'fridge-cabinet',
                           'single-oven-cabinet', 'tall-oven', 'double-oven-cabinet', 'laundry-cabinet'];

      let updatedCount = 0;
      elements.forEach(el => {
        if (cabinetTypes.includes(el.type)) {
          el.construction = cabinetSettings.construction;
          el.doorStyle = cabinetSettings.doorStyle;
          el.doorOverlay = cabinetSettings.doorOverlay;
          el.cabinetFinish = cabinetSettings.cabinetFinish;
          updatedCount++;
        }
      });

      if (updatedCount > 0) {
        // Redraw
        if (currentView === '2d') {
          draw();
        } else {
          init3D(); // Rebuild 3D scene with new cabinet settings
        }
        saveUndoState();

        const constructionLabel = cabinetSettings.construction === 'frameless' ? 'Frameless' : 'Framed';
        showToast(`Applied ${constructionLabel} ${cabinetSettings.doorStyle} style to ${updatedCount} cabinet(s)`, 'success');
      } else {
        showToast('No cabinets found to update', 'info');
      }
    }

    function updateFloorLevel() {
      const floorSelect = document.getElementById('floorLevel');
      const value = floorSelect.value;

      if (value === 'add') {
        // Add new floor
        const newFloorNum = cabinetSettings.floors.length + 1;
        const newFloor = {
          id: newFloorNum,
          name: `Floor ${newFloorNum}`,
          height: (newFloorNum - 1) * 10 // 10 feet per floor
        };
        cabinetSettings.floors.push(newFloor);

        // Add new option to dropdown
        const newOption = document.createElement('option');
        newOption.value = newFloorNum;
        newOption.textContent = `Floor ${newFloorNum}`;
        floorSelect.insertBefore(newOption, floorSelect.lastElementChild);

        // Select the new floor
        floorSelect.value = newFloorNum;
        cabinetSettings.currentFloor = newFloorNum;

        showToast(`Added Floor ${newFloorNum}`);
      } else {
        // Switch to selected floor
        cabinetSettings.currentFloor = parseInt(value);
        showToast(`Switched to Floor ${value}`);
      }

      // Filter elements to show only current floor
      updateFloorVisibility();

      if (currentView === '2d') {
        draw();
      } else {
        render3D();
      }
    }

    function updateTimeOfDay() {
      const timeSelect = document.getElementById('timeOfDay');
      sceneSettings.timeOfDay = timeSelect.value;

      // Lighting presets matching init3D - balanced for color accuracy
      const lightingPresets = {
        morning: {
          bg: 0xFFF8E7,
          ambient: { color: 0xFFF8F0, intensity: 0.35 },
          hemisphere: { sky: 0xFFE4C4, ground: 0x8B7355, intensity: 0.25 },
          sun: { color: 0xFFE4B5, intensity: 0.6, pos: [25, 12, 15] },
          fill: { intensity: 0.2 },
          exposure: 0.9
        },
        noon: {
          bg: 0xF5F8FA,
          ambient: { color: 0xFFFFFF, intensity: 0.4 },
          hemisphere: { sky: 0xE0F0FF, ground: 0x8B7355, intensity: 0.3 },
          sun: { color: 0xFFFFF8, intensity: 0.7, pos: [15, 25, 15] },
          fill: { intensity: 0.25 },
          exposure: 0.95
        },
        evening: {
          bg: 0xFFE8D6,
          ambient: { color: 0xFFE0C0, intensity: 0.3 },
          hemisphere: { sky: 0xFFA07A, ground: 0x6B4423, intensity: 0.2 },
          sun: { color: 0xFF8C00, intensity: 0.5, pos: [-20, 8, 10] },
          fill: { intensity: 0.25 },
          exposure: 0.85
        },
        night: {
          bg: 0x1E2A3A,
          ambient: { color: 0xC0C8D8, intensity: 0.25 },
          hemisphere: { sky: 0x4169E1, ground: 0x2F3F4F, intensity: 0.15 },
          sun: { color: 0xB0C4DE, intensity: 0.15, pos: [-15, 20, 10] },
          fill: { intensity: 0.35 }, // Interior lights
          exposure: 0.75
        },
        showroom: {
          bg: 0xFCFCFC,
          ambient: { color: 0xFFFFFF, intensity: 0.55 },
          hemisphere: { sky: 0xFFFFFF, ground: 0xF0F0F0, intensity: 0.35 },
          sun: { color: 0xFFFFFF, intensity: 0.85, pos: [10, 20, 10] },
          fill: { intensity: 0.4 },
          exposure: 1.1
        }
      };

      if (scene && renderer) {
        const preset = lightingPresets[sceneSettings.timeOfDay] || lightingPresets.noon;

        // Update renderer exposure
        renderer.toneMappingExposure = preset.exposure;

        // Update scene background
        scene.background = new THREE.Color(preset.bg);

        // Update lights by name
        scene.traverse(obj => {
          if (obj.name === 'ambientLight' && obj.isAmbientLight) {
            obj.color.setHex(preset.ambient.color);
            obj.intensity = preset.ambient.intensity;
          }
          if (obj.name === 'hemisphereLight' && obj.isHemisphereLight) {
            obj.color.setHex(preset.hemisphere.sky);
            obj.groundColor.setHex(preset.hemisphere.ground);
            obj.intensity = preset.hemisphere.intensity;
          }
          if (obj.name === 'sunLight' && obj.isDirectionalLight) {
            obj.position.set(...preset.sun.pos);
            obj.color.setHex(preset.sun.color);
            obj.intensity = preset.sun.intensity;
          }
          if (obj.name === 'fillLight' && obj.isDirectionalLight) {
            obj.intensity = preset.fill.intensity;
          }
          // Surface lights stay constant for texture visibility
        });

        // Re-render to show changes
        render3D();
      }

      const timeLabels = {
        morning: 'Morning (Golden Hour)',
        noon: 'Noon (Bright Daylight)',
        evening: 'Evening (Sunset)',
        night: 'Night (Interior Lights)'
      };
      showToast(`Time of day: ${timeLabels[sceneSettings.timeOfDay]}`);
    }

    function updateFloorVisibility() {
      // Mark elements with their floor level if not set
      elements.forEach(el => {
        if (!el.floorLevel) {
          el.floorLevel = 1; // Default to floor 1
        }
      });
    }

    function getElementsForCurrentFloor() {
      return elements.filter(el => !el.floorLevel || el.floorLevel === cabinetSettings.currentFloor);
    }

    // ===== FLOATING TOOLBAR =====
    function updateFloatingToolbar() {
      const toolbar = document.getElementById('floatingToolbar');
      const countEl = document.getElementById('selectionCount');
      const typeEl = document.getElementById('selectionType');

      if (!toolbar) return;

      if (selectedElement) {
        toolbar.classList.add('visible');
        countEl.textContent = '1';
        typeEl.textContent = selectedElement.label || 'Selected';
      } else {
        toolbar.classList.remove('visible');
      }
    }

    // ===== PROPERTIES =====
    function updateProperties() {
      const empty = document.getElementById('propertiesEmpty');
      const content = document.getElementById('propertiesContent');

      // Update floating toolbar visibility
      updateFloatingToolbar();

      if (selectedElement) {
        empty.style.display = 'none';
        content.style.display = 'block';

        document.getElementById('propType').textContent = selectedElement.label;
        // Show decimal value in input, formatted display beside it
        document.getElementById('propWidth').value = selectedElement.width.toFixed(4).replace(/\.?0+$/, '');
        document.getElementById('propHeight').value = selectedElement.height.toFixed(4).replace(/\.?0+$/, '');
        // Show formatted feet-inches display
        const widthDisplay = document.getElementById('propWidthDisplay');
        const heightDisplay = document.getElementById('propHeightDisplay');
        if (widthDisplay) widthDisplay.textContent = formatDimension(selectedElement.width);
        if (heightDisplay) heightDisplay.textContent = formatDimension(selectedElement.height);

        document.getElementById('propColor').value = selectedElement.color;
        document.getElementById('propRotation').textContent = (selectedElement.rotation || 0) + '';

        // Area & perimeter calculations
        const elArea = selectedElement.width * selectedElement.height;
        const elPerimeter = 2 * (selectedElement.width + selectedElement.height);
        const areaEl = document.getElementById('propArea');
        const perimEl = document.getElementById('propPerimeter');
        if (areaEl) {
          const areaSqFt = elArea.toFixed(2);
          const areaSqIn = (elArea * 144).toFixed(0);
          areaEl.textContent = `${areaSqFt} sq ft (${areaSqIn} sq in)`;
        }
        if (perimEl) {
          const perimFt = elPerimeter.toFixed(2);
          const perimIn = (elPerimeter * 12).toFixed(0);
          perimEl.textContent = `${perimFt} ft (${perimIn}")`;
        }

        const texturePreview = document.getElementById('propTexture');
        if (selectedElement.texture) {
          texturePreview.style.background = `url(${selectedElement.texture}) center/cover`;
        } else {
          texturePreview.style.background = selectedElement.color;
        }

        // Show material name if assigned
        const materialNameRow = document.getElementById('materialNameRow');
        const materialNameEl = document.getElementById('propMaterialName');
        if (materialNameRow && materialNameEl) {
          if (selectedElement.materialName) {
            materialNameRow.style.display = 'flex';
            materialNameEl.textContent = selectedElement.materialName;
          } else {
            materialNameRow.style.display = 'none';
            materialNameEl.textContent = '-';
          }
        }

        // Surface finish picker
        const finishRow = document.getElementById('finishRow');
        const finishPicker = document.getElementById('finishPicker');
        if (finishRow && finishPicker) {
          const matCat = selectedElement.materialCategory;
          const finishGroup = matCat ? CATEGORY_FINISH_GROUP[matCat] : null;
          const finishOpts = finishGroup ? (FINISH_OPTIONS[finishGroup] || []) : [];
          if (finishOpts.length > 0) {
            finishRow.style.display = 'flex';
            const currentFinish = (selectedElement.finish || 'polished').toLowerCase();
            finishPicker.innerHTML = finishOpts.map(f => {
              const fId = f.toLowerCase();
              const isActive = fId === currentFinish;
              return `<button class="finish-option${isActive ? ' active' : ''}" onclick="applyFinishToElement('${fId}')">${f}</button>`;
            }).join('');
          } else {
            finishRow.style.display = 'none';
            finishPicker.innerHTML = '';
          }
        }

        // Populate standard sizes dropdown
        const standardSizeRow = document.getElementById('standardSizeRow');
        const standardSizeSelect = document.getElementById('propStandardSize');
        const standardSizes = getStandardSizesForType(selectedElement.type);

        if (standardSizes.length > 0) {
          standardSizeRow.style.display = 'flex';
          standardSizeSelect.innerHTML = '<option value="">Custom</option>' +
            standardSizes.map(s => `<option value="${s.width}x${s.height}">${s.label}</option>`).join('');
        } else {
          standardSizeRow.style.display = 'none';
        }

        // Countertop-specific properties (edge profile, backsplash, finished ends)
        const countertopTypes = ['countertop', 'countertop-corner', 'countertop-l', 'countertop-u', 'island'];
        const isCountertop = countertopTypes.includes(selectedElement.type);
        const edgeProfileRow = document.getElementById('edgeProfileRow');
        const backsplashRow = document.getElementById('backsplashRow');
        const finishedEndsRow = document.getElementById('finishedEndsRow');

        if (edgeProfileRow) {
          edgeProfileRow.style.display = isCountertop ? 'flex' : 'none';
          if (isCountertop) {
            const profile = selectedElement.edgeProfile || 'eased';
            document.getElementById('propEdgeProfile').value = profile;

            // Show edge profile durability info
            const edgeInfo = FABRICATION_STANDARDS?.edgeDurability?.[profile];
            const infoDiv = document.getElementById('edgeProfileInfo');
            const infoRow = document.getElementById('edgeProfileInfoRow');

            if (infoDiv && infoRow && edgeInfo) {
              const stars = ''.repeat(edgeInfo.rating) + ''.repeat(5 - edgeInfo.rating);
              infoDiv.innerHTML = `<strong>Durability:</strong> ${stars}<br><strong>Chip Resistance:</strong> ${edgeInfo.chipResistance}<br>${edgeInfo.notes}`;
              infoRow.style.display = 'block';
            }
          }
        }

        // Hide edge profile info when not a countertop
        const edgeProfileInfoRow = document.getElementById('edgeProfileInfoRow');
        if (edgeProfileInfoRow && !isCountertop) {
          edgeProfileInfoRow.style.display = 'none';
        }

        if (backsplashRow) {
          backsplashRow.style.display = isCountertop ? 'flex' : 'none';
          if (isCountertop) {
            const bs = selectedElement.backsplash;
            if (!bs) {
              document.getElementById('propBacksplash').value = 'none';
            } else if (bs.type === 'full') {
              document.getElementById('propBacksplash').value = 'full';
            } else {
              document.getElementById('propBacksplash').value = bs.height.toString();
            }
          }
        }

        if (finishedEndsRow) {
          finishedEndsRow.style.display = isCountertop ? 'flex' : 'none';
          if (isCountertop) {
            const ends = selectedElement.finishedEnds || [];
            document.getElementById('propFinishedLeft').checked = ends.includes('left');
            document.getElementById('propFinishedRight').checked = ends.includes('right');
          }
        }

        // Thickness row for countertops (2cm vs 3cm)
        const thicknessRow = document.getElementById('thicknessRow');
        const edgeStyleRow = document.getElementById('edgeStyleRow');
        if (thicknessRow) {
          thicknessRow.style.display = isCountertop ? 'flex' : 'none';
          if (isCountertop) {
            const thickness = selectedElement.thickness || '3cm';
            document.getElementById('propThickness').value = thickness;

            // Show edge style row only for 2cm
            if (edgeStyleRow) {
              edgeStyleRow.style.display = thickness === '2cm' ? 'flex' : 'none';
              if (thickness === '2cm') {
                document.getElementById('propEdgeStyle').value = selectedElement.edgeBuildStyle || 'laminated';
              }
            }
          }
        }

        // Waterfall section for countertops - ALWAYS visible for any countertop type
        const waterfallSectionRow = document.getElementById('waterfallSectionRow');
        const waterfallHeightRow = document.getElementById('waterfallHeightRow');

        if (waterfallSectionRow) {
          // Show waterfall section for ALL countertop types
          waterfallSectionRow.style.display = isCountertop ? 'block' : 'none';
          if (isCountertop) {
            // Populate waterfall side checkboxes
            const sides = selectedElement.waterfallSides || [];
            const leftCb = document.getElementById('propWaterfallLeft');
            const rightCb = document.getElementById('propWaterfallRight');
            const frontCb = document.getElementById('propWaterfallFront');
            const backCb = document.getElementById('propWaterfallBack');
            if (leftCb) leftCb.checked = sides.includes('left');
            if (rightCb) rightCb.checked = sides.includes('right');
            if (frontCb) frontCb.checked = sides.includes('front');
            if (backCb) backCb.checked = sides.includes('back');
          }
        }

        if (waterfallHeightRow) {
          const hasWaterfallSides = selectedElement.waterfallSides && selectedElement.waterfallSides.length > 0;
          waterfallHeightRow.style.display = (isCountertop && hasWaterfallSides) ? 'flex' : 'none';
          if (isCountertop && hasWaterfallSides) {
            const dropHeight = selectedElement.waterfallHeight || 2.9;
            const heightSelect = document.getElementById('propWaterfallHeight');
            if (heightSelect) {
              if (dropHeight === 'floor') {
                heightSelect.value = 'floor';
              } else if ([2.5, 2.9, 3].includes(dropHeight)) {
                heightSelect.value = dropHeight.toString();
              } else {
                heightSelect.value = 'custom';
              }
            }
          }
        }

        // Overhang section for countertops
        const overhangSectionRow = document.getElementById('overhangSectionRow');
        if (overhangSectionRow) {
          overhangSectionRow.style.display = isCountertop ? 'block' : 'none';
          if (isCountertop) {
            // Get overhang values (stored in feet, display in inches) - 2" front is standard
            const front = (selectedElement.overhangFront !== undefined ? selectedElement.overhangFront : 0.167) * 12;
            const back = (selectedElement.overhangBack !== undefined ? selectedElement.overhangBack : 0) * 12;
            const left = (selectedElement.overhangLeft !== undefined ? selectedElement.overhangLeft : 0.125) * 12;
            const right = (selectedElement.overhangRight !== undefined ? selectedElement.overhangRight : 0.125) * 12;

            document.getElementById('propOverhangFront').value = front;
            document.getElementById('propOverhangBack').value = back;
            document.getElementById('propOverhangLeft').value = left;
            document.getElementById('propOverhangRight').value = right;

            // Check if matches a preset (2" = standard front overhang to cover cabinet face)
            const presetSelect = document.getElementById('propOverhangPreset');
            if (presetSelect) {
              if (front === 2 && back === 0 && left === 1.5 && right === 1.5) {
                presetSelect.value = 'standard';
              } else if (front === 2 && back === 2 && left === 2 && right === 2) {
                presetSelect.value = 'island';
              } else if (front === 12 && back === 2 && left === 1.5 && right === 1.5) {
                presetSelect.value = 'bar';
              } else if (front === 15 && back === 2 && left === 1.5 && right === 1.5) {
                presetSelect.value = 'breakfast';
              } else {
                presetSelect.value = '';
              }
            }
          }
        }

        // Seams row for countertops
        const seamsRow = document.getElementById('seamsRow');
        if (seamsRow) {
          seamsRow.style.display = isCountertop ? 'flex' : 'none';
          if (isCountertop) {
            // Update the full seam UI (dimensions, seam list, pieces)
            updateSeamUI();

            // Reset seam placement mode button when switching elements
            seamPlacementMode = false;
            const seamPlaceBtn = document.getElementById('seamPlaceModeBtn');
            if (seamPlaceBtn) {
              seamPlaceBtn.style.background = 'rgba(139, 92, 246, 0.3)';
              seamPlaceBtn.textContent = ' Click to Place';
            }
          }
        }

        // Sink-specific properties (color, mount type)
        const isSink = selectedElement.type.startsWith('sink');
        const sinkColorRow = document.getElementById('sinkColorRow');
        const sinkMountRow = document.getElementById('sinkMountRow');

        if (sinkColorRow) {
          sinkColorRow.style.display = isSink ? 'flex' : 'none';
          if (isSink) {
            document.getElementById('propSinkColor').value = selectedElement.sinkColor || 'stainless';
          }
        }

        if (sinkMountRow) {
          sinkMountRow.style.display = isSink ? 'flex' : 'none';
          if (isSink) {
            // Default mount based on sink type
            let defaultMount = 'undermount';
            if (selectedElement.type === 'sink-farmhouse') defaultMount = 'farmhouse';
            document.getElementById('propSinkMount').value = selectedElement.mountType || defaultMount;
          }
        }

        // Window/Door sill height (height from floor)
        const windowDoorTypes = ['window', 'window-large', 'window-bay', 'bay-window', 'picture-window',
          'door', 'double-door', 'sliding-door', 'french-door', 'glass-door', 'entry-archway', 'garage-door'];
        const isWindowOrDoor = windowDoorTypes.includes(selectedElement.type);
        const sillHeightRow = document.getElementById('sillHeightRow');
        const customSillRow = document.getElementById('customSillRow');

        if (sillHeightRow) {
          sillHeightRow.style.display = isWindowOrDoor ? 'flex' : 'none';
          if (isWindowOrDoor) {
            const sillHeight = selectedElement.sillHeight !== undefined ? selectedElement.sillHeight : getDefaultSillHeight(selectedElement.type);
            const select = document.getElementById('propSillHeight');

            // Check if it matches a preset
            const presets = [0, 1.5, 2, 3, 3.5, 4, 5];
            const matchesPreset = presets.some(p => Math.abs(sillHeight - p) < 0.05);

            if (matchesPreset) {
              select.value = presets.find(p => Math.abs(sillHeight - p) < 0.05).toString();
              if (customSillRow) customSillRow.style.display = 'none';
            } else {
              select.value = 'custom';
              if (customSillRow) {
                customSillRow.style.display = 'flex';
                document.getElementById('propCustomSill').value = sillHeight.toFixed(2);
              }
            }
          }
        }
        if (customSillRow && !isWindowOrDoor) {
          customSillRow.style.display = 'none';
        }

        // Door/Archway height controls
        const doorTypes = ['door', 'double-door', 'sliding-door', 'french-door', 'glass-door', 'entry-archway', 'garage-door'];
        const isDoor = doorTypes.includes(selectedElement.type);
        const isArchway = selectedElement.type === 'entry-archway';
        const doorHeightRow = document.getElementById('doorHeightRow');
        const customDoorHeightRow = document.getElementById('customDoorHeightRow');
        const archwayStyleRow = document.getElementById('archwayStyleRow');

        if (doorHeightRow) {
          doorHeightRow.style.display = isDoor ? 'flex' : 'none';
          if (isDoor) {
            const doorHeight = selectedElement.height3D !== undefined ? selectedElement.height3D : 6.8;
            const select = document.getElementById('propDoorHeight');

            // Check if it matches a preset
            const presets = [6.67, 6.83, 7, 8, 9, 10];
            const matchesPreset = presets.some(p => Math.abs(doorHeight - p) < 0.05);

            if (matchesPreset) {
              select.value = presets.find(p => Math.abs(doorHeight - p) < 0.05).toString();
              if (customDoorHeightRow) customDoorHeightRow.style.display = 'none';
            } else {
              select.value = 'custom';
              if (customDoorHeightRow) {
                customDoorHeightRow.style.display = 'flex';
                document.getElementById('propCustomDoorHeight').value = doorHeight.toFixed(2);
                document.getElementById('propDoorHeightDisplay').textContent = formatDimension(doorHeight);
              }
            }
          }
        }
        if (customDoorHeightRow && !isDoor) {
          customDoorHeightRow.style.display = 'none';
        }

        // Archway style (only for archways)
        if (archwayStyleRow) {
          archwayStyleRow.style.display = isArchway ? 'flex' : 'none';
          if (isArchway) {
            document.getElementById('propArchwayStyle').value = selectedElement.archwayStyle || 'round';
          }
        }

        // Window style and mullion pattern (only for windows)
        const windowTypes = ['window', 'window-large', 'window-bay', 'bay-window', 'picture-window'];
        const isWindow = windowTypes.includes(selectedElement.type);
        const windowStyleRow = document.getElementById('windowStyleRow');
        const mullionPatternRow = document.getElementById('mullionPatternRow');

        if (windowStyleRow) {
          windowStyleRow.style.display = isWindow ? 'flex' : 'none';
          if (isWindow) {
            document.getElementById('propWindowStyle').value = selectedElement.windowStyle || 'double-hung';
          }
        }

        if (mullionPatternRow) {
          mullionPatternRow.style.display = isWindow ? 'flex' : 'none';
          if (isWindow) {
            document.getElementById('propMullionPattern').value = selectedElement.mullionPattern || 'standard';
          }
        }

        // Window opening height (3D height of the window)
        const windowHeightRow = document.getElementById('windowHeightRow');
        const customWindowHeightRow = document.getElementById('customWindowHeightRow');

        if (windowHeightRow) {
          windowHeightRow.style.display = isWindow ? 'flex' : 'none';
          if (isWindow) {
            const winHeight = selectedElement.windowHeight !== undefined
              ? selectedElement.windowHeight
              : get3DHeight(selectedElement);
            const select = document.getElementById('propWindowHeight');

            // Check if it matches a preset
            const winPresets = [2, 2.5, 3, 3.5, 4, 5, 6];
            const matchesWinPreset = winPresets.some(p => Math.abs(winHeight - p) < 0.05);

            if (matchesWinPreset) {
              select.value = winPresets.find(p => Math.abs(winHeight - p) < 0.05).toString();
              if (customWindowHeightRow) customWindowHeightRow.style.display = 'none';
            } else {
              select.value = 'custom';
              if (customWindowHeightRow) {
                customWindowHeightRow.style.display = 'flex';
                document.getElementById('propCustomWindowHeight').value = winHeight.toFixed(2);
                const display = document.getElementById('propWindowHeightDisplay');
                if (display) display.textContent = formatDimension(winHeight);
              }
            }
          }
        }
        if (customWindowHeightRow && !isWindow) {
          customWindowHeightRow.style.display = 'none';
        }

        // Pony wall / half wall height controls
        const ponyWallTypes = ['pony-wall', 'pony-wall-bar', 'knee-wall'];
        const isPonyWall = ponyWallTypes.includes(selectedElement.type);
        const wallHeightRow = document.getElementById('wallHeightRow');
        const customWallHeightRow = document.getElementById('customWallHeightRow');

        if (wallHeightRow) {
          wallHeightRow.style.display = isPonyWall ? 'flex' : 'none';
          if (isPonyWall) {
            const wallHeight = selectedElement.wallHeight !== undefined ? selectedElement.wallHeight : 3.5;
            const select = document.getElementById('propWallHeight');

            // Check if it matches a preset
            const presets = [2, 2.5, 3, 3.5, 4];
            const matchesPreset = presets.some(p => Math.abs(wallHeight - p) < 0.05);

            if (matchesPreset) {
              select.value = presets.find(p => Math.abs(wallHeight - p) < 0.05).toString();
              if (customWallHeightRow) customWallHeightRow.style.display = 'none';
            } else {
              select.value = 'custom';
              if (customWallHeightRow) {
                customWallHeightRow.style.display = 'flex';
                document.getElementById('propCustomWallHeight').value = wallHeight.toFixed(2);
                document.getElementById('propWallHeightDisplay').textContent = formatDimension(wallHeight);
              }
            }
          }
        }
        if (customWallHeightRow && !isPonyWall) {
          customWallHeightRow.style.display = 'none';
        }

        // Niche depth controls
        const nicheTypes = ['wall-niche', 'fireplace-niche', 'tv-niche', 'shower-niche'];
        const isNiche = nicheTypes.includes(selectedElement.type);
        const nicheDepthRow = document.getElementById('nicheDepthRow');
        const customNicheDepthRow = document.getElementById('customNicheDepthRow');

        if (nicheDepthRow) {
          nicheDepthRow.style.display = isNiche ? 'flex' : 'none';
          if (isNiche) {
            const nicheDepth = selectedElement.nicheDepth !== undefined ? selectedElement.nicheDepth : 0.33;
            const select = document.getElementById('propNicheDepth');

            // Check if it matches a preset
            const presets = [0.25, 0.33, 0.5, 0.67, 1, 1.5];
            const matchesPreset = presets.some(p => Math.abs(nicheDepth - p) < 0.05);

            if (matchesPreset) {
              select.value = presets.find(p => Math.abs(nicheDepth - p) < 0.05).toString();
              if (customNicheDepthRow) customNicheDepthRow.style.display = 'none';
            } else {
              select.value = 'custom';
              if (customNicheDepthRow) {
                customNicheDepthRow.style.display = 'flex';
                document.getElementById('propCustomNicheDepth').value = nicheDepth.toFixed(2);
                document.getElementById('propNicheDepthDisplay').textContent = formatDimension(nicheDepth);
              }
            }
          }
        }
        if (customNicheDepthRow && !isNiche) {
          customNicheDepthRow.style.display = 'none';
        }

        // Stone surface thickness controls
        const stoneSurfaceTypes = ['wall-cap', 'bar-top', 'niche-surround', 'fireplace-surround', 'fireplace-hearth', 'mantel', 'window-sill', 'threshold'];
        const isStoneSurface = stoneSurfaceTypes.includes(selectedElement.type);
        const stoneThicknessRow = document.getElementById('stoneThicknessRow');

        if (stoneThicknessRow) {
          stoneThicknessRow.style.display = isStoneSurface ? 'flex' : 'none';
          if (isStoneSurface) {
            const thickness = selectedElement.stoneThickness !== undefined ? selectedElement.stoneThickness : 0.1;
            const select = document.getElementById('propStoneThickness');
            // Find closest preset
            const presets = [0.0625, 0.1, 0.125, 0.17, 0.25];
            const closestPreset = presets.reduce((prev, curr) =>
              Math.abs(curr - thickness) < Math.abs(prev - thickness) ? curr : prev
            );
            select.value = closestPreset.toString();
          }
        }

        // Cap height control for wall caps and bar tops
        const capTypes = ['wall-cap', 'bar-top'];
        const isCapElement = capTypes.includes(selectedElement.type);
        const capHeightRow = document.getElementById('capHeightRow');
        const customCapHeightRow = document.getElementById('customCapHeightRow');
        const edgePreviewBtnRow = document.getElementById('edgePreviewBtnRow');

        if (capHeightRow) {
          capHeightRow.style.display = isCapElement ? 'flex' : 'none';
          if (isCapElement) {
            const capHeight = selectedElement.capHeight !== undefined ? selectedElement.capHeight : 3.5;
            const select = document.getElementById('propCapHeight');
            const presets = [2, 2.5, 3, 3.5, 4];
            const matchesPreset = presets.some(p => Math.abs(capHeight - p) < 0.05);

            if (matchesPreset) {
              select.value = presets.find(p => Math.abs(capHeight - p) < 0.05).toString();
              if (customCapHeightRow) customCapHeightRow.style.display = 'none';
            } else {
              select.value = 'custom';
              if (customCapHeightRow) {
                customCapHeightRow.style.display = 'flex';
                document.getElementById('propCustomCapHeight').value = capHeight.toFixed(2);
                document.getElementById('propCapHeightDisplay').textContent = formatDimension(capHeight);
              }
            }
          }
        }
        if (customCapHeightRow && !isCapElement) customCapHeightRow.style.display = 'none';

        // Edge preview button for countertops and stone surfaces
        if (edgePreviewBtnRow) {
          const showEdgeBtn = selectedElement.type === 'countertop' || isStoneSurface;
          edgePreviewBtnRow.style.display = showEdgeBtn ? 'flex' : 'none';
        }

        // Flooring/tile grain direction controls
        const flooringTypes = ['flooring', 'tile', 'hardwood', 'laminate', 'vinyl', 'carpet'];
        const isFlooring = flooringTypes.includes(selectedElement.type);
        const grainDirectionRow = document.getElementById('grainDirectionRow');

        if (grainDirectionRow) {
          grainDirectionRow.style.display = isFlooring ? 'flex' : 'none';
          if (isFlooring) {
            const grainDir = selectedElement.grainDirection || 0;
            // Update button states
            document.querySelectorAll('.grain-btn').forEach(btn => {
              btn.classList.toggle('active', parseInt(btn.dataset.dir) === grainDir);
            });
          }
        }

        // Structural element controls (beams and columns)
        const beamTypes = ['steel-beam', 'wood-beam', 'concrete-beam', 'header', 'lvl-beam'];
        const columnTypes = ['steel-column', 'wood-post', 'concrete-column'];
        const isBeam = beamTypes.includes(selectedElement.type);
        const isColumn = columnTypes.includes(selectedElement.type);

        const beamDepthRow = document.getElementById('beamDepthRow');
        const customBeamDepthRow = document.getElementById('customBeamDepthRow');
        const beamElevationRow = document.getElementById('beamElevationRow');
        const customBeamElevationRow = document.getElementById('customBeamElevationRow');
        const columnHeightRow = document.getElementById('columnHeightRow');
        const customColumnHeightRow = document.getElementById('customColumnHeightRow');
        const columnSizeRow = document.getElementById('columnSizeRow');

        // Beam depth control
        if (beamDepthRow) {
          beamDepthRow.style.display = isBeam ? 'flex' : 'none';
          if (isBeam) {
            const beamDepth = selectedElement.beamDepth !== undefined ? selectedElement.beamDepth : getDefaultBeamDepth(selectedElement.type);
            const select = document.getElementById('propBeamDepth');
            const presets = [0.33, 0.5, 0.67, 0.83, 1, 1.17];
            const matchesPreset = presets.some(p => Math.abs(beamDepth - p) < 0.02);

            if (matchesPreset) {
              select.value = presets.find(p => Math.abs(beamDepth - p) < 0.02).toString();
              if (customBeamDepthRow) customBeamDepthRow.style.display = 'none';
            } else {
              select.value = 'custom';
              if (customBeamDepthRow) {
                customBeamDepthRow.style.display = 'flex';
                document.getElementById('propCustomBeamDepth').value = beamDepth.toFixed(2);
                document.getElementById('propBeamDepthDisplay').textContent = formatDimension(beamDepth);
              }
            }
          }
        }
        if (customBeamDepthRow && !isBeam) customBeamDepthRow.style.display = 'none';

        // Beam elevation control
        if (beamElevationRow) {
          beamElevationRow.style.display = isBeam ? 'flex' : 'none';
          if (isBeam) {
            const beamElevation = selectedElement.beamElevation;
            const select = document.getElementById('propBeamElevation');

            if (beamElevation === undefined) {
              select.value = 'ceiling';
              if (customBeamElevationRow) customBeamElevationRow.style.display = 'none';
            } else {
              const presets = [7, 7.5, 8, 9, 10];
              const matchesPreset = presets.some(p => Math.abs(beamElevation - p) < 0.05);

              if (matchesPreset) {
                select.value = presets.find(p => Math.abs(beamElevation - p) < 0.05).toString();
                if (customBeamElevationRow) customBeamElevationRow.style.display = 'none';
              } else {
                select.value = 'custom';
                if (customBeamElevationRow) {
                  customBeamElevationRow.style.display = 'flex';
                  document.getElementById('propCustomBeamElevation').value = beamElevation.toFixed(2);
                  document.getElementById('propBeamElevationDisplay').textContent = formatDimension(beamElevation);
                }
              }
            }
          }
        }
        if (customBeamElevationRow && !isBeam) customBeamElevationRow.style.display = 'none';

        // Column height control
        if (columnHeightRow) {
          columnHeightRow.style.display = isColumn ? 'flex' : 'none';
          if (isColumn) {
            const columnHeight = selectedElement.columnHeight;
            const select = document.getElementById('propColumnHeight');

            if (columnHeight === undefined) {
              select.value = 'ceiling';
              if (customColumnHeightRow) customColumnHeightRow.style.display = 'none';
            } else {
              const presets = [8, 9, 10, 12];
              const matchesPreset = presets.some(p => Math.abs(columnHeight - p) < 0.05);

              if (matchesPreset) {
                select.value = presets.find(p => Math.abs(columnHeight - p) < 0.05).toString();
                if (customColumnHeightRow) customColumnHeightRow.style.display = 'none';
              } else {
                select.value = 'custom';
                if (customColumnHeightRow) {
                  customColumnHeightRow.style.display = 'flex';
                  document.getElementById('propCustomColumnHeight').value = columnHeight.toFixed(2);
                  document.getElementById('propColumnHeightDisplay').textContent = formatDimension(columnHeight);
                }
              }
            }
          }
        }
        if (customColumnHeightRow && !isColumn) customColumnHeightRow.style.display = 'none';

        // Column size control
        if (columnSizeRow) {
          columnSizeRow.style.display = isColumn ? 'flex' : 'none';
          if (isColumn) {
            const colSize = selectedElement.width || 0.5;
            const select = document.getElementById('propColumnSize');
            const presets = [0.33, 0.5, 0.67, 1, 1.33];
            const matchesPreset = presets.some(p => Math.abs(colSize - p) < 0.02);

            if (matchesPreset) {
              select.value = presets.find(p => Math.abs(colSize - p) < 0.02).toString();
            } else {
              select.value = 'custom';
            }
          }
        }

        // Full-height wall controls (walls, masonry, concrete, etc.)
        const fullWallTypes = ['wall', 'wall-block', 'wall-concrete', 'wall-framed', 'wall-wood-2x4', 'wall-wood-2x6', 'wall-brick', 'wall-steel', 'wall-aluminum'];
        const isFullWall = fullWallTypes.includes(selectedElement.type);
        const fullWallHeightRow = document.getElementById('fullWallHeightRow');
        const customFullWallHeightRow = document.getElementById('customFullWallHeightRow');
        const wallThicknessRow = document.getElementById('wallThicknessRow');
        const customWallThicknessRow = document.getElementById('customWallThicknessRow');

        // Full wall height control
        if (fullWallHeightRow) {
          fullWallHeightRow.style.display = isFullWall ? 'flex' : 'none';
          if (isFullWall) {
            const wallHeight = selectedElement.wallHeight;
            const select = document.getElementById('propFullWallHeight');

            if (wallHeight === undefined) {
              select.value = 'ceiling';
              if (customFullWallHeightRow) customFullWallHeightRow.style.display = 'none';
            } else {
              const presets = [8, 9, 10, 12, 14, 16];
              const matchesPreset = presets.some(p => Math.abs(wallHeight - p) < 0.05);

              if (matchesPreset) {
                select.value = presets.find(p => Math.abs(wallHeight - p) < 0.05).toString();
                if (customFullWallHeightRow) customFullWallHeightRow.style.display = 'none';
              } else {
                select.value = 'custom';
                if (customFullWallHeightRow) {
                  customFullWallHeightRow.style.display = 'flex';
                  document.getElementById('propCustomFullWallHeight').value = wallHeight.toFixed(2);
                  document.getElementById('propFullWallHeightDisplay').textContent = formatDimension(wallHeight);
                }
              }
            }
          }
        }
        if (customFullWallHeightRow && !isFullWall) customFullWallHeightRow.style.display = 'none';

        // Wall thickness control
        if (wallThicknessRow) {
          wallThicknessRow.style.display = isFullWall ? 'flex' : 'none';
          if (isFullWall) {
            const thickness = selectedElement.height || 0.5; // In 2D, 'height' is the depth/thickness
            const select = document.getElementById('propWallThickness');
            const presets = [0.33, 0.5, 0.67, 0.83, 1, 1.33];
            const matchesPreset = presets.some(p => Math.abs(thickness - p) < 0.02);

            if (matchesPreset) {
              select.value = presets.find(p => Math.abs(thickness - p) < 0.02).toString();
              if (customWallThicknessRow) customWallThicknessRow.style.display = 'none';
            } else {
              select.value = 'custom';
              if (customWallThicknessRow) {
                customWallThicknessRow.style.display = 'flex';
                document.getElementById('propCustomWallThickness').value = thickness.toFixed(2);
                document.getElementById('propWallThicknessDisplay').textContent = formatDimension(thickness);
              }
            }
          }
        }
        if (customWallThicknessRow && !isFullWall) customWallThicknessRow.style.display = 'none';

        // Generic 3D height override for elements without specialized height controls
        const generic3DHeightRow = document.getElementById('generic3DHeightRow');
        const customGeneric3DHeightRow = document.getElementById('customGeneric3DHeightRow');
        const typesWithSpecializedHeight = new Set([
          'window', 'window-large', 'picture-window', 'window-bay', 'window-arch', 'window-circle',
          'door', 'door-double', 'door-sliding', 'door-french', 'door-bifold', 'door-pocket', 'glass-door',
          'wall', 'full-wall', 'pony-wall', 'half-wall', 'knee-wall',
          'beam', 'header', 'beam-decorative', 'column', 'column-round',
          'countertop', 'countertop-l', 'countertop-u', 'countertop-corner', 'island',
          'flooring', 'tile', 'floor-tile', 'hardwood', 'laminate',
          'wall-cap', 'bar-top', 'niche', 'niche-arched', 'niche-shelf'
        ]);
        const showGenericHeight = !typesWithSpecializedHeight.has(selectedElement.type);
        if (generic3DHeightRow) {
          generic3DHeightRow.style.display = showGenericHeight ? 'flex' : 'none';
          if (showGenericHeight) {
            const h3d = selectedElement.height3D;
            const select = document.getElementById('propGeneric3DHeight');
            if (h3d !== undefined && h3d !== null) {
              const presets = [0.5, 1, 1.5, 2, 2.5, 3, 3.5, 4, 5, 6, 7, 8];
              const matchPreset = presets.find(p => Math.abs(h3d - p) < 0.02);
              if (matchPreset !== undefined) {
                select.value = matchPreset.toString();
                if (customGeneric3DHeightRow) customGeneric3DHeightRow.style.display = 'none';
              } else {
                select.value = 'custom';
                if (customGeneric3DHeightRow) {
                  customGeneric3DHeightRow.style.display = 'flex';
                  document.getElementById('propCustomGeneric3DHeight').value = h3d.toFixed(2);
                }
              }
            } else {
              select.value = 'default';
              if (customGeneric3DHeightRow) customGeneric3DHeightRow.style.display = 'none';
            }
          }
        }
        if (customGeneric3DHeightRow && !showGenericHeight) customGeneric3DHeightRow.style.display = 'none';

        // Update pricing section
        const pricingSection = document.getElementById('pricingSection');
        if (pricingSection && checkPermission('canViewPrices')) {
          pricingSection.style.display = 'block';

          const priceInfo = getElementPrice(selectedElement);
          document.getElementById('propBasePrice').textContent = '$' + priceInfo.price.toFixed(2);
          document.getElementById('propPriceOverride').value = selectedElement.priceOverride || '';
          document.getElementById('propPriceUnit').value = selectedElement.priceUnit || 'sqft';
          document.getElementById('propMargin').value = selectedElement.marginPercent !== null ? selectedElement.marginPercent : '';

          // Calculate and show item total
          const margin = getElementMargin(selectedElement);
          let quantity = 1;
          if (['countertop', 'backsplash', 'flooring', 'tile'].includes(selectedElement.type)) {
            quantity = selectedElement.width * selectedElement.height;
          }
          const cost = priceInfo.price * quantity;
          const retail = cost * (1 + margin / 100);
          document.getElementById('propItemTotal').textContent = '$' + retail.toFixed(2);
        } else if (pricingSection) {
          pricingSection.style.display = 'none';
        }
      } else {
        empty.style.display = 'block';
        content.style.display = 'none';
      }
    }

    function updateSelectedElement() {
      if (!selectedElement || selectedElement.locked) return;

      // Parse dimension input (accepts feet-inches like 3'-6" or decimal 2.5)
      const widthInput = document.getElementById('propWidth').value;
      const heightInput = document.getElementById('propHeight').value;

      selectedElement.width = roundToSixteenth(parseDimension(widthInput)) || 1;
      selectedElement.height = roundToSixteenth(parseDimension(heightInput)) || 1;
      selectedElement.color = document.getElementById('propColor').value;

      // Mark element as needing 3D update
      markElement3DDirty(selectedElement.id);

      // Update display with formatted dimensions
      updateProperties();
      draw();
    }

    // Set grain/tile direction for flooring
    function setGrainDirection(angle) {
      if (!selectedElement || selectedElement.locked) return;

      const isFlooringType = ['flooring', 'tile', 'hardwood', 'laminate', 'vinyl', 'carpet'].includes(selectedElement.type);
      if (!isFlooringType) return;

      selectedElement.grainDirection = angle;

      // Mark element as needing 3D update
      markElement3DDirty(selectedElement.id);

      // Update button states
      document.querySelectorAll('.grain-btn').forEach(btn => {
        btn.classList.toggle('active', parseInt(btn.dataset.dir) === angle);
      });

      saveUndoState();
      draw();
      update3DScene();

      const dirNames = { 0: 'Horizontal', 90: 'Vertical', 45: 'Diagonal ()', 135: 'Diagonal ()' };
      showSnapFeedback(`Grain direction: ${dirNames[angle] || angle + ''}`);
    }

    // Get default beam depth based on type
    function getDefaultBeamDepth(type) {
      switch(type) {
        case 'steel-beam': return 0.67;     // W8 beam - 8"
        case 'wood-beam': return 0.5;        // 6" timber
        case 'concrete-beam': return 0.83;   // 10" concrete beam
        case 'header': return 0.33;          // 4" header
        case 'lvl-beam': return 0.92;        // 11" LVL
        default: return 0.67;
      }
    }

    // Update beam depth from dropdown
    function updateBeamDepth() {
      if (!selectedElement || selectedElement.locked) return;

      const select = document.getElementById('propBeamDepth');
      const value = select.value;
      const customRow = document.getElementById('customBeamDepthRow');

      if (value === 'custom') {
        customRow.style.display = 'flex';
        const current = selectedElement.beamDepth || getDefaultBeamDepth(selectedElement.type);
        document.getElementById('propCustomBeamDepth').value = current.toFixed(2);
        document.getElementById('propBeamDepthDisplay').textContent = formatDimension(current);
        return;
      }

      customRow.style.display = 'none';
      const depth = parseFloat(value);
      selectedElement.beamDepth = depth;

      saveUndoState();
      draw();
      update3DScene();
      showSnapFeedback(`Beam depth: ${Math.round(depth * 12)}"`);
    }

    // Apply custom beam depth
    function applyCustomBeamDepth() {
      if (!selectedElement || selectedElement.locked) return;

      const input = document.getElementById('propCustomBeamDepth');
      const depth = parseDimension(input.value);
      if (depth && depth > 0 && depth <= 4) {
        selectedElement.beamDepth = depth;
        document.getElementById('propBeamDepthDisplay').textContent = formatDimension(depth);

        saveUndoState();
        draw();
        update3DScene();
        showSnapFeedback(`Beam depth: ${formatDimension(depth)}`);
      }
    }

    // Update beam elevation from dropdown
    function updateBeamElevation() {
      if (!selectedElement || selectedElement.locked) return;

      const select = document.getElementById('propBeamElevation');
      const value = select.value;
      const customRow = document.getElementById('customBeamElevationRow');

      if (value === 'custom') {
        customRow.style.display = 'flex';
        const current = selectedElement.beamElevation || roomHeight || 8;
        document.getElementById('propCustomBeamElevation').value = current.toFixed(2);
        document.getElementById('propBeamElevationDisplay').textContent = formatDimension(current);
        return;
      }

      customRow.style.display = 'none';

      if (value === 'ceiling') {
        delete selectedElement.beamElevation; // Use room height
        showSnapFeedback('Beam at ceiling level');
      } else {
        selectedElement.beamElevation = parseFloat(value);
        showSnapFeedback(`Beam elevation: ${formatDimension(parseFloat(value))}`);
      }

      saveUndoState();
      draw();
      update3DScene();
    }

    // Apply custom beam elevation
    function applyCustomBeamElevation() {
      if (!selectedElement || selectedElement.locked) return;

      const input = document.getElementById('propCustomBeamElevation');
      const elevation = parseDimension(input.value);
      if (elevation && elevation > 0 && elevation <= 20) {
        selectedElement.beamElevation = elevation;
        document.getElementById('propBeamElevationDisplay').textContent = formatDimension(elevation);

        saveUndoState();
        draw();
        update3DScene();
        showSnapFeedback(`Beam elevation: ${formatDimension(elevation)}`);
      }
    }

    // Update column height from dropdown
    function updateColumnHeight() {
      if (!selectedElement || selectedElement.locked) return;

      const select = document.getElementById('propColumnHeight');
      const value = select.value;
      const customRow = document.getElementById('customColumnHeightRow');

      if (value === 'custom') {
        customRow.style.display = 'flex';
        const current = selectedElement.columnHeight || roomHeight || 8;
        document.getElementById('propCustomColumnHeight').value = current.toFixed(2);
        document.getElementById('propColumnHeightDisplay').textContent = formatDimension(current);
        return;
      }

      customRow.style.display = 'none';

      if (value === 'ceiling') {
        delete selectedElement.columnHeight; // Use room height
        showSnapFeedback('Column: floor to ceiling');
      } else {
        selectedElement.columnHeight = parseFloat(value);
        showSnapFeedback(`Column height: ${formatDimension(parseFloat(value))}`);
      }

      saveUndoState();
      draw();
      update3DScene();
    }

    // Apply custom column height
    function applyCustomColumnHeight() {
      if (!selectedElement || selectedElement.locked) return;

      const input = document.getElementById('propCustomColumnHeight');
      const height = parseDimension(input.value);
      if (height && height > 0 && height <= 20) {
        selectedElement.columnHeight = height;
        document.getElementById('propColumnHeightDisplay').textContent = formatDimension(height);

        saveUndoState();
        draw();
        update3DScene();
        showSnapFeedback(`Column height: ${formatDimension(height)}`);
      }
    }

    // Update column size from dropdown
    function updateColumnSize() {
      if (!selectedElement || selectedElement.locked) return;

      const select = document.getElementById('propColumnSize');
      const value = select.value;

      if (value === 'custom') {
        // Custom sizes can be entered via width/height fields
        showSnapFeedback('Enter custom size in Width/Depth fields');
        return;
      }

      const size = parseFloat(value);
      selectedElement.width = size;
      selectedElement.height = size; // Square column

      updateProperties();
      saveUndoState();
      draw();
      update3DScene();
      showSnapFeedback(`Column size: ${Math.round(size * 12)}"${Math.round(size * 12)}"`);
    }

    // Generic 3D height override for elements without specialized height controls
    function updateGeneric3DHeight() {
      if (!selectedElement || selectedElement.locked) return;

      const select = document.getElementById('propGeneric3DHeight');
      const value = select.value;
      const customRow = document.getElementById('customGeneric3DHeightRow');

      if (value === 'custom') {
        customRow.style.display = 'flex';
        const current = selectedElement.height3D || 3;
        document.getElementById('propCustomGeneric3DHeight').value = current.toFixed(2);
        return;
      }

      customRow.style.display = 'none';

      if (value === 'default') {
        delete selectedElement.height3D;
      } else {
        selectedElement.height3D = parseFloat(value);
      }

      markElement3DDirty(selectedElement.id);
      saveUndoState();
      draw();
      update3DScene();
      const label = value === 'default' ? 'Default' : formatDimension(parseFloat(value));
      showSnapFeedback(`3D Height: ${label}`);
    }

    function applyCustomGeneric3DHeight() {
      if (!selectedElement || selectedElement.locked) return;

      const input = document.getElementById('propCustomGeneric3DHeight');
      const height = parseFloat(input.value);
      if (height && height >= 0.1 && height <= 20) {
        selectedElement.height3D = height;
        markElement3DDirty(selectedElement.id);
        saveUndoState();
        draw();
        update3DScene();
        showSnapFeedback(`3D Height: ${formatDimension(height)}`);
      }
    }

    // Update full wall height from dropdown
    function updateFullWallHeight() {
      if (!selectedElement || selectedElement.locked) return;

      const select = document.getElementById('propFullWallHeight');
      const value = select.value;
      const customRow = document.getElementById('customFullWallHeightRow');

      if (value === 'custom') {
        customRow.style.display = 'flex';
        const current = selectedElement.wallHeight || roomHeight || 8;
        document.getElementById('propCustomFullWallHeight').value = current.toFixed(2);
        document.getElementById('propFullWallHeightDisplay').textContent = formatDimension(current);
        return;
      }

      customRow.style.display = 'none';

      if (value === 'ceiling') {
        delete selectedElement.wallHeight; // Use room height
        showSnapFeedback('Wall: floor to ceiling');
      } else {
        selectedElement.wallHeight = parseFloat(value);
        showSnapFeedback(`Wall height: ${formatDimension(parseFloat(value))}`);
      }

      saveUndoState();
      draw();
      update3DScene();
    }

    // Apply custom full wall height
    function applyCustomFullWallHeight() {
      if (!selectedElement || selectedElement.locked) return;

      const input = document.getElementById('propCustomFullWallHeight');
      const height = parseDimension(input.value);
      if (height && height > 0 && height <= 30) {
        selectedElement.wallHeight = height;
        document.getElementById('propFullWallHeightDisplay').textContent = formatDimension(height);

        saveUndoState();
        draw();
        update3DScene();
        showSnapFeedback(`Wall height: ${formatDimension(height)}`);
      }
    }

    // Update wall thickness from dropdown
    function updateWallThickness() {
      if (!selectedElement || selectedElement.locked) return;

      const select = document.getElementById('propWallThickness');
      const value = select.value;
      const customRow = document.getElementById('customWallThicknessRow');

      if (value === 'custom') {
        customRow.style.display = 'flex';
        const current = selectedElement.height || 0.5;
        document.getElementById('propCustomWallThickness').value = current.toFixed(2);
        document.getElementById('propWallThicknessDisplay').textContent = formatDimension(current);
        return;
      }

      customRow.style.display = 'none';
      const thickness = parseFloat(value);
      selectedElement.height = thickness; // In 2D, height is depth/thickness

      updateProperties();
      saveUndoState();
      draw();
      update3DScene();
      showSnapFeedback(`Wall thickness: ${Math.round(thickness * 12)}"`);
    }

    // Apply custom wall thickness
    function applyCustomWallThickness() {
      if (!selectedElement || selectedElement.locked) return;

      const input = document.getElementById('propCustomWallThickness');
      const thickness = parseDimension(input.value);
      if (thickness && thickness > 0 && thickness <= 3) {
        selectedElement.height = thickness;
        document.getElementById('propWallThicknessDisplay').textContent = formatDimension(thickness);

        updateProperties();
        saveUndoState();
        draw();
        update3DScene();
        showSnapFeedback(`Wall thickness: ${formatDimension(thickness)}`);
      }
    }

    // Apply a standard size from dropdown
    function applyStandardSize() {
      if (!selectedElement || selectedElement.locked) return;

      const select = document.getElementById('propStandardSize');
      const value = select.value;
      if (!value) return;

      const [width, height] = value.split('x').map(parseFloat);
      if (width && height) {
        selectedElement.width = width;
        selectedElement.height = height;
        updateProperties();
        draw();
        showSnapFeedback(`Applied standard size: ${formatDimension(width)}  ${formatDimension(height)}`);
      }
    }

    // Get default sill height based on element type (building code compliant)
    function getDefaultSillHeight(type) {
      // Proper construction sill heights per IRC / industry standards
      switch(type) {
        case 'window':
          return 3;       // 36" - IRC standard residential window sill
        case 'window-large':
          return 2;       // 24" - picture windows sit lower for views
        case 'window-bay':
        case 'bay-window':
          return 3.5;     // 42" - above counter height (kitchen bay windows)
        case 'picture-window':
          return 1.5;     // 18" - near floor for panoramic views
        case 'door':
        case 'double-door':
        case 'sliding-door':
        case 'french-door':
        case 'glass-door':
        case 'entry-archway':
        case 'garage-door':
          return 0;       // Floor level for all doors
        default:
          return 3;       // 36" IRC default
      }
    }

    // Update sill height from dropdown
    function updateSillHeight() {
      if (!selectedElement) return;

      const select = document.getElementById('propSillHeight');
      const value = select.value;
      const customSillRow = document.getElementById('customSillRow');

      if (value === 'custom') {
        customSillRow.style.display = 'flex';
        document.getElementById('propCustomSill').value = selectedElement.sillHeight || getDefaultSillHeight(selectedElement.type);
        return;
      }

      customSillRow.style.display = 'none';
      const sillHeight = parseFloat(value);
      selectedElement.sillHeight = sillHeight;

      // Show building code info
      let codeInfo = '';
      if (sillHeight < 2) {
        codeInfo = ' (Note: Standard min is 24")';
      } else if (sillHeight > 3.67) {
        codeInfo = ' (Warning: May exceed egress max 44")';
      }

      markElement3DDirty(selectedElement.id);
      saveUndoState();
      draw();
      update3DScene();
      showSnapFeedback(`Sill height: ${Math.round(sillHeight * 12)}"${codeInfo}`);
    }

    // Apply custom sill height
    function applyCustomSillHeight() {
      if (!selectedElement) return;

      const input = document.getElementById('propCustomSill');
      const sillHeight = parseFloat(input.value) || 0;

      // Clamp to reasonable values
      selectedElement.sillHeight = Math.max(0, Math.min(8, sillHeight));

      // Building code warnings
      let warning = '';
      if (sillHeight < 2 && selectedElement.type === 'window') {
        warning = ' - Below 24" minimum for safety';
      } else if (sillHeight > 3.67 && selectedElement.type === 'window') {
        warning = ' - Above 44" egress maximum';
      }

      markElement3DDirty(selectedElement.id);
      saveUndoState();
      draw();
      update3DScene();
      showSnapFeedback(`Custom sill: ${Math.round(sillHeight * 12)}"${warning}`);
    }

    // Update window opening height (3D height of the window)
    function updateWindowOpeningHeight() {
      if (!selectedElement) return;

      const select = document.getElementById('propWindowHeight');
      const value = select.value;
      const customRow = document.getElementById('customWindowHeightRow');

      if (value === 'custom') {
        if (customRow) {
          customRow.style.display = 'flex';
          document.getElementById('propCustomWindowHeight').value =
            selectedElement.windowHeight || get3DHeight(selectedElement);
        }
        return;
      }

      if (customRow) customRow.style.display = 'none';
      const windowHeight = parseFloat(value);
      selectedElement.windowHeight = windowHeight;

      markElement3DDirty(selectedElement.id);
      saveUndoState();
      draw();
      update3DScene();
      showSnapFeedback(`Window height: ${Math.round(windowHeight * 12)}"`);
    }

    // Apply custom window opening height
    function applyCustomWindowOpeningHeight() {
      if (!selectedElement) return;

      const input = document.getElementById('propCustomWindowHeight');
      const windowHeight = Math.max(1, Math.min(10, parseFloat(input.value) || 3));
      selectedElement.windowHeight = windowHeight;

      const display = document.getElementById('propWindowHeightDisplay');
      if (display) display.textContent = formatDimension(windowHeight);

      markElement3DDirty(selectedElement.id);
      saveUndoState();
      draw();
      update3DScene();
      showSnapFeedback(`Window height: ${Math.round(windowHeight * 12)}"`);
    }

    // Update door/archway height
    function updateDoorHeight() {
      if (!selectedElement) return;

      const select = document.getElementById('propDoorHeight');
      const value = select.value;
      const customDoorHeightRow = document.getElementById('customDoorHeightRow');

      if (value === 'custom') {
        customDoorHeightRow.style.display = 'flex';
        const currentHeight = selectedElement.height3D || 6.8;
        document.getElementById('propCustomDoorHeight').value = currentHeight.toFixed(2);
        document.getElementById('propDoorHeightDisplay').textContent = formatDimension(currentHeight);
        return;
      }

      customDoorHeightRow.style.display = 'none';
      const doorHeight = parseFloat(value);
      selectedElement.height3D = doorHeight;

      saveUndoState();
      draw();
      update3DScene();
      showSnapFeedback(`Opening height: ${Math.round(doorHeight * 12)}" (${formatDimension(doorHeight)})`);
    }

    // Apply custom door height
    function applyCustomDoorHeight() {
      if (!selectedElement) return;

      const input = document.getElementById('propCustomDoorHeight');
      const doorHeight = parseFloat(input.value) || 6.8;

      // Clamp to reasonable values
      selectedElement.height3D = Math.max(5, Math.min(12, doorHeight));

      document.getElementById('propDoorHeightDisplay').textContent = formatDimension(selectedElement.height3D);

      saveUndoState();
      draw();
      update3DScene();
      showSnapFeedback(`Custom height: ${Math.round(selectedElement.height3D * 12)}"`);
    }

    // Update archway style
    function updateArchwayStyle() {
      if (!selectedElement) return;

      const style = document.getElementById('propArchwayStyle').value;
      selectedElement.archwayStyle = style;

      saveUndoState();
      draw();
      update3DScene();
      showSnapFeedback(`Archway style: ${style}`);
    }

    // Update window style (double-hung, casement, sliding, etc.)
    function updateWindowStyle() {
      if (!selectedElement) return;

      const style = document.getElementById('propWindowStyle').value;
      selectedElement.windowStyle = style;

      saveUndoState();
      draw();
      update3DScene();
      showSnapFeedback(`Window style: ${style.replace('-', ' ')}`);
    }

    // Update window mullion/grille pattern
    function updateMullionPattern() {
      if (!selectedElement) return;

      const pattern = document.getElementById('propMullionPattern').value;
      selectedElement.mullionPattern = pattern;

      saveUndoState();
      draw();
      update3DScene();
      showSnapFeedback(`Mullion pattern: ${pattern}`);
    }

    // Update wall height for pony walls/half walls
    function updateWallHeight() {
      if (!selectedElement) return;

      const select = document.getElementById('propWallHeight');
      const value = select.value;
      const customWallHeightRow = document.getElementById('customWallHeightRow');

      if (value === 'custom') {
        customWallHeightRow.style.display = 'flex';
        const currentHeight = selectedElement.wallHeight || 3.5;
        document.getElementById('propCustomWallHeight').value = currentHeight.toFixed(2);
        document.getElementById('propWallHeightDisplay').textContent = formatDimension(currentHeight);
        return;
      }

      customWallHeightRow.style.display = 'none';
      const wallHeight = parseFloat(value);
      selectedElement.wallHeight = wallHeight;

      // Update any wall-caps linked to this wall
      updateLinkedWallCaps(selectedElement, wallHeight);

      saveUndoState();
      draw();
      update3DScene();
      showSnapFeedback(`Wall height: ${Math.round(wallHeight * 12)}" (${formatDimension(wallHeight)})`);
    }

    // Update any wall-caps that are linked to or overlapping with this pony wall
    function updateLinkedWallCaps(wall, wallHeight) {
      const capTypes = ['wall-cap', 'bar-top'];
      const wallCenterX = wall.x / pixelsPerFoot + wall.width / 2;
      const wallCenterY = wall.y / pixelsPerFoot + wall.height / 2;

      elements.forEach(el => {
        if (!capTypes.includes(el.type)) return;

        // Check if linked by parentWallId
        if (el.parentWallId === wall.id) {
          el.capHeight = wallHeight;
          return;
        }

        // Check if overlapping (for manually placed caps)
        const capCenterX = el.x / pixelsPerFoot + el.width / 2;
        const capCenterY = el.y / pixelsPerFoot + el.height / 2;
        const distX = Math.abs(capCenterX - wallCenterX);
        const distY = Math.abs(capCenterY - wallCenterY);

        // If cap overlaps this wall, update its height
        if (distX < (el.width + wall.width) / 2 + 0.5 &&
            distY < (el.height + wall.height) / 2 + 0.5) {
          el.capHeight = wallHeight;
        }
      });
    }

    // Apply custom wall height
    function applyCustomWallHeight() {
      if (!selectedElement) return;

      const input = document.getElementById('propCustomWallHeight');
      const wallHeight = parseFloat(input.value) || 3.5;

      // Clamp to reasonable values (1ft to 8ft)
      selectedElement.wallHeight = Math.max(1, Math.min(8, wallHeight));

      // Update any wall-caps linked to this wall
      updateLinkedWallCaps(selectedElement, selectedElement.wallHeight);

      // Update display
      document.getElementById('propWallHeightDisplay').textContent = formatDimension(selectedElement.wallHeight);

      saveUndoState();
      draw();
      update3DScene();
      showSnapFeedback(`Wall height: ${Math.round(selectedElement.wallHeight * 12)}" (${formatDimension(selectedElement.wallHeight)})`);
    }

    // Update niche depth for recessed wall elements
    function updateNicheDepth() {
      if (!selectedElement) return;

      const select = document.getElementById('propNicheDepth');
      const value = select.value;
      const customNicheDepthRow = document.getElementById('customNicheDepthRow');

      if (value === 'custom') {
        customNicheDepthRow.style.display = 'flex';
        const currentDepth = selectedElement.nicheDepth || 0.33;
        document.getElementById('propCustomNicheDepth').value = currentDepth.toFixed(2);
        document.getElementById('propNicheDepthDisplay').textContent = formatDimension(currentDepth);
        return;
      }

      customNicheDepthRow.style.display = 'none';
      const nicheDepth = parseFloat(value);
      selectedElement.nicheDepth = nicheDepth;

      saveUndoState();
      draw();
      update3DScene();
      showSnapFeedback(`Niche depth: ${Math.round(nicheDepth * 12)}" (${formatDimension(nicheDepth)})`);
    }

    // Apply custom niche depth
    function applyCustomNicheDepth() {
      if (!selectedElement) return;

      const input = document.getElementById('propCustomNicheDepth');
      const nicheDepth = parseFloat(input.value) || 0.33;

      // Clamp to reasonable values (2" to 3ft)
      selectedElement.nicheDepth = Math.max(0.17, Math.min(3, nicheDepth));

      // Update display
      document.getElementById('propNicheDepthDisplay').textContent = formatDimension(selectedElement.nicheDepth);

      saveUndoState();
      draw();
      update3DScene();
      showSnapFeedback(`Niche depth: ${Math.round(selectedElement.nicheDepth * 12)}" (${formatDimension(selectedElement.nicheDepth)})`);
    }

    // Update stone surface thickness
    function updateStoneThickness() {
      if (!selectedElement) return;

      const select = document.getElementById('propStoneThickness');
      const thickness = parseFloat(select.value);

      selectedElement.stoneThickness = thickness;

      // Convert to inches for display
      const thicknessInches = thickness * 12;
      let thicknessLabel = '';
      if (Math.abs(thicknessInches - 0.75) < 0.1) thicknessLabel = '3/4" (2cm)';
      else if (Math.abs(thicknessInches - 1.25) < 0.1) thicknessLabel = '1.25" (3cm)';
      else if (Math.abs(thicknessInches - 1.5) < 0.1) thicknessLabel = '1.5"';
      else if (Math.abs(thicknessInches - 2) < 0.2) thicknessLabel = '2"';
      else if (Math.abs(thicknessInches - 3) < 0.2) thicknessLabel = '3"';
      else thicknessLabel = thicknessInches.toFixed(1) + '"';

      saveUndoState();
      draw();
      update3DScene();
      showSnapFeedback(`Stone thickness: ${thicknessLabel}`);
    }

    // Update cap height for wall caps and bar tops
    function updateCapHeight() {
      if (!selectedElement) return;

      const select = document.getElementById('propCapHeight');
      const value = select.value;
      const customRow = document.getElementById('customCapHeightRow');

      if (value === 'custom') {
        if (customRow) {
          customRow.style.display = 'flex';
          const currentHeight = selectedElement.capHeight || 3.5;
          document.getElementById('propCustomCapHeight').value = currentHeight.toFixed(2);
          document.getElementById('propCapHeightDisplay').textContent = formatDimension(currentHeight);
        }
        return;
      }

      if (customRow) customRow.style.display = 'none';

      const capHeight = parseFloat(value);
      selectedElement.capHeight = capHeight;

      saveUndoState();
      draw();
      update3DScene();
      showSnapFeedback(`Cap height: ${formatDimension(capHeight)} (${Math.round(capHeight * 12)}")`);
    }

    // Apply custom cap height
    function applyCustomCapHeight() {
      if (!selectedElement) return;

      const input = document.getElementById('propCustomCapHeight');
      const capHeight = parseFloat(input.value) || 3;

      selectedElement.capHeight = Math.max(0.5, Math.min(8, capHeight));

      // Update display
      document.getElementById('propCapHeightDisplay').textContent = formatDimension(selectedElement.capHeight);

      saveUndoState();
      draw();
      update3DScene();
      showSnapFeedback(`Cap height: ${formatDimension(selectedElement.capHeight)} (${Math.round(selectedElement.capHeight * 12)}")`);
    }

    // Update edge profile for selected countertop (from properties panel)
    function updateSelectedEdgeProfile() {
      const countertopTypes = ['countertop', 'countertop-corner', 'countertop-l', 'countertop-u', 'island'];
      if (!selectedElement || !countertopTypes.includes(selectedElement.type)) return;

      const profile = document.getElementById('propEdgeProfile').value;
      selectedElement.edgeProfile = profile;

      // Show edge profile durability info
      const edgeInfo = FABRICATION_STANDARDS.edgeDurability[profile];
      const infoDiv = document.getElementById('edgeProfileInfo');
      const infoRow = document.getElementById('edgeProfileInfoRow');

      if (infoDiv && infoRow && edgeInfo) {
        const stars = ''.repeat(edgeInfo.rating) + ''.repeat(5 - edgeInfo.rating);
        infoDiv.innerHTML = `<strong>Durability:</strong> ${stars}<br><strong>Chip Resistance:</strong> ${edgeInfo.chipResistance}<br>${edgeInfo.notes}`;
        infoRow.style.display = 'block';
      } else if (infoRow) {
        infoRow.style.display = 'none';
      }

      // Waterfall sides are now independent of edge profile - don't clear them
      // Edge profile only affects the visible edge shape (bullnose, ogee, etc.)

      update3DScene();
      calculateQuote();
      showSnapFeedback(`Edge profile: ${profile}`);
    }

    // Update countertop thickness (2cm vs 3cm)
    function updateCountertopThickness() {
      const countertopTypes = ['countertop', 'countertop-corner', 'countertop-l', 'countertop-u', 'island'];
      if (!selectedElement || !countertopTypes.includes(selectedElement.type)) return;

      const thickness = document.getElementById('propThickness').value;
      const edgeStyle = document.getElementById('propEdgeStyle').value;

      selectedElement.thickness = thickness;
      selectedElement.edgeBuildStyle = thickness === '2cm' ? edgeStyle : null;

      // Show/hide edge style row based on thickness
      const edgeStyleRow = document.getElementById('edgeStyleRow');
      if (edgeStyleRow) {
        edgeStyleRow.style.display = thickness === '2cm' ? 'flex' : 'none';
      }

      update3DScene();
      calculateQuote();

      if (thickness === '2cm') {
        showSnapFeedback(`2cm thickness with ${edgeStyle} edge build`);
      } else {
        showSnapFeedback(`3cm thickness (standard)`);
      }
    }

    // Update backsplash height for countertops
    function updateBacksplash() {
      if (!selectedElement || selectedElement.type !== 'countertop') return;

      const value = document.getElementById('propBacksplash').value;
      if (value === 'none') {
        selectedElement.backsplash = null;
      } else if (value === 'full') {
        selectedElement.backsplash = { height: 18, type: 'full' }; // Full height to upper cabinets
      } else {
        selectedElement.backsplash = { height: parseInt(value), type: 'standard' };
      }
      update3DScene();
      calculateQuote();
      showSnapFeedback(`Backsplash: ${value === 'none' ? 'None' : value + '"'}`);
    }

    // Update finished ends for countertops
    function updateFinishedEnds() {
      if (!selectedElement || selectedElement.type !== 'countertop') return;

      const ends = [];
      if (document.getElementById('propFinishedLeft').checked) ends.push('left');
      if (document.getElementById('propFinishedRight').checked) ends.push('right');
      selectedElement.finishedEnds = ends.length > 0 ? ends : null;
      update3DScene();
      calculateQuote();
    }

    // Update waterfall sides (which sides get waterfall treatment)
    function updateWaterfallSides() {
      const countertopTypes = ['countertop', 'countertop-corner', 'countertop-l', 'countertop-u', 'island'];
      if (!selectedElement || !countertopTypes.includes(selectedElement.type)) return;

      const waterfallSides = [];
      if (document.getElementById('propWaterfallLeft')?.checked) waterfallSides.push('left');
      if (document.getElementById('propWaterfallRight')?.checked) waterfallSides.push('right');
      if (document.getElementById('propWaterfallFront')?.checked) waterfallSides.push('front');
      if (document.getElementById('propWaterfallBack')?.checked) waterfallSides.push('back');

      selectedElement.waterfallSides = waterfallSides.length > 0 ? waterfallSides : null;

      // If any waterfall sides are enabled, ensure waterfall height row is visible
      const waterfallHeightRow = document.getElementById('waterfallHeightRow');
      if (waterfallHeightRow) {
        waterfallHeightRow.style.display = waterfallSides.length > 0 ? 'flex' : 'none';
      }

      update3DScene();
      calculateQuote();

      if (waterfallSides.length > 0) {
        showSnapFeedback(`Waterfall sides: ${waterfallSides.join(', ')}`);
      }
    }

    // Update waterfall drop height
    function updateWaterfallHeight() {
      const countertopTypes = ['countertop', 'countertop-corner', 'countertop-l', 'countertop-u', 'island'];
      if (!selectedElement || !countertopTypes.includes(selectedElement.type)) return;

      const value = document.getElementById('propWaterfallHeight')?.value;

      if (value === 'floor') {
        // Calculate height to floor from counter
        selectedElement.waterfallHeight = 'floor';
        selectedElement.waterfallDropFeet = 3; // Default counter height
      } else if (value === 'custom') {
        const customHeight = prompt('Enter waterfall drop height in feet:', '3');
        if (customHeight && !isNaN(parseFloat(customHeight))) {
          selectedElement.waterfallHeight = parseFloat(customHeight);
          selectedElement.waterfallDropFeet = parseFloat(customHeight);
        }
      } else {
        selectedElement.waterfallHeight = parseFloat(value);
        selectedElement.waterfallDropFeet = parseFloat(value);
      }

      update3DScene();
      calculateQuote();
      showSnapFeedback(`Waterfall drop: ${selectedElement.waterfallHeight === 'floor' ? 'To floor' : selectedElement.waterfallHeight + "'"}`);
    }

    // Fabrication guidelines based on Marble Institute of America standards
    const FABRICATION_STANDARDS = {
      overhang: {
        // Maximum unsupported overhang by thickness
        '2cm': { maxUnsupported: 6, bracketRequired: 6, plywoodRequired: true },
        '3cm': { maxUnsupported: 10, bracketRequired: 12, plywoodRequired: false }
      },
      // Maximum unsupported span (side-to-side between supports)
      maxSpan: {
        '2cm': 24, // inches
        '3cm': 36  // inches
      },
      // Seating overhang standards
      seating: {
        bar: { depth: 12, description: 'Standard bar seating' },
        breakfast: { depth: 15, description: 'Comfortable breakfast bar' },
        ada: { depth: 19, minKneeHeight: 27, description: 'ADA accessible' }
      },
      // The 1/3 rule: overhang should not exceed 1/3 of total countertop depth
      maxOverhangRatio: 1/3,
      // Minimum support: 2/3 of countertop must be supported
      minSupportRatio: 2/3,
      // Edge profile durability ratings (1-5, 5 being most durable)
      edgeDurability: {
        'eased': { rating: 4, chipResistance: 'Good', notes: 'Versatile, good for all stone types' },
        'pencil': { rating: 4, chipResistance: 'Good', notes: 'Small radius, practical' },
        'quarter-round': { rating: 4, chipResistance: 'Good', notes: 'Larger radius than pencil' },
        'half-bullnose': { rating: 5, chipResistance: 'Excellent', notes: 'Most practical choice, extremely chip resistant' },
        'full-bullnose': { rating: 5, chipResistance: 'Excellent', notes: 'Nearly indestructible' },
        'quarter-bevel': { rating: 4, chipResistance: 'Good', notes: 'Resistant to wear' },
        'ogee': { rating: 2, chipResistance: 'Low', notes: 'Decorative but prone to chipping' },
        'double-ogee': { rating: 2, chipResistance: 'Low', notes: 'Very decorative, not for high-traffic' },
        'dupont': { rating: 3, chipResistance: 'Moderate', notes: 'Complex profile, moderate durability' },
        'cove': { rating: 3, chipResistance: 'Moderate', notes: 'Concave curve traps moisture' },
        'mitered': { rating: 4, chipResistance: 'Good', notes: 'Clean modern look' },
        'waterfall': { rating: 4, chipResistance: 'Good', notes: 'Mitered for waterfall applications' }
      },
      // Seam placement rules
      seams: {
        // Standard slab dimensions (in inches)
        maxSlabWidth: 120,  // 10 feet
        maxSlabDepth: 60,   // 5 feet
        // Jumbo slab dimensions
        jumboSlabWidth: 130,
        jumboSlabDepth: 68,
        // Minimum distances for seam placement
        minFromEdge: 6,     // Minimum 6" from countertop edge
        minFromSink: 4,     // Minimum 4" from sink/cooktop cutout
        minFromCorner: 6,   // Minimum 6" from inside corners
        // Seam visibility preference zones (percentage from edge)
        preferredZone: { min: 0.25, max: 0.75 }, // Middle 50% is preferred
        // Types of elements to avoid seaming over
        avoidOver: ['sink', 'sink-double', 'sink-farmhouse', 'cooktop', 'range']
      }
    };

    // Check overhang and return warnings/requirements
    function validateOverhang(overhangInches, thickness = '3cm', countertopDepthInches = 25) {
      const standards = FABRICATION_STANDARDS.overhang[thickness] || FABRICATION_STANDARDS.overhang['3cm'];
      const warnings = [];
      const requirements = [];

      // Check max unsupported overhang
      if (overhangInches > standards.maxUnsupported) {
        requirements.push(`Support brackets required (>${standards.maxUnsupported}" for ${thickness})`);
      }

      // Check bracket requirement threshold
      if (overhangInches > standards.bracketRequired) {
        requirements.push(`Heavy-duty brackets needed every 18-24"`);
      }

      // Check 1/3 rule
      const maxByRule = countertopDepthInches * FABRICATION_STANDARDS.maxOverhangRatio;
      if (overhangInches > maxByRule) {
        warnings.push(`Exceeds 1/3 rule (max ${maxByRule.toFixed(1)}" for ${countertopDepthInches}" depth)`);
      }

      // 2cm specific requirements
      if (thickness === '2cm' && standards.plywoodRequired) {
        requirements.push('Plywood underlayment required for 2cm stone');
      }

      // Seating depth checks
      if (overhangInches >= 12) {
        requirements.push('Ensure support brackets extend within 4" of edge');
      }
      if (overhangInches >= 15) {
        warnings.push('Consider leg supports or corbels for stability');
      }

      return { warnings, requirements, needsSupport: overhangInches > standards.maxUnsupported };
    }

    // Update countertop overhang (front, back, left, right)
    function updateOverhang() {
      const countertopTypes = ['countertop', 'countertop-corner', 'countertop-l', 'countertop-u', 'island'];
      if (!selectedElement || !countertopTypes.includes(selectedElement.type)) return;

      // Get new values in inches
      const frontIn = parseFloat(document.getElementById('propOverhangFront')?.value || 1.5);
      const backIn = parseFloat(document.getElementById('propOverhangBack')?.value || 0);
      const leftIn = parseFloat(document.getElementById('propOverhangLeft')?.value || 1.5);
      const rightIn = parseFloat(document.getElementById('propOverhangRight')?.value || 1.5);

      // Convert to feet
      const frontFt = frontIn / 12;
      const backFt = backIn / 12;
      const leftFt = leftIn / 12;
      const rightFt = rightIn / 12;

      // Get old overhang values (default to 2" front = 0.167ft if not set)
      const oldFront = selectedElement.overhangFront !== undefined ? selectedElement.overhangFront : 0.167;
      const oldBack = selectedElement.overhangBack !== undefined ? selectedElement.overhangBack : 0;
      const oldLeft = selectedElement.overhangLeft !== undefined ? selectedElement.overhangLeft : 0.125;
      const oldRight = selectedElement.overhangRight !== undefined ? selectedElement.overhangRight : 0.125;

      // Calculate the change in overhang
      const deltaFront = frontFt - oldFront;
      const deltaBack = backFt - oldBack;
      const deltaLeft = leftFt - oldLeft;
      const deltaRight = rightFt - oldRight;

      // Update countertop dimensions based on overhang changes
      // Width changes by left + right delta
      // Height (depth) changes by front + back delta
      selectedElement.width += (deltaLeft + deltaRight);
      selectedElement.height += (deltaFront + deltaBack);

      // Update position - move to account for left and back overhang changes
      // Left overhang increases = move countertop left (decrease x)
      // Back overhang increases = move countertop up (decrease y)
      selectedElement.x -= deltaLeft * pixelsPerFoot;
      selectedElement.y -= deltaBack * pixelsPerFoot;

      // Store new overhang values
      selectedElement.overhangFront = frontFt;
      selectedElement.overhangBack = backFt;
      selectedElement.overhangLeft = leftFt;
      selectedElement.overhangRight = rightFt;

      // Update dimension display in properties panel
      document.getElementById('propWidth').value = selectedElement.width.toFixed(4).replace(/\.?0+$/, '');
      document.getElementById('propHeight').value = selectedElement.height.toFixed(4).replace(/\.?0+$/, '');

      // Validate against fabrication standards
      const thickness = selectedElement.thickness || '3cm';
      const depthInches = selectedElement.height * 12;

      // Check largest overhang
      const maxOverhang = Math.max(frontIn, backIn, leftIn, rightIn);
      const validation = validateOverhang(maxOverhang, thickness, depthInches);

      // Store validation results on element
      selectedElement.needsBrackets = validation.needsSupport;
      selectedElement.fabricationNotes = [...validation.warnings, ...validation.requirements];

      // Update warning display in UI
      updateOverhangWarningDisplay(validation);

      // Clear preset selection if manually editing
      const presetSelect = document.getElementById('propOverhangPreset');
      if (presetSelect) presetSelect.value = '';

      draw();
      update3DScene();
      calculateQuote();
      saveUndoState();
    }

    // Apply overhang preset (Standard, Island, Bar, Breakfast Bar, ADA)
    function applyOverhangPreset() {
      const countertopTypes = ['countertop', 'countertop-corner', 'countertop-l', 'countertop-u', 'island'];
      if (!selectedElement || !countertopTypes.includes(selectedElement.type)) return;

      const preset = document.getElementById('propOverhangPreset')?.value;
      if (!preset) return;

      let front = 2, back = 0, left = 1.5, right = 1.5; // Default in inches - 2" front covers cabinet face
      let presetName = preset;

      switch(preset) {
        case 'standard':
          front = 2; back = 0; left = 1.5; right = 1.5;
          presetName = 'Standard (2" front)';
          break;
        case 'island':
          front = 2; back = 2; left = 2; right = 2;
          presetName = 'Island (2" all sides)';
          break;
        case 'bar':
          front = 12; back = 2; left = 1.5; right = 1.5;
          presetName = 'Bar Seating (12" front)';
          break;
        case 'breakfast':
          front = 15; back = 2; left = 1.5; right = 1.5;
          presetName = 'Breakfast Bar (15" front)';
          break;
        case 'ada':
          front = 19; back = 2; left = 1.5; right = 1.5;
          presetName = 'ADA Accessible (19" knee clearance)';
          break;
      }

      // Update input fields
      document.getElementById('propOverhangFront').value = front;
      document.getElementById('propOverhangBack').value = back;
      document.getElementById('propOverhangLeft').value = left;
      document.getElementById('propOverhangRight').value = right;

      // Convert to feet
      const frontFt = front / 12;
      const backFt = back / 12;
      const leftFt = left / 12;
      const rightFt = right / 12;

      // Get old overhang values (default to 2" front = 0.167ft if not set)
      const oldFront = selectedElement.overhangFront !== undefined ? selectedElement.overhangFront : 0.167;
      const oldBack = selectedElement.overhangBack !== undefined ? selectedElement.overhangBack : 0;
      const oldLeft = selectedElement.overhangLeft !== undefined ? selectedElement.overhangLeft : 0.125;
      const oldRight = selectedElement.overhangRight !== undefined ? selectedElement.overhangRight : 0.125;

      // Calculate deltas
      const deltaFront = frontFt - oldFront;
      const deltaBack = backFt - oldBack;
      const deltaLeft = leftFt - oldLeft;
      const deltaRight = rightFt - oldRight;

      // Resize countertop
      selectedElement.width += (deltaLeft + deltaRight);
      selectedElement.height += (deltaFront + deltaBack);

      // Reposition
      selectedElement.x -= deltaLeft * pixelsPerFoot;
      selectedElement.y -= deltaBack * pixelsPerFoot;

      // Store new overhang values
      selectedElement.overhangFront = frontFt;
      selectedElement.overhangBack = backFt;
      selectedElement.overhangLeft = leftFt;
      selectedElement.overhangRight = rightFt;

      // Update dimension display
      document.getElementById('propWidth').value = selectedElement.width.toFixed(4).replace(/\.?0+$/, '');
      document.getElementById('propHeight').value = selectedElement.height.toFixed(4).replace(/\.?0+$/, '');

      // Validate and show warnings
      const thickness = selectedElement.thickness || '3cm';
      const depthInches = selectedElement.height * 12;
      const maxOverhang = Math.max(front, back, left, right);
      const validation = validateOverhang(maxOverhang, thickness, depthInches);

      // Store validation results
      selectedElement.needsBrackets = validation.needsSupport;
      selectedElement.fabricationNotes = [...validation.warnings, ...validation.requirements];

      // Update warning display
      updateOverhangWarningDisplay(validation);

      draw();
      update3DScene();
      calculateQuote();
      saveUndoState();
      showSnapFeedback(`Overhang: ${presetName}`);
    }

    // Update the overhang warning display in the UI
    function updateOverhangWarningDisplay(validation) {
      const warningDiv = document.getElementById('overhangWarning');
      const warningText = document.getElementById('overhangWarningText');

      if (!warningDiv || !warningText) return;

      const allMessages = [...validation.requirements, ...validation.warnings];

      if (allMessages.length > 0) {
        warningDiv.style.display = 'block';
        warningText.innerHTML = allMessages.map(msg => ` ${msg}`).join('<br>');
      } else {
        warningDiv.style.display = 'none';
      }
    }

    // Add countertop on top of selected cabinet
    function addCountertopToCabinet() {
      if (!selectedElement) return;

      // Check if selected element is a cabinet type
      const cabinetTypes = ['base-cabinet', 'corner-cabinet', 'lazy-susan', 'drawer-base', 'sink-base', 'island'];
      if (!cabinetTypes.includes(selectedElement.type) && !selectedElement.type.startsWith('base-')) return;

      const cabinet = selectedElement;
      const cabX = cabinet.x;
      const cabY = cabinet.y;
      const cabinetDepth = cabinet.height || cabinet.depth || 2; // Cabinet depth in feet

      // Proper overhang: 2" front (covers cabinet face), 1.5" sides, 0" back (against wall)
      // For islands, use 2" on all sides so cabinet faces are recessed
      const isIsland = cabinet.type === 'island' || cabinet.type === 'base-cabinet' && cabinet.y > roomDepth * pixelsPerFoot * 0.3;

      const frontOverhang = 0.167; // 2 inches in feet - covers cabinet door faces
      const backOverhang = isIsland ? 0.167 : 0; // Islands get overhang all around, wall cabinets don't need back
      const sideOverhang = 0.125; // 1.5 inches in feet

      // Calculate countertop dimensions with proper overhang
      // Depth: cabinet depth + front overhang + back overhang
      const countertopDepth = cabinetDepth + frontOverhang + backOverhang;

      // Create countertop element that fits the cabinet with proper overhang
      const countertop = {
        id: generateId(),
        type: 'countertop',
        name: 'Countertop',
        x: cabX - (sideOverhang * pixelsPerFoot),
        y: cabY - (backOverhang * pixelsPerFoot),
        width: cabinet.width + (sideOverhang * 2),  // Add 1.5" each side = 3" total
        height: countertopDepth, // 2" front + cabinet depth (+ 2" back for islands)
        rotation: cabinet.rotation || 0,
        color: '#a0a0a0',
        roomId: currentRoom,
        edgeProfile: 'eased',
        thickness: '3cm',
        overhangFront: frontOverhang,
        overhangBack: backOverhang,
        overhangLeft: sideOverhang,
        overhangRight: sideOverhang
      };

      elements.push(countertop);
      selectedElement = countertop;

      draw();
      update3DScene();
      calculateQuote();
      updateProperties();
      showSnapFeedback(`Countertop added (${Math.round(countertopDepth * 12)}" deep with ${Math.round(frontOverhang * 12)}" front overhang)`);
    }

    // Update sink properties (color, mount type)
    function updateSinkProperties() {
      if (!selectedElement || !selectedElement.type.startsWith('sink')) return;

      const sinkColor = document.getElementById('propSinkColor').value;
      const mountType = document.getElementById('propSinkMount').value;

      selectedElement.sinkColor = sinkColor;
      selectedElement.mountType = mountType;

      // Update the element color for 2D view based on sink finish
      const sinkColors = {
        stainless: '#C0C0C0',
        black: '#2A2A2A',
        white: '#F5F5F5',
        graphite: '#4A4A4A',
        bisque: '#F5E6D3',
        bronze: '#5C4033'
      };
      selectedElement.color = sinkColors[sinkColor] || '#C0C0C0';

      draw();
      update3DScene();
      calculateQuote();

      const colorNames = {
        stainless: 'Stainless Steel',
        black: 'Matte Black',
        white: 'White',
        graphite: 'Graphite',
        bisque: 'Bisque',
        bronze: 'Oil-Rubbed Bronze'
      };
      showSnapFeedback(`Sink: ${colorNames[sinkColor]} / ${mountType}`);
    }

    // Add a seam to the selected countertop
    function addSeamToCountertop() {
      const countertopTypes = ['countertop', 'countertop-corner', 'countertop-l', 'countertop-u', 'island'];
      if (!selectedElement || !countertopTypes.includes(selectedElement.type)) return;

      // Initialize seams array if needed
      if (!selectedElement.seams) {
        selectedElement.seams = [];
      }

      // Calculate seam requirements to suggest optimal placement
      const requirements = calculateSeamRequirements(selectedElement);
      const existingCount = selectedElement.seams.length;
      let newPosition;

      // Use suggested positions if available, otherwise calculate
      if (requirements.suggestedPositions.length > existingCount) {
        newPosition = requirements.suggestedPositions[existingCount];
      } else if (existingCount === 0) {
        newPosition = 0.5; // Center
      } else {
        // Add at positions that avoid existing seams
        const existingPositions = selectedElement.seams.map(s => s.position);
        const candidates = [0.33, 0.67, 0.25, 0.75, 0.4, 0.6];
        newPosition = candidates.find(pos => {
          return !existingPositions.some(existing => Math.abs(existing - pos) < 0.1);
        }) || 0.5;
      }

      // Validate the seam placement
      const validation = validateSeamPlacement(selectedElement, newPosition);

      // If there are errors, try to find a better position
      if (!validation.isValid) {
        // Try alternative positions
        const alternatives = [0.5, 0.45, 0.55, 0.4, 0.6, 0.35, 0.65];
        for (const altPos of alternatives) {
          const altValidation = validateSeamPlacement(selectedElement, altPos);
          if (altValidation.isValid) {
            newPosition = altPos;
            validation.warnings = altValidation.warnings;
            validation.errors = [];
            break;
          }
        }
      }

      // Add the seam
      selectedElement.seams.push({
        position: newPosition,
        id: Date.now(),
        validation: { warnings: validation.warnings, errors: validation.errors }
      });

      // Sort seams by position
      selectedElement.seams.sort((a, b) => a.position - b.position);

      updateProperties();
      updateSeamUI();
      draw();
      update3DScene();

      // Show feedback with any warnings
      const posPercent = Math.round(newPosition * 100);
      const posInches = Math.round(newPosition * selectedElement.width * 12);
      if (validation.errors.length > 0) {
        showToast(` Seam at ${posInches}" (${posPercent}%): ${validation.errors[0]}`, 'warning', 4000);
      } else if (validation.warnings.length > 0) {
        showToast(`Seam at ${posInches}" (${posPercent}%) - Note: ${validation.warnings[0]}`, 'info', 3000);
      } else {
        showSnapFeedback(`Seam added at ${posInches}" (${posPercent}%)`);
      }
    }

    // Clear all seams from countertop
    function clearSeams() {
      const countertopTypes = ['countertop', 'countertop-corner', 'countertop-l', 'countertop-u', 'island'];
      if (!selectedElement || !countertopTypes.includes(selectedElement.type)) return;

      selectedElement.seams = [];
      updateProperties();
      updateSeamUI();
      draw();
      update3DScene();
      showSnapFeedback('All seams removed');
    }

    // Remove a specific seam
    function removeSeam(seamId) {
      if (!selectedElement || !selectedElement.seams) return;

      selectedElement.seams = selectedElement.seams.filter(s => s.id !== seamId);
      updateProperties();
      updateSeamUI();
      draw();
      update3DScene();
      showSnapFeedback('Seam removed');
    }

    // Seam placement mode state
    let seamPlacementMode = false;

    // Toggle interactive seam placement mode
    function toggleSeamPlacementMode() {
      const countertopTypes = ['countertop', 'countertop-corner', 'countertop-l', 'countertop-u', 'island'];
      if (!selectedElement || !countertopTypes.includes(selectedElement.type)) {
        showToast('Select a countertop first', 'warning', 2000);
        return;
      }

      seamPlacementMode = !seamPlacementMode;
      const btn = document.getElementById('seamPlaceModeBtn');

      if (seamPlacementMode) {
        btn.style.background = 'rgba(139, 92, 246, 0.8)';
        btn.textContent = ' Click Countertop...';
        showSnapFeedback('Click on countertop to place seam');
      } else {
        btn.style.background = 'rgba(139, 92, 246, 0.3)';
        btn.textContent = ' Click to Place';
      }
    }

    // Handle seam placement click on canvas
    function handleSeamPlacementClick(e) {
      if (!seamPlacementMode || !selectedElement) return false;

      const countertopTypes = ['countertop', 'countertop-corner', 'countertop-l', 'countertop-u', 'island'];
      if (!countertopTypes.includes(selectedElement.type)) return false;

      const rect = canvas.getBoundingClientRect();
      const mouseX = (e.clientX - rect.left - panOffset.x) / zoomLevel;
      const mouseY = (e.clientY - rect.top - panOffset.y) / zoomLevel;

      // Get countertop bounds
      const elX = selectedElement.x;
      const elY = selectedElement.y;
      const elW = selectedElement.width * pixelsPerFoot;
      const elH = selectedElement.height * pixelsPerFoot;

      // Check if click is within countertop
      if (mouseX >= elX && mouseX <= elX + elW &&
          mouseY >= elY && mouseY <= elY + elH) {

        // Calculate seam position as percentage along width
        const seamPosition = (mouseX - elX) / elW;

        // Validate placement
        const validation = validateSeamPlacement(selectedElement, seamPosition);

        // Initialize seams array if needed
        if (!selectedElement.seams) {
          selectedElement.seams = [];
        }

        // Add the seam
        selectedElement.seams.push({
          position: seamPosition,
          id: Date.now(),
          validation: { warnings: validation.warnings, errors: validation.errors }
        });

        // Sort seams by position
        selectedElement.seams.sort((a, b) => a.position - b.position);

        updateProperties();
        updateSeamUI();
        draw();
        update3DScene();

        const posInches = Math.round(seamPosition * selectedElement.width * 12);
        const posPercent = Math.round(seamPosition * 100);

        if (validation.errors.length > 0) {
          showToast(` Seam at ${posInches}" (${posPercent}%): ${validation.errors[0]}`, 'warning', 4000);
        } else {
          showSnapFeedback(`Seam placed at ${posInches}" (${posPercent}%)`);
        }

        return true; // Consumed the click
      }

      return false;
    }

    // Update seam UI with list and piece dimensions
    function updateSeamUI() {
      const countertopTypes = ['countertop', 'countertop-corner', 'countertop-l', 'countertop-u', 'island'];
      if (!selectedElement || !countertopTypes.includes(selectedElement.type)) return;

      const widthInches = selectedElement.width * 12;
      const depthInches = selectedElement.height * 12;
      const standards = FABRICATION_STANDARDS.seams;

      // Update countertop dimensions display
      const dimDisplay = document.getElementById('ctopDimensions');
      const statusDisplay = document.getElementById('ctopSeamStatus');
      if (dimDisplay) {
        dimDisplay.innerHTML = `<strong>${widthInches.toFixed(0)}"  ${depthInches.toFixed(0)}"</strong> (${(widthInches/12).toFixed(1)}'  ${(depthInches/12).toFixed(1)}')`;
      }

      // Determine if seams are needed
      const needsSeam = widthInches > standards.maxSlabWidth;
      if (statusDisplay) {
        if (needsSeam) {
          const minSeams = Math.ceil(widthInches / standards.maxSlabWidth) - 1;
          const currentSeams = selectedElement.seams?.length || 0;
          if (currentSeams >= minSeams) {
            statusDisplay.innerHTML = ' OK';
            statusDisplay.style.background = 'rgba(16, 185, 129, 0.3)';
            statusDisplay.style.color = '#6ee7b7';
          } else {
            statusDisplay.innerHTML = ` Need ${minSeams} seam${minSeams > 1 ? 's' : ''}`;
            statusDisplay.style.background = 'rgba(239, 68, 68, 0.3)';
            statusDisplay.style.color = '#fca5a5';
          }
        } else {
          statusDisplay.innerHTML = ' Fits slab';
          statusDisplay.style.background = 'rgba(16, 185, 129, 0.3)';
          statusDisplay.style.color = '#6ee7b7';
        }
      }

      // Update seam count
      const seamCount = document.getElementById('seamCount');
      const seams = selectedElement.seams || [];
      if (seamCount) {
        seamCount.textContent = `${seams.length} seam${seams.length !== 1 ? 's' : ''}`;
      }

      // Show seam requirement warning if needed
      const reqInfo = document.getElementById('seamRequirementInfo');
      const reqText = document.getElementById('seamRequirementText');
      if (reqInfo && reqText) {
        if (needsSeam && seams.length < Math.ceil(widthInches / standards.maxSlabWidth) - 1) {
          reqInfo.style.display = 'block';
          reqText.innerHTML = ` Countertop exceeds ${standards.maxSlabWidth}" max slab width. Seams required.`;
        } else {
          reqInfo.style.display = 'none';
        }
      }

      // Build seam list
      const seamListContainer = document.getElementById('seamListContainer');
      const seamList = document.getElementById('seamList');
      if (seamListContainer && seamList) {
        if (seams.length > 0) {
          seamListContainer.style.display = 'block';
          seamList.innerHTML = seams.map((seam, idx) => {
            const posInches = Math.round(seam.position * widthInches);
            const posPercent = Math.round(seam.position * 100);
            const hasWarning = seam.validation?.warnings?.length > 0;
            const hasError = seam.validation?.errors?.length > 0;

            return `
              <div style="display: flex; align-items: center; gap: 6px; padding: 4px 6px; background: rgba(255,255,255,0.05); border-radius: 4px;">
                <span style="color: #9ca3af; font-size: 10px; width: 20px;">#${idx + 1}</span>
                <input type="number" value="${posInches}" min="6" max="${widthInches - 6}" step="1"
                  onchange="updateSeamPosition(${seam.id}, this.value / ${widthInches})"
                  style="width: 50px; padding: 2px 4px; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); border-radius: 3px; color: #fff; font-size: 11px;">
                <span style="color: #9ca3af; font-size: 10px;">" (${posPercent}%)</span>
                ${hasError ? '<span style="color: #f87171;" title="' + (seam.validation.errors[0] || '') + '"></span>' : ''}
                ${hasWarning && !hasError ? '<span style="color: #fbbf24;" title="' + (seam.validation.warnings[0] || '') + '"></span>' : ''}
                <button onclick="removeSeam(${seam.id})" style="margin-left: auto; padding: 2px 6px; background: rgba(239, 68, 68, 0.2); border: none; border-radius: 3px; color: #f87171; cursor: pointer; font-size: 10px;"></button>
              </div>
            `;
          }).join('');
        } else {
          seamListContainer.style.display = 'none';
        }
      }

      // Calculate and display piece dimensions
      const piecesInfo = document.getElementById('pieceDimensionsInfo');
      const piecesList = document.getElementById('piecesList');
      if (piecesInfo && piecesList) {
        if (seams.length > 0) {
          piecesInfo.style.display = 'block';

          // Calculate piece widths
          const sortedPositions = [0, ...seams.map(s => s.position), 1].sort((a, b) => a - b);
          const pieces = [];

          for (let i = 0; i < sortedPositions.length - 1; i++) {
            const pieceWidthInches = (sortedPositions[i + 1] - sortedPositions[i]) * widthInches;
            const fitsStandard = pieceWidthInches <= standards.maxSlabWidth && depthInches <= standards.maxSlabDepth;
            const fitsJumbo = pieceWidthInches <= standards.jumboSlabWidth && depthInches <= standards.jumboSlabDepth;

            pieces.push({
              width: pieceWidthInches,
              depth: depthInches,
              fitsStandard,
              fitsJumbo,
              slabType: fitsStandard ? 'Standard' : (fitsJumbo ? 'Jumbo' : 'OVERSIZE')
            });
          }

          piecesList.innerHTML = pieces.map((p, i) => {
            const icon = p.fitsStandard ? '' : (p.fitsJumbo ? '' : '');
            const color = p.fitsStandard ? '#6ee7b7' : (p.fitsJumbo ? '#93c5fd' : '#f87171');
            return `<div style="color: ${color};">${icon} Piece ${i + 1}: <strong>${p.width.toFixed(0)}"  ${p.depth.toFixed(0)}"</strong> (${p.slabType})</div>`;
          }).join('');
        } else {
          piecesInfo.style.display = 'none';
        }
      }
    }

    // Update a specific seam position
    function updateSeamPosition(seamId, newPosition) {
      if (!selectedElement || !selectedElement.seams) return;

      const seam = selectedElement.seams.find(s => s.id === seamId);
      if (!seam) return;

      // Clamp position between 0.05 and 0.95
      newPosition = Math.max(0.05, Math.min(0.95, newPosition));

      // Re-validate
      const validation = validateSeamPlacement(selectedElement, newPosition);
      seam.position = newPosition;
      seam.validation = { warnings: validation.warnings, errors: validation.errors };

      // Re-sort seams
      selectedElement.seams.sort((a, b) => a.position - b.position);

      updateSeamUI();
      draw();
      update3DScene();
    }

    // Validate seam placement against fabrication standards
    function validateSeamPlacement(countertop, seamPosition) {
      const warnings = [];
      const errors = [];
      const standards = FABRICATION_STANDARDS.seams;

      const widthInches = countertop.width * 12;
      const seamPosInches = widthInches * seamPosition;

      // Check minimum distance from edges
      const distFromLeft = seamPosInches;
      const distFromRight = widthInches - seamPosInches;

      if (distFromLeft < standards.minFromEdge) {
        errors.push(`Seam too close to left edge (${distFromLeft.toFixed(1)}" < ${standards.minFromEdge}" min)`);
      }
      if (distFromRight < standards.minFromEdge) {
        errors.push(`Seam too close to right edge (${distFromRight.toFixed(1)}" < ${standards.minFromEdge}" min)`);
      }

      // Check if seam is in preferred visibility zone
      if (seamPosition < standards.preferredZone.min || seamPosition > standards.preferredZone.max) {
        warnings.push('Seam placement outside preferred zone (middle 50% is optimal)');
      }

      // Check for elements placed on this countertop that the seam might cross
      const countertopBounds = {
        left: countertop.x / pixelsPerFoot,
        right: (countertop.x / pixelsPerFoot) + countertop.width,
        top: countertop.y / pixelsPerFoot,
        bottom: (countertop.y / pixelsPerFoot) + countertop.height
      };
      const seamXFeet = countertopBounds.left + (countertop.width * seamPosition);

      elements.forEach(el => {
        if (el === countertop) return;
        if (!standards.avoidOver.includes(el.type)) return;

        const elLeft = el.x / pixelsPerFoot;
        const elRight = elLeft + el.width;
        const elTop = el.y / pixelsPerFoot;
        const elBottom = elTop + el.height;

        // Check if element overlaps with countertop
        const overlapsCountertop = !(elRight < countertopBounds.left ||
                                     elLeft > countertopBounds.right ||
                                     elBottom < countertopBounds.top ||
                                     elTop > countertopBounds.bottom);

        if (overlapsCountertop) {
          // Check if seam passes through this element
          const seamBuffer = standards.minFromSink / 12; // Convert to feet
          if (seamXFeet >= (elLeft - seamBuffer) && seamXFeet <= (elRight + seamBuffer)) {
            errors.push(`Seam crosses over ${el.type.replace(/-/g, ' ')} - water infiltration risk`);
          }
        }
      });

      return {
        warnings,
        errors,
        isValid: errors.length === 0,
        seamPosition
      };
    }

    // Calculate if countertop needs seams based on slab dimensions
    function calculateSeamRequirements(countertop) {
      const standards = FABRICATION_STANDARDS.seams;
      const widthInches = countertop.width * 12;
      const depthInches = countertop.height * 12;

      const requirements = {
        needsSeam: false,
        reason: '',
        suggestedPositions: [],
        minSeams: 0
      };

      // Check if width exceeds max slab width
      if (widthInches > standards.maxSlabWidth) {
        requirements.needsSeam = true;
        requirements.reason = `Width (${widthInches.toFixed(0)}") exceeds max slab width (${standards.maxSlabWidth}")`;

        // Calculate minimum number of seams needed
        requirements.minSeams = Math.ceil(widthInches / standards.maxSlabWidth) - 1;

        // Suggest evenly distributed seam positions
        for (let i = 1; i <= requirements.minSeams; i++) {
          const pos = i / (requirements.minSeams + 1);
          requirements.suggestedPositions.push(pos);
        }
      }

      // Check if depth exceeds max slab depth (would need to reorient slab)
      if (depthInches > standards.maxSlabDepth && !requirements.needsSeam) {
        if (widthInches <= standards.maxSlabDepth) {
          // Can rotate slab - depth becomes width
          requirements.reason = 'Slab will be oriented lengthwise for depth';
        } else if (depthInches > standards.jumboSlabDepth) {
          requirements.needsSeam = true;
          requirements.reason = `Depth (${depthInches.toFixed(0)}") exceeds jumbo slab depth (${standards.jumboSlabDepth}")`;
        }
      }

      return requirements;
    }

    // Show seam requirement notification
    function showSeamRequirementCheck() {
      if (!selectedElement) return;

      const countertopTypes = ['countertop', 'countertop-corner', 'countertop-l', 'countertop-u', 'island'];
      if (!countertopTypes.includes(selectedElement.type)) return;

      const req = calculateSeamRequirements(selectedElement);
      const currentSeams = selectedElement.seams?.length || 0;

      if (req.needsSeam && currentSeams < req.minSeams) {
        showToast(` ${req.reason}. Need at least ${req.minSeams} seam${req.minSeams > 1 ? 's' : ''}.`, 'warning', 5000);
      } else if (!req.needsSeam && currentSeams === 0) {
        showToast(' Countertop fits within standard slab dimensions - no seam required', 'success', 3000);
      }
    }

    // Get standard sizes for element type
    function getStandardSizesForType(type) {
      const sizes = [];

      switch (type) {
        case 'door':
          sizes.push({ label: '2\'-8" (32")', width: 2.667, height: 0.5 });
          sizes.push({ label: '3\'-0" (36")', width: 3, height: 0.5 });
          sizes.push({ label: '2\'-6" (30")', width: 2.5, height: 0.5 });
          break;
        case 'double-door':
          sizes.push({ label: '5\'-0" (60")', width: 5, height: 0.5 });
          sizes.push({ label: '6\'-0" (72")', width: 6, height: 0.5 });
          break;
        case 'sliding-door':
          sizes.push({ label: '6\'-0" (72")', width: 6, height: 0.5 });
          sizes.push({ label: '8\'-0" (96")', width: 8, height: 0.5 });
          sizes.push({ label: '9\'-0" (108")', width: 9, height: 0.5 });
          break;
        case 'entry-archway':
          sizes.push({ label: '3\'-0" (36")', width: 3, height: 0.5 });
          sizes.push({ label: '4\'-0" (48")', width: 4, height: 0.5 });
          sizes.push({ label: '5\'-0" (60")', width: 5, height: 0.5 });
          break;
        case 'garage-door':
          sizes.push({ label: '8\' Single', width: 8, height: 0.5 });
          sizes.push({ label: '9\' Single', width: 9, height: 0.5 });
          sizes.push({ label: '16\' Double', width: 16, height: 0.5 });
          sizes.push({ label: '18\' Double', width: 18, height: 0.5 });
          break;
        case 'window':
          sizes.push({ label: '2\'-0"  3\'-0"', width: 2, height: 0.5 });
          sizes.push({ label: '3\'-0"  4\'-0"', width: 3, height: 0.5 });
          sizes.push({ label: '4\'-0"  5\'-0"', width: 4, height: 0.5 });
          sizes.push({ label: '6\'-0" Picture', width: 6, height: 0.5 });
          break;
        case 'base-cabinet':
          sizes.push({ label: '12" Base', width: 1, height: 2 });
          sizes.push({ label: '15" Base', width: 1.25, height: 2 });
          sizes.push({ label: '18" Base', width: 1.5, height: 2 });
          sizes.push({ label: '24" Base', width: 2, height: 2 });
          sizes.push({ label: '30" Base', width: 2.5, height: 2 });
          sizes.push({ label: '36" Base', width: 3, height: 2 });
          break;
        case 'drawer-base':
          sizes.push({ label: '12" Drawer', width: 1, height: 2 });
          sizes.push({ label: '15" Drawer', width: 1.25, height: 2 });
          sizes.push({ label: '18" Drawer', width: 1.5, height: 2 });
          sizes.push({ label: '24" Drawer', width: 2, height: 2 });
          sizes.push({ label: '30" Drawer', width: 2.5, height: 2 });
          sizes.push({ label: '36" Drawer', width: 3, height: 2 });
          break;
        case 'sink-base':
          sizes.push({ label: '30" Sink Base', width: 2.5, height: 2 });
          sizes.push({ label: '33" Sink Base', width: 2.75, height: 2 });
          sizes.push({ label: '36" Sink Base', width: 3, height: 2 });
          sizes.push({ label: '42" Sink Base', width: 3.5, height: 2 });
          break;
        case 'corner-cabinet':
        case 'lazy-susan':
          sizes.push({ label: '33" Corner', width: 2.75, height: 2.75 });
          sizes.push({ label: '36" Corner', width: 3, height: 3 });
          sizes.push({ label: '39" Corner', width: 3.25, height: 3.25 });
          break;
        case 'wall-cabinet':
          sizes.push({ label: '12" Wall', width: 1, height: 1 });
          sizes.push({ label: '18" Wall', width: 1.5, height: 1 });
          sizes.push({ label: '24" Wall', width: 2, height: 1 });
          sizes.push({ label: '30" Wall', width: 2.5, height: 1 });
          sizes.push({ label: '36" Wall', width: 3, height: 1 });
          break;
        case 'tall-cabinet':
          sizes.push({ label: '18" Pantry', width: 1.5, height: 2 });
          sizes.push({ label: '24" Pantry', width: 2, height: 2 });
          sizes.push({ label: '36" Pantry', width: 3, height: 2 });
          break;
        case 'fridge-cabinet':
          sizes.push({ label: '30" Fridge Cabinet', width: 2.5, height: 7 });
          sizes.push({ label: '36" Fridge Cabinet', width: 3, height: 7 });
          sizes.push({ label: '42" Fridge Cabinet', width: 3.5, height: 7 });
          break;
        case 'island':
          sizes.push({ label: '4\'  2\' Small', width: 4, height: 2 });
          sizes.push({ label: '5\'  3\' Medium', width: 5, height: 3 });
          sizes.push({ label: '6\'  3\' Large', width: 6, height: 3 });
          sizes.push({ label: '8\'  4\' XL', width: 8, height: 4 });
          break;
        case 'countertop':
          sizes.push({ label: '25" Depth Std', width: 3, height: 2.083 });
          sizes.push({ label: '30" Depth Deep', width: 3, height: 2.5 });
          break;
        case 'sink':
          sizes.push({ label: '25" Single', width: 2.083, height: 1.83 });
          sizes.push({ label: '30" Single', width: 2.5, height: 1.83 });
          sizes.push({ label: '33" Single', width: 2.75, height: 1.83 });
          break;
        case 'sink-double':
          sizes.push({ label: '33" Double', width: 2.75, height: 1.83 });
          sizes.push({ label: '36" Double', width: 3, height: 1.83 });
          sizes.push({ label: '42" Double', width: 3.5, height: 1.83 });
          break;
        case 'sink-farmhouse':
          sizes.push({ label: '30" Farmhouse', width: 2.5, height: 1.75 });
          sizes.push({ label: '33" Farmhouse', width: 2.75, height: 1.75 });
          sizes.push({ label: '36" Farmhouse', width: 3, height: 1.75 });
          break;
        case 'stove':
        case 'range':
          sizes.push({ label: '30" Range', width: 2.5, height: 2.25 });
          sizes.push({ label: '36" Pro Range', width: 3, height: 2.25 });
          sizes.push({ label: '48" Pro Range', width: 4, height: 2.5 });
          break;
        case 'refrigerator':
          sizes.push({ label: '30" Standard', width: 2.5, height: 2.5 });
          sizes.push({ label: '36" Wide', width: 3, height: 2.75 });
          sizes.push({ label: '42" Built-in', width: 3.5, height: 2 });
          break;
        case 'dishwasher':
          sizes.push({ label: '24" Standard', width: 2, height: 2 });
          sizes.push({ label: '18" Compact', width: 1.5, height: 2 });
          break;
      }

      return sizes;
    }

    // ===== MATERIALS =====
    function openMaterialPicker() {
      if (!selectedElement) return;

      const modal = document.getElementById('materialModal');
      modal.style.display = ''; // Reset any inline display style
      modal.classList.add('active');
      renderMaterialCategories();
      renderModalMaterials('granite');
    }

    function renderMaterialCategories() {
      const container = document.getElementById('materialCategories');
      container.innerHTML = Object.keys(MATERIALS).map(cat => `
        <button class="material-category-btn ${cat === 'granite' ? 'active' : ''}"
                onclick="renderModalMaterials('${cat}', this)">
          ${cat.charAt(0).toUpperCase() + cat.slice(1)}
        </button>
      `).join('') + `
        <button class="material-category-btn" onclick="renderModalMaterials('custom', this)">
          My Uploads
        </button>
      `;
    }

    function renderModalMaterials(category, btn) {
      document.querySelectorAll('.material-category-btn').forEach(b => b.classList.remove('active'));
      if (btn) btn.classList.add('active');

      const container = document.getElementById('materialsGrid');

      if (category === 'custom') {
        container.innerHTML = `
          <div class="upload-material-btn" onclick="document.getElementById('materialUpload').click()">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
              <polyline points="17 8 12 3 7 8"/>
              <line x1="12" y1="3" x2="12" y2="15"/>
            </svg>
            <span>Upload</span>
          </div>
          ${customMaterials.map(m => `
            <div class="material-modal-item"
                 style="background: url(${m.url}) center/cover"
                 onclick="applyMaterial('${m.url}')">
              <div class="material-name">${m.name}</div>
            </div>
          `).join('')}
        `;
      } else {
        const materials = MATERIALS[category] || [];
        const canShowPrice = PRICING_ACCESS.canViewPricing;
        container.innerHTML = `
          <div class="upload-material-btn" onclick="document.getElementById('materialUpload').click()">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
              <polyline points="17 8 12 3 7 8"/>
              <line x1="12" y1="3" x2="12" y2="15"/>
            </svg>
            <span>Upload</span>
          </div>
          ${materials.map(m => {
            const priceTier = getMaterialPriceTier(m.price);
            const tierInfo = priceTier ? PRICE_TIERS[priceTier] : null;
            const bgUrl = m.url ? getProxiedUrl(m.url) : null;
            return `
            <div class="material-modal-item ${m.brand === 'Daltile' || m.brand?.includes('Daltile') ? 'daltile-material' : ''}"
                 style="background: ${bgUrl ? `url(${bgUrl})` : m.color} center/cover"
                 onclick="applyMaterial('${m.url || m.color}', '${m.color}')"
                 data-sku="${m.sku || ''}"
                 data-price="${canShowPrice && m.price ? m.price : ''}">
              ${canShowPrice && m.price ? `<div class="material-price" style="background: ${tierInfo?.color || '#666'}">$${m.price.toFixed(2)}/sf</div>` : ''}
              ${m.brand ? `<div class="material-brand">${m.brand}</div>` : ''}
              <div class="material-name">${m.name}</div>
            </div>
          `}).join('')}
        `;
      }
    }

    function applyMaterial(urlOrColor, fallbackColor) {
      if (!selectedElement) return;

      // Check if it's a URL (http, data:, or relative path like /images/)
      const isUrl = urlOrColor.startsWith('http') || urlOrColor.startsWith('data:') || urlOrColor.startsWith('/');
      if (isUrl) {
        selectedElement.texture = urlOrColor;
        const img = new Image();
        img.crossOrigin = 'anonymous';

        // Use proxied URL for MSI images to handle CORS
        const finalUrl = getProxiedUrl(urlOrColor);

        img.onload = () => {
          selectedElement.textureImg = img;
          draw();
          render3D(); // Update 3D view as well
          updateProperties();
        };
        img.onerror = () => {
          // Fall back to color
          console.log('Image failed to load:', urlOrColor);
          selectedElement.texture = null;
          selectedElement.color = fallbackColor || '#888';
          draw();
          render3D(); // Update 3D view as well
        };
        img.src = finalUrl;
      } else {
        selectedElement.texture = null;
        selectedElement.textureImg = null;
        selectedElement.color = urlOrColor;
        draw();
        render3D(); // Update 3D view as well
        updateProperties();
      }

      closeModal('materialModal');
    }

    // ===== IMAGE OPTIMIZATION UTILITIES =====

    /**
     * Optimize an image for texture use - resizes large images and compresses
     * @param {File|Blob|string} source - Image file, blob, or data URL
     * @param {Object} options - Optimization options
     * @returns {Promise<{url: string, width: number, height: number}>}
     */
    async function optimizeImageForTexture(source, options = {}) {
      const {
        maxWidth = 2048,
        maxHeight = 2048,
        quality = 0.85,
        format = 'image/jpeg' // jpeg for photos, png for graphics
      } = options;

      return new Promise((resolve, reject) => {
        const img = new Image();
        img.crossOrigin = 'anonymous';

        img.onload = () => {
          let { width, height } = img;
          let needsResize = false;

          // Calculate new dimensions if image is too large
          if (width > maxWidth || height > maxHeight) {
            const ratio = Math.min(maxWidth / width, maxHeight / height);
            width = Math.round(width * ratio);
            height = Math.round(height * ratio);
            needsResize = true;
          }

          // Check if we need to process (resize or compress)
          const shouldProcess = needsResize ||
            (typeof source === 'string' && source.startsWith('data:') && source.length > 500000);

          if (!shouldProcess && typeof source === 'string') {
            // Image is small enough, return as-is
            resolve({ url: source, width: img.width, height: img.height, optimized: false });
            return;
          }

          // Create canvas for resizing/compression
          const canvas = document.createElement('canvas');
          canvas.width = width;
          canvas.height = height;
          const ctx = canvas.getContext('2d');

          // Use high-quality image smoothing
          ctx.imageSmoothingEnabled = true;
          ctx.imageSmoothingQuality = 'high';

          // Draw image onto canvas
          ctx.drawImage(img, 0, 0, width, height);

          // Convert to optimized data URL
          const optimizedUrl = canvas.toDataURL(format, quality);

          resolve({
            url: optimizedUrl,
            width,
            height,
            optimized: true,
            originalSize: typeof source === 'string' ? source.length : 0,
            optimizedSize: optimizedUrl.length
          });
        };

        img.onerror = () => {
          reject(new Error('Failed to load image for optimization'));
        };

        // Load image from source
        if (source instanceof File || source instanceof Blob) {
          const reader = new FileReader();
          reader.onload = (e) => { img.src = e.target.result; };
          reader.onerror = () => reject(new Error('Failed to read image file'));
          reader.readAsDataURL(source);
        } else if (typeof source === 'string') {
          img.src = source;
        } else {
          reject(new Error('Invalid image source'));
        }
      });
    }

    /**
     * Optimize multiple images in parallel with progress callback
     */
    async function optimizeImages(files, options = {}, onProgress = null) {
      const results = [];
      let completed = 0;

      for (const file of files) {
        try {
          const result = await optimizeImageForTexture(file, options);
          results.push({ success: true, ...result, name: file.name });
        } catch (err) {
          results.push({ success: false, error: err.message, name: file.name });
        }
        completed++;
        if (onProgress) onProgress(completed, files.length);
      }

      return results;
    }

    // Quick upload texture directly from properties panel
    function quickUploadTexture() {
      if (!selectedElement) {
        alert('Please select an element first');
        return;
      }

      const input = document.createElement('input');
      input.type = 'file';
      input.accept = 'image/*';
      input.onchange = async (e) => {
        const file = e.target.files[0];
        if (!file) return;

        try {
          // Show loading indicator
          if (typeof showToast === 'function') {
            showToast('Optimizing image...', 'info');
          }

          // Optimize image before storing (resize if too large, compress)
          const result = await optimizeImageForTexture(file, {
            maxWidth: 2048,
            maxHeight: 2048,
            quality: 0.85,
            format: file.type === 'image/png' ? 'image/png' : 'image/jpeg'
          });

          const url = result.url;

          // Log optimization results for debugging
          if (result.optimized) {
            const savings = result.originalSize > 0 ?
              Math.round((1 - result.optimizedSize / result.originalSize) * 100) : 0;
            console.log(`Image optimized: ${result.width}x${result.height}, saved ${savings}%`);
          }

          // Save to custom materials
          customMaterials.push({
            id: Date.now(),
            name: file.name.split('.')[0],
            url: url
          });

          // Apply to selected element
          selectedElement.texture = url;
          selectedElement.materialName = file.name.split('.')[0];

          const img = new Image();
          img.onload = () => {
            selectedElement.textureImg = img;
            draw();
            updateProperties();
            if (typeof showToast === 'function') {
              showToast('Texture applied successfully', 'success');
            }
          };
          img.src = url;
        } catch (err) {
          console.error('Failed to optimize image:', err);
          if (typeof showToast === 'function') {
            showToast('Failed to load image', 'error');
          }
        }
      };
      input.click();
    }

    // Clear texture from selected element
    function clearTexture() {
      if (!selectedElement) return;

      selectedElement.texture = null;
      selectedElement.textureImg = null;
      selectedElement.materialName = null;
      selectedElement.materialId = null;
      draw();
      updateProperties();
    }

    async function handleMaterialUpload(e) {
      const file = e.target.files[0];
      if (!file) return;

      try {
        // Optimize the uploaded image
        const result = await optimizeImageForTexture(file, {
          maxWidth: 2048,
          maxHeight: 2048,
          quality: 0.85,
          format: file.type === 'image/png' ? 'image/png' : 'image/jpeg'
        });

        const url = result.url;
        const name = file.name.split('.')[0];

        customMaterials.push({ id: Date.now(), name, url });

        if (selectedElement) {
          applyMaterial(url);
        }
      } catch (err) {
        console.error('Failed to process material upload:', err);
        if (typeof showToast === 'function') {
          showToast('Failed to upload material', 'error');
        }
      }
      e.target.value = '';
    }

    function uploadElementTexture(type) {
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = 'image/*';
      input.onchange = async (e) => {
        const file = e.target.files[0];
        if (!file) return;

        try {
          // Optimize the uploaded image
          const result = await optimizeImageForTexture(file, {
            maxWidth: 1024, // Smaller for element textures in sidebar
            maxHeight: 1024,
            quality: 0.8,
            format: file.type === 'image/png' ? 'image/png' : 'image/jpeg'
          });

          elementTextures[type] = result.url;
          renderSidebar();
        } catch (err) {
          console.error('Failed to upload element texture:', err);
        }
      };
      input.click();
    }

    // ===== PRICING FUNCTIONS =====

    // Calculate total quote from all elements
    function calculateQuoteTotal() {
      // Use cached value if available and recent
      if (window.currentQuoteTotal !== undefined && window.currentQuoteTotal > 0) {
        return window.currentQuoteTotal;
      }

      let total = 0;
      elements.forEach(el => {
        const priceInfo = getElementPrice(el);
        const margin = getElementMargin(el) || 30;
        let cost = priceInfo?.price || 0;

        // Area-based items (countertops, flooring, etc.)
        if (['countertop', 'backsplash', 'flooring', 'tile'].includes(el.type)) {
          cost = (el.width || 1) * (el.height || 1) * cost;
        }

        // Add margin to get retail price
        total += cost * (1 + margin / 100);
      });

      window.currentQuoteTotal = total;
      return total;
    }

    // Get effective price for an element (priority: override -> catalog -> material -> custom -> default)
    function getElementPrice(element) {
      // 1) Manual override takes highest priority
      if (element.priceOverride !== null && element.priceOverride !== undefined) {
        return { price: element.priceOverride, source: 'override' };
      }

      // 2) Check for cabinet catalog pricing (by SKU)
      if (element.sku && element.catalog) {
        const catalog = CABINET_CATALOGS[element.catalog];
        if (catalog) {
          for (const category of Object.values(catalog.cabinets)) {
            const cab = category.find(c => c.sku === element.sku);
            if (cab && cab.price) {
              return { price: cab.price, source: 'catalog' };
            }
          }
        }
      }

      // 3) Check for material-specific pricing
      if (element.materialId) {
        for (const category in MATERIALS) {
          const mat = MATERIALS[category].find(m => m.id === element.materialId);
          if (mat && mat.price) {
            return { price: mat.price, source: 'material' };
          }
        }
      }

      // 4) Check custom prices from Excel import
      if (element.materialId && PRICING_STATE.customPrices[element.materialId]) {
        return { price: PRICING_STATE.customPrices[element.materialId], source: 'pricelist' };
      }

      // 5) Fall back to default type pricing
      return { price: CONFIG.PRICING[element.type] || 0, source: 'default' };
    }

    // Get element category for margin lookup (pricing-specific categories)
    function getElementMarginCategory(type) {
      if (type.includes('cabinet') || type === 'island') return 'cabinet';
      if (['countertop', 'backsplash'].includes(type)) return 'countertop';
      if (['flooring', 'tile'].includes(type)) return 'flooring';
      if (['stove', 'refrigerator', 'dishwasher', 'microwave', 'oven', 'range-hood', 'sink'].includes(type)) return 'appliance';
      return 'other';
    }

    // Get effective margin for an element (priority: item -> category -> global)
    function getElementMargin(element) {
      // 1) Per-item margin override
      if (element.marginPercent !== null && element.marginPercent !== undefined) {
        return element.marginPercent;
      }

      // 2) Category-specific margin
      const category = getElementMarginCategory(element.type);
      if (PRICING_STATE.categoryMargins && PRICING_STATE.categoryMargins[category] !== undefined) {
        return PRICING_STATE.categoryMargins[category];
      }

      // 3) Global default margin
      return PRICING_STATE.globalMargin;
    }

    // Get material name from ID
    function getMaterialName(materialId) {
      if (!materialId) return null;
      for (const category in MATERIALS) {
        const mat = MATERIALS[category].find(m => m.id === materialId);
        if (mat) return mat.name;
      }
      return null;
    }

    // Update element price from properties panel
    function updateElementPrice() {
      if (!selectedElement) return;

      const overrideInput = document.getElementById('propPriceOverride');
      const unitSelect = document.getElementById('propPriceUnit');
      const marginInput = document.getElementById('propMargin');

      const override = overrideInput && overrideInput.value ? parseFloat(overrideInput.value) : null;
      const unit = unitSelect ? unitSelect.value : 'sqft';
      const margin = marginInput && marginInput.value ? parseFloat(marginInput.value) : null;

      selectedElement.priceOverride = override;
      selectedElement.priceUnit = unit;
      selectedElement.marginPercent = margin;

      calculateQuote();
      updatePricingDisplay();
    }

    // Update pricing display in properties panel
    function updatePricingDisplay() {
      if (!selectedElement) return;

      const priceInfo = getElementPrice(selectedElement);
      const margin = getElementMargin(selectedElement);

      document.getElementById('propBasePrice').textContent = '$' + priceInfo.price.toFixed(2);

      // Calculate item total
      let quantity = 1;
      if (['countertop', 'backsplash', 'flooring', 'tile'].includes(selectedElement.type)) {
        quantity = selectedElement.width * selectedElement.height;
      }

      const cost = priceInfo.price * quantity;
      const retail = cost * (1 + margin / 100);

      document.getElementById('propItemTotal').textContent = '$' + retail.toFixed(2);
    }

    // Check if action is allowed based on permissions
    function checkPermission(action) {
      // For pricing-related actions, also check subscription status
      if (action === 'canViewPrices' || action === 'canViewCosts') {
        // If user doesn't have subscription access to pricing, deny regardless of share permissions
        if (!PRICING_ACCESS.canViewPricing) return false;
      }

      // For shared views, check share permissions
      if (!SHARE_STATE.isSharedView) return true;
      // Deny by default if allowedActions not set (secure default)
      if (!SHARE_STATE.allowedActions) return false;
      return SHARE_STATE.allowedActions[action] === true;
    }

    // Toggle between cost and retail view
    function setQuoteView(view) {
      PRICING_STATE.showCostView = (view === 'cost');
      document.getElementById('retailViewBtn').classList.toggle('active', view === 'retail');
      document.getElementById('costViewBtn').classList.toggle('active', view === 'cost');
      calculateQuote();
    }

    // ===== CABINET RUN BREAKDOWN HELPER =====
    // Break down a cabinet run into individual standard-size cabinets + fillers
    function breakdownCabinetRun(widthFt, cabinetType, unitPrice) {
      const widthInches = widthFt * 12;
      const standards = TAKEOFF_STANDARDS.cabinet;
      const standardWidths = standards.standardWidths; // [9, 12, 15, 18, 21, 24, 27, 30, 33, 36]

      // Results
      const result = {
        cabinets: [],        // Array of { width, count, price }
        fillers: [],         // Array of { width, count, price }
        toeKick: { lengthLF: 0, price: 0 },
        scribe: { lengthLF: 0, price: 0 },
        totalCabinets: 0,
        totalFillers: 0,
        summary: ''
      };

      // Find optimal cabinet combination to fill the width
      let remaining = widthInches;
      const cabinetCounts = {};

      // Greedy algorithm: use largest cabinets first
      const sortedWidths = [...standardWidths].sort((a, b) => b - a);

      for (const cabWidth of sortedWidths) {
        if (remaining >= cabWidth) {
          const count = Math.floor(remaining / cabWidth);
          if (count > 0) {
            cabinetCounts[cabWidth] = count;
            remaining -= count * cabWidth;
          }
        }
      }

      // Handle remaining space
      if (remaining > 0) {
        if (remaining >= standards.filler.minWidth && remaining <= standards.filler.maxWidth) {
          // Small gap - use filler
          result.fillers.push({
            width: remaining,
            count: 1,
            price: (remaining / 12) * standards.filler.pricePerLF * (standards.baseHeight / 12)
          });
          result.totalFillers++;
        } else if (remaining > standards.filler.maxWidth) {
          // Larger gap - try to use smallest standard cabinet + filler
          const smallestCab = Math.min(...standardWidths);
          if (remaining >= smallestCab) {
            cabinetCounts[smallestCab] = (cabinetCounts[smallestCab] || 0) + 1;
            remaining -= smallestCab;
            if (remaining >= standards.filler.minWidth) {
              result.fillers.push({
                width: remaining,
                count: 1,
                price: (remaining / 12) * standards.filler.pricePerLF * (standards.baseHeight / 12)
              });
              result.totalFillers++;
            }
          }
        }
        // Very small remainder (< 1.5") - absorbed as acceptable gap
      }

      // Convert counts to result array with prices
      for (const [width, count] of Object.entries(cabinetCounts)) {
        const widthNum = parseInt(width);
        // Price scales roughly with width (using a simple scaling from unit price)
        const scaledPrice = unitPrice * (widthNum / 30); // 30" as baseline
        result.cabinets.push({
          width: widthNum,
          count: count,
          priceEach: scaledPrice,
          priceTotal: scaledPrice * count
        });
        result.totalCabinets += count;
      }

      // Calculate toe kick (runs full length of cabinet run)
      result.toeKick.lengthLF = widthFt;
      result.toeKick.price = widthFt * standards.toeKick.pricePerLF;

      // Build summary string
      const cabinetSummary = result.cabinets
        .sort((a, b) => b.width - a.width)
        .map(c => `${c.count}x ${c.width}"`)
        .join(' + ');
      const fillerSummary = result.fillers.length > 0
        ? ` + ${result.fillers.map(f => `${f.width.toFixed(1)}" filler`).join(', ')}`
        : '';
      result.summary = cabinetSummary + fillerSummary;

      return result;
    }

    // ===== SLAB CALCULATION HELPER =====
    // Calculate how many slabs needed for countertop area
    function calculateSlabRequirement(totalSqft) {
      const slabStandards = TAKEOFF_STANDARDS.slab;
      const grossSqft = totalSqft * (1 + slabStandards.wastePercent / 100);

      // Try standard slab first (most common)
      const standardSlab = slabStandards.standardSizes.find(s => s.name === 'Standard Slab');
      const slabSqft = standardSlab?.sqft || 45.8;

      const slabsNeeded = Math.ceil(grossSqft / slabSqft);

      return {
        netSqft: totalSqft,
        grossSqft: grossSqft,
        wastePercent: slabStandards.wastePercent,
        slabsNeeded: slabsNeeded,
        slabSize: standardSlab?.name || 'Standard Slab',
        slabSqft: slabSqft
      };
    }

    // ===== QUOTE (Enhanced with Full Element Support) =====
    function calculateQuote() {
      const items = {};
      let totalCost = 0;
      let totalRetail = 0;

      // Filler pricing (per linear foot)
      const FILLER_PRICE_PER_LF = 25;
      const MIN_FILLER_WIDTH = 0.125; // 1.5" minimum

      // All countertop types (sqft pricing)
      const COUNTERTOP_TYPES = ['countertop', 'countertop-corner', 'countertop-l', 'countertop-u', 'island'];
      const SQFT_TYPES = [...COUNTERTOP_TYPES, 'backsplash', 'flooring', 'tile'];

      // All cabinet types
      const CABINET_TYPES = [
        'base-cabinet', 'wall-cabinet', 'tall-cabinet', 'corner-cabinet',
        'sink-base', 'drawer-base', 'lazy-susan', 'fridge-cabinet',
        'pantry', 'blind-corner', 'microwave-cabinet'
      ];

      // Helper to check if type is a cabinet
      function isCabinetType(type) {
        return CABINET_TYPES.some(ct => type.includes(ct) || type === ct);
      }

      // Process each element
      elements.forEach(el => {
        const priceInfo = getElementPrice(el);
        const margin = getElementMargin(el);

        let baseCost = 0;
        let quantity = 1;
        let unit = el.priceUnit || 'unit';
        let fillerCost = 0;
        let fillerWidth = 0;
        let boxCount = 1;
        let sqft = 0;

        // Determine pricing method based on element type
        const isCountertop = COUNTERTOP_TYPES.some(ct => el.type.includes(ct) || el.type === ct);
        const isSqftType = SQFT_TYPES.some(st => el.type.includes(st) || el.type === st);
        const isCabinet = isCabinetType(el.type);

        if (isCountertop || isSqftType) {
          // Square footage pricing for countertops and surfaces
          sqft = getElementSqft(el);
          baseCost = sqft * priceInfo.price;
          quantity = sqft;
          unit = 'sqft';

          // Add edge pricing for countertops
          if (isCountertop && el.edgeProfile && TAKEOFF_STANDARDS?.edgeProfiles) {
            const edgePrice = TAKEOFF_STANDARDS.edgeProfiles[el.edgeProfile]?.pricePerLF || 0;
            const hasBackWall = !el.overhangBack || el.overhangBack < 0.1;
            const perimeter = (el.width + el.height) * 2;
            const edgeLF = hasBackWall ? perimeter - el.width : perimeter;
            baseCost += edgeLF * edgePrice;
          }
        } else if (isCabinet) {
          // Cabinet pricing - use breakdown for larger runs
          const widthInches = el.width * 12;

          // If cabinet is wider than largest standard (36"), break it down
          if (widthInches > 36) {
            const breakdown = breakdownCabinetRun(el.width, el.type, priceInfo.price);

            // Calculate total cost from breakdown
            baseCost = breakdown.cabinets.reduce((sum, c) => sum + c.priceTotal, 0);
            baseCost += breakdown.fillers.reduce((sum, f) => sum + f.price, 0);
            baseCost += breakdown.toeKick.price;

            boxCount = breakdown.totalCabinets;
            fillerWidth = breakdown.fillers.reduce((sum, f) => sum + f.width, 0) / 12; // Convert to feet
            fillerCost = breakdown.fillers.reduce((sum, f) => sum + f.price, 0);

            quantity = boxCount;
            unit = 'cabinets';

            // Store breakdown details on element for display
            el.breakdown = breakdown;
            el.boxCount = boxCount;
            el.fillerWidth = fillerWidth;
            el.toeKickLF = breakdown.toeKick.lengthLF;
          } else if (el.skuWidth && el.sku) {
            // SKU-based pricing for catalog cabinets
            const actualWidth = el.width;
            const skuWidth = el.skuWidth;

            if (actualWidth > skuWidth * 1.1) {
              boxCount = Math.ceil(actualWidth / skuWidth);
              const remainder = actualWidth - ((boxCount - 1) * skuWidth);
              if (remainder < skuWidth * 0.5 && remainder >= MIN_FILLER_WIDTH) {
                boxCount--;
                fillerWidth = remainder;
                fillerCost = fillerWidth * FILLER_PRICE_PER_LF;
              }
              baseCost = priceInfo.price * boxCount;
              quantity = boxCount;
              unit = 'boxes';
            } else {
              baseCost = priceInfo.price;
              quantity = 1;
              unit = 'unit';
            }
            el.boxCount = boxCount;
            el.fillerWidth = fillerWidth;
          } else {
            // Standard single cabinet pricing
            baseCost = priceInfo.price;
            quantity = 1;
            unit = 'unit';
            el.boxCount = 1;
            el.fillerWidth = 0;

            // Add toe kick for single cabinets too
            const toeKickCost = el.width * TAKEOFF_STANDARDS.cabinet.toeKick.pricePerLF;
            baseCost += toeKickCost;
            el.toeKickLF = el.width;
          }
        } else {
          // Standard unit pricing for appliances, fixtures, etc.
          baseCost = priceInfo.price;
          quantity = 1;
          unit = 'unit';
        }

        const totalBaseCost = baseCost + fillerCost;
        const retailPrice = totalBaseCost * (1 + margin / 100);

        // Store calculated prices on element
        el.costPrice = totalBaseCost;
        el.retailPrice = retailPrice;

        // Create unique key for each item
        // Use element ID for individual tracking, but group by type+material for display
        const materialName = getMaterialName(el.materialId) || el.materialName;
        const widthInches = Math.round(el.width * 12);

        let itemKey, itemLabel;

        if (isCabinet) {
          // Group cabinets by type and width for cleaner display
          const cabinetType = el.type.replace('-cabinet', '').replace('sink-', 'Sink ').replace('drawer-', 'Drawer ');
          itemKey = `cabinet-${el.type}-${widthInches}`;
          itemLabel = el.label || `${cabinetType.charAt(0).toUpperCase() + cabinetType.slice(1)} ${widthInches}"`;
          if (el.sku) {
            itemKey = `cabinet-${el.sku}`;
            itemLabel = el.skuName || el.sku;
          }
        } else if (isCountertop) {
          // Group countertops by material
          itemKey = `countertop-${el.materialId || 'unspecified'}`;
          itemLabel = materialName ? `Countertop (${materialName})` : (el.label || 'Countertop');
        } else if (isSqftType) {
          itemKey = `${el.type}-${el.materialId || 'default'}`;
          itemLabel = materialName ? `${el.label || el.type} (${materialName})` : (el.label || el.type);
        } else {
          // Individual items (appliances, fixtures)
          itemKey = `${el.type}-${el.id}`;
          itemLabel = el.label || el.type;
        }

        if (!items[itemKey]) {
          items[itemKey] = {
            count: 0,
            costTotal: 0,
            retailTotal: 0,
            label: itemLabel,
            sqft: 0,
            linearFt: 0,
            boxCount: 0,
            fillerTotal: 0,
            margin: margin,
            priceSource: priceInfo.source,
            sku: el.sku || null,
            type: el.type,
            isCabinet: isCabinet,
            isCountertop: isCountertop
          };
        }

        items[itemKey].count++;
        items[itemKey].costTotal += totalBaseCost;
        items[itemKey].retailTotal += retailPrice;
        items[itemKey].boxCount += boxCount;
        items[itemKey].fillerTotal += fillerWidth;

        if (unit === 'sqft') {
          items[itemKey].sqft += sqft;
        }
        if (isCabinet) {
          items[itemKey].linearFt += el.width;
        }

        totalCost += totalBaseCost;
        totalRetail += retailPrice;
      });

      // Add filler strips as separate line item if any exist
      const totalFiller = Object.values(items).reduce((sum, item) => sum + item.fillerTotal, 0);
      if (totalFiller > MIN_FILLER_WIDTH) {
        const fillerMargin = 30;
        const fillerCost = totalFiller * FILLER_PRICE_PER_LF;
        const fillerRetail = fillerCost * (1 + fillerMargin / 100);
        items['filler-strips'] = {
          count: 1,
          costTotal: fillerCost,
          retailTotal: fillerRetail,
          label: `Filler Strips (${(totalFiller * 12).toFixed(1)}")`,
          sqft: 0,
          linearFt: totalFiller,
          boxCount: 0,
          fillerTotal: totalFiller,
          margin: fillerMargin,
          priceSource: 'standard',
          sku: 'FILLER',
          type: 'filler',
          isCabinet: false,
          isCountertop: false
        };
        totalCost += fillerCost;
        totalRetail += fillerRetail;
      }

      // Add toe kick as separate line item
      const totalToeKickLF = elements
        .filter(el => CABINET_TYPES.some(ct => el.type.includes(ct) || el.type === ct))
        .reduce((sum, el) => sum + (el.toeKickLF || el.width), 0);
      if (totalToeKickLF > 0) {
        const toeKickMargin = 25;
        const toeKickCost = totalToeKickLF * TAKEOFF_STANDARDS.cabinet.toeKick.pricePerLF;
        const toeKickRetail = toeKickCost * (1 + toeKickMargin / 100);
        items['toe-kick'] = {
          count: 1,
          costTotal: toeKickCost,
          retailTotal: toeKickRetail,
          label: `Toe Kick (${totalToeKickLF.toFixed(1)} LF)`,
          sqft: 0,
          linearFt: totalToeKickLF,
          boxCount: 0,
          fillerTotal: 0,
          margin: toeKickMargin,
          priceSource: 'standard',
          sku: 'TOEKICK',
          type: 'toekick',
          isCabinet: false,
          isCountertop: false
        };
        totalCost += toeKickCost;
        totalRetail += toeKickRetail;
      }

      // Add slab calculation for countertops
      const totalCountertopSqftForSlabs = elements
        .filter(el => COUNTERTOP_TYPES.some(ct => el.type.includes(ct) || el.type === ct))
        .reduce((sum, el) => sum + getElementSqft(el), 0);
      if (totalCountertopSqftForSlabs > 0) {
        const slabCalc = calculateSlabRequirement(totalCountertopSqftForSlabs);
        // Store slab info for display (not as cost item, just informational)
        items['slab-info'] = {
          count: slabCalc.slabsNeeded,
          costTotal: 0, // Material cost already included in countertop pricing
          retailTotal: 0,
          label: `Stone Slabs Needed`,
          sqft: slabCalc.grossSqft,
          linearFt: 0,
          boxCount: 0,
          fillerTotal: 0,
          margin: 0,
          priceSource: 'info',
          sku: 'SLAB-INFO',
          type: 'info',
          isCabinet: false,
          isCountertop: false,
          isInfo: true,
          slabDetails: `${slabCalc.slabsNeeded} ${slabCalc.slabSize}(s) @ ${slabCalc.slabSqft} sqft each (includes ${slabCalc.wastePercent}% waste)`
        };
      }

      // ===== LABOR COSTS CALCULATION =====
      // Calculate labor costs based on user labor rates and takeoffs
      const laborMargin = PRICING_STATE.categoryMargins.labor || PRICING_STATE.globalMargin || 20;
      let totalLaborCost = 0;
      let totalLaborRetail = 0;

      // Get totals from current items for labor calculations
      const totalCountertopSqft = Object.values(items)
        .filter(item => item.isCountertop)
        .reduce((sum, item) => sum + item.sqft, 0);

      const totalCabinetCount = Object.values(items)
        .filter(item => item.isCabinet)
        .reduce((sum, item) => sum + item.count, 0);

      // Stone fabrication labor (if countertops exist)
      if (totalCountertopSqft > 0 && userLaborRates.stone) {
        // Fabrication
        const fabRate = userLaborRates.stone.fabrication?.rate || 0;
        if (fabRate > 0) {
          const fabCost = totalCountertopSqft * fabRate;
          const fabRetail = fabCost * (1 + laborMargin / 100);
          items['labor-fabrication'] = {
            count: 1,
            costTotal: fabCost,
            retailTotal: fabRetail,
            label: `Fabrication (${totalCountertopSqft.toFixed(1)} sqft)`,
            sqft: totalCountertopSqft,
            linearFt: 0,
            boxCount: 0,
            fillerTotal: 0,
            margin: laborMargin,
            priceSource: 'labor',
            sku: 'LABOR-FAB',
            type: 'labor',
            isCabinet: false,
            isCountertop: false,
            isLabor: true
          };
          totalLaborCost += fabCost;
          totalLaborRetail += fabRetail;
        }

        // Installation
        const installRate = userLaborRates.stone.installation?.rate || 0;
        if (installRate > 0) {
          const installCost = totalCountertopSqft * installRate;
          const installRetail = installCost * (1 + laborMargin / 100);
          items['labor-ct-install'] = {
            count: 1,
            costTotal: installCost,
            retailTotal: installRetail,
            label: `Countertop Installation (${totalCountertopSqft.toFixed(1)} sqft)`,
            sqft: totalCountertopSqft,
            linearFt: 0,
            boxCount: 0,
            fillerTotal: 0,
            margin: laborMargin,
            priceSource: 'labor',
            sku: 'LABOR-INST',
            type: 'labor',
            isCabinet: false,
            isCountertop: false,
            isLabor: true
          };
          totalLaborCost += installCost;
          totalLaborRetail += installRetail;
        }

        // Template visit (flat fee if countertops exist)
        const templateRate = userLaborRates.stone.template?.rate || 0;
        if (templateRate > 0) {
          const templateRetail = templateRate * (1 + laborMargin / 100);
          items['labor-template'] = {
            count: 1,
            costTotal: templateRate,
            retailTotal: templateRetail,
            label: 'Template Visit',
            sqft: 0,
            linearFt: 0,
            boxCount: 0,
            fillerTotal: 0,
            margin: laborMargin,
            priceSource: 'labor',
            sku: 'LABOR-TEMP',
            type: 'labor',
            isCabinet: false,
            isCountertop: false,
            isLabor: true
          };
          totalLaborCost += templateRate;
          totalLaborRetail += templateRetail;
        }
      }

      // Cabinet installation labor (if cabinets exist)
      if (totalCabinetCount > 0 && userLaborRates.cabinet) {
        const cabInstallRate = userLaborRates.cabinet.installation?.rate || 0;
        if (cabInstallRate > 0) {
          const cabInstallCost = totalCabinetCount * cabInstallRate;
          const cabInstallRetail = cabInstallCost * (1 + laborMargin / 100);
          items['labor-cab-install'] = {
            count: totalCabinetCount,
            costTotal: cabInstallCost,
            retailTotal: cabInstallRetail,
            label: `Cabinet Installation (${totalCabinetCount} cabinets)`,
            sqft: 0,
            linearFt: 0,
            boxCount: totalCabinetCount,
            fillerTotal: 0,
            margin: laborMargin,
            priceSource: 'labor',
            sku: 'LABOR-CAB',
            type: 'labor',
            isCabinet: false,
            isCountertop: false,
            isLabor: true
          };
          totalLaborCost += cabInstallCost;
          totalLaborRetail += cabInstallRetail;
        }
      }

      // Check for sinks (plumbing labor)
      const sinkItems = elements.filter(el => el.type === 'sink' || el.type.includes('sink'));
      if (sinkItems.length > 0 && userLaborRates.plumbing) {
        const sinkRate = userLaborRates.plumbing.sinkInstall?.rate || 0;
        if (sinkRate > 0) {
          const sinkLaborCost = sinkItems.length * sinkRate;
          const sinkLaborRetail = sinkLaborCost * (1 + laborMargin / 100);
          items['labor-sink-install'] = {
            count: sinkItems.length,
            costTotal: sinkLaborCost,
            retailTotal: sinkLaborRetail,
            label: `Sink Installation (${sinkItems.length})`,
            sqft: 0,
            linearFt: 0,
            boxCount: 0,
            fillerTotal: 0,
            margin: laborMargin,
            priceSource: 'labor',
            sku: 'LABOR-SINK',
            type: 'labor',
            isCabinet: false,
            isCountertop: false,
            isLabor: true
          };
          totalLaborCost += sinkLaborCost;
          totalLaborRetail += sinkLaborRetail;
        }
      }

      // Check for faucets
      const faucetItems = elements.filter(el => el.type === 'faucet' || el.type.includes('faucet'));
      if (faucetItems.length > 0 && userLaborRates.plumbing) {
        const faucetRate = userLaborRates.plumbing.faucetInstall?.rate || 0;
        if (faucetRate > 0) {
          const faucetLaborCost = faucetItems.length * faucetRate;
          const faucetLaborRetail = faucetLaborCost * (1 + laborMargin / 100);
          items['labor-faucet-install'] = {
            count: faucetItems.length,
            costTotal: faucetLaborCost,
            retailTotal: faucetLaborRetail,
            label: `Faucet Installation (${faucetItems.length})`,
            sqft: 0,
            linearFt: 0,
            boxCount: 0,
            fillerTotal: 0,
            margin: laborMargin,
            priceSource: 'labor',
            sku: 'LABOR-FAUCET',
            type: 'labor',
            isCabinet: false,
            isCountertop: false,
            isLabor: true
          };
          totalLaborCost += faucetLaborCost;
          totalLaborRetail += faucetLaborRetail;
        }
      }

      // Add labor totals to grand total
      totalCost += totalLaborCost;
      totalRetail += totalLaborRetail;

      renderQuoteItems(items, totalCost, totalRetail);
    }

    function renderQuoteItems(items, totalCost, totalRetail) {
      const quoteItems = document.getElementById('quoteItems');
      const showCost = PRICING_STATE.showCostView;
      const canViewPrices = checkPermission('canViewPrices');
      const canViewCosts = checkPermission('canViewCosts');

      if (Object.keys(items).length === 0) {
        quoteItems.innerHTML = `
          <div class="quote-item">
            <span class="quote-item-name">No items yet</span>
            <span class="quote-item-value">$0</span>
          </div>
        `;
      } else {
        // Sort items: countertops first, then cabinets, then others, then labor
        const sortedItems = Object.entries(items).sort(([, a], [, b]) => {
          // Labor items always last
          if (a.isLabor && !b.isLabor) return 1;
          if (!a.isLabor && b.isLabor) return -1;
          // Countertops first
          if (a.isCountertop && !b.isCountertop) return -1;
          if (!a.isCountertop && b.isCountertop) return 1;
          // Then cabinets
          if (a.isCabinet && !b.isCabinet) return -1;
          if (!a.isCabinet && b.isCabinet) return 1;
          return 0;
        });

        quoteItems.innerHTML = sortedItems.map(([key, data]) => {
          const displayPrice = showCost && canViewCosts ? data.costTotal : data.retailTotal;
          const marginBadge = canViewCosts ? `<span class="margin-badge">${data.margin}%</span>` : '';

          // Build quantity/detail info based on item type
          let quantityInfo = '';
          let detailInfo = '';

          if (data.isCountertop || data.sqft > 0) {
            // Countertops: show sqft
            quantityInfo = data.count > 1 ? `(${data.count} pcs)` : '';
            detailInfo = `<span style="color: #888; font-size: 11px;"> - ${data.sqft.toFixed(1)} sqft</span>`;
          } else if (data.isCabinet) {
            // Cabinets: show breakdown details
            const linearInches = Math.round(data.linearFt * 12);
            if (data.boxCount > 1) {
              // Show cabinet breakdown for runs
              quantityInfo = `(${data.boxCount} cabs)`;
              let breakdownDetail = `${linearInches}" run`;
              if (data.fillerTotal > 0) {
                breakdownDetail += ` + ${(data.fillerTotal * 12).toFixed(1)}" filler`;
              }
              detailInfo = `<span style="color: #888; font-size: 11px;"> - ${breakdownDetail}</span>`;
            } else if (data.count > 1) {
              quantityInfo = `(${data.count})`;
              detailInfo = linearInches > 0 ? `<span style="color: #888; font-size: 11px;"> - ${linearInches}" total</span>` : '';
            } else {
              quantityInfo = '';
              detailInfo = linearInches > 0 ? `<span style="color: #888; font-size: 11px;"> - ${linearInches}"</span>` : '';
            }
          } else {
            // Other items
            quantityInfo = data.count > 1 ? `(${data.count})` : '';
          }

          if (!canViewPrices) {
            return `
              <div class="quote-item">
                <span class="quote-item-name">${data.label} ${quantityInfo}${detailInfo}</span>
              </div>
            `;
          }

          // Determine styling based on item type
          let itemStyle = '';
          let itemPrefix = '';
          if (data.isCountertop) {
            itemStyle = 'background: rgba(249,203,0,0.05); border-left: 2px solid var(--gold-primary);';
          } else if (data.isLabor) {
            itemStyle = 'background: rgba(99,102,241,0.05); border-left: 2px solid var(--primary);';
            itemPrefix = '<span style="color: var(--primary); font-size: 10px; margin-right: 6px;"></span>';
          } else if (data.isInfo) {
            // Info-only items (like slab count)
            itemStyle = 'background: rgba(100,149,237,0.05); border-left: 2px solid cornflowerblue; font-style: italic;';
            return `
              <div class="quote-item" style="${itemStyle}">
                <span class="quote-item-name" style="font-size: 11px;">
                  <span style="color: cornflowerblue;"></span> ${data.label}: ${data.count}
                  <br><span style="color: #888; font-size: 10px;">${data.slabDetails || ''}</span>
                </span>
              </div>
            `;
          } else if (data.type === 'filler' || data.type === 'toekick') {
            itemStyle = 'background: rgba(139,69,19,0.05); border-left: 2px solid #8B4513;';
            itemPrefix = '<span style="color: #8B4513; font-size: 10px; margin-right: 6px;"></span>';
          }

          return `
            <div class="quote-item" style="${itemStyle}">
              <span class="quote-item-name">
                ${itemPrefix}${data.label} ${quantityInfo}${detailInfo}
                ${marginBadge}
              </span>
              <span class="quote-item-value">
                $${displayPrice.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2})}
              </span>
            </div>
          `;
        }).join('');
      }

      // Update totals
      const displayTotal = showCost && canViewCosts ? totalCost : totalRetail;
      const quoteTotalEl = document.getElementById('quoteTotal');
      if (quoteTotalEl) {
        quoteTotalEl.textContent = canViewPrices
          ? '$' + displayTotal.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2})
          : '---';
      }

      // Show/hide cost breakdown
      const costRow = document.getElementById('quoteCostRow');
      const marginRow = document.getElementById('quoteMarginRow');

      if (costRow && marginRow) {
        if (canViewCosts) {
          costRow.style.display = 'flex';
          marginRow.style.display = 'flex';
          document.getElementById('quoteCost').textContent = '$' + totalCost.toLocaleString(undefined, {minimumFractionDigits: 2});
          document.getElementById('quoteMargin').textContent = '$' + (totalRetail - totalCost).toLocaleString(undefined, {minimumFractionDigits: 2});
        } else {
          costRow.style.display = 'none';
          marginRow.style.display = 'none';
        }
      }

      // Store quote total for payment processing and show/hide checkout button
      window.currentQuoteTotal = totalRetail;
      window.currentQuoteCost = totalCost;
      const quoteActions = document.getElementById('quoteActions');
      if (quoteActions) {
        quoteActions.style.display = totalRetail > 0 ? 'block' : 'none';
      }

      // Update quick takeoff stats
      updateQuickTakeoffStats();
    }

    // Update the quick takeoff stats in the sidebar
    function updateQuickTakeoffStats() {
      const takeoffs = calculateTakeoffs();
      const statsDiv = document.getElementById('takeoffQuickStats');
      const slabCount = document.getElementById('quickSlabCount');
      const cabinetCount = document.getElementById('quickCabinetCount');

      if (statsDiv && slabCount && cabinetCount) {
        const hasElements = takeoffs.stone.slabsNeeded > 0 || takeoffs.cabinets.totalCount > 0;
        statsDiv.style.display = hasElements ? 'block' : 'none';
        slabCount.textContent = takeoffs.stone.slabsNeeded || 0;
        cabinetCount.textContent = takeoffs.cabinets.totalCount || 0;
      }
    }

    // ============ PAYMENT PROCESSING ============

    const STRIPE_PUBLIC_KEY = 'pk_live_51Smr3E3qDbNyHFmdPLN9iXM3rMQv6hKNtXEP5yVpZVRHBFZ5xk0jKvPy4kQMQ6yHVzXSzVBBZlP8rMGKK9TyZ7qJ00q0Y3nKpN';
    const API_BASE = 'https://surprise-granite-email-api.onrender.com';
    let selectedPaymentOption = 'deposit';
    let stripeInstance = null;

    function openPaymentModal() {
      const total = window.currentQuoteTotal || 0;
      if (total <= 0) {
        showToast('Add items to your design before checkout', 'error');
        return;
      }

      // Initialize Stripe if not already
      if (!stripeInstance && typeof Stripe !== 'undefined') {
        stripeInstance = Stripe(STRIPE_PUBLIC_KEY);
      }

      // Calculate payment amounts
      const depositAmount = Math.max(99, total * 0.1); // 10% or minimum $99
      const discountedFull = total * 0.95; // 5% discount for full payment

      // Update modal values
      document.getElementById('paymentDesignName').textContent = document.getElementById('projectName')?.value || 'Kitchen Design';

      // Find primary countertop material
      const countertop = elements.find(el => el.type === 'countertop' && el.materialName);
      document.getElementById('paymentMaterial').textContent = countertop?.materialName || 'Various materials';

      // Calculate total square footage of countertops (includes L and U shapes)
      const countertopSqft = elements
        .filter(el => el.type === 'countertop' || el.type === 'countertop-l' || el.type === 'countertop-u')
        .reduce((sum, el) => sum + getElementSqft(el), 0);
      document.getElementById('paymentSqft').textContent = countertopSqft > 0 ? `${countertopSqft.toFixed(1)} sq ft` : '-';

      document.getElementById('paymentTotal').textContent = '$' + total.toLocaleString(undefined, {minimumFractionDigits: 2});
      document.getElementById('depositAmount').textContent = '$' + depositAmount.toLocaleString(undefined, {minimumFractionDigits: 2});
      document.getElementById('fullAmount').textContent = '$' + discountedFull.toLocaleString(undefined, {minimumFractionDigits: 2});

      // Pre-fill email if user is logged in
      if (window.currentUser?.email) {
        document.getElementById('paymentEmail').value = window.currentUser.email;
      }

      // Reset selection to deposit
      selectPaymentOption('deposit');

      // Show modal
      document.getElementById('paymentModal').style.display = 'flex';
    }

    function closePaymentModal() {
      document.getElementById('paymentModal').style.display = 'none';
    }

    // Close modal when clicking outside
    document.addEventListener('click', (e) => {
      const modal = document.getElementById('paymentModal');
      if (e.target === modal) {
        closePaymentModal();
      }
    });

    function selectPaymentOption(option) {
      selectedPaymentOption = option;
      const total = window.currentQuoteTotal || 0;

      // Update UI
      document.querySelectorAll('.payment-option').forEach(el => el.classList.remove('selected'));
      document.getElementById('option' + option.charAt(0).toUpperCase() + option.slice(1))?.classList.add('selected');

      // Update button text
      const btnText = document.getElementById('paymentBtnText');
      switch(option) {
        case 'deposit':
          const depositAmt = Math.max(99, total * 0.1);
          btnText.textContent = `Pay $${depositAmt.toFixed(2)} Deposit`;
          break;
        case 'consultation':
          btnText.textContent = 'Pay $99 Consultation Fee';
          break;
        case 'full':
          const fullAmt = total * 0.95;
          btnText.textContent = `Pay $${fullAmt.toLocaleString(undefined, {minimumFractionDigits: 2})} (5% off)`;
          break;
      }
    }

    async function processPayment() {
      const email = document.getElementById('paymentEmail').value.trim();
      const phone = document.getElementById('paymentPhone').value.trim();

      if (!email || !email.includes('@')) {
        showToast('Please enter a valid email address', 'error');
        document.getElementById('paymentEmail').focus();
        return;
      }

      const btn = document.getElementById('paymentSubmitBtn');
      const btnText = document.getElementById('paymentBtnText');
      const originalText = btnText.textContent;

      btn.disabled = true;
      btnText.textContent = 'Processing...';

      try {
        const total = window.currentQuoteTotal || 0;
        let amount = 0;
        let itemName = '';
        let description = '';

        switch(selectedPaymentOption) {
          case 'deposit':
            amount = Math.max(99, total * 0.1);
            itemName = 'Design Deposit (10%)';
            description = `Deposit for project: ${document.getElementById('projectName')?.value || 'Kitchen Design'}`;
            break;
          case 'consultation':
            amount = 99;
            itemName = 'Design Consultation';
            description = 'In-home or virtual design consultation';
            break;
          case 'full':
            amount = total * 0.95;
            itemName = 'Full Project Payment (5% discount)';
            description = `Full payment for project: ${document.getElementById('projectName')?.value || 'Kitchen Design'}`;
            break;
        }

        // Save design to localStorage/Supabase before checkout
        const designData = {
          name: document.getElementById('projectName')?.value || 'Kitchen Design',
          roomWidth,
          roomDepth,
          roomHeight,
          elements: JSON.parse(JSON.stringify(elements)),
          quoteTotal: total,
          paymentOption: selectedPaymentOption,
          paymentAmount: amount,
          customerEmail: email,
          customerPhone: phone,
          createdAt: new Date().toISOString()
        };

        // Store design reference for after payment
        localStorage.setItem('sg_pending_design', JSON.stringify(designData));

        // Create checkout session
        const response = await fetch(`${API_BASE}/api/create-checkout-session`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            items: [{
              name: itemName,
              price: Math.round(amount * 100), // Convert to cents
              quantity: 1,
              image: ''
            }],
            customer_email: email,
            success_url: `${window.location.origin}/tools/room-designer/?payment=success&session_id={CHECKOUT_SESSION_ID}`,
            cancel_url: `${window.location.origin}/tools/room-designer/?payment=canceled`,
            metadata: {
              order_source: 'room_designer',
              payment_type: selectedPaymentOption,
              project_total: total.toString(),
              phone: phone
            }
          })
        });

        const data = await response.json();

        if (data.error) {
          throw new Error(data.error);
        }

        // Redirect to Stripe Checkout
        if (data.url) {
          window.location.href = data.url;
        } else if (data.sessionId && stripeInstance) {
          const result = await stripeInstance.redirectToCheckout({ sessionId: data.sessionId });
          if (result.error) {
            throw new Error(result.error.message);
          }
        }

      } catch (error) {
        console.error('Payment error:', error);
        showToast('Payment failed: ' + error.message, 'error');
        btn.disabled = false;
        btnText.textContent = originalText;
      }
    }

    // Approve and Pay - for quote_approval permission
    window.approveAndPay = async function() {
      const btn = document.querySelector('.approve-pay-btn');
      if (!btn) return;

      const originalContent = btn.innerHTML;
      btn.disabled = true;
      btn.innerHTML = `
        <svg class="spinner" viewBox="0 0 24 24" style="width:20px;height:20px;margin-right:8px;animation:spin 1s linear infinite;">
          <circle cx="12" cy="12" r="10" stroke="currentColor" stroke-width="3" fill="none" stroke-dasharray="32" stroke-linecap="round"/>
        </svg>
        Processing...
      `;

      try {
        // Calculate quote total
        const total = calculateQuoteTotal();
        const depositAmount = total * 0.5; // 50% deposit

        if (depositAmount < 1) {
          throw new Error('Quote total is too low for payment');
        }

        // Get project name and share info
        const projectName = document.querySelector('.review-title')?.textContent || 'Design Project';
        const shareId = SHARE_STATE.shareId || window.location.pathname.split('/').pop() || 'unknown';

        // Prompt for email if not already known
        let customerEmail = SHARE_STATE.customerEmail || '';
        if (!customerEmail) {
          customerEmail = prompt('Please enter your email address for order confirmation:');
          if (!customerEmail || !customerEmail.includes('@')) {
            throw new Error('Valid email required to proceed');
          }
        }

        // Create design data for record-keeping
        const approvalData = {
          shareId: shareId,
          projectName: projectName,
          roomWidth,
          roomDepth,
          roomHeight,
          elements: JSON.parse(JSON.stringify(elements)),
          quoteTotal: total,
          depositAmount: depositAmount,
          customerEmail: customerEmail,
          approvedAt: new Date().toISOString(),
          status: 'pending_payment'
        };

        // Store approval reference for after payment
        localStorage.setItem('sg_pending_approval', JSON.stringify(approvalData));

        // Create checkout session for deposit
        const response = await fetch(`${API_BASE}/api/create-checkout-session`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            items: [{
              name: `Design Approval Deposit - ${projectName}`,
              price: Math.round(depositAmount * 100), // Convert to cents
              quantity: 1,
              image: ''
            }],
            customer_email: customerEmail,
            success_url: `${window.location.origin}/tools/room-designer/?approval=success&share_id=${shareId}&session_id={CHECKOUT_SESSION_ID}`,
            cancel_url: `${window.location.href}`,
            metadata: {
              order_source: 'room_designer_approval',
              payment_type: 'quote_approval_deposit',
              share_id: shareId,
              project_name: projectName,
              project_total: total.toString(),
              deposit_amount: depositAmount.toString()
            }
          })
        });

        const data = await response.json();

        if (data.error) {
          throw new Error(data.error);
        }

        // Mark design as approved before redirect
        try {
          await updateShareStatus(shareId, 'approved_pending_payment');
        } catch (e) {
          console.log('Could not update share status:', e);
        }

        // Redirect to Stripe Checkout
        if (data.url) {
          window.location.href = data.url;
        } else if (data.sessionId && stripeInstance) {
          const result = await stripeInstance.redirectToCheckout({ sessionId: data.sessionId });
          if (result.error) {
            throw new Error(result.error.message);
          }
        }

      } catch (error) {
        console.error('Approval payment error:', error);
        showToast('Payment failed: ' + error.message, 'error');
        btn.disabled = false;
        btn.innerHTML = originalContent;
      }
    };

    // Update share status in Supabase
    async function updateShareStatus(shareId, status) {
      if (!shareId) return;

      try {
        const supabaseClient = getSupabaseClient();
        if (!supabaseClient) return;

        await supabaseClient
          .from('room_designer_shares')
          .update({
            status: status,
            approved_at: status.includes('approved') ? new Date().toISOString() : null
          })
          .eq('share_id', shareId);

        console.log('Share status updated to:', status);
      } catch (e) {
        console.error('Error updating share status:', e);
      }
    }

    // Check for approval success on page load
    function checkApprovalStatus() {
      const params = new URLSearchParams(window.location.search);
      const approvalStatus = params.get('approval');
      const shareId = params.get('share_id');
      const sessionId = params.get('session_id');

      if (approvalStatus === 'success' && shareId) {
        // Clear the URL params
        window.history.replaceState({}, document.title, window.location.pathname);

        // Load the pending approval data
        const pendingApproval = localStorage.getItem('sg_pending_approval');
        if (pendingApproval) {
          const approvalData = JSON.parse(pendingApproval);
          localStorage.removeItem('sg_pending_approval');

          // Update share status to fully approved
          updateShareStatus(shareId, 'approved_paid');

          // Show success message
          showToast('Design approved and deposit paid successfully!', 'success');

          // Show confirmation modal
          showApprovalConfirmation(approvalData);
        } else {
          showToast('Design approved! Thank you for your payment.', 'success');
        }
      }
    }

    // Show approval confirmation modal
    function showApprovalConfirmation(approvalData) {
      const modal = document.createElement('div');
      modal.className = 'approval-confirmation-modal';
      modal.innerHTML = `
        <div class="approval-confirmation-content">
          <div class="approval-success-icon">
            <svg viewBox="0 0 24 24" fill="none" stroke="#22c55e" stroke-width="2" style="width:64px;height:64px;">
              <path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/>
              <polyline points="22 4 12 14.01 9 11.01"/>
            </svg>
          </div>
          <h2>Design Approved!</h2>
          <p>Thank you for approving your design.</p>
          <div class="approval-details">
            <div class="approval-detail">
              <span class="label">Project:</span>
              <span class="value">${approvalData.projectName || 'Kitchen Design'}</span>
            </div>
            <div class="approval-detail">
              <span class="label">Deposit Paid:</span>
              <span class="value">$${(approvalData.depositAmount || 0).toFixed(2)}</span>
            </div>
            <div class="approval-detail">
              <span class="label">Remaining Balance:</span>
              <span class="value">$${((approvalData.quoteTotal || 0) - (approvalData.depositAmount || 0)).toFixed(2)}</span>
            </div>
          </div>
          <p class="approval-next-steps">Our team will contact you within 24 hours to schedule your project.</p>
          <button class="btn btn-primary" onclick="this.closest('.approval-confirmation-modal').remove()">Close</button>
        </div>
      `;
      document.body.appendChild(modal);

      // Add styles if not present
      if (!document.getElementById('approval-confirmation-styles')) {
        const style = document.createElement('style');
        style.id = 'approval-confirmation-styles';
        style.textContent = `
          .approval-confirmation-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.6);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
          }
          .approval-confirmation-content {
            background: white;
            border-radius: 16px;
            padding: 32px;
            max-width: 400px;
            text-align: center;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
          }
          .approval-success-icon {
            margin-bottom: 16px;
          }
          .approval-confirmation-content h2 {
            margin: 0 0 8px 0;
            color: #22c55e;
          }
          .approval-details {
            background: #f5f5f7;
            border-radius: 8px;
            padding: 16px;
            margin: 16px 0;
            text-align: left;
          }
          .approval-detail {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #e5e5e5;
          }
          .approval-detail:last-child {
            border-bottom: none;
          }
          .approval-detail .label {
            color: #666;
          }
          .approval-detail .value {
            font-weight: 600;
          }
          .approval-next-steps {
            color: #666;
            font-size: 13px;
            margin: 16px 0;
          }
        `;
        document.head.appendChild(style);
      }
    }

    // Check for payment success/cancel on page load
    function checkPaymentStatus() {
      const params = new URLSearchParams(window.location.search);
      const paymentStatus = params.get('payment');
      const sessionId = params.get('session_id');

      if (paymentStatus === 'success') {
        // Clear the URL params
        window.history.replaceState({}, document.title, window.location.pathname);

        // Load the pending design
        const pendingDesign = localStorage.getItem('sg_pending_design');
        if (pendingDesign) {
          try {
            const design = JSON.parse(pendingDesign);
            showToast(`Payment successful! Your ${design.paymentOption === 'deposit' ? 'deposit' : 'payment'} has been processed.`, 'success');

            // Save design to Supabase with payment reference
            if (window.supabaseClient) {
              saveDesignWithPayment(design, sessionId);
            }

            localStorage.removeItem('sg_pending_design');
          } catch (e) {
            showToast('Payment successful!', 'success');
          }
        } else {
          showToast('Payment successful! Thank you for your order.', 'success');
        }
      } else if (paymentStatus === 'canceled') {
        window.history.replaceState({}, document.title, window.location.pathname);
        showToast('Payment was canceled. Your design has been saved.', 'info');
      }
    }

    async function saveDesignWithPayment(design, sessionId) {
      try {
        const { data: { session } } = await window.supabaseClient.auth.getSession();

        const designRecord = {
          name: design.name,
          user_id: session?.user?.id || null,
          customer_email: design.customerEmail,
          customer_phone: design.customerPhone,
          room_data: {
            width: design.roomWidth,
            depth: design.roomDepth,
            height: design.roomHeight,
            elements: design.elements
          },
          quote_total: design.quoteTotal,
          payment_type: design.paymentOption,
          payment_amount: design.paymentAmount,
          stripe_session_id: sessionId,
          status: 'paid_deposit',
          created_at: design.createdAt
        };

        // Insert into designs table (if it exists)
        const { error } = await window.supabaseClient
          .from('room_designs')
          .insert([designRecord]);

        if (error) {
          console.log('Design save note:', error.message);
          // Table might not exist yet - that's okay
        } else {
          console.log('Design saved with payment reference');
        }
      } catch (e) {
        console.log('Design save skipped:', e.message);
      }
    }

    // Call on page load
    document.addEventListener('DOMContentLoaded', () => {
      checkPaymentStatus();
      checkApprovalStatus();
    });

    function generateQuote() {
      const projectName = document.getElementById('projectName').value;
      const roomType = document.getElementById('roomType').value;

      let text = `QUOTE: ${projectName}\nRoom: ${roomType} (${roomWidth}'  ${roomDepth}')\n${'='.repeat(30)}\n\n`;
      elements.forEach(el => {
        text += `${el.label}: ${el.width}'  ${el.height}'\n`;
      });
      text += `\n${'='.repeat(30)}\nTotal: ${document.getElementById('quoteTotal').textContent}`;

      alert(text);
    }

    // ===== MODALS =====
    function openShareModal() {
      const modal = document.getElementById('shareModal');
      modal.style.display = ''; // Reset inline display style
      modal.classList.add('active');
      // Load active shares if we have a design ID
      if (SHARE_STATE.designId) {
        loadActiveShares();
      }
    }

    function openModal(id) {
      const modal = document.getElementById(id);
      if (!modal) return;
      modal.style.display = ''; // Reset any inline display style
      modal.classList.add('active');
    }

    function closeModal(id) {
      const modal = document.getElementById(id);
      if (!modal) return;
      // Don't allow closing if it's a required modal (for auth)
      if (modal.getAttribute('data-required') === 'true') {
        return;
      }
      modal.classList.remove('active');
      // Reset inline display style so CSS class controls visibility
      modal.style.display = '';
    }

    // ===== EDGE PREVIEW MODAL =====
    let edgePreviewScene, edgePreviewCamera, edgePreviewRenderer, edgePreviewControls;
    let edgePreviewElement = null;
    let edgePreviewAnimationId = null;

    function showEdgePreviewModal(element) {
      edgePreviewElement = element;

      const modal = document.getElementById('edgePreviewModal');
      modal.classList.add('active');

      // Update UI with current element settings
      const profile = element.edgeProfile || 'eased';
      const thickness = element.thickness || '3cm';

      document.getElementById('edgeProfileName').textContent = getEdgeProfileLabel(profile);
      document.getElementById('edgeProfileSelect').value = profile;

      // Initialize thickness toggle button states
      const btn2cm = document.getElementById('thickness2cmBtn');
      const btn3cm = document.getElementById('thickness3cmBtn');
      if (thickness === '2cm') {
        btn2cm.style.background = 'var(--gold)';
        btn2cm.style.color = '#000';
        btn3cm.style.background = 'transparent';
        btn3cm.style.color = 'var(--text-muted)';
      } else {
        btn3cm.style.background = 'var(--gold)';
        btn3cm.style.color = '#000';
        btn2cm.style.background = 'transparent';
        btn2cm.style.color = 'var(--text-muted)';
      }

      // Initialize or update 3D preview
      setTimeout(() => initEdgePreview3D(element), 100);
    }

    function getEdgeProfileLabel(profile) {
      const labels = {
        'eased': 'Eased',
        'pencil': 'Pencil Round',
        'quarter-round': 'Quarter Round',
        'half-bullnose': 'Half Bullnose',
        'demi-bullnose': 'Half Bullnose',
        'full-bullnose': 'Full Bullnose',
        'bevel': 'Bevel',
        'quarter-bevel': 'Quarter Bevel',
        'ogee': 'Ogee',
        'double-ogee': 'Double Ogee',
        'cove': 'Cove',
        'dupont': 'Dupont',
        'mitered': 'Mitered',
        'waterfall': 'Waterfall',
        'flat-polish': 'Flat Polish',
        'square': 'Square Edge',
        'chiseled': 'Chiseled'
      };
      return labels[profile] || profile;
    }

    function initEdgePreview3D(element) {
      const container = document.getElementById('edgePreview3D');
      if (!container) return;

      // Clear existing
      if (edgePreviewRenderer) {
        container.innerHTML = '';
        if (edgePreviewAnimationId) {
          cancelAnimationFrame(edgePreviewAnimationId);
        }
      }

      // Scene setup
      edgePreviewScene = new THREE.Scene();
      edgePreviewScene.background = new THREE.Color(0x1a1a2e);

      // Camera - positioned to show the edge profile clearly from the front-right
      const aspect = container.clientWidth / container.clientHeight;
      edgePreviewCamera = new THREE.PerspectiveCamera(35, aspect, 0.01, 50);
      // Position camera to view the front edge profile - from front-right, slightly above
      // Looking at the front edge of the countertop to see the profile shape
      edgePreviewCamera.position.set(0.8, 0.4, 1.8);
      edgePreviewCamera.lookAt(0, 0.05, 0.3);

      // Renderer
      edgePreviewRenderer = new THREE.WebGLRenderer({ antialias: true });
      edgePreviewRenderer.setSize(container.clientWidth, container.clientHeight);
      edgePreviewRenderer.shadowMap.enabled = true;
      edgePreviewRenderer.toneMapping = THREE.ACESFilmicToneMapping;
      edgePreviewRenderer.toneMappingExposure = 1.2;
      container.appendChild(edgePreviewRenderer.domElement);

      // Controls - enable zoom and pan for exploring the edge
      edgePreviewControls = new THREE.OrbitControls(edgePreviewCamera, edgePreviewRenderer.domElement);
      edgePreviewControls.enableDamping = true;
      edgePreviewControls.dampingFactor = 0.05;
      // Target the front edge of the countertop
      edgePreviewControls.target.set(0, 0.05, 0.3);
      edgePreviewControls.enableZoom = true;
      edgePreviewControls.minDistance = 0.5;
      edgePreviewControls.maxDistance = 5.0;

      // Enhanced lighting for edge visibility
      const ambient = new THREE.AmbientLight(0xffffff, 0.6);
      edgePreviewScene.add(ambient);

      // Key light from front-right to illuminate the edge profile
      const keyLight = new THREE.DirectionalLight(0xffffff, 1.2);
      keyLight.position.set(2, 3, 4);
      keyLight.castShadow = true;
      edgePreviewScene.add(keyLight);

      // Fill light from opposite side
      const fillLight = new THREE.DirectionalLight(0xffffff, 0.5);
      fillLight.position.set(-3, 2, -2);
      edgePreviewScene.add(fillLight);

      // Rim light from behind to highlight the edge curve
      const rimLight = new THREE.DirectionalLight(0xffffff, 0.4);
      rimLight.position.set(0, 1, -3);
      edgePreviewScene.add(rimLight);

      // Create edge profile sample
      createEdgePreviewMesh(element);

      // Animation loop
      function animate() {
        edgePreviewAnimationId = requestAnimationFrame(animate);
        edgePreviewControls.update();
        edgePreviewRenderer.render(edgePreviewScene, edgePreviewCamera);
      }
      animate();
    }

    function createEdgePreviewMesh(element) {
      // Remove old meshes
      const oldMesh = edgePreviewScene.getObjectByName('edgeSample');
      if (oldMesh) edgePreviewScene.remove(oldMesh);
      const oldGroup = edgePreviewScene.getObjectByName('edgeGroup');
      if (oldGroup) edgePreviewScene.remove(oldGroup);

      const profile = element.edgeProfile || 'eased';
      const thickness = element.thickness || '3cm';
      const is2cm = thickness === '2cm';
      const color = parseInt(element.color?.replace('#', '') || '708090', 16);
      const textureUrl = element.texture || null;

      // Create material with nice stone-like appearance
      let material;
      if (textureUrl) {
        const textureLoader = new THREE.TextureLoader();
        const texture = textureLoader.load(textureUrl);
        texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
        texture.repeat.set(0.5, 0.5);
        material = new THREE.MeshStandardMaterial({
          map: texture,
          roughness: 0.25,
          metalness: 0.05
        });
      } else {
        material = new THREE.MeshStandardMaterial({
          color: color,
          roughness: 0.25,
          metalness: 0.05
        });
      }

      const group = new THREE.Group();
      group.name = 'edgeGroup';

      // Countertop slab dimensions
      const slabWidth = 2.0;   // Width (left to right)
      const slabDepth = 1.2;   // Depth (front to back)
      // Thickness: 3cm = ~1.2", 2cm = ~0.8" (scaled up for visibility)
      const slabThickness = is2cm ? 0.08 : 0.12;
      const t = slabThickness;
      const frontX = slabDepth * 0.3; // Front edge position

      // For waterfall, create special visualization
      if (profile === 'waterfall') {
        // MITERED WATERFALL - like mitered drop edge but turns 90 vertical
        // Pieces are JOINED together with 45 seam at corner

        const waterfallDrop = 0.7;

        // HORIZONTAL SLAB (same as mitered edge)
        const slabGeo = new THREE.BoxGeometry(slabWidth, t, slabDepth);
        const slab = new THREE.Mesh(slabGeo, material);
        slab.position.y = t / 2;
        slab.castShadow = true;
        group.add(slab);

        // VERTICAL WATERFALL - back touches slab front, top at y=t
        const wfGeo = new THREE.BoxGeometry(slabWidth, waterfallDrop, t);
        const wfPanel = new THREE.Mesh(wfGeo, material);
        wfPanel.position.set(0, t - waterfallDrop / 2, slabDepth / 2 + t / 2);
        wfPanel.castShadow = true;
        group.add(wfPanel);

        // 45 MITER SEAM at corner
        const seamMat = new THREE.MeshStandardMaterial({
          color: 0x444444, roughness: 0.6, transparent: true, opacity: 0.5
        });
        const seamDiag = t * Math.SQRT2;
        const seamGeo = new THREE.BoxGeometry(slabWidth + 0.01, 0.002, seamDiag);
        const seam = new THREE.Mesh(seamGeo, seamMat);
        seam.rotation.x = -Math.PI / 4;
        seam.position.set(0, t / 2, slabDepth / 2 + t / 2);
        group.add(seam);

        group.position.set(-slabWidth / 2, 0, -slabDepth / 2 + 0.15);
        edgePreviewScene.add(group);
        return;
      }

      // Create the main slab body
      const slabGeometry = new THREE.BoxGeometry(slabWidth, t, slabDepth);
      const slab = new THREE.Mesh(slabGeometry, material);
      slab.position.y = t / 2;
      slab.castShadow = true;
      slab.receiveShadow = true;
      group.add(slab);

      // Create the front edge profile using extrusion
      const edgeShape = new THREE.Shape();

      // Define edge profiles - cross-section viewed from the side
      // X = depth (into slab), Y = height (thickness)
      switch(profile) {
        case 'flat-polish':
        case 'square': {
          // Perfectly square edge with polished face - no rounding
          edgeShape.moveTo(0, 0);
          edgeShape.lineTo(frontX, 0);
          edgeShape.lineTo(frontX, t);
          edgeShape.lineTo(0, t);
          break;
        }
        case 'pencil': {
          // Very small radius on top corner only (~1/16")
          const r = t * 0.08;
          edgeShape.moveTo(0, 0);
          edgeShape.lineTo(frontX, 0);
          edgeShape.lineTo(frontX, t - r);
          edgeShape.quadraticCurveTo(frontX, t, frontX - r, t);
          edgeShape.lineTo(0, t);
          break;
        }
        case 'eased': {
          // Small rounded ease on top corner (~1/8" radius)
          const r = t * 0.12;
          edgeShape.moveTo(0, 0);
          edgeShape.lineTo(frontX, 0);
          edgeShape.lineTo(frontX, t - r);
          edgeShape.quadraticCurveTo(frontX, t, frontX - r, t);
          edgeShape.lineTo(0, t);
          break;
        }
        case 'quarter-round': {
          // Quarter-circle on top corner only
          const r = t * 0.3;
          edgeShape.moveTo(0, 0);
          edgeShape.lineTo(frontX, 0);
          edgeShape.lineTo(frontX, t - r);
          // Quarter arc from vertical to horizontal
          edgeShape.absarc(frontX - r, t - r, r, 0, Math.PI / 2, false);
          edgeShape.lineTo(0, t);
          break;
        }
        case 'half-bullnose':
        case 'demi-bullnose': {
          // Rounded top half, flat/square bottom
          // The front face curves from top surface, bottom edge is square
          const r = t * 0.5;
          edgeShape.moveTo(0, 0);
          edgeShape.lineTo(frontX, 0); // Flat bottom edge
          edgeShape.lineTo(frontX, t * 0.5); // Halfway up, still flat
          // Arc from halfway to top
          edgeShape.absarc(frontX - r, t * 0.5, r, 0, Math.PI / 2, false);
          edgeShape.lineTo(0, t);
          break;
        }
        case 'full-bullnose': {
          // Complete semicircle - both top and bottom rounded
          // The entire front edge is a half-cylinder
          const r = t * 0.5;
          const centerY = t / 2;
          edgeShape.moveTo(0, 0);
          edgeShape.lineTo(frontX - r, 0); // To arc start
          // Full semicircle from bottom to top
          edgeShape.absarc(frontX - r, centerY, r, -Math.PI / 2, Math.PI / 2, false);
          edgeShape.lineTo(0, t);
          break;
        }
        case 'ogee': {
          // Classic S-curve: concave cove at top, convex bullnose below
          edgeShape.moveTo(0, 0);
          edgeShape.lineTo(frontX, 0);
          // Lower convex curve (bullnose portion)
          edgeShape.bezierCurveTo(
            frontX + t * 0.15, t * 0.15,
            frontX + t * 0.15, t * 0.35,
            frontX, t * 0.5
          );
          // Upper concave curve (cove portion)
          edgeShape.bezierCurveTo(
            frontX - t * 0.1, t * 0.65,
            frontX - t * 0.1, t * 0.85,
            frontX - t * 0.05, t
          );
          edgeShape.lineTo(0, t);
          break;
        }
        case 'double-ogee': {
          // Two S-curves stacked
          edgeShape.moveTo(0, 0);
          edgeShape.lineTo(frontX, 0);
          // First ogee (lower)
          edgeShape.bezierCurveTo(
            frontX + t * 0.08, t * 0.08,
            frontX + t * 0.08, t * 0.17,
            frontX, t * 0.25
          );
          edgeShape.bezierCurveTo(
            frontX - t * 0.06, t * 0.32,
            frontX - t * 0.06, t * 0.42,
            frontX, t * 0.5
          );
          // Second ogee (upper)
          edgeShape.bezierCurveTo(
            frontX + t * 0.08, t * 0.58,
            frontX + t * 0.08, t * 0.67,
            frontX, t * 0.75
          );
          edgeShape.bezierCurveTo(
            frontX - t * 0.06, t * 0.82,
            frontX - t * 0.06, t * 0.92,
            frontX - t * 0.03, t
          );
          edgeShape.lineTo(0, t);
          break;
        }
        case 'bevel':
        case 'quarter-bevel': {
          // 45-degree chamfer on top corner
          const bevelSize = t * 0.25;
          edgeShape.moveTo(0, 0);
          edgeShape.lineTo(frontX, 0);
          edgeShape.lineTo(frontX, t - bevelSize);
          edgeShape.lineTo(frontX - bevelSize, t);
          edgeShape.lineTo(0, t);
          break;
        }
        case 'cove': {
          // Concave (inward) curve on front face
          edgeShape.moveTo(0, 0);
          edgeShape.lineTo(frontX, 0);
          edgeShape.lineTo(frontX, t * 0.3);
          edgeShape.quadraticCurveTo(frontX - t * 0.3, t * 0.5, frontX - t * 0.1, t);
          edgeShape.lineTo(0, t);
          break;
        }
        case 'dupont': {
          // Stepped profile with bullnose top
          edgeShape.moveTo(0, 0);
          edgeShape.lineTo(frontX, 0);
          // Lower step (flat)
          edgeShape.lineTo(frontX, t * 0.35);
          // Step back
          edgeShape.lineTo(frontX - t * 0.12, t * 0.35);
          edgeShape.lineTo(frontX - t * 0.12, t * 0.5);
          // Step forward
          edgeShape.lineTo(frontX, t * 0.5);
          // Bullnose top portion
          edgeShape.bezierCurveTo(
            frontX + t * 0.1, t * 0.65,
            frontX + t * 0.1, t * 0.85,
            frontX - t * 0.05, t
          );
          edgeShape.lineTo(0, t);
          break;
        }
        case 'chiseled': {
          // Rough-hewn textured edge appearance
          edgeShape.moveTo(0, 0);
          edgeShape.lineTo(frontX - t * 0.05, 0);
          // Irregular chiseled profile
          edgeShape.lineTo(frontX, t * 0.1);
          edgeShape.lineTo(frontX - t * 0.08, t * 0.25);
          edgeShape.lineTo(frontX + t * 0.02, t * 0.4);
          edgeShape.lineTo(frontX - t * 0.05, t * 0.55);
          edgeShape.lineTo(frontX + t * 0.03, t * 0.7);
          edgeShape.lineTo(frontX - t * 0.06, t * 0.85);
          edgeShape.lineTo(frontX - t * 0.02, t);
          edgeShape.lineTo(0, t);
          break;
        }
        default: // eased as fallback
          const easeR = t * 0.1;
          edgeShape.moveTo(0, 0);
          edgeShape.lineTo(frontX, 0);
          edgeShape.lineTo(frontX, t - easeR);
          edgeShape.quadraticCurveTo(frontX, t, frontX - easeR, t);
          edgeShape.lineTo(0, t);
      }
      edgeShape.closePath();

      // Extrude along the width of the slab
      const extrudeSettings = {
        steps: 2,
        depth: slabWidth,
        bevelEnabled: false
      };

      const edgeGeometry = new THREE.ExtrudeGeometry(edgeShape, extrudeSettings);
      const edgeMesh = new THREE.Mesh(edgeGeometry, material);
      edgeMesh.name = 'edgeSample';

      // Position the edge at the front of the slab
      edgeMesh.rotation.y = -Math.PI / 2;
      edgeMesh.position.set(slabWidth / 2, 0, slabDepth / 2);
      edgeMesh.castShadow = true;
      edgeMesh.receiveShadow = true;
      group.add(edgeMesh);

      // Position group for best viewing angle
      group.position.set(-slabWidth / 2, 0, -slabDepth / 2 + 0.15);

      edgePreviewScene.add(group);
    }

    function updateEdgeProfile(profile) {
      if (!edgePreviewElement) return;

      edgePreviewElement.edgeProfile = profile;
      document.getElementById('edgeProfileName').textContent = getEdgeProfileLabel(profile);

      // Update 3D preview
      createEdgePreviewMesh(edgePreviewElement);

      // Update main canvas and 3D view
      draw();
      render3D();
    }

    function updateEdgeThickness(thickness) {
      if (!edgePreviewElement) return;

      edgePreviewElement.thickness = thickness;

      // Update button states
      const btn2cm = document.getElementById('thickness2cmBtn');
      const btn3cm = document.getElementById('thickness3cmBtn');

      if (thickness === '2cm') {
        btn2cm.style.background = 'var(--gold)';
        btn2cm.style.color = '#000';
        btn3cm.style.background = 'transparent';
        btn3cm.style.color = 'var(--text-muted)';
      } else {
        btn3cm.style.background = 'var(--gold)';
        btn3cm.style.color = '#000';
        btn2cm.style.background = 'transparent';
        btn2cm.style.color = 'var(--text-muted)';
      }

      // Update 3D preview to show thickness difference
      createEdgePreviewMesh(edgePreviewElement);

      // Update main canvas and 3D view
      draw();
      render3D();
    }

    function rotateEdgePreview(direction) {
      if (!edgePreviewCamera || !edgePreviewControls) return;

      const target = edgePreviewControls.target;

      if (direction === 'reset') {
        // Reset to default view - front-right angle showing edge profile
        edgePreviewCamera.position.set(0.8, 0.4, 1.8);
        edgePreviewControls.target.set(0, 0.05, 0.3);
      } else if (direction === 'left') {
        // Rotate camera around the target
        const angle = 0.4;
        const dx = edgePreviewCamera.position.x - target.x;
        const dz = edgePreviewCamera.position.z - target.z;
        edgePreviewCamera.position.x = target.x + dx * Math.cos(angle) + dz * Math.sin(angle);
        edgePreviewCamera.position.z = target.z - dx * Math.sin(angle) + dz * Math.cos(angle);
      } else if (direction === 'right') {
        // Rotate camera around the target
        const angle = -0.4;
        const dx = edgePreviewCamera.position.x - target.x;
        const dz = edgePreviewCamera.position.z - target.z;
        edgePreviewCamera.position.x = target.x + dx * Math.cos(angle) + dz * Math.sin(angle);
        edgePreviewCamera.position.z = target.z - dx * Math.sin(angle) + dz * Math.cos(angle);
      }
      edgePreviewControls.update();
    }

    function closeEdgePreview() {
      const modal = document.getElementById('edgePreviewModal');
      modal.classList.remove('active');

      // Cleanup
      if (edgePreviewAnimationId) {
        cancelAnimationFrame(edgePreviewAnimationId);
        edgePreviewAnimationId = null;
      }
      if (edgePreviewRenderer) {
        edgePreviewRenderer.dispose();
      }
      edgePreviewElement = null;
    }

    function applyEdgeAndClose() {
      // Edge profile already applied via updateEdgeProfile
      closeEdgePreview();
      updateProperties();
      showSnapFeedback('Edge profile updated');
    }

    function copyShareLink() {
      const input = document.getElementById('shareLink');
      if (input.value) {
        navigator.clipboard.writeText(input.value).then(() => {
          const btn = document.getElementById('copyShareBtn');
          const originalText = btn.textContent;
          btn.textContent = 'Copied!';
          setTimeout(() => btn.textContent = originalText, 2000);
        }).catch(() => {
          input.select();
          document.execCommand('copy');
          alert('Link copied!');
        });
      }
    }

    // Social sharing functionality
    async function shareToSocial(platform) {
      const shareUrl = document.getElementById('shareLink').value;
      const projectName = document.getElementById('projectName').value || 'My Room Design';
      const description = `Check out my ${document.getElementById('roomType').value || 'room'} design created with Surprise Granite Room Designer!`;

      if (!shareUrl && platform !== 'download') {
        showToast('Please generate a share link first', 'warning');
        return;
      }

      switch (platform) {
        case 'email':
          const emailSubject = encodeURIComponent(`${projectName} - Room Design`);
          const emailBody = encodeURIComponent(`${description}\n\nView design: ${shareUrl}`);
          window.open(`mailto:?subject=${emailSubject}&body=${emailBody}`, '_blank');
          break;

        case 'pinterest':
          // Pinterest requires an image URL - capture current view
          try {
            const imageUrl = await captureDesignImage();
            const pinUrl = `https://pinterest.com/pin/create/button/?url=${encodeURIComponent(shareUrl)}&media=${encodeURIComponent(imageUrl)}&description=${encodeURIComponent(description)}`;
            window.open(pinUrl, '_blank', 'width=750,height=550');
          } catch (err) {
            // Fallback without image
            const pinUrl = `https://pinterest.com/pin/create/button/?url=${encodeURIComponent(shareUrl)}&description=${encodeURIComponent(description)}`;
            window.open(pinUrl, '_blank', 'width=750,height=550');
          }
          break;

        case 'facebook':
          const fbUrl = `https://www.facebook.com/sharer/sharer.php?u=${encodeURIComponent(shareUrl)}&quote=${encodeURIComponent(description)}`;
          window.open(fbUrl, '_blank', 'width=600,height=400');
          break;

        case 'download':
          await downloadDesignImage();
          break;
      }
    }

    // Capture current design as image data URL
    async function captureDesignImage() {
      return new Promise((resolve, reject) => {
        try {
          let canvas;
          if (currentView === '3d' && renderer) {
            renderer.render(scene, camera);
            canvas = renderer.domElement;
          } else {
            canvas = document.getElementById('canvas');
          }

          const dataUrl = canvas.toDataURL('image/png');
          resolve(dataUrl);
        } catch (err) {
          reject(err);
        }
      });
    }

    // Download design as image
    async function downloadDesignImage() {
      try {
        const projectName = document.getElementById('projectName').value || 'room-design';
        const viewType = currentView === '3d' ? '3d' : '2d';

        let canvas;
        if (currentView === '3d' && renderer) {
          renderer.render(scene, camera);
          canvas = renderer.domElement;
        } else {
          canvas = document.getElementById('canvas');
        }

        const link = document.createElement('a');
        link.download = `${projectName.replace(/\s+/g, '-')}-${viewType}.png`;
        link.href = canvas.toDataURL('image/png');
        link.click();

        showToast('Image downloaded successfully', 'success');
      } catch (err) {
        console.error('Failed to download image:', err);
        showToast('Failed to download image', 'error');
      }
    }

    function setSharePermission(perm, btn) {
      document.querySelectorAll('#shareModal .permission-btn').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
    }

    // ===== PRICE LIST MODAL FUNCTIONS =====
    let pendingPriceData = null;

    // openPriceListModal is defined later (shows labor tab by default)

    function showPriceTab(tab) {
      document.querySelectorAll('.price-tab').forEach(t => t.style.display = 'none');
      document.querySelectorAll('.price-list-tabs .tab-btn').forEach(b => b.classList.remove('active'));

      document.getElementById('priceTab' + tab.charAt(0).toUpperCase() + tab.slice(1)).style.display = 'block';
      event.target.classList.add('active');
    }

    // Handle price list file upload
    async function handlePriceListUpload(event) {
      const file = event.target.files[0];
      if (!file) return;

      const extension = file.name.split('.').pop().toLowerCase();

      try {
        let data;
        if (extension === 'csv') {
          data = await parseCSVFile(file);
        } else if (['xlsx', 'xls'].includes(extension)) {
          data = await parseExcelFile(file);
        } else {
          throw new Error('Unsupported file format. Please use .xlsx, .xls, or .csv');
        }

        showColumnMapping(data);
      } catch (error) {
        alert('Error parsing file: ' + error.message);
        console.error(error);
      }
    }

    // Parse Excel file using SheetJS
    async function parseExcelFile(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = (e) => {
          try {
            if (typeof XLSX === 'undefined') {
              throw new Error('Excel parser not loaded. Please refresh the page.');
            }
            const data = new Uint8Array(e.target.result);
            const workbook = XLSX.read(data, { type: 'array' });
            const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
            const jsonData = XLSX.utils.sheet_to_json(firstSheet, { header: 1 });

            resolve({
              headers: jsonData[0] || [],
              rows: jsonData.slice(1).filter(row => row.some(cell => cell !== null && cell !== '')),
              raw: jsonData
            });
          } catch (err) {
            reject(err);
          }
        };
        reader.onerror = () => reject(new Error('Failed to read file'));
        reader.readAsArrayBuffer(file);
      });
    }

    // Parse CSV file
    async function parseCSVFile(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = (e) => {
          try {
            const text = e.target.result;
            const lines = text.split(/\r?\n/).filter(line => line.trim());
            const rows = lines.map(line => {
              const matches = line.match(/("([^"]*)"|[^,]+)/g) || [];
              return matches.map(val => val.replace(/^"|"$/g, '').trim());
            });

            resolve({
              headers: rows[0] || [],
              rows: rows.slice(1),
              raw: rows
            });
          } catch (err) {
            reject(err);
          }
        };
        reader.onerror = () => reject(new Error('Failed to read file'));
        reader.readAsText(file);
      });
    }

    function showColumnMapping(data) {
      pendingPriceData = data;

      document.getElementById('priceListDropzone').style.display = 'none';
      document.getElementById('columnMapping').style.display = 'block';

      const headers = data.headers;
      const optionsHtml = '<option value="">-- Select --</option>' +
        headers.map((h, i) => `<option value="${i}">${h}</option>`).join('');

      document.getElementById('mapMaterialId').innerHTML = optionsHtml;
      document.getElementById('mapMaterialName').innerHTML = optionsHtml;
      document.getElementById('mapPrice').innerHTML = optionsHtml;
      document.getElementById('mapUnit').innerHTML = '<option value="">None</option>' +
        headers.map((h, i) => `<option value="${i}">${h}</option>`).join('');

      // Auto-detect columns by name
      headers.forEach((h, i) => {
        const lower = String(h).toLowerCase();
        if (lower.includes('sku') || lower.includes('id') || lower.includes('code') || lower.includes('item')) {
          document.getElementById('mapMaterialId').value = i;
        }
        if (lower.includes('name') || lower.includes('material') || lower.includes('product') || lower.includes('description')) {
          document.getElementById('mapMaterialName').value = i;
        }
        if (lower.includes('price') || lower.includes('cost') || lower.includes('rate') || lower.includes('amount')) {
          document.getElementById('mapPrice').value = i;
        }
        if (lower.includes('unit') || lower.includes('uom')) {
          document.getElementById('mapUnit').value = i;
        }
      });

      updateMappingPreview();
    }

    function updateMappingPreview() {
      if (!pendingPriceData) return;

      const idCol = parseInt(document.getElementById('mapMaterialId').value);
      const nameCol = parseInt(document.getElementById('mapMaterialName').value);
      const priceCol = parseInt(document.getElementById('mapPrice').value);

      const preview = document.getElementById('mappingPreview');
      const sampleRows = pendingPriceData.rows.slice(0, 5);

      preview.innerHTML = `
        <table class="preview-table">
          <thead>
            <tr>
              <th>SKU/ID</th>
              <th>Name</th>
              <th>Price</th>
            </tr>
          </thead>
          <tbody>
            ${sampleRows.map(row => `
              <tr>
                <td>${isNaN(idCol) ? '-' : (row[idCol] || '-')}</td>
                <td>${isNaN(nameCol) ? '-' : (row[nameCol] || '-')}</td>
                <td>${isNaN(priceCol) ? '-' : formatPriceValue(row[priceCol])}</td>
              </tr>
            `).join('')}
          </tbody>
        </table>
        <p class="preview-count" style="margin-top:8px;font-size:12px;color:var(--text-muted);">${pendingPriceData.rows.length} items found</p>
      `;
    }

    function formatPriceValue(value) {
      if (!value) return '-';
      const num = parseFloat(String(value).replace(/[$,]/g, ''));
      return isNaN(num) ? '-' : '$' + num.toFixed(2);
    }

    function applyPriceList() {
      if (!pendingPriceData) return;

      const idCol = parseInt(document.getElementById('mapMaterialId').value);
      const nameCol = parseInt(document.getElementById('mapMaterialName').value);
      const priceCol = parseInt(document.getElementById('mapPrice').value);

      if (isNaN(priceCol)) {
        alert('Please select the Price column');
        return;
      }

      let matched = 0;
      let updated = 0;

      pendingPriceData.rows.forEach(row => {
        const id = !isNaN(idCol) ? String(row[idCol] || '').trim() : null;
        const name = !isNaN(nameCol) ? String(row[nameCol] || '').trim() : null;
        const price = parseFloat(String(row[priceCol] || '').replace(/[$,]/g, ''));

        if (isNaN(price) || price <= 0) return;

        // Store by ID in custom prices
        if (id) {
          PRICING_STATE.customPrices[id] = price;
        }

        // Update MATERIALS object for SKU/name matches
        for (const category in MATERIALS) {
          MATERIALS[category].forEach(mat => {
            if ((mat.sku && mat.sku === id) ||
                (mat.id && mat.id === id) ||
                (mat.name && name && mat.name.toLowerCase() === name.toLowerCase())) {
              mat.price = price;
              matched++;
            }
          });
        }
        updated++;
      });

      PRICING_STATE.activePriceList = 'Custom Import (' + new Date().toLocaleDateString() + ')';

      alert(`Price list applied!\n${updated} prices imported\n${matched} materials updated`);

      closeModal('priceListModal');
      calculateQuote();
      resetPriceUpload();
    }

    function cancelPriceUpload() {
      resetPriceUpload();
    }

    function resetPriceUpload() {
      pendingPriceData = null;
      document.getElementById('priceListDropzone').style.display = 'block';
      document.getElementById('columnMapping').style.display = 'none';
      document.getElementById('priceListFile').value = '';
    }

    function renderCurrentPrices() {
      const list = document.getElementById('currentPricesList');
      if (!list) return;

      let html = '';
      for (const category in MATERIALS) {
        const materials = MATERIALS[category].filter(m => m.price);
        if (materials.length === 0) continue;

        html += `<div class="price-category-header">${category.charAt(0).toUpperCase() + category.slice(1)}</div>`;
        materials.forEach(m => {
          html += `
            <div class="current-price-item">
              <span class="price-item-name">${m.name}</span>
              <span class="price-item-sku">${m.sku || '-'}</span>
              <span class="price-item-value">$${m.price.toFixed(2)}</span>
            </div>
          `;
        });
      }

      list.innerHTML = html || '<p class="empty-state">No priced materials</p>';
    }

    function filterCurrentPrices() {
      const query = document.getElementById('priceSearchInput').value.toLowerCase();
      const items = document.querySelectorAll('.current-price-item');
      items.forEach(item => {
        const name = item.querySelector('.price-item-name').textContent.toLowerCase();
        item.style.display = name.includes(query) ? 'flex' : 'none';
      });
    }

    // ===== LABOR RATES MANAGEMENT =====
    // Store for user-modified labor rates (loaded from localStorage)
    let userLaborRates = JSON.parse(localStorage.getItem('sg_labor_rates') || 'null') || JSON.parse(JSON.stringify(LABOR_RATES));
    let userMaterialPricing = JSON.parse(localStorage.getItem('sg_material_pricing') || 'null') || JSON.parse(JSON.stringify(MATERIAL_PRICING));

    // Toggle labor category accordion
    function toggleLaborCategory(category) {
      const container = document.getElementById('laborItems' + category.charAt(0).toUpperCase() + category.slice(1));
      const parentCategory = container.closest('.labor-category');

      // Toggle expanded state
      parentCategory.classList.toggle('expanded');

      // Render items if expanding and empty
      if (parentCategory.classList.contains('expanded') && container.innerHTML === '') {
        renderLaborCategoryItems(category);
      }
    }

    // Render items for a specific labor category
    function renderLaborCategoryItems(category) {
      const container = document.getElementById('laborItems' + category.charAt(0).toUpperCase() + category.slice(1));
      if (!container) return;

      const items = userLaborRates[category];
      if (!items) return;

      let html = '';
      for (const [key, item] of Object.entries(items)) {
        const unitLabels = {
          'sqft': '/ sq ft',
          'lf': '/ lin ft',
          'cabinet': '/ cabinet',
          'each': '/ each',
          'hour': '/ hour',
          'visit': '/ visit',
          'trip': '/ trip',
          'permit': '/ permit',
          'piece': '/ piece',
          'location': '/ location',
          'load': '/ load',
          'percent': '%'
        };

        html += `
          <div class="labor-item">
            <span class="labor-item-label">${item.label}</span>
            <div class="labor-item-rate">
              <span style="color: var(--text-muted); font-size: 12px;">${item.unit === 'percent' ? '' : '$'}</span>
              <input type="number"
                     id="laborRate_${category}_${key}"
                     value="${item.rate}"
                     min="0"
                     step="${item.unit === 'percent' ? '1' : '0.01'}"
                     onchange="updateLaborRate('${category}', '${key}', this.value)">
              <span class="labor-item-unit">${unitLabels[item.unit] || item.unit}</span>
            </div>
          </div>
        `;
      }

      container.innerHTML = html;
    }

    // Update a specific labor rate
    function updateLaborRate(category, key, value) {
      const numValue = parseFloat(value) || 0;
      if (userLaborRates[category] && userLaborRates[category][key]) {
        userLaborRates[category][key].rate = numValue;
      }
    }

    // Save all labor rates to localStorage
    function saveLaborRates() {
      localStorage.setItem('sg_labor_rates', JSON.stringify(userLaborRates));
      showNotification('Labor rates saved successfully!', 'success');

      // Recalculate quote if open
      calculateQuote();
    }

    // Reset labor rates to defaults
    function resetLaborRates() {
      if (!confirm('Reset all labor rates to default values?')) return;

      userLaborRates = JSON.parse(JSON.stringify(LABOR_RATES));
      localStorage.removeItem('sg_labor_rates');

      // Re-render all expanded categories
      document.querySelectorAll('.labor-category.expanded').forEach(cat => {
        const itemsContainer = cat.querySelector('.labor-category-items');
        if (itemsContainer && itemsContainer.id) {
          const categoryName = itemsContainer.id.replace('laborItems', '').toLowerCase();
          renderLaborCategoryItems(categoryName);
        }
      });

      showNotification('Labor rates reset to defaults', 'info');
    }

    // Initialize labor rates tab when opening
    function initLaborRatesTab() {
      // Expand first category by default
      const firstCategory = document.querySelector('.labor-category');
      if (firstCategory && !firstCategory.classList.contains('expanded')) {
        firstCategory.classList.add('expanded');
        renderLaborCategoryItems('stone');
      }
    }

    // ===== MATERIAL PRICING MANAGEMENT =====
    // Render slab materials pricing
    function renderSlabMaterials() {
      const container = document.getElementById('slabMaterialsList');
      if (!container) return;

      let html = '';
      for (const [key, mat] of Object.entries(userMaterialPricing.slabMaterials)) {
        html += `
          <div class="material-price-row">
            <span class="material-price-label">${mat.label}</span>
            <div class="material-price-inputs">
              <span>$</span>
              <input type="number"
                     id="slabPrice_${key}"
                     value="${mat.slabPrice}"
                     min="0"
                     step="1"
                     placeholder="Slab price"
                     onchange="updateSlabPrice('${key}', this.value)">
              <span>/ slab (~${mat.slabSqft} sqft)</span>
            </div>
          </div>
        `;
      }

      container.innerHTML = html;
    }

    // Render sqft materials pricing
    function renderSqftMaterials() {
      const container = document.getElementById('sqftMaterialsList');
      if (!container) return;

      let html = '';
      for (const [key, mat] of Object.entries(userMaterialPricing.sqftMaterials)) {
        html += `
          <div class="material-price-row">
            <span class="material-price-label">${mat.label}</span>
            <div class="material-price-inputs">
              <span>$</span>
              <input type="number"
                     id="sqftPrice_${key}"
                     value="${mat.pricePerSqft}"
                     min="0"
                     step="0.01"
                     placeholder="Price / sqft"
                     onchange="updateSqftPrice('${key}', this.value)">
              <span>/ sq ft</span>
            </div>
          </div>
        `;
      }

      container.innerHTML = html;
    }

    // Update slab material price
    function updateSlabPrice(key, value) {
      const numValue = parseFloat(value) || 0;
      if (userMaterialPricing.slabMaterials[key]) {
        userMaterialPricing.slabMaterials[key].slabPrice = numValue;
      }
    }

    // Update sqft material price
    function updateSqftPrice(key, value) {
      const numValue = parseFloat(value) || 0;
      if (userMaterialPricing.sqftMaterials[key]) {
        userMaterialPricing.sqftMaterials[key].pricePerSqft = numValue;
      }
    }

    // Save material pricing
    function saveMaterialPricing() {
      localStorage.setItem('sg_material_pricing', JSON.stringify(userMaterialPricing));
      showNotification('Material pricing saved!', 'success');
      calculateQuote();
    }

    // Initialize materials tab
    function initMaterialsTab() {
      renderSlabMaterials();
      renderSqftMaterials();
    }

    // Override showPriceTab to initialize tabs
    const _originalShowPriceTab = showPriceTab;
    showPriceTab = function(tab) {
      // Hide all tabs
      document.querySelectorAll('.price-tab').forEach(t => t.style.display = 'none');
      document.querySelectorAll('.price-list-tabs .tab-btn').forEach(b => b.classList.remove('active'));

      // Show selected tab
      const tabId = 'priceTab' + tab.charAt(0).toUpperCase() + tab.slice(1);
      const tabEl = document.getElementById(tabId);
      if (tabEl) tabEl.style.display = 'block';

      // Find and activate the clicked button
      document.querySelectorAll('.price-list-tabs .tab-btn').forEach(b => {
        if (b.textContent.toLowerCase().includes(tab.toLowerCase().replace('upload', 'up').replace('saved', 'sav'))) {
          b.classList.add('active');
        }
      });

      // Initialize tab-specific content
      if (tab === 'labor') {
        initLaborRatesTab();
      } else if (tab === 'materials') {
        initMaterialsTab();
      }
    };

    // Override openPriceListModal to show labor tab by default
    function openPriceListModal() {
      document.getElementById('priceListModal').classList.add('active');
      showPriceTab('labor');
    }

    // ===== ROOM MANAGEMENT =====
    // Room colors for visual distinction
    const ROOM_COLORS = [
      '#6366f1', // Indigo
      '#10b981', // Emerald
      '#f59e0b', // Amber
      '#ef4444', // Red
      '#8b5cf6', // Purple
      '#06b6d4', // Cyan
      '#ec4899', // Pink
      '#84cc16'  // Lime
    ];

    // Rooms storage - loaded from localStorage
    let projectRooms = JSON.parse(localStorage.getItem('sg_project_rooms') || 'null') || [
      { id: 'default', name: 'Default Room', color: '#6366f1' }
    ];
    let currentRoom = 'default';

    // Initialize room selector
    function initRoomSelector() {
      const select = document.getElementById('currentRoomSelect');
      if (!select) return;

      select.innerHTML = projectRooms.map(room =>
        `<option value="${room.id}" ${room.id === currentRoom ? 'selected' : ''}>${room.name}</option>`
      ).join('');
    }

    // Switch active room
    function switchRoom(roomId) {
      currentRoom = roomId;
      localStorage.setItem('sg_current_room', currentRoom);

      // Update elements display (could filter by room)
      calculateQuote();
    }

    // Open room manager modal
    function openRoomManager() {
      renderRoomList();
      document.getElementById('roomManagerModal').classList.add('active');
    }

    // Render room list in manager
    function renderRoomList() {
      const list = document.getElementById('roomList');
      if (!list) return;

      if (projectRooms.length === 0) {
        list.innerHTML = '<p class="empty-state">No rooms created yet</p>';
        return;
      }

      // Count elements per room
      const roomCounts = {};
      elements.forEach(el => {
        const room = el.roomId || 'default';
        roomCounts[room] = (roomCounts[room] || 0) + 1;
      });

      list.innerHTML = projectRooms.map(room => `
        <div class="room-list-item" data-room-id="${room.id}">
          <div class="room-color" style="background: ${room.color};"></div>
          <div class="room-name">${room.name}</div>
          <div class="room-count">${roomCounts[room.id] || 0} items</div>
          <div class="room-actions">
            <button onclick="editRoom('${room.id}')" title="Edit">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:14px;height:14px;">
                <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/>
                <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/>
              </svg>
            </button>
            ${room.id !== 'default' ? `
              <button class="delete" onclick="deleteRoom('${room.id}')" title="Delete">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:14px;height:14px;">
                  <polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/>
                </svg>
              </button>
            ` : ''}
          </div>
        </div>
      `).join('');
    }

    // Add new room
    function addRoom() {
      const nameInput = document.getElementById('newRoomName');
      const name = nameInput.value.trim();

      if (!name) {
        showNotification('Please enter a room name', 'error');
        return;
      }

      // Check for duplicate
      if (projectRooms.some(r => r.name.toLowerCase() === name.toLowerCase())) {
        showNotification('A room with this name already exists', 'error');
        return;
      }

      const newRoom = {
        id: 'room_' + Date.now(),
        name: name,
        color: ROOM_COLORS[projectRooms.length % ROOM_COLORS.length]
      };

      projectRooms.push(newRoom);
      saveRooms();

      nameInput.value = '';
      renderRoomList();
      initRoomSelector();

      showNotification(`Room "${name}" created`, 'success');
    }

    // Edit room
    function editRoom(roomId) {
      const room = projectRooms.find(r => r.id === roomId);
      if (!room) return;

      const newName = prompt('Enter new room name:', room.name);
      if (newName && newName.trim()) {
        room.name = newName.trim();
        saveRooms();
        renderRoomList();
        initRoomSelector();
      }
    }

    // Delete room
    function deleteRoom(roomId) {
      if (roomId === 'default') return;

      const room = projectRooms.find(r => r.id === roomId);
      if (!room) return;

      if (!confirm(`Delete room "${room.name}"? Elements in this room will be moved to Default Room.`)) return;

      // Move elements to default room
      elements.forEach(el => {
        if (el.roomId === roomId) {
          el.roomId = 'default';
        }
      });

      projectRooms = projectRooms.filter(r => r.id !== roomId);
      saveRooms();

      if (currentRoom === roomId) {
        currentRoom = 'default';
      }

      renderRoomList();
      initRoomSelector();
      calculateQuote();

      showNotification('Room deleted', 'info');
    }

    // Save rooms to localStorage
    function saveRooms() {
      localStorage.setItem('sg_project_rooms', JSON.stringify(projectRooms));
    }

    // Assign element to room
    function assignElementToRoom(elementId, roomId) {
      const el = elements.find(e => e.id === elementId);
      if (el) {
        el.roomId = roomId;
        calculateQuote();
      }
    }

    // ===== QUOTE PREVIEW MODAL =====
    let quotePreviewData = {};
    let quoteTaxRate = 0;

    function openQuotePreview() {
      // Build quote data with editable prices
      buildQuotePreviewData();

      // Populate room filter
      const roomFilter = document.getElementById('quoteRoomFilter');
      roomFilter.innerHTML = '<option value="all">All Rooms</option>' +
        projectRooms.map(r => `<option value="${r.id}">${r.name}</option>`).join('');

      // Render quote items
      renderQuotePreviewTable('all');

      // Update totals
      updateQuotePreviewTotals();

      // Pre-fill customer info - priority: lead info > saved customer > empty
      if (currentLeadInfo && currentLeadInfo.name) {
        // Use lead info (from account dashboard)
        document.getElementById('quoteCustomerName').value = currentLeadInfo.name || '';
        document.getElementById('quoteCustomerEmail').value = currentLeadInfo.email || '';
        document.getElementById('quoteCustomerPhone').value = currentLeadInfo.phone || '';
        document.getElementById('quoteProjectName').value = currentProjectName || `${currentLeadInfo.projectType || ''} Project`.trim();

        // Pre-fill notes with lead message if available
        if (currentLeadInfo.notes) {
          document.getElementById('quoteNotes').value = `Customer Request: ${currentLeadInfo.notes}`;
        }
      } else {
        // Load saved customer info if any
        const savedCustomer = JSON.parse(localStorage.getItem('sg_quote_customer') || '{}');
        document.getElementById('quoteCustomerName').value = savedCustomer.name || '';
        document.getElementById('quoteCustomerEmail').value = savedCustomer.email || '';
        document.getElementById('quoteCustomerPhone').value = savedCustomer.phone || '';
        document.getElementById('quoteProjectName').value = currentProjectName || '';
      }

      document.getElementById('quotePreviewModal').classList.add('active');
    }

    function buildQuotePreviewData() {
      quotePreviewData = { items: [], roomTotals: {} };

      // Process elements similar to calculateQuote but store editable data
      const COUNTERTOP_TYPES = ['countertop', 'countertop-corner', 'countertop-l', 'countertop-u', 'island'];
      const CABINET_TYPES = ['base-cabinet', 'wall-cabinet', 'tall-cabinet', 'corner-cabinet', 'sink-base', 'drawer-base', 'lazy-susan', 'fridge-cabinet', 'pantry', 'blind-corner'];

      elements.forEach(el => {
        const roomId = el.roomId || 'default';
        const priceInfo = getElementPrice(el);
        const margin = getElementMargin(el);

        const isCountertop = COUNTERTOP_TYPES.some(ct => el.type.includes(ct) || el.type === ct);
        const isCabinet = CABINET_TYPES.some(ct => el.type.includes(ct) || el.type === ct);

        let sqft = 0;
        let baseCost = 0;
        let qty = 1;
        let unit = 'unit';

        if (isCountertop || el.type.includes('backsplash') || el.type.includes('flooring')) {
          sqft = getElementSqft(el);
          baseCost = sqft * priceInfo.price;
          qty = sqft;
          unit = 'sqft';
        } else {
          baseCost = priceInfo.price;
        }

        // Use override prices if set, otherwise calculate
        const costPrice = el.overrideCost !== undefined ? el.overrideCost : baseCost;
        const retailPrice = el.overrideRetail !== undefined ? el.overrideRetail : baseCost * (1 + margin / 100);

        quotePreviewData.items.push({
          id: el.id,
          elementRef: el,
          roomId: roomId,
          label: el.label || el.type,
          type: el.type,
          isCountertop,
          isCabinet,
          isLabor: false,
          qty: qty,
          unit: unit,
          sqft: sqft,
          baseCost: baseCost,
          costPrice: costPrice,
          retailPrice: retailPrice,
          margin: margin,
          isOverridden: el.overrideCost !== undefined || el.overrideRetail !== undefined
        });

        // Track room totals
        if (!quotePreviewData.roomTotals[roomId]) {
          quotePreviewData.roomTotals[roomId] = { cost: 0, retail: 0 };
        }
        quotePreviewData.roomTotals[roomId].cost += costPrice;
        quotePreviewData.roomTotals[roomId].retail += retailPrice;
      });

      // Add labor items
      const totalCountertopSqft = quotePreviewData.items
        .filter(i => i.isCountertop)
        .reduce((sum, i) => sum + i.sqft, 0);

      const totalCabinetCount = quotePreviewData.items
        .filter(i => i.isCabinet)
        .length;

      if (totalCountertopSqft > 0 && userLaborRates.stone) {
        const fabRate = userLaborRates.stone.fabrication?.rate || 0;
        const installRate = userLaborRates.stone.installation?.rate || 0;
        const laborMargin = PRICING_STATE.categoryMargins.labor || 20;

        if (fabRate > 0) {
          const fabCost = totalCountertopSqft * fabRate;
          quotePreviewData.items.push({
            id: 'labor-fab',
            roomId: 'labor',
            label: `Stone Fabrication (${totalCountertopSqft.toFixed(1)} sqft)`,
            type: 'labor',
            isLabor: true,
            qty: totalCountertopSqft,
            unit: 'sqft',
            baseCost: fabCost,
            costPrice: fabCost,
            retailPrice: fabCost * (1 + laborMargin / 100),
            margin: laborMargin
          });
        }

        if (installRate > 0) {
          const installCost = totalCountertopSqft * installRate;
          quotePreviewData.items.push({
            id: 'labor-install',
            roomId: 'labor',
            label: `Countertop Installation (${totalCountertopSqft.toFixed(1)} sqft)`,
            type: 'labor',
            isLabor: true,
            qty: totalCountertopSqft,
            unit: 'sqft',
            baseCost: installCost,
            costPrice: installCost,
            retailPrice: installCost * (1 + laborMargin / 100),
            margin: laborMargin
          });
        }
      }

      if (totalCabinetCount > 0 && userLaborRates.cabinet) {
        const cabInstallRate = userLaborRates.cabinet.installation?.rate || 0;
        const laborMargin = PRICING_STATE.categoryMargins.labor || 20;

        if (cabInstallRate > 0) {
          const cabInstallCost = totalCabinetCount * cabInstallRate;
          quotePreviewData.items.push({
            id: 'labor-cab',
            roomId: 'labor',
            label: `Cabinet Installation (${totalCabinetCount} cabinets)`,
            type: 'labor',
            isLabor: true,
            qty: totalCabinetCount,
            unit: 'cabinet',
            baseCost: cabInstallCost,
            costPrice: cabInstallCost,
            retailPrice: cabInstallCost * (1 + laborMargin / 100),
            margin: laborMargin
          });
        }
      }
    }

    function renderQuotePreviewTable(filterRoom) {
      const tbody = document.getElementById('quotePreviewBody');
      if (!tbody) return;

      let html = '';
      let currentRoomId = null;

      // Sort items by room
      const sortedItems = [...quotePreviewData.items].sort((a, b) => {
        if (a.roomId === b.roomId) return 0;
        if (a.roomId === 'labor') return 1;
        if (b.roomId === 'labor') return -1;
        return a.roomId.localeCompare(b.roomId);
      });

      // Filter by room if needed
      const filteredItems = filterRoom === 'all'
        ? sortedItems
        : sortedItems.filter(i => i.roomId === filterRoom || i.roomId === 'labor');

      filteredItems.forEach((item, index) => {
        // Add room header if room changed
        if (item.roomId !== currentRoomId && filterRoom === 'all') {
          const room = item.roomId === 'labor'
            ? { name: 'Labor & Services', color: '#6366f1' }
            : projectRooms.find(r => r.id === item.roomId) || { name: 'Unknown', color: '#888' };

          html += `
            <tr class="room-header">
              <td colspan="6">
                <span style="display: inline-block; width: 12px; height: 12px; border-radius: 3px; background: ${room.color}; margin-right: 8px;"></span>
                ${room.name}
              </td>
            </tr>
          `;
          currentRoomId = item.roomId;
        }

        // Determine icon
        let iconClass = 'other';
        let iconSymbol = '';
        if (item.isCountertop) {
          iconClass = 'countertop';
          iconSymbol = '';
        } else if (item.isCabinet) {
          iconClass = 'cabinet';
          iconSymbol = '';
        } else if (item.isLabor) {
          iconClass = 'labor';
          iconSymbol = '';
        }

        // Calculate current margin
        const currentMargin = item.costPrice > 0 ? ((item.retailPrice / item.costPrice - 1) * 100).toFixed(0) : 0;
        const marginClass = currentMargin < 15 ? 'low' : 'high';

        html += `
          <tr data-item-id="${item.id}">
            <td><div class="quote-item-type-icon ${iconClass}">${iconSymbol}</div></td>
            <td>
              <div style="font-weight: 500;">${item.label}</div>
              ${item.sqft > 0 ? `<div style="font-size: 11px; color: var(--text-muted);">${item.sqft.toFixed(1)} sqft</div>` : ''}
            </td>
            <td style="text-align: center;">${item.qty > 1 ? (item.unit === 'sqft' ? item.qty.toFixed(1) : item.qty) : '1'}</td>
            <td>
              <input type="number"
                     class="quote-editable-input ${item.isOverridden ? 'modified' : ''}"
                     value="${item.costPrice.toFixed(2)}"
                     step="0.01"
                     min="0"
                     onchange="updateQuoteItemCost('${item.id}', this.value)"
                     ${item.isLabor ? 'readonly' : ''}>
            </td>
            <td>
              <input type="number"
                     class="quote-editable-input ${item.isOverridden ? 'modified' : ''}"
                     value="${item.retailPrice.toFixed(2)}"
                     step="0.01"
                     min="0"
                     onchange="updateQuoteItemRetail('${item.id}', this.value)">
            </td>
            <td><span class="quote-margin-badge ${marginClass}">${currentMargin}%</span></td>
          </tr>
        `;
      });

      tbody.innerHTML = html || '<tr><td colspan="6" style="text-align: center; padding: 40px; color: var(--text-muted);">No items in quote</td></tr>';
    }

    function updateQuoteItemCost(itemId, value) {
      const item = quotePreviewData.items.find(i => i.id === itemId);
      if (!item) return;

      const newCost = parseFloat(value) || 0;
      item.costPrice = newCost;
      item.isOverridden = true;

      // Update element if it's a design element
      if (item.elementRef) {
        item.elementRef.overrideCost = newCost;
      }

      updateQuotePreviewTotals();
    }

    function updateQuoteItemRetail(itemId, value) {
      const item = quotePreviewData.items.find(i => i.id === itemId);
      if (!item) return;

      const newRetail = parseFloat(value) || 0;
      item.retailPrice = newRetail;
      item.isOverridden = true;

      // Update element if it's a design element
      if (item.elementRef) {
        item.elementRef.overrideRetail = newRetail;
      }

      // Update margin badge
      const row = document.querySelector(`tr[data-item-id="${itemId}"]`);
      if (row) {
        const margin = item.costPrice > 0 ? ((newRetail / item.costPrice - 1) * 100).toFixed(0) : 0;
        const badge = row.querySelector('.quote-margin-badge');
        if (badge) {
          badge.textContent = margin + '%';
          badge.className = 'quote-margin-badge ' + (margin < 15 ? 'low' : 'high');
        }
      }

      updateQuotePreviewTotals();
    }

    function updateQuoteTax(value) {
      quoteTaxRate = parseFloat(value) || 0;
      updateQuotePreviewTotals();
    }

    function updateQuotePreviewTotals() {
      const subtotal = quotePreviewData.items.reduce((sum, i) => sum + i.retailPrice, 0);
      const tax = subtotal * (quoteTaxRate / 100);
      const total = subtotal + tax;

      document.getElementById('quotePreviewSubtotal').textContent = '$' + subtotal.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2});
      document.getElementById('quotePreviewTax').textContent = '$' + tax.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2});
      document.getElementById('quotePreviewTotal').textContent = '$' + total.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2});
      document.getElementById('quoteTaxRate').textContent = quoteTaxRate;
    }

    function filterQuoteByRoom(roomId) {
      renderQuotePreviewTable(roomId);
    }

    // ===== QUOTE SHARING =====
    async function shareQuoteLink() {
      document.getElementById('generatedLinkSection').style.display = 'none';
      document.getElementById('generateLinkBtn').textContent = 'Generate Link';
      document.getElementById('shareQuoteModal').classList.add('active');
    }

    async function generateQuoteShareLink() {
      const btn = document.getElementById('generateLinkBtn');
      btn.textContent = 'Generating...';
      btn.disabled = true;

      try {
        // Save design to Supabase for sharing
        const shareData = {
          projectName: currentProjectName || 'Untitled Design',
          customerEmail: document.getElementById('shareCustomerEmail').value || null,
          showPricing: document.getElementById('shareShowPricing').checked,
          allowDeposit: document.getElementById('shareAllowDeposit').checked,
          allowSchedule: document.getElementById('shareAllowSchedule').checked,
          expiryDays: parseInt(document.getElementById('shareLinkExpiry').value),
          rooms: projectRooms,
          elements: elements.map(el => ({
            ...el,
            // Strip out Three.js objects
            mesh: undefined,
            object3D: undefined
          })),
          quoteItems: quotePreviewData.items,
          totalRetail: quotePreviewData.items.reduce((sum, i) => sum + i.retailPrice, 0),
          createdAt: new Date().toISOString()
        };

        // Generate unique share ID
        const shareId = 'sq_' + Date.now().toString(36) + Math.random().toString(36).substr(2, 9);

        // Save to Supabase
        const { data, error } = await supabaseClient
          .from('shared_quotes')
          .insert({
            share_id: shareId,
            project_name: shareData.projectName,
            customer_email: shareData.customerEmail,
            show_pricing: shareData.showPricing,
            allow_deposit: shareData.allowDeposit,
            allow_schedule: shareData.allowSchedule,
            expires_at: shareData.expiryDays > 0 ? new Date(Date.now() + shareData.expiryDays * 24 * 60 * 60 * 1000).toISOString() : null,
            data: shareData,
            lead_id: currentLeadInfo?.id || window.currentLeadId || null,
            created_by: (await supabaseClient.auth.getUser()).data?.user?.id || null
          })
          .select()
          .single();

        // If linked to a lead, update lead status to "quoted"
        if (currentLeadInfo?.id || window.currentLeadId) {
          await supabaseClient
            .from('leads')
            .update({ status: 'quoted', updated_at: new Date().toISOString() })
            .eq('id', currentLeadInfo?.id || window.currentLeadId);
        }

        if (error) throw error;

        // Generate shareable URL
        const shareUrl = `${window.location.origin}/quote/view/?id=${shareId}`;

        document.getElementById('generatedShareLink').value = shareUrl;
        document.getElementById('generatedLinkSection').style.display = 'block';

        btn.textContent = 'Link Generated!';
        setTimeout(() => {
          btn.textContent = 'Generate New Link';
          btn.disabled = false;
        }, 2000);

        showNotification('Share link generated!', 'success');

      } catch (error) {
        console.error('Error generating share link:', error);

        // Fallback: create a local share link with encoded data
        const encodedData = btoa(JSON.stringify({
          name: currentProjectName,
          items: quotePreviewData.items.slice(0, 20), // Limit for URL length
          total: quotePreviewData.items.reduce((sum, i) => sum + i.retailPrice, 0)
        }));

        const fallbackUrl = `${window.location.origin}/tools/room-designer/share.html?data=${encodedData.substr(0, 1000)}`;
        document.getElementById('generatedShareLink').value = fallbackUrl;
        document.getElementById('generatedLinkSection').style.display = 'block';

        btn.textContent = 'Generate Link';
        btn.disabled = false;

        showNotification('Share link created (local only)', 'warning');
      }
    }

    function copyGeneratedLink() {
      const input = document.getElementById('generatedShareLink');
      input.select();
      document.execCommand('copy');
      showNotification('Link copied to clipboard!', 'success');
    }

    function copyQuoteLink() {
      // Quick copy current design link
      shareQuoteLink();
    }

    // Send quote via email
    async function sendQuoteEmail() {
      const customerEmail = document.getElementById('quoteCustomerEmail').value;
      const customerName = document.getElementById('quoteCustomerName').value;

      if (!customerEmail) {
        showNotification('Please enter customer email', 'error');
        return;
      }

      // Save customer info
      localStorage.setItem('sg_quote_customer', JSON.stringify({
        name: customerName,
        email: customerEmail,
        phone: document.getElementById('quoteCustomerPhone').value
      }));

      // For now, generate link and show email instructions
      await generateQuoteShareLink();

      const shareUrl = document.getElementById('generatedShareLink').value;
      const total = document.getElementById('quotePreviewTotal').textContent;

      // Open email client
      const subject = encodeURIComponent(`Quote for ${currentProjectName || 'Your Project'} - Surprise Granite`);
      const body = encodeURIComponent(
        `Hi ${customerName || 'Valued Customer'},\n\n` +
        `Thank you for your interest! Here is your quote for ${currentProjectName || 'your project'}:\n\n` +
        `Estimated Total: ${total}\n\n` +
        `View your full quote and design here:\n${shareUrl}\n\n` +
        `If you have any questions, please don't hesitate to reach out.\n\n` +
        `Best regards,\nSurprise Granite Team`
      );

      window.open(`mailto:${customerEmail}?subject=${subject}&body=${body}`, '_blank');

      showNotification('Email client opened', 'success');
    }

    // ===== ESTIMATE DATABASE FUNCTIONS =====
    let currentEstimateId = null;
    let currentEstimateNumber = null;

    async function saveEstimateToDatabase() {
      const btn = document.getElementById('saveEstimateBtn');
      const originalText = btn.innerHTML;

      // Get customer info
      const customerName = document.getElementById('quoteCustomerName').value.trim();
      const customerEmail = document.getElementById('quoteCustomerEmail').value.trim();
      const customerPhone = document.getElementById('quoteCustomerPhone').value.trim();
      const customerAddress = document.getElementById('quoteCustomerAddress').value.trim();
      const projectName = document.getElementById('quoteProjectName').value.trim() || currentProjectName || 'Untitled Project';
      const notes = document.getElementById('quoteNotes').value.trim();
      const taxRate = parseFloat(document.getElementById('quoteTaxInput').value) || 0;

      // Validate required fields
      if (!customerName) {
        showNotification('Customer name is required', 'error');
        document.getElementById('quoteCustomerName').focus();
        return;
      }
      if (!customerEmail) {
        showNotification('Customer email is required', 'error');
        document.getElementById('quoteCustomerEmail').focus();
        return;
      }

      // Check if user is logged in
      const user = window.SgAuth?.getUser();
      if (!user) {
        showLoginPrompt('Please log in to save estimates.');
        return;
      }

      btn.innerHTML = '<span class="spinner" style="width:14px;height:14px;border:2px solid transparent;border-top-color:currentColor;border-radius:50%;animation:spin 1s linear infinite;display:inline-block;margin-right:6px;"></span> Saving...';
      btn.disabled = true;

      try {
        const { url: SUPABASE_URL, anonKey: SUPABASE_ANON_KEY } = getSupabaseConfig();

        const session = await window.SgAuth?.getSession?.();
        const authToken = session?.access_token || SUPABASE_ANON_KEY;

        const headers = {
          'apikey': SUPABASE_ANON_KEY,
          'Authorization': `Bearer ${authToken}`,
          'Accept': 'application/json',
          'Content-Type': 'application/json',
          'Prefer': 'return=representation'
        };

        // Get next estimate number using RPC function
        let estimateNumber = 'EST-' + Date.now().toString().slice(-6); // Fallback
        try {
          const rpcResponse = await fetch(`${SUPABASE_URL}/rest/v1/rpc/get_next_estimate_number`, {
            method: 'POST',
            headers,
            body: JSON.stringify({ p_user_id: user.id })
          });
          if (rpcResponse.ok) {
            const rpcData = await rpcResponse.json();
            if (rpcData) estimateNumber = rpcData;
          }
        } catch (e) {
          console.log('Could not get estimate number from DB, using fallback:', e);
        }

        // Calculate totals from quote preview data
        buildQuotePreviewData();
        const subtotal = quotePreviewData.items.reduce((sum, i) => sum + i.retailPrice, 0);
        const taxAmount = subtotal * (taxRate / 100);
        const total = subtotal + taxAmount;

        // Parse address into components if possible
        const addressParts = customerAddress.split(',').map(s => s.trim());
        const city = addressParts[1] || '';
        const stateZip = addressParts[2] || '';
        const [state, zip] = stateZip.split(' ').filter(Boolean);

        // Create or find customer record
        let customerId = null;
        try {
          // First check if customer exists by email
          const customerLookup = await fetch(
            `${SUPABASE_URL}/rest/v1/customers?email=eq.${encodeURIComponent(customerEmail)}&select=id`,
            { method: 'GET', headers }
          );

          if (customerLookup.ok) {
            const existingCustomers = await customerLookup.json();
            if (existingCustomers && existingCustomers.length > 0) {
              customerId = existingCustomers[0].id;
              console.log('Found existing customer:', customerId);
            }
          }

          // If no customer exists, create one
          if (!customerId) {
            const customerData = {
              email: customerEmail,
              name: customerName,
              phone: customerPhone || null,
              address: addressParts[0] || customerAddress,
              city: city || null,
              state: state || null,
              zip: zip || null,
              source: 'room_designer',
              created_by: user.id
            };

            const createCustomerResponse = await fetch(`${SUPABASE_URL}/rest/v1/customers`, {
              method: 'POST',
              headers,
              body: JSON.stringify(customerData)
            });

            if (createCustomerResponse.ok) {
              const newCustomer = await createCustomerResponse.json();
              customerId = Array.isArray(newCustomer) ? newCustomer[0]?.id : newCustomer.id;
              console.log('Created new customer:', customerId);
            }
          }
        } catch (e) {
          console.log('Customer creation optional, continuing:', e);
        }

        // Create estimate record
        const estimateData = {
          user_id: user.id,
          estimate_number: estimateNumber,
          customer_name: customerName,
          customer_email: customerEmail,
          customer_phone: customerPhone || null,
          customer_address: addressParts[0] || customerAddress,
          customer_city: city || null,
          customer_state: state || null,
          customer_zip: zip || null,
          project_name: projectName,
          project_description: `Room Designer Quote - ${rooms.length} room(s)`,
          estimate_date: new Date().toISOString().split('T')[0],
          valid_until: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString().split('T')[0], // 30 days
          subtotal: subtotal,
          tax_rate: taxRate,
          tax_amount: taxAmount,
          total: total,
          deposit_percent: 50,
          deposit_amount: total * 0.5,
          notes: notes || null,
          status: 'draft'
        };

        // Insert estimate
        const estimateResponse = await fetch(`${SUPABASE_URL}/rest/v1/estimates`, {
          method: 'POST',
          headers,
          body: JSON.stringify(estimateData)
        });

        if (!estimateResponse.ok) {
          const errorText = await estimateResponse.text();
          throw new Error(`Failed to create estimate: ${errorText}`);
        }

        const estimateResult = await estimateResponse.json();
        const estimateId = Array.isArray(estimateResult) ? estimateResult[0]?.id : estimateResult.id;

        if (!estimateId) {
          throw new Error('No estimate ID returned');
        }

        currentEstimateId = estimateId;
        currentEstimateNumber = estimateNumber;

        // Create estimate line items
        const lineItems = quotePreviewData.items.map((item, index) => ({
          estimate_id: estimateId,
          name: item.label,
          description: `${item.type} - ${item.unit === 'sqft' ? item.sqft.toFixed(1) + ' sqft' : item.qty + ' ' + item.unit}`,
          category: item.isLabor ? 'labor' : (item.isCountertop ? 'material' : (item.isCabinet ? 'cabinet' : 'other')),
          quantity: item.qty,
          unit_type: item.unit,
          unit_price: item.retailPrice / item.qty,
          total: item.retailPrice,
          cost: item.costPrice,
          sort_order: index,
          group_name: item.roomId === 'labor' ? 'Labor' : (rooms.find(r => r.id === item.roomId)?.name || 'Default Room')
        }));

        if (lineItems.length > 0) {
          const itemsResponse = await fetch(`${SUPABASE_URL}/rest/v1/estimate_items`, {
            method: 'POST',
            headers,
            body: JSON.stringify(lineItems)
          });

          if (!itemsResponse.ok) {
            console.error('Failed to create line items:', await itemsResponse.text());
          }
        }

        // Create access token for customer viewing
        const accessToken = generateToken(32);
        const tokenResponse = await fetch(`${SUPABASE_URL}/rest/v1/estimate_tokens`, {
          method: 'POST',
          headers,
          body: JSON.stringify({
            estimate_id: estimateId,
            token: accessToken,
            expires_at: new Date(Date.now() + 90 * 24 * 60 * 60 * 1000).toISOString() // 90 days
          })
        });

        // Generate customer view URL
        const viewUrl = `${window.location.origin}/estimate/view?token=${accessToken}`;

        // Update UI
        document.getElementById('estimateNumberBadge').textContent = estimateNumber;
        document.getElementById('estimateNumberBadge').style.display = 'block';
        document.getElementById('estimateStatusSection').style.display = 'block';
        document.getElementById('estimateStatusText').textContent = `Estimate ${estimateNumber} saved!`;
        document.getElementById('estimateViewLink').value = viewUrl;
        document.getElementById('estimateShareUrl').style.display = 'block';

        // Save to localStorage for persistence
        localStorage.setItem('sg_last_estimate', JSON.stringify({
          id: estimateId,
          number: estimateNumber,
          token: accessToken,
          customerEmail: customerEmail,
          total: total,
          createdAt: new Date().toISOString()
        }));

        showNotification(`Estimate ${estimateNumber} saved successfully!`, 'success');

      } catch (error) {
        console.error('Error saving estimate:', error);
        showNotification('Failed to save estimate: ' + error.message, 'error');
      } finally {
        btn.innerHTML = originalText;
        btn.disabled = false;
      }
    }

    function copyEstimateLink() {
      const linkInput = document.getElementById('estimateViewLink');
      linkInput.select();
      document.execCommand('copy');
      showNotification('Estimate link copied!', 'success');
    }

    // Initialize rooms on load
    setTimeout(() => {
      initRoomSelector();
      currentRoom = localStorage.getItem('sg_current_room') || 'default';
    }, 100);

    // ===== MARGIN MODAL FUNCTIONS =====
    function openMarginModal() {
      document.getElementById('globalMarginInput').value = PRICING_STATE.globalMargin;

      // Populate category margins
      document.querySelectorAll('.category-margin-row input').forEach(input => {
        const category = input.dataset.category;
        const value = PRICING_STATE.categoryMargins[category];
        input.value = value !== undefined ? value : PRICING_STATE.globalMargin;
      });

      document.getElementById('marginModal').classList.add('active');
    }

    function applyMargins() {
      PRICING_STATE.globalMargin = parseInt(document.getElementById('globalMarginInput').value) || 30;

      document.querySelectorAll('.category-margin-row input').forEach(input => {
        const category = input.dataset.category;
        const value = parseInt(input.value);
        if (!isNaN(value)) {
          PRICING_STATE.categoryMargins[category] = value;
        }
      });

      closeModal('marginModal');
      calculateQuote();
    }

    // ===== SHARING FUNCTIONS (Supabase) =====

    // ===== PRELOADER FUNCTIONS =====
    // Preloader Steps for Blueprint CAD Animation
    // Minimal preloader
    let preloaderMinTime = 2000;
    let preloaderStartTime = 0;
    let preloaderReady = false;
    let preloaderProgress = 0;
    let preloaderInterval = null;

    function showPreloader(message, companyName) {
      const preloader = document.getElementById('cloudPreloader');
      const companyEl = document.getElementById('preloaderCompanyMain');
      const progressBar = document.getElementById('preloaderProgressBar');

      if (preloader) {
        preloader.classList.remove('loaded');
        preloaderStartTime = Date.now();
        preloaderReady = false;
        preloaderProgress = 0;

        // Set company name
        if (companyEl) {
          companyEl.textContent = companyName || 'Surprise Granite';
        }

        // Reset progress
        if (progressBar) progressBar.style.width = '0%';

        // Clear any existing interval
        if (preloaderInterval) clearInterval(preloaderInterval);

        // Animate progress bar
        preloaderInterval = setInterval(() => {
          preloaderProgress += 2;
          if (progressBar) progressBar.style.width = Math.min(preloaderProgress, 90) + '%';

          if (preloaderProgress >= 90 && preloaderReady) {
            if (progressBar) progressBar.style.width = '100%';
            clearInterval(preloaderInterval);
            setTimeout(hidePreloaderNow, 300);
          }
        }, 40);
      }
    }

    function hidePreloader() {
      preloaderReady = true;
      const elapsed = Date.now() - preloaderStartTime;

      if (elapsed >= preloaderMinTime && preloaderProgress >= 90) {
        const progressBar = document.getElementById('preloaderProgressBar');
        if (progressBar) progressBar.style.width = '100%';
        setTimeout(hidePreloaderNow, 300);
      }
    }

    function hidePreloaderNow() {
      const preloader = document.getElementById('cloudPreloader');
      if (preloaderInterval) {
        clearInterval(preloaderInterval);
        preloaderInterval = null;
      }
      if (preloader) {
        preloader.classList.add('loaded');
      }
    }

    // Get Supabase client - use global client only
    function getSupabaseClient() {
      // Use the global client from supabase-init.js
      return window._sgSupabaseClient || null;
    }

    // Get Supabase credentials from centralized config
    function getSupabaseConfig() {
      const config = window.SG_CONFIG || window._sgSupabaseConfig || {};
      return {
        url: config.SUPABASE_URL || config.url || 'https://ypeypgwsycxcagncgdur.supabase.co',
        anonKey: config.SUPABASE_ANON_KEY || 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InlwZXlwZ3dzeWN4Y2FnbmNnZHVyIiwicm9sZSI6ImFub24iLCJpYXQiOjE3Njc3NTQ4MjMsImV4cCI6MjA4MzMzMDgyM30.R13pNv2FDtGhfeu7gUcttYNrQAbNYitqR4FIq3O2-ME',
        storageKey: config.SUPABASE_STORAGE_KEY || config.storageKey || 'sg-auth-token'
      };
    }

    // Get current authenticated user
    function getCurrentUser() {
      // Try sg-auth first
      if (window.sgAuth && typeof window.sgAuth.getUser === 'function') {
        return window.sgAuth.getUser();
      }
      // Try getting from Supabase session
      const supabase = getSupabaseClient();
      if (supabase) {
        // Note: this is sync access to cached session
        const session = supabase.auth?.session;
        if (session?.user) return session.user;
      }
      // Check localStorage for cached user
      try {
        const stored = localStorage.getItem('sb-ypeypgwsycxcagncgdur-auth-token');
        if (stored) {
          const parsed = JSON.parse(stored);
          if (parsed?.user) return parsed.user;
        }
      } catch (e) {}
      return null;
    }

    // Generate cryptographically secure share token
    function generateToken(length = 16) {
      const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZabcdefghjkmnpqrstuvwxyz23456789';
      let token = '';

      // Use Web Crypto API for secure random values
      if (window.crypto && window.crypto.getRandomValues) {
        const randomValues = new Uint32Array(length);
        crypto.getRandomValues(randomValues);
        for (let i = 0; i < length; i++) {
          token += chars.charAt(randomValues[i] % chars.length);
        }
      } else {
        // Fallback for very old browsers - combine multiple entropy sources
        const timestamp = Date.now().toString(36);
        const random = Math.random().toString(36).substring(2);
        const combined = timestamp + random + performance.now().toString(36);
        for (let i = 0; i < length; i++) {
          const index = (combined.charCodeAt(i % combined.length) * (i + 1)) % chars.length;
          token += chars.charAt(index);
        }
        console.warn('Using fallback token generation - crypto API not available');
      }
      return token;
    }

    // ===== AUTHENTICATION FUNCTIONS =====

    // Show login prompt modal
    function showLoginPrompt(message) {
      document.getElementById('loginPromptMessage').textContent = message || 'Sign in to continue.';
      document.getElementById('loginFormContainer').style.display = 'block';
      document.getElementById('loginSuccessContainer').style.display = 'none';
      document.getElementById('loginError').style.display = 'none';
      document.getElementById('loginEmail').value = '';
      document.getElementById('loginPassword').value = '';
      document.getElementById('loginModal').classList.add('active');
      document.getElementById('loginModal').removeAttribute('data-required');
      resetSignInButton();
    }

    // Show required login prompt (non-dismissible, for initial access)
    function showLoginPromptRequired() {
      document.getElementById('loginPromptMessage').innerHTML =
        'Sign in to access the Room Designer.<br><span style="font-size: 12px; opacity: 0.7;">Create professional kitchen & bath layouts with instant quotes.</span>';
      document.getElementById('loginFormContainer').style.display = 'block';
      document.getElementById('loginSuccessContainer').style.display = 'none';
      document.getElementById('loginError').style.display = 'none';
      document.getElementById('loginEmail').value = '';
      document.getElementById('loginPassword').value = '';
      const modal = document.getElementById('loginModal');
      modal.classList.add('active');
      modal.setAttribute('data-required', 'true');
      resetSignInButton();
    }

    // Continue as guest without signing in
    function continueAsGuest() {
      pendingAuthInit = false;
      const loginModal = document.getElementById('loginModal');
      loginModal.removeAttribute('data-required');
      loginModal.classList.remove('active');

      // Set guest mode indicator
      PRICING_ACCESS.accountType = 'guest';
      PRICING_ACCESS.canViewPricing = false;

      // Show guest mode toast after workspace loads
      setTimeout(() => {
        showToast('You\'re using Guest Mode. Sign in to save designs to the cloud.', 'info');
        // Add guest mode indicator to header
        showGuestModeIndicator();
      }, 1500);

      initializeWorkspace();
    }

    // Show guest mode indicator in header
    function showGuestModeIndicator() {
      const userMenu = document.getElementById('userAccountMenu');
      if (!userMenu) return;

      // Check if indicator already exists
      if (document.getElementById('guestModeIndicator')) return;

      const indicator = document.createElement('div');
      indicator.id = 'guestModeIndicator';
      indicator.style.cssText = `
        display: flex;
        align-items: center;
        gap: 6px;
        padding: 6px 12px;
        background: rgba(255, 193, 7, 0.15);
        border: 1px solid rgba(255, 193, 7, 0.3);
        border-radius: 6px;
        font-size: 12px;
        color: #ffc107;
        cursor: pointer;
        margin-right: 8px;
      `;
      indicator.innerHTML = `
        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <circle cx="12" cy="12" r="10"/>
          <line x1="12" y1="16" x2="12" y2="12"/>
          <line x1="12" y1="8" x2="12.01" y2="8"/>
        </svg>
        <span>Guest Mode</span>
      `;
      indicator.title = 'Click to sign in and save to cloud';
      indicator.onclick = () => showLoginPrompt('Sign in to save your designs to the cloud and access them from any device.');

      userMenu.parentNode.insertBefore(indicator, userMenu);
    }

    // Remove guest mode indicator (when user signs in)
    function removeGuestModeIndicator() {
      const indicator = document.getElementById('guestModeIndicator');
      if (indicator) indicator.remove();
    }

    // Handle Google OAuth login
    async function handleGoogleLogin() {
      const googleBtn = document.querySelector('.google-signin-btn');
      const originalContent = googleBtn?.innerHTML;

      try {
        // Show loading state
        if (googleBtn) {
          googleBtn.disabled = true;
          googleBtn.innerHTML = `
            <svg class="spinner" viewBox="0 0 24 24" width="20" height="20" style="animation: spin 1s linear infinite;">
              <circle cx="12" cy="12" r="10" stroke="currentColor" stroke-width="2" fill="none" stroke-dasharray="31.4" stroke-dashoffset="10"/>
            </svg>
            Connecting to Google...
          `;
        }

        const supabase = getSupabaseClient();
        if (!supabase) {
          throw new Error('Authentication not available');
        }

        const { data, error } = await supabase.auth.signInWithOAuth({
          provider: 'google',
          options: {
            redirectTo: window.location.origin + '/tools/room-designer/'
          }
        });

        if (error) {
          document.getElementById('loginError').textContent = error.message;
          document.getElementById('loginError').style.display = 'block';
          // Reset button
          if (googleBtn && originalContent) {
            googleBtn.disabled = false;
            googleBtn.innerHTML = originalContent;
          }
        }
        // Note: If successful, page will redirect, so no need to reset button
      } catch (err) {
        console.error('Google login error:', err);
        document.getElementById('loginError').textContent = 'Failed to connect with Google. Please try again.';
        document.getElementById('loginError').style.display = 'block';
        // Reset button on error
        if (googleBtn && originalContent) {
          googleBtn.disabled = false;
          googleBtn.innerHTML = originalContent;
        }
      }
    }

    // Handle login form submission
    async function handleLogin() {
      const email = document.getElementById('loginEmail').value.trim();
      const password = document.getElementById('loginPassword').value;
      const errorEl = document.getElementById('loginError');
      const btn = document.getElementById('signInBtn');

      if (!email || !password) {
        errorEl.textContent = 'Please enter email and password.';
        errorEl.style.display = 'block';
        return;
      }

      try {
        errorEl.style.display = 'none';

        // Show loading state
        if (btn) {
          btn.classList.add('loading');
          btn.disabled = true;
        }

        if (!window.SgAuth) {
          throw new Error('Auth system not loaded. Please refresh the page.');
        }

        const result = await window.SgAuth.signIn(email, password);

        // Show success
        document.getElementById('loginFormContainer').style.display = 'none';
        document.getElementById('loginSuccessContainer').style.display = 'block';
        document.getElementById('loginWelcome').textContent = `Welcome back, ${result.profile?.full_name || email}!`;

        // Update header UI
        updateAuthUI();

        // If this was a required login to access the tool, continue initialization
        if (pendingAuthInit) {
          pendingAuthInit = false;
          setTimeout(() => {
            closeModal('loginModal');
            initializeWorkspace();
          }, 1000);
        }

      } catch (err) {
        console.error('Login error:', err);
        errorEl.textContent = err.message || 'Login failed. Please try again.';
        errorEl.style.display = 'block';

        // Reset button
        if (btn) {
          btn.classList.remove('loading');
          btn.disabled = false;
        }
      }
    }

    // Reset sign in button state
    function resetSignInButton() {
      const btn = document.getElementById('signInBtn');
      if (btn) {
        btn.classList.remove('loading');
        btn.disabled = false;
      }
    }

    // Update header to show logged-in state
    function updateAuthUI() {
      const user = window.SgAuth?.getUser();
      const profile = window.SgAuth?.getProfile();

      // Update new user menu
      const userAvatarSmall = document.getElementById('userAvatarSmall');
      const userNameDisplay = document.getElementById('userNameDisplay');
      const loggedOutMenu = document.getElementById('loggedOutMenu');
      const loggedInMenu = document.getElementById('loggedInMenu');

      if (user) {
        // Remove guest mode indicator when signed in
        removeGuestModeIndicator();

        const name = profile?.full_name?.split(' ')[0] || user.email.split('@')[0];
        const initial = name.charAt(0).toUpperCase();

        if (userAvatarSmall) userAvatarSmall.textContent = initial;
        if (userNameDisplay) userNameDisplay.textContent = name;
        if (loggedOutMenu) loggedOutMenu.style.display = 'none';
        if (loggedInMenu) loggedInMenu.style.display = 'block';
      } else {
        if (userAvatarSmall) userAvatarSmall.textContent = '?';
        if (userNameDisplay) userNameDisplay.textContent = 'Sign In';
        if (loggedOutMenu) loggedOutMenu.style.display = 'block';
        if (loggedInMenu) loggedInMenu.style.display = 'none';
      }

      // Legacy accountBtn support
      const accountBtn = document.getElementById('accountBtn');
      if (accountBtn) {
        if (user) {
          const name = profile?.full_name?.split(' ')[0] || user.email.split('@')[0];
          accountBtn.innerHTML = `
            <span style="width:28px;height:28px;background:var(--gold);border-radius:50%;display:flex;align-items:center;justify-content:center;font-weight:600;color:var(--dark);font-size:12px;">${name.charAt(0).toUpperCase()}</span>
            <span>${name}</span>
          `;
          accountBtn.onclick = () => window.location.href = '/account/';
        } else {
          accountBtn.innerHTML = `
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:20px;height:20px;">
              <path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"/>
              <circle cx="12" cy="7" r="4"/>
            </svg>
            <span>Sign In</span>
          `;
          accountBtn.onclick = () => showLoginPrompt();
        }
      }
    }

    // Toggle user dropdown menu
    function toggleUserMenu() {
      const dropdown = document.getElementById('userDropdown');
      if (dropdown) {
        dropdown.classList.toggle('show');
      }
    }

    // Close user menu
    function closeUserMenu() {
      const dropdown = document.getElementById('userDropdown');
      if (dropdown) {
        dropdown.classList.remove('show');
      }
    }

    // Handle Google Sign In
    async function handleGoogleSignIn() {
      closeUserMenu();
      try {
        // Use SgAuth if available
        if (window.SgAuth && window.SgAuth.signInWithGoogle) {
          await window.SgAuth.signInWithGoogle(window.location.href);
        } else {
          // Fallback to direct Supabase call
          const client = getSupabaseClient();
          if (client) {
            const { error } = await client.auth.signInWithOAuth({
              provider: 'google',
              options: {
                redirectTo: window.location.href
              }
            });
            if (error) throw error;
          }
        }
      } catch (err) {
        console.error('Google sign in error:', err);
        showToast('Error connecting to Google');
      }
    }

    // Handle logout
    async function handleLogout() {
      closeUserMenu();
      try {
        if (window.SgAuth) {
          await window.SgAuth.signOut();
        }
        updateAuthUI();
        showToast('Signed out successfully');
      } catch (err) {
        console.error('Logout error:', err);
        showToast('Error signing out');
      }
    }

    // Close user menu when clicking outside
    document.addEventListener('click', function(e) {
      const menu = document.getElementById('userAccountMenu');
      const dropdown = document.getElementById('userDropdown');
      if (menu && dropdown && !menu.contains(e.target)) {
        dropdown.classList.remove('show');
      }
    });

    // Initialize auth state on load
    function initAuth() {
      if (window.SgAuth) {
        window.SgAuth.onAuthChange(async (event, data) => {
          console.log('Auth state changed:', event);
          updateAuthUI();

          // Check pricing access on any auth change (force refresh to get latest from DB)
          await checkPricingAccess(true);

          // Re-render cabinet catalog after pricing access is checked
          setTimeout(() => {
            if (typeof renderCabinetCatalog === 'function') {
              renderCabinetCatalog();
            }
          }, 100);

          // When user signs in, clear cached designs so they reload from server
          if (event === 'SIGNED_IN' || event === 'TOKEN_REFRESHED') {
            allDesigns = { my: [], shared: [], recent: [] };
            // If My Designs modal is open, refresh it
            const modal = document.getElementById('myDesignsModal');
            if (modal && modal.classList.contains('active')) {
              loadMyDesigns();
            }
          }
        });
      }

      // Also listen to Supabase auth changes directly
      const supabase = getSupabaseClient();
      if (supabase) {
        supabase.auth.onAuthStateChange((event, session) => {
          console.log('Supabase auth state changed:', event);
          if (event === 'SIGNED_IN' || event === 'TOKEN_REFRESHED') {
            // Clear cached designs to force reload
            allDesigns = { my: [], shared: [], recent: [] };
          }
        });
      }

      // Initial update
      setTimeout(updateAuthUI, 500);
    }

    // ===== TOAST NOTIFICATIONS =====
    function showToast(message, type = 'info', duration = 3000) {
      let container = document.getElementById('toastContainer');
      if (!container) {
        container = document.createElement('div');
        container.id = 'toastContainer';
        container.className = 'toast-container';
        document.body.appendChild(container);
      }

      // Define icons for each type
      const icons = {
        success: `<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="#34A853" stroke-width="2" style="flex-shrink: 0;">
          <path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/>
          <polyline points="22 4 12 14.01 9 11.01"/>
        </svg>`,
        error: `<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="#EA4335" stroke-width="2" style="flex-shrink: 0;">
          <circle cx="12" cy="12" r="10"/>
          <line x1="15" y1="9" x2="9" y2="15"/>
          <line x1="9" y1="9" x2="15" y2="15"/>
        </svg>`,
        warning: `<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="#FBBC05" stroke-width="2" style="flex-shrink: 0;">
          <path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"/>
          <line x1="12" y1="9" x2="12" y2="13"/>
          <line x1="12" y1="17" x2="12.01" y2="17"/>
        </svg>`,
        info: `<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="#4285F4" stroke-width="2" style="flex-shrink: 0;">
          <circle cx="12" cy="12" r="10"/>
          <line x1="12" y1="16" x2="12" y2="12"/>
          <line x1="12" y1="8" x2="12.01" y2="8"/>
        </svg>`
      };

      const toast = document.createElement('div');
      toast.className = `toast ${type}`;
      toast.style.display = 'flex';
      toast.style.alignItems = 'center';
      toast.style.gap = '10px';
      toast.innerHTML = `${icons[type] || icons.info}<span>${message}</span>`;
      container.appendChild(toast);

      // Update animation duration based on custom duration
      if (duration !== 3000) {
        toast.style.animation = `toastIn 0.3s ease, toastOut 0.3s ease ${(duration - 300) / 1000}s forwards`;
      }

      // Remove toast after animation
      setTimeout(() => {
        toast.remove();
      }, duration);
    }

    // Generate share link and save to Supabase
    async function generateShareLink() {
      console.log('=== generateShareLink START ===');

      // Check if user is logged in
      const user = window.SgAuth?.getUser();
      if (!user) {
        showLoginPrompt('Please log in to save and share your designs.');
        return;
      }

      // Show loading indicator
      showLoading('Generating share link...');

      // Get user profile for company name
      let companyName = 'Surprise Granite Marble & Quartz'; // default
      try {
        const profile = await window.SgAuth?.getProfile();
        if (profile && profile.company_name) {
          companyName = profile.company_name;
        } else if (profile && profile.full_name) {
          companyName = profile.full_name;
        }
      } catch (e) {
        console.log('Could not fetch profile:', e);
      }

      const permissionBtn = document.querySelector('#shareModal .permission-btn.active');
      const permission = permissionBtn ? permissionBtn.dataset.permission : 'quote_view';
      console.log('Permission selected:', permission);

      const projectName = document.getElementById('projectName').value || 'Untitled Design';
      const roomType = document.getElementById('roomType').value;

      console.log('Project:', projectName, 'Room:', roomType);
      console.log('Elements count:', elements.length);
      console.log('User:', user.email);
      console.log('Company:', companyName);

      // Calculate quote total
      let quoteTotal = 0;
      elements.forEach(el => {
        const priceInfo = getElementPrice(el);
        const margin = getElementMargin(el) || 30;
        let cost = priceInfo?.price || 0;
        if (['countertop', 'backsplash', 'flooring', 'tile'].includes(el.type)) {
          cost = (el.width || 1) * (el.height || 1) * cost;
        }
        quoteTotal += cost * (1 + margin / 100);
      });

      // Save current room state before creating share data
      saveCurrentRoomState();

      const designData = {
        user_id: user.id,
        name: projectName,
        room_type: roomType,
        room_width: roomWidth,
        room_depth: roomDepth,
        elements: elements.map(el => serializeElement(el)),
        settings: {
          walls: walls.map(w => serializeWall(w)),
          pricing_config: {
            globalMargin: PRICING_STATE.globalMargin,
            categoryMargins: PRICING_STATE.categoryMargins,
            customPrices: PRICING_STATE.customPrices
          },
          company_name: companyName,
          current_room_id: currentRoomId,
          pixelsPerFoot: pixelsPerFoot,
          // Multi-room support (stored in settings to avoid column mismatch)
          rooms: rooms.map(room => ({
            ...room,
            elements: (room.elements || []).map(el =>
              el.xFt !== undefined ? { ...el, textureImg: null } : serializeElement(el)
            ),
            walls: (room.walls || []).map(w =>
              w.x1Ft !== undefined ? { ...w } : serializeWall(w)
            )
          })),
          share_mode: permission === 'full_collab' ? 'edit' : 'view',
          is_public: document.getElementById('shareToGallery')?.checked || false
        },
        quote_total: quoteTotal
      };

      try {
        // Use centralized config
        const { url: SUPABASE_URL, anonKey: SUPABASE_ANON_KEY } = getSupabaseConfig();

        // Get auth token if logged in
        const session = await window.SgAuth?.getSession?.();
        const authToken = session?.access_token || SUPABASE_ANON_KEY;

        const headers = {
          'apikey': SUPABASE_ANON_KEY,
          'Authorization': `Bearer ${authToken}`,
          'Accept': 'application/json',
          'Content-Type': 'application/json',
          'Prefer': 'return=representation'
        };

        let designId = SHARE_STATE.designId;
        let designToken = SHARE_STATE.designToken;
        console.log('Current state - designId:', designId, 'designToken:', designToken);

        // If designId is a local ID (starts with "local-"), we need to create a new one in Supabase
        const isLocalDesign = designId && String(designId).startsWith('local-');
        if (isLocalDesign) {
          console.log('Local design detected, will create new Supabase design');
          designId = null;
          designToken = null;
        }

        // Create or update design in database
        if (!designId) {
          designToken = generateToken(16);
          console.log('Creating new design with token:', designToken);

          const insertData = {
            share_token: designToken,
            ...designData
          };

          const response = await fetch(`${SUPABASE_URL}/rest/v1/room_designs`, {
            method: 'POST',
            headers,
            body: JSON.stringify(insertData)
          });

          if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`Insert failed: ${response.status} - ${errorText}`);
          }

          const data = await response.json();
          console.log('Insert result:', data);

          designId = Array.isArray(data) ? data[0]?.id : data.id;
          SHARE_STATE.designId = designId;
          SHARE_STATE.designToken = designToken;
          console.log('Design created with ID:', designId);
        } else {
          // Update existing design
          const updateData = {
            ...designData,
            updated_at: new Date().toISOString()
          };

          const response = await fetch(`${SUPABASE_URL}/rest/v1/room_designs?id=eq.${designId}`, {
            method: 'PATCH',
            headers,
            body: JSON.stringify(updateData)
          });

          if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`Update failed: ${response.status} - ${errorText}`);
          }
        }

        // Check if customer email provided to link to a lead
        const customerEmail = document.getElementById('shareCustomerEmail')?.value?.trim();
        let leadId = null;

        if (customerEmail) {
          try {
            // First try to find existing lead by email
            const leadResponse = await fetch(
              `${SUPABASE_URL}/rest/v1/leads?email=eq.${encodeURIComponent(customerEmail)}&select=id&order=created_at.desc&limit=1`,
              { headers }
            );
            const leads = await leadResponse.json();

            if (leads && leads.length > 0) {
              leadId = leads[0].id;
              console.log('Found existing lead:', leadId);
            } else {
              // Create a new lead for this customer
              const newLeadResponse = await fetch(`${SUPABASE_URL}/rest/v1/leads`, {
                method: 'POST',
                headers,
                body: JSON.stringify({
                  email: customerEmail,
                  full_name: customerEmail.split('@')[0],
                  source: 'Design Share',
                  project_type: roomType,
                  owner_id: user.id,
                  status: 'new',
                  message: `Design project: ${projectName}`
                })
              });
              const newLeads = await newLeadResponse.json();
              if (newLeads && newLeads.length > 0) {
                leadId = newLeads[0].id;
                console.log('Created new lead:', leadId);
              }
            }
          } catch (leadErr) {
            console.warn('Could not link to lead:', leadErr);
          }
        }

        // Create share record with specific permission
        const shareToken = generateToken(12);
        const shareData = {
          design_id: designId,
          share_token: shareToken,
          permission_level: permission
        };

        if (leadId) {
          shareData.lead_id = leadId;
        }

        const shareResponse = await fetch(`${SUPABASE_URL}/rest/v1/room_design_shares`, {
          method: 'POST',
          headers,
          body: JSON.stringify(shareData)
        });

        if (!shareResponse.ok) {
          const errorText = await shareResponse.text();
          throw new Error(`Share insert failed: ${shareResponse.status} - ${errorText}`);
        }

        // Display share URL
        const shareUrl = `${window.location.origin}${window.location.pathname}?share=${shareToken}`;
        document.getElementById('shareLink').value = shareUrl;
        document.getElementById('copyShareBtn').disabled = false;
        document.getElementById('shareStatusText').textContent = 'Design shared!';

        // Show social sharing options
        const socialSection = document.getElementById('socialShareSection');
        if (socialSection) socialSection.style.display = 'block';

        loadActiveShares();
        hideLoading();
        showToast('Share link created successfully', 'success');

      } catch (err) {
        console.error('Share error:', err);
        // Fallback to localStorage for local testing
        const token = generateToken(16);

        // Save design to localStorage
        const localDesign = {
          id: token,
          share_token: token,
          name: projectName,
          room_type: roomType,
          room_width: roomWidth,
          room_depth: roomDepth,
          elements: elements.map(el => ({ ...el, textureImg: null })),
          settings: {
            walls: walls,
            pricing_config: {
              globalMargin: PRICING_STATE.globalMargin,
              categoryMargins: PRICING_STATE.categoryMargins,
              customPrices: PRICING_STATE.customPrices
            },
            company_name: companyName
          },
          quote_total: quoteTotal,
          share_mode: permission === 'full_collab' ? 'edit' : 'view',
          permission_level: permission,
          created_at: new Date().toISOString()
        };

        // Store in localStorage
        const localShares = JSON.parse(localStorage.getItem('roomDesignerLocalShares') || '{}');
        localShares[token] = localDesign;
        localStorage.setItem('roomDesignerLocalShares', JSON.stringify(localShares));

        const shareUrl = `${window.location.origin}${window.location.pathname}?share=${token}`;
        document.getElementById('shareLink').value = shareUrl;
        document.getElementById('copyShareBtn').disabled = false;
        document.getElementById('shareStatusText').textContent = 'Link generated (local mode - for testing)';

        // Show social sharing options
        const socialSection = document.getElementById('socialShareSection');
        if (socialSection) socialSection.style.display = 'block';

        hideLoading();
        showToast('Share link created (local storage mode)', 'info');
      }
    }

    // Helper function to load design data into the canvas
    function loadDesignData(design, permission, shareData = null) {
      console.log('=== loadDesignData START ===');
      console.log('Design:', design);
      console.log('Permission:', permission);

      try {
        // Update preloader with company name
        let companyName = 'Surprise Granite Marble & Quartz';
        if (design.settings && design.settings.company_name) {
          companyName = design.settings.company_name;
        } else if (design.created_by) {
          companyName = design.created_by;
        } else if (design.company_name) {
          companyName = design.company_name;
        }
        const companyEl = document.getElementById('preloaderCompanyMain');
        if (companyEl) {
          companyEl.textContent = companyName;
        }

        // Set share state - only mark as shared view if permission was explicitly provided
        // (When designer loads their own design, no permission is passed)
        const isActuallySharedView = permission !== undefined && permission !== null;
        SHARE_STATE.isSharedView = isActuallySharedView;
        SHARE_STATE.permission = permission || 'full_collab';
        SHARE_STATE.allowedActions = PERMISSION_LEVELS[permission] || PERMISSION_LEVELS.full_collab;
        SHARE_STATE.designId = design.id;
        SHARE_STATE.designToken = design.share_token;

        if (shareData) {
          SHARE_STATE.shareId = shareData.id;
          SHARE_STATE.shareToken = shareData.share_token;
          SHARE_STATE.leadId = shareData.lead_id;
          SHARE_STATE.customerName = shareData.customer_name || null;
          SHARE_STATE.comments = shareData.comments || [];

          // Load comments from customer_messages if lead_id exists
          if (shareData.lead_id) {
            loadCommentsFromMessages(shareData.lead_id, shareData.id);

            // Subscribe to realtime comment notifications (for designers only)
            if (!SHARE_STATE.isSharedView) {
              subscribeToCustomerComments(shareData.lead_id);

              // Fetch customer name if not already set
              if (!SHARE_STATE.customerName) {
                fetchCustomerName(shareData.lead_id);
              }
            }
          }
        }

        // Load design data into form fields (name field, with project_name fallback for legacy)
        document.getElementById('projectName').value = design.name || design.project_name || 'Untitled Design';
        document.getElementById('roomType').value = design.room_type || 'kitchen';
        roomWidth = parseFloat(design.room_width) || 12;
        roomDepth = parseFloat(design.room_depth) || 10;
        document.getElementById('roomWidth').value = roomWidth;
        document.getElementById('roomDepth').value = roomDepth;

        // Validate design has actual content before overwriting
        const designElements = design.elements || [];
        const designWalls = design.settings?.walls || design.walls || [];
        if (designElements.length === 0 && elements.length > 0) {
          console.warn('loadDesignData: design has no elements but current canvas has', elements.length, ' preserving current state');
          // Still load share state above, but don't clear canvas
          return;
        }

        // Load elements and walls
        elements = designElements;
        walls = designWalls;

        // Load multi-room data if available (check both top-level and settings)
        const designRooms = (design.rooms && design.rooms.length > 0) ? design.rooms
          : (design.settings?.rooms && design.settings.rooms.length > 0) ? design.settings.rooms
          : null;

        if (designRooms && designRooms.length > 0) {
          rooms = designRooms.map(room => ({
            ...room,
            elements: room.elements || [],
            walls: room.walls || []
          }));
          currentRoomId = design.settings?.current_room_id || design.current_room_id || rooms[0].id;
          // Also sync the other room tracking variable
          currentRoom = currentRoomId;

          // Load current room data
          const activeRoom = getCurrentRoom();
          if (activeRoom) {
            elements = activeRoom.elements || [];
            walls = activeRoom.walls || [];
            roomWidth = activeRoom.width || roomWidth;
            roomDepth = activeRoom.depth || roomDepth;
          }

          console.log('Loaded multi-room layout with', rooms.length, 'rooms, currentRoomId:', currentRoomId);
          updateRoomList();
        } else {
          // Single room - initialize rooms array
          initializeRooms();
          currentRoom = currentRoomId || 'default';
          const firstRoom = getCurrentRoom();
          if (firstRoom) {
            firstRoom.elements = elements;
            firstRoom.walls = walls;
            firstRoom.width = roomWidth;
            firstRoom.depth = roomDepth;
          }
          updateRoomList();
        }

        console.log('Loaded elements:', elements.length);
        console.log('Loaded walls:', walls.length);

        // Normalize element positions if saved scale differs from current
        // This ensures 3D rendering is accurate regardless of viewport size
        const savedScale = design.settings?.pixelsPerFoot || 40;
        fitToScreen(); // Calculate current pixelsPerFoot based on viewport

        console.log('Saved scale:', savedScale, 'Current scale:', pixelsPerFoot);

        // Deserialize positions from feet-based format (or legacy pixel-based with scale conversion)
        elements = elements.map(el => deserializeElement({ ...el }, savedScale));
        walls = walls.map(w => deserializeWall({ ...w }, savedScale));

        // Deserialize room element and wall positions
        rooms.forEach(room => {
          if (room.elements) {
            room.elements = room.elements.map(el => deserializeElement({ ...el }, savedScale));
          }
          if (room.walls) {
            room.walls = room.walls.map(w => deserializeWall({ ...w }, savedScale));
          }
          room.pixelsPerFoot = pixelsPerFoot;
        });

        // Ensure elements have required properties
        elements = elements.map(el => ({
          ...el,
          textureImg: null,
          status: el.status || 'pending'
        }));

        // Load pricing config
        if (design.pricing_config) {
          PRICING_STATE.globalMargin = design.pricing_config.globalMargin || 30;
          PRICING_STATE.categoryMargins = design.pricing_config.categoryMargins || {};
          PRICING_STATE.customPrices = design.pricing_config.customPrices || {};
        }

        // Reload textures for elements
        elements.forEach(el => {
          if (el.materialId) {
            loadElementTexture(el);
          }
        });

        selectedElement = null;
        updateProperties();
        calculateQuote();
        draw();

        // Show Review Room UI first
        showReviewRoom(design.project_name, permission);

        // Wait for textures to load, then initialize 3D view
        setTimeout(() => {
          console.log('Initializing 3D view with', elements.length, 'elements');
          console.log('Room dimensions:', roomWidth, 'x', roomDepth, ', currentRoomId:', currentRoomId, ', currentRoom:', currentRoom);
          console.log('Elements sample:', elements.slice(0, 3).map(e => ({ type: e.type, roomId: e.roomId, x: e.x, y: e.y })));

          // Switch to 3D view first
          setView('3d');
          // Force re-init 3D scene after a short delay
          setTimeout(() => {
            console.log('Forcing 3D re-init...');
            init3D();
            render3D();
            console.log('3D scene initialized, scene children:', scene?.children?.length || 0);
            // Hide preloader after 3D is ready
            hidePreloader();
            console.log('=== loadDesignData COMPLETE ===');
            // Log view activity
            logActivity('view');

            // Subscribe to realtime updates for live sync
            // Customers will see designer changes instantly
            if (SHARE_STATE.isSharedView && SHARE_STATE.designId) {
              subscribeToDesignUpdates(SHARE_STATE.designId);
              console.log('Realtime subscription initiated for design:', SHARE_STATE.designId);
            }
          }, 300);
        }, 800);

      } catch (err) {
        console.error('loadDesignData error:', err);
        alert('Error loading design: ' + err.message);
        hidePreloader();
      }
    }

    // Load shared design from token
    async function loadSharedDesign(shareToken) {
      console.log('=== loadSharedDesign START ===');
      console.log('Token:', shareToken);

      // Show cloud preloader with Remodely AI branding
      showPreloader('Initializing 3D workspace');

      try {
        const supabase = getSupabaseClient();
        console.log('Supabase client:', supabase ? 'available' : 'NOT AVAILABLE');

        if (!supabase) {
          console.warn('Supabase not available for loading shared design, trying localStorage...');

          // Try localStorage fallback
          const localShares = JSON.parse(localStorage.getItem('roomDesignerLocalShares') || '{}');
          const localDesign = localShares[shareToken];

          if (localDesign) {
            console.log('Found design in localStorage:', localDesign.name);
            loadDesignData(localDesign, localDesign.permission_level || 'full_collab');
            showToast('Design loaded from local storage (offline mode)', 'info');
            return;
          }

          hidePreloader();
          showShareLinkError('Cannot load shared design - database connection unavailable. Please try again later.');
          return;
        }

        // Use centralized config
        const { url: SUPABASE_URL, anonKey: SUPABASE_ANON_KEY } = getSupabaseConfig();
        const headers = {
          'apikey': SUPABASE_ANON_KEY,
          'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
          'Accept': 'application/json',
          'Content-Type': 'application/json'
        };

        // First try to get the share record by share_token
        console.log('Querying room_design_shares for token:', shareToken);
        let shareData = null;
        let shareError = null;

        try {
          const shareRes = await fetch(
            `${SUPABASE_URL}/rest/v1/room_design_shares?share_token=eq.${shareToken}&select=*`,
            { headers }
          );
          const shareResults = await shareRes.json();
          shareData = shareResults.length > 0 ? shareResults[0] : null;
          console.log('Share query result:', shareData);
        } catch (e) {
          shareError = e;
          console.error('Share query error:', e);
        }

        // If not found by share_token, try to find by design token directly
        if (!shareData) {
          console.log('Not found in shares, trying room_designs directly...');

          try {
            const designRes = await fetch(
              `${SUPABASE_URL}/rest/v1/room_designs?share_token=eq.${shareToken}&select=*`,
              { headers }
            );
            const designResults = await designRes.json();
            const directDesign = designResults.length > 0 ? designResults[0] : null;

            console.log('Direct design query result:', directDesign);

            if (directDesign) {
              // Found as a direct design link - load it directly
              loadDesignData(directDesign, 'full_collab');
              return;
            }
          } catch (e) {
            console.error('Design query error:', e);
          }

          // Try localStorage fallback for local testing
          console.log('Trying localStorage fallback...');
          const localShares = JSON.parse(localStorage.getItem('roomDesignerLocalShares') || '{}');
          const localDesign = localShares[shareToken];

          if (localDesign) {
            console.log('Found design in localStorage:', localDesign.name);
            loadDesignData(localDesign, localDesign.permission_level || 'full_collab');
            showToast('Design loaded from local storage', 'info');
            return;
          }

          console.error('Share error:', shareError);
          hidePreloader();
          showShareLinkError('Share link not found or expired. Please ask the designer for a new link.');
          return;
        }

        // Then get the associated design using direct fetch
        console.log('Loading design with id:', shareData.design_id);
        let design = null;
        try {
          const designRes = await fetch(
            `${SUPABASE_URL}/rest/v1/room_designs?id=eq.${shareData.design_id}&select=*`,
            { headers }
          );
          const designResults = await designRes.json();
          design = designResults.length > 0 ? designResults[0] : null;
        } catch (e) {
          console.error('Design fetch error:', e);
        }

        if (!design) {
          console.error('Design not found for id:', shareData.design_id);
          hidePreloader();
          showShareLinkError('Design not found or has been deleted.');
          return;
        }

        // Update access count (fire and forget, don't block on this)
        fetch(`${SUPABASE_URL}/rest/v1/room_design_shares?id=eq.${shareData.id}`, {
          method: 'PATCH',
          headers,
          body: JSON.stringify({
            access_count: (shareData.access_count || 0) + 1,
            last_accessed_at: new Date().toISOString()
          })
        }).catch(e => console.warn('Could not update access count:', e));

        const permission = shareData.permission_level;

        // Use the helper function to load the design
        loadDesignData(design, permission, shareData);

      } catch (err) {
        console.error('Load shared design error:', err);
        hidePreloader();
        showShareLinkError('Error loading shared design: ' + err.message);
      }
    }

    // Show error overlay when share link fails to load
    function showShareLinkError(message) {
      // Hide the main canvas area and show error instead
      const mainArea = document.querySelector('.main');
      if (mainArea) {
        mainArea.innerHTML = `
          <div class="share-error-overlay" style="
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: var(--bg);
            z-index: 1000;
            text-align: center;
            padding: 40px;
          ">
            <svg viewBox="0 0 24 24" fill="none" stroke="var(--text-muted)" stroke-width="1.5" style="width: 80px; height: 80px; margin-bottom: 24px; opacity: 0.5;">
              <circle cx="12" cy="12" r="10"/>
              <path d="M15 9l-6 6M9 9l6 6"/>
            </svg>
            <h2 style="color: var(--text); margin: 0 0 16px 0; font-size: 24px;">Link Unavailable</h2>
            <p style="color: var(--text-muted); margin: 0 0 32px 0; max-width: 400px; line-height: 1.6;">
              ${message}
            </p>
            <div style="display: flex; gap: 12px;">
              <a href="/tools/room-designer/" class="btn btn-primary" style="text-decoration: none;">
                Start New Design
              </a>
              <a href="/" class="btn btn-secondary" style="text-decoration: none;">
                Go to Homepage
              </a>
            </div>
          </div>
        `;
      }
    }

    // Show the Review Room overlay UI
    function showReviewRoom(projectName, permission) {
      const permInfo = PERMISSION_LEVELS[permission];

      // Create review room overlay
      const reviewRoom = document.createElement('div');
      reviewRoom.id = 'reviewRoom';
      reviewRoom.className = 'review-room';
      reviewRoom.innerHTML = `
        <div class="review-header">
          <div class="review-header-left">
            <h2 class="review-title">${projectName || 'Design Review'}</h2>
            <span class="review-permission-badge">${permInfo?.name || permission}</span>
            <div id="liveIndicator" class="live-indicator disconnected" title="Connecting to live updates...">
              <span class="live-dot"></span>
              <span>LIVE</span>
            </div>
          </div>
          <div class="review-header-right">
            <button class="btn btn-secondary" onclick="toggleReviewPanel()">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:16px;height:16px;">
                <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"/>
              </svg>
              Review Panel
            </button>
            <button class="btn btn-secondary" id="toggle3DBtn" onclick="toggle3DView()">
              2D View
            </button>
            ${permission === 'full_collab' ? `
            <button class="btn btn-secondary" onclick="exitReviewMode()" title="Exit to Editor">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:16px;height:16px;">
                <path d="M18 6L6 18M6 6l12 12"/>
              </svg>
            </button>
            ` : ''}
          </div>
        </div>

        <div class="review-panel" id="reviewPanel">
          <div class="review-panel-header">
            <h3>Design Elements</h3>
            <button class="review-panel-close" onclick="toggleReviewPanel()"></button>
          </div>

          <div class="review-summary">
            <div class="review-stat">
              <span class="stat-value" id="reviewTotal">$0</span>
              <span class="stat-label">Total Quote</span>
            </div>
            <div class="review-stat">
              <span class="stat-value" id="reviewItemCount">0</span>
              <span class="stat-label">Items</span>
            </div>
            <div class="review-stat">
              <span class="stat-value approved" id="reviewApproved">0</span>
              <span class="stat-label">Approved</span>
            </div>
          </div>

          <div class="review-elements" id="reviewElements">
            <!-- Populated by JS -->
          </div>

          <div class="review-comments-section">
            <h4>Comments</h4>
            <div class="review-comments" id="reviewComments">
              <!-- Populated by JS -->
            </div>
            <div class="review-comment-input">
              <input type="text" id="newCommentInput" placeholder="Add a comment..." onkeypress="if(event.key==='Enter')addReviewComment()">
              <button class="btn btn-primary btn-sm" onclick="addReviewComment()">Send</button>
            </div>
          </div>

          ${permission === 'quote_approval' ? `
          <div class="review-actions quote-approval-actions">
            <div class="approval-summary">
              <p class="approval-note">Review the design above. When ready, approve and pay to confirm your order.</p>
            </div>
            <button class="btn btn-success btn-lg approve-pay-btn" onclick="approveAndPay()">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:20px;height:20px;margin-right:8px;">
                <path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/>
                <polyline points="22 4 12 14.01 9 11.01"/>
              </svg>
              Approve & Pay Deposit
            </button>
            <p class="approval-terms">By clicking above, you approve this design and authorize a 50% deposit charge.</p>
          </div>
          ` : permission === 'full_collab' || permission === 'quote_view' ? `
          <div class="review-actions">
            <button class="btn btn-success" onclick="approveAllElements()">Approve All</button>
            <button class="btn btn-primary" onclick="submitReview()">Submit Review</button>
          </div>
          ` : ''}
        </div>
      `;

      document.body.appendChild(reviewRoom);

      // Apply permission-based UI adjustments
      applyPermissionRestrictions();

      // Populate review elements list
      console.log('Populating review with elements:', elements.length);
      updateReviewElements();
      updateReviewComments();
      updateReviewStats();

      // Auto-open the review panel for quote_view, full_collab, and quote_approval
      if (permission === 'quote_view' || permission === 'full_collab' || permission === 'quote_approval') {
        const panel = document.getElementById('reviewPanel');
        if (panel) {
          panel.classList.add('open');
          console.log('Auto-opened review panel for permission:', permission);
        }
      }
    }

    // Toggle review panel visibility
    function toggleReviewPanel() {
      const panel = document.getElementById('reviewPanel');
      if (panel) {
        panel.classList.toggle('open');
      }
    }

    // Exit review mode and return to normal editor
    function exitReviewMode() {
      const reviewRoom = document.getElementById('reviewRoom');
      if (reviewRoom) {
        reviewRoom.remove();
      }

      // Reset share state
      SHARE_STATE.isSharedView = false;
      SHARE_STATE.permission = 'full_collab';
      SHARE_STATE.allowedActions = PERMISSION_LEVELS.full_collab;

      // Switch back to 2D view
      setView('2d');

      // Re-enable all UI elements
      document.querySelectorAll('[data-permission-hidden]').forEach(el => {
        el.style.display = '';
        el.removeAttribute('data-permission-hidden');
      });

      draw();
    }

    // Update review elements list
    function updateReviewElements() {
      console.log('updateReviewElements called');
      const container = document.getElementById('reviewElements');
      if (!container) {
        console.log('Review elements container not found');
        return;
      }

      const canApprove = PERMISSION_LEVELS[SHARE_STATE.permission]?.canApprove || false;
      const canViewPrices = checkPermission('canViewPrices');
      console.log('canApprove:', canApprove, 'canViewPrices:', canViewPrices);

      if (elements.length === 0) {
        container.innerHTML = '<p class="empty-state">No elements in this design</p>';
        return;
      }

      container.innerHTML = elements.map((el, index) => {
        const priceInfo = getElementPrice(el);
        const margin = getElementMargin(el) || 30;
        let cost = priceInfo?.price || 0;
        if (['countertop', 'backsplash', 'flooring', 'tile'].includes(el.type)) {
          cost = (el.width || 1) * (el.height || 1) * cost;
        }
        const retail = cost * (1 + margin / 100);
        const status = el.status || 'pending';
        const statusIcon = status === 'approved' ? '' : status === 'rejected' ? '' : '';
        const statusClass = status;

        return `
          <div class="review-element ${statusClass}" data-index="${index}" onclick="selectReviewElement(${index})">
            <div class="review-element-header">
              <span class="review-element-status ${statusClass}">${statusIcon}</span>
              <span class="review-element-name">${el.label}</span>
              ${canViewPrices ? `<span class="review-element-price">$${(retail || 0).toFixed(2)}</span>` : ''}
            </div>
            <div class="review-element-details">
              <span>${formatDimension(el.width)}  ${formatDimension(el.height)}</span>
              ${el.material ? `<span class="review-element-material">${el.material}</span>` : ''}
            </div>
            ${canApprove ? `
            <div class="review-element-actions">
              <button class="btn-approve" onclick="event.stopPropagation(); setElementStatus(${index}, 'approved')" title="Approve"></button>
              <button class="btn-reject" onclick="event.stopPropagation(); setElementStatus(${index}, 'rejected')" title="Reject"></button>
              <button class="btn-comment" onclick="event.stopPropagation(); commentOnElement(${index})" title="Comment"></button>
            </div>
            ` : ''}
          </div>
        `;
      }).join('');
    }

    // Select an element from the review panel
    function selectReviewElement(index) {
      if (elements[index]) {
        selectedElement = elements[index];
        updateProperties();
        draw();

        // Highlight in 3D if available
        if (is3DMode) {
          // Could add 3D highlighting here
        }
      }
    }

    // Set element approval status
    async function setElementStatus(index, status) {
      if (elements[index]) {
        elements[index].status = status;
        updateReviewElements();
        updateReviewStats();
        draw();

        // Log activity
        const activityType = status === 'approved' ? 'approve' : 'reject';
        logActivity(activityType, index, elements[index].label);

        // Save status to database
        await saveReviewState();
      }
    }

    // Approve all elements
    async function approveAllElements() {
      elements.forEach(el => el.status = 'approved');
      updateReviewElements();
      updateReviewStats();
      draw();
      await saveReviewState();
    }

    // Comment on specific element
    function commentOnElement(index) {
      const comment = prompt(`Add comment for "${elements[index]?.label}":`);
      if (comment && comment.trim()) {
        const newComment = {
          elementIndex: index,
          elementLabel: elements[index]?.label,
          text: comment.trim(),
          timestamp: new Date().toISOString(),
          author: 'Reviewer'
        };
        SHARE_STATE.comments = SHARE_STATE.comments || [];
        SHARE_STATE.comments.push(newComment);
        updateReviewComments();
        saveReviewState();
      }
    }

    // Add general review comment
    async function addReviewComment() {
      const input = document.getElementById('newCommentInput');
      const text = input?.value?.trim();
      if (!text) return;

      const newComment = {
        text: text,
        timestamp: new Date().toISOString(),
        author: 'Customer',
        direction: 'inbound'
      };

      SHARE_STATE.comments = SHARE_STATE.comments || [];
      SHARE_STATE.comments.push(newComment);
      input.value = '';
      updateReviewComments();

      // Log comment activity
      logActivity('comment', null, null, text);

      // Save to customer_messages for unified communication
      if (SHARE_STATE.leadId) {
        try {
          // Direct Supabase insert for reliability
          const supabase = getSupabaseClient();
          if (supabase) {
            const { data, error } = await supabase
              .from('customer_messages')
              .insert({
                customer_id: SHARE_STATE.leadId,
                message: text,
                direction: 'inbound',
                channel: 'design_share',
                metadata: {
                  share_id: SHARE_STATE.shareId,
                  design_id: SHARE_STATE.designId,
                  author: 'Customer'
                }
              })
              .select()
              .single();

            if (error) {
              console.warn('Supabase insert error:', error);
            } else {
              console.log('Comment saved to customer_messages:', data);
            }
          }
        } catch (err) {
          console.warn('Could not save comment to messages:', err);
        }
      }

      await saveReviewState();
    }

    // Load comments from customer_messages table
    async function loadCommentsFromMessages(leadId, shareId) {
      try {
        const supabase = getSupabaseClient();
        if (!supabase) return;

        const { data: messages, error } = await supabase
          .from('customer_messages')
          .select('*')
          .eq('customer_id', leadId)
          .eq('channel', 'design_share')
          .order('created_at', { ascending: true });

        if (error) {
          console.warn('Could not load messages:', error);
          return;
        }

        if (messages && messages.length > 0) {
          // Convert messages to comment format and merge with existing
          const messageComments = messages
            .filter(m => !m.metadata?.share_id || m.metadata?.share_id === shareId)
            .map(m => ({
              text: m.message,
              timestamp: m.created_at,
              author: m.direction === 'outbound' ? (m.metadata?.author || 'Surprise Granite') : 'Customer',
              direction: m.direction,
              messageId: m.id
            }));

          // Merge with any existing JSONB comments, avoiding duplicates
          const existingTexts = new Set(SHARE_STATE.comments.map(c => c.text + c.timestamp));
          const newComments = messageComments.filter(c => !existingTexts.has(c.text + c.timestamp));

          SHARE_STATE.comments = [...SHARE_STATE.comments, ...newComments]
            .sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

          updateReviewComments();
        }
      } catch (err) {
        console.warn('Error loading comments from messages:', err);
      }
    }

    // Update comments display
    function updateReviewComments() {
      const container = document.getElementById('reviewComments');
      if (!container) return;

      const comments = SHARE_STATE.comments || [];

      if (comments.length === 0) {
        container.innerHTML = '<p class="empty-state">No comments yet. Start the conversation!</p>';
        return;
      }

      container.innerHTML = comments.map(c => {
        const isStaff = c.direction === 'outbound' || (c.author && c.author !== 'Customer' && c.author !== 'Reviewer');
        const safeAuthor = escapeHtml(c.author || 'Customer');
        const safeElementLabel = c.elementLabel ? escapeHtml(c.elementLabel) : null;
        return `
          <div class="review-comment ${isStaff ? 'staff-comment' : 'customer-comment'}" style="${isStaff ? 'background: rgba(249, 168, 37, 0.1); border-left: 3px solid var(--gold);' : ''}">
            <div class="comment-header">
              <span class="comment-author" style="${isStaff ? 'color: var(--gold);' : ''}">${safeAuthor}</span>
              ${safeElementLabel ? `<span class="comment-element">on ${safeElementLabel}</span>` : ''}
              <span class="comment-time">${new Date(c.timestamp).toLocaleString()}</span>
            </div>
            <div class="comment-text">${escapeHtml(c.text)}</div>
          </div>
        `;
      }).join('');

      container.scrollTop = container.scrollHeight;
    }

    // Escape HTML to prevent XSS in comments
    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    // Update review stats
    function updateReviewStats() {
      console.log('updateReviewStats called, elements:', elements.length);
      console.log('Can view prices:', checkPermission('canViewPrices'));

      const totalEl = document.getElementById('reviewTotal');
      const countEl = document.getElementById('reviewItemCount');
      const approvedEl = document.getElementById('reviewApproved');

      if (totalEl && checkPermission('canViewPrices')) {
        let total = 0;
        elements.forEach(el => {
          if (el.retailPrice) {
            total += el.retailPrice;
          } else {
            const priceInfo = getElementPrice(el);
            const margin = getElementMargin(el);
            let cost = priceInfo?.price || 0;
            if (['countertop', 'backsplash', 'flooring', 'tile'].includes(el.type)) {
              cost = (el.width || 1) * (el.height || 1) * cost;
            }
            total += cost * (1 + (margin || 30) / 100);
          }
        });
        console.log('Calculated total:', total);
        totalEl.textContent = '$' + total.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2});
      } else if (totalEl) {
        totalEl.textContent = '--';
      }

      if (countEl) countEl.textContent = elements.length;

      if (approvedEl) {
        const approved = elements.filter(el => el.status === 'approved').length;
        approvedEl.textContent = approved;
      }
    }

    // Save review state to database
    async function saveReviewState() {
      if (!SHARE_STATE.shareId) return;

      try {
        const supabase = getSupabaseClient();
        if (!supabase) return;

        // Save element statuses to the design
        await supabase
          .from('room_designs')
          .update({
            elements: elements.map(el => ({
              ...el,
              textureImg: null
            }))
          })
          .eq('id', SHARE_STATE.designId);

        // Save comments to the share record
        await supabase
          .from('room_design_shares')
          .update({
            comments: SHARE_STATE.comments
          })
          .eq('id', SHARE_STATE.shareId);

      } catch (err) {
        console.error('Error saving review state:', err);
      }
    }

    // Submit final review
    async function submitReview() {
      const approved = elements.filter(el => el.status === 'approved').length;
      const rejected = elements.filter(el => el.status === 'rejected').length;
      const pending = elements.filter(el => el.status === 'pending').length;

      const summary = `Review Summary:\n\n Approved: ${approved}\n Rejected: ${rejected}\n Pending: ${pending}\n\nSubmit this review?`;

      if (confirm(summary)) {
        await saveReviewState();
        alert('Review submitted! The design owner will be notified.');
      }
    }

    // Reload texture for an element
    function loadElementTexture(el) {
      if (!el.materialId) return;

      for (const category in MATERIALS) {
        const mat = MATERIALS[category].find(m => m.id === el.materialId);
        if (mat && mat.url) {
          const img = new Image();
          img.crossOrigin = 'anonymous';
          img.onload = () => {
            el.textureImg = img;
            draw();
          };
          img.src = mat.url;
          break;
        }
      }
    }

    // Apply UI restrictions based on permission level
    function applyPermissionRestrictions() {
      const perms = SHARE_STATE.allowedActions;
      if (!perms) return;

      console.log('Applying permission restrictions:', SHARE_STATE.permission, perms);

      // Hide/disable editing controls for non-edit permissions
      if (!perms.canEdit) {
        document.body.classList.add('review-readonly');
        document.body.classList.add('view-only-mode');

        // Hide the entire left sidebar (tools, cabinets, floor plans, etc.)
        const sidebar = document.querySelector('.sidebar');
        if (sidebar) {
          sidebar.style.display = 'none';
        }

        // Hide the top toolbar action buttons (save, export, etc.) except view controls
        const topToolbar = document.querySelector('.top-toolbar');
        if (topToolbar) {
          // Hide editing buttons but keep view/zoom controls
          topToolbar.querySelectorAll('button, .btn').forEach(btn => {
            const id = btn.id || '';
            const text = btn.textContent?.toLowerCase() || '';
            // Keep: 2D/3D toggle, zoom, view controls
            const keepVisible = id.includes('view') || id.includes('zoom') ||
                               id.includes('2d') || id.includes('3d') ||
                               text.includes('2d') || text.includes('3d') ||
                               btn.classList.contains('view-btn');
            if (!keepVisible) {
              btn.style.display = 'none';
            }
          });
        }

        // Hide the save button
        const saveBtn = document.getElementById('saveDesignBtn');
        if (saveBtn) saveBtn.style.display = 'none';

        // Hide the share button (viewers shouldn't reshare)
        const shareBtn = document.getElementById('shareDesignBtn');
        if (shareBtn) shareBtn.style.display = 'none';

        // Hide item picker / element picker
        const itemPicker = document.getElementById('itemPicker');
        if (itemPicker) itemPicker.style.display = 'none';

        // Hide element selector dropdown
        const elementSelector = document.getElementById('elementSelector');
        if (elementSelector) elementSelector.style.display = 'none';

        // Disable all tool buttons
        document.querySelectorAll('.tool-btn').forEach(btn => {
          btn.disabled = true;
          btn.style.opacity = '0.5';
          btn.style.pointerEvents = 'none';
        });

        // Disable element buttons
        document.querySelectorAll('.element-btn, .toolbar-btn').forEach(btn => {
          btn.disabled = true;
          btn.style.opacity = '0.5';
          btn.style.pointerEvents = 'none';
        });

        // Disable properties panel inputs
        const propsContent = document.getElementById('propertiesContent');
        if (propsContent) {
          propsContent.querySelectorAll('input, select, button').forEach(el => {
            el.disabled = true;
          });
        }

        // Hide the floating action buttons
        const floatingActions = document.querySelector('.floating-actions');
        if (floatingActions) floatingActions.style.display = 'none';

        // Hide quick actions
        const quickActions = document.querySelector('.quick-actions');
        if (quickActions) quickActions.style.display = 'none';

        // Hide the delete/duplicate buttons in context
        document.querySelectorAll('[onclick*="delete"], [onclick*="duplicate"], [onclick*="Delete"], [onclick*="Duplicate"]').forEach(el => {
          el.style.display = 'none';
        });

        // Expand the canvas area since sidebar is hidden
        const workspace = document.querySelector('.workspace');
        if (workspace) {
          workspace.style.gridTemplateColumns = '1fr';
        }

        // Show a viewer badge
        showViewerModeBadge(perms);
      }

      // Hide pricing elements in main panel (shown in review panel instead)
      if (!perms.canViewPrices) {
        const quotePanel = document.getElementById('quotePanel');
        if (quotePanel) quotePanel.style.display = 'none';

        // Hide price-related elements
        document.querySelectorAll('.price-display, .quote-total, .element-price').forEach(el => {
          el.style.display = 'none';
        });
      }

      // Hide cost view toggle
      if (!perms.canViewCosts) {
        const costBtn = document.getElementById('costViewBtn');
        if (costBtn) costBtn.style.display = 'none';
      }

      // Show presentation mode for presentation permission
      if (SHARE_STATE.permission === 'presentation') {
        document.body.classList.add('presentation-mode');
      }

      // Material view hides most UI
      if (SHARE_STATE.permission === 'material_view') {
        document.body.classList.add('material-view-mode');
      }

      // Auto-open review panel after a delay
      setTimeout(() => {
        const panel = document.getElementById('reviewPanel');
        if (panel) panel.classList.add('open');
      }, 1000);
    }

    // Show a badge indicating viewer mode
    function showViewerModeBadge(perms) {
      // Remove any existing badge
      const existing = document.getElementById('viewerModeBadge');
      if (existing) existing.remove();

      const badge = document.createElement('div');
      badge.id = 'viewerModeBadge';
      badge.className = 'viewer-mode-badge';

      const permName = PERMISSION_LEVELS[SHARE_STATE.permission]?.name || 'View Only';
      const icon = perms.canApprove ? '' : '';

      badge.innerHTML = `
        <span class="badge-icon">${icon}</span>
        <span class="badge-text">${permName}</span>
        ${perms.canApprove ? '<span class="badge-action">Review & Approve</span>' : ''}
      `;

      document.body.appendChild(badge);
    }

    function showPermissionNotice(permission) {
      const permInfo = PERMISSION_LEVELS[permission];
      if (!permInfo) return;

      const notice = document.createElement('div');
      notice.className = 'permission-notice';
      notice.innerHTML = `
        <div class="notice-content">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:18px;height:18px;">
            <circle cx="12" cy="12" r="10"/>
            <path d="M12 16v-4"/>
            <path d="M12 8h.01"/>
          </svg>
          <span>Viewing as: <strong>${permInfo.name}</strong></span>
          <button onclick="this.parentElement.parentElement.remove()" style="background:none;border:none;color:inherit;cursor:pointer;font-size:16px;"></button>
        </div>
      `;
      document.body.appendChild(notice);

      setTimeout(() => notice.remove(), 8000);
    }

    // Load active shares for current design
    async function loadActiveShares() {
      if (!SHARE_STATE.designId) return;

      try {
        const supabase = getSupabaseClient();
        if (!supabase) return;

        const { data, error } = await supabase
          .from('room_design_shares')
          .select('*')
          .eq('design_id', SHARE_STATE.designId)
          .order('created_at', { ascending: false });

        if (error) throw error;

        renderActiveShares(data || []);

        // Also load recent activity
        loadRecentActivity();
      } catch (err) {
        console.error('Load shares error:', err);
      }
    }

    function renderActiveShares(shares) {
      const container = document.getElementById('activeShares');
      const list = document.getElementById('sharesList');
      if (!container || !list) return;

      if (shares.length === 0) {
        container.style.display = 'none';
        return;
      }

      container.style.display = 'block';
      list.innerHTML = shares.map(share => `
        <div class="share-item">
          <div class="share-info">
            <span class="share-permission">${PERMISSION_LEVELS[share.permission_level]?.name || share.permission_level}</span>
            <span class="share-stats">${share.access_count || 0} views</span>
          </div>
          <div class="share-actions">
            <button class="btn btn-sm" onclick="copyToClipboard('${window.location.origin}${window.location.pathname}?share=${share.share_token}')">Copy</button>
            <button class="btn btn-sm btn-danger" onclick="revokeShare('${share.id}')">Revoke</button>
          </div>
        </div>
      `).join('');
    }

    function copyToClipboard(text) {
      navigator.clipboard.writeText(text).then(() => {
        alert('Copied to clipboard!');
      }).catch(() => {
        const temp = document.createElement('textarea');
        temp.value = text;
        document.body.appendChild(temp);
        temp.select();
        document.execCommand('copy');
        document.body.removeChild(temp);
        alert('Copied to clipboard!');
      });
    }

    async function revokeShare(shareId) {
      if (!confirm('Revoke this share link? Anyone with this link will no longer be able to access.')) return;

      try {
        const supabase = getSupabaseClient();
        if (!supabase) return;

        const { error } = await supabase
          .from('room_design_shares')
          .delete()
          .eq('id', shareId);

        if (error) throw error;

        loadActiveShares();
      } catch (err) {
        alert('Error revoking share: ' + err.message);
      }
    }

    // Log activity for notifications
    async function logActivity(type, elementIndex = null, elementName = null, commentText = null) {
      if (!SHARE_STATE.designId) return;

      try {
        const supabase = getSupabaseClient();
        if (!supabase) return;

        await supabase.from('design_activity').insert({
          design_id: SHARE_STATE.designId,
          share_id: SHARE_STATE.shareId,
          activity_type: type,
          element_index: elementIndex,
          element_name: elementName,
          comment_text: commentText
        });
      } catch (err) {
        console.error('Error logging activity:', err);
      }
    }

    // Load recent activity for a design
    async function loadRecentActivity() {
      if (!SHARE_STATE.designId) return;

      try {
        const supabase = getSupabaseClient();
        if (!supabase) return;

        const { data, error } = await supabase
          .from('design_activity')
          .select('*')
          .eq('design_id', SHARE_STATE.designId)
          .order('created_at', { ascending: false })
          .limit(20);

        if (error) throw error;

        renderActivityList(data || []);
      } catch (err) {
        console.error('Error loading activity:', err);
      }
    }

    // Render the activity list
    function renderActivityList(activities) {
      const container = document.getElementById('recentActivity');
      const list = document.getElementById('activityList');
      if (!container || !list) return;

      if (activities.length === 0) {
        container.style.display = 'none';
        return;
      }

      container.style.display = 'block';

      const icons = {
        view: '',
        comment: '',
        approve: '',
        reject: ''
      };

      const formatTime = (timestamp) => {
        const date = new Date(timestamp);
        const now = new Date();
        const diffMs = now - date;
        const diffMins = Math.floor(diffMs / 60000);
        const diffHours = Math.floor(diffMs / 3600000);
        const diffDays = Math.floor(diffMs / 86400000);

        if (diffMins < 1) return 'Just now';
        if (diffMins < 60) return `${diffMins}m ago`;
        if (diffHours < 24) return `${diffHours}h ago`;
        if (diffDays < 7) return `${diffDays}d ago`;
        return date.toLocaleDateString();
      };

      const getActivityText = (activity) => {
        switch (activity.activity_type) {
          case 'view':
            return 'Someone viewed the design';
          case 'comment':
            return `Comment: "${activity.comment_text?.substring(0, 50)}${activity.comment_text?.length > 50 ? '...' : ''}"`;
          case 'approve':
            return `Approved: ${activity.element_name || 'an element'}`;
          case 'reject':
            return `Rejected: ${activity.element_name || 'an element'}`;
          default:
            return 'Activity';
        }
      };

      list.innerHTML = activities.map(activity => `
        <div class="activity-item">
          <div class="activity-icon ${activity.activity_type}">${icons[activity.activity_type] || ''}</div>
          <div class="activity-content">
            <div class="activity-text">${getActivityText(activity)}</div>
            <div class="activity-time">${formatTime(activity.created_at)}</div>
          </div>
        </div>
      `).join('');
    }

    // Check URL for shared design token on page load
    function checkSharedDesignUrl() {
      const urlParams = new URLSearchParams(window.location.search);
      // Check for both 'share' and 'p' parameters
      const shareToken = urlParams.get('share') || urlParams.get('p');

      console.log('Checking shared design URL:', window.location.search);
      console.log('Share token found:', shareToken);

      if (shareToken) {
        console.log('Loading shared design with token:', shareToken);
        loadSharedDesign(shareToken);
      }
    }

    // Check for lead info passed from account page
    // Global lead info storage for quote integration
    let currentLeadInfo = null;

    function checkLeadInfo() {
      const urlParams = new URLSearchParams(window.location.search);
      const fromLead = urlParams.get('from_lead');

      if (!fromLead) return;

      try {
        const leadInfoJson = sessionStorage.getItem('sg_lead_for_design');
        if (!leadInfoJson) return;

        const leadInfo = JSON.parse(leadInfoJson);
        console.log('Loading design from lead:', leadInfo);

        // Store lead info globally for use in quotes and estimates
        currentLeadInfo = {
          id: leadInfo.id,
          name: leadInfo.full_name || '',
          email: leadInfo.email || '',
          phone: leadInfo.phone || '',
          address: leadInfo.address || '',
          projectType: leadInfo.project_type || '',
          notes: leadInfo.message || ''
        };

        // Pre-fill project name with customer name and project type
        const projectNameField = document.getElementById('projectName');
        if (projectNameField) {
          const projectType = leadInfo.project_type ? `${leadInfo.project_type.charAt(0).toUpperCase() + leadInfo.project_type.slice(1)} ` : '';
          projectNameField.value = `${leadInfo.full_name} - ${projectType}Design`;
          currentProjectName = projectNameField.value;
        }

        // Set room type based on project type
        const roomTypeField = document.getElementById('roomType');
        if (roomTypeField && leadInfo.project_type) {
          const typeMap = {
            'kitchen': 'kitchen',
            'bathroom': 'bathroom',
            'flooring': 'living-room',
            'fireplace': 'living-room',
            'outdoor': 'outdoor-kitchen',
            'commercial': 'commercial'
          };
          const roomType = typeMap[leadInfo.project_type.toLowerCase()] || 'kitchen';
          roomTypeField.value = roomType;
          changeRoomType();
        }

        // Store lead ID for later association
        window.currentLeadId = leadInfo.id;

        // Also save to localStorage for persistence if page refreshes
        localStorage.setItem('sg_current_lead_info', JSON.stringify(currentLeadInfo));

        // Clear sessionStorage to prevent reuse on new tabs
        sessionStorage.removeItem('sg_lead_for_design');

        // Clean up URL
        history.replaceState(null, '', window.location.pathname);

        // Show lead context banner
        showLeadContextBanner(leadInfo.full_name);

        showNotification(`Design started for ${leadInfo.full_name}`, 'success');
      } catch (e) {
        console.error('Error loading lead info:', e);
      }
    }

    // Show a banner indicating this design is linked to a lead
    function showLeadContextBanner(customerName) {
      // Check if banner already exists
      if (document.getElementById('leadContextBanner')) return;

      const banner = document.createElement('div');
      banner.id = 'leadContextBanner';
      banner.style.cssText = `
        position: fixed;
        top: 56px;
        left: 50%;
        transform: translateX(-50%);
        background: linear-gradient(135deg, rgba(99, 102, 241, 0.9) 0%, rgba(139, 92, 246, 0.9) 100%);
        backdrop-filter: blur(10px);
        padding: 8px 20px;
        border-radius: 0 0 12px 12px;
        font-size: 12px;
        font-weight: 500;
        color: white;
        z-index: 200;
        display: flex;
        align-items: center;
        gap: 10px;
        box-shadow: 0 4px 20px rgba(99, 102, 241, 0.3);
      `;
      banner.innerHTML = `
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:14px;height:14px;">
          <path d="M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"/>
          <circle cx="8.5" cy="7" r="4"/>
          <line x1="20" y1="8" x2="20" y2="14"/><line x1="23" y1="11" x2="17" y2="11"/>
        </svg>
        <span>Designing for: <strong>${customerName}</strong></span>
        <button onclick="clearLeadContext()" style="background:rgba(255,255,255,0.2);border:none;color:white;padding:2px 8px;border-radius:4px;cursor:pointer;font-size:10px;margin-left:8px;">
          Clear
        </button>
      `;
      document.body.appendChild(banner);
    }

    // Clear lead context
    function clearLeadContext() {
      currentLeadInfo = null;
      window.currentLeadId = null;
      localStorage.removeItem('sg_current_lead_info');

      const banner = document.getElementById('leadContextBanner');
      if (banner) banner.remove();

      showNotification('Lead context cleared', 'info');
    }

    // Restore lead info from localStorage on page load
    function restoreLeadInfo() {
      try {
        const savedLead = localStorage.getItem('sg_current_lead_info');
        if (savedLead) {
          currentLeadInfo = JSON.parse(savedLead);
          window.currentLeadId = currentLeadInfo.id;
          showLeadContextBanner(currentLeadInfo.name);
        }
      } catch (e) {
        console.error('Error restoring lead info:', e);
      }
    }

    function clearCanvas() {
      if (!confirm('Clear all elements from canvas?\n\nRoom settings will be preserved.\nYour progress will still be auto-saved.')) return;

      elements = [];
      walls = walls.filter(w => w.type === 'area');
      selectedElement = null;

      updateProperties();
      updateElementSelector();
      updateItemPicker();
      calculateQuote();
      saveUndoState(); // This also triggers auto-save
      draw();
      render3D();

      showToast('Canvas cleared', 'info');
    }

    // ===== EXPORT FUNCTIONALITY =====
    function toggleExportMenu() {
      const menu = document.getElementById('exportMenu');
      menu.classList.toggle('show');

      // Close when clicking outside
      const closeHandler = (e) => {
        if (!e.target.closest('.export-dropdown')) {
          menu.classList.remove('show');
          document.removeEventListener('click', closeHandler);
        }
      };

      setTimeout(() => {
        document.addEventListener('click', closeHandler);
      }, 0);
    }

    function exportToPDF() {
      document.getElementById('exportMenu').classList.remove('show');

      const { jsPDF } = window.jspdf;
      const doc = new jsPDF('p', 'mm', 'letter');

      const projectName = document.getElementById('projectName').value || 'Room Design';
      const roomType = document.getElementById('roomType').value;
      const quoteTotal = document.getElementById('quoteTotal').textContent;

      // Header
      doc.setFillColor(184, 154, 91); // Gold color
      doc.rect(0, 0, 216, 35, 'F');

      doc.setTextColor(0, 0, 0);
      doc.setFontSize(24);
      doc.setFont('helvetica', 'bold');
      doc.text('Surprise Granite', 15, 20);

      doc.setFontSize(10);
      doc.setFont('helvetica', 'normal');
      doc.text('Room Design Proposal', 15, 28);

      // Project info
      doc.setTextColor(51, 51, 51);
      doc.setFontSize(16);
      doc.setFont('helvetica', 'bold');
      doc.text(projectName, 15, 50);

      doc.setFontSize(11);
      doc.setFont('helvetica', 'normal');
      doc.setTextColor(102, 102, 102);
      doc.text(`Room Type: ${roomType.charAt(0).toUpperCase() + roomType.slice(1)}`, 15, 58);
      doc.text(`Dimensions: ${roomWidth}'  ${roomDepth}'`, 15, 65);
      doc.text(`Date: ${new Date().toLocaleDateString()}`, 15, 72);

      // Canvas image - 2D floor plan
      const canvas2D = document.getElementById('canvas');
      const imgData2D = canvas2D.toDataURL('image/png');
      doc.text('2D Floor Plan', 15, 85);
      doc.addImage(imgData2D, 'PNG', 15, 88, 85, 65);

      // 3D view if available
      if (renderer) {
        renderer.render(scene, camera);
        const imgData3D = renderer.domElement.toDataURL('image/png');
        doc.text('3D Visualization', 110, 85);
        doc.addImage(imgData3D, 'PNG', 110, 88, 85, 65);
      }

      // Elements list
      let yPos = 165;
      doc.setFontSize(14);
      doc.setFont('helvetica', 'bold');
      doc.setTextColor(51, 51, 51);
      doc.text('Design Elements', 15, yPos);
      yPos += 8;

      doc.setFontSize(10);
      doc.setFont('helvetica', 'normal');

      // Table header
      doc.setFillColor(240, 240, 240);
      doc.rect(15, yPos, 180, 8, 'F');
      doc.setTextColor(51, 51, 51);
      doc.text('Item', 18, yPos + 5.5);
      doc.text('Type', 75, yPos + 5.5);
      doc.text('Dimensions', 120, yPos + 5.5);
      doc.text('Material', 155, yPos + 5.5);
      yPos += 10;

      elements.forEach((el, index) => {
        if (yPos > 250) {
          doc.addPage();
          yPos = 20;
        }

        const bgColor = index % 2 === 0 ? [255, 255, 255] : [248, 248, 248];
        doc.setFillColor(...bgColor);
        doc.rect(15, yPos - 4, 180, 8, 'F');

        doc.setTextColor(51, 51, 51);
        doc.text(el.label || 'Element', 18, yPos + 1);
        doc.text(el.type.replace(/-/g, ' '), 75, yPos + 1);
        doc.text(`${el.width}'  ${el.height}'`, 120, yPos + 1);
        doc.text(el.material || '-', 155, yPos + 1);
        yPos += 8;
      });

      // Quote total
      yPos += 10;
      doc.setFillColor(184, 154, 91);
      doc.rect(15, yPos, 180, 15, 'F');
      doc.setTextColor(0, 0, 0);
      doc.setFontSize(14);
      doc.setFont('helvetica', 'bold');
      doc.text('Estimated Total:', 20, yPos + 10);
      doc.text(quoteTotal, 155, yPos + 10);

      // Footer
      doc.setFontSize(8);
      doc.setTextColor(128, 128, 128);
      doc.text('This is an estimate only. Final pricing may vary based on material selection and installation requirements.', 15, 270);
      doc.text('Surprise Granite  surprisegranite.com  (623) 466-4177', 15, 276);

      doc.save(`${projectName.replace(/\s+/g, '-')}-proposal.pdf`);
    }

    function exportToJSON() {
      document.getElementById('exportMenu').classList.remove('show');

      const projectName = document.getElementById('projectName').value || 'Room Design';

      const designData = {
        version: '1.0',
        projectName: projectName,
        roomType: document.getElementById('roomType').value,
        roomWidth: roomWidth,
        roomDepth: roomDepth,
        elements: elements.map(el => ({
          id: el.id,
          type: el.type,
          label: el.label,
          x: el.x,
          y: el.y,
          width: el.width,
          height: el.height,
          rotation: el.rotation,
          color: el.color,
          material: el.material,
          materialId: el.materialId,
          category: el.category,
          catalogSku: el.catalogSku
        })),
        walls: walls,
        createdAt: new Date().toISOString()
      };

      const jsonStr = JSON.stringify(designData, null, 2);
      const blob = new Blob([jsonStr], { type: 'application/json' });
      const url = URL.createObjectURL(blob);

      const a = document.createElement('a');
      a.href = url;
      a.download = `${projectName.replace(/\s+/g, '-')}-design.json`;
      a.click();

      URL.revokeObjectURL(url);
    }

    function importFromJSON() {
      document.getElementById('exportMenu').classList.remove('show');

      const input = document.createElement('input');
      input.type = 'file';
      input.accept = '.json';

      input.onchange = (e) => {
        const file = e.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = (event) => {
          try {
            const data = JSON.parse(event.target.result);

            if (!data.version || !data.elements) {
              throw new Error('Invalid design file format');
            }

            // Restore design
            document.getElementById('projectName').value = data.projectName || 'Imported Design';
            document.getElementById('roomType').value = data.roomType || 'kitchen';
            roomWidth = data.roomWidth || 12;
            roomDepth = data.roomDepth || 10;
            document.getElementById('roomWidth').value = roomWidth;
            document.getElementById('roomDepth').value = roomDepth;

            // Restore elements
            elements = data.elements.map(el => ({
              ...el,
              textureImg: null // Will reload texture if needed
            }));

            // Restore nextGroupId from locked elements
            let maxGroupNum = 0;
            elements.forEach(el => {
              if (el.groupId) {
                const match = el.groupId.match(/group-(\d+)/);
                if (match) {
                  maxGroupNum = Math.max(maxGroupNum, parseInt(match[1]));
                }
              }
            });
            nextGroupId = maxGroupNum + 1;

            // Reload textures for elements
            elements.forEach(el => {
              if (el.materialId) {
                const category = Object.keys(MATERIALS).find(cat =>
                  MATERIALS[cat].some(m => m.id === el.materialId)
                );
                if (category) {
                  const material = MATERIALS[category].find(m => m.id === el.materialId);
                  if (material && material.url) {
                    const img = new Image();
                    img.crossOrigin = 'anonymous';
                    img.onload = () => {
                      el.textureImg = img;
                      draw();
                    };
                    img.src = material.url;
                  }
                }
              }
            });

            walls = data.walls || walls;

            selectedElement = null;
            updateProperties();
            calculateQuote();
            saveUndoState();
            draw();
            update3DScene();

            alert('Design loaded successfully!');
          } catch (err) {
            alert('Error loading design: ' + err.message);
          }
        };
        reader.readAsText(file);
      };

      input.click();
    }

    function exportToPNG() {
      document.getElementById('exportMenu').classList.remove('show');

      const projectName = document.getElementById('projectName').value || 'Room Design';
      const currentView = document.querySelector('.view-btn.active').id;

      let canvas;
      if (currentView === 'view3D' && renderer) {
        renderer.render(scene, camera);
        canvas = renderer.domElement;
      } else {
        canvas = document.getElementById('canvas');
      }

      const link = document.createElement('a');
      link.download = `${projectName.replace(/\s+/g, '-')}-${currentView === 'view3D' ? '3d' : '2d'}.png`;
      link.href = canvas.toDataURL('image/png');
      link.click();
    }

    function exportToCSV() {
      document.getElementById('exportMenu').classList.remove('show');

      const projectName = document.getElementById('projectName').value || 'Room Design';

      let csv = 'Item,Type,Category,Width (ft),Height (ft),Material,SKU,Notes\n';

      elements.forEach(el => {
        const row = [
          `"${el.label || 'Element'}"`,
          `"${el.type.replace(/-/g, ' ')}"`,
          `"${el.category || ''}"`,
          el.width,
          el.height,
          `"${el.material || ''}"`,
          `"${el.catalogSku || ''}"`,
          `""`
        ];
        csv += row.join(',') + '\n';
      });

      // Summary section
      csv += '\n';
      csv += 'Summary\n';
      csv += `Project,${projectName}\n`;
      csv += `Room Type,${document.getElementById('roomType').value}\n`;
      csv += `Room Dimensions,${roomWidth}' x ${roomDepth}'\n`;
      csv += `Total Elements,${elements.length}\n`;
      csv += `Estimated Total,${document.getElementById('quoteTotal').textContent}\n`;
      csv += `Generated,${new Date().toLocaleString()}\n`;

      const blob = new Blob([csv], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);

      const a = document.createElement('a');
      a.href = url;
      a.download = `${projectName.replace(/\s+/g, '-')}-parts-list.csv`;
      a.click();

      URL.revokeObjectURL(url);
    }

    // ===== MY DESIGNS MODAL =====
    let currentDesignsTab = 'my';
    let allDesigns = { my: [], shared: [], recent: [] };

    function openMyDesignsModal() {
      document.getElementById('myDesignsModal').classList.add('active');
      loadMyDesigns();
    }

    // Save current design to local storage
    function saveDesignLocally() {
      const projectName = document.getElementById('projectName').value || 'Untitled Design';
      const roomType = document.getElementById('roomType').value || 'kitchen';

      const design = {
        id: 'local-' + Date.now(),
        name: projectName,
        room_type: roomType,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString(),
        room_width: roomWidth,
        room_depth: roomDepth,
        elements: elements.map(el => serializeElement(el)),
        walls: walls.map(w => serializeWall(w)),
        rooms: rooms.map(r => ({
          ...r,
          elements: (r.elements || []).map(el =>
            el.xFt !== undefined ? { ...el, textureImg: null } : serializeElement(el)
          ),
          walls: (r.walls || []).map(w =>
            w.x1Ft !== undefined ? { ...w } : serializeWall(w)
          )
        })),
        settings: {
          pixelsPerFoot: pixelsPerFoot
        }
      };

      // Get existing designs
      let designs = [];
      try {
        designs = JSON.parse(localStorage.getItem('room_designs') || '[]');
      } catch (e) {}

      // Add new design at the beginning
      designs.unshift(design);

      // Keep only last 10 designs to avoid quota issues
      designs = designs.slice(0, 10);

      try {
        localStorage.setItem('room_designs', JSON.stringify(designs));
      } catch (quotaErr) {
        // Quota exceeded  aggressively trim and retry
        console.warn('Local save quota exceeded, trimming designs...');
        try {
          designs = designs.slice(0, 3);
          localStorage.removeItem(AUTOSAVE_KEY + '_backup');
          localStorage.setItem('room_designs', JSON.stringify(designs));
        } catch (retryErr) {
          // Last resort: clear old designs, keep only current
          try {
            localStorage.setItem('room_designs', JSON.stringify([design]));
          } catch (finalErr) {
            console.error('Cannot save locally  storage completely full');
            return design;
          }
        }
      }
      showSnapFeedback('Design saved locally');
      return design;
    }

    // Save design to cloud (Supabase) or locally
    async function saveDesignToCloud() {
      console.log('saveDesignToCloud called');
      const saveBtn = document.getElementById('saveDesignBtn');
      const saveText = document.getElementById('saveDesignText');

      // Show saving state
      if (saveBtn) saveBtn.disabled = true;
      if (saveText) saveText.textContent = 'Saving...';

      try {
        // Check if user is logged in
        const user = window.SgAuth?.getUser();
        console.log('Save - user:', user?.id);

        if (!user) {
          // Save locally if not logged in
          saveDesignLocally();
          showToast('Design saved locally. Sign in to save to cloud.', 'info');
          return;
        }

        const projectName = document.getElementById('projectName').value || 'Untitled Design';
        const roomType = document.getElementById('roomType').value || 'kitchen';

        // Save current room state
        saveCurrentRoomState();

        // Calculate quote total
        let quoteTotal = 0;
        elements.forEach(el => {
          const priceInfo = getElementPrice(el);
          const margin = getElementMargin(el) || 30;
          let cost = priceInfo?.price || 0;
          if (['countertop', 'backsplash', 'flooring', 'tile'].includes(el.type)) {
            cost = (el.width || 1) * (el.height || 1) * cost;
          }
          quoteTotal += cost * (1 + margin / 100);
        });

        // Get company name from profile
        let companyName = 'My Design';
        try {
          const profile = await window.SgAuth?.getProfile();
          if (profile?.company_name) {
            companyName = profile.company_name;
          } else if (profile?.full_name) {
            companyName = profile.full_name;
          }
        } catch (e) {
          console.log('Could not fetch profile:', e);
        }

        const designData = {
          user_id: user.id,
          name: projectName,
          room_type: roomType,
          room_width: roomWidth,
          room_depth: roomDepth,
          elements: elements.map(el => serializeElement(el)),
          settings: {
            walls: walls.map(w => serializeWall(w)),
            pricing_config: {
              globalMargin: PRICING_STATE.globalMargin,
              categoryMargins: PRICING_STATE.categoryMargins,
              customPrices: PRICING_STATE.customPrices
            },
            company_name: companyName,
            current_room_id: currentRoomId,
            pixelsPerFoot: pixelsPerFoot,
            // Multi-room support (stored in settings to avoid column mismatch)
            rooms: rooms.map(room => ({
              ...room,
              elements: (room.elements || []).map(el =>
                el.xFt !== undefined ? { ...el, textureImg: null } : serializeElement(el)
              ),
              walls: (room.walls || []).map(w =>
                w.x1Ft !== undefined ? { ...w } : serializeWall(w)
              )
            }))
          },
          quote_total: quoteTotal
        };

        const { url: SUPABASE_URL, anonKey: SUPABASE_ANON_KEY } = getSupabaseConfig();

        const session = await window.SgAuth?.getSession?.();
        const authToken = session?.access_token || SUPABASE_ANON_KEY;

        const headers = {
          'apikey': SUPABASE_ANON_KEY,
          'Authorization': `Bearer ${authToken}`,
          'Accept': 'application/json',
          'Content-Type': 'application/json',
          'Prefer': 'return=representation'
        };

        let designId = SHARE_STATE.designId;

        // If it's a local design ID, we need to create a new one in Supabase
        const isLocalDesign = designId && String(designId).startsWith('local-');
        if (isLocalDesign) {
          designId = null;
        }

        if (!designId) {
          // Create new design
          const designToken = generateToken(16);
          const insertData = {
            share_token: designToken,
            ...designData
          };

          const response = await fetch(`${SUPABASE_URL}/rest/v1/room_designs`, {
            method: 'POST',
            headers,
            body: JSON.stringify(insertData)
          });

          if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`Save failed: ${response.status} - ${errorText}`);
          }

          const data = await response.json();
          designId = Array.isArray(data) ? data[0]?.id : data.id;
          SHARE_STATE.designId = designId;
          SHARE_STATE.designToken = designToken;

          // Check for customer shares to enable messaging
          await setupDesignerCommentNotifications(designId);

          showToast('Design saved to cloud!', 'success');
        } else {
          // Update existing design
          const updateData = {
            ...designData,
            updated_at: new Date().toISOString()
          };

          const response = await fetch(`${SUPABASE_URL}/rest/v1/room_designs?id=eq.${designId}`, {
            method: 'PATCH',
            headers,
            body: JSON.stringify(updateData)
          });

          if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`Update failed: ${response.status} - ${errorText}`);
          }

          // Check for customer shares to enable messaging (in case it wasn't set up yet)
          await setupDesignerCommentNotifications(designId);

          showToast('Design updated!', 'success');
        }

        // Also save locally as backup
        saveDesignLocally();

      } catch (err) {
        console.error('Error saving design:', err);
        // Fall back to local save
        saveDesignLocally();
        showToast('Saved locally. Cloud sync failed: ' + err.message, 'warning');
      } finally {
        // Reset button state
        if (saveBtn) saveBtn.disabled = false;
        if (saveText) saveText.textContent = 'Save';
      }
    }

    function switchDesignsTab(tab, btn) {
      currentDesignsTab = tab;
      document.querySelectorAll('.designs-tab').forEach(t => t.classList.remove('active'));
      btn.classList.add('active');
      renderDesignsGrid();
    }

    async function loadMyDesigns() {
      const grid = document.getElementById('designsGrid');
      const empty = document.getElementById('designsEmpty');
      if (!grid) {
        console.warn('designsGrid not found');
        return;
      }
      grid.innerHTML = '<div class="designs-loading">Loading designs...</div>';
      if (empty) empty.style.display = 'none';

      try {
        const supabase = getSupabaseClient();
        let user = getCurrentUser();

        console.log('loadMyDesigns: supabase=', !!supabase, 'user=', user?.id);

        // If no user but supabase exists, wait a moment for auth to restore
        if (!user && supabase) {
          try {
            const { data: { session }, error: sessionErr } = await supabase.auth.getSession();
            if (sessionErr) {
              console.warn('Session error:', sessionErr);
            } else if (session?.user) {
              user = session.user;
              console.log('Got user from session:', user.id);
            }
          } catch (authErr) {
            console.warn('Auth check in loadMyDesigns failed:', authErr);
          }
        }

        if (!supabase || !user) {
          // Load from localStorage
          const localDesigns = JSON.parse(localStorage.getItem('room_designs') || '[]');
          allDesigns.my = localDesigns.map((d, i) => ({
            id: d.id || `local-${i}`,  // Preserve original design ID
            name: d.name || 'Untitled Design',
            room_type: d.room_type || 'kitchen',
            room_width: d.room_width || 12,
            room_depth: d.room_depth || 10,
            created_at: d.created_at || new Date().toISOString(),
            updated_at: d.updated_at || d.created_at,
            elements_count: d.elements?.length || 0,
            comments_count: 0,
            preview: d.preview || null,
            isLocal: true,
            originalIndex: i  // Keep index for fallback lookup
          }));
          allDesigns.shared = [];
          allDesigns.recent = JSON.parse(localStorage.getItem('recent_designs') || '[]');
          renderDesignsGrid();
          return;
        }

        // Load user's own designs
        const { data: myDesigns, error: myError } = await supabase
          .from('room_designs')
          .select('*')
          .eq('user_id', user.id)
          .order('updated_at', { ascending: false });

        if (myError) throw myError;

        // Load designs shared with user (try multiple possible column names)
        let sharedDesigns = [];
        try {
          // Try to get shares where user is the recipient
          const { data, error } = await supabase
            .from('room_design_shares')
            .select('*, room_designs(*)')
            .order('created_at', { ascending: false })
            .limit(50);

          if (!error && data) {
            // Filter to only show designs not owned by current user
            sharedDesigns = data.filter(s => s.room_designs?.user_id !== user.id);
          }
        } catch (shareErr) {
          console.warn('Could not load shared designs:', shareErr);
        }

        // Process designs with all available data
        allDesigns.my = (myDesigns || []).map(d => ({
          id: d.id,
          name: d.name || d.design_data?.name || 'Untitled Design',
          room_type: d.room_type || d.design_data?.room_type || 'kitchen',
          room_width: d.room_width || d.design_data?.room_width || 12,
          room_depth: d.room_depth || d.design_data?.room_depth || 10,
          created_at: d.created_at,
          updated_at: d.updated_at,
          elements_count: d.design_data?.elements?.length || d.elements?.length || 0,
          comments_count: d.comments_count || 0,
          preview: d.thumbnail_url || d.preview_url,
          share_token: d.share_token,
          isLocal: false,
          design_data: d.design_data // Keep for loading
        }));

        allDesigns.shared = (sharedDesigns || []).filter(s => s.room_designs).map(s => ({
          id: s.design_id,
          name: s.room_designs?.name || 'Shared Design',
          room_type: s.room_designs?.room_type || 'kitchen',
          room_width: s.room_designs?.room_width || 12,
          room_depth: s.room_designs?.room_depth || 10,
          created_at: s.share_date || s.created_at,
          shared_by: s.shared_by_name || 'Someone',
          permission: s.permission_level,
          share_token: s.share_token,
          elements_count: s.room_designs?.design_data?.elements?.length || 0,
          comments_count: s.comments_count || 0,
          isLocal: false
        }));

        // Load recent from localStorage
        allDesigns.recent = JSON.parse(localStorage.getItem('recent_designs') || '[]');

        renderDesignsGrid();

      } catch (err) {
        console.error('Error loading designs:', err);
        // Show local designs as fallback
        const localDesigns = JSON.parse(localStorage.getItem('room_designs') || '[]');
        if (localDesigns.length > 0) {
          allDesigns.my = localDesigns.map((d, i) => ({
            id: d.id || `local-${i}`,
            name: d.name || 'Untitled Design',
            room_type: d.room_type || 'kitchen',
            room_width: d.room_width || 12,
            room_depth: d.room_depth || 10,
            created_at: d.created_at || new Date().toISOString(),
            updated_at: d.updated_at || d.created_at,
            elements_count: d.elements?.length || 0,
            comments_count: 0,
            preview: d.preview || null,
            isLocal: true,
            originalIndex: i
          }));
          renderDesignsGrid();
          showToast('Showing local designs. Cloud sync failed.', 'warning');
        } else {
          grid.innerHTML = '<div class="designs-loading">Error loading designs. Try refreshing.</div>';
        }
      }
    }

    // Debug: manually trigger My Designs - call from console: testMyDesigns()
    window.testMyDesigns = function() {
      console.log('Testing My Designs modal...');
      openMyDesignsModal();
    };

    // Debug: test save functionality - call from console: testSave()
    window.testSave = async function() {
      console.log('=== TESTING SAVE ===');
      const user = window.SgAuth?.getUser();
      console.log('User:', user);

      if (!user) {
        console.log('Not logged in - will save locally');
      }

      await saveDesignToCloud();
      console.log('Save complete. SHARE_STATE:', SHARE_STATE);
    };

    // Debug: manually add a test message - call from console: addTestMessage()
    window.addTestMessage = async function(message = 'Test message from console') {
      console.log('=== ADDING TEST MESSAGE ===');

      if (!SHARE_STATE.leadId) {
        console.log('No leadId. Looking for one...');
        // Try to find a lead from any share
        if (SHARE_STATE.designId) {
          const supabase = getSupabaseClient();
          if (supabase) {
            const { data: shares } = await supabase
              .from('room_design_shares')
              .select('lead_id')
              .eq('design_id', SHARE_STATE.designId)
              .not('lead_id', 'is', null)
              .limit(1);
            if (shares && shares[0]) {
              SHARE_STATE.leadId = shares[0].lead_id;
              console.log('Found leadId:', SHARE_STATE.leadId);
            }
          }
        }
      }

      if (!SHARE_STATE.leadId) {
        console.log('Still no leadId. Cannot add message.');
        console.log('You need to share this design with a customer first.');
        return;
      }

      const supabase = getSupabaseClient();
      if (!supabase) {
        console.log('No Supabase client');
        return;
      }

      const { data, error } = await supabase
        .from('customer_messages')
        .insert({
          customer_id: SHARE_STATE.leadId,
          message: message,
          direction: 'inbound',
          channel: 'design_share',
          metadata: {
            share_id: SHARE_STATE.shareId,
            design_id: SHARE_STATE.designId,
            author: 'Test Customer'
          }
        })
        .select()
        .single();

      if (error) {
        console.error('Error adding message:', error);
      } else {
        console.log('Message added:', data);
        // Reload messages
        await loadDesignerMessages(SHARE_STATE.leadId);
      }
    };

    // Debug: check all tables - call from console: debugTables()
    window.debugTables = async function() {
      console.log('=== DEBUG TABLES ===');
      const supabase = getSupabaseClient();
      if (!supabase) {
        console.log('No Supabase client');
        return;
      }

      const user = window.SgAuth?.getUser();
      console.log('Current user:', user?.id);

      // Check room_designs
      const { data: designs, error: designErr } = await supabase
        .from('room_designs')
        .select('id, name, share_token, created_at')
        .eq('user_id', user?.id)
        .limit(5);
      console.log('Your designs:', designs);
      if (designErr) console.error('Design error:', designErr);

      // Check room_design_shares
      if (designs && designs[0]) {
        const { data: shares, error: shareErr } = await supabase
          .from('room_design_shares')
          .select('*')
          .eq('design_id', designs[0].id);
        console.log('Shares for first design:', shares);
        if (shareErr) console.error('Share error:', shareErr);
      }

      // Check customer_messages
      const { data: messages, error: msgErr } = await supabase
        .from('customer_messages')
        .select('*')
        .eq('channel', 'design_share')
        .limit(10);
      console.log('Recent design_share messages:', messages);
      if (msgErr) console.error('Message error:', msgErr);
    };

    function renderDesignsGrid() {
      const grid = document.getElementById('designsGrid');
      const empty = document.getElementById('designsEmpty');

      const designs = allDesigns[currentDesignsTab] || [];

      if (designs.length === 0) {
        grid.innerHTML = '';
        empty.style.display = 'block';
        return;
      }

      empty.style.display = 'none';

      const formatDate = (date) => {
        const d = new Date(date);
        const now = new Date();
        const diffDays = Math.floor((now - d) / 86400000);
        if (diffDays === 0) return 'Today';
        if (diffDays === 1) return 'Yesterday';
        if (diffDays < 7) return `${diffDays} days ago`;
        return d.toLocaleDateString();
      };

      // Room type icons
      const roomTypeIcons = {
        kitchen: '<path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"/><polyline points="9 22 9 12 15 12 15 22"/>',
        bathroom: '<path d="M4 12h16M4 12v8a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-8M4 12V6a2 2 0 0 1 2-2h2"/><circle cx="8" cy="5" r="1"/>',
        laundry: '<rect x="4" y="4" width="16" height="16" rx="2"/><circle cx="12" cy="12" r="4"/><circle cx="12" cy="12" r="1"/>',
        outdoor: '<circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/>',
        default: '<rect x="3" y="3" width="18" height="18" rx="2"/><path d="M3 9h18M9 21V9"/>'
      };

      grid.innerHTML = designs.map((design, idx) => {
        const roomType = design.room_type || 'kitchen';
        const roomIcon = roomTypeIcons[roomType] || roomTypeIcons.default;
        const elemCount = design.elements_count || design.design_data?.elements?.length || 0;
        const roomW = design.room_width || design.design_data?.room_width || 12;
        const roomD = design.room_depth || design.design_data?.room_depth || 10;
        const isCloud = !design.isLocal;

        return `
        <div class="design-card" onclick="loadDesignFromList('${design.id}', '${design.share_token || ''}', ${design.isLocal || false}, ${design.originalIndex !== undefined ? design.originalIndex : idx})">
          <div class="design-card-preview">
            ${design.preview
              ? `<img src="${design.preview}" alt="${design.name}">`
              : `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                  ${roomIcon}
                </svg>`
            }
            ${currentDesignsTab === 'shared'
              ? `<span class="design-card-badge">${design.permission || 'View'}</span>`
              : design.share_token
                ? '<span class="design-card-badge shared">Shared</span>'
                : design.isLocal
                  ? '<span class="design-card-badge local">Local</span>'
                  : '<span class="design-card-badge cloud">Cloud</span>'
            }
            <button class="design-card-delete" onclick="event.stopPropagation(); deleteDesign('${design.id}', ${design.isLocal || false}, ${design.originalIndex !== undefined ? design.originalIndex : idx})" title="Delete design">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M3 6h18M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6M8 6V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/>
                <line x1="10" y1="11" x2="10" y2="17"/><line x1="14" y1="11" x2="14" y2="17"/>
              </svg>
            </button>
          </div>
          <div class="design-card-info">
            <div class="design-card-name" title="${design.name || 'Untitled'}">${design.name || 'Untitled Design'}</div>
            <div class="design-card-details">
              <span class="design-card-room-type" title="${roomType}">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">${roomIcon}</svg>
                ${roomType.charAt(0).toUpperCase() + roomType.slice(1)}
              </span>
              <span class="design-card-dims">${roomW}'${roomD}'</span>
              ${elemCount > 0 ? `<span class="design-card-elements">${elemCount} items</span>` : ''}
            </div>
            <div class="design-card-meta">
              <span class="design-card-date">
                <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <circle cx="12" cy="12" r="10"/><path d="M12 6v6l4 2"/>
                </svg>
                ${formatDate(design.created_at || design.updated_at)}
              </span>
              ${design.comments_count > 0 ? `
                <span class="design-card-comments">
                  <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"/>
                  </svg>
                  ${design.comments_count}
                </span>
              ` : ''}
            </div>
          </div>
        </div>
      `}).join('');
    }

    // Delete a design from local storage or cloud
    async function deleteDesign(designId, isLocal, originalIndex) {
      const design = (allDesigns[currentDesignsTab] || []).find(d => d.id === designId);
      const designName = design?.name || 'this design';

      if (!confirm(`Are you sure you want to delete "${designName}"?\n\nThis action cannot be undone.`)) {
        return;
      }

      try {
        if (isLocal) {
          // Delete from localStorage (key is 'room_designs')
          const localDesigns = JSON.parse(localStorage.getItem('room_designs') || '[]');
          const updatedDesigns = localDesigns.filter((d, idx) => {
            // Match by index if originalIndex provided, otherwise by id
            if (originalIndex !== undefined) {
              return idx !== originalIndex;
            }
            return d.id !== designId;
          });
          localStorage.setItem('room_designs', JSON.stringify(updatedDesigns));
          showToast('Design deleted', 'success');
        } else {
          // Delete from Supabase
          const supabase = getSupabaseClient();
          if (!supabase) {
            showToast('Cannot connect to cloud', 'error');
            return;
          }

          const { error } = await supabase
            .from('room_designs')
            .delete()
            .eq('id', designId);

          if (error) {
            console.error('Delete error:', error);
            showToast('Failed to delete design: ' + error.message, 'error');
            return;
          }

          showToast('Design deleted from cloud', 'success');
        }

        // Refresh the designs list
        await loadMyDesigns();
      } catch (err) {
        console.error('Delete design error:', err);
        showToast('Failed to delete design', 'error');
      }
    }

    function filterDesigns(query) {
      const designs = allDesigns[currentDesignsTab] || [];
      const filtered = designs.filter(d =>
        d.name.toLowerCase().includes(query.toLowerCase())
      );

      const grid = document.getElementById('designsGrid');
      const empty = document.getElementById('designsEmpty');

      if (filtered.length === 0 && query) {
        grid.innerHTML = '';
        empty.style.display = 'block';
        return;
      }

      // Temporarily override for rendering
      const original = allDesigns[currentDesignsTab];
      allDesigns[currentDesignsTab] = filtered;
      renderDesignsGrid();
      allDesigns[currentDesignsTab] = original;
    }

    // ===== HISTORY STATE MANAGEMENT =====
    // Stores the previous design state when navigating between designs
    let previousDesignState = null;

    function saveCurrentDesignToHistory() {
      // Save current design state so we can restore it on back navigation
      previousDesignState = {
        elements: JSON.parse(JSON.stringify(elements)),
        walls: JSON.parse(JSON.stringify(walls)),
        roomWidth: roomWidth,
        roomDepth: roomDepth,
        projectName: document.getElementById('projectName').value,
        roomType: document.getElementById('roomType').value,
        designId: SHARE_STATE.designId
      };
      // Store in sessionStorage for persistence across page reloads
      sessionStorage.setItem('sg_previous_design', JSON.stringify(previousDesignState));
    }

    function restorePreviousDesign() {
      // Try to get from memory first, then sessionStorage
      let state = previousDesignState;
      if (!state) {
        const stored = sessionStorage.getItem('sg_previous_design');
        if (stored) {
          state = JSON.parse(stored);
        }
      }

      if (state) {
        elements = state.elements || [];
        walls = state.walls || [];
        roomWidth = state.roomWidth || 12;
        roomDepth = state.roomDepth || 14;
        document.getElementById('projectName').value = state.projectName || 'New Design';
        document.getElementById('roomType').value = state.roomType || 'kitchen';
        document.getElementById('roomWidth').value = roomWidth;
        document.getElementById('roomDepth').value = roomDepth;
        SHARE_STATE.designId = state.designId;

        // Reload textures
        elements.forEach(el => {
          if (el.texture) {
            const img = new Image();
            img.crossOrigin = 'anonymous';
            img.onload = () => {
              el.textureImg = img;
              draw();
            };
            img.src = el.texture;
          }
        });

        calculateQuote();
        draw();
        update3DScene();
        showSnapFeedback('Returned to previous design');
        return true;
      }
      return false;
    }

    // Handle browser back/forward navigation
    window.addEventListener('popstate', function(event) {
      console.log('Popstate event:', event.state);

      // Check if we have a previous design to restore
      if (event.state === null || !event.state.shareToken) {
        // Going back to the main page (no share token)
        if (restorePreviousDesign()) {
          // Clear the URL if it has a share token
          if (window.location.search.includes('share=')) {
            history.replaceState({}, '', window.location.pathname);
          }
        }
      } else if (event.state.shareToken) {
        // Navigating to a shared design
        loadSharedDesign(event.state.shareToken);
      } else if (event.state.designId && event.state.isLocal) {
        // Navigating to a local design
        const localDesigns = JSON.parse(localStorage.getItem('room_designs') || '[]');
        const design = localDesigns.find(d => d.id === event.state.designId);
        if (design) {
          loadLocalDesign(design);
        }
      }
    });

    async function loadDesignFromList(id, shareToken, isLocal, originalIndex) {
      console.log('loadDesignFromList called:', { id, shareToken, isLocal, originalIndex });
      closeModal('myDesignsModal');

      // Show loading indicator
      showToast('Loading design...', 'info');

      if (isLocal) {
        try {
          const localDesigns = JSON.parse(localStorage.getItem('room_designs') || '[]');
          console.log('Local designs found:', localDesigns.length);

          // Find design by ID first, then by index as fallback
          let design = localDesigns.find(d => d.id === id);
          if (!design && originalIndex !== undefined && localDesigns[originalIndex]) {
            design = localDesigns[originalIndex];
            console.log('Found design by index:', originalIndex);
          }

          if (design) {
            console.log('Loading local design:', design.name, 'with', design.elements?.length, 'elements');
            // Save current state to history before loading new design
            saveCurrentDesignToHistory();
            loadLocalDesign(design);
            // Update URL without reload
            history.pushState({ designId: id, isLocal: true }, '', window.location.pathname);
            showToast(`Loaded: ${design.name || 'Untitled Design'}`, 'success');
          } else {
            console.error('Design not found in localStorage. ID:', id, 'Index:', originalIndex);
            showToast('Design not found in local storage', 'error');
          }
        } catch (err) {
          console.error('Error loading local design:', err);
          showToast('Error loading local design: ' + err.message, 'error');
        }
        return;
      }

      // Designer loading their own design from cloud
      try {
        const supabase = getSupabaseClient();
        if (!supabase) {
          showToast('Cannot connect to cloud. Try again later.', 'error');
          return;
        }

        console.log('Fetching design from cloud:', id);
        const { data, error } = await supabase
          .from('room_designs')
          .select('*')
          .eq('id', id)
          .single();

        if (error) {
          console.error('Supabase error:', error);
          throw error;
        }

        console.log('Cloud design data:', data);
        console.log('Record fields:', Object.keys(data || {}));

        // Check if we have design data - it might be in design_data field OR directly on the record
        // Note: elements might be an empty array, so check for existence not truthiness
        const hasDesignData = data?.design_data ||
                              data?.elements !== undefined ||
                              data?.room_width !== undefined;

        if (data && hasDesignData) {
          // Designer loading their own design - NOT a shared view
          SHARE_STATE.isSharedView = false;
          SHARE_STATE.designId = id;
          SHARE_STATE.designToken = data.share_token;

          // Save current state before loading
          saveCurrentDesignToHistory();

          // Determine where the design data is stored
          if (data.design_data) {
            // Design data is in nested object
            loadDesignData(data.design_data);
          } else {
            // Design data is directly on the record (elements, settings, etc.)
            // Build the design object that loadDesignData expects
            const designObj = {
              id: data.id,
              name: data.name || 'Untitled',
              room_type: data.room_type || 'kitchen',
              room_width: data.room_width || 12,
              room_depth: data.room_depth || 10,
              elements: data.elements || [],
              walls: data.settings?.walls || data.walls || [],
              rooms: data.rooms || [],
              settings: data.settings || { pixelsPerFoot: 40 },
              share_token: data.share_token
            };
            console.log('Built design object from record:', {
              name: designObj.name,
              room_width: designObj.room_width,
              room_depth: designObj.room_depth,
              elements_count: designObj.elements.length,
              walls_count: designObj.walls.length,
              rooms_count: designObj.rooms.length
            });
            loadDesignData(designObj);
          }

          // Update project name from design record
          if (data.name) {
            document.getElementById('projectName').value = data.name;
          }

          // Set up realtime sync for this design
          subscribeToDesignUpdates(id);

          // Check for any shares with leads and subscribe to comment notifications
          setupDesignerCommentNotifications(id);

          showToast(`Loaded: ${data.name || 'Design'}`, 'success');
        } else {
          console.error('No design data found in record:', data);
          console.log('Record keys:', Object.keys(data || {}));
          showToast('Design data is empty or corrupted', 'error');
        }
      } catch (err) {
        console.error('Error loading cloud design:', err);
        showToast('Error loading design: ' + (err.message || 'Unknown error'), 'error');
      }
    }

    // Set up comment notifications for designers when they load their own design
    async function setupDesignerCommentNotifications(designId) {
      if (!designId) return;

      try {
        const supabase = getSupabaseClient();
        if (!supabase) return;

        // Find any shares for this design that have an associated lead
        let shares, error;
        try {
          const result = await supabase
            .from('room_design_shares')
            .select('id, lead_id, customer_name')
            .eq('design_id', designId)
            .not('lead_id', 'is', null)
            .limit(1);
          shares = result.data;
          error = result.error;
        } catch (queryErr) {
          // Table may not exist yet  non-critical feature
          console.log('room_design_shares query failed (table may not exist):', queryErr.message);
          return;
        }

        if (error || !shares || shares.length === 0) {
          console.log('No customer shares found for this design');
          return;
        }

        const share = shares[0];
        SHARE_STATE.leadId = share.lead_id;
        SHARE_STATE.customerName = share.customer_name || null;
        SHARE_STATE.shareId = share.id;

        // Fetch customer name if not set
        if (!SHARE_STATE.customerName) {
          await fetchCustomerName(share.lead_id);
        }

        // Subscribe to realtime comment notifications
        subscribeToCustomerComments(share.lead_id);

        // Show the messages panel and load messages
        showDesignerMessagesPanel();
        await loadDesignerMessages(share.lead_id);

        console.log('Designer comment notifications set up for lead:', share.lead_id);
      } catch (err) {
        console.warn('Could not set up comment notifications:', err);
      }
    }

    // Toggle any panel section collapse/expand
    function togglePanelSection(sectionId) {
      const section = document.getElementById(sectionId);
      if (section) {
        section.classList.toggle('collapsed');
      }
    }

    // Toggle messages panel collapse/expand
    function toggleMessagesPanel() {
      const content = document.getElementById('messagesContent');
      if (content) {
        if (content.style.display === 'none') {
          content.style.display = 'block';
        } else {
          content.style.display = 'none';
        }
      }
    }

    // Show the designer messages panel with customer linked
    function showDesignerMessagesPanel() {
      const content = document.getElementById('messagesContent');
      const inputArea = document.getElementById('messageInputArea');
      const noCustomerMsg = document.getElementById('noCustomerMessage');
      const section = document.getElementById('messagesSection');

      // Make sure panel is expanded when customer is linked
      if (content) {
        content.style.display = 'block';
      }
      if (section) {
        section.style.display = 'block';
      }

      // Show the reply input and hide the "no customer" message
      if (inputArea) {
        inputArea.style.display = 'flex';
      }
      if (noCustomerMsg) {
        noCustomerMsg.style.display = 'none';
      }

      // Update panel header to show customer name if available
      const panelTitle = document.querySelector('#messagesSection .panel-title span:first-child');
      if (panelTitle && SHARE_STATE.customerName) {
        panelTitle.textContent = ` ${SHARE_STATE.customerName}`;
      }
    }

    // Load messages for designer view
    async function loadDesignerMessages(leadId) {
      console.log('loadDesignerMessages called with leadId:', leadId);
      if (!leadId) {
        console.log('No leadId provided');
        return;
      }

      const container = document.getElementById('customerMessagesList');
      if (!container) {
        console.log('customerMessagesList container not found');
        return;
      }

      try {
        const supabase = getSupabaseClient();
        if (!supabase) {
          console.log('No Supabase client');
          return;
        }

        console.log('Querying customer_messages for customer_id:', leadId);
        const { data: messages, error } = await supabase
          .from('customer_messages')
          .select('*')
          .eq('customer_id', leadId)
          .eq('channel', 'design_share')
          .order('created_at', { ascending: true });

        console.log('Messages query result:', { messages, error });

        if (error) {
          console.warn('Error loading messages:', error);
          return;
        }

        if (!messages || messages.length === 0) {
          container.innerHTML = '<div class="no-messages">No messages yet.<br><span style="font-size: 10px; color: var(--text-muted);">Customer comments will appear here</span></div>';
          updateMessageBadge(0);
          return;
        }

        // Hide the "no customer" message since we have messages
        const noCustomerMsg = document.getElementById('noCustomerMessage');
        if (noCustomerMsg) noCustomerMsg.style.display = 'none';

        // Render messages
        container.innerHTML = messages.map(msg => `
          <div class="customer-message ${msg.direction}">
            <div class="customer-message-header">
              <span class="customer-message-author">${msg.direction === 'inbound' ? (SHARE_STATE.customerName || 'Customer') : 'You'}</span>
              <span class="customer-message-time">${formatMessageTime(msg.created_at)}</span>
            </div>
            <div class="customer-message-text">${escapeHtml(msg.message)}</div>
          </div>
        `).join('');

        // Scroll to bottom
        container.scrollTop = container.scrollHeight;

        // Update badge with unread count (inbound messages)
        const unreadCount = messages.filter(m => m.direction === 'inbound' && !m.read_at).length;
        updateMessageBadge(unreadCount);

      } catch (err) {
        console.warn('Error loading designer messages:', err);
      }
    }

    function formatMessageTime(timestamp) {
      const date = new Date(timestamp);
      const now = new Date();
      const diffMs = now - date;
      const diffMins = Math.floor(diffMs / 60000);
      const diffHours = Math.floor(diffMs / 3600000);
      const diffDays = Math.floor(diffMs / 86400000);

      if (diffMins < 1) return 'Just now';
      if (diffMins < 60) return `${diffMins}m ago`;
      if (diffHours < 24) return `${diffHours}h ago`;
      if (diffDays < 7) return `${diffDays}d ago`;
      return date.toLocaleDateString();
    }

    // Note: escapeHtml is defined earlier (around line 49675)

    // Debug function - call from console: debugMessages()
    window.debugMessages = async function() {
      console.log('=== MESSAGE DEBUG ===');
      console.log('SHARE_STATE:', SHARE_STATE);
      console.log('leadId:', SHARE_STATE.leadId);
      console.log('designId:', SHARE_STATE.designId);

      const supabase = getSupabaseClient();
      if (!supabase) {
        console.log('No Supabase client');
        return;
      }

      // Check shares for this design
      if (SHARE_STATE.designId) {
        console.log('--- Checking shares for design ---');
        const { data: shares, error: shareErr } = await supabase
          .from('room_design_shares')
          .select('*')
          .eq('design_id', SHARE_STATE.designId);
        console.log('Shares for this design:', shares);
        console.log('Share error:', shareErr);

        // If we found a share with lead_id, use it
        if (shares && shares.length > 0) {
          const shareWithLead = shares.find(s => s.lead_id);
          if (shareWithLead) {
            console.log('Found share with lead_id:', shareWithLead.lead_id);
            SHARE_STATE.leadId = shareWithLead.lead_id;
            SHARE_STATE.shareId = shareWithLead.id;
          }
        }
      }

      if (SHARE_STATE.leadId) {
        console.log('--- Checking messages for lead ---');
        const { data, error } = await supabase
          .from('customer_messages')
          .select('*')
          .eq('customer_id', SHARE_STATE.leadId);
        console.log('All messages for this customer:', data);
        console.log('Error:', error);

        // Try loading with the function
        await loadDesignerMessages(SHARE_STATE.leadId);
      } else {
        console.log('No leadId found in any shares for this design.');
        console.log('To link a customer: share the design with a customer from the Connections page.');
      }
    };

    // Force refresh messages - call from console: refreshMessages()
    window.refreshMessages = function() {
      if (SHARE_STATE.leadId) {
        loadDesignerMessages(SHARE_STATE.leadId);
      } else {
        console.log('No leadId - load a shared design first');
      }
    };

    function updateMessageBadge(count) {
      const badge = document.getElementById('messageBadge');
      if (badge) {
        badge.textContent = count;
        if (count > 0) {
          badge.classList.add('has-messages');
        } else {
          badge.classList.remove('has-messages');
        }
      }
    }

    // Send designer reply
    async function sendDesignerReply() {
      // Only designers (non-shared view) can send replies
      if (SHARE_STATE.isSharedView) {
        showToast('Only designers can send replies', 'error');
        return;
      }

      // Verify user is authenticated
      const user = window.SgAuth?.getUser();
      if (!user) {
        showToast('Please log in to send messages', 'error');
        return;
      }

      const input = document.getElementById('designerReplyInput');
      const message = input?.value?.trim();
      if (!message || !SHARE_STATE.leadId) return;

      try {
        const supabase = getSupabaseClient();
        if (!supabase) {
          showToast('Unable to send message', 'error');
          return;
        }

        const { error } = await supabase
          .from('customer_messages')
          .insert({
            customer_id: SHARE_STATE.leadId,
            message: message,
            direction: 'outbound',
            channel: 'design_share',
            metadata: {
              share_id: SHARE_STATE.shareId,
              design_id: SHARE_STATE.designId,
              author: 'Designer'
            }
          });

        if (error) {
          console.error('Error sending reply:', error);
          showToast('Failed to send message', 'error');
          return;
        }

        // Clear input and reload messages
        input.value = '';
        showToast('Message sent', 'success');
        await loadDesignerMessages(SHARE_STATE.leadId);

      } catch (err) {
        console.error('Error sending designer reply:', err);
        showToast('Failed to send message', 'error');
      }
    }

    // Load a locally saved design
    function loadLocalDesign(design) {
      console.log('loadLocalDesign called with:', design.name, design.elements?.length, 'elements');

      // Restore room dimensions
      roomWidth = design.room_width || 12;
      roomDepth = design.room_depth || 10;

      // Clear and restore elements
      elements.length = 0;
      if (design.elements && design.elements.length > 0) {
        design.elements.forEach(el => {
          elements.push({
            ...el,
            textureImg: null
          });
        });

        // Reload textures
        elements.forEach(el => {
          if (el.texture) {
            const img = new Image();
            img.crossOrigin = 'anonymous';
            img.onload = () => {
              el.textureImg = img;
              draw();
              if (currentView === '3d') update3DScene();
            };
            img.onerror = () => console.warn('Failed to load texture:', el.texture);
            img.src = el.texture;
          }
        });
      }

      // Clear and restore walls
      walls.length = 0;
      if (design.walls && design.walls.length > 0) {
        design.walls.forEach(w => walls.push(w));
      }

      // Restore multi-room data if present
      if (design.rooms && design.rooms.length > 0) {
        rooms.length = 0;
        design.rooms.forEach(room => {
          rooms.push({
            ...room,
            elements: room.elements || [],
            walls: room.walls || []
          });
        });
        currentRoomId = design.currentRoomId || rooms[0]?.id;
        updateRoomList();
      } else {
        // Single room - sync with room system
        initializeRooms();
        const currentRoomObj = getCurrentRoom();
        if (currentRoomObj) {
          currentRoomObj.elements = [...elements];
          currentRoomObj.walls = [...walls];
          currentRoomObj.width = roomWidth;
          currentRoomObj.depth = roomDepth;
        }
      }

      // Update project name
      const projectNameEl = document.getElementById('projectName');
      if (projectNameEl) {
        projectNameEl.value = design.name || 'Untitled Design';
      }

      // Update room type
      const roomTypeEl = document.getElementById('roomType');
      if (roomTypeEl && design.room_type) {
        roomTypeEl.value = design.room_type;
      }

      // Update UI dimensions
      const roomWidthEl = document.getElementById('roomWidth');
      const roomDepthEl = document.getElementById('roomDepth');
      if (roomWidthEl) roomWidthEl.value = roomWidth;
      if (roomDepthEl) roomDepthEl.value = roomDepth;

      // Set local design ID
      SHARE_STATE.designId = design.id;
      SHARE_STATE.isSharedView = false;

      // Fit to screen and normalize positions
      fitToScreen();
      const savedScale = design.settings?.pixelsPerFoot || 40;
      if (savedScale !== pixelsPerFoot && savedScale > 0) {
        const scaleRatio = pixelsPerFoot / savedScale;
        console.log('Normalizing local design positions with ratio:', scaleRatio);
        elements.forEach(el => {
          el.x = (el.x || 0) * scaleRatio;
          el.y = (el.y || 0) * scaleRatio;
        });
        walls.forEach(wall => {
          if (wall.x1 !== undefined) wall.x1 *= scaleRatio;
          if (wall.y1 !== undefined) wall.y1 *= scaleRatio;
          if (wall.x2 !== undefined) wall.x2 *= scaleRatio;
          if (wall.y2 !== undefined) wall.y2 *= scaleRatio;
        });
      }

      // Redraw everything
      draw();
      if (currentView === '3d') {
        update3DScene();
      }
      calculateQuote();
      updateProperties();
      updateElementSelector();

      console.log('Local design loaded successfully with', elements.length, 'elements');
    }

    // Add recent design tracking
    function trackRecentDesign(design) {
      let recent = JSON.parse(localStorage.getItem('recent_designs') || '[]');
      // Remove if already exists
      recent = recent.filter(r => r.id !== design.id);
      // Add to front
      recent.unshift({
        id: design.id,
        name: design.name,
        share_token: design.share_token,
        created_at: new Date().toISOString()
      });
      // Keep only last 10
      recent = recent.slice(0, 10);
      localStorage.setItem('recent_designs', JSON.stringify(recent));
    }

    // ===== NOTIFICATIONS =====
    function requestNotificationPermission() {
      if ('Notification' in window && Notification.permission === 'default') {
        Notification.requestPermission();
      }
    }

    function showNotification(title, body) {
      // In-app toast
      const toast = document.getElementById('notificationToast');
      document.getElementById('notificationTitle').textContent = title;
      document.getElementById('notificationBody').textContent = body;
      toast.classList.add('show');

      setTimeout(() => {
        toast.classList.remove('show');
      }, 5000);

      // Browser notification
      if ('Notification' in window && Notification.permission === 'granted') {
        new Notification(title, {
          body: body,
          icon: '/images/logo.png',
          badge: '/images/logo.png'
        });
      }
    }

    function hideNotification() {
      document.getElementById('notificationToast').classList.remove('show');
    }

    function playNotificationSound() {
      // Create a simple notification beep
      try {
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const oscillator = audioCtx.createOscillator();
        const gainNode = audioCtx.createGain();

        oscillator.connect(gainNode);
        gainNode.connect(audioCtx.destination);

        oscillator.frequency.value = 800;
        oscillator.type = 'sine';
        gainNode.gain.value = 0.1;

        oscillator.start();
        setTimeout(() => oscillator.stop(), 100);
      } catch (e) {
        // Audio not available
      }
    }

    // Helper function for consistent color from string
    function stringToColor(str) {
      let hash = 0;
      for (let i = 0; i < str.length; i++) {
        hash = str.charCodeAt(i) + ((hash << 5) - hash);
      }
      const hue = hash % 360;
      return `hsl(${hue}, 65%, 45%)`;
    }

    // Note: escapeHtml is defined earlier (around line 49675)

    // ===== LOADING OVERLAY =====
    function showLoading(message = 'Loading...') {
      let overlay = document.getElementById('loadingOverlay');
      if (!overlay) {
        overlay = document.createElement('div');
        overlay.id = 'loadingOverlay';
        overlay.className = 'loading-overlay';
        overlay.innerHTML = `
          <div style="text-align: center;">
            <div class="loading-spinner"></div>
            <div class="loading-text" id="loadingText">${message}</div>
          </div>
        `;
        document.body.appendChild(overlay);
      } else {
        document.getElementById('loadingText').textContent = message;
      }
      // Use setTimeout to ensure CSS transition works
      setTimeout(() => overlay.classList.add('active'), 10);
    }

    function hideLoading() {
      const overlay = document.getElementById('loadingOverlay');
      if (overlay) {
        overlay.classList.remove('active');
      }
    }

    // ===== AUTO-SAVE INDICATOR =====
    let autoSaveIndicatorTimeout = null;

    function showAutoSaveIndicator() {
      // Create indicator if it doesn't exist
      let indicator = document.getElementById('autosaveIndicator');
      if (!indicator) {
        indicator = document.createElement('div');
        indicator.id = 'autosaveIndicator';
        indicator.className = 'autosave-indicator';
        indicator.innerHTML = `
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5">
            <polyline points="20 6 9 17 4 12"/>
          </svg>
          <span>Saved</span>
        `;
        document.body.appendChild(indicator);
      }

      // Clear any existing timeout
      if (autoSaveIndicatorTimeout) {
        clearTimeout(autoSaveIndicatorTimeout);
      }

      // Show indicator
      requestAnimationFrame(() => {
        indicator.classList.add('show');
      });

      // Hide after 1.5 seconds
      autoSaveIndicatorTimeout = setTimeout(() => {
        indicator.classList.remove('show');
      }, 1500);
    }

    // ===== MOBILE TOOLBAR INITIALIZATION =====
    function initMobileToolbar() {
      // Only create if not already exists and on mobile
      if (document.getElementById('mobileToolbar') || window.innerWidth > 900) return;

      const toolbar = document.createElement('div');
      toolbar.id = 'mobileToolbar';
      toolbar.className = 'mobile-toolbar';
      toolbar.innerHTML = `
        <button class="tool-btn" onclick="setTool('select')" title="Select">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M3 3l7.07 16.97 2.51-7.39 7.39-2.51L3 3z"/>
          </svg>
        </button>
        <button class="tool-btn" onclick="setTool('pan')" title="Pan">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M5 9l-3 3 3 3M9 5l3-3 3 3M15 19l-3 3-3-3M19 9l3 3-3 3"/>
          </svg>
        </button>
        <button class="tool-btn" onclick="toggleMobileMenu()" title="Menu">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <line x1="3" y1="12" x2="21" y2="12"/>
            <line x1="3" y1="6" x2="21" y2="6"/>
            <line x1="3" y1="18" x2="21" y2="18"/>
          </svg>
        </button>
        <button class="tool-btn" onclick="undo()" title="Undo">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M3 7v6h6"/>
            <path d="M21 17a9 9 0 0 0-9-9 9 9 0 0 0-6 2.3L3 13"/>
          </svg>
        </button>
        <button class="tool-btn" onclick="openModal('shareModal')" title="Share">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <circle cx="18" cy="5" r="3"/>
            <circle cx="6" cy="12" r="3"/>
            <circle cx="18" cy="19" r="3"/>
            <line x1="8.59" y1="13.51" x2="15.42" y2="17.49"/>
            <line x1="15.41" y1="6.51" x2="8.59" y2="10.49"/>
          </svg>
        </button>
      `;
      document.body.appendChild(toolbar);
    }

    function toggleMobileMenu() {
      // Show a simple menu for mobile users
      const menu = document.getElementById('mobileMenuOverlay');
      if (menu) {
        menu.classList.toggle('active');
      } else {
        const menuOverlay = document.createElement('div');
        menuOverlay.id = 'mobileMenuOverlay';
        menuOverlay.className = 'modal-overlay active';
        menuOverlay.innerHTML = `
          <div class="modal" style="max-width: 300px;">
            <div class="modal-header">
              <h3 class="modal-title">Menu</h3>
              <button class="modal-close" onclick="document.getElementById('mobileMenuOverlay').classList.remove('active')"></button>
            </div>
            <div style="display: flex; flex-direction: column; gap: 8px; padding: 16px;">
              <button class="btn btn-secondary" onclick="openModal('templateModal'); document.getElementById('mobileMenuOverlay').classList.remove('active');">Load Template</button>
              <button class="btn btn-secondary" onclick="openModal('myDesignsModal'); document.getElementById('mobileMenuOverlay').classList.remove('active');">My Designs</button>
              <button class="btn btn-secondary" onclick="setView(currentView === '2d' ? '3d' : '2d'); document.getElementById('mobileMenuOverlay').classList.remove('active');">Toggle 2D/3D</button>
              <button class="btn btn-secondary" onclick="exportDesign(); document.getElementById('mobileMenuOverlay').classList.remove('active');">Save Design</button>
              <button class="btn btn-secondary" onclick="resetZoom(); document.getElementById('mobileMenuOverlay').classList.remove('active');">Reset Zoom</button>
            </div>
          </div>
        `;
        document.body.appendChild(menuOverlay);
        menuOverlay.addEventListener('click', (e) => {
          if (e.target === menuOverlay) menuOverlay.classList.remove('active');
        });
      }
    }

    // Initialize mobile toolbar on load
    if (window.innerWidth <= 900) {
      document.addEventListener('DOMContentLoaded', initMobileToolbar);
    }
    window.addEventListener('resize', () => {
      if (window.innerWidth <= 900) {
        initMobileToolbar();
      } else {
        const toolbar = document.getElementById('mobileToolbar');
        if (toolbar) toolbar.remove();
      }
    });

  </script>

  <!-- Slab Layout Module -->
  <script src="slab-layout.js"></script>
  <script>
    // Initialize Slab Layout when DOM is ready
    document.addEventListener('DOMContentLoaded', function() {
      if (window.SlabLayout) {
        window.SlabLayout.init();
        console.log('SlabLayout: Module initialized');
      }
    });

    // Add keyboard shortcut for Slab Layout (S key)
    document.addEventListener('keydown', function(e) {
      if (e.key === 's' && !e.ctrlKey && !e.metaKey && !e.altKey) {
        const target = e.target;
        const isInput = target.tagName === 'INPUT' || target.tagName === 'TEXTAREA' || target.isContentEditable;
        if (!isInput && window.SlabLayout) {
          e.preventDefault();
          window.SlabLayout.toggle();
        }
      }
    });
  </script>
<script defer src="/js/remodely-hub.js?v=20260118"></script>
</body>
</html>
