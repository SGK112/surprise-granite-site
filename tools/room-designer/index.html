<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Room Designer Pro | Powered by Remodely.ai | Surprise Granite</title>
  <link rel="icon" href="https://cdn.prod.website-files.com/6456ce4476abb25581fbad0c/6456ce4476abb269c6fbb176_Surprise-Granite-favicon-32x32px.png">
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">

  <!-- Three.js for 3D -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>

  <!-- Supabase -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

  <!-- Auth System - Initialize Supabase BEFORE sg-auth.js loads -->
  <script>
    // Initialize global Supabase client immediately (synchronous)
    window._sgSupabaseClient = null;
    window._sgSupabaseError = null;

    // Create client immediately if supabase is available
    (function initSupabase() {
      try {
        if (window.supabase && window.supabase.createClient) {
          window._sgSupabaseClient = window.supabase.createClient(
            'https://ypeypgwsycxcagncgdur.supabase.co',
            'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InlwZXlwZ3dzeWN4Y2FnbmNnZHVyIiwicm9sZSI6ImFub24iLCJpYXQiOjE3Njc3NTQ4MjMsImV4cCI6MjA4MzMzMDgyM30.R13pNv2FDtGhfeu7gUcttYNrQAbNYitqR4FIq3O2-ME',
            {
              auth: {
                persistSession: true,
                autoRefreshToken: true,
                detectSessionInUrl: true
              },
              global: {
                headers: { 'x-client-info': 'room-designer' }
              }
            }
          );
          console.log('SG Supabase: Client initialized');
        } else {
          console.warn('SG Supabase: SDK not loaded yet');
        }
      } catch (err) {
        window._sgSupabaseError = err;
        console.error('SG Supabase: Init error', err);
      }
    })();
  </script>
  <script src="/js/sg-auth.js"></script>

  <!-- PDF Export -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

  <!-- SheetJS for Excel/CSV parsing -->
  <script src="https://cdn.sheetjs.com/xlsx-0.20.1/package/dist/xlsx.full.min.js"></script>

  <!-- Stripe.js for Payment Processing -->
  <script src="https://js.stripe.com/v3/"></script>

  <style>
    :root {
      --primary: #6366f1;
      --primary-dark: #4f46e5;
      --gold: #f9cb00;
      --gold-dark: #d4ab00;
      --dark: #0f0f1a;
      --dark-surface: #1a1a2e;
      --dark-elevated: #252540;
      --dark-hover: #2d2d4a;
      --text: #ffffff;
      --text-secondary: rgba(255,255,255,0.7);
      --text-muted: rgba(255,255,255,0.5);
      --border: rgba(255,255,255,0.1);
      --border-color: rgba(255,255,255,0.1);
      --panel-bg: #1a1a2e;
      --hover-bg: #2d2d4a;
      --text-primary: #ffffff;
      --success: #10b981;
      --warning: #f59e0b;
      --error: #ef4444;
      --remodely-gradient: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
    }

    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      font-family: 'Inter', -apple-system, sans-serif;
      background: var(--dark);
      color: var(--text);
      min-height: 100vh;
      overflow: hidden;
    }

    .app {
      height: 100vh;
      display: flex;
      flex-direction: column;
    }

    /* Header */
    .header {
      background: linear-gradient(90deg, rgba(30, 30, 46, 0.98) 0%, rgba(26, 26, 38, 0.98) 100%);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      border-bottom: 1px solid var(--border);
      padding: 0 20px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      height: 56px;
      flex-shrink: 0;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
      position: relative;
      z-index: 100;
    }

    .header-left {
      display: flex;
      align-items: center;
      gap: 20px;
    }

    .logo-group {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .logo {
      display: flex;
      align-items: center;
      gap: 8px;
      text-decoration: none;
    }

    .logo img {
      height: 28px;
    }

    .logo-divider {
      width: 1px;
      height: 24px;
      background: var(--border);
    }

    .powered-by {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 11px;
      color: var(--text-muted);
    }

    .powered-by .remodely-badge {
      background: var(--remodely-gradient);
      padding: 3px 8px;
      border-radius: 4px;
      font-weight: 600;
      font-size: 10px;
      color: white;
    }

    .project-input {
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 6px 12px;
      color: var(--text);
      font-size: 14px;
      font-weight: 500;
      min-width: 200px;
    }

    .project-input:focus {
      outline: none;
      border-color: var(--primary);
    }

    .header-center {
      display: flex;
      gap: 4px;
      background: var(--dark-elevated);
      padding: 4px;
      border-radius: 8px;
    }

    .view-btn {
      padding: 8px 16px;
      background: transparent;
      border: none;
      color: var(--text-muted);
      font-size: 13px;
      font-weight: 500;
      cursor: pointer;
      border-radius: 6px;
      transition: all 0.2s;
    }

    .view-btn:hover {
      color: var(--text);
    }

    .view-btn.active {
      background: var(--primary);
      color: white;
    }

    .header-right {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    /* User Account Menu */
    .user-account-menu {
      position: relative;
    }

    .user-menu-btn {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 12px;
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      border-radius: 8px;
      color: var(--text-primary);
      cursor: pointer;
      font-size: 13px;
      font-weight: 500;
      transition: all 0.2s;
    }

    .user-menu-btn:hover {
      background: var(--hover-bg);
      border-color: var(--gold);
    }

    .user-avatar-small {
      width: 28px;
      height: 28px;
      border-radius: 50%;
      background: linear-gradient(135deg, var(--gold), #cca600);
      color: #1a1a2e;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 700;
      font-size: 12px;
    }

    .user-name-display {
      max-width: 100px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .user-dropdown {
      position: absolute;
      top: 100%;
      right: 0;
      margin-top: 8px;
      background: var(--dark-surface);
      border: 1px solid var(--border);
      border-radius: 10px;
      min-width: 200px;
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
      opacity: 0;
      visibility: hidden;
      transform: translateY(-10px);
      transition: all 0.2s;
      z-index: 9999;
      pointer-events: none;
    }

    .user-dropdown.show {
      opacity: 1;
      visibility: visible;
      transform: translateY(0);
      pointer-events: auto;
    }

    .dropdown-item {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 12px 16px;
      color: var(--text-secondary);
      text-decoration: none;
      font-size: 14px;
      cursor: pointer;
      transition: all 0.2s;
      border: none;
      background: none;
      width: 100%;
      text-align: left;
    }

    .dropdown-item:first-child {
      border-radius: 10px 10px 0 0;
    }

    .dropdown-item:last-child {
      border-radius: 0 0 10px 10px;
    }

    .dropdown-item:hover {
      background: var(--hover-bg);
      color: var(--text-primary);
    }

    .dropdown-item svg {
      opacity: 0.7;
    }

    .dropdown-item:hover svg {
      opacity: 1;
    }

    .dropdown-divider {
      height: 1px;
      background: var(--border-color);
      margin: 4px 0;
    }

    .dropdown-item.logout-item {
      color: #ff6b6b;
    }

    .dropdown-item.logout-item:hover {
      background: rgba(255, 107, 107, 0.1);
      color: #ff6b6b;
    }

    .dropdown-item.google-signin {
      background: #fff;
      color: #3c4043;
      font-weight: 500;
      border-bottom: 1px solid var(--border);
    }

    .dropdown-item.google-signin:hover {
      background: #f8f9fa;
    }

    .dropdown-item.google-signin svg {
      opacity: 1;
    }

    .btn {
      padding: 8px 16px;
      border-radius: 6px;
      font-size: 13px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      gap: 6px;
      border: none;
    }

    .btn-secondary {
      background: var(--dark-elevated);
      color: var(--text);
      border: 1px solid var(--border);
    }

    .btn-secondary:hover {
      background: var(--dark-hover);
    }

    .btn-primary {
      background: var(--gold);
      color: #000;
    }

    .btn-primary:hover {
      background: var(--gold-dark);
    }

    .btn-sm {
      padding: 6px 10px;
      font-size: 11px;
    }

    /* Export Dropdown */
    .export-dropdown {
      position: relative;
    }

    .export-menu {
      position: absolute;
      top: 100%;
      right: 0;
      margin-top: 4px;
      background: var(--dark-surface);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 8px 0;
      min-width: 180px;
      box-shadow: 0 10px 40px rgba(0,0,0,0.4);
      z-index: 1000;
      display: none;
    }

    .export-menu.show {
      display: block;
    }

    .export-menu button {
      width: 100%;
      padding: 10px 16px;
      background: none;
      border: none;
      color: var(--text);
      font-size: 13px;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 10px;
      text-align: left;
    }

    .export-menu button:hover {
      background: var(--dark-hover);
    }

    .export-menu button svg {
      flex-shrink: 0;
      color: var(--text-muted);
    }

    .export-divider {
      height: 1px;
      background: var(--border);
      margin: 8px 0;
    }

    /* Main Layout */
    .main {
      flex: 1;
      display: flex;
      overflow: hidden;
    }

    /* Sidebar */
    .sidebar {
      width: 220px;
      background: linear-gradient(180deg, rgba(30, 30, 46, 0.98) 0%, rgba(26, 26, 38, 0.98) 100%);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      border-right: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      flex-shrink: 0;
      overflow-y: auto;
      box-shadow: 2px 0 8px rgba(0, 0, 0, 0.15);
    }

    .sidebar-section {
      border-bottom: 1px solid var(--border);
    }

    .sidebar-header {
      padding: 12px 16px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      cursor: pointer;
    }

    .sidebar-header:hover {
      background: var(--dark-hover);
    }

    .sidebar-title {
      font-size: 11px;
      font-weight: 600;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .sidebar-toggle {
      color: var(--text-muted);
      font-size: 10px;
    }

    .sidebar-content {
      padding: 0 12px 12px;
    }

    .sidebar-content.collapsed {
      display: none;
    }

    /* Sidebar section */
    .sidebar-section {
      position: relative;
    }

    /* Room List */
    .room-list {
      display: flex;
      flex-direction: column;
      gap: 4px;
      max-height: 200px;
      overflow-y: auto;
    }

    .room-item {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 10px;
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .room-item:hover {
      background: var(--dark-surface);
      border-color: var(--primary);
    }

    .room-item.active {
      background: rgba(249, 203, 0, 0.1);
      border-color: var(--gold);
    }

    .room-icon {
      font-size: 16px;
    }

    .room-name {
      flex: 1;
      font-size: 12px;
      font-weight: 500;
      color: var(--text-primary);
    }

    .room-size {
      font-size: 10px;
      color: var(--text-secondary);
      background: var(--dark);
      padding: 2px 6px;
      border-radius: 4px;
    }

    .room-delete-btn {
      width: 18px;
      height: 18px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: transparent;
      border: none;
      color: var(--text-secondary);
      font-size: 14px;
      cursor: pointer;
      border-radius: 4px;
      opacity: 0;
      transition: all 0.2s;
    }

    .room-item:hover .room-delete-btn {
      opacity: 1;
    }

    .room-delete-btn:hover {
      background: var(--error);
      color: white;
    }

    /* Floor Plans Grid */
    .floorplan-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 8px;
    }

    .floorplan-item {
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 10px;
      cursor: pointer;
      transition: all 0.2s;
      text-align: center;
    }

    .floorplan-item:hover {
      background: var(--dark-hover);
      border-color: var(--primary);
    }

    .floorplan-item.active {
      border-color: var(--primary);
      background: rgba(99, 102, 241, 0.15);
    }

    .floorplan-preview {
      width: 100%;
      height: 40px;
      margin-bottom: 6px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .floorplan-preview svg {
      width: 100%;
      height: 100%;
    }

    .floorplan-name {
      font-size: 10px;
      color: var(--text-secondary);
    }

    /* Tool Grid */
    .tool-grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 4px;
    }

    .tool-btn {
      aspect-ratio: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: var(--dark-elevated);
      border: 1px solid transparent;
      border-radius: 6px;
      color: var(--text-muted);
      cursor: pointer;
      transition: all 0.2s;
      padding: 6px;
    }

    .tool-btn:hover {
      background: var(--dark-hover);
      color: var(--text);
    }

    .tool-btn.active {
      background: var(--primary);
      color: white;
      border-color: var(--primary);
    }

    .tool-btn svg {
      width: 18px;
      height: 18px;
      margin-bottom: 2px;
    }

    .tool-btn span {
      font-size: 8px;
      font-weight: 500;
    }

    /* Layout Options Panel */
    .layout-options-panel {
      background: var(--dark-elevated);
      border: 1px solid var(--gold);
      border-radius: 8px;
      margin: 8px;
      overflow: hidden;
    }

    .layout-options-header {
      background: linear-gradient(135deg, var(--gold) 0%, #d4a84b 100%);
      color: var(--dark-bg);
      padding: 8px 12px;
      font-weight: 600;
      font-size: 12px;
    }

    .layout-options-content {
      padding: 10px;
    }

    .layout-option-row {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 8px;
    }

    .layout-option-row label {
      font-size: 11px;
      color: var(--text-secondary);
      min-width: 75px;
    }

    .layout-option-row select {
      flex: 1;
      background: var(--dark-bg);
      border: 1px solid var(--border);
      border-radius: 4px;
      color: var(--text);
      padding: 4px 6px;
      font-size: 11px;
    }

    .layout-option-row select:focus {
      border-color: var(--gold);
      outline: none;
    }

    .layout-option-row input[type="checkbox"] {
      accent-color: var(--gold);
    }

    .layout-option-hint {
      font-size: 10px;
      color: var(--text-muted);
      text-align: center;
      padding-top: 4px;
      border-top: 1px solid var(--border);
      margin-top: 4px;
    }

    /* Element Grid */
    .element-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 6px;
    }

    .element-item {
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 8px;
      cursor: grab;
      transition: all 0.2s;
      text-align: center;
      position: relative;
    }

    .element-item:hover {
      background: var(--dark-hover);
      border-color: var(--primary);
    }

    .element-item:active {
      cursor: grabbing;
    }

    .element-item.has-texture {
      border-color: var(--success);
    }

    .element-icon {
      width: 44px;
      height: 44px;
      margin: 0 auto 6px;
      border-radius: 6px;
      background-size: cover;
      background-position: center;
      box-shadow: 0 2px 4px rgba(0,0,0,0.3);
      border: 1px solid rgba(255,255,255,0.1);
      overflow: hidden;
    }

    .element-icon.element-svg {
      background: var(--dark-hover);
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 4px;
    }

    .element-icon.element-svg svg {
      width: 100%;
      height: 100%;
    }

    .element-name {
      font-size: 9px;
      font-weight: 500;
      color: var(--text-secondary);
    }

    .element-upload-btn {
      position: absolute;
      top: 4px;
      right: 4px;
      width: 16px;
      height: 16px;
      background: var(--dark-surface);
      border: 1px solid var(--border);
      border-radius: 3px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      opacity: 0;
      transition: all 0.2s;
    }

    .element-item:hover .element-upload-btn {
      opacity: 1;
    }

    .element-upload-btn:hover {
      background: var(--primary);
      border-color: var(--primary);
    }

    .element-upload-btn svg {
      width: 10px;
      height: 10px;
      color: var(--text);
    }

    /* Materials Library */
    .materials-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 6px;
    }

    .material-item {
      aspect-ratio: 1;
      border-radius: 6px;
      cursor: pointer;
      border: 2px solid transparent;
      transition: all 0.2s;
      background-size: cover;
      background-position: center;
      position: relative;
    }

    .material-item:hover {
      border-color: var(--primary);
      transform: scale(1.05);
    }

    .material-item.selected {
      border-color: var(--gold);
    }

    .material-item::after {
      content: attr(data-name);
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      padding: 2px 4px;
      font-size: 8px;
      text-align: center;
      border-radius: 0 0 4px 4px;
    }

    .materials-tabs {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
      margin-bottom: 10px;
    }

    .material-tab {
      padding: 4px 8px;
      font-size: 10px;
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      border-radius: 4px;
      color: var(--text-muted);
      cursor: pointer;
      transition: all 0.2s;
    }

    .material-tab:hover {
      color: var(--text);
      border-color: var(--primary);
    }

    .material-tab.active {
      background: var(--primary);
      color: white;
      border-color: var(--primary);
    }

    .material-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 8px;
    }

    .material-swatch {
      aspect-ratio: 1;
      border-radius: 8px;
      cursor: pointer;
      border: 2px solid transparent;
      transition: all 0.2s;
      background-size: cover;
      background-position: center;
      position: relative;
      overflow: hidden;
    }

    .material-swatch:hover {
      border-color: var(--primary);
      transform: scale(1.03);
    }

    .material-swatch.selected {
      border-color: var(--gold);
      box-shadow: 0 0 10px rgba(249, 203, 0, 0.4);
    }

    .material-swatch-label {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: linear-gradient(transparent, rgba(0,0,0,0.85));
      padding: 20px 6px 6px;
      font-size: 9px;
      text-align: center;
      font-weight: 500;
    }

    .material-price-badge {
      position: absolute;
      top: 4px;
      right: 4px;
      background: var(--gold);
      color: #000;
      padding: 2px 5px;
      border-radius: 4px;
      font-size: 8px;
      font-weight: 600;
      z-index: 2;
    }

    .material-brand-badge {
      position: absolute;
      top: 4px;
      left: 4px;
      background: rgba(0,0,0,0.7);
      color: #fff;
      padding: 2px 5px;
      border-radius: 4px;
      font-size: 7px;
      font-weight: 500;
      z-index: 2;
      text-transform: uppercase;
      letter-spacing: 0.3px;
    }

    .material-no-texture-badge {
      position: absolute;
      bottom: 22px;
      right: 4px;
      color: rgba(255,255,255,0.5);
      font-size: 8px;
      z-index: 2;
    }

    .material-hint {
      font-size: 10px;
      color: var(--text-muted);
      text-align: center;
      margin-top: 10px;
      padding: 8px;
      background: var(--dark-elevated);
      border-radius: 6px;
      border: 1px dashed var(--border);
    }

    /* Cabinet Catalog */
    .catalog-brand select,
    .catalog-series select {
      width: 100%;
      padding: 8px 12px;
      background: rgba(255, 255, 255, 0.05);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 8px;
      color: var(--text);
      font-size: 12px;
      margin-bottom: 8px;
      cursor: pointer;
      transition: all 0.2s ease;
      appearance: none;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 24 24' fill='none' stroke='%23888' stroke-width='2'%3E%3Cpath d='M6 9l6 6 6-6'/%3E%3C/svg%3E");
      background-repeat: no-repeat;
      background-position: right 10px center;
      padding-right: 30px;
    }

    .catalog-brand select:hover,
    .catalog-series select:hover {
      background: rgba(255, 255, 255, 0.08);
      border-color: rgba(255, 255, 255, 0.2);
    }

    .catalog-brand select:focus,
    .catalog-series select:focus {
      outline: none;
      border-color: var(--primary);
      box-shadow: 0 0 0 3px rgba(249, 203, 0, 0.15);
    }

    .cabinet-catalog-list {
      max-height: 200px;
      overflow-y: auto;
      border: 1px solid var(--border);
      border-radius: 6px;
      background: var(--dark);
    }

    .cabinet-catalog-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 8px 10px;
      border-bottom: 1px solid var(--border);
      cursor: pointer;
      transition: background 0.15s;
    }

    .cabinet-catalog-item:last-child {
      border-bottom: none;
    }

    .cabinet-catalog-item:hover {
      background: var(--dark-elevated);
    }

    .cabinet-catalog-item.dragging {
      opacity: 0.5;
    }

    .cabinet-item-info {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .cabinet-item-sku {
      font-size: 10px;
      color: var(--text-muted);
      font-family: monospace;
    }

    .cabinet-item-name {
      font-size: 11px;
      color: var(--text);
      font-weight: 500;
    }

    .cabinet-item-size {
      font-size: 10px;
      color: var(--primary);
    }

    .cabinet-item-price {
      font-size: 11px;
      font-weight: 600;
      color: var(--success, #22c55e);
      margin-left: auto;
      padding: 2px 6px;
      background: rgba(34, 197, 94, 0.1);
      border-radius: 4px;
    }

    .cabinet-item-add {
      width: 24px;
      height: 24px;
      border-radius: 4px;
      background: var(--primary);
      border: none;
      color: white;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      font-weight: bold;
      transition: background 0.15s;
    }

    .cabinet-item-add:hover {
      background: var(--primary-dark);
    }

    .catalog-actions {
      margin-top: 10px;
      display: flex;
      gap: 6px;
    }

    .catalog-actions .btn {
      flex: 1;
      justify-content: center;
    }

    /* Product Catalog */
    .product-search-bar {
      display: flex;
      gap: 6px;
      margin-bottom: 10px;
    }

    .product-search-bar input {
      flex: 1;
      padding: 6px 10px;
      border: 1px solid var(--border);
      border-radius: 4px;
      background: var(--dark);
      color: var(--text);
      font-size: 12px;
    }

    .product-search-bar .search-icon {
      width: 28px;
      height: 28px;
      border: 1px solid var(--border);
      border-radius: 4px;
      background: var(--dark);
      color: var(--text-muted);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .product-filters {
      display: flex;
      gap: 6px;
      margin-bottom: 10px;
    }

    .product-filters select {
      flex: 1;
      padding: 6px 8px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 6px;
      background: rgba(255, 255, 255, 0.05);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      color: var(--text);
      font-size: 10px;
      cursor: pointer;
      transition: all 0.2s ease;
      appearance: none;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='10' height='10' viewBox='0 0 24 24' fill='none' stroke='%23888' stroke-width='2'%3E%3Cpath d='M6 9l6 6 6-6'/%3E%3C/svg%3E");
      background-repeat: no-repeat;
      background-position: right 6px center;
      padding-right: 22px;
    }

    .product-filters select:hover {
      background: rgba(255, 255, 255, 0.08);
      border-color: rgba(255, 255, 255, 0.2);
    }

    .product-filters select:focus {
      outline: none;
      border-color: var(--primary);
    }

    .product-catalog-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 8px;
      max-height: 240px;
      overflow-y: auto;
      padding: 4px;
      background: var(--dark);
      border-radius: 6px;
      border: 1px solid var(--border);
    }

    .product-card {
      background: var(--dark-elevated);
      border-radius: 6px;
      padding: 6px;
      cursor: pointer;
      transition: all 0.2s;
      border: 2px solid transparent;
    }

    .product-card:hover {
      border-color: var(--primary);
      transform: translateY(-2px);
    }

    .product-card.selected {
      border-color: var(--primary);
      background: rgba(59, 130, 246, 0.1);
    }

    .product-card-image {
      width: 100%;
      aspect-ratio: 1;
      border-radius: 4px;
      object-fit: cover;
      background: var(--dark);
      margin-bottom: 4px;
    }

    .product-card-name {
      font-size: 10px;
      font-weight: 500;
      color: var(--text);
      line-height: 1.2;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .product-card-meta {
      font-size: 9px;
      color: var(--text-muted);
      margin-top: 2px;
    }

    .product-hint {
      text-align: center;
      font-size: 10px;
      color: var(--text-muted);
      margin-top: 8px;
    }

    .loading-products {
      grid-column: 1 / -1;
      text-align: center;
      padding: 20px;
      color: var(--text-muted);
      font-size: 11px;
    }

    /* Canvas Area */
    .canvas-area {
      flex: 1;
      display: flex;
      flex-direction: column;
      background: #12121f;
      position: relative;
      overflow: hidden;
    }

    .canvas-toolbar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 16px;
      background: var(--dark-surface);
      border-bottom: 1px solid var(--border);
      flex-shrink: 0;
    }

    .toolbar-group {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .toolbar-divider {
      width: 1px;
      height: 20px;
      background: var(--border);
      margin: 0 8px;
    }

    .zoom-controls {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .zoom-btn {
      width: 28px;
      height: 28px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      border-radius: 4px;
      color: var(--text);
      cursor: pointer;
      font-size: 14px;
    }

    .zoom-btn:hover {
      background: var(--dark-hover);
    }

    .zoom-level {
      font-size: 12px;
      color: var(--text-secondary);
      min-width: 40px;
      text-align: center;
    }

    .canvas-info {
      display: flex;
      gap: 16px;
      font-size: 11px;
      color: var(--text-muted);
    }

    .canvas-wrapper {
      flex: 1;
      position: relative;
      overflow: hidden;
      cursor: crosshair;
    }

    #canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }

    /* 3D View */
    #three-container {
      position: absolute;
      inset: 0;
      display: none;
    }

    #three-container.active {
      display: block;
    }

    /* 3D View Controls */
    .three-controls {
      position: absolute;
      bottom: 20px;
      left: 20px;
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      z-index: 100;
      max-width: calc(100% - 250px);
    }

    .three-controls button {
      padding: 6px 10px;
      background: rgba(30, 30, 40, 0.9);
      border: 1px solid var(--border);
      border-radius: 6px;
      color: var(--text);
      font-size: 11px;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 5px;
      transition: all 0.2s;
      backdrop-filter: blur(8px);
      white-space: nowrap;
    }

    .three-controls button:hover {
      background: rgba(50, 50, 65, 0.95);
      border-color: var(--accent);
    }

    .three-controls button.active {
      background: var(--accent);
      color: white;
      border-color: var(--accent);
    }

    .three-controls button svg {
      width: 14px;
      height: 14px;
      flex-shrink: 0;
    }

    .three-hint {
      position: absolute;
      bottom: 20px;
      right: 20px;
      padding: 8px 12px;
      background: rgba(30, 30, 40, 0.85);
      border-radius: 6px;
      font-size: 11px;
      color: var(--text-secondary);
      backdrop-filter: blur(8px);
    }

    .three-hint.walkthrough-hint {
      background: linear-gradient(135deg, rgba(139, 92, 246, 0.9), rgba(59, 130, 246, 0.9));
      color: white;
      font-size: 12px;
      padding: 10px 16px;
      border: 1px solid rgba(255, 255, 255, 0.2);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    }

    .three-hint.walkthrough-hint strong {
      display: block;
      margin-bottom: 4px;
      font-size: 13px;
    }

    /* Right Panel */
    .right-panel {
      width: 260px;
      background: linear-gradient(180deg, rgba(30, 30, 46, 0.98) 0%, rgba(26, 26, 38, 0.98) 100%);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      border-left: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      flex-shrink: 0;
      overflow-y: auto;
      box-shadow: -2px 0 8px rgba(0, 0, 0, 0.15);
    }

    .panel-section {
      padding: 12px 16px;
      border-bottom: 1px solid var(--border);
    }

    .panel-title {
      font-size: 11px;
      font-weight: 600;
      color: var(--text-muted);
      text-transform: uppercase;
      margin-bottom: 10px;
    }

    /* Element Selector Styles */
    #elementSelectorSection .panel-title {
      display: flex;
      align-items: center;
    }

    .element-total-count {
      background: var(--accent);
      color: white;
      font-size: 10px;
      padding: 2px 6px;
      border-radius: 10px;
      margin-left: auto;
      font-weight: 600;
    }

    .element-type-selector {
      display: flex;
      flex-direction: column;
      gap: 4px;
      max-height: 200px;
      overflow-y: auto;
    }

    .element-type-row {
      display: flex;
      align-items: center;
      padding: 6px 8px;
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.15s ease;
      gap: 8px;
    }

    .element-type-row:hover {
      background: var(--dark-surface);
      border-color: var(--accent);
    }

    .element-type-row.active {
      background: rgba(99, 102, 241, 0.15);
      border-color: var(--accent);
    }

    .element-type-row.has-selection {
      border-left: 3px solid var(--accent);
    }

    .element-type-checkbox {
      width: 16px;
      height: 16px;
      border-radius: 4px;
      border: 2px solid var(--border);
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
    }

    .element-type-row.active .element-type-checkbox {
      background: var(--accent);
      border-color: var(--accent);
    }

    .element-type-row.active .element-type-checkbox::after {
      content: 'âœ“';
      color: white;
      font-size: 10px;
      font-weight: bold;
    }

    .element-type-label {
      flex: 1;
      font-size: 12px;
      color: var(--text);
      text-transform: capitalize;
    }

    .element-type-count {
      background: var(--dark-surface);
      color: var(--text-muted);
      font-size: 10px;
      padding: 2px 6px;
      border-radius: 8px;
      font-weight: 500;
    }

    .element-type-row.active .element-type-count {
      background: var(--accent);
      color: white;
    }

    .element-instance-list {
      margin-top: 8px;
      padding-top: 8px;
      border-top: 1px solid var(--border);
      max-height: 150px;
      overflow-y: auto;
    }

    .element-instance-item {
      display: flex;
      align-items: center;
      padding: 5px 8px;
      margin-bottom: 3px;
      background: var(--dark-surface);
      border-radius: 4px;
      cursor: pointer;
      font-size: 11px;
      color: var(--text-secondary);
      transition: all 0.1s ease;
    }

    .element-instance-item:hover {
      background: var(--dark-elevated);
      color: var(--text);
    }

    .element-instance-item.selected {
      background: rgba(99, 102, 241, 0.2);
      color: var(--accent);
      font-weight: 500;
    }

    .element-instance-dims {
      margin-left: auto;
      font-size: 10px;
      color: var(--text-muted);
    }

    .element-selector-actions {
      display: flex;
      gap: 6px;
      margin-top: 8px;
      padding-top: 8px;
      border-top: 1px solid var(--border);
    }

    .btn-small {
      padding: 4px 8px;
      font-size: 11px;
      border-radius: 4px;
      border: none;
      cursor: pointer;
      transition: all 0.15s ease;
    }

    .btn-small.btn-primary {
      background: var(--accent);
      color: white;
    }

    .btn-small.btn-secondary {
      background: var(--dark-elevated);
      color: var(--text-secondary);
      border: 1px solid var(--border);
    }

    .btn-small.btn-danger {
      background: var(--error);
      color: white;
    }

    .btn-small:hover {
      opacity: 0.85;
      transform: translateY(-1px);
    }

    .no-elements-msg {
      color: var(--text-muted);
      font-size: 11px;
      text-align: center;
      padding: 12px;
    }

    /* Flat Element List Styles */
    .element-flat-list {
      border: 1px solid var(--border);
      border-radius: 6px;
      background: var(--dark-bg);
    }

    .element-list-item {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 10px;
      cursor: pointer;
      border-bottom: 1px solid var(--border);
      transition: all 0.15s ease;
    }

    .element-list-item:last-child {
      border-bottom: none;
    }

    .element-list-item:hover {
      background: var(--dark-elevated);
    }

    .element-list-item.selected {
      background: rgba(99, 102, 241, 0.2);
      border-left: 3px solid var(--accent);
    }

    .element-list-icon {
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: var(--dark-elevated);
      border-radius: 4px;
      font-size: 12px;
      flex-shrink: 0;
    }

    .element-list-info {
      flex: 1;
      min-width: 0;
      overflow: hidden;
    }

    .element-list-name {
      font-size: 12px;
      font-weight: 500;
      color: var(--text);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .element-list-meta {
      font-size: 10px;
      color: var(--text-muted);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    /* Item Picker / Quote List Styles */
    .item-picker-total {
      background: linear-gradient(135deg, #22c55e, #16a34a);
      color: white;
      font-size: 11px;
      padding: 3px 8px;
      border-radius: 4px;
      font-weight: 600;
    }

    .item-picker-controls {
      margin-bottom: 8px;
    }

    .item-filter {
      width: 100%;
      padding: 6px 8px;
      font-size: 11px;
    }

    .item-picker-list {
      max-height: 280px;
      overflow-y: auto;
      border: 1px solid var(--border);
      border-radius: 6px;
      background: var(--dark-surface);
    }

    .item-picker-item {
      display: flex;
      flex-direction: column;
      padding: 8px 10px;
      border-bottom: 1px solid var(--border);
      cursor: pointer;
      transition: all 0.15s ease;
    }

    .item-picker-item:last-child {
      border-bottom: none;
    }

    .item-picker-item:hover {
      background: var(--dark-elevated);
    }

    .item-picker-item.selected {
      background: rgba(99, 102, 241, 0.15);
      border-left: 3px solid var(--accent);
    }

    .item-row-main {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .item-checkbox {
      width: 14px;
      height: 14px;
      cursor: pointer;
    }

    .item-icon {
      width: 24px;
      height: 24px;
      background: var(--dark-elevated);
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      flex-shrink: 0;
    }

    .item-details {
      flex: 1;
      min-width: 0;
    }

    .item-name {
      font-size: 12px;
      font-weight: 500;
      color: var(--text);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .item-meta {
      font-size: 10px;
      color: var(--text-muted);
      display: flex;
      gap: 8px;
    }

    .item-price {
      font-size: 11px;
      font-weight: 600;
      color: #22c55e;
      white-space: nowrap;
    }

    .item-row-secondary {
      display: flex;
      justify-content: space-between;
      margin-top: 4px;
      padding-left: 46px;
    }

    .item-material {
      font-size: 10px;
      color: var(--accent);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 120px;
    }

    .item-dims {
      font-size: 10px;
      color: var(--text-muted);
    }

    .item-detail-line {
      font-size: 10px;
      margin-top: 2px;
      color: var(--text-muted);
    }

    .item-sku {
      background: rgba(99, 102, 241, 0.2);
      color: var(--accent);
      padding: 1px 4px;
      border-radius: 3px;
      font-family: monospace;
      font-size: 9px;
    }

    .item-catalog {
      color: var(--text-muted);
      font-size: 9px;
    }

    .item-sqft {
      color: #22c55e;
      font-weight: 500;
    }

    .item-rate {
      color: var(--text-muted);
      font-style: italic;
    }

    .item-picker-summary {
      margin-top: 8px;
      padding: 8px;
      background: var(--dark-elevated);
      border-radius: 6px;
    }

    .summary-row {
      display: flex;
      justify-content: space-between;
      font-size: 11px;
      color: var(--text-secondary);
      margin-bottom: 4px;
    }

    .summary-row:last-child {
      margin-bottom: 0;
      font-weight: 600;
      color: var(--text);
    }

    .item-picker-actions {
      display: flex;
      gap: 6px;
      margin-top: 8px;
    }

    .item-picker-empty {
      padding: 20px;
      text-align: center;
      color: var(--text-muted);
      font-size: 12px;
    }

    /* Room Templates Styles */
    .room-templates-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 6px;
    }

    .template-btn {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 10px 6px;
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s ease;
      color: var(--text);
    }

    .template-btn:hover {
      background: var(--dark-surface);
      border-color: var(--accent);
      transform: translateY(-2px);
    }

    .template-btn:active {
      transform: translateY(0);
    }

    .template-icon {
      font-size: 20px;
      margin-bottom: 4px;
    }

    .template-name {
      font-size: 10px;
      font-weight: 500;
      color: var(--text-secondary);
    }

    .template-btn:hover .template-name {
      color: var(--accent);
    }

    .template-hint {
      font-size: 10px;
      color: var(--text-muted);
      text-align: center;
      margin-top: 8px;
      margin-bottom: 0;
    }

    .room-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 8px;
    }

    .input-group {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .input-label {
      font-size: 10px;
      color: var(--text-muted);
    }

    .input-field {
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      border-radius: 4px;
      padding: 6px 8px;
      color: var(--text);
      font-size: 12px;
    }

    .input-field:focus {
      outline: none;
      border-color: var(--primary);
    }

    select.input-field {
      cursor: pointer;
    }

    /* Properties Panel */
    .properties-empty {
      text-align: center;
      padding: 20px;
      color: var(--text-muted);
      font-size: 12px;
    }

    .quick-actions {
      display: flex;
      gap: 4px;
    }

    .quick-btn {
      padding: 6px;
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      border-radius: 6px;
      cursor: pointer;
      color: var(--text-secondary);
      transition: all 0.15s;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .quick-btn:hover {
      background: var(--gold);
      color: var(--dark-bg);
      border-color: var(--gold);
    }

    .quick-btn.danger:hover {
      background: #e74c3c;
      border-color: #e74c3c;
      color: white;
    }

    /* Visibility toggle styles */
    .visibility-toggle {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 4px 6px;
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      border-radius: 4px;
      cursor: pointer;
      font-size: 10px;
      color: var(--text-secondary);
      transition: all 0.15s;
    }

    .visibility-toggle:hover {
      background: rgba(200, 169, 106, 0.1);
      border-color: var(--gold);
    }

    .visibility-toggle input[type="checkbox"] {
      width: 14px;
      height: 14px;
      margin: 0;
      cursor: pointer;
      accent-color: var(--gold);
    }

    .visibility-toggle input[type="checkbox"]:not(:checked) + span {
      text-decoration: line-through;
      opacity: 0.5;
    }

    /* Collapsible panel styles */
    .collapsible-header {
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .collapsible-header:hover {
      color: var(--gold);
    }

    .panel-toggle {
      font-size: 10px;
      transition: transform 0.2s;
    }

    .collapsible-panel .panel-content {
      overflow: hidden;
      transition: max-height 0.3s ease, padding 0.3s ease;
      max-height: 500px;
    }

    .collapsible-panel .panel-content.collapsed {
      max-height: 0;
      padding-top: 0;
      padding-bottom: 0;
    }

    .property-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }

    .property-label {
      font-size: 11px;
      color: var(--text-secondary);
    }

    .property-input {
      width: 70px;
      background: rgba(255, 255, 255, 0.05);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 6px;
      padding: 6px 8px;
      color: var(--text);
      font-size: 11px;
      text-align: right;
      transition: all 0.2s ease;
    }

    .property-input:hover {
      background: rgba(255, 255, 255, 0.08);
      border-color: rgba(255, 255, 255, 0.2);
    }

    .property-input:focus {
      outline: none;
      border-color: var(--primary);
      box-shadow: 0 0 0 3px rgba(249, 203, 0, 0.15);
    }

    .property-select {
      width: 100px;
      background: rgba(255, 255, 255, 0.05);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 6px;
      padding: 6px 8px;
      color: var(--text);
      font-size: 10px;
      cursor: pointer;
      transition: all 0.2s ease;
      appearance: none;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='10' height='10' viewBox='0 0 24 24' fill='none' stroke='%23888' stroke-width='2'%3E%3Cpath d='M6 9l6 6 6-6'/%3E%3C/svg%3E");
      background-repeat: no-repeat;
      background-position: right 6px center;
      padding-right: 22px;
    }

    .property-select:hover {
      background: rgba(255, 255, 255, 0.08);
      border-color: rgba(255, 255, 255, 0.2);
    }

    .property-select:focus {
      outline: none;
      border-color: var(--primary);
    }

    .checkbox-group {
      display: flex;
      gap: 10px;
      font-size: 10px;
    }

    .checkbox-group label {
      display: flex;
      align-items: center;
      gap: 4px;
      cursor: pointer;
    }

    .checkbox-group input[type="checkbox"] {
      width: 12px;
      height: 12px;
      accent-color: var(--primary);
    }

    .seam-controls {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .seam-btn {
      padding: 3px 8px;
      font-size: 10px;
      background: var(--primary);
      color: white;
      border: none;
      border-radius: 3px;
      cursor: pointer;
    }

    .seam-btn:hover {
      background: var(--accent);
    }

    .seam-btn.seam-clear {
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      color: var(--text-muted);
    }

    .seam-btn.seam-clear:hover {
      border-color: #dc3545;
      color: #dc3545;
    }

    .seam-count {
      font-size: 10px;
      color: var(--text-muted);
    }

    .dimension-display {
      font-size: 10px;
      color: var(--gold);
      margin-left: 6px;
      white-space: nowrap;
      min-width: 50px;
    }

    .color-picker {
      width: 70px;
      height: 26px;
      border: 1px solid var(--border);
      border-radius: 4px;
      cursor: pointer;
      padding: 0;
    }

    .texture-preview {
      width: 70px;
      height: 40px;
      border-radius: 4px;
      background-size: cover;
      background-position: center;
      border: 1px solid var(--border);
      cursor: pointer;
    }

    .texture-preview:hover {
      border-color: var(--primary);
    }

    .texture-controls {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .texture-upload-btn,
    .texture-clear-btn {
      width: 28px;
      height: 28px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      border-radius: 4px;
      cursor: pointer;
      color: var(--text-secondary);
      font-size: 12px;
      padding: 0;
    }

    .texture-upload-btn:hover {
      background: var(--primary);
      border-color: var(--primary);
      color: white;
    }

    .texture-clear-btn:hover {
      background: var(--error);
      border-color: var(--error);
      color: white;
    }

    .texture-upload-btn svg {
      width: 14px;
      height: 14px;
    }

    /* Grain Direction Controls */
    .grain-direction-controls {
      display: flex;
      gap: 4px;
    }

    .grain-btn {
      width: 28px;
      height: 28px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      border-radius: 4px;
      cursor: pointer;
      color: var(--text-secondary);
      font-size: 14px;
      font-weight: bold;
      padding: 0;
      transition: all 0.2s;
    }

    .grain-btn:hover {
      background: var(--primary);
      border-color: var(--primary);
      color: white;
    }

    .grain-btn.active {
      background: var(--gold);
      border-color: var(--gold);
      color: var(--dark-bg);
    }

    /* Validation Panel */
    .validation-section {
      border-bottom: 1px solid var(--border);
      padding-bottom: 8px;
      margin-bottom: 8px;
    }

    .validation-section .panel-title {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .validation-toggle,
    .validation-refresh {
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      border-radius: 4px;
      color: var(--text-secondary);
      cursor: pointer;
      font-size: 12px;
      padding: 2px 6px;
      margin-left: auto;
    }

    .validation-toggle:hover,
    .validation-refresh:hover {
      background: var(--primary);
      color: white;
      border-color: var(--primary);
    }

    .validation-toggle.active {
      background: var(--success);
      color: white;
      border-color: var(--success);
    }

    .validation-content {
      padding: 8px 16px;
      font-size: 11px;
      max-height: 180px;
      overflow-y: auto;
    }

    .validation-hint {
      color: var(--text-muted);
      font-style: italic;
    }

    .validation-ok {
      color: var(--success);
      font-weight: 500;
    }

    .validation-category {
      margin-bottom: 10px;
    }

    .validation-category-title {
      font-weight: 600;
      color: var(--text-secondary);
      margin-bottom: 4px;
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .validation-issue {
      display: flex;
      align-items: flex-start;
      gap: 6px;
      padding: 4px 0;
      border-bottom: 1px solid var(--border);
    }

    .validation-issue:last-child {
      border-bottom: none;
    }

    .validation-icon {
      flex-shrink: 0;
      font-size: 12px;
    }

    .validation-error .validation-icon {
      color: var(--error);
    }

    .validation-warning .validation-icon {
      color: var(--gold);
    }

    .validation-info .validation-icon {
      color: var(--primary);
    }

    .validation-message {
      color: var(--text-secondary);
      line-height: 1.3;
    }

    /* Quote Panel */
    .quote-section {
      flex: 1;
      display: flex;
      flex-direction: column;
      min-height: 0;
    }

    .quote-items {
      flex: 1;
      overflow-y: auto;
      padding: 0 16px;
    }

    .quote-item {
      display: flex;
      justify-content: space-between;
      padding: 8px 0;
      border-bottom: 1px solid var(--border);
      font-size: 11px;
    }

    .quote-item-name {
      color: var(--text-secondary);
    }

    .quote-item-value {
      color: var(--text);
      font-weight: 500;
    }

    .quote-total {
      padding: 12px 16px;
      background: var(--dark-elevated);
      border-top: 1px solid var(--border);
    }

    .quote-total-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .quote-total-label {
      font-size: 12px;
      font-weight: 600;
      color: var(--text);
    }

    .quote-total-value {
      font-size: 18px;
      font-weight: 700;
      color: var(--gold);
    }

    .quote-actions {
      padding-top: 12px;
      border-top: 1px solid var(--border);
    }

    .btn-checkout {
      width: 100%;
      padding: 12px 16px;
      background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%);
      color: white;
      border: none;
      border-radius: 8px;
      font-size: 13px;
      font-weight: 600;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
      box-shadow: 0 2px 8px rgba(34, 197, 94, 0.3);
    }

    .btn-checkout:hover {
      background: linear-gradient(135deg, #16a34a 0%, #15803d 100%);
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(34, 197, 94, 0.4);
    }

    .btn-checkout:disabled {
      background: #4a4a5a;
      cursor: not-allowed;
      box-shadow: none;
      transform: none;
    }

    .quote-disclaimer {
      font-size: 10px;
      color: var(--text-secondary);
      text-align: center;
      margin: 8px 0 0;
      line-height: 1.4;
    }

    /* Payment Modal */
    .payment-modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.7);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10000;
      backdrop-filter: blur(4px);
    }

    .payment-modal {
      background: var(--dark-elevated);
      border-radius: 16px;
      width: 90%;
      max-width: 480px;
      max-height: 90vh;
      overflow-y: auto;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
      border: 1px solid var(--border);
    }

    .payment-modal-header {
      padding: 20px 24px;
      border-bottom: 1px solid var(--border);
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .payment-modal-header h2 {
      font-size: 18px;
      font-weight: 600;
      margin: 0;
      color: var(--text);
    }

    .payment-modal-close {
      background: none;
      border: none;
      color: var(--text-secondary);
      cursor: pointer;
      padding: 4px;
      border-radius: 4px;
      transition: all 0.2s;
    }

    .payment-modal-close:hover {
      color: var(--text);
      background: var(--border);
    }

    .payment-modal-body {
      padding: 24px;
    }

    .payment-summary {
      background: rgba(255, 255, 255, 0.03);
      border-radius: 12px;
      padding: 16px;
      margin-bottom: 20px;
    }

    .payment-summary-row {
      display: flex;
      justify-content: space-between;
      padding: 8px 0;
      font-size: 13px;
    }

    .payment-summary-row.total {
      border-top: 1px solid var(--border);
      margin-top: 8px;
      padding-top: 12px;
      font-weight: 600;
      font-size: 15px;
    }

    .payment-summary-row .label {
      color: var(--text-secondary);
    }

    .payment-summary-row .value {
      color: var(--text);
    }

    .payment-summary-row.total .value {
      color: var(--gold);
    }

    .payment-options {
      margin-bottom: 20px;
    }

    .payment-option {
      background: rgba(255, 255, 255, 0.03);
      border: 2px solid var(--border);
      border-radius: 12px;
      padding: 16px;
      margin-bottom: 12px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .payment-option:hover {
      border-color: var(--accent-color);
      background: rgba(139, 92, 246, 0.05);
    }

    .payment-option.selected {
      border-color: var(--gold);
      background: rgba(212, 175, 55, 0.1);
    }

    .payment-option-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 6px;
    }

    .payment-option-title {
      font-weight: 600;
      font-size: 14px;
      color: var(--text);
    }

    .payment-option-amount {
      font-weight: 700;
      font-size: 16px;
      color: var(--gold);
    }

    .payment-option-desc {
      font-size: 12px;
      color: var(--text-secondary);
      line-height: 1.4;
    }

    .payment-form-group {
      margin-bottom: 16px;
    }

    .payment-form-group label {
      display: block;
      font-size: 12px;
      font-weight: 500;
      color: var(--text-secondary);
      margin-bottom: 6px;
    }

    .payment-form-group input {
      width: 100%;
      padding: 10px 12px;
      background: var(--dark);
      border: 1px solid var(--border);
      border-radius: 8px;
      color: var(--text);
      font-size: 14px;
    }

    .payment-form-group input:focus {
      outline: none;
      border-color: var(--accent-color);
    }

    .payment-submit {
      width: 100%;
      padding: 14px 20px;
      background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%);
      color: white;
      border: none;
      border-radius: 10px;
      font-size: 15px;
      font-weight: 600;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      transition: all 0.2s;
    }

    .payment-submit:hover {
      background: linear-gradient(135deg, #16a34a 0%, #15803d 100%);
    }

    .payment-submit:disabled {
      background: #4a4a5a;
      cursor: not-allowed;
    }

    .payment-secure {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      margin-top: 16px;
      font-size: 11px;
      color: var(--text-secondary);
    }

    .payment-secure svg {
      width: 14px;
      height: 14px;
    }

    /* Context Menu */
    .context-menu {
      position: fixed;
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 6px 0;
      min-width: 160px;
      z-index: 1000;
      box-shadow: 0 8px 32px rgba(0,0,0,0.4);
    }

    .context-menu-item {
      padding: 8px 14px;
      font-size: 12px;
      color: var(--text-secondary);
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .context-menu-item:hover {
      background: var(--dark-hover);
      color: var(--text);
    }

    .context-menu-item.danger {
      color: var(--error);
    }

    .context-menu-item svg {
      width: 14px;
      height: 14px;
    }

    .context-menu-divider {
      height: 1px;
      background: var(--border);
      margin: 4px 0;
    }

    .context-menu-label {
      padding: 6px 14px;
      font-size: 10px;
      color: var(--text-muted);
      text-transform: uppercase;
      font-weight: 600;
    }

    /* Modals */
    .modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.7);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1001;
    }

    .modal-overlay.active {
      display: flex;
    }

    .modal {
      background: var(--dark-surface);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 20px;
      width: 100%;
      max-width: 500px;
      max-height: 80vh;
      overflow-y: auto;
    }

    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 16px;
    }

    .modal-title {
      font-size: 16px;
      font-weight: 600;
    }

    .modal-close {
      width: 28px;
      height: 28px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: var(--dark-elevated);
      border: none;
      border-radius: 4px;
      color: var(--text-muted);
      cursor: pointer;
      font-size: 18px;
    }

    .modal-close:hover {
      background: var(--dark-hover);
      color: var(--text);
    }

    /* Hide close button on required modals */
    .modal-overlay[data-required="true"] .modal-close {
      display: none;
    }

    /* Login Modal Styles */
    .login-modal {
      max-width: 440px !important;
      padding: 32px !important;
    }

    .google-signin-btn {
      width: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 12px;
      padding: 14px 20px;
      background: #fff;
      border: 1px solid #dadce0;
      border-radius: 8px;
      font-size: 15px;
      font-weight: 500;
      color: #3c4043;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .google-signin-btn:hover {
      background: #f8f9fa;
      border-color: #c6c6c6;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    }

    .login-divider {
      display: flex;
      align-items: center;
      margin: 24px 0;
      color: var(--text-muted);
      font-size: 13px;
    }

    .login-divider::before,
    .login-divider::after {
      content: '';
      flex: 1;
      height: 1px;
      background: var(--border);
    }

    .login-divider span {
      padding: 0 16px;
    }

    /* Sign In Button - Clean & Modern */
    .btn-signin {
      position: relative;
      width: 100%;
      height: 50px;
      background: linear-gradient(135deg, var(--gold) 0%, #c9a227 100%);
      border: none;
      border-radius: 8px;
      color: #000;
      font-size: 15px;
      font-weight: 600;
      cursor: pointer;
      overflow: hidden;
      margin-bottom: 16px;
      transition: all 0.2s ease;
    }

    .btn-signin:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(212, 175, 55, 0.4);
    }

    .btn-signin:active {
      transform: translateY(0);
    }

    .btn-signin:disabled {
      opacity: 0.7;
      cursor: not-allowed;
      transform: none;
    }

    .btn-signin-text {
      transition: opacity 0.2s ease;
    }

    .btn-signin.loading .btn-signin-text {
      opacity: 0;
    }

    .btn-signin-loader {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 20px;
      height: 20px;
      margin: -10px 0 0 -10px;
      border: 2px solid rgba(0, 0, 0, 0.2);
      border-top-color: #000;
      border-radius: 50%;
      opacity: 0;
      transition: opacity 0.2s ease;
    }

    .btn-signin.loading .btn-signin-loader {
      opacity: 1;
      animation: spinBtn 0.6s linear infinite;
    }

    @keyframes spinBtn {
      to { transform: rotate(360deg); }
    }

    /* Material Picker Modal */
    .material-categories {
      display: flex;
      gap: 8px;
      margin-bottom: 16px;
      flex-wrap: wrap;
    }

    .material-category-btn {
      padding: 6px 12px;
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      border-radius: 4px;
      color: var(--text-secondary);
      font-size: 11px;
      cursor: pointer;
    }

    .material-category-btn:hover {
      border-color: var(--primary);
    }

    .material-category-btn.active {
      background: var(--primary);
      border-color: var(--primary);
      color: white;
    }

    .materials-modal-grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 10px;
    }

    .material-modal-item {
      aspect-ratio: 1;
      border-radius: 8px;
      cursor: pointer;
      border: 2px solid transparent;
      background-size: cover;
      background-position: center;
      position: relative;
      overflow: hidden;
    }

    .material-modal-item:hover {
      border-color: var(--primary);
    }

    .material-modal-item.selected {
      border-color: var(--gold);
    }

    .material-modal-item .material-name {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.8);
      padding: 4px 6px;
      font-size: 9px;
      text-align: center;
    }

    .material-modal-item .material-price {
      position: absolute;
      top: 4px;
      right: 4px;
      padding: 2px 6px;
      border-radius: 4px;
      font-size: 8px;
      font-weight: 600;
      color: white;
      text-shadow: 0 1px 2px rgba(0,0,0,0.3);
    }

    .material-modal-item .material-brand {
      position: absolute;
      top: 4px;
      left: 4px;
      padding: 2px 5px;
      border-radius: 3px;
      font-size: 7px;
      font-weight: 500;
      background: rgba(0,0,0,0.7);
      color: white;
    }

    .material-modal-item.daltile-material {
      border: 1px solid rgba(99, 102, 241, 0.3);
    }

    .material-modal-item.daltile-material:hover {
      border-color: var(--primary);
      box-shadow: 0 0 0 2px rgba(99, 102, 241, 0.2);
    }

    .upload-material-btn {
      aspect-ratio: 1;
      border-radius: 8px;
      border: 2px dashed var(--border);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      color: var(--text-muted);
      gap: 4px;
    }

    .upload-material-btn:hover {
      border-color: var(--primary);
      color: var(--primary);
    }

    .upload-material-btn svg {
      width: 24px;
      height: 24px;
    }

    .upload-material-btn span {
      font-size: 9px;
    }

    /* Share Modal */
    .share-link-box {
      display: flex;
      gap: 8px;
      margin-bottom: 16px;
    }

    .share-link-input {
      flex: 1;
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 10px 12px;
      color: var(--text);
      font-size: 12px;
    }

    .permission-options {
      display: flex;
      gap: 8px;
      margin-bottom: 16px;
    }

    .permission-btn {
      flex: 1;
      padding: 10px;
      background: var(--dark-elevated);
      border: 2px solid var(--border);
      border-radius: 6px;
      color: var(--text-secondary);
      cursor: pointer;
      text-align: center;
    }

    .permission-btn:hover {
      border-color: var(--primary);
    }

    .permission-btn.active {
      border-color: var(--primary);
      background: rgba(99, 102, 241, 0.1);
      color: var(--text);
    }

    .permission-btn-title {
      font-size: 12px;
      font-weight: 600;
      margin-bottom: 2px;
    }

    .permission-btn-desc {
      font-size: 10px;
      color: var(--text-muted);
    }

    /* Enhanced Share Modal */
    .share-status {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 12px;
      font-size: 12px;
      color: var(--text-secondary);
    }

    .share-status .status-indicator {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--text-muted);
    }

    .permission-section h4 {
      font-size: 12px;
      margin-bottom: 12px;
      color: var(--text-secondary);
    }

    #shareModal .permission-options {
      flex-direction: column;
    }

    #shareModal .permission-btn {
      display: flex;
      align-items: center;
      gap: 12px;
      text-align: left;
    }

    .permission-icon {
      width: 36px;
      height: 36px;
      min-width: 36px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: var(--dark-hover);
      border-radius: 8px;
    }

    .permission-icon svg {
      width: 18px;
      height: 18px;
      stroke: var(--text-secondary);
    }

    .permission-info {
      flex: 1;
    }

    .share-actions {
      margin-top: 16px;
    }

    .active-shares {
      margin-top: 20px;
      padding-top: 16px;
      border-top: 1px solid var(--border);
    }

    .active-shares h4,
    .recent-activity h4 {
      font-size: 12px;
      margin-bottom: 12px;
      color: var(--text-secondary);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .recent-activity {
      margin-top: 16px;
      padding-top: 16px;
      border-top: 1px solid var(--border);
    }

    .activity-list {
      max-height: 200px;
      overflow-y: auto;
    }

    .activity-item {
      display: flex;
      align-items: flex-start;
      gap: 10px;
      padding: 10px;
      background: var(--dark-elevated);
      border-radius: 6px;
      margin-bottom: 6px;
      font-size: 12px;
    }

    .activity-icon {
      width: 28px;
      height: 28px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      flex-shrink: 0;
    }

    .activity-icon.view { background: rgba(99, 102, 241, 0.2); }
    .activity-icon.comment { background: rgba(249, 203, 0, 0.2); }
    .activity-icon.approve { background: rgba(16, 185, 129, 0.2); }
    .activity-icon.reject { background: rgba(239, 68, 68, 0.2); }

    .activity-content {
      flex: 1;
    }

    .activity-text {
      color: var(--text-primary);
      line-height: 1.4;
    }

    .activity-time {
      color: var(--text-muted);
      font-size: 10px;
      margin-top: 2px;
    }

    .share-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px;
      background: var(--dark-elevated);
      border-radius: 6px;
      margin-bottom: 8px;
    }

    .share-info {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .share-permission {
      font-size: 11px;
      font-weight: 500;
    }

    .share-stats {
      font-size: 10px;
      color: var(--text-muted);
    }

    .share-item .share-actions {
      display: flex;
      gap: 8px;
      margin-top: 0;
    }

    .share-item .share-actions button {
      margin-left: 0;
      padding: 6px 12px;
      font-size: 11px;
    }

    /* Pricing Section in Properties */
    .pricing-section {
      margin-top: 16px;
      padding-top: 12px;
      border-top: 1px solid var(--border);
    }

    .property-section-title {
      font-size: 10px;
      font-weight: 600;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 10px;
    }

    .price-override-group {
      display: flex;
      gap: 4px;
    }

    .price-input {
      width: 70px !important;
    }

    .margin-input {
      width: 60px !important;
    }

    .property-select-sm {
      width: 50px;
      padding: 5px 4px;
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      border-radius: 4px;
      color: var(--text);
      font-size: 10px;
    }

    .price-result {
      margin-top: 8px;
      padding-top: 8px;
      border-top: 1px dashed var(--border);
    }

    .price-highlight {
      color: var(--gold);
      font-weight: 600;
    }

    /* Enhanced Quote Panel */
    .quote-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .quote-view-toggle {
      display: flex;
      background: var(--dark-elevated);
      border-radius: 4px;
      padding: 2px;
    }

    .toggle-btn {
      padding: 4px 8px;
      font-size: 10px;
      background: transparent;
      border: none;
      color: var(--text-muted);
      cursor: pointer;
      border-radius: 3px;
      transition: all 0.2s;
    }

    .toggle-btn:hover {
      color: var(--text-secondary);
    }

    .toggle-btn.active {
      background: var(--primary);
      color: white;
    }

    .quote-actions {
      display: flex;
      gap: 6px;
      margin: 10px 0;
    }

    .quote-actions .btn {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 10px;
      padding: 6px 8px;
    }

    .quote-summary {
      margin-top: 10px;
    }

    .quote-row {
      display: flex;
      justify-content: space-between;
      padding: 4px 0;
      font-size: 11px;
      color: var(--text-secondary);
    }

    .margin-badge {
      display: inline-block;
      font-size: 9px;
      background: var(--dark-hover);
      padding: 2px 5px;
      border-radius: 3px;
      margin-left: 6px;
      color: var(--text-muted);
    }

    /* Price List Modal */
    .price-list-tabs {
      display: flex;
      gap: 4px;
      margin-bottom: 16px;
      border-bottom: 1px solid var(--border);
      padding-bottom: 8px;
    }

    .tab-btn {
      padding: 8px 16px;
      background: transparent;
      border: none;
      color: var(--text-muted);
      cursor: pointer;
      font-size: 12px;
      border-radius: 4px;
      transition: all 0.2s;
    }

    .tab-btn:hover {
      color: var(--text-secondary);
      background: var(--dark-elevated);
    }

    .tab-btn.active {
      background: var(--dark-elevated);
      color: var(--text);
    }

    .price-tab {
      min-height: 200px;
    }

    .upload-dropzone {
      border: 2px dashed var(--border);
      border-radius: 8px;
      padding: 40px 20px;
      text-align: center;
      cursor: pointer;
      transition: all 0.2s;
    }

    .upload-dropzone:hover {
      border-color: var(--primary);
      background: rgba(99, 102, 241, 0.05);
    }

    .column-mapping {
      padding: 16px 0;
    }

    .mapping-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
    }

    .mapping-row label {
      font-size: 12px;
      color: var(--text-secondary);
    }

    .mapping-row select {
      width: 200px;
    }

    .mapping-preview {
      margin: 16px 0;
      padding: 12px;
      background: var(--dark-elevated);
      border-radius: 6px;
    }

    .preview-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 11px;
    }

    .preview-table th,
    .preview-table td {
      padding: 8px 6px;
      text-align: left;
      border-bottom: 1px solid var(--border);
    }

    .preview-table th {
      background: var(--dark-hover);
      font-weight: 600;
      font-size: 10px;
      text-transform: uppercase;
    }

    .mapping-actions {
      display: flex;
      justify-content: flex-end;
      gap: 8px;
      margin-top: 16px;
    }

    .saved-lists {
      min-height: 100px;
    }

    .price-list-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: var(--dark-elevated);
      border-radius: 6px;
      margin-bottom: 8px;
    }

    .price-list-name {
      font-weight: 500;
      font-size: 13px;
    }

    .price-list-date {
      font-size: 11px;
      color: var(--text-muted);
    }

    .current-prices-header {
      margin-bottom: 12px;
    }

    .search-input {
      width: 100%;
      padding: 10px 12px;
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      border-radius: 6px;
      color: var(--text);
      font-size: 12px;
    }

    .current-prices-list {
      max-height: 300px;
      overflow-y: auto;
    }

    .price-category-header {
      font-size: 11px;
      font-weight: 600;
      color: var(--text-muted);
      text-transform: uppercase;
      padding: 8px 0 4px;
      margin-top: 8px;
      border-bottom: 1px solid var(--border);
    }

    .current-price-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 4px;
      font-size: 11px;
      border-bottom: 1px solid var(--dark-elevated);
    }

    .price-item-name {
      flex: 1;
    }

    .price-item-sku {
      width: 80px;
      color: var(--text-muted);
      font-size: 10px;
    }

    .price-item-value {
      font-weight: 500;
      color: var(--gold);
    }

    .empty-state {
      text-align: center;
      color: var(--text-muted);
      padding: 20px;
      font-size: 12px;
    }

    /* Margin Modal */
    .margin-section {
      padding: 8px 0;
    }

    .margin-global {
      margin-bottom: 16px;
    }

    .margin-global label {
      display: block;
      font-size: 12px;
      margin-bottom: 6px;
      color: var(--text-secondary);
    }

    .margin-input-group {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .margin-input-group input {
      width: 80px;
    }

    .margin-symbol {
      font-size: 12px;
      color: var(--text-muted);
    }

    .margin-categories h4 {
      font-size: 12px;
      margin-bottom: 12px;
      color: var(--text-secondary);
    }

    .category-margin-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 0;
      border-bottom: 1px solid var(--dark-elevated);
    }

    .category-margin-row span {
      font-size: 12px;
    }

    .modal-footer {
      display: flex;
      justify-content: flex-end;
      gap: 8px;
      margin-top: 20px;
      padding-top: 16px;
      border-top: 1px solid var(--border);
    }

    /* Permission Notice */
    .permission-notice {
      position: fixed;
      top: 60px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 1002;
      animation: slideDown 0.3s ease;
    }

    .notice-content {
      display: flex;
      align-items: center;
      gap: 10px;
      background: var(--dark-surface);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 12px 16px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.3);
      font-size: 12px;
    }

    @keyframes slideDown {
      from { opacity: 0; transform: translateX(-50%) translateY(-10px); }
      to { opacity: 1; transform: translateX(-50%) translateY(0); }
    }

    /* Presentation Mode */
    body.presentation-mode .sidebar,
    body.presentation-mode .right-panel {
      display: none;
    }

    body.presentation-mode .canvas-container {
      width: 100%;
    }

    /* Button danger variant */
    .btn-danger {
      background: var(--error);
      color: white;
    }

    .btn-danger:hover {
      background: #dc2626;
    }

    /* ============================================= */
    /* Minimal Professional Loading Screen */
    /* ============================================= */
    .cloud-preloader {
      position: fixed;
      inset: 0;
      background: #0a0a0a;
      z-index: 99999;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      transition: opacity 0.6s ease, visibility 0.6s ease;
    }

    .cloud-preloader.loaded {
      opacity: 0;
      visibility: hidden;
      pointer-events: none;
    }

    /* Main Content */
    .preloader-content {
      text-align: center;
      opacity: 0;
      animation: contentFadeIn 0.8s ease-out 0.2s forwards;
    }

    @keyframes contentFadeIn {
      0% { opacity: 0; transform: translateY(10px); }
      100% { opacity: 1; transform: translateY(0); }
    }

    /* Company Name */
    .preloader-company {
      font-family: 'Inter', -apple-system, sans-serif;
      font-size: 2.5rem;
      font-weight: 700;
      color: #ffffff;
      margin-bottom: 8px;
      letter-spacing: -0.02em;
    }

    .preloader-tagline {
      font-size: 1rem;
      color: rgba(255,255,255,0.4);
      margin-bottom: 48px;
    }

    /* Loading Bar */
    .preloader-loading {
      width: 200px;
      margin: 0 auto;
    }

    .preloader-bar {
      height: 2px;
      background: rgba(255,255,255,0.1);
      border-radius: 2px;
      overflow: hidden;
    }

    .preloader-bar-fill {
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, #6366f1, #8b5cf6);
      border-radius: 2px;
      transition: width 0.3s ease;
    }

    /* Powered By Badge */
    .preloader-powered {
      position: absolute;
      bottom: 40px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      align-items: center;
      gap: 8px;
      opacity: 0;
      animation: poweredFadeIn 0.6s ease-out 0.8s forwards;
    }

    @keyframes poweredFadeIn {
      0% { opacity: 0; }
      100% { opacity: 1; }
    }

    .preloader-powered-icon {
      width: 20px;
      height: 20px;
    }

    .preloader-powered-icon svg {
      width: 20px;
      height: 20px;
    }

    .preloader-powered-text {
      font-size: 12px;
      color: rgba(255,255,255,0.3);
    }

    .preloader-powered-brand {
      color: rgba(255,255,255,0.5);
      font-weight: 600;
    }

    /* Hide old elements */
    .blueprint-grid,
    .blueprint-corners,
    .preloader-main,
    .room-wireframe,
    .steps-flow,
    .progress-section,
    .designer-section,
    .powered-by-section { display: none !important; }

    .cad-element.countertop {
      display: none;
      width: 240px;
      height: 40px;
      bottom: 60px;
      left: 80px;
      border-color: rgba(249, 203, 0, 0.7);
      animation: elementPlace 0.6s ease-out 2s forwards;
    }

    .cad-element.countertop::before { border-color: rgba(249, 203, 0, 0.5); }

    .cad-element.cabinet {
      width: 80px;
      height: 100px;
      bottom: 60px;
      left: 80px;
      border-color: rgba(139, 92, 246, 0.7);
      animation: elementPlace 0.6s ease-out 2.3s forwards;
    }

    .cad-element.cabinet::before { border-color: rgba(139, 92, 246, 0.5); }

    .cad-element.cabinet-2 {
      width: 80px;
      height: 100px;
      bottom: 60px;
      left: 180px;
      border-color: rgba(139, 92, 246, 0.7);
      animation: elementPlace 0.6s ease-out 2.5s forwards;
    }

    .cad-element.island {
      width: 120px;
      height: 80px;
      bottom: 120px;
      left: 180px;
      border-color: rgba(34, 197, 94, 0.7);
      animation: elementPlace 0.6s ease-out 2.7s forwards;
    }

    .cad-element.island::before { border-color: rgba(34, 197, 94, 0.5); }

    .cad-element.appliance {
      width: 50px;
      height: 50px;
      bottom: 60px;
      right: 80px;
      border-color: rgba(239, 68, 68, 0.7);
      animation: elementPlace 0.6s ease-out 2.9s forwards;
    }

    .cad-element.appliance::before { border-color: rgba(239, 68, 68, 0.5); }

    @keyframes elementPlace {
      0% {
        opacity: 0;
        transform: scale(0.8);
        filter: blur(4px);
      }
      50% {
        opacity: 1;
        border-color: inherit;
        box-shadow: 0 0 20px currentColor;
      }
      100% {
        opacity: 1;
        transform: scale(1);
        filter: blur(0);
        box-shadow: 0 0 10px currentColor;
      }
    }

    /* Node Connection Lines - ReactFlow Style */
    .node-connections {
      position: absolute;
      inset: 0;
      pointer-events: none;
      opacity: 0;
      animation: connectionsFadeIn 0.8s ease-out 3.2s forwards;
    }

    @keyframes connectionsFadeIn {
      0% { opacity: 0; }
      100% { opacity: 1; }
    }

    .connection-line {
      position: absolute;
      background: linear-gradient(90deg, rgba(59, 130, 246, 0.6), rgba(139, 92, 246, 0.6));
      height: 2px;
      transform-origin: left center;
      animation: lineGrow 0.5s ease-out forwards;
    }

    .connection-line::after {
      content: '';
      position: absolute;
      right: -4px;
      top: -3px;
      width: 8px;
      height: 8px;
      background: rgba(139, 92, 246, 0.8);
      border-radius: 50%;
      box-shadow: 0 0 10px rgba(139, 92, 246, 0.6);
    }

    @keyframes lineGrow {
      0% { width: 0; }
      100% { width: 100%; }
    }

    /* Right Side Panel */
    .preloader-panel {
      width: 320px;
      display: flex;
      flex-direction: column;
      gap: 24px;
    }

    /* Brand Section */
    /* Designer/Company Section - Main Focus */
    .designer-section {
      text-align: center;
      opacity: 0;
      animation: designerFadeIn 0.8s ease-out 0.8s forwards;
      margin-bottom: 32px;
    }

    @keyframes designerFadeIn {
      0% { opacity: 0; transform: translateY(-20px); }
      100% { opacity: 1; transform: translateY(0); }
    }

    .designer-label {
      font-size: 11px;
      color: rgba(255,255,255,0.5);
      letter-spacing: 3px;
      text-transform: uppercase;
      margin-bottom: 12px;
    }

    .designer-company {
      font-family: 'Inter', -apple-system, sans-serif;
      font-size: 1.8rem;
      font-weight: 800;
      color: #ffffff;
      margin-bottom: 6px;
      line-height: 1.2;
    }

    .designer-tagline {
      font-size: 13px;
      color: rgba(255,255,255,0.5);
    }

    /* Steps Node Flow */
    .steps-flow {
      display: flex;
      flex-direction: column;
      gap: 0;
      position: relative;
    }

    .step-node {
      display: flex;
      align-items: center;
      gap: 16px;
      padding: 12px 16px;
      background: rgba(255,255,255,0.03);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 12px;
      position: relative;
      opacity: 0;
      transform: translateX(-20px);
      transition: all 0.4s ease;
    }

    .step-node.visible {
      opacity: 1;
      transform: translateX(0);
    }

    .step-node.active {
      background: rgba(66, 133, 244, 0.1);
      border-color: rgba(66, 133, 244, 0.4);
      box-shadow: 0 0 30px rgba(66, 133, 244, 0.2);
    }

    .step-node.completed {
      background: rgba(34, 197, 94, 0.08);
      border-color: rgba(34, 197, 94, 0.2);
    }

    .step-node-icon {
      width: 40px;
      height: 40px;
      border-radius: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      background: rgba(255,255,255,0.05);
      border: 1px solid rgba(255,255,255,0.1);
      transition: all 0.3s ease;
    }

    .step-node.active .step-node-icon {
      background: linear-gradient(135deg, rgba(66, 133, 244, 0.3), rgba(52, 168, 83, 0.3));
      border-color: rgba(66, 133, 244, 0.5);
      box-shadow: 0 0 20px rgba(66, 133, 244, 0.4);
    }

    .step-node.completed .step-node-icon {
      background: rgba(34, 197, 94, 0.2);
      border-color: rgba(34, 197, 94, 0.4);
    }

    .step-node-content {
      flex: 1;
    }

    .step-node-title {
      font-size: 13px;
      font-weight: 600;
      color: rgba(255,255,255,0.9);
      margin-bottom: 2px;
    }

    .step-node-desc {
      font-size: 11px;
      color: rgba(255,255,255,0.4);
    }

    .step-node.active .step-node-title {
      color: #4285F4;
    }

    .step-node.completed .step-node-title {
      color: rgba(34, 197, 94, 0.9);
    }

    /* Connection between nodes */
    .step-connector {
      width: 2px;
      height: 16px;
      background: rgba(255,255,255,0.1);
      margin-left: 35px;
      position: relative;
      overflow: hidden;
    }

    .step-connector::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 0%;
      background: linear-gradient(180deg, rgba(66, 133, 244, 0.6), rgba(52, 168, 83, 0.6));
      transition: height 0.3s ease;
    }

    .step-connector.filled::after {
      height: 100%;
    }

    /* Progress Section */
    .progress-section {
      background: rgba(255,255,255,0.03);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 16px;
      padding: 20px;
      opacity: 0;
      animation: progressFadeIn 0.6s ease-out 1.2s forwards;
    }

    @keyframes progressFadeIn {
      0% { opacity: 0; transform: scale(0.95); }
      100% { opacity: 1; transform: scale(1); }
    }

    .progress-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
    }

    .progress-label {
      font-size: 12px;
      font-weight: 600;
      color: rgba(255,255,255,0.7);
      text-transform: uppercase;
      letter-spacing: 2px;
    }

    .progress-percent {
      font-size: 14px;
      font-weight: 700;
      color: #818cf8;
    }

    .progress-bar-container {
      height: 8px;
      background: rgba(255,255,255,0.1);
      border-radius: 8px;
      overflow: hidden;
    }

    .progress-bar-fill {
      height: 100%;
      background: linear-gradient(90deg, #4285F4, #34A853, #FBBC05, #EA4335);
      border-radius: 8px;
      width: 0%;
      transition: width 0.5s cubic-bezier(0.4, 0, 0.2, 1);
      position: relative;
    }

    .progress-bar-fill::after {
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
      animation: shimmer 1.5s infinite;
    }

    @keyframes shimmer {
      0% { transform: translateX(-100%); }
      100% { transform: translateX(100%); }
    }

    /* Powered By Remodely Badge */
    .powered-by-section {
      position: absolute;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      opacity: 0;
      animation: poweredByFadeIn 0.6s ease-out 1.5s forwards;
    }

    @keyframes poweredByFadeIn {
      0% { opacity: 0; transform: translateX(-50%) translateY(10px); }
      100% { opacity: 1; transform: translateX(-50%) translateY(0); }
    }

    .powered-by-badge {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px 20px;
      background: rgba(255,255,255,0.05);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 50px;
      backdrop-filter: blur(10px);
    }

    .powered-by-icon {
      width: 22px;
      height: 22px;
    }

    .powered-by-icon svg {
      width: 22px;
      height: 22px;
    }

    .powered-by-text {
      display: flex;
      align-items: center;
      gap: 5px;
    }

    .powered-by-label {
      font-size: 11px;
      color: rgba(255,255,255,0.4);
    }

    .powered-by-brand {
      font-size: 12px;
      font-weight: 700;
      color: #ffffff;
    }

    /* Scan Line */
    .scan-line {
      position: absolute;
      left: 0;
      right: 0;
      height: 2px;
      background: linear-gradient(90deg, transparent, rgba(66, 133, 244, 0.6), rgba(52, 168, 83, 0.6), rgba(251, 188, 5, 0.6), transparent);
      box-shadow: 0 0 20px rgba(66, 133, 244, 0.4);
      animation: scanDown 4s ease-in-out infinite;
      pointer-events: none;
    }

    @keyframes scanDown {
      0% { top: -2px; opacity: 0; }
      10% { opacity: 1; }
      90% { opacity: 1; }
      100% { top: 100%; opacity: 0; }
    }

    /* Mobile Responsive */
    @media (max-width: 900px) {
      .preloader-main {
        flex-direction: column;
        gap: 30px;
      }

      .room-wireframe {
        width: 300px;
        height: 220px;
      }

      .preloader-panel {
        width: 100%;
        max-width: 350px;
      }

      .cad-element.countertop { width: 180px; height: 30px; left: 60px; }
      .cad-element.cabinet { width: 60px; height: 75px; left: 60px; }
      .cad-element.cabinet-2 { width: 60px; height: 75px; left: 130px; }
      .cad-element.island { width: 90px; height: 60px; left: 130px; }
    }

    /* Review Room */
    .loading-shared {
      pointer-events: none;
    }

    .loading-shared::after {
      display: none; /* Hide old loading, use cloud preloader instead */
      background: rgba(0,0,0,0.9);
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-size: 18px;
      z-index: 9999;
    }

    .review-room {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      z-index: 1000;
    }

    .review-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 20px;
      background: linear-gradient(135deg, var(--dark-surface) 0%, #1a1a35 100%);
      border-bottom: 1px solid var(--border);
    }

    .review-header-left {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .review-title {
      font-size: 18px;
      font-weight: 600;
      color: var(--gold);
    }

    .review-permission-badge {
      padding: 4px 10px;
      background: var(--primary);
      border-radius: 12px;
      font-size: 11px;
      font-weight: 500;
    }

    .review-header-right {
      display: flex;
      gap: 8px;
    }

    .review-panel {
      position: fixed;
      top: 56px;
      right: -380px;
      width: 380px;
      height: calc(100vh - 56px);
      background: var(--dark-surface);
      border-left: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      transition: right 0.3s ease;
      z-index: 999;
    }

    .review-panel.open {
      right: 0;
    }

    .review-panel-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 16px;
      border-bottom: 1px solid var(--border);
    }

    .review-panel-header h3 {
      font-size: 14px;
      font-weight: 600;
    }

    .review-panel-close {
      width: 28px;
      height: 28px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: var(--dark-elevated);
      border: none;
      border-radius: 4px;
      color: var(--text-muted);
      cursor: pointer;
      font-size: 18px;
    }

    .review-summary {
      display: flex;
      padding: 16px;
      gap: 16px;
      background: var(--dark-elevated);
      border-bottom: 1px solid var(--border);
    }

    .review-stat {
      flex: 1;
      text-align: center;
    }

    .stat-value {
      display: block;
      font-size: 20px;
      font-weight: 700;
      color: var(--gold);
    }

    .stat-value.approved {
      color: var(--success);
    }

    .stat-label {
      font-size: 10px;
      color: var(--text-muted);
      text-transform: uppercase;
    }

    .review-elements {
      flex: 1;
      overflow-y: auto;
      padding: 12px;
    }

    .review-element {
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 12px;
      margin-bottom: 8px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .review-element:hover {
      border-color: var(--primary);
    }

    .review-element.approved {
      border-color: var(--success);
      background: rgba(16, 185, 129, 0.1);
    }

    .review-element.rejected {
      border-color: var(--error);
      background: rgba(239, 68, 68, 0.1);
    }

    .review-element-header {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 6px;
    }

    .review-element-status {
      width: 20px;
      height: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 50%;
      font-size: 12px;
      background: var(--dark-hover);
    }

    .review-element-status.approved {
      background: var(--success);
      color: white;
    }

    .review-element-status.rejected {
      background: var(--error);
      color: white;
    }

    .review-element-name {
      flex: 1;
      font-weight: 500;
      font-size: 13px;
    }

    .review-element-price {
      font-weight: 600;
      color: var(--gold);
      font-size: 13px;
    }

    .review-element-details {
      display: flex;
      gap: 12px;
      font-size: 11px;
      color: var(--text-muted);
      margin-bottom: 8px;
    }

    .review-element-material {
      color: var(--text-secondary);
    }

    .review-element-actions {
      display: flex;
      gap: 6px;
      padding-top: 8px;
      border-top: 1px solid var(--border);
    }

    .btn-approve, .btn-reject, .btn-comment {
      flex: 1;
      padding: 6px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      transition: all 0.2s;
    }

    .btn-approve {
      background: rgba(16, 185, 129, 0.2);
      color: var(--success);
    }

    .btn-approve:hover {
      background: var(--success);
      color: white;
    }

    .btn-reject {
      background: rgba(239, 68, 68, 0.2);
      color: var(--error);
    }

    .btn-reject:hover {
      background: var(--error);
      color: white;
    }

    .btn-comment {
      background: var(--dark-hover);
      color: var(--text-secondary);
    }

    .btn-comment:hover {
      background: var(--primary);
      color: white;
    }

    .review-comments-section {
      border-top: 1px solid var(--border);
      padding: 12px;
    }

    .review-comments-section h4 {
      font-size: 12px;
      margin-bottom: 8px;
      color: var(--text-secondary);
    }

    .review-comments {
      max-height: 150px;
      overflow-y: auto;
      margin-bottom: 8px;
    }

    .review-comment {
      background: var(--dark-elevated);
      border-radius: 6px;
      padding: 8px;
      margin-bottom: 6px;
      font-size: 12px;
    }

    .comment-header {
      display: flex;
      gap: 8px;
      margin-bottom: 4px;
      font-size: 10px;
      color: var(--text-muted);
    }

    .comment-author {
      font-weight: 600;
      color: var(--text-secondary);
    }

    .comment-element {
      color: var(--primary);
    }

    .comment-text {
      color: var(--text);
    }

    .review-comment-input {
      display: flex;
      gap: 6px;
    }

    .review-comment-input input {
      flex: 1;
      padding: 8px 10px;
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      border-radius: 6px;
      color: var(--text);
      font-size: 12px;
    }

    .review-actions {
      padding: 12px;
      border-top: 1px solid var(--border);
      display: flex;
      gap: 8px;
    }

    .review-actions .btn {
      flex: 1;
    }

    .btn-success {
      background: var(--success);
      color: white;
    }

    .btn-success:hover {
      background: #059669;
    }

    /* Quote Approval Actions */
    .quote-approval-actions {
      flex-direction: column;
      text-align: center;
      padding: 16px;
    }

    .approval-summary {
      margin-bottom: 12px;
    }

    .approval-note {
      color: var(--text-secondary);
      font-size: 13px;
      margin: 0;
    }

    .approve-pay-btn {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 100%;
      padding: 14px 24px;
      font-size: 16px;
      font-weight: 600;
      background: linear-gradient(135deg, #22c55e, #16a34a);
      border: none;
      border-radius: 8px;
      color: white;
      cursor: pointer;
      transition: all 0.2s;
      box-shadow: 0 4px 12px rgba(34, 197, 94, 0.3);
    }

    .approve-pay-btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 6px 16px rgba(34, 197, 94, 0.4);
      background: linear-gradient(135deg, #16a34a, #15803d);
    }

    .approve-pay-btn:active {
      transform: translateY(0);
    }

    .approve-pay-btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      transform: none;
    }

    .approval-terms {
      color: var(--text-secondary);
      font-size: 11px;
      margin: 12px 0 0 0;
      opacity: 0.8;
    }

    .btn-lg {
      padding: 14px 24px;
      font-size: 16px;
    }

    /* Adjust main content when review room is active */
    body:has(.review-room) .header {
      display: none;
    }

    body:has(.review-room) .main-content {
      padding-top: 56px;
    }

    body:has(.review-room) .sidebar {
      margin-top: 56px;
      height: calc(100vh - 56px);
    }

    body:has(.review-room) .right-panel {
      margin-top: 56px;
      height: calc(100vh - 56px);
    }

    body:has(.review-room) .canvas-container {
      height: calc(100vh - 56px);
    }

    body:has(.review-room) .shortcuts-hint {
      display: none;
    }

    /* Hide editing UI in review mode for non-editors */
    body.review-readonly .sidebar {
      display: none;
    }

    body.review-readonly .right-panel .panel-section:not(#quotePanel) {
      display: none;
    }

    /* Keyboard Shortcuts - auto-hide after delay */
    .shortcuts-hint {
      position: fixed;
      bottom: 12px;
      right: 12px;
      background: var(--dark-surface);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 8px 12px;
      font-size: 9px;
      color: var(--text-muted);
      display: flex;
      gap: 12px;
      opacity: 1;
      transition: opacity 0.5s ease-out;
      z-index: 100;
    }

    .shortcuts-hint.hidden {
      opacity: 0;
      pointer-events: none;
    }

    .shortcuts-hint:hover {
      opacity: 1 !important;
      pointer-events: auto !important;
    }

    .shortcut {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .shortcut kbd {
      background: var(--dark-elevated);
      padding: 2px 4px;
      border-radius: 3px;
      font-family: inherit;
      font-size: 9px;
    }

    /* Responsive */
    @media (max-width: 1200px) {
      .sidebar { width: 180px; }
      .right-panel { width: 220px; }
    }

    @media (max-width: 900px) {
      .sidebar, .right-panel { display: none; }
    }

    /* Toast Notifications */
    .toast-container {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 10000;
      display: flex;
      flex-direction: column;
      gap: 10px;
      pointer-events: none;
    }

    .toast {
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 12px 20px;
      color: var(--text-primary);
      font-size: 14px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
      animation: toastIn 0.3s ease, toastOut 0.3s ease 2.7s forwards;
      pointer-events: auto;
    }

    .toast.success {
      border-color: #34A853;
    }

    .toast.error {
      border-color: #EA4335;
    }

    @keyframes toastIn {
      from { opacity: 0; transform: translateY(20px); }
      to { opacity: 1; transform: translateY(0); }
    }

    @keyframes toastOut {
      from { opacity: 1; transform: translateY(0); }
      to { opacity: 0; transform: translateY(-20px); }
    }

    /* ===== MY DESIGNS MODAL ===== */
    .designs-tabs {
      display: flex;
      gap: 4px;
      padding: 0 0 16px 0;
      border-bottom: 1px solid var(--border-color);
      margin-bottom: 16px;
    }

    .designs-tab {
      padding: 10px 20px;
      background: transparent;
      border: none;
      color: var(--text-secondary);
      font-size: 14px;
      cursor: pointer;
      border-radius: 8px;
      transition: all 0.2s;
    }

    .designs-tab:hover {
      background: var(--dark-hover);
      color: var(--text-primary);
    }

    .designs-tab.active {
      background: var(--accent-color);
      color: white;
    }

    .designs-search {
      position: relative;
      margin-bottom: 16px;
    }

    .designs-search input {
      width: 100%;
      padding: 12px 16px 12px 44px;
      background: var(--dark-hover);
      border: 1px solid var(--border-color);
      border-radius: 10px;
      color: var(--text-primary);
      font-size: 14px;
    }

    .designs-search svg {
      position: absolute;
      left: 14px;
      top: 50%;
      transform: translateY(-50%);
      width: 18px;
      height: 18px;
      stroke: var(--text-muted);
    }

    .designs-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
      gap: 16px;
      max-height: 50vh;
      overflow-y: auto;
      padding: 4px 8px 8px 4px; /* Top/left for hover, right for scrollbar, bottom for shadow */
    }

    .design-card {
      background: var(--dark-hover);
      border: 1px solid var(--border-color);
      border-radius: 12px;
      overflow: hidden;
      cursor: pointer;
      transition: all 0.2s;
    }

    .design-card:hover {
      border-color: var(--accent-color);
      transform: scale(1.02);
      box-shadow: 0 8px 24px rgba(0,0,0,0.3);
      z-index: 10;
      position: relative;
    }

    .design-card-preview {
      height: 140px;
      background: var(--panel-bg);
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      overflow: hidden;
    }

    .design-card-preview img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .design-card-preview svg {
      width: 48px;
      height: 48px;
      stroke: var(--text-muted);
    }

    .design-card-badge {
      position: absolute;
      top: 8px;
      right: 8px;
      padding: 4px 8px;
      background: rgba(0,0,0,0.6);
      backdrop-filter: blur(4px);
      border-radius: 4px;
      font-size: 10px;
      color: white;
      text-transform: uppercase;
    }

    .design-card-info {
      padding: 12px;
    }

    .design-card-name {
      font-weight: 600;
      color: var(--text-primary);
      margin-bottom: 4px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .design-card-meta {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 12px;
      color: var(--text-muted);
    }

    .design-card-date {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .design-card-comments {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .designs-loading, .designs-empty {
      text-align: center;
      padding: 40px;
      color: var(--text-muted);
    }

    .designs-empty svg {
      width: 64px;
      height: 64px;
      margin-bottom: 16px;
      stroke: var(--text-muted);
    }

    .designs-empty p {
      margin-bottom: 16px;
      font-size: 16px;
    }

    /* Notification Toast */
    .notification-toast {
      position: fixed;
      top: 20px;
      right: 20px;
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 16px 20px;
      background: rgba(30, 30, 40, 0.95);
      backdrop-filter: blur(20px);
      border: 1px solid var(--border-color);
      border-radius: 12px;
      box-shadow: 0 8px 32px rgba(0,0,0,0.4);
      z-index: 10000;
      transform: translateX(calc(100% + 40px));
      transition: transform 0.3s ease;
      max-width: 360px;
    }

    .notification-toast.show {
      transform: translateX(0);
    }

    .notification-icon {
      width: 40px;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: var(--accent-color);
      border-radius: 10px;
      flex-shrink: 0;
    }

    .notification-icon svg {
      width: 20px;
      height: 20px;
      stroke: white;
    }

    .notification-content {
      flex: 1;
      min-width: 0;
    }

    .notification-title {
      font-weight: 600;
      color: var(--text-primary);
      font-size: 14px;
      margin-bottom: 2px;
    }

    .notification-body {
      font-size: 13px;
      color: var(--text-secondary);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .notification-close {
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: transparent;
      border: none;
      color: var(--text-muted);
      cursor: pointer;
      font-size: 18px;
      border-radius: 4px;
    }

    .notification-close:hover {
      background: var(--dark-hover);
      color: var(--text-primary);
    }
  </style>
</head>
<body>
  <!-- Minimal Loading Screen -->
  <div class="cloud-preloader loaded" id="cloudPreloader">
    <!-- Main Content -->
    <div class="preloader-content">
      <div class="preloader-company" id="preloaderCompanyMain">Your Company</div>
      <div class="preloader-tagline">Design Quote</div>
      <div class="preloader-loading">
        <div class="preloader-bar">
          <div class="preloader-bar-fill" id="preloaderProgressBar"></div>
        </div>
      </div>
    </div>

    <!-- Powered By -->
    <div class="preloader-powered">
      <div class="preloader-powered-icon">
        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" fill="none">
          <defs>
            <linearGradient id="remodelyGradient" x1="0%" y1="0%" x2="100%" y2="100%">
              <stop offset="0%" style="stop-color:#6366f1"/>
              <stop offset="100%" style="stop-color:#8b5cf6"/>
            </linearGradient>
          </defs>
          <path d="M3 21V10l9-7 9 7v11" stroke="url(#remodelyGradient)" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"/>
          <path d="M21 21h-7" stroke="#8b5cf6" stroke-width="2.5" stroke-linecap="round"/>
        </svg>
      </div>
      <div class="preloader-powered-text">Powered by <span class="preloader-powered-brand">Remodely.ai</span></div>
    </div>
  </div>
  <div class="app">
    <!-- Header -->
    <header class="header">
      <div class="header-left">
        <div class="logo-group">
          <a href="/" class="logo">
            <img src="https://cdn.prod.website-files.com/6456ce4476abb25581fbad0c/6456ce4476abb269c6fbb176_Surprise-Granite-favicon-32x32px.png" alt="Surprise Granite">
          </a>
          <div class="logo-divider"></div>
          <div class="powered-by">
            <span>Powered by</span>
            <span class="remodely-badge">Remodely.ai</span>
          </div>
        </div>
        <input type="text" class="project-input" id="projectName" value="Untitled Project" placeholder="Project name">
      </div>

      <div class="header-center">
        <button class="view-btn active" id="view2D" onclick="setView('2d')">2D Plan</button>
        <button class="view-btn" id="view3D" onclick="setView('3d')">3D View</button>
        <button class="view-btn" id="viewDetailedModel" onclick="previewDetailedCabinetModel()" title="Preview imported 3D cabinet model">Preview Model</button>
      </div>

      <div class="header-right">
        <!-- User Account Menu -->
        <div class="user-account-menu" id="userAccountMenu">
          <button class="user-menu-btn" id="userMenuBtn" onclick="toggleUserMenu()">
            <div class="user-avatar-small" id="userAvatarSmall">?</div>
            <span class="user-name-display" id="userNameDisplay">Sign In</span>
            <svg width="10" height="10" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <polyline points="6 9 12 15 18 9"/>
            </svg>
          </button>
          <div class="user-dropdown" id="userDropdown">
            <!-- Logged out state -->
            <div id="loggedOutMenu">
              <button class="dropdown-item google-signin" onclick="handleGoogleSignIn()">
                <svg width="16" height="16" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                  <path fill="#4285F4" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"/>
                  <path fill="#34A853" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/>
                  <path fill="#FBBC05" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/>
                  <path fill="#EA4335" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/>
                </svg>
                Sign in with Google
              </button>
              <button class="dropdown-item" onclick="showLoginPrompt('Sign in to save and share your designs')">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M15 3h4a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2h-4"/>
                  <polyline points="10 17 15 12 10 7"/>
                  <line x1="15" y1="12" x2="3" y2="12"/>
                </svg>
                Sign In with Email
              </button>
              <button class="dropdown-item" onclick="continueAsGuest(); closeUserMenu();">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"/>
                  <circle cx="12" cy="7" r="4"/>
                </svg>
                Continue as Guest
              </button>
            </div>
            <!-- Logged in state -->
            <div id="loggedInMenu" style="display: none;">
              <a href="/account/" class="dropdown-item">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"/>
                  <circle cx="12" cy="7" r="4"/>
                </svg>
                My Account
              </a>
              <a href="/account/?page=my-designs" class="dropdown-item">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>
                  <line x1="3" y1="9" x2="21" y2="9"/>
                  <line x1="9" y1="21" x2="9" y2="9"/>
                </svg>
                My Designs
              </a>
              <a href="/account/?page=tools" class="dropdown-item">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M14.7 6.3a1 1 0 0 0 0 1.4l1.6 1.6a1 1 0 0 0 1.4 0l3.77-3.77a6 6 0 0 1-7.94 7.94l-6.91 6.91a2.12 2.12 0 0 1-3-3l6.91-6.91a6 6 0 0 1 7.94-7.94l-3.76 3.76z"/>
                </svg>
                All Tools
              </a>
              <div class="dropdown-divider"></div>
              <button class="dropdown-item logout-item" onclick="handleLogout()">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4"/>
                  <polyline points="16 17 21 12 16 7"/>
                  <line x1="21" y1="12" x2="9" y2="12"/>
                </svg>
                Sign Out
              </button>
            </div>
          </div>
        </div>

        <!-- Save Design Button -->
        <button class="btn btn-primary" id="saveDesignBtn" onclick="saveDesignToCloud()" style="background: #10B981; border-color: #10B981;">
          <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M19 21H5a2 2 0 01-2-2V5a2 2 0 012-2h11l5 5v11a2 2 0 01-2 2z"/>
            <polyline points="17 21 17 13 7 13 7 21"/>
            <polyline points="7 3 7 8 15 8"/>
          </svg>
          <span id="saveDesignText">Save</span>
        </button>

        <button class="btn btn-secondary" onclick="openMyDesignsModal()">
          <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M3 7v10a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-6l-2-2H5a2 2 0 00-2 2z"/>
          </svg>
          My Designs
        </button>

        <button class="btn btn-secondary" onclick="openShareModal()">
          <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M4 12v8a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-8"/>
            <polyline points="16,6 12,2 8,6"/>
            <line x1="12" y1="2" x2="12" y2="15"/>
          </svg>
          Share
        </button>

        <div class="export-dropdown">
          <button class="btn btn-secondary" onclick="toggleExportMenu()">
            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
              <polyline points="7 10 12 15 17 10"/>
              <line x1="12" y1="15" x2="12" y2="3"/>
            </svg>
            Export
            <svg width="10" height="10" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="margin-left: 4px;">
              <polyline points="6 9 12 15 18 9"/>
            </svg>
          </button>
          <div class="export-menu" id="exportMenu">
            <button onclick="exportToPDF()">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
                <polyline points="14,2 14,8 20,8"/>
                <line x1="16" y1="13" x2="8" y2="13"/>
                <line x1="16" y1="17" x2="8" y2="17"/>
              </svg>
              PDF Proposal
            </button>
            <button onclick="exportToJSON()">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
                <polyline points="14,2 14,8 20,8"/>
                <line x1="9" y1="15" x2="15" y2="15"/>
              </svg>
              Save Design (JSON)
            </button>
            <button onclick="exportToPNG()">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>
                <circle cx="8.5" cy="8.5" r="1.5"/>
                <polyline points="21,15 16,10 5,21"/>
              </svg>
              Export Image (PNG)
            </button>
            <button onclick="exportToCSV()">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
                <polyline points="14,2 14,8 20,8"/>
                <line x1="8" y1="13" x2="16" y2="13"/>
                <line x1="8" y1="17" x2="16" y2="17"/>
                <line x1="12" y1="9" x2="12" y2="21"/>
              </svg>
              Parts List (CSV)
            </button>
            <div class="export-divider"></div>
            <button onclick="importFromJSON()">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                <polyline points="17 8 12 3 7 8"/>
                <line x1="12" y1="3" x2="12" y2="15"/>
              </svg>
              Load Design (JSON)
            </button>
          </div>
        </div>

        <button class="btn btn-primary" onclick="generateQuote()">
          <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
            <polyline points="14,2 14,8 20,8"/>
          </svg>
          Get Quote
        </button>
      </div>
    </header>

    <!-- Main Content -->
    <main class="main">
      <!-- Left Sidebar -->
      <aside class="sidebar">
        <!-- Multi-Room Manager -->
        <div class="sidebar-section" data-tutorial="rooms">
          <div class="sidebar-header" onclick="toggleSection(this)">
            <span class="sidebar-title">Rooms</span>
            <span class="sidebar-toggle">â–¼</span>
          </div>
          <div class="sidebar-content">
            <div id="roomList" class="room-list">
              <!-- Room list will be rendered here -->
            </div>
            <button class="btn btn-primary btn-sm" onclick="showAddRoomModal()" style="width: 100%; margin-top: 8px;">
              + Add Room
            </button>
            <div style="margin-top: 8px; display: flex; gap: 4px;">
              <button class="btn btn-secondary btn-sm" onclick="viewAllRooms3D()" style="flex: 1; font-size: 10px;" title="View all rooms in 3D">
                ðŸ  View All
              </button>
              <button class="btn btn-secondary btn-sm" onclick="exportMultiRoomLayout()" style="flex: 1; font-size: 10px;" title="Export layout">
                ðŸ“¤ Export
              </button>
            </div>
          </div>
        </div>

        <!-- Floor Plans -->
        <div class="sidebar-section">
          <div class="sidebar-header" onclick="toggleSection(this)" title="Choose a room layout">
            <span class="sidebar-title">Floor Plans</span>
            <span class="sidebar-toggle">â–¼</span>
          </div>
          <div class="sidebar-content">
            <div class="floorplan-grid" id="floorplanGrid">
              <!-- Floor plans will be rendered here -->
            </div>
          </div>
        </div>

        <!-- Tools -->
        <div class="sidebar-section">
          <div class="sidebar-header" onclick="toggleSection(this)" title="Draw & edit tools">
            <span class="sidebar-title">Tools</span>
            <span class="sidebar-toggle">â–¼</span>
          </div>
          <div class="sidebar-content">
            <div class="tool-grid">
              <button class="tool-btn active" id="toolSelect" onclick="setTool('select')" title="Select (V)">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M3 3l7.07 16.97 2.51-7.39 7.39-2.51L3 3z"/>
                </svg>
                <span>Select</span>
              </button>
              <button class="tool-btn" id="toolWall" onclick="setTool('wall')" title="Draw Wall (W)">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <rect x="3" y="3" width="18" height="18" rx="2"/>
                </svg>
                <span>Wall</span>
              </button>
              <button class="tool-btn" id="toolCountertop" onclick="setTool('countertop')" title="Draw Countertop (C)">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <rect x="2" y="8" width="20" height="4" rx="1"/>
                  <rect x="4" y="12" width="16" height="8" fill="none"/>
                </svg>
                <span>Counter</span>
              </button>
              <button class="tool-btn" id="toolPan" onclick="setTool('pan')" title="Pan (H)">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M18 11V6a2 2 0 0 0-2-2a2 2 0 0 0-2 2"/>
                  <path d="M14 10V4a2 2 0 0 0-2-2a2 2 0 0 0-2 2v2"/>
                  <path d="M10 10.5V6a2 2 0 0 0-2-2a2 2 0 0 0-2 2v8"/>
                  <path d="M18 8a2 2 0 1 1 4 0v6a8 8 0 0 1-8 8h-2c-2.8 0-4.5-.86-5.99-2.34l-3.6-3.6a2 2 0 0 1 2.83-2.82L7 15"/>
                </svg>
                <span>Pan</span>
              </button>
              <button class="tool-btn" id="toolMeasure" onclick="setTool('measure')" title="Measure (M)">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M21.3 8.7 8.7 21.3c-1 1-2.5 1-3.4 0l-2.6-2.6c-1-1-1-2.5 0-3.4L15.3 2.7c1-1 2.5-1 3.4 0l2.6 2.6c1 1 1 2.5 0 3.4Z"/>
                </svg>
                <span>Measure</span>
              </button>
              <button class="tool-btn" id="toolAutoCounter" onclick="generateCountertopsOverCabinets()" title="Auto-generate countertops over base cabinets">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <rect x="2" y="6" width="20" height="3" rx="1" fill="currentColor" opacity="0.3"/>
                  <rect x="4" y="9" width="16" height="10" rx="1"/>
                  <path d="M12 2v4M8 4l4-2 4 2"/>
                </svg>
                <span>Auto Top</span>
              </button>
              <button class="tool-btn" id="toolAlign" onclick="showAlignMenu()" title="Align selected elements">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <line x1="4" y1="6" x2="20" y2="6"/>
                  <line x1="4" y1="12" x2="20" y2="12"/>
                  <line x1="4" y1="18" x2="20" y2="18"/>
                  <rect x="8" y="4" width="8" height="4" fill="currentColor" opacity="0.3"/>
                  <rect x="6" y="10" width="12" height="4" fill="currentColor" opacity="0.3"/>
                </svg>
                <span>Align</span>
              </button>
              <button class="tool-btn" id="toolLayout" onclick="setTool('layout')" title="Cabinet Layout (L) - Click and drag to create cabinet runs">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <rect x="2" y="14" width="6" height="8" rx="1"/>
                  <rect x="9" y="14" width="6" height="8" rx="1"/>
                  <rect x="16" y="14" width="6" height="8" rx="1"/>
                  <rect x="2" y="12" width="20" height="2" fill="currentColor" opacity="0.4"/>
                  <path d="M4 10 L12 4 L20 10" stroke-width="1.5"/>
                </svg>
                <span>Layout</span>
              </button>
            </div>
          </div>
        </div>

        <!-- Layout Tool Options (shown when layout tool is active) -->
        <div class="layout-options-panel" id="layoutOptionsPanel" style="display: none;">
          <div class="layout-options-header">
            <span>ðŸ“ Layout Brush Options</span>
          </div>
          <div class="layout-options-content">
            <div class="layout-option-row">
              <label>Element Type:</label>
              <select id="layoutElementType" onchange="updateLayoutElementType()">
                <optgroup label="Base Cabinets">
                  <option value="base-cabinet" selected>Base Cabinet</option>
                  <option value="drawer-base">Drawer Base</option>
                  <option value="sink-base">Sink Base</option>
                  <option value="corner-cabinet">Corner Cabinet</option>
                  <option value="lazy-susan">Lazy Susan</option>
                </optgroup>
                <optgroup label="Upper Cabinets">
                  <option value="wall-cabinet">Wall Cabinet</option>
                </optgroup>
                <optgroup label="Tall Cabinets">
                  <option value="tall-cabinet">Tall/Pantry</option>
                </optgroup>
                <optgroup label="Walls">
                  <option value="pony-wall">Pony Wall</option>
                  <option value="knee-wall">Knee Wall</option>
                  <option value="wall">Full Wall</option>
                </optgroup>
                <optgroup label="Surfaces">
                  <option value="countertop">Countertop</option>
                  <option value="backsplash">Backsplash</option>
                </optgroup>
              </select>
            </div>
            <div class="layout-option-row">
              <label>Depth:</label>
              <select id="layoutDepth" onchange="updateLayoutDepth()">
                <option value="1">12" (Wall Cab)</option>
                <option value="1.5">18"</option>
                <option value="2" selected>24" (Base Cab)</option>
                <option value="2.5">30"</option>
                <option value="3">36" (Island)</option>
              </select>
            </div>
            <div class="layout-option-row">
              <label>Corner Treatment:</label>
              <select id="layoutCornerType" onchange="updateLayoutCornerType()">
                <option value="corner-cabinet" selected>Corner Cabinet (36")</option>
                <option value="lazy-susan">Lazy Susan (36")</option>
                <option value="blind-corner">Blind Corner</option>
                <option value="filler">Filler Space</option>
                <option value="none">No Corner (overlap)</option>
              </select>
            </div>
            <div class="layout-option-row">
              <label>
                <input type="checkbox" id="layoutAddCountertop" onchange="updateLayoutCountertop()">
                Auto-add countertop
              </label>
            </div>
            <div class="layout-option-row">
              <label>
                <input type="checkbox" id="layoutSnapToWalls" checked onchange="updateLayoutWallSnap()">
                Snap to walls
              </label>
            </div>
            <div class="layout-option-hint">
              Click & drag to draw runs â€¢ Turn creates corners
            </div>
          </div>
        </div>

        <!-- Cabinets -->
        <div class="sidebar-section">
          <div class="sidebar-header" onclick="toggleSection(this)" title="Add cabinets">
            <span class="sidebar-title">Cabinets</span>
            <span class="sidebar-toggle">â–¼</span>
          </div>
          <div class="sidebar-content">
            <div class="element-grid" id="cabinetsGrid">
              <!-- Elements rendered by JS -->
            </div>
          </div>
        </div>

        <!-- Surfaces -->
        <div class="sidebar-section">
          <div class="sidebar-header" onclick="toggleSection(this)" title="Countertops & flooring">
            <span class="sidebar-title">Surfaces</span>
            <span class="sidebar-toggle">â–¼</span>
          </div>
          <div class="sidebar-content">
            <div style="display: flex; gap: 4px; margin-bottom: 8px;">
              <button class="quick-btn" style="flex: 1; font-size: 10px; padding: 4px 6px;" onclick="fillRoomWithFlooring()" title="Fill entire room with flooring">
                Fill Floor
              </button>
              <button class="quick-btn" style="flex: 1; font-size: 10px; padding: 4px 6px;" onclick="generateCountertopsOverCabinets()" title="Auto-generate countertops over base cabinets">
                Auto Counter
              </button>
            </div>
            <div class="element-grid" id="surfacesGrid">
              <!-- Elements rendered by JS -->
            </div>
          </div>
        </div>

        <!-- Appliances -->
        <div class="sidebar-section">
          <div class="sidebar-header" onclick="toggleSection(this)" title="Sinks, stoves & more">
            <span class="sidebar-title">Appliances</span>
            <span class="sidebar-toggle">â–¼</span>
          </div>
          <div class="sidebar-content">
            <div class="element-grid" id="appliancesGrid">
              <!-- Elements rendered by JS -->
            </div>
          </div>
        </div>

        <!-- Structure -->
        <div class="sidebar-section">
          <div class="sidebar-header" onclick="toggleSection(this)" title="Doors, windows & walls">
            <span class="sidebar-title">Structure</span>
            <span class="sidebar-toggle">â–¼</span>
          </div>
          <div class="sidebar-content">
            <div class="element-grid" id="structureGrid">
              <!-- Elements rendered by JS -->
            </div>
          </div>
        </div>

        <!-- Bathroom Fixtures -->
        <div class="sidebar-section">
          <div class="sidebar-header" onclick="toggleSection(this)" title="Toilets, tubs, vanities & showers">
            <span class="sidebar-title">Bathroom</span>
            <span class="sidebar-toggle">â–¼</span>
          </div>
          <div class="sidebar-content">
            <div class="element-grid" id="bathroomGrid">
              <!-- Elements rendered by JS -->
            </div>
          </div>
        </div>

        <!-- Laundry -->
        <div class="sidebar-section">
          <div class="sidebar-header" onclick="toggleSection(this)" title="Washer, dryer & laundry items">
            <span class="sidebar-title">Laundry</span>
            <span class="sidebar-toggle">â–¼</span>
          </div>
          <div class="sidebar-content">
            <div class="element-grid" id="laundryGrid">
              <!-- Elements rendered by JS -->
            </div>
          </div>
        </div>

        <!-- Closet -->
        <div class="sidebar-section">
          <div class="sidebar-header" onclick="toggleSection(this)" title="Closet organization & storage">
            <span class="sidebar-title">Closet</span>
            <span class="sidebar-toggle">â–¼</span>
          </div>
          <div class="sidebar-content">
            <div class="element-grid" id="closetGrid">
              <!-- Elements rendered by JS -->
            </div>
          </div>
        </div>

        <!-- Materials Library -->
        <div class="sidebar-section">
          <div class="sidebar-header" onclick="toggleSection(this)" title="Apply materials">
            <span class="sidebar-title">Materials</span>
            <span class="sidebar-toggle">â–¼</span>
          </div>
          <div class="sidebar-content">
            <div class="materials-tabs">
              <!-- Countertop Stones -->
              <button class="material-tab active" onclick="showMaterialCategory('granite', this)">Granite</button>
              <button class="material-tab" onclick="showMaterialCategory('quartz', this)">Quartz</button>
              <button class="material-tab" onclick="showMaterialCategory('marble', this)">Marble</button>
              <button class="material-tab" onclick="showMaterialCategory('quartzite', this)">Quartzite</button>
              <!-- Flooring -->
              <button class="material-tab" onclick="showMaterialCategory('tile', this)">Tile</button>
              <button class="material-tab" onclick="showMaterialCategory('flooring', this)">LVT</button>
              <button class="material-tab" onclick="showMaterialCategory('hardscape', this)">Hardscape</button>
              <!-- Cabinet Finishes -->
              <button class="material-tab" onclick="showMaterialCategory('cabinets', this)">Cabinets</button>
              <button class="material-tab" onclick="showMaterialCategory('vanities', this)">Vanities</button>
              <!-- Specialty -->
              <button class="material-tab" onclick="showMaterialCategory('showerPanels', this)">Shower</button>
              <button class="material-tab" onclick="showMaterialCategory('flooringTrims', this)">Trims</button>
            </div>
            <div class="material-grid" id="materialGrid">
              <!-- Materials rendered by JS -->
            </div>
            <div class="material-hint">Click material, then click element to apply</div>
          </div>
        </div>

        <!-- Cabinet Catalog -->
        <div class="sidebar-section">
          <div class="sidebar-header" onclick="toggleSection(this)" title="Browse cabinet SKUs">
            <span class="sidebar-title">Cabinet Catalog</span>
            <span class="sidebar-toggle">â–¼</span>
          </div>
          <div class="sidebar-content">
            <div class="catalog-brand">
              <select id="catalogSelect" onchange="changeCatalog(this.value)">
                <option value="procraft">ProCraft Cabinetry</option>
                <option value="msi">MSI Cabinetry</option>
                <option value="custom">Custom / Import</option>
              </select>
            </div>
            <div class="catalog-series" id="catalogSeries">
              <select id="seriesSelect" onchange="changeSeries(this.value)">
                <option value="shaker-white">Shaker White</option>
                <option value="shaker-grey">Shaker Grey</option>
                <option value="shaker-espresso">Shaker Espresso</option>
              </select>
            </div>
            <div class="materials-tabs" id="cabinetCategoryTabs">
              <button class="material-tab active" onclick="showCabinetCategory('base', this)">Base</button>
              <button class="material-tab" onclick="showCabinetCategory('drawer', this)">Drawer</button>
              <button class="material-tab" onclick="showCabinetCategory('sink', this)">Sink</button>
              <button class="material-tab" onclick="showCabinetCategory('wall', this)">Wall</button>
              <button class="material-tab" onclick="showCabinetCategory('tall', this)">Tall</button>
              <button class="material-tab" onclick="showCabinetCategory('corner', this)">Corner</button>
              <button class="material-tab" onclick="showCabinetCategory('lazySusan', this)">L.Susan</button>
            </div>
            <div class="cabinet-catalog-list" id="cabinetCatalogList">
              <!-- Cabinets rendered by JS -->
            </div>
            <div class="catalog-actions">
              <button class="btn btn-sm btn-secondary" onclick="importCabinetList()" title="Import cabinet list from CSV or JSON">
                <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                  <polyline points="17 8 12 3 7 8"/>
                  <line x1="12" y1="3" x2="12" y2="15"/>
                </svg>
                Import List
              </button>
            </div>
          </div>
        </div>

        <!-- Product Catalog from Website -->
        <div class="sidebar-section">
          <div class="sidebar-header" onclick="toggleSection(this)" title="Shop online products">
            <span class="sidebar-title">Store Products</span>
            <span class="sidebar-toggle">â–¼</span>
          </div>
          <div class="sidebar-content">
            <div class="product-search-bar">
              <input type="text" id="productSearchInput" placeholder="Search products..." oninput="filterStoreProducts()">
              <button class="search-icon" onclick="filterStoreProducts()">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <circle cx="11" cy="11" r="8"/>
                  <line x1="21" y1="21" x2="16.65" y2="16.65"/>
                </svg>
              </button>
            </div>
            <div class="materials-tabs" id="productCategoryTabs">
              <button class="material-tab active" onclick="showProductCategory('countertops', this)">Countertops</button>
              <button class="material-tab" onclick="showProductCategory('tile', this)">Tile</button>
              <button class="material-tab" onclick="showProductCategory('flooring', this)">Flooring</button>
              <button class="material-tab" onclick="showProductCategory('sinks', this)">Sinks</button>
            </div>
            <div class="product-filters">
              <select id="productBrandFilter" onchange="filterStoreProducts()">
                <option value="">All Brands</option>
              </select>
              <select id="productTypeFilter" onchange="filterStoreProducts()">
                <option value="">All Types</option>
              </select>
            </div>
            <div class="product-catalog-grid" id="productCatalogGrid">
              <div class="loading-products">Loading products...</div>
            </div>
            <div class="product-hint">Click product to apply as material</div>
          </div>
        </div>
      </aside>

      <!-- Canvas Area -->
      <div class="canvas-area">
        <div class="canvas-toolbar">
          <div class="toolbar-group">
            <button class="btn btn-sm btn-secondary" id="undoBtn" onclick="undo()" title="Undo (Ctrl+Z)">
              <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M3 10h10a5 5 0 0 1 5 5v2"/>
                <polyline points="3 10 8 5 8 15 3 10"/>
              </svg>
            </button>
            <button class="btn btn-sm btn-secondary" id="redoBtn" onclick="redo()" title="Redo (Ctrl+Y)">
              <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M21 10H11a5 5 0 0 0-5 5v2"/>
                <polyline points="21 10 16 5 16 15 21 10"/>
              </svg>
            </button>
            <div class="toolbar-divider"></div>
            <div class="zoom-controls">
              <button class="zoom-btn" onclick="zoomOut()">âˆ’</button>
              <span class="zoom-level" id="zoomLevel" onclick="resetZoom()" title="Click to reset to 100%" style="cursor: pointer;">100%</span>
              <button class="zoom-btn" onclick="zoomIn()">+</button>
              <button class="zoom-btn" onclick="resetZoom()" title="Reset to 100%">â†º</button>
              <button class="zoom-btn" onclick="fitToScreen()" title="Fit to screen">âŠ¡</button>
              <button class="zoom-btn" id="lockViewBtn" onclick="toggleViewLock()" title="Lock view (prevent pan/zoom)">ðŸ”“</button>
            </div>
            <div class="toolbar-divider"></div>
            <button class="btn btn-sm btn-secondary" onclick="clearCanvas()" title="Clear all elements (keeps room settings)">Clear Canvas</button>
            <button class="btn btn-sm btn-secondary" onclick="resetCanvas()" style="color: #ef4444;" title="Reset entire project including saved progress">Reset Project</button>
          </div>
          <div class="canvas-info">
            <span id="canvasSize">12' Ã— 10'</span>
            <span id="elementCount">0 elements</span>
          </div>
        </div>
        <div class="canvas-wrapper" id="canvasWrapper">
          <canvas id="canvas"></canvas>
        </div>
        <div id="three-container">
          <div class="three-controls">
            <button onclick="reset3DView()" title="Reset camera to default position">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/>
                <path d="M3 3v5h5"/>
              </svg>
              Reset View
            </button>
            <button onclick="set3DViewAngle('top')" title="Top-down view">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="12" cy="12" r="3"/>
                <path d="M12 2v4M12 18v4M2 12h4M18 12h4"/>
              </svg>
              Top
            </button>
            <button onclick="set3DViewAngle('front')" title="Front view">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <rect x="3" y="3" width="18" height="18" rx="2"/>
              </svg>
              Front
            </button>
            <button onclick="set3DViewAngle('counter')" title="Counter-level view (eye height at countertop)">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M2 17h20M2 12h20M7 17v-5M17 17v-5"/>
              </svg>
              Counter
            </button>
            <button onclick="set3DViewAngle('corner')" title="Corner view (diagonal across room)">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M3 21L21 3M3 21h6M3 21v-6"/>
              </svg>
              Corner
            </button>
            <button onclick="toggleCabinetFocus()" title="Hide walls/windows to focus on cabinets" id="focusCabinetsBtn">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <rect x="4" y="10" width="6" height="10" rx="1"/>
                <rect x="14" y="10" width="6" height="10" rx="1"/>
                <path d="M4 8h16"/>
              </svg>
              Focus
            </button>
            <button onclick="toggleWalkthroughMode()" title="First-person walkthrough mode (WASD + mouse)" id="walkthroughBtn">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="12" cy="8" r="4"/>
                <path d="M12 12v8M8 16l4 4 4-4"/>
              </svg>
              Walk
            </button>
          </div>
          <div class="three-hint" id="threeHint">
            Left-drag: Rotate â€¢ Scroll: Zoom â€¢ Middle-drag: Pan
          </div>
          <div class="three-hint walkthrough-hint" id="walkthroughHint" style="display: none;">
            <strong>Walkthrough Mode:</strong> WASD to move â€¢ Mouse to look â€¢ Q/E for up/down â€¢ ESC to exit
          </div>
        </div>
      </div>

      <!-- Right Panel -->
      <aside class="right-panel">
        <!-- Element List - Click to Select -->
        <div class="panel-section" id="elementSelectorSection">
          <div class="panel-title" style="display: flex; justify-content: space-between; align-items: center;">
            <span>Elements on Canvas</span>
            <span class="element-total-count" id="elementTotalCount">0</span>
          </div>
          <div class="element-list-filter" style="margin-bottom: 8px;">
            <select class="input-field" id="elementListFilter" onchange="updateElementSelector()" style="font-size: 11px; padding: 4px 6px;">
              <option value="all">All Elements</option>
              <option value="cabinets">Cabinets</option>
              <option value="countertops">Countertops</option>
              <option value="appliances">Appliances</option>
              <option value="fixtures">Fixtures</option>
              <option value="other">Other</option>
            </select>
          </div>
          <div class="element-flat-list" id="elementFlatList" style="max-height: 250px; overflow-y: auto;">
            <!-- All elements listed here - click to select -->
          </div>
          <div class="element-selector-actions" id="elementSelectorActions" style="display: none; gap: 4px; margin-top: 8px;">
            <button class="btn-small btn-primary" onclick="focusSelectedElement()" title="Center view on element">Focus</button>
            <button class="btn-small btn-secondary" onclick="duplicateSelectedElement()" title="Duplicate element">Copy</button>
            <button class="btn-small btn-danger" onclick="deleteSelectedElement()" title="Delete element">Delete</button>
          </div>
        </div>

        <div class="panel-section">
          <div class="panel-title">Room Settings</div>
          <div class="room-grid">
            <div class="input-group">
              <label class="input-label">Room Type</label>
              <select class="input-field" id="roomType" onchange="updateRoom()">
                <option value="kitchen">Kitchen</option>
                <option value="bathroom">Bathroom</option>
                <option value="shower">Shower Room</option>
                <option value="closet">Walk-in Closet</option>
                <option value="laundry">Laundry</option>
                <option value="bedroom">Bedroom</option>
                <option value="living">Living Room</option>
                <option value="office">Office</option>
                <option value="commercial">Commercial</option>
              </select>
            </div>
            <div class="input-group">
              <label class="input-label">Width (ft)</label>
              <input type="number" class="input-field" id="roomWidth" value="20" min="8" max="100" onchange="updateRoom()">
            </div>
            <div class="input-group">
              <label class="input-label">Depth (ft)</label>
              <input type="number" class="input-field" id="roomDepth" value="16" min="8" max="100" onchange="updateRoom()">
            </div>
            <div class="input-group">
              <label class="input-label">Ceiling (ft)</label>
              <select class="input-field" id="roomHeight" onchange="updateRoomHeight()">
                <option value="8" selected>8' Standard</option>
                <option value="9">9' Raised</option>
                <option value="10">10' High</option>
                <option value="12">12' Vaulted</option>
              </select>
            </div>
            <div class="input-group">
              <label class="input-label">Scale</label>
              <select class="input-field" id="scaleMode" onchange="updateScale()">
                <option value="fit">Fit to Screen</option>
                <option value="40">40 px/ft</option>
                <option value="50">50 px/ft</option>
                <option value="60">60 px/ft</option>
              </select>
            </div>
          </div>
        </div>

        <!-- Room Templates -->
        <div class="panel-section">
          <div class="panel-title">Room Templates</div>
          <div class="room-templates-grid">
            <button class="template-btn" onclick="loadRoomTemplate('kitchen-l')" title="L-shaped kitchen with island">
              <span class="template-icon">ðŸ³</span>
              <span class="template-name">L-Kitchen</span>
            </button>
            <button class="template-btn" onclick="loadRoomTemplate('kitchen-galley')" title="Galley kitchen layout">
              <span class="template-icon">ðŸ </span>
              <span class="template-name">Galley</span>
            </button>
            <button class="template-btn" onclick="loadRoomTemplate('kitchen-u')" title="U-shaped kitchen">
              <span class="template-icon">ðŸ”²</span>
              <span class="template-name">U-Kitchen</span>
            </button>
            <button class="template-btn" onclick="loadRoomTemplate('bathroom-master')" title="Master bathroom with tub and shower">
              <span class="template-icon">ðŸ›</span>
              <span class="template-name">Master Bath</span>
            </button>
            <button class="template-btn" onclick="loadRoomTemplate('bathroom-half')" title="Half bathroom (powder room)">
              <span class="template-icon">ðŸš½</span>
              <span class="template-name">Half Bath</span>
            </button>
            <button class="template-btn" onclick="loadRoomTemplate('shower-walkin')" title="Walk-in shower with bench">
              <span class="template-icon">ðŸš¿</span>
              <span class="template-name">Walk-in Shower</span>
            </button>
            <button class="template-btn" onclick="loadRoomTemplate('closet-walkin')" title="Walk-in closet with shelving">
              <span class="template-icon">ðŸ‘”</span>
              <span class="template-name">Walk-in Closet</span>
            </button>
            <button class="template-btn" onclick="loadRoomTemplate('laundry-room')" title="Laundry room with cabinets">
              <span class="template-icon">ðŸ§º</span>
              <span class="template-name">Laundry</span>
            </button>
          </div>
          <p class="template-hint">Click a template to load preset room layout</p>
        </div>

        <!-- Cabinet Settings -->
        <div class="panel-section">
          <div class="panel-title">Cabinet Settings</div>
          <div class="room-grid">
            <div class="input-group">
              <label class="input-label">Construction</label>
              <select class="input-field" id="cabinetConstruction" onchange="updateCabinetSettings()">
                <option value="frameless">Frameless (Euro)</option>
                <option value="framed">Framed (Face Frame)</option>
              </select>
            </div>
            <div class="input-group">
              <label class="input-label">Door Style</label>
              <select class="input-field" id="doorStyle" onchange="updateCabinetSettings()">
                <option value="shaker">Shaker</option>
                <option value="flat">Flat Panel</option>
                <option value="raised">Raised Panel</option>
                <option value="slab">Slab (No Detail)</option>
              </select>
            </div>
            <div class="input-group">
              <label class="input-label">Door Overlay</label>
              <select class="input-field" id="doorOverlay" onchange="updateCabinetSettings()">
                <option value="full">Full Overlay</option>
                <option value="partial">Partial Overlay</option>
                <option value="inset">Inset</option>
              </select>
            </div>
            <div class="input-group">
              <label class="input-label">Floor Level</label>
              <select class="input-field" id="floorLevel" onchange="updateFloorLevel()">
                <option value="1">Floor 1</option>
                <option value="2">Floor 2</option>
                <option value="3">Floor 3</option>
                <option value="add">+ Add Floor</option>
              </select>
            </div>
          </div>
        </div>

        <!-- Scene Settings -->
        <div class="panel-section">
          <div class="panel-title">Scene Settings</div>
          <div class="room-grid">
            <div class="input-group">
              <label class="input-label">Time of Day</label>
              <select class="input-field" id="timeOfDay" onchange="updateTimeOfDay()">
                <option value="morning">Morning (Sunrise)</option>
                <option value="noon" selected>Noon (Daylight)</option>
                <option value="evening">Evening (Sunset)</option>
                <option value="night">Night</option>
              </select>
            </div>
          </div>
        </div>

        <!-- Item Picker / Quote List -->
        <div class="panel-section" id="itemPickerSection">
          <div class="panel-title" style="display: flex; align-items: center; justify-content: space-between;">
            <span>Item List</span>
            <span class="item-picker-total" id="itemPickerTotal">$0.00</span>
          </div>
          <div class="item-picker-controls">
            <select class="input-field item-filter" id="itemFilterType" onchange="filterItemList()">
              <option value="all">All Items</option>
              <option value="cabinets">Cabinets</option>
              <option value="countertops">Countertops</option>
              <option value="appliances">Appliances</option>
              <option value="sinks">Sinks</option>
              <option value="flooring">Flooring</option>
              <option value="fixtures">Fixtures</option>
              <option value="other">Other</option>
            </select>
          </div>
          <div class="item-picker-list" id="itemPickerList">
            <!-- Populated by JavaScript -->
          </div>
          <div class="item-picker-summary" id="itemPickerSummary">
            <div id="itemCategorySummary">
              <!-- Category breakdown populated by JS -->
            </div>
            <div class="summary-row" style="margin-top: 8px; padding-top: 8px; border-top: 1px solid var(--border);">
              <span>Items:</span>
              <span id="itemCount">0</span>
            </div>
            <div class="summary-row" style="font-size: 13px;">
              <span><strong>Total:</strong></span>
              <span id="itemSubtotal" style="color: #22c55e; font-weight: 700;">$0.00</span>
            </div>
          </div>
          <div class="item-picker-actions">
            <button class="btn-small btn-secondary" onclick="selectAllItems()">Select All</button>
            <button class="btn-small btn-secondary" onclick="deselectAllItems()">Deselect</button>
            <button class="btn-small btn-danger" onclick="deleteSelectedItems()">Delete</button>
          </div>
        </div>

        <!-- Hidden element list for compatibility -->
        <div id="elementLayerList" style="display: none;"></div>
        <span id="elementCountDisplay" style="display: none;">0</span>

        <div class="panel-section" id="propertiesPanel">
          <div class="panel-title">Properties</div>
          <div class="properties-empty" id="propertiesEmpty">
            Select an element to edit
          </div>
          <div id="propertiesContent" style="display: none;">
            <!-- Quick Actions Toolbar -->
            <div class="quick-actions" style="display: flex; gap: 4px; margin-bottom: 12px; padding-bottom: 12px; border-bottom: 1px solid var(--border-color);">
              <button class="quick-btn" onclick="duplicateSelectedElement()" title="Duplicate (Ctrl+D)">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="16" height="16">
                  <rect x="9" y="9" width="13" height="13" rx="2"/>
                  <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/>
                </svg>
              </button>
              <button class="quick-btn" onclick="rotateSelectedElement(90)" title="Rotate 90Â° (R)">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="16" height="16">
                  <path d="M21 12a9 9 0 1 1-9-9c2.52 0 4.93 1 6.74 2.74L21 8"/>
                  <path d="M21 3v5h-5"/>
                </svg>
              </button>
              <button class="quick-btn" onclick="rotateSelectedElement(180)" title="Rotate 180Â°">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="16" height="16">
                  <path d="M21 12a9 9 0 0 1-9 9 9 9 0 0 1-9-9"/>
                  <path d="M3 12a9 9 0 0 1 9-9 9 9 0 0 1 9 9"/>
                  <path d="M16 16l2 2 2-2"/>
                  <path d="M8 8l-2-2-2 2"/>
                </svg>
              </button>
              <button class="quick-btn" onclick="flipSelectedElement('h')" title="Flip Horizontal">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="16" height="16">
                  <path d="M8 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h3"/>
                  <path d="M16 3h3a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2h-3"/>
                  <line x1="12" y1="3" x2="12" y2="21"/>
                </svg>
              </button>
              <button class="quick-btn" onclick="bringToFront()" title="Bring to Front">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="16" height="16">
                  <rect x="8" y="8" width="12" height="12" rx="2" fill="currentColor" opacity="0.3"/>
                  <rect x="4" y="4" width="12" height="12" rx="2"/>
                </svg>
              </button>
              <button class="quick-btn" onclick="sendToBack()" title="Send to Back">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="16" height="16">
                  <rect x="4" y="4" width="12" height="12" rx="2" fill="currentColor" opacity="0.3"/>
                  <rect x="8" y="8" width="12" height="12" rx="2"/>
                </svg>
              </button>
              <button class="quick-btn danger" onclick="deleteSelectedElement()" title="Delete (Del)">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="16" height="16">
                  <path d="M3 6h18"/>
                  <path d="M8 6V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/>
                  <path d="M19 6l-1 14a2 2 0 0 1-2 2H8a2 2 0 0 1-2-2L5 6"/>
                </svg>
              </button>
            </div>
            <div class="property-row">
              <span class="property-label">Type</span>
              <span class="property-value" id="propType">-</span>
            </div>
            <div class="property-row">
              <span class="property-label">Width</span>
              <input type="text" class="property-input" id="propWidth" placeholder="e.g. 3'-6&quot; or 2.5" onchange="updateSelectedElement()" title="Enter feet-inches (3'-6&quot;) or decimal feet (2.5)">
              <span class="dimension-display" id="propWidthDisplay"></span>
            </div>
            <div class="property-row">
              <span class="property-label">Depth</span>
              <input type="text" class="property-input" id="propHeight" placeholder="e.g. 2'-0&quot; or 2" onchange="updateSelectedElement()" title="Enter feet-inches (2'-0&quot;) or decimal feet (2)">
              <span class="dimension-display" id="propHeightDisplay"></span>
            </div>
            <div class="property-row" id="standardSizeRow" style="display: none;">
              <span class="property-label">Standard</span>
              <select class="property-select" id="propStandardSize" onchange="applyStandardSize()">
                <option value="">Custom</option>
              </select>
            </div>
            <!-- Window/Door height from floor -->
            <div class="property-row" id="sillHeightRow" style="display: none;">
              <span class="property-label">Sill Height</span>
              <div style="display: flex; align-items: center; gap: 8px;">
                <select class="property-select" id="propSillHeight" onchange="updateSillHeight()" style="flex: 1;">
                  <option value="0">0" - Floor Level (Doors)</option>
                  <option value="2">24" - Standard Window</option>
                  <option value="3">36" - At Counter Level</option>
                  <option value="3.5">42" - Above Counter</option>
                  <option value="4">48" - High Window</option>
                  <option value="custom">Custom...</option>
                </select>
              </div>
            </div>
            <div class="property-row" id="customSillRow" style="display: none;">
              <span class="property-label">Custom (ft)</span>
              <input type="number" class="property-input" id="propCustomSill" step="0.0833" min="0" max="8" onchange="applyCustomSillHeight()">
            </div>
            <!-- Door/Archway height controls -->
            <div class="property-row" id="doorHeightRow" style="display: none;">
              <span class="property-label">Opening Height</span>
              <div style="display: flex; align-items: center; gap: 8px;">
                <select class="property-select" id="propDoorHeight" onchange="updateDoorHeight()" style="flex: 1;">
                  <option value="6.67">80" - Standard Door</option>
                  <option value="6.83">82" - Standard+</option>
                  <option value="7">84" - 7 Foot</option>
                  <option value="8">96" - 8 Foot</option>
                  <option value="9">108" - 9 Foot</option>
                  <option value="10">120" - 10 Foot</option>
                  <option value="custom">Custom...</option>
                </select>
              </div>
            </div>
            <div class="property-row" id="customDoorHeightRow" style="display: none;">
              <span class="property-label">Height (ft)</span>
              <input type="number" class="property-input" id="propCustomDoorHeight" step="0.0833" min="5" max="12" onchange="applyCustomDoorHeight()">
              <span class="dimension-display" id="propDoorHeightDisplay"></span>
            </div>
            <!-- Archway style controls -->
            <div class="property-row" id="archwayStyleRow" style="display: none;">
              <span class="property-label">Arch Style</span>
              <select class="property-select" id="propArchwayStyle" onchange="updateArchwayStyle()">
                <option value="round">Round Arch</option>
                <option value="pointed">Pointed/Gothic</option>
                <option value="flat">Flat Top (Cased Opening)</option>
                <option value="elliptical">Elliptical</option>
              </select>
            </div>
            <!-- Window Style controls -->
            <div class="property-row" id="windowStyleRow" style="display: none;">
              <span class="property-label">Window Style</span>
              <select class="property-select" id="propWindowStyle" onchange="updateWindowStyle()">
                <option value="double-hung">Double-Hung</option>
                <option value="single-hung">Single-Hung</option>
                <option value="casement">Casement</option>
                <option value="sliding">Sliding</option>
                <option value="fixed">Fixed/Picture</option>
              </select>
            </div>
            <div class="property-row" id="mullionPatternRow" style="display: none;">
              <span class="property-label">Mullion Pattern</span>
              <select class="property-select" id="propMullionPattern" onchange="updateMullionPattern()">
                <option value="standard">Standard Cross</option>
                <option value="colonial">Colonial Grid</option>
                <option value="prairie">Prairie Style</option>
                <option value="none">No Grilles</option>
              </select>
            </div>
            <!-- Pony Wall / Half Wall height controls -->
            <div class="property-row" id="wallHeightRow" style="display: none;">
              <span class="property-label">Wall Height</span>
              <div style="display: flex; align-items: center; gap: 8px;">
                <select class="property-select" id="propWallHeight" onchange="updateWallHeight()" style="flex: 1;">
                  <option value="2">24" - Knee Wall</option>
                  <option value="2.5">30" - Low Pony</option>
                  <option value="3">36" - Counter Height</option>
                  <option value="3.5">42" - Standard Pony</option>
                  <option value="4">48" - Bar Height</option>
                  <option value="custom">Custom...</option>
                </select>
              </div>
            </div>
            <div class="property-row" id="customWallHeightRow" style="display: none;">
              <span class="property-label">Height (ft)</span>
              <input type="number" class="property-input" id="propCustomWallHeight" step="0.0833" min="1" max="8" onchange="applyCustomWallHeight()">
              <span class="dimension-display" id="propWallHeightDisplay"></span>
            </div>
            <!-- Full-height wall controls (masonry, concrete, etc.) -->
            <div class="property-row" id="fullWallHeightRow" style="display: none;">
              <span class="property-label">Wall Height</span>
              <div style="display: flex; align-items: center; gap: 8px;">
                <select class="property-select" id="propFullWallHeight" onchange="updateFullWallHeight()" style="flex: 1;">
                  <option value="ceiling">To Ceiling</option>
                  <option value="8">8' (96")</option>
                  <option value="9">9' (108")</option>
                  <option value="10">10' (120")</option>
                  <option value="12">12' (144")</option>
                  <option value="14">14' (168")</option>
                  <option value="16">16' (192")</option>
                  <option value="custom">Custom...</option>
                </select>
              </div>
            </div>
            <div class="property-row" id="customFullWallHeightRow" style="display: none;">
              <span class="property-label">Height (ft)</span>
              <div class="dimension-input-group">
                <input type="text" class="property-input dimension-input" id="propCustomFullWallHeight" placeholder="8" onchange="applyCustomFullWallHeight()">
                <span class="dimension-display" id="propFullWallHeightDisplay"></span>
              </div>
            </div>
            <div class="property-row" id="wallThicknessRow" style="display: none;">
              <span class="property-label">Wall Thickness</span>
              <div style="display: flex; align-items: center; gap: 8px;">
                <select class="property-select" id="propWallThickness" onchange="updateWallThickness()" style="flex: 1;">
                  <option value="0.33">4" (2x4 stud)</option>
                  <option value="0.5">6" (2x6 stud)</option>
                  <option value="0.67">8" (CMU block)</option>
                  <option value="0.83">10" (Double CMU)</option>
                  <option value="1">12" (Concrete)</option>
                  <option value="1.33">16" (Heavy)</option>
                  <option value="custom">Custom...</option>
                </select>
              </div>
            </div>
            <div class="property-row" id="customWallThicknessRow" style="display: none;">
              <span class="property-label">Thickness (ft)</span>
              <div class="dimension-input-group">
                <input type="text" class="property-input dimension-input" id="propCustomWallThickness" placeholder="0.5" onchange="applyCustomWallThickness()">
                <span class="dimension-display" id="propWallThicknessDisplay"></span>
              </div>
            </div>
            <!-- Niche depth controls -->
            <div class="property-row" id="nicheDepthRow" style="display: none;">
              <span class="property-label">Recess Depth</span>
              <div style="display: flex; align-items: center; gap: 8px;">
                <select class="property-select" id="propNicheDepth" onchange="updateNicheDepth()" style="flex: 1;">
                  <option value="0.25">3" - Shallow</option>
                  <option value="0.33">4" - Standard</option>
                  <option value="0.5">6" - Deep</option>
                  <option value="0.67">8" - TV Recess</option>
                  <option value="1">12" - Fireplace</option>
                  <option value="1.5">18" - Deep Fireplace</option>
                  <option value="custom">Custom...</option>
                </select>
              </div>
            </div>
            <div class="property-row" id="customNicheDepthRow" style="display: none;">
              <span class="property-label">Depth (ft)</span>
              <input type="number" class="property-input" id="propCustomNicheDepth" step="0.0833" min="0.1" max="3" onchange="applyCustomNicheDepth()">
              <span class="dimension-display" id="propNicheDepthDisplay"></span>
            </div>
            <!-- Stone surface thickness controls -->
            <div class="property-row" id="stoneThicknessRow" style="display: none;">
              <span class="property-label">Stone Thickness</span>
              <div style="display: flex; align-items: center; gap: 8px;">
                <select class="property-select" id="propStoneThickness" onchange="updateStoneThickness()" style="flex: 1;">
                  <option value="0.0625">3/4" (2cm)</option>
                  <option value="0.1">1.25" (3cm)</option>
                  <option value="0.125">1.5"</option>
                  <option value="0.17">2"</option>
                  <option value="0.25">3"</option>
                </select>
              </div>
            </div>
            <!-- Cap height control for wall caps/bar tops -->
            <div class="property-row" id="capHeightRow" style="display: none;">
              <span class="property-label">Cap Height</span>
              <div style="display: flex; align-items: center; gap: 8px;">
                <select class="property-select" id="propCapHeight" onchange="updateCapHeight()" style="flex: 1;">
                  <option value="2">2' (24") - Knee wall</option>
                  <option value="2.5">2.5' (30")</option>
                  <option value="3">3' (36") - Standard counter</option>
                  <option value="3.5">3.5' (42") - Pony wall</option>
                  <option value="4">4' (48") - Bar height</option>
                  <option value="custom">Custom...</option>
                </select>
              </div>
            </div>
            <div class="property-row" id="customCapHeightRow" style="display: none;">
              <span class="property-label">Height (ft)</span>
              <input type="number" class="property-input" id="propCustomCapHeight" step="0.0833" min="0.5" max="8" onchange="applyCustomCapHeight()">
              <span class="dimension-display" id="propCapHeightDisplay"></span>
            </div>
            <!-- Edge preview button -->
            <div class="property-row" id="edgePreviewBtnRow" style="display: none;">
              <button class="btn btn-secondary" style="width: 100%; padding: 8px;" onclick="showEdgePreviewModal(selectedElement)">
                View Edge Profile 3D
              </button>
            </div>
            <div class="property-row" id="edgeProfileRow" style="display: none;">
              <span class="property-label">Edge Profile</span>
              <select class="property-select" id="propEdgeProfile" onchange="updateEdgeProfile()">
                <option value="eased">Eased (Standard)</option>
                <option value="pencil">Pencil Round</option>
                <option value="quarter-round">Quarter Round</option>
                <option value="quarter-bevel">Quarter Bevel</option>
                <option value="half-bullnose">Half Bullnose</option>
                <option value="full-bullnose">Full Bullnose</option>
                <option value="ogee">Ogee (+$25/LF)</option>
                <option value="double-ogee">Double Ogee (+$35/LF)</option>
                <option value="cove">Cove (+$20/LF)</option>
                <option value="dupont">Dupont (+$30/LF)</option>
                <option value="mitered">Mitered (+$15/LF)</option>
                <option value="waterfall">Waterfall (+$50/LF)</option>
              </select>
            </div>
            <div class="property-row" id="thicknessRow" style="display: none;">
              <span class="property-label">Slab Thickness</span>
              <select class="property-select" id="propThickness" onchange="updateCountertopThickness()">
                <option value="3cm">3cm (1.25") - Standard</option>
                <option value="2cm">2cm (0.75") - Requires Edge Buildup</option>
              </select>
            </div>
            <div class="property-row" id="edgeStyleRow" style="display: none;">
              <span class="property-label">Edge Buildup (2cm)</span>
              <select class="property-select" id="propEdgeStyle" onchange="updateCountertopThickness()">
                <option value="laminated">Laminated (4cm look)</option>
                <option value="mitered">Mitered (45Â° seam)</option>
                <option value="stacked">Stacked (vertical seam)</option>
              </select>
            </div>
            <!-- Waterfall edge configuration -->
            <div class="property-row" id="waterfallRow" style="display: none;">
              <span class="property-label">Waterfall Sides</span>
              <div class="checkbox-group" style="flex-wrap: wrap;">
                <label><input type="checkbox" id="propWaterfallLeft" onchange="updateWaterfallSides()"> Left</label>
                <label><input type="checkbox" id="propWaterfallRight" onchange="updateWaterfallSides()"> Right</label>
                <label><input type="checkbox" id="propWaterfallFront" onchange="updateWaterfallSides()"> Front</label>
                <label><input type="checkbox" id="propWaterfallBack" onchange="updateWaterfallSides()"> Back</label>
              </div>
            </div>
            <div class="property-row" id="waterfallHeightRow" style="display: none;">
              <span class="property-label">Waterfall Drop</span>
              <select class="property-select" id="propWaterfallHeight" onchange="updateWaterfallHeight()">
                <option value="2.5">2.5' (30") - Counter height</option>
                <option value="2.9">2.9' (35") - Cabinet height</option>
                <option value="3">3' (36") - Island height</option>
                <option value="floor">To Floor</option>
                <option value="custom">Custom...</option>
              </select>
            </div>
            <div class="property-row" id="backsplashRow" style="display: none;">
              <span class="property-label">Backsplash</span>
              <select class="property-select" id="propBacksplash" onchange="updateBacksplash()">
                <option value="none">None</option>
                <option value="4">4" Standard</option>
                <option value="6">6" Raised</option>
                <option value="18">18" Mid-Height</option>
                <option value="full">Full Height</option>
              </select>
            </div>
            <div class="property-row" id="finishedEndsRow" style="display: none;">
              <span class="property-label">Finished Ends</span>
              <div class="checkbox-group">
                <label><input type="checkbox" id="propFinishedLeft" onchange="updateFinishedEnds()"> Left</label>
                <label><input type="checkbox" id="propFinishedRight" onchange="updateFinishedEnds()"> Right</label>
              </div>
            </div>
            <div class="property-row" id="seamsRow" style="display: none;">
              <span class="property-label">Seams</span>
              <div class="seam-controls">
                <button class="seam-btn" onclick="addSeamToCountertop()" title="Add seam at countertop center">+ Add Seam</button>
                <span class="seam-count" id="seamCount">0 seams</span>
                <button class="seam-btn seam-clear" onclick="clearSeams()" title="Remove all seams">Clear</button>
              </div>
            </div>
            <!-- Sink-specific properties -->
            <div class="property-row" id="sinkColorRow" style="display: none;">
              <span class="property-label">Sink Finish</span>
              <select class="property-select" id="propSinkColor" onchange="updateSinkProperties()">
                <option value="stainless">Stainless Steel</option>
                <option value="black">Matte Black</option>
                <option value="white">White</option>
                <option value="graphite">Graphite</option>
                <option value="bisque">Bisque</option>
                <option value="bronze">Oil-Rubbed Bronze</option>
              </select>
            </div>
            <div class="property-row" id="sinkMountRow" style="display: none;">
              <span class="property-label">Mount Type</span>
              <select class="property-select" id="propSinkMount" onchange="updateSinkProperties()">
                <option value="undermount">Undermount</option>
                <option value="topmount">Top Mount</option>
                <option value="farmhouse">Farmhouse/Apron</option>
              </select>
            </div>
            <div class="property-row">
              <span class="property-label">Color</span>
              <input type="color" class="color-picker" id="propColor" onchange="updateSelectedElement()">
            </div>
            <div class="property-row">
              <span class="property-label">Texture</span>
              <div class="texture-controls">
                <div class="texture-preview" id="propTexture" onclick="openMaterialPicker()" title="Click to browse materials"></div>
                <button class="texture-upload-btn" onclick="quickUploadTexture()" title="Upload custom image">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                    <polyline points="17 8 12 3 7 8"/>
                    <line x1="12" y1="3" x2="12" y2="15"/>
                  </svg>
                </button>
                <button class="texture-clear-btn" onclick="clearTexture()" title="Clear texture">âœ•</button>
              </div>
            </div>
            <div class="property-row">
              <span class="property-label">Rotation</span>
              <span class="property-value" id="propRotation">0Â°</span>
            </div>
            <div class="property-row" id="grainDirectionRow" style="display: none;">
              <span class="property-label">Grain/Tile Dir</span>
              <div class="grain-direction-controls">
                <button class="grain-btn" data-dir="0" onclick="setGrainDirection(0)" title="Horizontal (â†’)">â†’</button>
                <button class="grain-btn" data-dir="90" onclick="setGrainDirection(90)" title="Vertical (â†“)">â†“</button>
                <button class="grain-btn" data-dir="45" onclick="setGrainDirection(45)" title="Diagonal (â†˜)">â†˜</button>
                <button class="grain-btn" data-dir="135" onclick="setGrainDirection(135)" title="Diagonal (â†™)">â†™</button>
              </div>
            </div>

            <!-- Structural Element Controls -->
            <div class="property-row" id="beamDepthRow" style="display: none;">
              <span class="property-label">Beam Depth</span>
              <select class="property-select" id="propBeamDepth" onchange="updateBeamDepth()">
                <option value="0.33">4" (Header)</option>
                <option value="0.5">6" (W6)</option>
                <option value="0.67">8" (W8)</option>
                <option value="0.83">10" (W10)</option>
                <option value="1">12" (W12)</option>
                <option value="1.17">14" (W14)</option>
                <option value="custom">Custom...</option>
              </select>
            </div>
            <div class="property-row" id="customBeamDepthRow" style="display: none;">
              <span class="property-label">Custom Depth</span>
              <div class="dimension-input-group">
                <input type="text" class="property-input dimension-input" id="propCustomBeamDepth" placeholder="0.67" onchange="applyCustomBeamDepth()">
                <span class="dimension-display" id="propBeamDepthDisplay"></span>
              </div>
            </div>
            <div class="property-row" id="beamElevationRow" style="display: none;">
              <span class="property-label">Elevation</span>
              <select class="property-select" id="propBeamElevation" onchange="updateBeamElevation()">
                <option value="ceiling">At Ceiling</option>
                <option value="7">7' (84")</option>
                <option value="7.5">7'-6" (90")</option>
                <option value="8">8' (96")</option>
                <option value="9">9' (108")</option>
                <option value="10">10' (120")</option>
                <option value="custom">Custom...</option>
              </select>
            </div>
            <div class="property-row" id="customBeamElevationRow" style="display: none;">
              <span class="property-label">Custom Elev</span>
              <div class="dimension-input-group">
                <input type="text" class="property-input dimension-input" id="propCustomBeamElevation" placeholder="8" onchange="applyCustomBeamElevation()">
                <span class="dimension-display" id="propBeamElevationDisplay"></span>
              </div>
            </div>
            <div class="property-row" id="columnHeightRow" style="display: none;">
              <span class="property-label">Column Height</span>
              <select class="property-select" id="propColumnHeight" onchange="updateColumnHeight()">
                <option value="ceiling">Floor to Ceiling</option>
                <option value="8">8' (96")</option>
                <option value="9">9' (108")</option>
                <option value="10">10' (120")</option>
                <option value="12">12' (144")</option>
                <option value="custom">Custom...</option>
              </select>
            </div>
            <div class="property-row" id="customColumnHeightRow" style="display: none;">
              <span class="property-label">Custom Height</span>
              <div class="dimension-input-group">
                <input type="text" class="property-input dimension-input" id="propCustomColumnHeight" placeholder="8" onchange="applyCustomColumnHeight()">
                <span class="dimension-display" id="propColumnHeightDisplay"></span>
              </div>
            </div>
            <div class="property-row" id="columnSizeRow" style="display: none;">
              <span class="property-label">Column Size</span>
              <select class="property-select" id="propColumnSize" onchange="updateColumnSize()">
                <option value="0.33">4"Ã—4" (Post)</option>
                <option value="0.5">6"Ã—6" (HSS 6)</option>
                <option value="0.67">8"Ã—8" (HSS 8)</option>
                <option value="1">12"Ã—12" (Concrete)</option>
                <option value="1.33">16"Ã—16" (Large)</option>
                <option value="custom">Custom...</option>
              </select>
            </div>

            <!-- Pricing Section -->
            <div class="pricing-section" id="pricingSection">
              <div class="property-section-title">Pricing</div>
              <div class="property-row">
                <span class="property-label">Base Price</span>
                <span class="property-value" id="propBasePrice">$0.00</span>
              </div>
              <div class="property-row">
                <span class="property-label">Override</span>
                <div class="price-override-group">
                  <input type="number" class="property-input price-input" id="propPriceOverride" placeholder="Auto" step="0.01" min="0" onchange="updateElementPrice()">
                  <select class="property-select-sm" id="propPriceUnit" onchange="updateElementPrice()">
                    <option value="sqft">/sqft</option>
                    <option value="linear_ft">/lf</option>
                    <option value="unit">each</option>
                  </select>
                </div>
              </div>
              <div class="property-row">
                <span class="property-label">Margin %</span>
                <input type="number" class="property-input margin-input" id="propMargin" placeholder="Default" step="1" min="0" max="200" onchange="updateElementPrice()">
              </div>
              <div class="property-row price-result">
                <span class="property-label">Item Total</span>
                <span class="property-value price-highlight" id="propItemTotal">$0.00</span>
              </div>
            </div>
          </div>
        </div>

        <!-- Building Code Validation -->
        <div class="validation-section" id="validationPanel">
          <div class="panel-section">
            <div class="panel-title">
              Building Standards
              <button class="validation-toggle" onclick="toggleWorkTriangle()" title="Toggle work triangle">â–³</button>
              <button class="validation-refresh" onclick="runValidation()" title="Check design">âœ“</button>
            </div>
          </div>
          <div class="validation-content" id="validationContent">
            <div class="validation-hint">Click âœ“ to validate your design</div>
          </div>
        </div>

        <div class="quote-section" id="quotePanel">
          <div class="panel-section">
            <div class="quote-header">
              <div class="panel-title">Quote Summary</div>
              <div class="quote-view-toggle">
                <button class="toggle-btn active" id="retailViewBtn" onclick="setQuoteView('retail')" title="Show retail prices">Retail</button>
                <button class="toggle-btn" id="costViewBtn" onclick="setQuoteView('cost')" title="Show cost prices">Cost</button>
              </div>
            </div>
          </div>
          <div class="quote-actions">
            <button class="btn btn-sm btn-secondary" onclick="openPriceListModal()" title="Upload or manage price lists">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:14px;height:14px;margin-right:4px;">
                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                <polyline points="17 8 12 3 7 8"/>
                <line x1="12" y1="3" x2="12" y2="15"/>
              </svg>
              Price List
            </button>
            <button class="btn btn-sm btn-secondary" onclick="openMarginModal()" title="Configure profit margins">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:14px;height:14px;margin-right:4px;">
                <line x1="19" y1="5" x2="5" y2="19"/>
                <circle cx="6.5" cy="6.5" r="2.5"/>
                <circle cx="17.5" cy="17.5" r="2.5"/>
              </svg>
              Margins
            </button>
          </div>
          <div class="quote-items" id="quoteItems">
            <div class="quote-item">
              <span class="quote-item-name">No items yet</span>
              <span class="quote-item-value">$0</span>
            </div>
          </div>
          <div class="quote-summary">
            <div class="quote-row" id="quoteCostRow" style="display: none;">
              <span>Material Cost</span>
              <span id="quoteCost">$0.00</span>
            </div>
            <div class="quote-row" id="quoteMarginRow" style="display: none;">
              <span>Markup</span>
              <span id="quoteMargin">$0.00</span>
            </div>
            <div class="quote-total">
              <div class="quote-total-row">
                <span class="quote-total-label">Estimated Total</span>
                <span class="quote-total-value" id="quoteTotal">$0</span>
              </div>
            </div>
            <!-- Payment Actions -->
            <div class="quote-actions" id="quoteActions" style="margin-top: 12px; display: none;">
              <button class="btn-checkout" onclick="openPaymentModal()" id="checkoutBtn">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:16px;height:16px;margin-right:6px;">
                  <rect x="1" y="4" width="22" height="16" rx="2"/><line x1="1" y1="10" x2="23" y2="10"/>
                </svg>
                Pay Deposit & Schedule
              </button>
              <p class="quote-disclaimer">10% deposit required to schedule consultation</p>
            </div>
          </div>
        </div>
      </aside>
    </main>
  </div>

  <!-- Payment Modal -->
  <div class="payment-modal-overlay" id="paymentModal" style="display: none;">
    <div class="payment-modal">
      <div class="payment-modal-header">
        <h2>Complete Your Order</h2>
        <button class="payment-modal-close" onclick="closePaymentModal()">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="20" height="20">
            <line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/>
          </svg>
        </button>
      </div>
      <div class="payment-modal-body">
        <!-- Design Summary -->
        <div class="payment-summary">
          <div class="payment-summary-row">
            <span class="label">Design Name</span>
            <span class="value" id="paymentDesignName">Kitchen Design</span>
          </div>
          <div class="payment-summary-row">
            <span class="label">Countertop Material</span>
            <span class="value" id="paymentMaterial">-</span>
          </div>
          <div class="payment-summary-row">
            <span class="label">Square Footage</span>
            <span class="value" id="paymentSqft">0 sq ft</span>
          </div>
          <div class="payment-summary-row total">
            <span class="label">Project Estimate</span>
            <span class="value" id="paymentTotal">$0</span>
          </div>
        </div>

        <!-- Payment Options -->
        <div class="payment-options">
          <div class="payment-option selected" onclick="selectPaymentOption('deposit')" id="optionDeposit">
            <div class="payment-option-header">
              <span class="payment-option-title">10% Deposit</span>
              <span class="payment-option-amount" id="depositAmount">$0</span>
            </div>
            <p class="payment-option-desc">Reserve your consultation and lock in pricing. Remainder due at installation.</p>
          </div>
          <div class="payment-option" onclick="selectPaymentOption('consultation')" id="optionConsultation">
            <div class="payment-option-header">
              <span class="payment-option-title">Design Consultation</span>
              <span class="payment-option-amount">$99</span>
            </div>
            <p class="payment-option-desc">1-hour in-home or virtual consultation with our design expert. Applied to project if you proceed.</p>
          </div>
          <div class="payment-option" onclick="selectPaymentOption('full')" id="optionFull">
            <div class="payment-option-header">
              <span class="payment-option-title">Full Payment</span>
              <span class="payment-option-amount" id="fullAmount">$0</span>
            </div>
            <p class="payment-option-desc">Pay in full and receive 5% discount. Fastest scheduling priority.</p>
          </div>
        </div>

        <!-- Contact Info -->
        <div class="payment-form-group">
          <label>Email Address</label>
          <input type="email" id="paymentEmail" placeholder="you@example.com" required>
        </div>
        <div class="payment-form-group">
          <label>Phone Number</label>
          <input type="tel" id="paymentPhone" placeholder="(555) 123-4567">
        </div>

        <!-- Submit -->
        <button class="payment-submit" onclick="processPayment()" id="paymentSubmitBtn">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="18" height="18">
            <rect x="1" y="4" width="22" height="16" rx="2"/><line x1="1" y1="10" x2="23" y2="10"/>
          </svg>
          <span id="paymentBtnText">Pay Deposit & Continue</span>
        </button>

        <div class="payment-secure">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <rect x="3" y="11" width="18" height="11" rx="2"/><path d="M7 11V7a5 5 0 0 1 10 0v4"/>
          </svg>
          Secured by Stripe â€¢ 256-bit encryption
        </div>
      </div>
    </div>
  </div>

  <!-- Context Menu -->
  <div class="context-menu" id="contextMenu" style="display: none;">
    <div class="context-menu-label" id="contextMenuLabel">Element</div>
    <div class="context-menu-item" onclick="contextAction('rotate')">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <path d="M21 2v6h-6"/><path d="M3 12a9 9 0 0 1 15-6.7L21 8"/>
      </svg>
      Rotate 90Â°
    </div>
    <div class="context-menu-item" onclick="contextAction('duplicate')">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <rect x="9" y="9" width="13" height="13" rx="2"/><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/>
      </svg>
      Duplicate
    </div>
    <div class="context-menu-item" onclick="contextAction('texture')">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <rect x="3" y="3" width="18" height="18" rx="2"/><circle cx="8.5" cy="8.5" r="1.5"/><path d="M21 15l-5-5L5 21"/>
      </svg>
      Change Texture
    </div>
    <div class="context-menu-item" onclick="contextAction('lock')">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <rect x="3" y="11" width="18" height="11" rx="2"/><path d="M7 11V7a5 5 0 0 1 10 0v4"/>
      </svg>
      <span id="lockText">Lock</span>
    </div>
    <div class="context-menu-divider"></div>
    <div class="context-menu-item" onclick="contextAction('front')">Bring to Front</div>
    <div class="context-menu-item" onclick="contextAction('back')">Send to Back</div>
    <div class="context-menu-divider"></div>
    <div class="context-menu-item danger" onclick="contextAction('delete')">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/>
      </svg>
      Delete
    </div>
  </div>

  <!-- 3D Tooltip -->
  <div id="tooltip3D" style="display: none; position: fixed; background: rgba(0,0,0,0.85); color: white; padding: 8px 12px; border-radius: 6px; font-size: 12px; pointer-events: none; z-index: 10000; max-width: 200px; box-shadow: 0 2px 10px rgba(0,0,0,0.3);">
    <div id="tooltip3DLabel" style="font-weight: bold; margin-bottom: 4px;"></div>
    <div id="tooltip3DSize" style="color: #ccc; font-size: 11px;"></div>
  </div>

  <!-- Share Modal - Enhanced -->
  <div class="modal-overlay" id="shareModal">
    <div class="modal" style="max-width: 500px;">
      <div class="modal-header">
        <h3 class="modal-title">Share Project</h3>
        <button class="modal-close" onclick="closeModal('shareModal')">Ã—</button>
      </div>

      <div class="share-status" id="shareStatus">
        <span class="status-indicator"></span>
        <span id="shareStatusText">Not shared yet</span>
      </div>

      <div class="share-link-box">
        <input type="text" class="share-link-input" id="shareLink" readonly placeholder="Generate a share link...">
        <button class="btn btn-secondary" id="copyShareBtn" onclick="copyShareLink()" disabled>Copy</button>
      </div>

      <div class="permission-section">
        <h4>Permission Level</h4>
        <div class="permission-options">
          <div class="permission-btn active" data-permission="quote_approval" onclick="setSharePermission('quote_approval', this)">
            <div class="permission-icon" style="background: linear-gradient(135deg, #22c55e, #16a34a);">
              <svg viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2">
                <path d="M9 12l2 2 4-4"/>
                <rect x="3" y="4" width="18" height="16" rx="2"/>
                <path d="M3 10h18"/>
              </svg>
            </div>
            <div class="permission-info">
              <div class="permission-btn-title">Send for Approval</div>
              <div class="permission-btn-desc">Customer reviews quote & pays to approve</div>
            </div>
          </div>

          <div class="permission-btn" data-permission="full_collab" onclick="setSharePermission('full_collab', this)">
            <div class="permission-icon">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/>
                <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/>
              </svg>
            </div>
            <div class="permission-info">
              <div class="permission-btn-title">Full Collaboration</div>
              <div class="permission-btn-desc">Can edit everything including prices</div>
            </div>
          </div>

          <div class="permission-btn" data-permission="quote_view" onclick="setSharePermission('quote_view', this)">
            <div class="permission-icon">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="12" cy="12" r="3"/>
                <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/>
              </svg>
            </div>
            <div class="permission-info">
              <div class="permission-btn-title">Quote View</div>
              <div class="permission-btn-desc">See prices, cannot edit</div>
            </div>
          </div>

          <div class="permission-btn" data-permission="material_view" onclick="setSharePermission('material_view', this)">
            <div class="permission-icon">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <rect x="3" y="3" width="7" height="7"/>
                <rect x="14" y="3" width="7" height="7"/>
                <rect x="14" y="14" width="7" height="7"/>
                <rect x="3" y="14" width="7" height="7"/>
              </svg>
            </div>
            <div class="permission-info">
              <div class="permission-btn-title">Material View</div>
              <div class="permission-btn-desc">See materials only, no prices</div>
            </div>
          </div>

          <div class="permission-btn" data-permission="presentation" onclick="setSharePermission('presentation', this)">
            <div class="permission-icon">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <rect x="2" y="3" width="20" height="14" rx="2"/>
                <line x1="8" y1="21" x2="16" y2="21"/>
                <line x1="12" y1="17" x2="12" y2="21"/>
              </svg>
            </div>
            <div class="permission-info">
              <div class="permission-btn-title">Presentation</div>
              <div class="permission-btn-desc">Client-pretty, no costs shown</div>
            </div>
          </div>
        </div>
      </div>

      <div class="share-actions">
        <button class="btn btn-primary" onclick="generateShareLink()">Generate Share Link</button>
      </div>

      <div class="active-shares" id="activeShares" style="display:none;">
        <h4>Active Share Links</h4>
        <div class="shares-list" id="sharesList"></div>
      </div>

      <div class="recent-activity" id="recentActivity" style="display:none;">
        <h4>Recent Activity</h4>
        <div class="activity-list" id="activityList"></div>
      </div>
    </div>
  </div>

  <!-- My Designs Modal -->
  <div class="modal-overlay" id="myDesignsModal">
    <div class="modal" style="max-width: 800px; max-height: 85vh;">
      <div class="modal-header">
        <h3 class="modal-title">My Designs</h3>
        <button class="modal-close" onclick="closeModal('myDesignsModal')">Ã—</button>
      </div>

      <div class="designs-tabs">
        <button class="designs-tab active" onclick="switchDesignsTab('my', this)">My Designs</button>
        <button class="designs-tab" onclick="switchDesignsTab('shared', this)">Shared With Me</button>
        <button class="designs-tab" onclick="switchDesignsTab('recent', this)">Recently Viewed</button>
      </div>

      <div class="designs-search">
        <input type="text" id="designsSearch" placeholder="Search designs..." oninput="filterDesigns(this.value)">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <circle cx="11" cy="11" r="8"/><path d="m21 21-4.35-4.35"/>
        </svg>
      </div>

      <div class="designs-grid" id="designsGrid">
        <div class="designs-loading">Loading designs...</div>
      </div>

      <div class="designs-empty" id="designsEmpty" style="display:none;">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
          <path d="M3 7v10a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-6l-2-2H5a2 2 0 00-2 2z"/>
        </svg>
        <p>No designs found</p>
        <button class="btn btn-primary" onclick="closeModal('myDesignsModal')">Create New Design</button>
      </div>

      <div style="margin-top: 16px; padding-top: 16px; border-top: 1px solid var(--border-color); display: flex; gap: 12px;">
        <button class="btn btn-primary" onclick="saveDesignLocally(); loadMyDesigns();">
          <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="margin-right: 6px;">
            <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/>
            <polyline points="17 21 17 13 7 13 7 21"/>
            <polyline points="7 3 7 8 15 8"/>
          </svg>
          Save Current Design
        </button>
        <button class="btn btn-secondary" onclick="closeModal('myDesignsModal')">Close</button>
      </div>
    </div>
  </div>

  <!-- Push Notification Toast -->
  <div class="notification-toast" id="notificationToast">
    <div class="notification-icon">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"/>
      </svg>
    </div>
    <div class="notification-content">
      <div class="notification-title" id="notificationTitle">New Message</div>
      <div class="notification-body" id="notificationBody">You have a new message</div>
    </div>
    <button class="notification-close" onclick="hideNotification()">Ã—</button>
  </div>

  <!-- Edge Preview Modal -->
  <div class="modal-overlay" id="edgePreviewModal">
    <div class="modal" style="max-width: 500px; background: var(--surface-secondary);">
      <div class="modal-header">
        <h3 class="modal-title">Edge Profile Preview</h3>
        <button class="modal-close" onclick="closeEdgePreview()">Ã—</button>
      </div>
      <div class="modal-body" style="padding: 0;">
        <!-- 3D Preview Container -->
        <div id="edgePreview3D" style="width: 100%; height: 280px; background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); border-radius: 8px 8px 0 0;"></div>

        <!-- Edge Info -->
        <div style="padding: 20px;">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
            <div>
              <div style="font-size: 11px; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.5px;">Current Edge Profile</div>
              <div id="edgeProfileName" style="font-size: 18px; font-weight: 600; color: var(--text-primary);">Eased</div>
            </div>
            <div style="text-align: right;">
              <div style="font-size: 11px; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.5px;">Thickness</div>
              <div id="edgeThickness" style="font-size: 18px; font-weight: 600; color: var(--gold);">3cm</div>
            </div>
          </div>

          <!-- Edge Profile Selector -->
          <div style="margin-bottom: 16px;">
            <label style="font-size: 12px; color: var(--text-muted); display: block; margin-bottom: 8px;">Change Edge Profile</label>
            <select id="edgeProfileSelect" onchange="updateEdgeProfile(this.value)" style="width: 100%; padding: 12px; background: var(--surface); border: 1px solid var(--border); border-radius: 8px; color: var(--text-primary); font-size: 14px;">
              <option value="eased">Eased (Standard)</option>
              <option value="pencil">Pencil Round</option>
              <option value="quarter-round">Quarter Round</option>
              <option value="half-bullnose">Half Bullnose</option>
              <option value="full-bullnose">Full Bullnose</option>
              <option value="bevel">Bevel / Quarter Bevel</option>
              <option value="ogee">Ogee (Premium)</option>
              <option value="double-ogee">Double Ogee (Premium)</option>
              <option value="cove">Cove</option>
              <option value="dupont">Dupont</option>
              <option value="mitered">Mitered</option>
              <option value="waterfall">Waterfall</option>
            </select>
          </div>

          <!-- Camera Controls -->
          <div style="display: flex; gap: 8px; justify-content: center;">
            <button class="btn btn-secondary" style="padding: 8px 16px; font-size: 12px;" onclick="rotateEdgePreview('left')">â† Rotate</button>
            <button class="btn btn-secondary" style="padding: 8px 16px; font-size: 12px;" onclick="rotateEdgePreview('reset')">Reset View</button>
            <button class="btn btn-secondary" style="padding: 8px 16px; font-size: 12px;" onclick="rotateEdgePreview('right')">Rotate â†’</button>
          </div>
        </div>
      </div>
      <div class="modal-footer">
        <button class="btn btn-secondary" onclick="closeEdgePreview()">Close</button>
        <button class="btn btn-primary" onclick="applyEdgeAndClose()">Apply & Close</button>
      </div>
    </div>
  </div>

  <!-- Login Modal -->
  <div class="modal-overlay" id="loginModal">
    <div class="modal login-modal">
      <div class="modal-header">
        <h3 class="modal-title" style="font-size: 22px;">Sign In</h3>
        <button class="modal-close login-modal-close" onclick="closeModal('loginModal')">Ã—</button>
      </div>

      <p id="loginPromptMessage" style="color: var(--text-secondary); margin-bottom: 24px; text-align: center; font-size: 15px; line-height: 1.5;">
        Sign in to save and share your designs.
      </p>

      <div id="loginFormContainer">
        <!-- Google OAuth Button -->
        <button class="google-signin-btn" onclick="handleGoogleLogin()">
          <svg viewBox="0 0 24 24" width="20" height="20">
            <path fill="#4285F4" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"/>
            <path fill="#34A853" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/>
            <path fill="#FBBC05" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/>
            <path fill="#EA4335" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/>
          </svg>
          Continue with Google
        </button>

        <div class="login-divider">
          <span>or</span>
        </div>

        <!-- Email/Password Form -->
        <div class="form-group" style="margin-bottom: 18px;">
          <label style="font-size: 13px; margin-bottom: 8px; display: block; font-weight: 500;">Email</label>
          <input type="email" id="loginEmail" class="input" placeholder="your@email.com" style="width: 100%; padding: 14px; font-size: 15px;">
        </div>
        <div class="form-group" style="margin-bottom: 18px;">
          <label style="font-size: 13px; margin-bottom: 8px; display: block; font-weight: 500;">Password</label>
          <input type="password" id="loginPassword" class="input" placeholder="â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢" style="width: 100%; padding: 14px; font-size: 15px;">
        </div>
        <div id="loginError" style="color: var(--error); font-size: 13px; margin-bottom: 14px; display: none;"></div>

        <!-- Sign In Button -->
        <button class="btn-signin" id="signInBtn" onclick="handleLogin()">
          <span class="btn-signin-text">Sign In</span>
          <span class="btn-signin-loader"></span>
        </button>
        <div style="text-align: center; font-size: 14px; color: var(--text-muted); margin-bottom: 16px;">
          Don't have an account? <a href="/sign-up/" target="_blank" style="color: var(--gold); font-weight: 500;">Sign up free</a>
        </div>
        <div class="login-divider" style="margin-bottom: 16px;">
          <span>or</span>
        </div>
        <button class="btn" style="width: 100%; padding: 12px; font-size: 14px; background: transparent; border: 1px solid var(--border-color); color: var(--text-secondary);" onclick="continueAsGuest()">Continue as Guest</button>
        <p style="text-align: center; font-size: 11px; color: var(--text-muted); margin-top: 10px; opacity: 0.7;">Guest designs are saved locally only</p>
      </div>

      <div id="loginSuccessContainer" style="display: none; text-align: center; padding: 20px 0;">
        <div style="width: 70px; height: 70px; background: var(--success); border-radius: 50%; display: flex; align-items: center; justify-content: center; margin: 0 auto 20px;">
          <svg viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="3" style="width: 35px; height: 35px;">
            <polyline points="20 6 9 17 4 12"/>
          </svg>
        </div>
        <h4 style="margin-bottom: 10px; font-size: 20px;">Signed In!</h4>
        <p id="loginWelcome" style="color: var(--text-secondary); margin-bottom: 20px; font-size: 15px;">Welcome back</p>
        <button class="btn btn-primary" style="padding: 14px 32px; font-size: 15px;" onclick="closeModal('loginModal')">Continue</button>
      </div>
    </div>
  </div>

  <!-- Price List Modal -->
  <div class="modal-overlay" id="priceListModal">
    <div class="modal" style="max-width: 700px;">
      <div class="modal-header">
        <h3 class="modal-title">Price List Manager</h3>
        <button class="modal-close" onclick="closeModal('priceListModal')">Ã—</button>
      </div>

      <div class="price-list-tabs">
        <button class="tab-btn active" onclick="showPriceTab('upload')">Upload</button>
        <button class="tab-btn" onclick="showPriceTab('saved')">Saved Lists</button>
        <button class="tab-btn" onclick="showPriceTab('current')">Current Prices</button>
      </div>

      <!-- Upload Tab -->
      <div class="price-tab" id="priceTabUpload">
        <div class="upload-dropzone" id="priceListDropzone" onclick="document.getElementById('priceListFile').click()">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:48px;height:48px;margin-bottom:12px;opacity:0.5;">
            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
            <polyline points="17 8 12 3 7 8"/>
            <line x1="12" y1="3" x2="12" y2="15"/>
          </svg>
          <p style="margin-bottom:4px;">Drop Excel or CSV file here</p>
          <p class="hint" style="font-size:12px;color:var(--text-muted);">Supports .xlsx, .xls, .csv</p>
          <input type="file" id="priceListFile" accept=".xlsx,.xls,.csv" onchange="handlePriceListUpload(event)" style="display:none">
        </div>

        <div class="column-mapping" id="columnMapping" style="display:none;">
          <h4 style="margin-bottom:12px;">Map Columns</h4>
          <div class="mapping-row">
            <label>Material ID/SKU</label>
            <select id="mapMaterialId" class="property-select" onchange="updateMappingPreview()"></select>
          </div>
          <div class="mapping-row">
            <label>Material Name</label>
            <select id="mapMaterialName" class="property-select" onchange="updateMappingPreview()"></select>
          </div>
          <div class="mapping-row">
            <label>Price</label>
            <select id="mapPrice" class="property-select" onchange="updateMappingPreview()"></select>
          </div>
          <div class="mapping-row">
            <label>Unit (optional)</label>
            <select id="mapUnit" class="property-select" onchange="updateMappingPreview()"></select>
          </div>
          <div class="mapping-preview" id="mappingPreview"></div>
          <div class="mapping-actions">
            <button class="btn btn-secondary" onclick="cancelPriceUpload()">Cancel</button>
            <button class="btn btn-primary" onclick="applyPriceList()">Apply Prices</button>
          </div>
        </div>
      </div>

      <!-- Saved Lists Tab -->
      <div class="price-tab" id="priceTabSaved" style="display:none;">
        <div class="saved-lists" id="savedPriceLists">
          <p class="empty-state">No saved price lists</p>
        </div>
        <button class="btn btn-primary" onclick="savePriceList()" style="margin-top:16px;">Save Current Prices</button>
      </div>

      <!-- Current Prices Tab -->
      <div class="price-tab" id="priceTabCurrent" style="display:none;">
        <div class="current-prices-header">
          <input type="text" class="search-input" id="priceSearchInput" placeholder="Search materials..." oninput="filterCurrentPrices()">
        </div>
        <div class="current-prices-list" id="currentPricesList"></div>
      </div>
    </div>
  </div>

  <!-- Margin Settings Modal -->
  <div class="modal-overlay" id="marginModal">
    <div class="modal" style="max-width: 450px;">
      <div class="modal-header">
        <h3 class="modal-title">Margin Settings</h3>
        <button class="modal-close" onclick="closeModal('marginModal')">Ã—</button>
      </div>

      <div class="margin-section">
        <div class="margin-global">
          <label>Default Margin</label>
          <div class="margin-input-group">
            <input type="number" class="property-input" id="globalMarginInput" value="30" min="0" max="200">
            <span class="margin-symbol">%</span>
          </div>
          <p class="hint" style="font-size:11px;color:var(--text-muted);margin-top:4px;">Applied to all items without custom margin</p>
        </div>

        <div class="margin-categories">
          <h4 style="margin:16px 0 12px;">Category Margins</h4>
          <div class="category-margin-row">
            <span>Countertops</span>
            <div class="margin-input-group">
              <input type="number" class="property-input" data-category="countertop" value="35" min="0" max="200">
              <span class="margin-symbol">%</span>
            </div>
          </div>
          <div class="category-margin-row">
            <span>Cabinets</span>
            <div class="margin-input-group">
              <input type="number" class="property-input" data-category="cabinet" value="25" min="0" max="200">
              <span class="margin-symbol">%</span>
            </div>
          </div>
          <div class="category-margin-row">
            <span>Appliances</span>
            <div class="margin-input-group">
              <input type="number" class="property-input" data-category="appliance" value="15" min="0" max="200">
              <span class="margin-symbol">%</span>
            </div>
          </div>
          <div class="category-margin-row">
            <span>Flooring/Tile</span>
            <div class="margin-input-group">
              <input type="number" class="property-input" data-category="flooring" value="30" min="0" max="200">
              <span class="margin-symbol">%</span>
            </div>
          </div>
        </div>
      </div>

      <div class="modal-footer">
        <button class="btn btn-secondary" onclick="closeModal('marginModal')">Cancel</button>
        <button class="btn btn-primary" onclick="applyMargins()">Apply</button>
      </div>
    </div>
  </div>

  <!-- Material Picker Modal -->
  <div class="modal-overlay" id="materialModal">
    <div class="modal" style="max-width: 600px;">
      <div class="modal-header">
        <h3 class="modal-title">Choose Material</h3>
        <button class="modal-close" onclick="closeModal('materialModal')">Ã—</button>
      </div>
      <div class="material-categories" id="materialCategories">
        <!-- Categories rendered by JS -->
      </div>
      <div class="materials-modal-grid" id="materialsGrid">
        <!-- Materials rendered by JS -->
      </div>
    </div>
  </div>

  <!-- Hidden file input -->
  <input type="file" id="materialUpload" accept="image/*" style="display: none" onchange="handleMaterialUpload(event)">

  <!-- Keyboard Shortcuts (hidden in review mode) -->
  <div class="shortcuts-hint" id="shortcutsHint">
    <div class="shortcut"><kbd>V</kbd> Select</div>
    <div class="shortcut"><kbd>W</kbd> Wall</div>
    <div class="shortcut"><kbd>C</kbd> Counter</div>
    <div class="shortcut"><kbd>Del</kbd> Delete</div>
    <div class="shortcut"><kbd>R</kbd> Rotate</div>
    <div class="shortcut"><kbd>Ctrl+D</kbd> Duplicate</div>
  </div>

  <script>
    // ===== CONFIGURATION =====
    const CONFIG = {
      MIN_PIXELS_PER_FOOT: 20,
      DEFAULT_PIXELS_PER_FOOT: 40,
      GRID_SUBDIVISIONS: 12, // 12 subdivisions = 1 inch grid (12" per foot)
      MEASUREMENT_PRECISION: 16, // 1/16" precision
      WALL_THICKNESS: 6,
      PRICING: {
        'base-cabinet': 150,
        'wall-cabinet': 120,
        'tall-cabinet': 300,
        'fridge-cabinet': 450,
        'corner-cabinet': 200,
        'island': 400,
        'countertop': 65,
        'backsplash': 25,
        'flooring': 8,
        'tile': 15,
        'sink': 350,
        'stove': 800,
        'refrigerator': 1200,
        'dishwasher': 600,
        'microwave': 250,
        'range-hood': 450,
        'oven': 1500,
        'door': 200,
        'window': 300,
        'wall': 0
      }
    };

    // ===== PRICING & SHARING STATE =====
    const PRICING_STATE = {
      globalMargin: 30,           // Default 30% markup
      categoryMargins: {
        countertop: 35,
        cabinet: 25,
        appliance: 15,
        flooring: 30,
        other: 30
      },
      showCostView: false,        // Toggle between cost/retail view
      priceLists: [],             // Saved price list configurations
      activePriceList: null,      // Currently active price list name
      customPrices: {}            // Temporary price overrides from Excel import
    };

    // ===== 3D MODEL CACHE =====
    const MODEL_CACHE = {
      kitchenCabinets: null,
      loadingPromise: null
    };

    // GLB Model Loader
    async function loadGLBModel(url) {
      return new Promise((resolve, reject) => {
        const loader = new THREE.GLTFLoader();
        loader.load(
          url,
          (gltf) => {
            console.log('GLB model loaded successfully');
            resolve(gltf);
          },
          (progress) => {
            const pct = (progress.loaded / progress.total * 100).toFixed(1);
            console.log(`Loading 3D model: ${pct}%`);
          },
          (error) => {
            console.error('Error loading GLB model:', error);
            reject(error);
          }
        );
      });
    }

    // Load kitchen cabinets model
    async function getKitchenCabinetsModel() {
      if (MODEL_CACHE.kitchenCabinets) {
        return MODEL_CACHE.kitchenCabinets.scene.clone();
      }
      if (MODEL_CACHE.loadingPromise) {
        await MODEL_CACHE.loadingPromise;
        return MODEL_CACHE.kitchenCabinets.scene.clone();
      }
      MODEL_CACHE.loadingPromise = loadGLBModel('/tools/room-designer/assets/models/kitchen-cabinets.glb');
      MODEL_CACHE.kitchenCabinets = await MODEL_CACHE.loadingPromise;
      return MODEL_CACHE.kitchenCabinets.scene.clone();
    }

    const SHARE_STATE = {
      designId: null,             // Supabase design ID
      designToken: null,          // Current design's share token
      permission: 'full_collab',  // Current user's permission level
      isSharedView: false,        // Whether viewing a shared design
      allowedActions: null        // Actions permitted by current permission
    };

    const PERMISSION_LEVELS = {
      full_collab: {
        name: 'Full Collaboration',
        description: 'Can edit everything including prices',
        canEdit: true,
        canViewPrices: true,
        canViewCosts: true,
        canViewMaterials: true,
        canExport: true,
        canApprove: false
      },
      quote_approval: {
        name: 'Quote Approval',
        description: 'Customer can view quote and approve with payment',
        canEdit: false,
        canViewPrices: true,
        canViewCosts: false,
        canViewMaterials: true,
        canExport: true,
        canApprove: true
      },
      quote_view: {
        name: 'Quote View',
        description: 'Can see prices but cannot edit',
        canEdit: false,
        canViewPrices: true,
        canViewCosts: false,
        canViewMaterials: true,
        canExport: true,
        canApprove: false
      },
      material_view: {
        name: 'Material View',
        description: 'See materials only, no pricing',
        canEdit: false,
        canViewPrices: false,
        canViewCosts: false,
        canViewMaterials: true,
        canExport: false
      },
      presentation: {
        name: 'Presentation',
        description: 'Client-pretty view, no costs shown',
        canEdit: false,
        canViewPrices: false,
        canViewCosts: false,
        canViewMaterials: false,
        canExport: false
      }
    };

    // ===== BUILDING STANDARDS =====
    const BUILDING_STANDARDS = {
      // Standard element dimensions (in feet)
      DOORS: {
        interior: { width: 2.667, height: 6.667, label: "2'-8\" Ã— 6'-8\"" },    // 32" Ã— 80"
        interiorWide: { width: 3, height: 6.667, label: "3'-0\" Ã— 6'-8\"" },    // 36" Ã— 80"
        exterior: { width: 3, height: 6.667, label: "3'-0\" Ã— 6'-8\"" },        // 36" Ã— 80"
        exteriorTall: { width: 3, height: 7, label: "3'-0\" Ã— 7'-0\"" },        // 36" Ã— 84"
        double: { width: 5, height: 6.667, label: "5'-0\" Ã— 6'-8\"" },          // 60" Ã— 80"
        sliding: { width: 6, height: 6.667, label: "6'-0\" Ã— 6'-8\"" },         // 72" Ã— 80"
        garage1car: { width: 8, height: 7, label: "8'-0\" Ã— 7'-0\"" },          // 96" Ã— 84"
        garage2car: { width: 16, height: 7, label: "16'-0\" Ã— 7'-0\"" }         // 192" Ã— 84"
      },
      WINDOWS: {
        small: { width: 2, height: 3, label: "2'-0\" Ã— 3'-0\"" },               // 24" Ã— 36"
        standard: { width: 3, height: 4, label: "3'-0\" Ã— 4'-0\"" },            // 36" Ã— 48"
        large: { width: 4, height: 5, label: "4'-0\" Ã— 5'-0\"" },               // 48" Ã— 60"
        picture: { width: 6, height: 4, label: "6'-0\" Ã— 4'-0\"" }              // 72" Ã— 48"
      },
      CABINETS: {
        // Base cabinets (height is depth in floor plan)
        base12: { width: 1, depth: 2, label: "12\" wide" },
        base15: { width: 1.25, depth: 2, label: "15\" wide" },
        base18: { width: 1.5, depth: 2, label: "18\" wide" },
        base21: { width: 1.75, depth: 2, label: "21\" wide" },
        base24: { width: 2, depth: 2, label: "24\" wide" },
        base27: { width: 2.25, depth: 2, label: "27\" wide" },
        base30: { width: 2.5, depth: 2, label: "30\" wide" },
        base33: { width: 2.75, depth: 2, label: "33\" wide" },
        base36: { width: 3, depth: 2, label: "36\" wide" },
        base42: { width: 3.5, depth: 2, label: "42\" wide" },
        base48: { width: 4, depth: 2, label: "48\" wide" },
        // Wall cabinets (shallower depth)
        wall12: { width: 1, depth: 1, label: "12\" wide" },
        wall15: { width: 1.25, depth: 1, label: "15\" wide" },
        wall18: { width: 1.5, depth: 1, label: "18\" wide" },
        wall24: { width: 2, depth: 1, label: "24\" wide" },
        wall30: { width: 2.5, depth: 1, label: "30\" wide" },
        wall36: { width: 3, depth: 1, label: "36\" wide" },
        // Tall/Pantry
        tall24: { width: 2, depth: 2, label: "24\" wide pantry" },
        tall36: { width: 3, depth: 2, label: "36\" wide pantry" }
      },
      COUNTERTOPS: {
        standardDepth: 2.083,  // 25" including overhang
        barHeight: 3.5,       // 42" bar height
        islandMinWidth: 2,    // 24" minimum
        islandMinDepth: 4     // 48" minimum for seating
      },
      // Clearance requirements (in feet)
      CLEARANCES: {
        walkway: 3,           // 36" minimum walkway
        twoCoook: 4,          // 48" for two cooks
        applianceOpen: 3.5,   // 42" in front of open appliance
        islandWalkway: 3.5,   // 42" around island
        adaTurning: 5,        // 60" ADA turning radius
        doorSwing: 1.5,       // 18" beside door latch
        doorFront: 5          // 60" in front of door
      },
      // Work triangle limits (in feet)
      WORK_TRIANGLE: {
        legMin: 4,            // Minimum leg length
        legMax: 9,            // Maximum leg length
        perimeterMin: 13,     // Minimum total perimeter
        perimeterMax: 26      // Maximum total perimeter
      },
      // Standard heights (for 3D and reference)
      HEIGHTS: {
        ceiling: 8,           // 8' standard ceiling
        ceilingTall: 9,       // 9' ceiling
        ceilingLuxury: 10,    // 10' ceiling
        baseCounter: 3,       // 36" counter height
        barCounter: 3.5,      // 42" bar height
        wallCabBottom: 4.5,   // 54" to bottom of wall cabinet
        wallCabTop: 7,        // 84" to top of wall cabinet
        rangeHood: 5.5,       // 66" to bottom of hood
        windowSill: 3         // 36" typical window sill
      }
    };

    // Standard snap dimensions (in feet) for smart snapping
    const SNAP_DIMENSIONS = {
      widths: [1, 1.25, 1.5, 1.75, 2, 2.25, 2.5, 2.75, 3, 3.5, 4, 4.5, 5, 6, 8],
      depths: [1, 1.5, 2, 2.5, 3, 4],
      tolerance: 0.0833  // 1" snap tolerance
    };

    // ===== MEASUREMENT FORMATTING =====
    // Format feet (decimal) to feet-inches-fractions string
    // Supports 1/16" precision
    function formatDimension(feet, showFractions = true) {
      const totalInches = feet * 12;
      const wholeInches = Math.floor(totalInches);
      const wholeFeet = Math.floor(wholeInches / 12);
      const remainingInches = wholeInches % 12;
      const fractionalInches = totalInches - wholeInches;

      // Convert to 16ths for fraction display
      const sixteenths = Math.round(fractionalInches * 16);

      // Simplify fraction
      let fractionStr = '';
      if (sixteenths > 0 && showFractions) {
        if (sixteenths === 16) {
          // Round up to next inch
          return formatDimension(feet + (1/192), showFractions);
        } else if (sixteenths === 8) {
          fractionStr = 'Â½';
        } else if (sixteenths === 4) {
          fractionStr = 'Â¼';
        } else if (sixteenths === 12) {
          fractionStr = 'Â¾';
        } else if (sixteenths % 2 === 0) {
          // Can simplify to eighths
          fractionStr = `${sixteenths/2}/8`;
        } else {
          fractionStr = `${sixteenths}/16`;
        }
      }

      // Build output string
      if (wholeFeet > 0 && remainingInches > 0) {
        return `${wholeFeet}'-${remainingInches}${fractionStr}"`;
      } else if (wholeFeet > 0 && fractionStr) {
        return `${wholeFeet}'-0${fractionStr}"`;
      } else if (wholeFeet > 0) {
        return `${wholeFeet}'-0"`;
      } else if (remainingInches > 0 || fractionStr) {
        return `${remainingInches}${fractionStr}"`;
      } else {
        return '0"';
      }
    }

    // Format dimensions as W Ã— H
    function formatSize(widthFt, heightFt) {
      return `${formatDimension(widthFt)} Ã— ${formatDimension(heightFt)}`;
    }

    // Parse dimension string back to feet (for input)
    // Accepts: "3'-6"", "3.5", "42"", "3' 6"", etc.
    function parseDimension(str) {
      if (typeof str === 'number') return str;
      str = str.toString().trim();

      // Already decimal feet
      if (/^[\d.]+$/.test(str)) {
        return parseFloat(str);
      }

      // Feet and inches: 3'-6" or 3' 6" or 3'6"
      const feetInchMatch = str.match(/(\d+)[''][\s-]*(\d+)?(?:\s*(\d+)\/(\d+))?[""]?/);
      if (feetInchMatch) {
        const feet = parseInt(feetInchMatch[1]) || 0;
        const inches = parseInt(feetInchMatch[2]) || 0;
        const fracNum = parseInt(feetInchMatch[3]) || 0;
        const fracDen = parseInt(feetInchMatch[4]) || 1;
        return feet + (inches + fracNum/fracDen) / 12;
      }

      // Just inches: 42" or 36"
      const inchMatch = str.match(/^(\d+)(?:\s*(\d+)\/(\d+))?[""]$/);
      if (inchMatch) {
        const inches = parseInt(inchMatch[1]) || 0;
        const fracNum = parseInt(inchMatch[2]) || 0;
        const fracDen = parseInt(inchMatch[3]) || 1;
        return (inches + fracNum/fracDen) / 12;
      }

      // Fallback
      return parseFloat(str) || 0;
    }

    // Round to nearest 1/16"
    function roundToSixteenth(feet) {
      const sixteenthsPerFoot = 12 * 16; // 192 sixteenths per foot
      return Math.round(feet * sixteenthsPerFoot) / sixteenthsPerFoot;
    }

    // ===== BUILDING CODE VALIDATION =====
    let validationIssues = [];
    let showWorkTriangle = false;

    // Find elements by type
    function findElementsByType(types) {
      if (!Array.isArray(types)) types = [types];
      return elements.filter(el => types.includes(el.type));
    }

    // Get element center point
    function getElementCenter(el) {
      return {
        x: el.x + (el.width * pixelsPerFoot) / 2,
        y: el.y + (el.height * pixelsPerFoot) / 2
      };
    }

    // Calculate distance between two elements (center to center)
    function getDistance(el1, el2) {
      const c1 = getElementCenter(el1);
      const c2 = getElementCenter(el2);
      const dx = (c2.x - c1.x) / pixelsPerFoot;
      const dy = (c2.y - c1.y) / pixelsPerFoot;
      return Math.sqrt(dx * dx + dy * dy);
    }

    // Get gap between two elements (edge to edge)
    function getGapBetween(el1, el2) {
      const r1 = {
        left: el1.x / pixelsPerFoot,
        right: (el1.x + el1.width * pixelsPerFoot) / pixelsPerFoot,
        top: el1.y / pixelsPerFoot,
        bottom: (el1.y + el1.height * pixelsPerFoot) / pixelsPerFoot
      };
      const r2 = {
        left: el2.x / pixelsPerFoot,
        right: (el2.x + el2.width * pixelsPerFoot) / pixelsPerFoot,
        top: el2.y / pixelsPerFoot,
        bottom: (el2.y + el2.height * pixelsPerFoot) / pixelsPerFoot
      };

      // Calculate gaps in each direction
      const gapX = Math.max(r1.left - r2.right, r2.left - r1.right, 0);
      const gapY = Math.max(r1.top - r2.bottom, r2.top - r1.bottom, 0);

      return Math.sqrt(gapX * gapX + gapY * gapY);
    }

    // Validate kitchen work triangle
    function validateWorkTriangle() {
      const issues = [];
      const sinks = findElementsByType('sink');
      const stoves = findElementsByType(['stove', 'range', 'cooktop']);
      const fridges = findElementsByType(['refrigerator', 'fridge']);

      if (sinks.length === 0 || stoves.length === 0 || fridges.length === 0) {
        return { valid: false, issues: [], triangle: null, message: 'Need sink, stove, and refrigerator for work triangle' };
      }

      const sink = sinks[0];
      const stove = stoves[0];
      const fridge = fridges[0];

      const leg1 = getDistance(sink, stove);
      const leg2 = getDistance(stove, fridge);
      const leg3 = getDistance(fridge, sink);
      const perimeter = leg1 + leg2 + leg3;

      const { legMin, legMax, perimeterMin, perimeterMax } = BUILDING_STANDARDS.WORK_TRIANGLE;

      // Check each leg
      if (leg1 < legMin) issues.push({ type: 'warning', message: `Sink-Stove: ${formatDimension(leg1)} (min ${formatDimension(legMin)})` });
      if (leg1 > legMax) issues.push({ type: 'warning', message: `Sink-Stove: ${formatDimension(leg1)} (max ${formatDimension(legMax)})` });
      if (leg2 < legMin) issues.push({ type: 'warning', message: `Stove-Fridge: ${formatDimension(leg2)} (min ${formatDimension(legMin)})` });
      if (leg2 > legMax) issues.push({ type: 'warning', message: `Stove-Fridge: ${formatDimension(leg2)} (max ${formatDimension(legMax)})` });
      if (leg3 < legMin) issues.push({ type: 'warning', message: `Fridge-Sink: ${formatDimension(leg3)} (min ${formatDimension(legMin)})` });
      if (leg3 > legMax) issues.push({ type: 'warning', message: `Fridge-Sink: ${formatDimension(leg3)} (max ${formatDimension(legMax)})` });

      // Check perimeter
      if (perimeter < perimeterMin) {
        issues.push({ type: 'error', message: `Triangle too small: ${formatDimension(perimeter)} (min ${formatDimension(perimeterMin)})` });
      }
      if (perimeter > perimeterMax) {
        issues.push({ type: 'error', message: `Triangle too large: ${formatDimension(perimeter)} (max ${formatDimension(perimeterMax)})` });
      }

      return {
        valid: issues.length === 0,
        issues,
        triangle: { sink, stove, fridge, leg1, leg2, leg3, perimeter },
        message: issues.length === 0 ? 'Work triangle OK' : `${issues.length} issue(s)`
      };
    }

    // Validate clearances between elements
    function validateClearances() {
      const issues = [];
      const { walkway, islandWalkway, applianceOpen } = BUILDING_STANDARDS.CLEARANCES;

      // Check island clearances
      const islands = findElementsByType('island');
      const counters = findElementsByType('countertop');
      const cabinets = findElementsByType(['base-cabinet', 'tall-cabinet']);

      islands.forEach(island => {
        // Check clearance to counters and cabinets
        [...counters, ...cabinets].forEach(other => {
          const gap = getGapBetween(island, other);
          if (gap > 0 && gap < islandWalkway) {
            issues.push({
              type: 'warning',
              message: `Island clearance: ${formatDimension(gap)} (min ${formatDimension(islandWalkway)})`,
              elements: [island, other]
            });
          }
        });
      });

      // Check walkway between parallel counters
      for (let i = 0; i < counters.length; i++) {
        for (let j = i + 1; j < counters.length; j++) {
          const gap = getGapBetween(counters[i], counters[j]);
          if (gap > 0 && gap < walkway) {
            issues.push({
              type: 'warning',
              message: `Counter gap: ${formatDimension(gap)} (min ${formatDimension(walkway)})`,
              elements: [counters[i], counters[j]]
            });
          }
        }
      }

      // Check appliance clearances
      const appliances = findElementsByType(['stove', 'refrigerator', 'dishwasher', 'oven']);
      appliances.forEach(app => {
        // Check for adequate space in front (simplified - check distance to facing elements)
        const facing = [...islands, ...counters].filter(other => {
          const gap = getGapBetween(app, other);
          return gap > 0 && gap < applianceOpen;
        });

        facing.forEach(other => {
          const gap = getGapBetween(app, other);
          issues.push({
            type: 'info',
            message: `${app.label} front clearance: ${formatDimension(gap)} (rec. ${formatDimension(applianceOpen)})`,
            elements: [app, other]
          });
        });
      });

      return issues;
    }

    // Validate door clearances
    function validateDoorClearances() {
      const issues = [];
      const doors = findElementsByType(['door', 'double-door', 'entry-archway']);
      const allElements = elements.filter(el => !['door', 'double-door', 'entry-archway', 'window'].includes(el.type));

      doors.forEach(door => {
        allElements.forEach(other => {
          const gap = getGapBetween(door, other);
          if (gap > 0 && gap < BUILDING_STANDARDS.CLEARANCES.doorSwing) {
            issues.push({
              type: 'warning',
              message: `Door swing blocked: ${formatDimension(gap)} to ${other.label}`,
              elements: [door, other]
            });
          }
        });
      });

      return issues;
    }

    // Run all validations
    function runValidation() {
      validationIssues = [];

      // Work triangle
      const triangleResult = validateWorkTriangle();
      if (triangleResult.issues.length > 0) {
        validationIssues.push(...triangleResult.issues.map(i => ({
          ...i,
          category: 'Work Triangle'
        })));
      }

      // Clearances
      const clearanceIssues = validateClearances();
      validationIssues.push(...clearanceIssues.map(i => ({
        ...i,
        category: 'Clearances'
      })));

      // Door clearances
      const doorIssues = validateDoorClearances();
      validationIssues.push(...doorIssues.map(i => ({
        ...i,
        category: 'Door Swing'
      })));

      updateValidationPanel();
      return validationIssues;
    }

    // Update the validation panel UI
    function updateValidationPanel() {
      const panel = document.getElementById('validationPanel');
      if (!panel) return;

      const content = document.getElementById('validationContent');
      if (!content) return;

      if (validationIssues.length === 0) {
        content.innerHTML = '<div class="validation-ok">âœ“ No issues found</div>';
        return;
      }

      // Group by category
      const grouped = {};
      validationIssues.forEach(issue => {
        if (!grouped[issue.category]) grouped[issue.category] = [];
        grouped[issue.category].push(issue);
      });

      content.innerHTML = Object.entries(grouped).map(([category, issues]) => `
        <div class="validation-category">
          <div class="validation-category-title">${category}</div>
          ${issues.map(issue => `
            <div class="validation-issue validation-${issue.type}">
              <span class="validation-icon">${issue.type === 'error' ? 'âœ—' : issue.type === 'warning' ? 'âš ' : 'â„¹'}</span>
              <span class="validation-message">${issue.message}</span>
            </div>
          `).join('')}
        </div>
      `).join('');
    }

    // Draw work triangle on canvas
    function drawWorkTriangle() {
      if (!showWorkTriangle) return;

      const result = validateWorkTriangle();
      if (!result.triangle) return;

      const { sink, stove, fridge, leg1, leg2, leg3 } = result.triangle;

      ctx.save();
      ctx.setLineDash([10, 5]);
      ctx.lineWidth = 2;
      ctx.strokeStyle = result.valid ? 'rgba(34, 197, 94, 0.7)' : 'rgba(239, 68, 68, 0.7)';
      ctx.fillStyle = result.valid ? 'rgba(34, 197, 94, 0.1)' : 'rgba(239, 68, 68, 0.1)';

      const c1 = getElementCenter(sink);
      const c2 = getElementCenter(stove);
      const c3 = getElementCenter(fridge);

      // Draw triangle
      ctx.beginPath();
      ctx.moveTo(c1.x, c1.y);
      ctx.lineTo(c2.x, c2.y);
      ctx.lineTo(c3.x, c3.y);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();

      // Draw leg labels
      ctx.setLineDash([]);
      ctx.font = 'bold 11px Inter';
      ctx.fillStyle = result.valid ? '#22c55e' : '#ef4444';
      ctx.textAlign = 'center';

      // Leg 1 (sink-stove)
      const mid1 = { x: (c1.x + c2.x) / 2, y: (c1.y + c2.y) / 2 };
      ctx.fillText(formatDimension(leg1), mid1.x, mid1.y - 8);

      // Leg 2 (stove-fridge)
      const mid2 = { x: (c2.x + c3.x) / 2, y: (c2.y + c3.y) / 2 };
      ctx.fillText(formatDimension(leg2), mid2.x, mid2.y - 8);

      // Leg 3 (fridge-sink)
      const mid3 = { x: (c3.x + c1.x) / 2, y: (c3.y + c1.y) / 2 };
      ctx.fillText(formatDimension(leg3), mid3.x, mid3.y - 8);

      ctx.restore();
    }

    // Snap to standard dimension
    function snapToStandard(value, type = 'width') {
      const standards = type === 'width' ? SNAP_DIMENSIONS.widths : SNAP_DIMENSIONS.depths;
      const tolerance = SNAP_DIMENSIONS.tolerance;

      for (const std of standards) {
        if (Math.abs(value - std) <= tolerance) {
          return std;
        }
      }
      return value;
    }

    // Get suggested standard size for element type
    function getSuggestedSize(elementType) {
      switch (elementType) {
        case 'door':
          return { width: 3, height: 0.5, note: "Standard 36\" door" };
        case 'double-door':
          return { width: 5, height: 0.5, note: "Standard 60\" double door" };
        case 'sliding-door':
          return { width: 6, height: 0.5, note: "Standard 72\" slider" };
        case 'window':
          return { width: 3, height: 0.5, note: "Standard 36\" window" };
        case 'base-cabinet':
          return { width: 2, height: 2, note: "Standard 24\" base cabinet" };
        case 'wall-cabinet':
          return { width: 2.5, height: 1, note: "Standard 30\" wall cabinet" };
        case 'tall-cabinet':
          return { width: 2, height: 2, note: "Standard 24\" pantry" };
        case 'fridge-cabinet':
          return { width: 3, height: 7, note: "Enclosure for 36\" fridge" };
        case 'island':
          return { width: 4, height: 2.5, note: "Minimum island size" };
        case 'countertop':
          return { width: 3, height: 2.083, note: "Standard 25\" depth" };
        default:
          return null;
      }
    }

    // SVG icons for element thumbnails (single-line for reliability)
    const ELEMENT_ICONS = {
      'base-cabinet': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="12" width="40" height="32" rx="2" fill="#8B5A2B"/><rect x="6" y="14" width="17" height="28" rx="1" fill="#A0522D"/><rect x="25" y="14" width="17" height="28" rx="1" fill="#A0522D"/><rect x="8" y="16" width="13" height="24" rx="1" fill="#CD853F"/><rect x="27" y="16" width="13" height="24" rx="1" fill="#CD853F"/><rect x="19" y="24" width="2" height="8" rx="1" fill="#FFD700"/><rect x="35" y="24" width="2" height="8" rx="1" fill="#FFD700"/><rect x="4" y="44" width="40" height="4" fill="#2a2a2a"/></svg>',
      'wall-cabinet': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="8" width="40" height="24" rx="2" fill="#8B5A2B"/><rect x="6" y="10" width="17" height="20" rx="1" fill="#A0522D"/><rect x="25" y="10" width="17" height="20" rx="1" fill="#A0522D"/><rect x="8" y="12" width="13" height="16" rx="1" fill="#CD853F"/><rect x="27" y="12" width="13" height="16" rx="1" fill="#CD853F"/><rect x="19" y="18" width="2" height="6" rx="1" fill="#FFD700"/><rect x="35" y="18" width="2" height="6" rx="1" fill="#FFD700"/></svg>',
      'tall-cabinet': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="10" y="2" width="28" height="44" rx="2" fill="#8B5A2B"/><rect x="12" y="4" width="24" height="18" rx="1" fill="#A0522D"/><rect x="12" y="24" width="24" height="20" rx="1" fill="#A0522D"/><rect x="14" y="6" width="20" height="14" rx="1" fill="#CD853F"/><rect x="14" y="26" width="20" height="16" rx="1" fill="#CD853F"/><rect x="32" y="11" width="2" height="6" rx="1" fill="#FFD700"/><rect x="32" y="32" width="2" height="6" rx="1" fill="#FFD700"/></svg>',
      'corner-cabinet': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><path d="M4 4 L4 44 L24 44 L24 24 L44 24 L44 4 Z" fill="#8B5A2B"/><path d="M6 6 L6 42 L22 42 L22 22 L42 22 L42 6 Z" fill="#A0522D"/><line x1="22" y1="22" x2="42" y2="42" stroke="#CD853F" stroke-width="2"/><circle cx="28" cy="28" r="8" fill="none" stroke="#CD853F" stroke-width="1.5"/><rect x="32" y="32" width="3" height="10" rx="1" fill="#FFD700" transform="rotate(45 33.5 37)"/><rect x="4" y="44" width="20" height="4" fill="#2a2a2a"/></svg>',
      'island': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="16" width="44" height="24" rx="2" fill="#8B5A2B"/><rect x="2" y="12" width="44" height="6" rx="1" fill="#708090"/><rect x="4" y="18" width="12" height="20" rx="1" fill="#CD853F"/><rect x="18" y="18" width="12" height="20" rx="1" fill="#CD853F"/><rect x="32" y="18" width="12" height="20" rx="1" fill="#CD853F"/><rect x="14" y="26" width="2" height="6" rx="1" fill="#FFD700"/><rect x="28" y="26" width="2" height="6" rx="1" fill="#FFD700"/><rect x="2" y="40" width="44" height="4" fill="#2a2a2a"/></svg>',
      'drawer-base': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="12" width="40" height="32" rx="2" fill="#8B5A2B"/><rect x="6" y="14" width="36" height="7" rx="1" fill="#CD853F"/><rect x="6" y="23" width="36" height="7" rx="1" fill="#CD853F"/><rect x="6" y="32" width="36" height="10" rx="1" fill="#CD853F"/><rect x="20" y="16" width="8" height="2" rx="1" fill="#FFD700"/><rect x="20" y="25" width="8" height="2" rx="1" fill="#FFD700"/><rect x="20" y="35" width="8" height="2" rx="1" fill="#FFD700"/><rect x="4" y="44" width="40" height="4" fill="#2a2a2a"/></svg>',
      'sink-base': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="12" width="40" height="32" rx="2" fill="#8B5A2B"/><rect x="6" y="14" width="36" height="5" rx="1" fill="#A0522D"/><rect x="6" y="21" width="17" height="21" rx="1" fill="#CD853F"/><rect x="25" y="21" width="17" height="21" rx="1" fill="#CD853F"/><rect x="19" y="29" width="2" height="6" rx="1" fill="#FFD700"/><rect x="35" y="29" width="2" height="6" rx="1" fill="#FFD700"/><ellipse cx="24" cy="8" rx="12" ry="4" fill="#E0E0E0"/><ellipse cx="24" cy="8" rx="8" ry="2.5" fill="#808080"/><rect x="4" y="44" width="40" height="4" fill="#2a2a2a"/></svg>',
      'lazy-susan': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><path d="M4 4 L4 44 L24 44 L24 24 L44 24 L44 4 Z" fill="#8B5A2B"/><path d="M6 6 L6 42 L22 42 L22 22 L42 22 L42 6 Z" fill="#A0522D"/><circle cx="24" cy="24" r="10" fill="none" stroke="#CD853F" stroke-width="2"/><circle cx="24" cy="24" r="6" fill="none" stroke="#CD853F" stroke-width="1.5"/><circle cx="24" cy="24" r="2" fill="#CD853F"/><path d="M24 14 L26 18 L22 18 Z" fill="#FFD700"/><rect x="4" y="44" width="20" height="4" fill="#2a2a2a"/></svg>',
      'countertop': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="18" width="44" height="8" rx="1" fill="#708090"/><rect x="2" y="20" width="44" height="4" fill="#5a6a7a"/><circle cx="10" cy="22" r="2" fill="#8090a0"/><circle cx="24" cy="22" r="2" fill="#8090a0"/><circle cx="38" cy="22" r="2" fill="#8090a0"/><rect x="2" y="26" width="44" height="2" fill="#4a5a6a"/></svg>',
      'backsplash': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="8" width="40" height="32" fill="#D4AF37"/><rect x="4" y="8" width="10" height="10" fill="#E5C158" stroke="#B8860B"/><rect x="14" y="8" width="10" height="10" fill="#D4AF37" stroke="#B8860B"/><rect x="24" y="8" width="10" height="10" fill="#E5C158" stroke="#B8860B"/><rect x="34" y="8" width="10" height="10" fill="#D4AF37" stroke="#B8860B"/><rect x="4" y="18" width="10" height="10" fill="#D4AF37" stroke="#B8860B"/><rect x="14" y="18" width="10" height="10" fill="#E5C158" stroke="#B8860B"/><rect x="24" y="18" width="10" height="10" fill="#D4AF37" stroke="#B8860B"/><rect x="34" y="18" width="10" height="10" fill="#E5C158" stroke="#B8860B"/><rect x="4" y="28" width="10" height="10" fill="#E5C158" stroke="#B8860B"/><rect x="14" y="28" width="10" height="10" fill="#D4AF37" stroke="#B8860B"/><rect x="24" y="28" width="10" height="10" fill="#E5C158" stroke="#B8860B"/><rect x="34" y="28" width="10" height="10" fill="#D4AF37" stroke="#B8860B"/></svg>',
      'flooring': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="2" width="22" height="44" fill="#CD853F"/><rect x="24" y="2" width="22" height="44" fill="#DEB887"/><line x1="2" y1="13" x2="24" y2="13" stroke="#8B4513"/><line x1="2" y1="24" x2="24" y2="24" stroke="#8B4513"/><line x1="2" y1="35" x2="24" y2="35" stroke="#8B4513"/><line x1="24" y1="8" x2="46" y2="8" stroke="#8B4513"/><line x1="24" y1="19" x2="46" y2="19" stroke="#8B4513"/><line x1="24" y1="30" x2="46" y2="30" stroke="#8B4513"/><line x1="24" y1="41" x2="46" y2="41" stroke="#8B4513"/></svg>',
      'tile': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="2" width="14" height="14" fill="#E8E8E8" stroke="#CCC"/><rect x="17" y="2" width="14" height="14" fill="#F5F5F5" stroke="#CCC"/><rect x="32" y="2" width="14" height="14" fill="#E8E8E8" stroke="#CCC"/><rect x="2" y="17" width="14" height="14" fill="#F5F5F5" stroke="#CCC"/><rect x="17" y="17" width="14" height="14" fill="#E8E8E8" stroke="#CCC"/><rect x="32" y="17" width="14" height="14" fill="#F5F5F5" stroke="#CCC"/><rect x="2" y="32" width="14" height="14" fill="#E8E8E8" stroke="#CCC"/><rect x="17" y="32" width="14" height="14" fill="#F5F5F5" stroke="#CCC"/><rect x="32" y="32" width="14" height="14" fill="#E8E8E8" stroke="#CCC"/></svg>',
      'sink': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="16" width="40" height="24" rx="4" fill="#E0E0E0"/><rect x="8" y="20" width="32" height="16" rx="2" fill="#404040"/><ellipse cx="24" cy="28" rx="12" ry="6" fill="#505050"/><rect x="22" y="6" width="4" height="10" rx="2" fill="#C0C0C0"/><ellipse cx="24" cy="6" rx="3" ry="2" fill="#A0A0A0"/><circle cx="24" cy="28" r="2" fill="#303030"/></svg>',
      'sink-double': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="16" width="44" height="24" rx="4" fill="#E0E0E0"/><rect x="5" y="20" width="17" height="16" rx="2" fill="#404040"/><rect x="26" y="20" width="17" height="16" rx="2" fill="#404040"/><ellipse cx="13.5" cy="28" rx="6" ry="5" fill="#505050"/><ellipse cx="34.5" cy="28" rx="6" ry="5" fill="#505050"/><rect x="22" y="6" width="4" height="10" rx="2" fill="#C0C0C0"/><ellipse cx="24" cy="6" rx="3" ry="2" fill="#A0A0A0"/><circle cx="13.5" cy="28" r="1.5" fill="#303030"/><circle cx="34.5" cy="28" r="1.5" fill="#303030"/></svg>',
      'sink-farmhouse': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="14" width="40" height="28" rx="2" fill="#F5F5DC" stroke="#D4C8A8" stroke-width="2"/><rect x="6" y="16" width="36" height="24" fill="#FFFEF7"/><rect x="8" y="18" width="32" height="20" rx="1" fill="#404040"/><ellipse cx="24" cy="28" rx="12" ry="7" fill="#505050"/><rect x="22" y="4" width="4" height="12" rx="2" fill="#C0C0C0"/><ellipse cx="24" cy="4" rx="3" ry="2" fill="#A0A0A0"/><circle cx="24" cy="30" r="2" fill="#303030"/><path d="M4 20 L4 14 Q4 12 6 12 L42 12 Q44 12 44 14 L44 20" fill="none" stroke="#C9B896" stroke-width="2"/></svg>',
      'stove': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="8" width="40" height="36" rx="2" fill="#2a2a2a"/><rect x="6" y="10" width="36" height="16" rx="1" fill="#1a1a1a"/><circle cx="14" cy="18" r="5" fill="#333" stroke="#444" stroke-width="2"/><circle cx="34" cy="18" r="5" fill="#333" stroke="#444" stroke-width="2"/><rect x="8" y="28" width="32" height="14" rx="1" fill="#1a1a1a"/><rect x="12" y="30" width="24" height="10" rx="1" fill="#111"/></svg>',
      'refrigerator': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="8" y="2" width="32" height="44" rx="2" fill="#D0D0D0"/><rect x="10" y="4" width="28" height="14" rx="1" fill="#E0E0E0"/><rect x="10" y="20" width="28" height="24" rx="1" fill="#E0E0E0"/><rect x="34" y="8" width="2" height="6" rx="1" fill="#888"/><rect x="34" y="28" width="2" height="10" rx="1" fill="#888"/><line x1="10" y1="18" x2="38" y2="18" stroke="#999" stroke-width="2"/></svg>',
      'dishwasher': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="6" y="8" width="36" height="36" rx="2" fill="#A0A0A0"/><rect x="8" y="10" width="32" height="6" rx="1" fill="#606060"/><rect x="8" y="18" width="32" height="24" rx="1" fill="#B8B8B8"/><rect x="12" y="12" width="4" height="2" rx="1" fill="#888"/><rect x="18" y="12" width="4" height="2" rx="1" fill="#888"/><rect x="14" y="32" width="20" height="2" rx="1" fill="#909090"/></svg>',
      'microwave': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="12" width="40" height="24" rx="2" fill="#3a3a3a"/><rect x="6" y="14" width="26" height="20" rx="1" fill="#1a1a1a"/><rect x="8" y="16" width="22" height="16" rx="1" fill="#222"/><rect x="34" y="16" width="8" height="16" rx="1" fill="#4a4a4a"/><circle cx="38" cy="20" r="2" fill="#666"/><circle cx="38" cy="28" r="2" fill="#666"/></svg>',
      'range-hood': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><path d="M8 32 L16 12 L32 12 L40 32 Z" fill="#808080"/><rect x="6" y="32" width="36" height="8" rx="1" fill="#909090"/><rect x="20" y="4" width="8" height="8" fill="#707070"/><rect x="10" y="36" width="6" height="2" rx="1" fill="#606060"/><rect x="21" y="36" width="6" height="2" rx="1" fill="#606060"/><rect x="32" y="36" width="6" height="2" rx="1" fill="#606060"/></svg>',
      'oven': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="6" y="4" width="36" height="40" rx="2" fill="#2a2a2a"/><rect x="8" y="6" width="32" height="8" rx="1" fill="#3a3a3a"/><rect x="8" y="16" width="32" height="26" rx="1" fill="#1a1a1a"/><rect x="12" y="20" width="24" height="18" rx="1" fill="#222"/><rect x="14" y="8" width="20" height="4" rx="1" fill="#444"/></svg>',
      'door': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="8" y="4" width="32" height="40" rx="1" fill="#DEB887"/><rect x="10" y="6" width="12" height="16" rx="1" fill="#D2B48C"/><rect x="26" y="6" width="12" height="16" rx="1" fill="#D2B48C"/><rect x="10" y="26" width="12" height="16" rx="1" fill="#D2B48C"/><rect x="26" y="26" width="12" height="16" rx="1" fill="#D2B48C"/><circle cx="36" cy="26" r="2" fill="#FFD700"/></svg>',
      'double-door': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="4" width="18" height="40" rx="1" fill="#DEB887"/><rect x="26" y="4" width="18" height="40" rx="1" fill="#DEB887"/><rect x="6" y="8" width="14" height="32" rx="1" fill="#D2B48C"/><rect x="28" y="8" width="14" height="32" rx="1" fill="#D2B48C"/><circle cx="18" cy="26" r="2" fill="#FFD700"/><circle cx="30" cy="26" r="2" fill="#FFD700"/></svg>',
      'sliding-door': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="4" width="44" height="40" rx="1" fill="#BC8F8F"/><rect x="4" y="6" width="20" height="36" fill="#ADD8E6" opacity="0.6"/><rect x="24" y="6" width="20" height="36" fill="#ADD8E6" opacity="0.4"/><line x1="24" y1="6" x2="24" y2="42" stroke="#888" stroke-width="2"/><rect x="4" y="42" width="40" height="2" fill="#666"/></svg>',
      'entry-archway': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><path d="M4 44 L4 16 Q4 4 24 4 Q44 4 44 16 L44 44" fill="none" stroke="#DAA520" stroke-width="4"/><path d="M8 44 L8 18 Q8 8 24 8 Q40 8 40 18 L40 44" fill="#F5DEB3" opacity="0.3"/></svg>',
      'garage-door': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="4" width="44" height="40" rx="1" fill="#A9A9A9"/><rect x="4" y="6" width="40" height="8" fill="#888"/><rect x="4" y="16" width="40" height="8" fill="#999"/><rect x="4" y="26" width="40" height="8" fill="#888"/><rect x="4" y="36" width="40" height="6" fill="#999"/><rect x="20" y="38" width="8" height="2" fill="#666"/></svg>',
      'window': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="8" width="40" height="32" rx="2" fill="#FFF"/><rect x="6" y="10" width="17" height="13" fill="#87CEEB"/><rect x="25" y="10" width="17" height="13" fill="#87CEEB"/><rect x="6" y="25" width="17" height="13" fill="#87CEEB"/><rect x="25" y="25" width="17" height="13" fill="#87CEEB"/><line x1="24" y1="10" x2="24" y2="38" stroke="#FFF" stroke-width="2"/><line x1="6" y1="24" x2="42" y2="24" stroke="#FFF" stroke-width="2"/></svg>',
      'wall': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="4" width="40" height="8" fill="#666"/><rect x="4" y="14" width="18" height="8" fill="#555"/><rect x="24" y="14" width="20" height="8" fill="#555"/><rect x="4" y="24" width="40" height="8" fill="#666"/><rect x="4" y="34" width="18" height="8" fill="#555"/><rect x="24" y="34" width="20" height="8" fill="#555"/></svg>',
      'wall-wood-2x4': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="8" y="2" width="6" height="44" fill="#DEB887"/><rect x="20" y="2" width="6" height="44" fill="#DEB887"/><rect x="32" y="2" width="6" height="44" fill="#DEB887"/><rect x="6" y="10" width="36" height="4" fill="#D2B48C"/><rect x="6" y="32" width="36" height="4" fill="#D2B48C"/></svg>',
      'wall-wood-2x6': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="6" y="2" width="8" height="44" fill="#CD853F"/><rect x="20" y="2" width="8" height="44" fill="#CD853F"/><rect x="34" y="2" width="8" height="44" fill="#CD853F"/><rect x="4" y="10" width="40" height="5" fill="#DEB887"/><rect x="4" y="32" width="40" height="5" fill="#DEB887"/></svg>',
      'wall-steel': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="10" y="2" width="4" height="44" fill="#708090"/><rect x="22" y="2" width="4" height="44" fill="#708090"/><rect x="34" y="2" width="4" height="44" fill="#708090"/><rect x="8" y="8" width="32" height="3" fill="#A9A9A9"/><rect x="8" y="36" width="32" height="3" fill="#A9A9A9"/><circle cx="12" cy="10" r="2" fill="#666"/><circle cx="24" cy="10" r="2" fill="#666"/><circle cx="36" cy="10" r="2" fill="#666"/></svg>',
      'wall-aluminum': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="10" y="2" width="3" height="44" fill="#C0C0C0"/><rect x="22" y="2" width="3" height="44" fill="#C0C0C0"/><rect x="34" y="2" width="3" height="44" fill="#C0C0C0"/><rect x="8" y="6" width="32" height="2" fill="#D3D3D3"/><rect x="8" y="22" width="32" height="2" fill="#D3D3D3"/><rect x="8" y="38" width="32" height="2" fill="#D3D3D3"/></svg>',
      'wall-concrete': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="4" width="40" height="40" fill="#808080"/><circle cx="12" cy="12" r="2" fill="#696969"/><circle cx="28" cy="18" r="3" fill="#696969"/><circle cx="18" cy="32" r="2" fill="#696969"/><circle cx="36" cy="28" r="2" fill="#696969"/><circle cx="24" cy="38" r="2" fill="#696969"/></svg>',
      'wall-brick': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="4" width="10" height="6" fill="#B22222"/><rect x="14" y="4" width="10" height="6" fill="#B22222"/><rect x="26" y="4" width="10" height="6" fill="#B22222"/><rect x="38" y="4" width="8" height="6" fill="#B22222"/><rect x="2" y="12" width="5" height="6" fill="#CD5C5C"/><rect x="9" y="12" width="10" height="6" fill="#CD5C5C"/><rect x="21" y="12" width="10" height="6" fill="#CD5C5C"/><rect x="33" y="12" width="10" height="6" fill="#CD5C5C"/><rect x="2" y="20" width="10" height="6" fill="#B22222"/><rect x="14" y="20" width="10" height="6" fill="#B22222"/><rect x="26" y="20" width="10" height="6" fill="#B22222"/><rect x="38" y="20" width="8" height="6" fill="#B22222"/><rect x="2" y="28" width="5" height="6" fill="#CD5C5C"/><rect x="9" y="28" width="10" height="6" fill="#CD5C5C"/><rect x="21" y="28" width="10" height="6" fill="#CD5C5C"/><rect x="33" y="28" width="10" height="6" fill="#CD5C5C"/><rect x="2" y="36" width="10" height="6" fill="#B22222"/><rect x="14" y="36" width="10" height="6" fill="#B22222"/><rect x="26" y="36" width="10" height="6" fill="#B22222"/><rect x="38" y="36" width="8" height="6" fill="#B22222"/></svg>',
      'wall-block': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="4" width="14" height="10" fill="#696969" stroke="#555"/><rect x="18" y="4" width="14" height="10" fill="#696969" stroke="#555"/><rect x="34" y="4" width="12" height="10" fill="#696969" stroke="#555"/><rect x="2" y="16" width="14" height="10" fill="#787878" stroke="#555"/><rect x="18" y="16" width="14" height="10" fill="#787878" stroke="#555"/><rect x="34" y="16" width="12" height="10" fill="#787878" stroke="#555"/><rect x="2" y="28" width="14" height="10" fill="#696969" stroke="#555"/><rect x="18" y="28" width="14" height="10" fill="#696969" stroke="#555"/><rect x="34" y="28" width="12" height="10" fill="#696969" stroke="#555"/></svg>',
      'steel-beam': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="18" width="40" height="12" fill="#4A4A4A"/><rect x="4" y="18" width="40" height="3" fill="#5A5A5A"/><rect x="4" y="27" width="40" height="3" fill="#3A3A3A"/><rect x="4" y="22" width="40" height="4" fill="#606060"/></svg>',
      'steel-column': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="16" y="4" width="16" height="40" fill="#4A4A4A"/><rect x="16" y="4" width="4" height="40" fill="#5A5A5A"/><rect x="28" y="4" width="4" height="40" fill="#3A3A3A"/><rect x="20" y="4" width="8" height="40" fill="#555"/></svg>',
      'wood-beam': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="18" width="40" height="12" fill="#8B6914" rx="1"/><line x1="8" y1="20" x2="8" y2="28" stroke="#6B4914" stroke-width="1"/><line x1="18" y1="20" x2="18" y2="28" stroke="#6B4914" stroke-width="1"/><line x1="28" y1="20" x2="28" y2="28" stroke="#6B4914" stroke-width="1"/><line x1="38" y1="20" x2="38" y2="28" stroke="#6B4914" stroke-width="1"/></svg>',
      'wood-post': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="16" y="4" width="16" height="40" fill="#8B6914" rx="1"/><line x1="20" y1="8" x2="20" y2="40" stroke="#6B4914" stroke-width="1"/><line x1="24" y1="8" x2="24" y2="40" stroke="#6B4914" stroke-width="1"/><line x1="28" y1="8" x2="28" y2="40" stroke="#6B4914" stroke-width="1"/></svg>',
      'concrete-beam': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="16" width="40" height="16" fill="#707070"/><circle cx="12" cy="22" r="2" fill="#606060"/><circle cx="28" cy="26" r="2" fill="#606060"/><circle cx="38" cy="22" r="2" fill="#808080"/></svg>',
      'concrete-column': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="12" y="4" width="24" height="40" fill="#707070"/><circle cx="20" cy="14" r="2" fill="#606060"/><circle cx="28" cy="28" r="2" fill="#606060"/><circle cx="22" cy="38" r="2" fill="#808080"/></svg>',
      'header': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="18" width="40" height="12" fill="#CD853F" rx="1"/><line x1="4" y1="24" x2="44" y2="24" stroke="#8B6914" stroke-width="1"/><rect x="4" y="18" width="40" height="2" fill="#DEB887"/></svg>',
      'lvl-beam': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="14" width="40" height="20" fill="#DEB887"/><line x1="4" y1="18" x2="44" y2="18" stroke="#C4A76C" stroke-width="1"/><line x1="4" y1="22" x2="44" y2="22" stroke="#C4A76C" stroke-width="1"/><line x1="4" y1="26" x2="44" y2="26" stroke="#C4A76C" stroke-width="1"/><line x1="4" y1="30" x2="44" y2="30" stroke="#C4A76C" stroke-width="1"/></svg>',
      'surface-stainless': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="16" width="44" height="16" rx="1" fill="#C0C0C0"/><line x1="4" y1="20" x2="44" y2="20" stroke="#D8D8D8" stroke-width="1"/><line x1="4" y1="24" x2="44" y2="24" stroke="#D8D8D8" stroke-width="1"/><line x1="4" y1="28" x2="44" y2="28" stroke="#D8D8D8" stroke-width="1"/><rect x="2" y="16" width="44" height="3" fill="#E0E0E0"/><rect x="2" y="29" width="44" height="3" fill="#A0A0A0"/></svg>',
      'surface-solid': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="16" width="44" height="16" rx="2" fill="#E8E4E0"/><rect x="2" y="16" width="44" height="2" fill="#F0ECE8"/><rect x="2" y="30" width="44" height="2" fill="#D8D4D0"/></svg>',
      'surface-laminate': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="18" width="44" height="12" fill="#D4C4A8"/><rect x="2" y="16" width="44" height="3" fill="#E8D8BC"/><rect x="2" y="29" width="44" height="3" fill="#4A4A4A"/><line x1="12" y1="18" x2="12" y2="30" stroke="#C4B498" stroke-width="1"/><line x1="24" y1="18" x2="24" y2="30" stroke="#C4B498" stroke-width="1"/><line x1="36" y1="18" x2="36" y2="30" stroke="#C4B498" stroke-width="1"/></svg>',
      'surface-butcherblock': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="16" width="44" height="16" fill="#C4A76C"/><line x1="8" y1="16" x2="8" y2="32" stroke="#8B6914" stroke-width="1"/><line x1="14" y1="16" x2="14" y2="32" stroke="#8B6914" stroke-width="1"/><line x1="20" y1="16" x2="20" y2="32" stroke="#8B6914" stroke-width="1"/><line x1="26" y1="16" x2="26" y2="32" stroke="#8B6914" stroke-width="1"/><line x1="32" y1="16" x2="32" y2="32" stroke="#8B6914" stroke-width="1"/><line x1="38" y1="16" x2="38" y2="32" stroke="#8B6914" stroke-width="1"/><rect x="2" y="16" width="44" height="2" fill="#D4B77C"/></svg>',
      'surface-concrete': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="16" width="44" height="16" fill="#808080"/><circle cx="10" cy="22" r="2" fill="#707070"/><circle cx="28" cy="26" r="3" fill="#707070"/><circle cx="38" cy="20" r="2" fill="#909090"/><circle cx="18" cy="28" r="2" fill="#909090"/></svg>',
      'glass-door': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="8" y="4" width="32" height="40" rx="1" fill="#FFF"/><rect x="10" y="6" width="28" height="36" fill="#ADD8E6" opacity="0.5"/><rect x="12" y="8" width="24" height="32" fill="#87CEEB" opacity="0.3"/><rect x="34" y="20" width="2" height="10" rx="1" fill="#C0C0C0"/></svg>',
      'french-door': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="4" width="40" height="40" rx="1" fill="#F5F5DC"/><rect x="6" y="6" width="17" height="36" fill="#ADD8E6" opacity="0.4"/><rect x="25" y="6" width="17" height="36" fill="#ADD8E6" opacity="0.4"/><line x1="24" y1="6" x2="24" y2="42" stroke="#F5F5DC" stroke-width="3"/><line x1="6" y1="16" x2="23" y2="16" stroke="#F5F5DC" stroke-width="2"/><line x1="6" y1="28" x2="23" y2="28" stroke="#F5F5DC" stroke-width="2"/><line x1="25" y1="16" x2="42" y2="16" stroke="#F5F5DC" stroke-width="2"/><line x1="25" y1="28" x2="42" y2="28" stroke="#F5F5DC" stroke-width="2"/></svg>',
      'window-large': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="8" width="44" height="32" rx="2" fill="#FFF"/><rect x="4" y="10" width="40" height="28" fill="#87CEEB"/><rect x="4" y="26" width="40" height="12" fill="#90EE90" opacity="0.5"/></svg>',
      'window-bay': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><path d="M8 8 L18 4 L30 4 L40 8 L40 40 L8 40 Z" fill="#FFF"/><path d="M10 10 L17 6 L31 6 L38 10 L38 38 L10 38 Z" fill="#87CEEB"/><line x1="17" y1="6" x2="14" y2="38" stroke="#FFF" stroke-width="2"/><line x1="31" y1="6" x2="34" y2="38" stroke="#FFF" stroke-width="2"/></svg>',
      'crown-molding': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="18" width="44" height="12" fill="#F5F5F5"/><path d="M2 18 Q24 14 46 18" fill="none" stroke="#E0E0E0" stroke-width="2"/><line x1="2" y1="22" x2="46" y2="22" stroke="#DDD" stroke-width="1"/><line x1="2" y1="26" x2="46" y2="26" stroke="#DDD" stroke-width="1"/></svg>',
      'baseboard': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="28" width="44" height="16" fill="#F5F5F5"/><line x1="2" y1="32" x2="46" y2="32" stroke="#E0E0E0" stroke-width="1"/><line x1="2" y1="36" x2="46" y2="36" stroke="#E0E0E0" stroke-width="1"/><rect x="2" y="42" width="44" height="2" fill="#DDD"/></svg>',
      'chair-rail': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="20" width="44" height="8" fill="#F5F5F5"/><path d="M2 20 Q24 18 46 20" fill="none" stroke="#E8E8E8" stroke-width="1"/><line x1="2" y1="24" x2="46" y2="24" stroke="#DDD" stroke-width="1"/></svg>',
      'countertop-l': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><path d="M4 4 L4 44 L28 44 L28 24 L44 24 L44 4 Z" fill="#708090"/><path d="M6 6 L6 42 L26 42 L26 22 L42 22 L42 6 Z" fill="#5a6a7a"/></svg>',
      'countertop-u': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><path d="M4 4 L4 44 L44 44 L44 4 L34 4 L34 34 L14 34 L14 4 Z" fill="#708090"/><path d="M6 6 L6 42 L42 42 L42 6 L32 6 L32 32 L16 32 L16 6 Z" fill="#5a6a7a"/></svg>',
      // Pony Walls & Half Walls
      'pony-wall': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="20" width="40" height="24" fill="#888"/><rect x="2" y="18" width="44" height="4" fill="#708090" rx="1"/><rect x="4" y="44" width="40" height="2" fill="#666"/></svg>',
      'pony-wall-bar': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="16" width="40" height="28" fill="#888"/><rect x="2" y="14" width="44" height="4" fill="#708090" rx="1"/><rect x="0" y="12" width="48" height="4" fill="#5a6a7a" rx="1"/><rect x="4" y="44" width="40" height="2" fill="#666"/></svg>',
      'knee-wall': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="28" width="40" height="16" fill="#888"/><rect x="2" y="26" width="44" height="4" fill="#708090" rx="1"/><rect x="4" y="44" width="40" height="2" fill="#666"/></svg>',
      // Niches & Recesses
      'wall-niche': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="4" width="40" height="40" fill="#888"/><rect x="10" y="10" width="28" height="28" fill="#333"/><rect x="12" y="12" width="24" height="24" fill="#222"/></svg>',
      'fireplace-niche': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="8" width="40" height="36" fill="#888"/><rect x="8" y="12" width="32" height="28" fill="#333"/><rect x="10" y="14" width="28" height="24" fill="#1a1a1a"/><ellipse cx="24" cy="32" rx="8" ry="4" fill="#FF4500" opacity="0.8"/><ellipse cx="24" cy="30" rx="5" ry="3" fill="#FFD700" opacity="0.6"/></svg>',
      'tv-niche': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="8" width="40" height="32" fill="#888"/><rect x="8" y="12" width="32" height="24" fill="#222"/><rect x="10" y="14" width="28" height="20" fill="#1a1a1a"/><rect x="12" y="16" width="24" height="16" fill="#333" stroke="#444"/></svg>',
      'shower-niche': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="10" y="8" width="28" height="32" fill="#87CEEB"/><rect x="14" y="12" width="20" height="24" fill="#555"/><rect x="16" y="14" width="16" height="20" fill="#444"/><ellipse cx="24" cy="24" rx="4" ry="2" fill="#666"/></svg>',
      'grab-bar': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="20" width="40" height="8" rx="4" fill="#C0C0C0"/><circle cx="8" cy="24" r="5" fill="#888"/><circle cx="40" cy="24" r="5" fill="#888"/><rect x="8" y="21" width="32" height="2" fill="#E0E0E0"/></svg>',
      // Stone Caps & Ledges
      'wall-cap': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="20" width="44" height="8" fill="#708090" rx="1"/><path d="M2 28 Q24 30 46 28" fill="#5a6a7a"/><rect x="4" y="26" width="40" height="16" fill="#aaa" opacity="0.3"/></svg>',
      'bar-top': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="18" width="44" height="6" fill="#708090" rx="1"/><path d="M2 24 Q24 26 46 24" fill="#5a6a7a"/><rect x="0" y="16" width="48" height="4" fill="#5a6a7a" rx="1"/><rect x="6" y="22" width="36" height="20" fill="#888" opacity="0.3"/></svg>',
      'niche-surround': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="4" width="8" height="40" fill="#708090"/><rect x="36" y="4" width="8" height="40" fill="#708090"/><rect x="4" y="4" width="40" height="8" fill="#708090"/><rect x="4" y="36" width="40" height="8" fill="#708090"/><rect x="12" y="12" width="24" height="24" fill="#333"/></svg>',
      'fireplace-surround': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="4" width="10" height="40" fill="#708090"/><rect x="36" y="4" width="10" height="40" fill="#708090"/><rect x="2" y="4" width="44" height="8" fill="#708090"/><rect x="2" y="36" width="44" height="8" fill="#5a6a7a"/><rect x="12" y="12" width="24" height="24" fill="#1a1a1a"/><ellipse cx="24" cy="30" rx="6" ry="3" fill="#FF4500" opacity="0.7"/></svg>',
      'fireplace-hearth': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="28" width="44" height="16" fill="#708090" rx="1"/><rect x="4" y="20" width="40" height="10" fill="#5a6a7a"/><path d="M2 44 Q24 46 46 44" fill="#4a5a6a"/></svg>',
      'mantel': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="18" width="44" height="6" fill="#8B4513" rx="1"/><rect x="6" y="24" width="6" height="16" fill="#A0522D"/><rect x="36" y="24" width="6" height="16" fill="#A0522D"/><rect x="0" y="16" width="48" height="4" fill="#A0522D" rx="1"/></svg>',
      'window-sill': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="8" y="8" width="32" height="24" fill="#87CEEB" stroke="#FFF" stroke-width="2"/><rect x="4" y="32" width="40" height="6" fill="#708090" rx="1"/><path d="M4 38 Q24 40 44 38" fill="#5a6a7a"/></svg>',
      'threshold': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="20" width="40" height="8" fill="#708090" rx="1"/><rect x="2" y="10" width="4" height="28" fill="#DEB887"/><rect x="42" y="10" width="4" height="28" fill="#DEB887"/><path d="M4 28 Q24 30 44 28" fill="#5a6a7a"/></svg>'
    };

    const ELEMENT_TYPES = {
      cabinets: [
        { type: 'base-cabinet', width: 3, height: 2, color: '#8B4513', label: 'Base Cabinet' },
        { type: 'drawer-base', width: 2, height: 2, color: '#8B4513', label: 'Drawer Base' },
        { type: 'sink-base', width: 3, height: 2, color: '#8B4513', label: 'Sink Base' },
        { type: 'wall-cabinet', width: 3, height: 1.5, color: '#A0522D', label: 'Wall Cabinet' },
        { type: 'tall-cabinet', width: 2, height: 7, color: '#8B4513', label: 'Tall Cabinet' },
        { type: 'fridge-cabinet', width: 3, height: 7, color: '#8B4513', label: 'Fridge Cabinet' },
        { type: 'corner-cabinet', width: 3, height: 3, color: '#7B3F00', label: 'Corner Cabinet' },
        { type: 'lazy-susan', width: 3, height: 3, color: '#7B3F00', label: 'Lazy Susan' },
        { type: 'island', width: 6, height: 3, color: '#654321', label: 'Island' }
      ],
      surfaces: [
        { type: 'countertop', width: 8, height: 2, color: '#708090', label: 'Countertop' },
        { type: 'countertop-l', width: 6, height: 6, color: '#708090', label: 'L-Counter' },
        { type: 'countertop-u', width: 8, height: 6, color: '#708090', label: 'U-Counter' },
        // Material-specific surfaces
        { type: 'surface-stainless', width: 4, height: 2, color: '#C0C0C0', label: 'Stainless Steel' },
        { type: 'surface-solid', width: 4, height: 2, color: '#E8E4E0', label: 'Solid Surface' },
        { type: 'surface-laminate', width: 4, height: 2, color: '#D4C4A8', label: 'Laminate/Formica' },
        { type: 'surface-butcherblock', width: 3, height: 2, color: '#C4A76C', label: 'Butcher Block' },
        { type: 'surface-concrete', width: 4, height: 2, color: '#808080', label: 'Concrete' },
        { type: 'backsplash', width: 6, height: 1.5, color: '#B8860B', label: 'Backsplash' },
        { type: 'flooring', width: 5, height: 5, color: '#D2691E', label: 'Flooring' },
        { type: 'tile', width: 4, height: 4, color: '#CCC', label: 'Tile Area' },
        // Stone Caps & Ledges (for pony walls, entryways, etc.)
        { type: 'wall-cap', width: 4, height: 0.5, color: '#708090', label: 'Wall Cap/Ledge', capHeight: 3.5, thickness: 0.125 },
        { type: 'bar-top', width: 6, height: 1.5, color: '#708090', label: 'Bar Top', capHeight: 3.5, thickness: 0.125 },
        // Stone Bezels & Surrounds (for niches, fireplaces)
        { type: 'niche-surround', width: 3, height: 4, color: '#708090', label: 'Niche Surround' },
        { type: 'fireplace-surround', width: 5, height: 4, color: '#708090', label: 'Fireplace Surround' },
        { type: 'fireplace-hearth', width: 5, height: 1.5, color: '#708090', label: 'Hearth' },
        { type: 'mantel', width: 5, height: 0.5, color: '#8B4513', label: 'Mantel/Shelf' },
        // Window & Door Sills
        { type: 'window-sill', width: 3, height: 0.5, color: '#708090', label: 'Window Sill' },
        { type: 'threshold', width: 3, height: 0.33, color: '#708090', label: 'Door Threshold' }
      ],
      appliances: [
        { type: 'sink', width: 2.75, height: 1.83, color: '#C0C0C0', label: 'Single Sink' },
        { type: 'sink-double', width: 3, height: 1.83, color: '#C0C0C0', label: 'Double Sink' },
        { type: 'sink-farmhouse', width: 2.5, height: 1.75, color: '#F5F5DC', label: 'Farmhouse Sink' },
        { type: 'stove', width: 2.5, height: 2.5, color: '#2F2F2F', label: 'Stove/Range' },
        { type: 'refrigerator', width: 3, height: 3, color: '#A9A9A9', label: 'Refrigerator' },
        { type: 'dishwasher', width: 2, height: 2, color: '#808080', label: 'Dishwasher' },
        { type: 'microwave', width: 2, height: 1.5, color: '#4a4a4a', label: 'Microwave' },
        { type: 'range-hood', width: 2.5, height: 1.5, color: '#696969', label: 'Range Hood' },
        { type: 'oven', width: 2.5, height: 2.5, color: '#3a3a3a', label: 'Wall Oven' }
      ],
      structure: [
        // Doors & Entryways
        { type: 'door', width: 3, height: 0.5, color: '#DEB887', label: 'Standard Door' },
        { type: 'double-door', width: 5, height: 0.5, color: '#D2B48C', label: 'Double Door' },
        { type: 'sliding-door', width: 6, height: 0.5, color: '#BC8F8F', label: 'Sliding Door' },
        { type: 'glass-door', width: 3, height: 0.5, color: '#ADD8E6', label: 'Glass Door' },
        { type: 'french-door', width: 5, height: 0.5, color: '#F5F5DC', label: 'French Door' },
        { type: 'entry-archway', width: 4, height: 0.5, color: '#DAA520', label: 'Archway' },
        { type: 'garage-door', width: 8, height: 0.5, color: '#A9A9A9', label: 'Garage Door' },
        // Windows
        { type: 'window', width: 4, height: 0.5, color: '#87CEEB', label: 'Window' },
        { type: 'window-large', width: 6, height: 0.5, color: '#87CEEB', label: 'Picture Window' },
        { type: 'window-bay', width: 5, height: 1, color: '#87CEEB', label: 'Bay Window' },
        // Trim & Molding
        { type: 'crown-molding', width: 10, height: 0.25, color: '#F5F5F5', label: 'Crown Molding' },
        { type: 'baseboard', width: 10, height: 0.15, color: '#F5F5F5', label: 'Baseboard' },
        { type: 'chair-rail', width: 10, height: 0.1, color: '#F5F5F5', label: 'Chair Rail' },
        // Walls - Residential
        { type: 'wall', width: 0.5, height: 8, color: '#555', label: 'Wall (Drywall)' },
        { type: 'wall-wood-2x4', width: 0.33, height: 8, color: '#8B7355', label: 'Wall (2x4 Wood)' },
        { type: 'wall-wood-2x6', width: 0.5, height: 8, color: '#8B6914', label: 'Wall (2x6 Wood)' },
        // Walls - Commercial
        { type: 'wall-steel', width: 0.33, height: 10, color: '#708090', label: 'Wall (Steel Frame)' },
        { type: 'wall-aluminum', width: 0.33, height: 10, color: '#C0C0C0', label: 'Wall (Aluminum)' },
        // Walls - Masonry
        { type: 'wall-concrete', width: 0.67, height: 8, color: '#808080', label: 'Wall (Concrete)' },
        { type: 'wall-brick', width: 0.67, height: 8, color: '#B22222', label: 'Wall (Brick)' },
        { type: 'wall-block', width: 0.67, height: 8, color: '#696969', label: 'Wall (CMU Block)' },
        // Structural - Beams & Columns
        { type: 'steel-beam', width: 8, height: 0.67, color: '#4A4A4A', label: 'Steel I-Beam' },
        { type: 'steel-column', width: 0.5, height: 0.5, color: '#4A4A4A', label: 'Steel Column' },
        { type: 'wood-beam', width: 6, height: 0.5, color: '#8B6914', label: 'Wood Beam' },
        { type: 'wood-post', width: 0.33, height: 0.33, color: '#8B6914', label: 'Wood Post 4x4' },
        { type: 'concrete-beam', width: 8, height: 0.83, color: '#707070', label: 'Concrete Beam' },
        { type: 'concrete-column', width: 1, height: 1, color: '#707070', label: 'Concrete Column' },
        { type: 'header', width: 4, height: 0.33, color: '#CD853F', label: 'Header/Lintel' },
        { type: 'lvl-beam', width: 8, height: 0.92, color: '#DEB887', label: 'LVL Beam' },
        // Pony Walls & Half Walls (for stone caps)
        { type: 'pony-wall', width: 4, height: 0.5, color: '#888', label: 'Pony Wall', wallHeight: 3.5 },
        { type: 'pony-wall-bar', width: 6, height: 0.5, color: '#888', label: 'Bar Height Wall', wallHeight: 3.5 },
        { type: 'knee-wall', width: 4, height: 0.5, color: '#888', label: 'Knee Wall', wallHeight: 2.5 },
        // Niches & Recesses (for stone bezels/surrounds)
        { type: 'wall-niche', width: 3, height: 4, color: '#444', label: 'Wall Niche' },
        { type: 'fireplace-niche', width: 4, height: 3, color: '#333', label: 'Fireplace Recess' },
        { type: 'tv-niche', width: 5, height: 3, color: '#222', label: 'TV Recess' },
        { type: 'shower-niche', width: 1, height: 1.5, color: '#555', label: 'Shower Niche' },
        // Shower Components
        { type: 'shower-pan', width: 4, height: 3, color: '#D0D0D0', label: 'Shower Pan' },
        { type: 'shower-curb', width: 4, height: 0.5, color: '#808080', label: 'Shower Curb' },
        { type: 'shower-wall', width: 4, height: 0.35, color: '#B0B0B0', label: 'Shower Wall Panel' },
        // Tile Surfaces
        { type: 'wall-tile', width: 4, height: 4, color: '#CCC', label: 'Wall Tile Panel' },
        { type: 'accent-wall', width: 6, height: 0.5, color: '#888', label: 'Accent Wall' },
        // ADA Accessibility
        { type: 'grab-bar', width: 2, height: 0.25, color: '#C0C0C0', label: 'Grab Bar 24"' },
        { type: 'grab-bar', width: 3, height: 0.25, color: '#C0C0C0', label: 'Grab Bar 36"' },
        { type: 'grab-bar', width: 3.5, height: 0.25, color: '#C0C0C0', label: 'Grab Bar 42"' }
      ],
      bathroom: [
        // Toilets
        { type: 'toilet', width: 1.5, height: 2.3, color: '#FFFFFF', label: 'Toilet (Elongated)' },
        { type: 'toilet-round', width: 1.5, height: 2, color: '#FFFFFF', label: 'Toilet (Round)' },
        { type: 'toilet-wall', width: 1.5, height: 1.8, color: '#FFFFFF', label: 'Wall-Hung Toilet' },
        { type: 'bidet', width: 1.5, height: 2, color: '#FFFFFF', label: 'Bidet' },
        // Bathtubs
        { type: 'bathtub', width: 5, height: 2.7, color: '#F5F5F5', label: 'Alcove Tub (60")' },
        { type: 'bathtub-freestanding', width: 5.5, height: 2.5, color: '#FFFFFF', label: 'Freestanding Tub' },
        { type: 'bathtub-corner', width: 5, height: 5, color: '#F5F5F5', label: 'Corner Tub' },
        { type: 'bathtub-walk-in', width: 4.5, height: 2.5, color: '#F0F0F0', label: 'Walk-in Tub' },
        // Vanities
        { type: 'vanity-24', width: 2, height: 1.75, color: '#8B7355', label: 'Vanity 24"' },
        { type: 'vanity-30', width: 2.5, height: 1.75, color: '#8B7355', label: 'Vanity 30"' },
        { type: 'vanity-36', width: 3, height: 1.75, color: '#8B7355', label: 'Vanity 36"' },
        { type: 'vanity-48', width: 4, height: 1.75, color: '#8B7355', label: 'Vanity 48"' },
        { type: 'vanity-60', width: 5, height: 1.75, color: '#8B7355', label: 'Double Vanity 60"' },
        { type: 'vanity-72', width: 6, height: 1.75, color: '#8B7355', label: 'Double Vanity 72"' },
        // Shower Components
        { type: 'shower-base-36', width: 3, height: 3, color: '#D0D0D0', label: 'Shower Base 36x36' },
        { type: 'shower-base-48', width: 4, height: 3, color: '#D0D0D0', label: 'Shower Base 48x36' },
        { type: 'shower-base-60', width: 5, height: 3, color: '#D0D0D0', label: 'Shower Base 60x36' },
        { type: 'shower-bench', width: 2, height: 1.5, color: '#A0A0A0', label: 'Shower Bench' },
        { type: 'shower-glass', width: 3, height: 0.15, color: '#B8E0FF', label: 'Glass Panel' },
        { type: 'shower-door', width: 2.5, height: 0.15, color: '#C4E8FF', label: 'Shower Door' },
        // Accessories
        { type: 'mirror', width: 3, height: 0.15, color: '#E8E8FF', label: 'Mirror' },
        { type: 'medicine-cabinet', width: 2, height: 0.5, color: '#C0C0C0', label: 'Medicine Cabinet' },
        { type: 'towel-bar', width: 2, height: 0.15, color: '#C0C0C0', label: 'Towel Bar' },
        { type: 'toilet-paper', width: 0.5, height: 0.5, color: '#A0A0A0', label: 'TP Holder' }
      ],
      laundry: [
        { type: 'washer', width: 2.3, height: 2.3, color: '#E8E8E8', label: 'Washer' },
        { type: 'dryer', width: 2.3, height: 2.3, color: '#E0E0E0', label: 'Dryer' },
        { type: 'washer-dryer-stack', width: 2.3, height: 2.3, color: '#E8E8E8', label: 'Stacked W/D' },
        { type: 'utility-sink', width: 2, height: 2, color: '#D0D0D0', label: 'Utility Sink' },
        { type: 'laundry-cabinet', width: 3, height: 2, color: '#8B7355', label: 'Laundry Cabinet' },
        { type: 'ironing-board', width: 1, height: 4, color: '#C0C0C0', label: 'Ironing Board' },
        { type: 'drying-rack', width: 2, height: 3, color: '#A0A0A0', label: 'Drying Rack' }
      ],
      closet: [
        { type: 'closet-rod', width: 4, height: 0.15, color: '#C0C0C0', label: 'Closet Rod' },
        { type: 'closet-shelf', width: 4, height: 1, color: '#D4C4A8', label: 'Shelf' },
        { type: 'closet-drawers', width: 2, height: 2, color: '#8B7355', label: 'Drawer Unit' },
        { type: 'shoe-rack', width: 3, height: 1.5, color: '#A0A0A0', label: 'Shoe Rack' },
        { type: 'closet-island', width: 3, height: 2, color: '#8B7355', label: 'Closet Island' },
        { type: 'jewelry-drawer', width: 2, height: 0.5, color: '#8B7355', label: 'Jewelry Drawer' },
        { type: 'tie-rack', width: 1.5, height: 2, color: '#A0A0A0', label: 'Tie/Belt Rack' },
        { type: 'full-mirror', width: 2, height: 0.15, color: '#E8E8FF', label: 'Full-Length Mirror' }
      ]
    };

    const FLOOR_PLANS = [
      { id: 'empty', name: 'Empty', walls: [] },
      { id: 'square', name: 'Square', walls: [
        { x: 0, y: 0, w: 1, h: 1, type: 'full' }
      ]},
      { id: 'l-shape', name: 'L-Shape', walls: [
        { x: 0, y: 0, w: 0.6, h: 1, type: 'rect' },
        { x: 0, y: 0, w: 1, h: 0.5, type: 'rect' }
      ]},
      { id: 'u-shape', name: 'U-Shape', walls: [
        { x: 0, y: 0, w: 0.3, h: 1, type: 'rect' },
        { x: 0.7, y: 0, w: 0.3, h: 1, type: 'rect' },
        { x: 0, y: 0.7, w: 1, h: 0.3, type: 'rect' }
      ]},
      { id: 'galley', name: 'Galley', walls: [
        { x: 0, y: 0, w: 0.2, h: 1, type: 'rect' },
        { x: 0.8, y: 0, w: 0.2, h: 1, type: 'rect' }
      ]},
      { id: 'open', name: 'Open Plan', walls: [
        { x: 0, y: 0.7, w: 0.4, h: 0.3, type: 'rect' }
      ]}
    ];

    // Helper function to resolve asset URLs for both file:// and http:// protocols
    function resolveAssetUrl(url) {
      if (!url) return null;
      if (url.startsWith('http') || url.startsWith('data:') || url.startsWith('blob:')) {
        return url;
      }
      // For local file:// protocol, construct absolute path
      if (window.location.protocol === 'file:') {
        const basePath = window.location.href.replace(/\/tools\/room-designer\/.*$/, '');
        return basePath + url;
      }
      // For http/https, relative paths work
      return url;
    }

    // Materials library using actual Surprise Granite product images + Daltile CTF Price List
    const MATERIALS = {
      granite: [
        // Surprise Granite Collection
        { id: 'granite-blackwood', name: 'Blackwood', color: '#2a2a2a', url: '/images/6456ce4576abb28c02fbc1f8_cambria-surprise-granite-blackwood-quartz-close-up.webp', brand: 'Cambria' },
        { id: 'granite-hermitage', name: 'Hermitage', color: '#8b7355', url: '/images/6456ce4476abb20e81fbb85f_cambria-surprise-granite-hermitage-close-up.webp', brand: 'Cambria' },
        { id: 'granite-winterbourne', name: 'Winterbourne', color: '#e8e4dc', url: '/images/6456ce4476abb2082efbb815_cambria-surprise-granite-winterbourne-close-up.webp', brand: 'Cambria' },
        { id: 'granite-clovelly', name: 'Clovelly', color: '#c9bfb0', url: '/images/6456ce4476abb2275dfbb824_cambria-surprise-granite-clovelly-moment2.webp', brand: 'Cambria' },
        // Daltile Natural Stone - Granite (CTF Price List Jan 2026)
        { id: 'daltile-absolute-black', name: 'Absolute Black', color: '#0a0a0a', sku: 'L75712121L', price: 10.45, brand: 'Daltile' },
        { id: 'daltile-alaska-white', name: 'Alaska White', color: '#E8E4E0', sku: 'L77612121L', price: 23.40, brand: 'Daltile' },
        { id: 'daltile-bianco-antico', name: 'Bianco Antico', color: '#E0D8D0', sku: 'L79912121L', price: 25.90, brand: 'Daltile' },
        { id: 'daltile-black-galaxy', name: 'Black Galaxy', color: '#1a1a2e', sku: 'L76712121L', price: 10.45, brand: 'Daltile' },
        { id: 'daltile-blue-pearl', name: 'Blue Pearl', color: '#3d4f6b', sku: 'L75812121L', price: 16.05, brand: 'Daltile' },
        { id: 'daltile-colonial-white', name: 'Colonial White', color: '#F0EBE5', sku: 'L79512121L', price: 23.40, brand: 'Daltile' },
        { id: 'daltile-delicatus-white', name: 'Delicatus White', color: '#FAF8F5', sku: 'L80812121L', price: 31.45, brand: 'Daltile' },
        { id: 'daltile-fantasy-brown', name: 'Fantasy Brown', color: '#C4B7A6', sku: 'L81212121L', price: 25.90, brand: 'Daltile' },
        { id: 'daltile-giallo-ornamental', name: 'Giallo Ornamental', color: '#C9B896', sku: 'L76012121L', price: 10.45, brand: 'Daltile' },
        { id: 'daltile-new-venetian-gold', name: 'New Venetian Gold', color: '#D4B878', sku: 'L76112121L', price: 10.45, brand: 'Daltile' },
        { id: 'daltile-river-white', name: 'River White', color: '#F0EBE5', sku: 'L80712121L', price: 23.40, brand: 'Daltile' },
        { id: 'daltile-santa-cecilia', name: 'Santa Cecilia', color: '#C8A878', sku: 'L76212121L', price: 10.45, brand: 'Daltile' },
        { id: 'daltile-steel-grey', name: 'Steel Grey', color: '#6B6B6B', sku: 'L78512121L', price: 10.45, brand: 'Daltile' },
        { id: 'daltile-typhoon-bordeaux', name: 'Typhoon Bordeaux', color: '#8B4A4A', sku: 'L79812121L', price: 25.90, brand: 'Daltile' },
        { id: 'daltile-uba-tuba', name: 'Uba Tuba', color: '#2A3A2A', sku: 'L76312121L', price: 5.80, brand: 'Daltile' },
        { id: 'daltile-white-ice', name: 'White Ice', color: '#F8F8F8', sku: 'L81112121L', price: 23.40, brand: 'Daltile' }
      ],
      quartz: [
        // Surprise Granite Collection
        { id: 'quartz-stellar-white', name: 'Stellar White', color: '#f5f5f5', url: '/images/6456ce4576abb21af6fbc914_msi-surfaces-quartz-surprise-granite-stellar-white-moment.webp', brand: 'MSI' },
        { id: 'quartz-shell-white', name: 'Shell White', color: '#faf8f5', url: '/images/6456ce4576abb28a6bfbc8cb_msi-surfaces-quartz-surprise-granite-shell-white-close-up.webp', brand: 'MSI' },
        { id: 'quartz-perla-white', name: 'Perla White', color: '#f0ece5', url: '/images/6456ce4576abb20436fbc89c_msi-surfaces-quartz-surprise-granite-perla-white-moment.webp', brand: 'MSI' },
        { id: 'quartz-stellar-gray', name: 'Stellar Gray', color: '#8a8a8a', url: '/images/6456ce4576abb2590afbc90f_msi-surfaces-quartz-surprise-granite-sstellar-gray-moment.webp', brand: 'MSI' },
        { id: 'quartz-midnight', name: 'Midnight Majesty', color: '#1a1a2e', url: '/images/6456ce4576abb2eaa9fbc85a_msi-surfaces-quartz-surprise-granite-midnight-majesty-close-up.webp', brand: 'MSI' },
        { id: 'quartz-calacatta', name: 'Calacatta Laurent', color: '#f8f6f0', url: '/images/6456ce4576abb294bffbc2da_dekton-surprise-granite-laurent-quartz-close-up.webp', brand: 'Dekton' },
        // MSI Premium Natural Quartz (Jan 2025 Price List) - with CDN images
        { id: 'msi-aruca-white', name: 'Aruca White', color: '#F5F5F5', sku: 'QSL-ARUCAWHT', price: 8.40, brand: 'MSI Quartz', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/aruca-white-quartz.jpg' },
        { id: 'msi-frost-white', name: 'Frost White', color: '#FFFFFF', sku: 'QSL-FRSTWHT', price: 8.40, brand: 'MSI Quartz', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/frost-white-quartz.jpg' },
        { id: 'msi-sparkling-white', name: 'Sparkling White', color: '#FAFAFA', sku: 'QSL-SPRWHT', price: 8.40, brand: 'MSI Quartz', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/sparkling-white-quartz.jpg' },
        { id: 'msi-arctic-white', name: 'Arctic White', color: '#F0F0F0', sku: 'QSL-ARCWHT', price: 9.00, brand: 'MSI Quartz', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/arctic-white-quartz.jpg' },
        { id: 'msi-carrara-mist', name: 'Carrara Mist', color: '#E8E8E8', sku: 'QSL-CARRMIST', price: 10.75, brand: 'MSI Quartz', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/carrara-mist-quartz.jpg' },
        { id: 'msi-calacatta-alto', name: 'Calacatta Alto', color: '#FAF8F5', sku: 'QSL-CALAALTO', price: 10.75, brand: 'MSI Quartz', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/calacatta-alto-quartz.jpg' },
        { id: 'msi-midnight-majesty', name: 'Midnight Majesty', color: '#1A1A1A', sku: 'QSL-MIDMAJ', price: 10.75, brand: 'MSI Quartz', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/midnight-majesty-quartz.jpg' },
        { id: 'msi-alabaster-white', name: 'Alabaster White', color: '#FAF8F5', sku: 'QSL-ALABWHT', price: 13.15, brand: 'MSI Quartz', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/alabaster-white-quartz.jpg' },
        { id: 'msi-calacatta-vicenza', name: 'Calacatta Vicenza', color: '#F8F5F0', sku: 'QSL-CALVIC', price: 13.15, brand: 'MSI Quartz', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/calacatta-vicenza-quartz.jpg' },
        { id: 'msi-calacatta-laza', name: 'Calacatta Laza', color: '#FAFAFA', sku: 'QSL-CALALAZA', price: 15.00, brand: 'MSI Quartz', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/calacatta-laza-quartz.jpg' },
        { id: 'msi-babylon-gray', name: 'Babylon Gray', color: '#4A4A4A', sku: 'QSL-BABYLONGRY', price: 15.00, brand: 'MSI Quartz', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/babylon-gray-quartz.jpg' },
        { id: 'msi-soapstone-mist', name: 'Soapstone Mist', color: '#686868', sku: 'QSL-SPSTNMIST', price: 15.00, brand: 'MSI Quartz', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/soapstone-mist-quartz.jpg' },
        { id: 'msi-calacatta-miraggio', name: 'Calacatta Miraggio', color: '#FAF8F5', sku: 'QSL-CALAMIRAGGIO', price: 18.00, brand: 'MSI Quartz', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/calacatta-miraggio-quartz.jpg' },
        { id: 'msi-calacatta-versailles', name: 'Calacatta Versailles', color: '#FAFAFA', sku: 'QSL-CALAVERSA', price: 20.75, brand: 'MSI Quartz', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/calacatta-versailles-quartz.jpg' },
        { id: 'msi-lumataj', name: 'Lumataj', color: '#F5F0E8', sku: 'QSL-LUMATAJ', price: 21.80, brand: 'MSI Quartz', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/lumataj-quartz.jpg' },
        // MSI Premium Quartz - Additional Colors (Jan 2025) - with CDN images
        { id: 'msi-iced-white', name: 'Iced White', color: '#F8F8F8', sku: 'QSL-ICEDWHT', price: 8.40, brand: 'MSI Quartz', tier: 'Group 0', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/iced-white-quartz.jpg' },
        { id: 'msi-bayshore-sand', name: 'Bayshore Sand', color: '#D4C4A8', sku: 'QSL-BAYSHRSND', price: 8.40, brand: 'MSI Quartz', tier: 'Group 0', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/bayshore-sand-quartz.jpg' },
        { id: 'msi-snow-white', name: 'Snow White', color: '#FEFEFE', sku: 'QSL-SNOWHTE', price: 9.00, brand: 'MSI Quartz', tier: 'Group 1', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/snow-white-quartz.jpg' },
        { id: 'msi-carrara-marmi', name: 'Carrara Marmi', color: '#F5F5F5', sku: 'QSL-CARMARMI', price: 10.75, brand: 'MSI Quartz', tier: 'Group 2', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/carrara-marmi-quartz.jpg' },
        { id: 'msi-stellar-white-g2', name: 'Stellar White', color: '#F5F5F5', sku: 'QSL-STELLARWHT', price: 10.75, brand: 'MSI Quartz', tier: 'Group 2', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/stellar-white-quartz.jpg' },
        { id: 'msi-calacatta-classique', name: 'Calacatta Classique', color: '#FAFAFA', sku: 'QSL-CALACLSQUE', price: 13.15, brand: 'MSI Quartz', tier: 'Group 3', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/calacatta-classique-quartz.jpg' },
        { id: 'msi-fairy-white', name: 'Fairy White', color: '#F8F8F8', sku: 'QSL-FAIWHT', price: 13.15, brand: 'MSI Quartz', tier: 'Group 3', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/fairy-white-quartz.jpg' },
        { id: 'msi-calacatta-botanica', name: 'Calacatta Botanica', color: '#F5F2EE', sku: 'QSL-CALABOTNICA', price: 15.00, brand: 'MSI Quartz', tier: 'Group 4', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/calacatta-botanica-quartz.jpg' },
        { id: 'msi-perla-white-g4', name: 'Perla White', color: '#F0ECE5', sku: 'QSL-PERWHT', price: 15.00, brand: 'MSI Quartz', tier: 'Group 4', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/perla-white-quartz.jpg' },
        { id: 'msi-calacatta-monaco', name: 'Calacatta Monaco', color: '#F8F5F0', sku: 'QSL-CALAMONACO', price: 17.00, brand: 'MSI Quartz', tier: 'Group 5', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/calacatta-monaco-quartz.jpg' },
        { id: 'msi-glacier-white', name: 'Glacier White', color: '#F8F8F8', sku: 'QSL-GLACIERWHT', price: 17.00, brand: 'MSI Quartz', tier: 'Group 5', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/glacier-white-quartz.jpg' },
        { id: 'msi-statuary-classique', name: 'Statuary Classique', color: '#FAFAFA', sku: 'QSL-STACLSQUE', price: 17.00, brand: 'MSI Quartz', tier: 'Group 5', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/statuary-classique-quartz.jpg' },
        { id: 'msi-calacatta-clara', name: 'Calacatta Clara', color: '#FAFAFA', sku: 'QSL-CALACLARA', price: 18.00, brand: 'MSI Quartz', tier: 'Group 6', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/calacatta-clara-quartz.jpg' },
        { id: 'msi-calacatta-luccia', name: 'Calacatta Luccia', color: '#FAFAFA', sku: 'QSL-CALALUCCIA', price: 18.00, brand: 'MSI Quartz', tier: 'Group 6', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/calacatta-luccia-quartz.jpg' },
        { id: 'msi-calacatta-trevi', name: 'Calacatta Trevi', color: '#FAFAFA', sku: 'QSL-CALATREVI', price: 18.00, brand: 'MSI Quartz', tier: 'Group 6', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/calacatta-trevi-quartz.jpg' },
        { id: 'msi-calacatta-goa', name: 'Calacatta Goa', color: '#FAF8F5', sku: 'QSL-CALAGOA', price: 20.75, brand: 'MSI Quartz', tier: 'Group 7', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/calacatta-goa-quartz.jpg' },
        { id: 'msi-calacatta-miraggio-gold', name: 'Calacatta Miraggio Gold', color: '#FAF5E8', sku: 'QSL-CALAMIRGOLD', price: 20.75, brand: 'MSI Quartz', tier: 'Group 7', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/calacatta-miraggio-gold-quartz.jpg' },
        { id: 'msi-azurmatt', name: 'Azurmatt', color: '#4A6B8C', sku: 'QSL-AZURMATT', price: 21.80, brand: 'MSI Quartz', tier: 'Group 8', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/azurmatt-quartz.jpg' },
        { id: 'msi-calacatta-viraldi', name: 'Calacatta Viraldi', color: '#FAF8F5', sku: 'QSL-CALAVIRALDI', price: 21.80, brand: 'MSI Quartz', tier: 'Group 8', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/calacatta-viraldi-quartz.jpg' },
        // Daltile ONE Quartz Surfaces (CTF Price List Jan 2026)
        { id: 'daltile-quartz-alabaster', name: 'Alabaster White', color: '#FAF8F5', sku: 'NQ90', price: 7.90, brand: 'Daltile ONE Quartz' },
        { id: 'daltile-quartz-simply-white', name: 'Simply White', color: '#FEFEFE', sku: 'NQ51', price: 7.90, brand: 'Daltile ONE Quartz' },
        { id: 'daltile-quartz-frost-white', name: 'Frost White', color: '#FFFFFF', sku: 'NQ01', price: 12.60, brand: 'Daltile ONE Quartz' },
        { id: 'daltile-quartz-carrara-mist', name: 'Carrara Mist', color: '#F5F5F5', sku: 'NQ64', price: 21.15, brand: 'Daltile ONE Quartz' },
        { id: 'daltile-quartz-calacatta-laza', name: 'Calacatta Laza', color: '#FAFAFA', sku: 'NQ73', price: 34.60, brand: 'Daltile ONE Quartz' }
      ],
      marble: [
        // Daltile Natural Stone - Marble (CTF Price List Jan 2026)
        { id: 'daltile-carrara-honed', name: 'Carrara White (Honed)', color: '#F5F5F5', sku: 'M70112181U', price: 10.45, brand: 'Daltile' },
        { id: 'daltile-carrara-polished', name: 'Carrara White (Polished)', color: '#FAFAFA', sku: 'M70112181L', price: 12.25, brand: 'Daltile' },
        { id: 'daltile-first-snow', name: 'First Snow Elegance', color: '#FFFFFF', sku: 'M19012181L', price: 38.80, brand: 'Daltile' }
      ],
      quartzite: [
        // Daltile Natural Stone - Quartzite (CTF Price List Jan 2026)
        { id: 'daltile-super-white', name: 'Super White', color: '#FEFEFE', sku: 'L02212121L', price: 39.85, brand: 'Daltile' },
        { id: 'daltile-taj-mahal', name: 'Taj Mahal', color: '#F5F0E8', sku: 'L02112121L', price: 39.85, brand: 'Daltile' },
        { id: 'daltile-calacatta-macaubas', name: 'Calacatta Macaubas', color: '#FAF8F5', sku: 'L02612121L', price: 39.85, brand: 'Daltile' },
        { id: 'daltile-azul-macaubas', name: 'Azul Macaubas', color: '#4A6B8C', sku: 'L02512121L', price: 39.85, brand: 'Daltile' },
        { id: 'daltile-sea-pearl', name: 'Sea Pearl', color: '#D8E0E8', sku: 'L02312121L', price: 39.85, brand: 'Daltile' },
        { id: 'daltile-madre-perla', name: 'Madre Perla', color: '#F0E8E0', sku: 'L02812121L', price: 31.20, brand: 'Daltile' }
      ],
      cabinets: [
        { id: 'cabinet-white', name: 'Shaker White', color: '#f5f5f5', url: '/images/6456ce4476abb22994fbb0d6_Liberty%20Shaker%20White%20Cabinet.webp' },
        { id: 'cabinet-grey', name: 'Shaker Grey', color: '#7a7a7a', url: '/images/6456ce4476abb22121fbb0d7_Liberty%20Shaker%20Grey%20Cabinet.webp' },
        { id: 'cabinet-espresso', name: 'Shaker Espresso', color: '#3d2b1f', url: '/images/6456ce4476abb20cc6fbb0d5_Liberty%20Shaker%20Espresso.webp' },
        { id: 'cabinet-black', name: 'Onyx Black', color: '#1a1a1a', url: '/images/6456ce4476abb24601fbb0e8_Onyx%20Black%20Shaker.webp' },
        { id: 'cabinet-uptown', name: 'Uptown White', color: '#fefefe', url: '/images/6456ce4476abb232ddfbb0eb_Uptown%20White%20Shaker.webp' },
        // MSI Cabinet Collection - Base Cabinets (Jan 2025 Pricing)
        { id: 'msi-cab-b09', name: 'MSI Base 9"', color: '#f5f5f5', sku: 'B09', price: 119.13, brand: 'MSI', type: 'base', width: 9 },
        { id: 'msi-cab-b12', name: 'MSI Base 12"', color: '#f5f5f5', sku: 'B12', price: 127.63, brand: 'MSI', type: 'base', width: 12 },
        { id: 'msi-cab-b15', name: 'MSI Base 15"', color: '#f5f5f5', sku: 'B15', price: 137.25, brand: 'MSI', type: 'base', width: 15 },
        { id: 'msi-cab-b18', name: 'MSI Base 18"', color: '#f5f5f5', sku: 'B18', price: 146.30, brand: 'MSI', type: 'base', width: 18 },
        { id: 'msi-cab-b21', name: 'MSI Base 21"', color: '#f5f5f5', sku: 'B21', price: 155.00, brand: 'MSI', type: 'base', width: 21 },
        { id: 'msi-cab-b24', name: 'MSI Base 24"', color: '#f5f5f5', sku: 'B24', price: 175.71, brand: 'MSI', type: 'base', width: 24 },
        { id: 'msi-cab-b30', name: 'MSI Base 30"', color: '#f5f5f5', sku: 'B30', price: 196.45, brand: 'MSI', type: 'base', width: 30 },
        { id: 'msi-cab-b36', name: 'MSI Base 36"', color: '#f5f5f5', sku: 'B36', price: 245.41, brand: 'MSI', type: 'base', width: 36 },
        { id: 'msi-cab-sb30', name: 'MSI Sink Base 30"', color: '#f5f5f5', sku: 'SB30', price: 151.82, brand: 'MSI', type: 'sink', width: 30 },
        { id: 'msi-cab-sb36', name: 'MSI Sink Base 36"', color: '#f5f5f5', sku: 'SB36', price: 171.82, brand: 'MSI', type: 'sink', width: 36 },
        { id: 'msi-cab-3db15', name: 'MSI Drawer Base 15"', color: '#f5f5f5', sku: '3DB15', price: 206.32, brand: 'MSI', type: 'drawer', width: 15 },
        { id: 'msi-cab-3db18', name: 'MSI Drawer Base 18"', color: '#f5f5f5', sku: '3DB18', price: 219.00, brand: 'MSI', type: 'drawer', width: 18 },
        // MSI Cabinet Collection - Wall Cabinets
        { id: 'msi-cab-w1236', name: 'MSI Wall 12x36"', color: '#f5f5f5', sku: 'W1236', price: 82.15, brand: 'MSI', type: 'wall', width: 12, height: 36 },
        { id: 'msi-cab-w1536', name: 'MSI Wall 15x36"', color: '#f5f5f5', sku: 'W1536', price: 92.77, brand: 'MSI', type: 'wall', width: 15, height: 36 },
        { id: 'msi-cab-w1836', name: 'MSI Wall 18x36"', color: '#f5f5f5', sku: 'W1836', price: 103.55, brand: 'MSI', type: 'wall', width: 18, height: 36 },
        { id: 'msi-cab-w2436', name: 'MSI Wall 24x36"', color: '#f5f5f5', sku: 'W2436', price: 136.01, brand: 'MSI', type: 'wall', width: 24, height: 36 },
        { id: 'msi-cab-w3036', name: 'MSI Wall 30x36"', color: '#f5f5f5', sku: 'W3036', price: 154.95, brand: 'MSI', type: 'wall', width: 30, height: 36 },
        { id: 'msi-cab-w3630', name: 'MSI Wall 36x30"', color: '#f5f5f5', sku: 'W3630', price: 154.95, brand: 'MSI', type: 'wall', width: 36, height: 30 },
        { id: 'msi-cab-w1242', name: 'MSI Wall 12x42"', color: '#f5f5f5', sku: 'W1242', price: 95.99, brand: 'MSI', type: 'wall', width: 12, height: 42 },
        { id: 'msi-cab-w2442', name: 'MSI Wall 24x42"', color: '#f5f5f5', sku: 'W2442', price: 159.90, brand: 'MSI', type: 'wall', width: 24, height: 42 },
        { id: 'msi-cab-w3042', name: 'MSI Wall 30x42"', color: '#f5f5f5', sku: 'W3042', price: 184.23, brand: 'MSI', type: 'wall', width: 30, height: 42 },
        // MSI Cabinet Collection - Vanity Cabinets
        { id: 'msi-cab-v3021', name: 'MSI Vanity 30x21"', color: '#f5f5f5', sku: 'V3021', price: 152.48, brand: 'MSI', type: 'vanity', width: 30 },
        { id: 'msi-cab-v3621', name: 'MSI Vanity 36x21"', color: '#f5f5f5', sku: 'V3621', price: 172.00, brand: 'MSI', type: 'vanity', width: 36 },
        { id: 'msi-cab-vdb4221', name: 'MSI Vanity Combo 42x21"', color: '#f5f5f5', sku: 'VDB4221R', price: 328.93, brand: 'MSI', type: 'vanity', width: 42 },
        { id: 'msi-cab-vdb4821', name: 'MSI Vanity Combo 48x21"', color: '#f5f5f5', sku: 'VDB4821', price: 361.88, brand: 'MSI', type: 'vanity', width: 48 }
      ],
      tile: [
        // Existing tiles
        { id: 'tile-perla', name: 'Taja Perla', color: '#d4cfc5', url: '/images/6456ce4576abb2d4d0fbcc56_taja-perla-porcelain-close-up-thumbnail.jpg' },
        { id: 'tile-white', name: 'White Subway', color: '#ffffff', url: '' },
        { id: 'tile-marble', name: 'Carrara Look', color: '#e8e8e8', url: '' },
        { id: 'tile-slate', name: 'Slate Grey', color: '#708090', url: '' },
        // Daltile PANORAMIC Porcelain Surfaces (CTF Price List Jan 2026)
        { id: 'daltile-panoramic-calacatta', name: 'PANORAMIC Calacatta', color: '#FAFAFA', sku: 'PAN-CAL', price: 31.20, brand: 'Daltile', series: 'PANORAMIC' },
        { id: 'daltile-panoramic-statuario', name: 'PANORAMIC Statuario', color: '#F8F8F8', sku: 'PAN-STA', price: 31.20, brand: 'Daltile', series: 'PANORAMIC' },
        { id: 'daltile-panoramic-nero', name: 'PANORAMIC Nero Marquina', color: '#1A1A1A', sku: 'PAN-NER', price: 28.80, brand: 'Daltile', series: 'PANORAMIC' },
        { id: 'daltile-panoramic-cement', name: 'PANORAMIC Cement', color: '#9E9E9E', sku: 'PAN-CEM', price: 8.90, brand: 'Daltile', series: 'PANORAMIC' }
      ],
      flooring: [
        { id: 'floor-premium', name: 'Premium LVP', color: '#b8956c', url: '/images/6456ce4476abb2d85bfbb1d2_All%20Flooring%20Hero%20Background%20Image.webp' },
        { id: 'floor-oak', name: 'Natural Oak', color: '#c4a76c', url: '' },
        { id: 'floor-walnut', name: 'Dark Walnut', color: '#5d4037', url: '' },
        { id: 'floor-maple', name: 'Light Maple', color: '#deb887', url: '' },
        // MSI Everlife LVT Flooring - Ashton Series (Tier 4 Pricing Q1 2025) - with CDN images
        { id: 'msi-lvt-bergen-hills', name: 'Ashton Bergen Hills', color: '#C4A76C', sku: 'ASHTON-BERGENHILLS', price: 1.25, brand: 'MSI Everlife', series: 'Ashton', warranty: '25yr Res' },
        { id: 'msi-lvt-maracay-brown', name: 'Ashton Maracay Brown', color: '#8B7355', sku: 'ASHTON-MARACAYBROWN', price: 1.25, brand: 'MSI Everlife', series: 'Ashton', warranty: '25yr Res' },
        { id: 'msi-lvt-york-gray', name: 'Ashton York Gray', color: '#7A7A7A', sku: 'ASHTON-YORKGRAY', price: 1.25, brand: 'MSI Everlife', series: 'Ashton', warranty: '25yr Res' },
        // MSI Everlife LVT - Cyrus Series - with CDN images
        { id: 'msi-lvt-akadia', name: 'Cyrus Akadia', color: '#A08060', sku: 'CYRUS-AKADIA', price: 1.55, brand: 'MSI Everlife', series: 'Cyrus', warranty: 'Lifetime/10yr Comm' },
        { id: 'msi-lvt-barnstorm', name: 'Cyrus Barnstorm', color: '#5D4037', sku: 'CYRUS-BARNSTORM', price: 1.55, brand: 'MSI Everlife', series: 'Cyrus', warranty: 'Lifetime/10yr Comm' },
        { id: 'msi-lvt-braly', name: 'Cyrus Braly', color: '#6B5344', sku: 'CYRUS-BRALY', price: 1.55, brand: 'MSI Everlife', series: 'Cyrus', warranty: 'Lifetime/10yr Comm' },
        { id: 'msi-lvt-fauna', name: 'Cyrus Fauna', color: '#9E8B7D', sku: 'CYRUS-FAUNA', price: 1.55, brand: 'MSI Everlife', series: 'Cyrus', warranty: 'Lifetime/10yr Comm' },
        { id: 'msi-lvt-katella-ash', name: 'Cyrus Katella Ash', color: '#8A8A8A', sku: 'CYRUS-KATELLAASH', price: 1.55, brand: 'MSI Everlife', series: 'Cyrus', warranty: 'Lifetime/10yr Comm' },
        { id: 'msi-lvt-ludlow', name: 'Cyrus Ludlow', color: '#7D6B5D', sku: 'CYRUS-LUDLOW', price: 1.55, brand: 'MSI Everlife', series: 'Cyrus', warranty: 'Lifetime/10yr Comm' },
        { id: 'msi-lvt-sandino', name: 'Cyrus Sandino', color: '#C4A878', sku: 'CYRUS-SANDINO', price: 1.55, brand: 'MSI Everlife', series: 'Cyrus', warranty: 'Lifetime/10yr Comm' },
        // MSI Everlife LVT - Prescott Series (Premium Commercial) - with CDN images
        { id: 'msi-lvt-prescott-akadia', name: 'Prescott Akadia', color: '#A08060', sku: 'PRESCOTT-AKADIA', price: 1.79, brand: 'MSI Everlife', series: 'Prescott', warranty: 'Lifetime/20yr Comm' },
        { id: 'msi-lvt-prescott-braly', name: 'Prescott Braly', color: '#6B5344', sku: 'PRESCOTT-BRALY', price: 1.79, brand: 'MSI Everlife', series: 'Prescott', warranty: 'Lifetime/20yr Comm' },
        { id: 'msi-lvt-prescott-fauna', name: 'Prescott Fauna', color: '#9E8B7D', sku: 'PRESCOTT-FAUNA', price: 1.79, brand: 'MSI Everlife', series: 'Prescott', warranty: 'Lifetime/20yr Comm' },
        { id: 'msi-lvt-prescott-ludlow', name: 'Prescott Ludlow', color: '#7D6B5D', sku: 'PRESCOTT-LUDLOW', price: 1.79, brand: 'MSI Everlife', series: 'Prescott', warranty: 'Lifetime/20yr Comm' },
        // MSI Everlife LVT - Andover Series - with CDN images
        { id: 'msi-lvt-bayhill-blonde', name: 'Andover Bayhill Blonde', color: '#DEB887', sku: 'ANDOVER-BAYHILLBLONDE', price: 1.79, brand: 'MSI Everlife', series: 'Andover', warranty: 'Lifetime/15yr Comm' },
        { id: 'msi-lvt-hatfield', name: 'Andover Hatfield', color: '#8B7355', sku: 'ANDOVER-HATFIELD', price: 1.79, brand: 'MSI Everlife', series: 'Andover', warranty: 'Lifetime/15yr Comm' },
        { id: 'msi-lvt-kingsdown-gray', name: 'Andover Kingsdown Gray', color: '#6E6E6E', sku: 'ANDOVER-KINGSDOWNGRAY', price: 1.79, brand: 'MSI Everlife', series: 'Andover', warranty: 'Lifetime/15yr Comm' },
        { id: 'msi-lvt-whitby-white', name: 'Andover Whitby White', color: '#E8E4DC', sku: 'ANDOVER-WHITBYWHITE', price: 1.79, brand: 'MSI Everlife', series: 'Andover', warranty: 'Lifetime/15yr Comm' },
        // MSI Everlife LVT - Trecento Series (Stone Look 12x24) - with CDN images
        { id: 'msi-lvt-calacatta-legend', name: 'Trecento Calacatta Legend', color: '#F5F5F5', sku: 'TRECENTO-CALACATTALEGEND', price: 1.75, brand: 'MSI Everlife', series: 'Trecento', warranty: 'Lifetime/10yr Comm' },
        { id: 'msi-lvt-carrara-avell', name: 'Trecento Carrara Avell', color: '#E8E8E8', sku: 'TRECENTO-CARRARAAVELL', price: 1.75, brand: 'MSI Everlife', series: 'Trecento', warranty: 'Lifetime/10yr Comm' },
        { id: 'msi-lvt-mountains-gray', name: 'Trecento Mountains Gray', color: '#9E9E9E', sku: 'TRECENTO-MOUNTAINSGRAY', price: 1.75, brand: 'MSI Everlife', series: 'Trecento', warranty: 'Lifetime/10yr Comm' },
        // MSI Everlife LVT - Laurel Series - with CDN images
        { id: 'msi-lvt-coastal-cottage', name: 'Laurel Coastal Cottage', color: '#D4C8B8', sku: 'LAUREL-COASTALCOTTAGE', price: 1.69, brand: 'MSI Everlife', series: 'Laurel', warranty: 'Lifetime/15yr Comm' },
        { id: 'msi-lvt-honey-hollow', name: 'Laurel Honey Hollow', color: '#C4A76C', sku: 'LAUREL-HONEYHOLLOW', price: 1.69, brand: 'MSI Everlife', series: 'Laurel', warranty: 'Lifetime/15yr Comm' },
        { id: 'msi-lvt-scandi', name: 'Laurel Scandi', color: '#E8E0D8', sku: 'LAUREL-SCANDI', price: 1.69, brand: 'MSI Everlife', series: 'Laurel', warranty: 'Lifetime/15yr Comm' },
        // MSI Everlife LVT - Studio Collection (Ultra Premium) - with CDN images
        { id: 'msi-lvt-studio-bozeman', name: 'Studio Bozeman', color: '#6B5344', sku: 'STUDIO-BOZEMAN', price: 3.39, brand: 'MSI Everlife', series: 'Studio', warranty: 'Lifetime/30yr Comm' },
        { id: 'msi-lvt-studio-taos', name: 'Studio Taos', color: '#8B7355', sku: 'STUDIO-TAOS', price: 3.39, brand: 'MSI Everlife', series: 'Studio', warranty: 'Lifetime/30yr Comm' },
        { id: 'msi-lvt-studio-roswell', name: 'Studio Roswell', color: '#A08060', sku: 'STUDIO-ROSWELL', price: 3.39, brand: 'MSI Everlife', series: 'Studio', warranty: 'Lifetime/30yr Comm' },
        // MSI DryBack LVT - Katavia Series (Budget)
        { id: 'msi-dryback-katavia-bleached-elm', name: 'Katavia Bleached Elm', color: '#D4C8B8', sku: 'VTGBLEELM6X48-2MM-6MIL', price: 0.80, brand: 'MSI DryBack', series: 'Katavia', warranty: '15yr Res' },
        { id: 'msi-dryback-katavia-burnished-acacia', name: 'Katavia Burnished Acacia', color: '#8B7355', sku: 'VTGBURACA6X48-2MM-6MIL', price: 0.80, brand: 'MSI DryBack', series: 'Katavia', warranty: '15yr Res' },
        { id: 'msi-dryback-katavia-charcoal-oak', name: 'Katavia Charcoal Oak', color: '#4A4A4A', sku: 'VTGCHAOAK6X48-2MM-6MIL', price: 0.80, brand: 'MSI DryBack', series: 'Katavia', warranty: '15yr Res' },
        { id: 'msi-dryback-katavia-elmwood-ash', name: 'Katavia Elmwood Ash', color: '#9E8B7D', sku: 'VTGELMASH6X48-2MM-6MIL', price: 0.80, brand: 'MSI DryBack', series: 'Katavia', warranty: '15yr Res' },
        { id: 'msi-dryback-katavia-twilight-oak', name: 'Katavia Twilight Oak', color: '#5D4037', sku: 'VTGTWIOAK6X48-2MM-6MIL', price: 0.80, brand: 'MSI DryBack', series: 'Katavia', warranty: '15yr Res' },
        { id: 'msi-dryback-katavia-woodrift-gray', name: 'Katavia Woodrift Gray', color: '#6E6E6E', sku: 'VTGWOOGRA6X48-2MM-6MIL', price: 0.80, brand: 'MSI DryBack', series: 'Katavia', warranty: '15yr Res' },
        // MSI DryBack LVT - Glenridge Series
        { id: 'msi-dryback-glenridge-aged-hickory', name: 'Glenridge Aged Hickory', color: '#7D6B5D', sku: 'VTGAGEHIC6X48-2MM-12MIL', price: 0.89, brand: 'MSI DryBack', series: 'Glenridge', warranty: '25yr Res/6yr Comm' },
        { id: 'msi-dryback-glenridge-coastal-mix', name: 'Glenridge Coastal Mix', color: '#A8A090', sku: 'VTGCOAMIX6X48-2MM-12MIL', price: 0.89, brand: 'MSI DryBack', series: 'Glenridge', warranty: '25yr Res/6yr Comm' },
        { id: 'msi-dryback-glenridge-jatoba', name: 'Glenridge Jatoba', color: '#6B4A3A', sku: 'VTGJATOBA6X48-2MM-12MIL', price: 0.89, brand: 'MSI DryBack', series: 'Glenridge', warranty: '25yr Res/6yr Comm' },
        { id: 'msi-dryback-glenridge-midnight-maple', name: 'Glenridge Midnight Maple', color: '#3D2B1F', sku: 'VTGMIDMAP6X48-2MM-12MIL', price: 0.89, brand: 'MSI DryBack', series: 'Glenridge', warranty: '25yr Res/6yr Comm' },
        { id: 'msi-dryback-glenridge-saddle-oak', name: 'Glenridge Saddle Oak', color: '#8B7355', sku: 'VTGSADOAK6X48-2MM-12MIL', price: 0.89, brand: 'MSI DryBack', series: 'Glenridge', warranty: '25yr Res/6yr Comm' },
        { id: 'msi-dryback-glenridge-tawny-birch', name: 'Glenridge Tawny Birch', color: '#C4A878', sku: 'VTGTAWBIR6X48-2MM-12MIL', price: 0.89, brand: 'MSI DryBack', series: 'Glenridge', warranty: '25yr Res/6yr Comm' },
        // MSI DryBack LVT - Acclima Series
        { id: 'msi-dryback-acclima-ayla', name: 'Acclima Ayla', color: '#C4A76C', sku: 'VTGAYLA7X48-2MM-12MIL', price: 0.98, brand: 'MSI DryBack', series: 'Acclima', warranty: '25yr Res/6yr Comm' },
        { id: 'msi-dryback-acclima-louis-hill', name: 'Acclima Louis Hill', color: '#8B7355', sku: 'VTGLOUHIL7X48-2MM-12MIL', price: 0.98, brand: 'MSI DryBack', series: 'Acclima', warranty: '25yr Res/6yr Comm' },
        { id: 'msi-dryback-acclima-ludlow', name: 'Acclima Ludlow', color: '#7D6B5D', sku: 'VTGLUDLOW7X48-2MM-12MIL', price: 0.98, brand: 'MSI DryBack', series: 'Acclima', warranty: '25yr Res/6yr Comm' },
        { id: 'msi-dryback-acclima-waldorf', name: 'Acclima Waldorf', color: '#A08060', sku: 'VTGWALDOR7X48-2MM-12MIL', price: 0.98, brand: 'MSI DryBack', series: 'Acclima', warranty: '25yr Res/6yr Comm' },
        { id: 'msi-dryback-acclima-whitfield-gray', name: 'Acclima Whitfield Gray', color: '#8A8A8A', sku: 'VTGWHTGRA7X48-2MM-12MIL', price: 0.98, brand: 'MSI DryBack', series: 'Acclima', warranty: '25yr Res/6yr Comm' },
        // MSI DryBack LVT - Wilmont Series (20mil wear layer)
        { id: 'msi-dryback-wilmont-burnished-acacia', name: 'Wilmont Burnished Acacia', color: '#8B7355', sku: 'VTGBURACA7X48-2.5MM-20MIL', price: 1.19, brand: 'MSI DryBack', series: 'Wilmont', warranty: 'Lifetime/15yr Comm' },
        { id: 'msi-dryback-wilmont-charcoal-oak', name: 'Wilmont Charcoal Oak', color: '#4A4A4A', sku: 'VTGCHAOAK7X48-2.5MM-20MIL', price: 1.19, brand: 'MSI DryBack', series: 'Wilmont', warranty: 'Lifetime/15yr Comm' },
        { id: 'msi-dryback-wilmont-elmwood-ash', name: 'Wilmont Elmwood Ash', color: '#9E8B7D', sku: 'VTGELMASH7X48-2.5MM-20MIL', price: 1.19, brand: 'MSI DryBack', series: 'Wilmont', warranty: 'Lifetime/15yr Comm' },
        { id: 'msi-dryback-wilmont-lime-washed', name: 'Wilmont Lime Washed Oak', color: '#E8E0D8', sku: 'VTGLIMWAS7X48-2.5MM-20MIL', price: 1.19, brand: 'MSI DryBack', series: 'Wilmont', warranty: 'Lifetime/15yr Comm' },
        { id: 'msi-dryback-wilmont-twilight-oak', name: 'Wilmont Twilight Oak', color: '#5D4037', sku: 'VTGTWIOAK7X48-2.5MM-20MIL', price: 1.19, brand: 'MSI DryBack', series: 'Wilmont', warranty: 'Lifetime/15yr Comm' },
        // MSI DryBack LVT - Kallum Series (Looselay Premium)
        { id: 'msi-dryback-kallum-akadia', name: 'Kallum Akadia', color: '#A08060', sku: 'VTGAKADIA9X48-5MM-20MIL', price: 1.69, brand: 'MSI DryBack', series: 'Kallum', warranty: 'Lifetime/25yr Comm' },
        { id: 'msi-dryback-kallum-cranton', name: 'Kallum Cranton', color: '#8B7355', sku: 'VTGCRANTO9X48-5MM-20MIL', price: 1.69, brand: 'MSI DryBack', series: 'Kallum', warranty: 'Lifetime/25yr Comm' },
        { id: 'msi-dryback-kallum-fauna', name: 'Kallum Fauna', color: '#9E8B7D', sku: 'VTGFAUNA9X48-5MM-20MIL', price: 1.69, brand: 'MSI DryBack', series: 'Kallum', warranty: 'Lifetime/25yr Comm' },
        { id: 'msi-dryback-kallum-finely', name: 'Kallum Finely', color: '#6B5344', sku: 'VTGFINELY9X48-5MM-20MIL', price: 1.69, brand: 'MSI DryBack', series: 'Kallum', warranty: 'Lifetime/25yr Comm' },
        { id: 'msi-dryback-kallum-larkin', name: 'Kallum Larkin', color: '#C4A76C', sku: 'VTGLARKIN9X48-5MM-20MIL', price: 1.69, brand: 'MSI DryBack', series: 'Kallum', warranty: 'Lifetime/25yr Comm' },
        { id: 'msi-dryback-kallum-walnut-waves', name: 'Kallum Walnut Waves', color: '#5D4037', sku: 'VTGWALWAV9X48-5MM-20MIL', price: 1.69, brand: 'MSI DryBack', series: 'Kallum', warranty: 'Lifetime/25yr Comm' }
      ],
      showerPanels: [
        // Daltile LUXORA Shower Panels (CTF Price List Jan 2026)
        { id: 'luxora-calacatta-gold', name: 'LUXORA Calacatta Gold', color: '#FAF8F0', sku: 'LUX-CAL-G', price: 5.80, brand: 'Daltile' },
        { id: 'luxora-carrara', name: 'LUXORA Carrara', color: '#F5F5F5', sku: 'LUX-CAR', price: 5.20, brand: 'Daltile' },
        { id: 'luxora-bianco-statuario', name: 'LUXORA Bianco Statuario', color: '#FEFEFE', sku: 'LUX-BIA', price: 5.80, brand: 'Daltile' }
      ],
      // MSI Hardscape Products (Tier 3 Q1 2025 Pricing)
      hardscape: [
        // Travertine Pavers - with CDN images
        { id: 'msi-trav-tuscany-beige', name: 'Tuscany Beige Travertine Paver 16x24', color: '#D4C4A8', sku: 'LPATBEI1624TUMBLED', price: 4.07, brand: 'MSI', category: 'Travertine Pavers', size: '16x24' },
        { id: 'msi-trav-tuscany-beige-6x12', name: 'Tuscany Beige Travertine Paver 6x12', color: '#D4C4A8', sku: 'LPATBEI0612TUMBLED', price: 3.58, brand: 'MSI', category: 'Travertine Pavers', size: '6x12' },
        { id: 'msi-trav-tuscany-choc', name: 'Tuscany Chocolat Travertine Paver 16x24', color: '#6B5344', sku: 'LPATCHOC1624TUMBLED', price: 5.44, brand: 'MSI', category: 'Travertine Pavers', size: '16x24' },
        { id: 'msi-trav-tuscany-ivory', name: 'Tuscany Ivory Travertine Paver 16x24', color: '#F0E8E0', sku: 'LPATIVORY1624TUMBLED', price: 5.13, brand: 'MSI', category: 'Travertine Pavers', size: '16x24' },
        { id: 'msi-trav-tuscany-walnut', name: 'Tuscany Walnut Travertine Paver 16x24', color: '#8B7355', sku: 'LPATWALNUT1624TUMBLED', price: 4.91, brand: 'MSI', category: 'Travertine Pavers', size: '16x24' },
        // Pool Coping - with CDN images
        { id: 'msi-coping-tuscany-beige', name: 'Tuscany Beige Pool Coping 4x12', color: '#D4C4A8', sku: 'LCOPATBEI412TUMBLED', price: 9.45, brand: 'MSI', category: 'Pool Coping', size: '4x12' },
        { id: 'msi-coping-tuscany-ivory', name: 'Tuscany Ivory Pool Coping 4x12', color: '#F0E8E0', sku: 'LCOPATIVORY412TUMBLED', price: 9.81, brand: 'MSI', category: 'Pool Coping', size: '4x12' },
        { id: 'msi-coping-tuscany-walnut', name: 'Tuscany Walnut Pool Coping 4x12', color: '#8B7355', sku: 'LCOPATWALNUT412TUMBLED', price: 11.03, brand: 'MSI', category: 'Pool Coping', size: '4x12' },
        // Porcelain Pavers - Arterra Collection - with CDN images
        { id: 'msi-arterra-beton-gray', name: 'Arterra Beton Gray 24x24', color: '#9E9E9E', sku: 'LPARTBETGRY2424', price: 5.98, brand: 'MSI', category: 'Porcelain Pavers', size: '24x24' },
        { id: 'msi-arterra-legions-aspen', name: 'Arterra Legions Aspen Ash 24x24', color: '#A08060', sku: 'LPARTLEGASP2424', price: 6.98, brand: 'MSI', category: 'Porcelain Pavers', size: '24x24' },
        { id: 'msi-arterra-praia-grey', name: 'Arterra Praia Grey 24x24', color: '#7A7A7A', sku: 'LPARTPRAIAGRY2424', price: 5.98, brand: 'MSI', category: 'Porcelain Pavers', size: '24x24' },
        { id: 'msi-arterra-tierra-sol', name: 'Arterra Tierra Sol Beige 24x24', color: '#C4A878', sku: 'LPARTTIERBEI2424', price: 5.98, brand: 'MSI', category: 'Porcelain Pavers', size: '24x24' },
        // Stacked Stone - with CDN images
        { id: 'msi-stack-arctic-white', name: 'Arctic White Stacked Stone', color: '#F5F5F5', sku: 'LSLEDARCWHT', price: 10.98, brand: 'MSI', category: 'Stacked Stone', size: '6x24' },
        { id: 'msi-stack-charcoal', name: 'Charcoal Stacked Stone', color: '#4A4A4A', sku: 'LSLEDCHAR', price: 9.98, brand: 'MSI', category: 'Stacked Stone', size: '6x24' },
        { id: 'msi-stack-golden-honey', name: 'Golden Honey Stacked Stone', color: '#C4A76C', sku: 'LSLEDGLDHNY', price: 9.98, brand: 'MSI', category: 'Stacked Stone', size: '6x24' },
        { id: 'msi-stack-white-oak', name: 'White Oak Stacked Stone', color: '#E8E4DC', sku: 'LSLEDWHTOAK', price: 11.98, brand: 'MSI', category: 'Stacked Stone', size: '6x24' },
        // Decomposed Granite & Aggregates
        { id: 'msi-dg-pathway', name: 'Decomposed Granite Pathway', color: '#C4A878', sku: 'DG-PATHWAY', price: 89.00, brand: 'MSI', category: 'Aggregates', unit: 'per yard' },
        // Pebbles (40lb bags)
        { id: 'msi-pebble-amazon-multi', name: 'Amazon Multi Pebbles', color: '#8B7355', sku: 'LPEBQAMZMUL3NAT40', price: 14.50, brand: 'MSI', category: 'Pebbles', unit: 'per 40lb bag' },
        { id: 'msi-pebble-black', name: 'Black Polished Pebbles', color: '#1A1A1A', sku: 'LPEBQBLK3POL40', price: 14.50, brand: 'MSI', category: 'Pebbles', unit: 'per 40lb bag' },
        { id: 'msi-pebble-white', name: 'White Polished Pebbles', color: '#F5F5F5', sku: 'LPEBMWHI3POL40', price: 14.50, brand: 'MSI', category: 'Pebbles', unit: 'per 40lb bag' },
        { id: 'msi-pebble-mixed', name: 'Mixed Polished Pebbles', color: '#9E8B7D', sku: 'LPEBMMIX3POL40', price: 14.50, brand: 'MSI', category: 'Pebbles', unit: 'per 40lb bag' },
        { id: 'msi-pebble-nile-gray', name: 'Nile Gray Pebbles', color: '#7A7A7A', sku: 'LPEBQNILGRY3NAT40', price: 14.50, brand: 'MSI', category: 'Pebbles', unit: 'per 40lb bag' },
        { id: 'msi-pebble-himalaya-white', name: 'Himalaya White Pebbles', color: '#FAFAFA', sku: 'LPEBMHIMWHI3NAT40', price: 14.50, brand: 'MSI', category: 'Pebbles', unit: 'per 40lb bag' },
        // Fire Glass (20lb bags)
        { id: 'msi-fireglass-galaxy-black', name: 'Fire Glass Galaxy Black', color: '#0A0A0A', sku: 'LFIRGGALBLK0.5CRU20', price: 21.00, brand: 'MSI', category: 'Fire Glass', unit: 'per 20lb bag' },
        { id: 'msi-fireglass-aqua-blue', name: 'Fire Glass Aqua Blue', color: '#00CED1', sku: 'LFIRGAQUBLU0.25CRU20', price: 21.00, brand: 'MSI', category: 'Fire Glass', unit: 'per 20lb bag' },
        { id: 'msi-fireglass-sapphire-blue', name: 'Fire Glass Sapphire Blue', color: '#0F52BA', sku: 'LFIRGSAPBLU0.5CRU20', price: 21.00, brand: 'MSI', category: 'Fire Glass', unit: 'per 20lb bag' },
        { id: 'msi-fireglass-marine-blue', name: 'Fire Glass Marine Blue', color: '#4169E1', sku: 'LFIRGMARBLU0.5CRU20', price: 21.00, brand: 'MSI', category: 'Fire Glass', unit: 'per 20lb bag' },
        { id: 'msi-fireglass-copper-brown', name: 'Fire Glass Copper Brown', color: '#B87333', sku: 'LFIRGCOPBRO0.5CRU20', price: 21.00, brand: 'MSI', category: 'Fire Glass', unit: 'per 20lb bag' },
        { id: 'msi-fireglass-glacial-silver', name: 'Fire Glass Glacial Silver', color: '#C0C0C0', sku: 'LFIRGGLASIL0.5CRU20', price: 21.00, brand: 'MSI', category: 'Fire Glass', unit: 'per 20lb bag' }
      ],
      // MSI Vanity Collections (2024 Flyer)
      vanities: [
        // RTA Vanities - Ready-To-Assemble Collection
        { id: 'msi-rta-v2721-white', name: 'RTA Vanity 27x21 White', color: '#FFFFFF', sku: 'VANHDR-V2721-WHT', brand: 'MSI', collection: 'RTA', width: 27, features: 'Plywood, Soft-close doors' },
        { id: 'msi-rta-v3021-white', name: 'RTA Vanity 30x21 White', color: '#FFFFFF', sku: 'VANHDR-V3021-WHT', brand: 'MSI', collection: 'RTA', width: 30, features: 'Plywood, Soft-close doors' },
        { id: 'msi-rta-v3621-white', name: 'RTA Vanity 36x21 White', color: '#FFFFFF', sku: 'VANHDR-V3621-WHT', brand: 'MSI', collection: 'RTA', width: 36, features: 'Plywood, Soft-close doors' },
        { id: 'msi-rta-v4821-white', name: 'RTA Vanity 48x21 Single Bowl White', color: '#FFFFFF', sku: 'VANHDR-V4821SB-FLSW-2H', brand: 'MSI', collection: 'RTA', width: 48, features: '4 doors, 2 drawers, Plywood' },
        { id: 'msi-rta-v6021-white', name: 'RTA Vanity 60x21 Double Bowl White', color: '#FFFFFF', sku: 'VANHDR-V6021DB-FLSW-2H', brand: 'MSI', collection: 'RTA', width: 60, features: '4 doors, 2 tilted drawers, Plywood' },
        { id: 'msi-rta-vdb15-white', name: 'RTA Drawer Vanity 15" White', color: '#FFFFFF', sku: 'VDB15-3', brand: 'MSI', collection: 'RTA', width: 15, features: '3-Drawer, Plywood' },
        { id: 'msi-rta-vdb21-white', name: 'RTA Drawer Vanity 21" White', color: '#FFFFFF', sku: 'VDB21-3', brand: 'MSI', collection: 'RTA', width: 21, features: '3-Drawer, Plywood' },
        // RTA Vanities - Grey Color
        { id: 'msi-rta-v3021-grey', name: 'RTA Vanity 30x21 Grey', color: '#7A7A7A', sku: 'VANHDR-V3021-GRY', brand: 'MSI', collection: 'RTA', width: 30, features: 'Plywood, Soft-close doors' },
        { id: 'msi-rta-v3621-grey', name: 'RTA Vanity 36x21 Grey', color: '#7A7A7A', sku: 'VANHDR-V3621-GRY', brand: 'MSI', collection: 'RTA', width: 36, features: 'Plywood, Soft-close doors' },
        { id: 'msi-rta-v4821-grey', name: 'RTA Vanity 48x21 Grey', color: '#7A7A7A', sku: 'VANHDR-V4821SB-GRY', brand: 'MSI', collection: 'RTA', width: 48, features: '4 doors, 2 drawers, Plywood' },
        // RTA Vanities - Blue Color
        { id: 'msi-rta-v3021-blue', name: 'RTA Vanity 30x21 Blue', color: '#4A6B8C', sku: 'VANHDR-V3021-BLU', brand: 'MSI', collection: 'RTA', width: 30, features: 'Plywood, Soft-close doors' },
        { id: 'msi-rta-v3621-blue', name: 'RTA Vanity 36x21 Blue', color: '#4A6B8C', sku: 'VANHDR-V3621-BLU', brand: 'MSI', collection: 'RTA', width: 36, features: 'Plywood, Soft-close doors' },
        // RTA Vanities - Black Color
        { id: 'msi-rta-v3021-black', name: 'RTA Vanity 30x21 Black', color: '#1A1A1A', sku: 'VANHDR-V3021-BLK', brand: 'MSI', collection: 'RTA', width: 30, features: 'Plywood, Soft-close doors' },
        { id: 'msi-rta-v3621-black', name: 'RTA Vanity 36x21 Black', color: '#1A1A1A', sku: 'VANHDR-V3621-BLK', brand: 'MSI', collection: 'RTA', width: 36, features: 'Plywood, Soft-close doors' },
        // RTA Vanities - Natural Oak
        { id: 'msi-rta-v3021-oak', name: 'RTA Vanity 30x21 Natural Oak', color: '#C4A76C', sku: 'VANHDR-V3021-OAK', brand: 'MSI', collection: 'RTA', width: 30, features: 'Wood veneer, Soft-close doors' },
        { id: 'msi-rta-v3621-oak', name: 'RTA Vanity 36x21 Natural Oak', color: '#C4A76C', sku: 'VANHDR-V3621-OAK', brand: 'MSI', collection: 'RTA', width: 36, features: 'Wood veneer, Soft-close doors' },
        // Fluted Vanities - Pre-Assembled Collection
        { id: 'msi-fluted-v3021', name: 'Fluted Vanity 30x21', color: '#DEB887', sku: 'VANFLT-V3021', brand: 'MSI', collection: 'Fluted', width: 30, features: 'Solid wood, Wood veneer, Pre-assembled' },
        { id: 'msi-fluted-v3621', name: 'Fluted Vanity 36x21', color: '#DEB887', sku: 'VANFLT-V3621', brand: 'MSI', collection: 'Fluted', width: 36, features: 'Solid wood, 3 drawers, Pre-assembled' },
        { id: 'msi-fluted-v3021-tilt', name: 'Fluted Vanity 30x21 w/Tilt Drawer', color: '#DEB887', sku: 'VANFLT-V3021-TILT', brand: 'MSI', collection: 'Fluted', width: 30, features: 'Solid wood, Tilted drawer, Pre-assembled' },
        { id: 'msi-fluted-v3621-tilt', name: 'Fluted Vanity 36x21 w/Tilt Drawer', color: '#DEB887', sku: 'VANFLT-V3621-TILT', brand: 'MSI', collection: 'Fluted', width: 36, features: 'Solid wood, 2 tilted drawers, Pre-assembled' },
        // Folding Vanities - Easy Assembly Collection
        { id: 'msi-fold-v2421', name: 'Folding Vanity 24x21', color: '#FFFFFF', sku: 'VANFOLD-V2421', brand: 'MSI', collection: 'Folding', width: 24, features: 'Solid wood frame, Plywood box, Easy assembly' },
        { id: 'msi-fold-v3021', name: 'Folding Vanity 30x21', color: '#FFFFFF', sku: 'VANFOLD-V3021', brand: 'MSI', collection: 'Folding', width: 30, features: 'Solid wood frame, Plywood box, Easy assembly' },
        { id: 'msi-fold-v3621', name: 'Folding Vanity 36x21', color: '#FFFFFF', sku: 'VANFOLD-V3621', brand: 'MSI', collection: 'Folding', width: 36, features: 'Solid wood frame, Plywood box, Easy assembly' },
        { id: 'msi-fold-v4221', name: 'Folding Vanity 42x21', color: '#FFFFFF', sku: 'VANFOLD-V4221', brand: 'MSI', collection: 'Folding', width: 42, features: 'Solid wood frame, Plywood box, Easy assembly' },
        { id: 'msi-fold-v4821', name: 'Folding Vanity 48x21', color: '#FFFFFF', sku: 'VANFOLD-V4821', brand: 'MSI', collection: 'Folding', width: 48, features: 'Solid wood frame, Plywood box, Easy assembly' },
        { id: 'msi-fold-v6021', name: 'Folding Vanity 60x21', color: '#FFFFFF', sku: 'VANFOLD-V6021', brand: 'MSI', collection: 'Folding', width: 60, features: 'Solid wood frame, Plywood box, Easy assembly' }
      ],
      // MSI Flooring Trim & Accessories
      flooringTrims: [
        { id: 'msi-trim-stairtread', name: 'Stair Tread (Eased Edge)', color: '#8B7355', sku: 'STAIR-TREAD', price: 37.00, brand: 'MSI', size: '47.25" x 12"', unit: 'each' },
        { id: 'msi-trim-stairnose-flush', name: 'Stair Nose (Flush)', color: '#8B7355', sku: 'STAIRNOSE-FLUSH', price: 32.00, brand: 'MSI', size: '94"', unit: 'each' },
        { id: 'msi-trim-stairnose-overlap', name: 'Stair Nose (Overlapping)', color: '#8B7355', sku: 'STAIRNOSE-OVERLAP', price: 27.00, brand: 'MSI', size: '94"', unit: 'each' },
        { id: 'msi-trim-endcap', name: 'End Cap', color: '#8B7355', sku: 'ENDCAP', price: 27.00, brand: 'MSI', size: '94"', unit: 'each' },
        { id: 'msi-trim-reducer', name: 'Surface Reducer', color: '#8B7355', sku: 'REDUCER', price: 22.00, brand: 'MSI', size: '94"', unit: 'each' },
        { id: 'msi-trim-tmolding', name: 'T-Molding', color: '#8B7355', sku: 'TMOLDING', price: 27.00, brand: 'MSI', size: '94"', unit: 'each' },
        { id: 'msi-trim-quarterround', name: 'Quarter Round', color: '#8B7355', sku: 'QUARTERROUND', price: 20.00, brand: 'MSI', size: '94"', unit: 'each' }
      ],
      // Cabinet Accessories
      cabinetAccessories: [
        { id: 'msi-acc-basepanel', name: 'Base Panel 36x96', color: '#F5F5F5', sku: 'BP3696', price: 59.39, brand: 'MSI' },
        { id: 'msi-acc-dishwasher-return', name: 'Dishwasher Return Panel', color: '#F5F5F5', sku: 'DWR3', price: 26.35, brand: 'MSI' },
        { id: 'msi-acc-basefiller', name: 'Base Filler 3x30', color: '#F5F5F5', sku: 'F330', price: 12.73, brand: 'MSI' },
        { id: 'msi-acc-scribemolding', name: 'Scribe Molding 96"', color: '#F5F5F5', sku: 'SM8', price: 6.43, brand: 'MSI' },
        { id: 'msi-acc-tallendpanel', name: 'Tall End Panel 30x96', color: '#F5F5F5', sku: 'TEP3096', price: 170.32, brand: 'MSI' },
        { id: 'msi-acc-toekick', name: 'Toe Kick 96"', color: '#F5F5F5', sku: 'TK8', price: 8.88, brand: 'MSI' },
        { id: 'msi-acc-wallfiller36', name: 'Wall Filler 3x36', color: '#F5F5F5', sku: 'WF336', price: 27.19, brand: 'MSI' },
        { id: 'msi-acc-wallfiller42', name: 'Wall Filler 3x42', color: '#F5F5F5', sku: 'WF342', price: 31.58, brand: 'MSI' },
        { id: 'msi-acc-wallfiller96', name: 'Wall Filler 3x96', color: '#F5F5F5', sku: 'WF396', price: 41.64, brand: 'MSI' }
      ]
    };

    // Stone pricing loaded from external JSON file (contains 1137 materials from Excel import)
    let stonePricingLoaded = false;

    // Load stone pricing data from external JSON file and merge into MATERIALS
    async function loadStonePricing() {
      if (stonePricingLoaded) return; // Already loaded

      try {
        const response = await fetch('stone-pricing.json');
        if (!response.ok) {
          console.warn('Stone pricing file not found, using built-in materials only');
          return;
        }

        const stonePricing = await response.json();
        let addedCount = 0;

        // Merge each category
        for (const category of ['granite', 'quartz', 'quartzite', 'marble', 'porcelain']) {
          if (stonePricing[category] && MATERIALS[category]) {
            // Get existing IDs to avoid duplicates
            const existingIds = new Set(MATERIALS[category].map(m => m.id));

            // Add new materials that don't already exist
            for (const material of stonePricing[category]) {
              if (!existingIds.has(material.id)) {
                MATERIALS[category].push(material);
                addedCount++;
              }
            }
          } else if (stonePricing[category]) {
            // Category doesn't exist in MATERIALS, create it
            MATERIALS[category] = stonePricing[category];
            addedCount += stonePricing[category].length;
          }
        }

        stonePricingLoaded = true;
        console.log(`Loaded ${addedCount} stone materials from pricing file`);

        // Refresh the materials panel if it's currently showing a stone category
        const activeCategory = document.querySelector('.material-tab.active')?.dataset?.category;
        if (['granite', 'quartz', 'quartzite', 'marble'].includes(activeCategory)) {
          renderMaterials(activeCategory);
        }

        return addedCount;
      } catch (error) {
        console.warn('Could not load stone pricing:', error);
        return 0;
      }
    }

    // Price tier helper for materials
    const PRICE_TIERS = {
      budget: { min: 0, max: 12.60, label: 'Budget-Friendly', color: '#10b981' },
      popular: { min: 12.60, max: 25.90, label: 'Popular Choice', color: '#f59e0b' },
      premium: { min: 25.90, max: 100, label: 'Premium', color: '#8b5cf6' }
    };

    function getMaterialPriceTier(price) {
      if (!price) return null;
      if (price <= PRICE_TIERS.budget.max) return 'budget';
      if (price <= PRICE_TIERS.popular.max) return 'popular';
      return 'premium';
    }

    // Helper to proxy external CDN URLs for CORS (using images.weserv.nl)
    function getProxiedUrl(url) {
      if (!url) return url;
      if (url.includes('cdn.msisurfaces.com')) {
        // Use images.weserv.nl as image proxy - it adds CORS headers
        return `https://images.weserv.nl/?url=${url.replace('https://', '')}`;
      }
      return url;
    }

    // Cabinet Catalogs from Manufacturers
    const CABINET_CATALOGS = {
      procraft: {
        name: 'ProCraft Cabinetry',
        logo: '/images/6456ce4476abb265e5fbb1f1_62708265be16bc2ec3e69111_procraft-cabinetry-p-500.png',
        series: {
          'shaker-white': { name: 'Shaker White', color: '#f5f5f5' },
          'shaker-grey': { name: 'Shaker Grey', color: '#7a7a7a' },
          'shaker-espresso': { name: 'Shaker Espresso', color: '#3d2b1f' }
        },
        cabinets: {
          base: [
            { sku: 'B09', name: 'Base 9"', width: 0.75, height: 2, depth: 2, type: 'base-cabinet', price: 185 },
            { sku: 'B12', name: 'Base 12"', width: 1, height: 2, depth: 2, type: 'base-cabinet', price: 215 },
            { sku: 'B15', name: 'Base 15"', width: 1.25, height: 2, depth: 2, type: 'base-cabinet', price: 245 },
            { sku: 'B18', name: 'Base 18"', width: 1.5, height: 2, depth: 2, type: 'base-cabinet', price: 275 },
            { sku: 'B21', name: 'Base 21"', width: 1.75, height: 2, depth: 2, type: 'base-cabinet', price: 305 },
            { sku: 'B24', name: 'Base 24"', width: 2, height: 2, depth: 2, type: 'base-cabinet', price: 335 },
            { sku: 'B27', name: 'Base 27"', width: 2.25, height: 2, depth: 2, type: 'base-cabinet', price: 365 },
            { sku: 'B30', name: 'Base 30"', width: 2.5, height: 2, depth: 2, type: 'base-cabinet', price: 395 },
            { sku: 'B33', name: 'Base 33"', width: 2.75, height: 2, depth: 2, type: 'base-cabinet', price: 425 },
            { sku: 'B36', name: 'Base 36"', width: 3, height: 2, depth: 2, type: 'base-cabinet', price: 455 },
            { sku: 'B42', name: 'Base 42"', width: 3.5, height: 2, depth: 2, type: 'base-cabinet', price: 515 },
            { sku: 'B48', name: 'Base 48"', width: 4, height: 2, depth: 2, type: 'base-cabinet', price: 575 }
          ],
          wall: [
            { sku: 'W0930', name: 'Wall 9"x30"', width: 0.75, height: 1.25, depth: 2.5, type: 'wall-cabinet', price: 145 },
            { sku: 'W1230', name: 'Wall 12"x30"', width: 1, height: 1.25, depth: 2.5, type: 'wall-cabinet', price: 165 },
            { sku: 'W1530', name: 'Wall 15"x30"', width: 1.25, height: 1.25, depth: 2.5, type: 'wall-cabinet', price: 185 },
            { sku: 'W1830', name: 'Wall 18"x30"', width: 1.5, height: 1.25, depth: 2.5, type: 'wall-cabinet', price: 205 },
            { sku: 'W2130', name: 'Wall 21"x30"', width: 1.75, height: 1.25, depth: 2.5, type: 'wall-cabinet', price: 225 },
            { sku: 'W2430', name: 'Wall 24"x30"', width: 2, height: 1.25, depth: 2.5, type: 'wall-cabinet', price: 245 },
            { sku: 'W3030', name: 'Wall 30"x30"', width: 2.5, height: 1.25, depth: 2.5, type: 'wall-cabinet', price: 285 },
            { sku: 'W3630', name: 'Wall 36"x30"', width: 3, height: 1.25, depth: 2.5, type: 'wall-cabinet', price: 325 },
            { sku: 'W0936', name: 'Wall 9"x36"', width: 0.75, height: 1.25, depth: 3, type: 'wall-cabinet', price: 165 },
            { sku: 'W1236', name: 'Wall 12"x36"', width: 1, height: 1.25, depth: 3, type: 'wall-cabinet', price: 185 },
            { sku: 'W1536', name: 'Wall 15"x36"', width: 1.25, height: 1.25, depth: 3, type: 'wall-cabinet', price: 215 },
            { sku: 'W1836', name: 'Wall 18"x36"', width: 1.5, height: 1.25, depth: 3, type: 'wall-cabinet', price: 245 },
            { sku: 'W2436', name: 'Wall 24"x36"', width: 2, height: 1.25, depth: 3, type: 'wall-cabinet', price: 285 },
            { sku: 'W3036', name: 'Wall 30"x36"', width: 2.5, height: 1.25, depth: 3, type: 'wall-cabinet', price: 335 },
            { sku: 'W3636', name: 'Wall 36"x36"', width: 3, height: 1.25, depth: 3, type: 'wall-cabinet', price: 385 },
            { sku: 'W0942', name: 'Wall 9"x42"', width: 0.75, height: 1.25, depth: 3.5, type: 'wall-cabinet', price: 185 },
            { sku: 'W1242', name: 'Wall 12"x42"', width: 1, height: 1.25, depth: 3.5, type: 'wall-cabinet', price: 215 },
            { sku: 'W1842', name: 'Wall 18"x42"', width: 1.5, height: 1.25, depth: 3.5, type: 'wall-cabinet', price: 275 },
            { sku: 'W2442', name: 'Wall 24"x42"', width: 2, height: 1.25, depth: 3.5, type: 'wall-cabinet', price: 325 },
            { sku: 'W3042', name: 'Wall 30"x42"', width: 2.5, height: 1.25, depth: 3.5, type: 'wall-cabinet', price: 385 },
            { sku: 'W3642', name: 'Wall 36"x42"', width: 3, height: 1.25, depth: 3.5, type: 'wall-cabinet', price: 445 }
          ],
          tall: [
            { sku: 'T189024', name: 'Pantry 18"x90"', width: 1.5, height: 2, depth: 7.5, type: 'tall-cabinet', price: 685 },
            { sku: 'T249024', name: 'Pantry 24"x90"', width: 2, height: 2, depth: 7.5, type: 'tall-cabinet', price: 795 },
            { sku: 'T309024', name: 'Pantry 30"x90"', width: 2.5, height: 2, depth: 7.5, type: 'tall-cabinet', price: 895 },
            { sku: 'T369024', name: 'Pantry 36"x90"', width: 3, height: 2, depth: 7.5, type: 'tall-cabinet', price: 995 },
            { sku: 'OC3390', name: 'Oven Cabinet 33"x90"', width: 2.75, height: 2, depth: 7.5, type: 'tall-cabinet', price: 945 },
            { sku: 'OC3396', name: 'Oven Cabinet 33"x96"', width: 2.75, height: 2, depth: 8, type: 'tall-cabinet', price: 1045 }
          ],
          corner: [
            { sku: 'DERA36', name: 'Diagonal Corner 36"', width: 3, height: 3, depth: 2, type: 'corner-cabinet', price: 545 },
            { sku: 'WDC2430', name: 'Diagonal Wall 24"x30"', width: 2, height: 2, depth: 2.5, type: 'corner-cabinet', price: 385 },
            { sku: 'WDC2436', name: 'Diagonal Wall 24"x36"', width: 2, height: 2, depth: 3, type: 'corner-cabinet', price: 425 },
            { sku: 'WDC2442', name: 'Diagonal Wall 24"x42"', width: 2, height: 2, depth: 3.5, type: 'corner-cabinet', price: 465 }
          ],
          lazySusan: [
            { sku: 'BLS33', name: 'Lazy Susan 33"', width: 2.75, height: 2.75, depth: 2, type: 'lazy-susan', price: 595 },
            { sku: 'BLS36', name: 'Lazy Susan 36"', width: 3, height: 3, depth: 2, type: 'lazy-susan', price: 645 },
            { sku: 'BLS39', name: 'Lazy Susan 39"', width: 3.25, height: 3.25, depth: 2, type: 'lazy-susan', price: 695 }
          ],
          sink: [
            { sku: 'SB30', name: 'Sink Base 30"', width: 2.5, height: 2, depth: 2, type: 'sink-base', price: 365 },
            { sku: 'SB33', name: 'Sink Base 33"', width: 2.75, height: 2, depth: 2, type: 'sink-base', price: 395 },
            { sku: 'SB36', name: 'Sink Base 36"', width: 3, height: 2, depth: 2, type: 'sink-base', price: 425 },
            { sku: 'SB42', name: 'Sink Base 42"', width: 3.5, height: 2, depth: 2, type: 'sink-base', price: 485 }
          ],
          drawer: [
            { sku: 'DB12', name: 'Drawer Base 12"', width: 1, height: 2, depth: 2, type: 'drawer-base', price: 295 },
            { sku: 'DB15', name: 'Drawer Base 15"', width: 1.25, height: 2, depth: 2, type: 'drawer-base', price: 335 },
            { sku: 'DB18', name: 'Drawer Base 18"', width: 1.5, height: 2, depth: 2, type: 'drawer-base', price: 375 },
            { sku: 'DB24', name: 'Drawer Base 24"', width: 2, height: 2, depth: 2, type: 'drawer-base', price: 425 },
            { sku: 'DB30', name: 'Drawer Base 30"', width: 2.5, height: 2, depth: 2, type: 'drawer-base', price: 485 },
            { sku: 'DB36', name: 'Drawer Base 36"', width: 3, height: 2, depth: 2, type: 'drawer-base', price: 545 }
          ]
        }
      },
      msi: {
        name: 'MSI Cabinetry',
        logo: null,
        series: {
          'euro-white': { name: 'Euro White', color: '#ffffff' },
          'euro-grey': { name: 'Euro Grey', color: '#6a6a6a' },
          'shaker-dove': { name: 'Shaker Dove', color: '#d3d3d3' },
          'shaker-graphite': { name: 'Shaker Graphite', color: '#4a4a4a' }
        },
        cabinets: {
          base: [
            { sku: 'MSI-B12', name: 'Base 12"', width: 1, height: 2, depth: 2, type: 'base-cabinet', price: 189 },
            { sku: 'MSI-B15', name: 'Base 15"', width: 1.25, height: 2, depth: 2, type: 'base-cabinet', price: 219 },
            { sku: 'MSI-B18', name: 'Base 18"', width: 1.5, height: 2, depth: 2, type: 'base-cabinet', price: 249 },
            { sku: 'MSI-B21', name: 'Base 21"', width: 1.75, height: 2, depth: 2, type: 'base-cabinet', price: 279 },
            { sku: 'MSI-B24', name: 'Base 24"', width: 2, height: 2, depth: 2, type: 'base-cabinet', price: 309 },
            { sku: 'MSI-B27', name: 'Base 27"', width: 2.25, height: 2, depth: 2, type: 'base-cabinet', price: 339 },
            { sku: 'MSI-B30', name: 'Base 30"', width: 2.5, height: 2, depth: 2, type: 'base-cabinet', price: 369 },
            { sku: 'MSI-B33', name: 'Base 33"', width: 2.75, height: 2, depth: 2, type: 'base-cabinet', price: 399 },
            { sku: 'MSI-B36', name: 'Base 36"', width: 3, height: 2, depth: 2, type: 'base-cabinet', price: 429 }
          ],
          wall: [
            { sku: 'MSI-W1230', name: 'Wall 12"x30"', width: 1, height: 1.25, depth: 2.5, type: 'wall-cabinet', price: 149 },
            { sku: 'MSI-W1530', name: 'Wall 15"x30"', width: 1.25, height: 1.25, depth: 2.5, type: 'wall-cabinet', price: 169 },
            { sku: 'MSI-W1830', name: 'Wall 18"x30"', width: 1.5, height: 1.25, depth: 2.5, type: 'wall-cabinet', price: 189 },
            { sku: 'MSI-W2430', name: 'Wall 24"x30"', width: 2, height: 1.25, depth: 2.5, type: 'wall-cabinet', price: 229 },
            { sku: 'MSI-W3030', name: 'Wall 30"x30"', width: 2.5, height: 1.25, depth: 2.5, type: 'wall-cabinet', price: 269 },
            { sku: 'MSI-W3630', name: 'Wall 36"x30"', width: 3, height: 1.25, depth: 2.5, type: 'wall-cabinet', price: 309 },
            { sku: 'MSI-W1236', name: 'Wall 12"x36"', width: 1, height: 1.25, depth: 3, type: 'wall-cabinet', price: 169 },
            { sku: 'MSI-W1536', name: 'Wall 15"x36"', width: 1.25, height: 1.25, depth: 3, type: 'wall-cabinet', price: 199 },
            { sku: 'MSI-W1836', name: 'Wall 18"x36"', width: 1.5, height: 1.25, depth: 3, type: 'wall-cabinet', price: 229 },
            { sku: 'MSI-W2436', name: 'Wall 24"x36"', width: 2, height: 1.25, depth: 3, type: 'wall-cabinet', price: 269 },
            { sku: 'MSI-W3036', name: 'Wall 30"x36"', width: 2.5, height: 1.25, depth: 3, type: 'wall-cabinet', price: 319 },
            { sku: 'MSI-W3636', name: 'Wall 36"x36"', width: 3, height: 1.25, depth: 3, type: 'wall-cabinet', price: 369 }
          ],
          tall: [
            { sku: 'MSI-T1890', name: 'Pantry 18"x90"', width: 1.5, height: 2, depth: 7.5, type: 'tall-cabinet', price: 649 },
            { sku: 'MSI-T2490', name: 'Pantry 24"x90"', width: 2, height: 2, depth: 7.5, type: 'tall-cabinet', price: 749 },
            { sku: 'MSI-T3090', name: 'Pantry 30"x90"', width: 2.5, height: 2, depth: 7.5, type: 'tall-cabinet', price: 849 }
          ],
          corner: [
            { sku: 'MSI-BC36', name: 'Base Corner 36"', width: 3, height: 3, depth: 2, type: 'corner-cabinet', price: 495 },
            { sku: 'MSI-WC24', name: 'Wall Corner 24"', width: 2, height: 2, depth: 2.5, type: 'corner-cabinet', price: 359 }
          ],
          sink: [
            { sku: 'MSI-SB30', name: 'Sink Base 30"', width: 2.5, height: 2, depth: 2, type: 'sink-base', price: 339 },
            { sku: 'MSI-SB33', name: 'Sink Base 33"', width: 2.75, height: 2, depth: 2, type: 'sink-base', price: 369 },
            { sku: 'MSI-SB36', name: 'Sink Base 36"', width: 3, height: 2, depth: 2, type: 'sink-base', price: 399 }
          ],
          drawer: [
            { sku: 'MSI-DB12', name: 'Drawer Base 12"', width: 1, height: 2, depth: 2, type: 'drawer-base', price: 269 },
            { sku: 'MSI-DB15', name: 'Drawer Base 15"', width: 1.25, height: 2, depth: 2, type: 'drawer-base', price: 309 },
            { sku: 'MSI-DB18', name: 'Drawer Base 18"', width: 1.5, height: 2, depth: 2, type: 'drawer-base', price: 349 },
            { sku: 'MSI-DB24', name: 'Drawer Base 24"', width: 2, height: 2, depth: 2, type: 'drawer-base', price: 399 }
          ]
        }
      },
      custom: {
        name: 'Custom Cabinets',
        logo: null,
        series: {},
        cabinets: {
          imported: [] // User-uploaded cabinet list
        }
      }
    };

    let currentCatalog = 'procraft';
    let currentCabinetCategory = 'base';
    let currentCabinetSeries = 'shaker-white';

    // ===== STATE =====
    let canvas, ctx;
    let currentTool = 'select';
    let currentView = '2d';
    let zoom = 1;
    let pixelsPerFoot = 40;
    let elements = [];
    let walls = [];
    let selectedElement = null;
    let isDragging = false;
    let dragOffset = { x: 0, y: 0 };
    let autoRotationApplied = false; // Track if auto-rotation was applied during this drag
    let lastSnappedWall = null; // Track which wall we last snapped to

    // Element cycling state - for cycling through overlapping elements
    let lastClickPos = { x: 0, y: 0 };
    let lastClickTime = 0;
    let cycleIndex = 0;
    const CLICK_CYCLE_THRESHOLD = 20; // pixels - how close clicks need to be to cycle
    const CLICK_CYCLE_TIME = 1000; // ms - max time between clicks to cycle

    // Resize state
    let isResizing = false;
    let resizeHandle = null; // 'nw', 'n', 'ne', 'e', 'se', 's', 'sw', 'w'
    let resizeStart = { x: 0, y: 0, width: 0, height: 0, elX: 0, elY: 0 };
    const HANDLE_SIZE = 10;

    let roomWidth = 20;
    let roomDepth = 16;
    let roomHeight = 8; // Ceiling height in feet (8', 9', 10', 12')
    let currentFloorPlan = 'empty';
    let contextMenuElement = null;
    let elementTextures = {}; // Store custom textures for element types
    let customMaterials = []; // User uploaded materials

    // Multi-room support
    let rooms = [];
    let currentRoomId = null;

    // Initialize default room
    function initializeRooms() {
      if (rooms.length === 0) {
        rooms.push({
          id: 'room-' + Date.now(),
          name: 'Kitchen',
          type: 'kitchen',
          width: roomWidth,
          depth: roomDepth,
          offsetX: 0,  // Position in multi-room layout
          offsetY: 0,
          elements: [],
          walls: [],
          floorPlan: 'empty'
        });
        currentRoomId = rooms[0].id;
      }
    }

    // Get current room object
    function getCurrentRoom() {
      return rooms.find(r => r.id === currentRoomId) || rooms[0];
    }

    // Save current room state before switching
    function saveCurrentRoomState() {
      const room = getCurrentRoom();
      if (room) {
        room.width = roomWidth;
        room.depth = roomDepth;
        room.elements = [...elements];
        room.walls = [...walls];
        room.floorPlan = currentFloorPlan;
      }
    }

    // Switch to a different room
    function switchToRoom(roomId) {
      saveCurrentRoomState();

      const room = rooms.find(r => r.id === roomId);
      if (!room) return;

      currentRoomId = roomId;
      roomWidth = room.width;
      roomDepth = room.depth;
      elements = room.elements || [];
      walls = room.walls || [];
      currentFloorPlan = room.floorPlan || 'empty';

      // Update UI
      document.getElementById('roomWidth').value = roomWidth;
      document.getElementById('roomDepth').value = roomDepth;
      document.getElementById('roomType').value = room.type || 'kitchen';

      // Redraw
      fitToScreen();
      draw();
      updateRoomList();
      calculateQuote();

      showToast(`Switched to ${room.name}`, 'info');
    }

    // Add a new room
    function addNewRoom(name, type, width, depth) {
      saveCurrentRoomState();

      // Calculate position for new room (to the right of existing rooms)
      let maxX = 0;
      rooms.forEach(r => {
        const rightEdge = r.offsetX + r.width;
        if (rightEdge > maxX) maxX = rightEdge;
      });

      const newRoom = {
        id: 'room-' + Date.now(),
        name: name || `Room ${rooms.length + 1}`,
        type: type || 'kitchen',
        width: width || 12,
        depth: depth || 10,
        offsetX: maxX + 2,  // 2ft gap between rooms
        offsetY: 0,
        elements: [],
        walls: [],
        floorPlan: 'empty'
      };

      rooms.push(newRoom);
      switchToRoom(newRoom.id);

      return newRoom;
    }

    // Delete a room
    function deleteRoom(roomId) {
      if (rooms.length <= 1) {
        showToast('Cannot delete the only room', 'error');
        return;
      }

      const index = rooms.findIndex(r => r.id === roomId);
      if (index === -1) return;

      const roomName = rooms[index].name;
      rooms.splice(index, 1);

      // If deleted current room, switch to first room
      if (currentRoomId === roomId) {
        switchToRoom(rooms[0].id);
      }

      updateRoomList();
      showToast(`Deleted ${roomName}`, 'info');
    }

    // Update room list UI
    function updateRoomList() {
      const container = document.getElementById('roomList');
      if (!container) return;

      container.innerHTML = rooms.map(room => `
        <div class="room-item ${room.id === currentRoomId ? 'active' : ''}" onclick="switchToRoom('${room.id}')">
          <span class="room-icon">${room.type === 'kitchen' ? 'ðŸ³' : room.type === 'bathroom' ? 'ðŸš¿' : 'ðŸ '}</span>
          <span class="room-name">${room.name}</span>
          <span class="room-size">${room.width}'Ã—${room.depth}'</span>
          ${rooms.length > 1 ? `<button class="room-delete-btn" onclick="event.stopPropagation(); deleteRoom('${room.id}')" title="Delete room">Ã—</button>` : ''}
        </div>
      `).join('');
    }

    // Show add room modal
    function showAddRoomModal() {
      const modal = document.getElementById('addRoomModal');
      if (modal) {
        modal.classList.add('active');
      } else {
        // Simple prompt fallback
        const name = prompt('Room name:', `Room ${rooms.length + 1}`);
        if (name) {
          const type = prompt('Room type (kitchen, bathroom, laundry, other):', 'kitchen');
          const width = parseInt(prompt('Room width (feet):', '12')) || 12;
          const depth = parseInt(prompt('Room depth (feet):', '10')) || 10;
          addNewRoom(name, type, width, depth);
        }
      }
    }

    // Make functions globally accessible
    window.switchToRoom = switchToRoom;
    window.addNewRoom = addNewRoom;
    window.deleteRoom = deleteRoom;
    window.showAddRoomModal = showAddRoomModal;
    window.updateRoomList = updateRoomList;

    // View all rooms in 3D (multi-room layout)
    let viewingAllRooms = false;

    function viewAllRooms3D() {
      saveCurrentRoomState();
      viewingAllRooms = true;

      // Switch to 3D view
      setView('3d');

      // Rebuild 3D scene with all rooms
      setTimeout(() => {
        init3DMultiRoom();
        showToast('Viewing all rooms - click a room to edit', 'info');
      }, 100);
    }

    // Initialize 3D scene with all rooms
    function init3DMultiRoom() {
      if (!window.THREE) {
        console.error('Three.js not loaded');
        return;
      }

      const container = document.getElementById('view3D');
      if (!container) return;

      // Clear existing scene
      container.innerHTML = '';

      // Calculate total layout dimensions
      let totalWidth = 0;
      let totalDepth = 0;
      rooms.forEach(room => {
        const rightEdge = room.offsetX + room.width;
        const bottomEdge = room.offsetY + room.depth;
        if (rightEdge > totalWidth) totalWidth = rightEdge;
        if (bottomEdge > totalDepth) totalDepth = bottomEdge;
      });

      // Create scene
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x1a1a2e);

      // Create camera with view of entire layout
      const camera = new THREE.PerspectiveCamera(
        60,
        container.clientWidth / container.clientHeight,
        0.1,
        1000
      );
      camera.position.set(totalWidth / 2, Math.max(totalWidth, totalDepth) * 1.5, totalDepth * 1.5);
      camera.lookAt(totalWidth / 2, 0, totalDepth / 2);

      // Create renderer
      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(container.clientWidth, container.clientHeight);
      renderer.shadowMap.enabled = true;
      container.appendChild(renderer.domElement);

      // Add controls
      const controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.target.set(totalWidth / 2, 0, totalDepth / 2);
      controls.update();

      // Lighting
      const ambient = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambient);

      const sun = new THREE.DirectionalLight(0xFFFBF0, 1.0);
      sun.position.set(totalWidth, 20, totalDepth / 2);
      sun.castShadow = true;
      scene.add(sun);

      // Render each room
      rooms.forEach((room, roomIndex) => {
        const roomGroup = new THREE.Group();
        roomGroup.position.set(room.offsetX, 0, room.offsetY);
        roomGroup.userData = { roomId: room.id, roomName: room.name };

        // Floor
        const floorGeo = new THREE.PlaneGeometry(room.width, room.depth);
        const floorMat = new THREE.MeshStandardMaterial({
          color: roomIndex === rooms.findIndex(r => r.id === currentRoomId) ? 0x3a5a8a : 0x2a3a4a,
          side: THREE.DoubleSide
        });
        const floor = new THREE.Mesh(floorGeo, floorMat);
        floor.rotation.x = -Math.PI / 2;
        floor.position.set(room.width / 2, 0, room.depth / 2);
        floor.receiveShadow = true;
        roomGroup.add(floor);

        // Room label
        const canvas = document.createElement('canvas');
        canvas.width = 256;
        canvas.height = 64;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = '#f9cb00';
        ctx.font = 'bold 24px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(room.name, 128, 40);

        const labelTexture = new THREE.CanvasTexture(canvas);
        const labelGeo = new THREE.PlaneGeometry(4, 1);
        const labelMat = new THREE.MeshBasicMaterial({ map: labelTexture, transparent: true });
        const label = new THREE.Mesh(labelGeo, labelMat);
        label.position.set(room.width / 2, 0.1, room.depth / 2);
        label.rotation.x = -Math.PI / 2;
        roomGroup.add(label);

        // Walls (outline)
        const wallHeight = room.height || roomHeight || 8;
        const wallMat = new THREE.MeshStandardMaterial({ color: 0x555555, transparent: true, opacity: 0.3 });

        // Back wall
        const backWall = new THREE.Mesh(new THREE.BoxGeometry(room.width, wallHeight, 0.3), wallMat);
        backWall.position.set(room.width / 2, wallHeight / 2, 0.15);
        roomGroup.add(backWall);

        // Left wall
        const leftWall = new THREE.Mesh(new THREE.BoxGeometry(0.3, wallHeight, room.depth), wallMat);
        leftWall.position.set(0.15, wallHeight / 2, room.depth / 2);
        roomGroup.add(leftWall);

        // Render elements for this room
        if (room.elements && room.elements.length > 0) {
          room.elements.forEach(el => {
            const elMesh = createSimple3DElement(el);
            if (elMesh) {
              // Convert 2D position to 3D
              const x3d = (el.x / pixelsPerFoot);
              const z3d = (el.y / pixelsPerFoot);
              elMesh.position.set(x3d + el.width / 2, 0, z3d + el.height / 2);
              roomGroup.add(elMesh);
            }
          });
        }

        scene.add(roomGroup);
      });

      // Animation loop
      function animate() {
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
      }
      animate();

      // Handle resize
      window.addEventListener('resize', () => {
        camera.aspect = container.clientWidth / container.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(container.clientWidth, container.clientHeight);
      });
    }

    // Create simplified 3D element for multi-room view
    function createSimple3DElement(el) {
      if (!window.THREE) return null;

      const w = el.width;
      const d = el.height;
      let h = 2.5; // default height

      // Adjust height based on type
      if (el.type.includes('tall')) h = 7;
      else if (el.type.includes('wall-cabinet')) h = 2.5;
      else if (el.type.includes('cabinet')) h = 2.9;
      else if (el.type === 'countertop') h = 0.1;
      else if (el.type === 'sink' || el.type === 'stove') h = 0.5;
      else if (el.type === 'refrigerator') h = 5.5;

      const color = new THREE.Color(el.color || '#808080');
      const geometry = new THREE.BoxGeometry(w, h, d);
      const material = new THREE.MeshStandardMaterial({ color: color });
      const mesh = new THREE.Mesh(geometry, material);
      mesh.castShadow = true;
      mesh.position.y = h / 2;

      return mesh;
    }

    // Export multi-room layout
    function exportMultiRoomLayout() {
      saveCurrentRoomState();

      const layoutData = {
        version: '1.0',
        projectName: document.getElementById('projectName').value || 'Multi-Room Design',
        createdAt: new Date().toISOString(),
        rooms: rooms.map(room => ({
          ...room,
          elements: room.elements.map(el => ({ ...el, textureImg: null }))
        })),
        currentRoomId: currentRoomId
      };

      const blob = new Blob([JSON.stringify(layoutData, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `multi-room-layout-${Date.now()}.json`;
      a.click();
      URL.revokeObjectURL(url);

      showToast('Layout exported successfully', 'success');
    }

    window.viewAllRooms3D = viewAllRooms3D;
    window.exportMultiRoomLayout = exportMultiRoomLayout;

    // Pan offset (for infinite canvas navigation)
    let panX = 0;
    let panY = 0;
    let isPanning = false;
    let panStart = { x: 0, y: 0 };
    let viewLocked = false; // Lock view to prevent accidental pan/zoom

    // Wall drawing
    let isDrawingWall = false;
    let wallStart = null;

    // Countertop drawing
    let isDrawingCountertop = false;
    let countertopStart = null;

    // Cabinet Settings State
    let cabinetSettings = {
      construction: 'frameless', // 'frameless' or 'framed'
      doorStyle: 'shaker',       // 'shaker', 'flat', 'raised', 'slab'
      doorOverlay: 'full',       // 'full', 'partial', 'inset'
      currentFloor: 1,
      floors: [{ id: 1, name: 'Floor 1', height: 0 }]
    };

    // Environment/Scene settings
    let sceneSettings = {
      timeOfDay: 'noon', // 'morning', 'noon', 'evening', 'night'
      showOutdoorView: true
    };

    // Outdoor view colors based on time of day
    const OUTDOOR_COLORS = {
      morning: { sky: 0xFDB813, horizon: 0xFFE4B5, ambient: 0xFFF8DC },
      noon: { sky: 0x87CEEB, horizon: 0xE0F7FA, ambient: 0xFFFFFF },
      evening: { sky: 0xFFA07A, horizon: 0xFFDAB9, ambient: 0xFFE4C4 },
      night: { sky: 0x191970, horizon: 0x2F4F4F, ambient: 0x404040 }
    };

    // Three.js
    let scene, camera, renderer, controls;
    let animationId = null; // Track animation frame to prevent duplicates

    // ===== INITIALIZATION =====
    document.addEventListener('DOMContentLoaded', init);

    // Undo/Redo state
    let undoStack = [];
    let redoStack = [];
    const MAX_UNDO_STATES = 50;

    // Track if we're waiting for login to continue
    let pendingAuthInit = false;
    let workspaceInitialized = false;

    // Wait for SgAuth to initialize (shared auth system)
    async function waitForAuth() {
      // Wait for SgAuth to be available
      let attempts = 0;
      while (!window.SgAuth && attempts < 30) {
        await new Promise(r => setTimeout(r, 100));
        attempts++;
      }

      // Wait for SgAuth to initialize with error handling
      if (window.SgAuth && window.SgAuth.init) {
        try {
          await window.SgAuth.init();
        } catch (err) {
          // Handle AbortError and other init errors gracefully
          if (err.name === 'AbortError') {
            console.warn('SgAuth init aborted (may have timed out):', err.message);
          } else {
            console.warn('SgAuth init error:', err);
          }
          // Continue without auth - user can still use the tool
        }
      }
    }

    async function init() {
      // Check if viewing a shared design (allow without login)
      const urlParams = new URLSearchParams(window.location.search);
      const shareToken = urlParams.get('share') || urlParams.get('p');

      // Check if this is an OAuth callback (has hash with access_token)
      const hashParams = new URLSearchParams(window.location.hash.substring(1));
      const isOAuthCallback = hashParams.has('access_token') || hashParams.has('error');

      // Wait for global auth system to be ready
      await waitForAuth();

      const supabase = getSupabaseClient();

      if (isOAuthCallback && supabase) {
        // Wait for Supabase to process the OAuth callback
        // Clear the hash from URL for cleaner look
        history.replaceState(null, '', window.location.pathname + window.location.search);

        // Give Supabase a moment to process the tokens
        await new Promise(resolve => setTimeout(resolve, 500));

        // Check session after OAuth processing
        try {
          const { data: { session } } = await supabase.auth.getSession();
          if (session) {
            initializeWorkspace();
            return;
          }
        } catch (authErr) {
          if (authErr.name !== 'AbortError') {
            console.warn('OAuth callback session check failed:', authErr.message);
          }
          // Continue without auth
        }
      }

      // If NOT a shared design, check authentication
      // Allow local file:// access without login for development
      const isLocalFile = window.location.protocol === 'file:';

      if (!shareToken && !isLocalFile) {
        // First check if SgAuth already has a logged-in user
        if (window.SgAuth && window.SgAuth.isLoggedIn()) {
          initializeWorkspace();
          return;
        }

        // Check if Supabase is available
        if (!supabase) {
          console.warn('Supabase not available, continuing without auth');
          initializeWorkspace();
          return;
        }

        // Try to get session with error handling
        let session = null;
        try {
          const result = await supabase.auth.getSession();
          session = result.data?.session;
        } catch (authErr) {
          // AbortError is benign - happens during page refresh/navigation
          if (authErr.name !== 'AbortError') {
            console.warn('Auth session check failed:', authErr.message);
          }
          // Continue without session - will initialize workspace
        }

        if (!session) {
          // Not logged in - show login prompt with guest option
          pendingAuthInit = true;
          hidePreloader();
          showLoginPromptRequired();

          // Listen for auth state changes (for when user logs in)
          try {
            supabase.auth.onAuthStateChange((event, session) => {
              if (event === 'SIGNED_IN' && session && !workspaceInitialized) {
                pendingAuthInit = false;
                // Force close login modal (remove required attribute first)
                const loginModal = document.getElementById('loginModal');
                loginModal.removeAttribute('data-required');
                loginModal.classList.remove('active');
                initializeWorkspace();
              }
            });
          } catch (authErr) {
            if (authErr.name !== 'AbortError') {
              console.warn('Auth state listener failed:', authErr.message);
            }
          }
          return;
        }
      }

      // Continue with normal initialization
      initializeWorkspace();
    }

    // Initialize the workspace (called after auth check passes)
    function initializeWorkspace() {
      if (workspaceInitialized) return; // Prevent double initialization
      workspaceInitialized = true;

      canvas = document.getElementById('canvas');
      ctx = canvas.getContext('2d');

      renderSidebar();
      renderFloorPlans();
      renderMaterials('granite');
      renderCabinetCatalog();

      // Load extended stone pricing from Excel import (async, non-blocking)
      loadStonePricing().then(count => {
        if (count > 0) {
          showToast(`Loaded ${count} stone materials with pricing`, 'success');
        }
      });

      setupEventListeners();
      setupDragDrop();
      fitToScreen();

      // Initialize multi-room system
      initializeRooms();
      // Sync elements with first room
      const firstRoom = getCurrentRoom();
      if (firstRoom) {
        firstRoom.elements = elements;
        firstRoom.walls = walls;
      }
      updateRoomList();

      // Initialize auth UI
      initAuth();

      // Check for shared design URL
      checkSharedDesignUrl();

      // Save initial state
      saveUndoState();

      // Keyboard shortcuts for undo/redo
      document.addEventListener('keydown', (e) => {
        if ((e.ctrlKey || e.metaKey) && e.key === 'z') {
          e.preventDefault();
          if (e.shiftKey) {
            redo();
          } else {
            undo();
          }
        }
        if ((e.ctrlKey || e.metaKey) && e.key === 'y') {
          e.preventDefault();
          redo();
        }
      });

      // Auto-hide keyboard shortcuts bar after 5 seconds
      const shortcutsHint = document.getElementById('shortcutsHint');
      if (shortcutsHint) {
        setTimeout(() => {
          shortcutsHint.classList.add('hidden');
        }, 5000);

        // Show on hover
        shortcutsHint.addEventListener('mouseenter', () => {
          shortcutsHint.classList.remove('hidden');
        });

        // Hide again after mouse leaves (with delay)
        shortcutsHint.addEventListener('mouseleave', () => {
          setTimeout(() => {
            shortcutsHint.classList.add('hidden');
          }, 2000);
        });
      }

      // Try to load auto-saved design (if not loading a shared design)
      const urlParams = new URLSearchParams(window.location.search);
      const shareToken = urlParams.get('share') || urlParams.get('p');
      if (!shareToken) {
        const loaded = loadAutoSavedDesign();
        if (loaded) {
          showToast(`Restored your design (${elements.length} elements)`, 'success');
          draw();
          render3D();
        }
      }

      // Initialize element selector dropdown and item picker
      updateElementSelector();
      updateItemPicker();

      // Show auto-save indicator
      console.log('Room Designer initialized. Auto-save enabled.');
    }

    // ===== AUTO-SAVE TO LOCALSTORAGE =====
    const AUTOSAVE_KEY = 'room_designer_autosave';
    let autosaveTimeout = null;
    let lastSaveTime = 0;
    let hasUnsavedChanges = false;

    function autoSaveDesign(immediate = false) {
      hasUnsavedChanges = true;

      // Debounce auto-save to avoid excessive writes
      if (autosaveTimeout) clearTimeout(autosaveTimeout);

      const doSave = () => {
        try {
          const saveData = {
            elements: elements.map(el => ({
              ...el,
              textureImg: undefined // Don't save image objects
            })),
            walls: walls,
            roomWidth: roomWidth,
            roomDepth: roomDepth,
            roomHeight: roomHeight,
            roomType: document.getElementById('roomType')?.value || 'kitchen',
            projectName: document.getElementById('projectName')?.value || 'Untitled',
            timestamp: Date.now(),
            version: 2 // Track save format version
          };
          localStorage.setItem(AUTOSAVE_KEY, JSON.stringify(saveData));
          lastSaveTime = Date.now();
          hasUnsavedChanges = false;
          console.log('Auto-saved design:', elements.length, 'elements');
        } catch (e) {
          console.warn('Auto-save failed:', e);
        }
      };

      if (immediate) {
        doSave();
      } else {
        autosaveTimeout = setTimeout(doSave, 1000); // 1 second debounce
      }
    }

    // Save before page unload
    window.addEventListener('beforeunload', (e) => {
      if (elements.length > 0) {
        // Force immediate save
        autoSaveDesign(true);

        // Only show warning if there are unsaved changes
        if (hasUnsavedChanges) {
          e.preventDefault();
          e.returnValue = 'You have unsaved changes. Are you sure you want to leave?';
          return e.returnValue;
        }
      }
    });

    // Also save on visibility change (tab switch, minimize)
    document.addEventListener('visibilitychange', () => {
      if (document.visibilityState === 'hidden' && elements.length > 0) {
        autoSaveDesign(true);
      }
    });

    // Periodic auto-save every 30 seconds if there are changes
    setInterval(() => {
      if (hasUnsavedChanges && elements.length > 0) {
        autoSaveDesign(true);
      }
    }, 30000);

    // ===== INACTIVITY TIMEOUT =====
    const INACTIVITY_TIMEOUT = 5 * 60 * 1000; // 5 minutes
    const INACTIVITY_WARNING = 60 * 1000; // 1 minute warning before timeout
    let lastActivityTime = Date.now();
    let inactivityTimer = null;
    let warningTimer = null;
    let isSessionLocked = false;

    function resetActivityTimer() {
      lastActivityTime = Date.now();

      // Clear existing timers
      if (inactivityTimer) clearTimeout(inactivityTimer);
      if (warningTimer) clearTimeout(warningTimer);

      // Hide warning if shown
      hideInactivityWarning();

      // Don't set new timers if session is locked
      if (isSessionLocked) return;

      // Set warning timer (1 minute before timeout)
      warningTimer = setTimeout(() => {
        showInactivityWarning();
      }, INACTIVITY_TIMEOUT - INACTIVITY_WARNING);

      // Set timeout timer
      inactivityTimer = setTimeout(() => {
        handleInactivityTimeout();
      }, INACTIVITY_TIMEOUT);
    }

    function showInactivityWarning() {
      // Don't show if no work to save
      if (elements.length === 0) return;

      // Create warning modal if it doesn't exist
      let modal = document.getElementById('inactivityModal');
      if (!modal) {
        modal = document.createElement('div');
        modal.id = 'inactivityModal';
        modal.className = 'modal-overlay';
        modal.innerHTML = `
          <div class="modal" style="max-width: 400px; text-align: center;">
            <div class="modal-header">
              <h3 style="color: #f59e0b;">âš ï¸ Session Timeout Warning</h3>
            </div>
            <div class="modal-body" style="padding: 20px;">
              <p style="font-size: 16px; margin-bottom: 15px;">You've been inactive for a while.</p>
              <p style="margin-bottom: 20px;">Your session will be saved and locked in <strong id="inactivityCountdown">60</strong> seconds.</p>
              <button class="btn btn-primary" onclick="stayActive()" style="padding: 12px 30px; font-size: 16px;">
                I'm Still Here
              </button>
            </div>
          </div>
        `;
        document.body.appendChild(modal);
      }

      modal.classList.add('active');

      // Start countdown
      let countdown = 60;
      const countdownEl = document.getElementById('inactivityCountdown');
      const countdownInterval = setInterval(() => {
        countdown--;
        if (countdownEl) countdownEl.textContent = countdown;
        if (countdown <= 0 || isSessionLocked) {
          clearInterval(countdownInterval);
        }
      }, 1000);

      modal.dataset.countdownInterval = countdownInterval;
    }

    function hideInactivityWarning() {
      const modal = document.getElementById('inactivityModal');
      if (modal) {
        modal.classList.remove('active');
        if (modal.dataset.countdownInterval) {
          clearInterval(parseInt(modal.dataset.countdownInterval));
        }
      }
    }

    function stayActive() {
      hideInactivityWarning();
      resetActivityTimer();
      showToast('Session extended', 'success');
    }

    function handleInactivityTimeout() {
      // Save work first
      if (elements.length > 0) {
        autoSaveDesign(true);
      }

      isSessionLocked = true;
      hideInactivityWarning();

      // Show locked screen
      let lockScreen = document.getElementById('sessionLockScreen');
      if (!lockScreen) {
        lockScreen = document.createElement('div');
        lockScreen.id = 'sessionLockScreen';
        lockScreen.style.cssText = `
          position: fixed;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          background: rgba(0, 0, 0, 0.9);
          z-index: 100000;
          display: flex;
          align-items: center;
          justify-content: center;
          flex-direction: column;
        `;
        lockScreen.innerHTML = `
          <div style="text-align: center; color: white; padding: 40px;">
            <div style="font-size: 60px; margin-bottom: 20px;">ðŸ”’</div>
            <h2 style="font-size: 28px; margin-bottom: 15px;">Session Timed Out</h2>
            <p style="font-size: 16px; color: #aaa; margin-bottom: 10px;">You were inactive for 5 minutes.</p>
            <p style="font-size: 14px; color: #888; margin-bottom: 30px;">Your work has been saved automatically.</p>
            <button onclick="unlockSession()" style="
              background: linear-gradient(135deg, #3b82f6, #2563eb);
              color: white;
              border: none;
              padding: 15px 40px;
              font-size: 18px;
              border-radius: 8px;
              cursor: pointer;
              font-weight: 600;
            ">
              Resume Working
            </button>
          </div>
        `;
        document.body.appendChild(lockScreen);
      }
      lockScreen.style.display = 'flex';
    }

    function unlockSession() {
      isSessionLocked = false;
      const lockScreen = document.getElementById('sessionLockScreen');
      if (lockScreen) {
        lockScreen.style.display = 'none';
      }
      resetActivityTimer();
      showToast('Welcome back! Your work was saved.', 'success');
    }

    // Track user activity
    const activityEvents = ['mousedown', 'mousemove', 'keydown', 'touchstart', 'scroll', 'click'];
    activityEvents.forEach(event => {
      document.addEventListener(event, () => {
        if (!isSessionLocked) {
          resetActivityTimer();
        }
      }, { passive: true });
    });

    // Start activity tracking
    resetActivityTimer();

    function loadAutoSavedDesign() {
      try {
        const saved = localStorage.getItem(AUTOSAVE_KEY);
        if (!saved) {
          console.log('No auto-save found');
          return false;
        }

        const data = JSON.parse(saved);
        if (!data.elements || !Array.isArray(data.elements)) {
          console.log('Invalid auto-save data');
          return false;
        }

        // Check if save is recent (within 30 days)
        const age = Date.now() - (data.timestamp || 0);
        const maxAge = 30 * 24 * 60 * 60 * 1000; // 30 days
        if (age > maxAge) {
          console.log('Auto-save too old, clearing');
          clearAutoSave();
          return false;
        }

        // Skip if no elements to restore
        if (data.elements.length === 0) {
          console.log('Auto-save is empty');
          return false;
        }

        // Restore elements
        elements.length = 0;
        data.elements.forEach(el => {
          // Ensure element has required properties
          if (!el.id) el.id = Date.now() + Math.random();
          if (!el.type) return; // Skip invalid elements

          // Restore texture images if URLs exist
          if (el.texture && !el.textureImg) {
            const img = new Image();
            img.crossOrigin = 'anonymous';
            img.onload = () => {
              el.textureImg = img;
              draw();
            };
            img.onerror = () => {
              console.warn('Failed to load texture:', el.texture);
            };
            img.src = el.texture;
          }
          elements.push(el);
        });

        // Restore walls
        if (data.walls && Array.isArray(data.walls)) {
          walls.length = 0;
          data.walls.forEach(w => walls.push(w));
        }

        // Restore room settings with validation
        if (data.roomWidth && data.roomWidth > 0 && data.roomWidth <= 100) {
          roomWidth = data.roomWidth;
          const roomWidthEl = document.getElementById('roomWidth');
          if (roomWidthEl) roomWidthEl.value = roomWidth;
        }
        if (data.roomDepth && data.roomDepth > 0 && data.roomDepth <= 100) {
          roomDepth = data.roomDepth;
          const roomDepthEl = document.getElementById('roomDepth');
          if (roomDepthEl) roomDepthEl.value = roomDepth;
        }
        if (data.roomHeight && data.roomHeight > 0 && data.roomHeight <= 30) {
          roomHeight = data.roomHeight;
          const roomHeightEl = document.getElementById('roomHeight');
          if (roomHeightEl) roomHeightEl.value = roomHeight;
        }
        if (data.roomType) {
          const roomTypeEl = document.getElementById('roomType');
          if (roomTypeEl) roomTypeEl.value = data.roomType;
        }
        if (data.projectName) {
          const projectNameEl = document.getElementById('projectName');
          if (projectNameEl) projectNameEl.value = data.projectName;
        }

        // Update UI components
        updateCanvasSize();
        updateElementSelector();
        updateItemPicker();
        calculateQuote();

        console.log('Loaded auto-saved design:', elements.length, 'elements');
        hasUnsavedChanges = false;
        return true;
      } catch (e) {
        console.warn('Failed to load auto-save:', e);
        // Clear corrupted save data
        clearAutoSave();
        return false;
      }
    }

    function clearAutoSave() {
      try {
        localStorage.removeItem(AUTOSAVE_KEY);
        hasUnsavedChanges = false;
        console.log('Auto-save cleared');
      } catch (e) {
        console.warn('Failed to clear auto-save:', e);
      }
    }

    // Check if there's saved work
    function hasSavedWork() {
      try {
        const saved = localStorage.getItem(AUTOSAVE_KEY);
        if (!saved) return false;
        const data = JSON.parse(saved);
        return data.elements && data.elements.length > 0;
      } catch (e) {
        return false;
      }
    }

    // ===== UNDO/REDO =====
    function saveUndoState() {
      // Clone current state
      const state = {
        elements: JSON.parse(JSON.stringify(elements.map(el => ({
          ...el,
          textureImg: el.textureImg ? el.textureImg.src : null
        })))),
        walls: JSON.parse(JSON.stringify(walls)),
        roomWidth: roomWidth,
        roomDepth: roomDepth
      };

      undoStack.push(state);

      // Limit stack size
      if (undoStack.length > MAX_UNDO_STATES) {
        undoStack.shift();
      }

      // Clear redo stack on new action
      redoStack = [];

      updateUndoButtons();

      // Auto-save to localStorage
      autoSaveDesign();
    }

    function undo() {
      if (undoStack.length <= 1) return; // Keep at least one state

      // Save current to redo
      const currentState = undoStack.pop();
      redoStack.push(currentState);

      // Restore previous state
      const prevState = undoStack[undoStack.length - 1];
      restoreState(prevState);

      updateUndoButtons();
    }

    function redo() {
      if (redoStack.length === 0) return;

      const state = redoStack.pop();
      undoStack.push(state);
      restoreState(state);

      updateUndoButtons();
    }

    function restoreState(state) {
      elements = state.elements.map(el => {
        const restored = { ...el };
        // Reload texture if it had one
        if (el.textureImg) {
          const img = new Image();
          img.crossOrigin = 'anonymous';
          img.onload = () => {
            restored.textureImg = img;
            draw();
          };
          img.src = el.textureImg;
          restored.textureImg = null; // Will be set when loaded
        }
        return restored;
      });
      walls = state.walls;
      roomWidth = state.roomWidth;
      roomDepth = state.roomDepth;

      selectedElement = null;
      updateProperties();
      calculateQuote();
      draw();
    }

    function updateUndoButtons() {
      const undoBtn = document.getElementById('undoBtn');
      const redoBtn = document.getElementById('redoBtn');

      if (undoBtn) {
        undoBtn.disabled = undoStack.length <= 1;
        undoBtn.title = `Undo (${undoStack.length - 1} steps)`;
      }
      if (redoBtn) {
        redoBtn.disabled = redoStack.length === 0;
        redoBtn.title = `Redo (${redoStack.length} steps)`;
      }
    }

    function resetCanvas() {
      if (!confirm('RESET ENTIRE PROJECT?\n\nThis will:\nâ€¢ Delete all elements\nâ€¢ Clear room settings\nâ€¢ Erase saved progress\n\nThis cannot be undone!')) return;

      // Clear everything
      elements = [];
      walls = [];
      selectedElement = null;
      undoStack = [];
      redoStack = [];

      // Reset room settings to defaults
      roomWidth = 12;
      roomDepth = 10;
      roomHeight = 8;
      document.getElementById('roomWidth').value = 12;
      document.getElementById('roomDepth').value = 10;
      document.getElementById('roomHeight').value = 8;

      const projectNameEl = document.getElementById('projectName');
      if (projectNameEl) projectNameEl.value = 'Untitled Project';

      const roomTypeEl = document.getElementById('roomType');
      if (roomTypeEl) roomTypeEl.value = 'kitchen';

      // Clear auto-save so refresh starts fresh
      clearAutoSave();

      updateProperties();
      updateElementSelector();
      updateItemPicker();
      calculateQuote();
      updateCanvasSize();
      draw();
      render3D();

      showToast('Project reset to defaults', 'info');
    }

    function renderSidebar() {
      // Render element grids with SVG icons
      ['cabinets', 'surfaces', 'appliances', 'structure', 'bathroom', 'laundry', 'closet'].forEach(category => {
        const grid = document.getElementById(category + 'Grid');
        if (!grid) return;

        grid.innerHTML = ELEMENT_TYPES[category].map(el => {
          // Get the SVG icon for this element type
          const svgIcon = ELEMENT_ICONS[el.type];

          // Build icon content - prefer SVG, fallback to color
          let iconContent;
          if (elementTextures[el.type]) {
            // Custom uploaded texture
            iconContent = `<div class="element-icon" style="background-image: url(${elementTextures[el.type]}); background-size: cover; background-position: center;"></div>`;
          } else if (svgIcon) {
            // SVG icon from ELEMENT_ICONS
            iconContent = `<div class="element-icon element-svg">${svgIcon}</div>`;
          } else {
            // Color fallback
            iconContent = `<div class="element-icon" style="background: ${el.color};"></div>`;
          }

          return `
            <div class="element-item ${elementTextures[el.type] ? 'has-texture' : ''}"
                 draggable="true"
                 data-type="${el.type}"
                 data-category="${category}">
              ${iconContent}
              <div class="element-name">${el.label}</div>
              <div class="element-upload-btn" onclick="event.stopPropagation(); uploadElementTexture('${el.type}')" title="Upload custom texture">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                  <polyline points="17 8 12 3 7 8"/>
                  <line x1="12" y1="3" x2="12" y2="15"/>
                </svg>
              </div>
            </div>
          `;
        }).join('');
      });
    }

    function renderFloorPlans() {
      const grid = document.getElementById('floorplanGrid');
      grid.innerHTML = FLOOR_PLANS.map(fp => `
        <div class="floorplan-item ${currentFloorPlan === fp.id ? 'active' : ''}"
             onclick="selectFloorPlan('${fp.id}')">
          <div class="floorplan-preview">
            ${getFloorPlanSVG(fp)}
          </div>
          <div class="floorplan-name">${fp.name}</div>
        </div>
      `).join('');
    }

    function getFloorPlanSVG(fp) {
      if (fp.id === 'empty') {
        return `<svg viewBox="0 0 40 30"><rect x="2" y="2" width="36" height="26" fill="none" stroke="#666" stroke-width="1" stroke-dasharray="2"/></svg>`;
      }
      if (fp.id === 'square') {
        return `<svg viewBox="0 0 40 30"><rect x="2" y="2" width="36" height="26" fill="#333" stroke="#666" stroke-width="1"/></svg>`;
      }
      if (fp.id === 'l-shape') {
        return `<svg viewBox="0 0 40 30"><path d="M2 2 H26 V15 H15 V28 H2 Z" fill="#333" stroke="#666" stroke-width="1"/></svg>`;
      }
      if (fp.id === 'u-shape') {
        return `<svg viewBox="0 0 40 30"><path d="M2 2 H12 V20 H28 V2 H38 V28 H2 Z" fill="#333" stroke="#666" stroke-width="1"/></svg>`;
      }
      if (fp.id === 'galley') {
        return `<svg viewBox="0 0 40 30"><rect x="2" y="2" width="8" height="26" fill="#333" stroke="#666"/><rect x="30" y="2" width="8" height="26" fill="#333" stroke="#666"/></svg>`;
      }
      if (fp.id === 'open') {
        return `<svg viewBox="0 0 40 30"><rect x="2" y="2" width="36" height="26" fill="none" stroke="#666" stroke-dasharray="2"/><rect x="2" y="18" width="16" height="10" fill="#333" stroke="#666"/></svg>`;
      }
      return `<svg viewBox="0 0 40 30"><rect x="2" y="2" width="36" height="26" fill="none" stroke="#666"/></svg>`;
    }

    // ===== MATERIALS LIBRARY =====
    let selectedMaterial = null;
    let currentMaterialCategory = 'granite';

    function renderMaterials(category = 'granite') {
      currentMaterialCategory = category;
      const grid = document.getElementById('materialGrid');
      const materials = MATERIALS[category] || [];

      grid.innerHTML = materials.map(mat => {
        // Build tooltip with details
        let tooltip = mat.name;
        if (mat.brand) tooltip += ` | ${mat.brand}`;
        if (mat.price) tooltip += ` | $${mat.price}/sqft`;
        if (mat.sku) tooltip += ` | SKU: ${mat.sku}`;
        if (mat.series) tooltip += ` | ${mat.series}`;
        if (mat.warranty) tooltip += ` | ${mat.warranty}`;
        if (mat.features) tooltip += ` | ${mat.features}`;

        // Price badge
        const priceBadge = mat.price
          ? `<div class="material-price-badge">$${mat.price}${mat.unit ? '/' + mat.unit : '/sf'}</div>`
          : '';

        // Brand badge
        const brandBadge = mat.brand
          ? `<div class="material-brand-badge">${mat.brand.replace('MSI ', '').replace('Daltile ', '').substring(0, 10)}</div>`
          : '';

        // Resolve image URL using helper
        const imageUrl = resolveAssetUrl(mat.url);

        // Determine background style - use image with color fallback
        // CSS background-image will fall back to color if image fails
        const bgStyle = imageUrl
          ? `url('${imageUrl}') center/cover no-repeat, linear-gradient(${mat.color || '#666'}, ${mat.color || '#666'})`
          : mat.color || '#666';

        // Add indicator if no texture (color only)
        const noTextureBadge = !imageUrl
          ? '<div class="material-no-texture-badge" title="Color only - no texture image">â—</div>'
          : '';

        return `
        <div class="material-swatch ${selectedMaterial?.id === mat.id ? 'selected' : ''}"
             style="background: ${bgStyle};"
             onclick="selectMaterial('${mat.id}')"
             data-url="${imageUrl || ''}"
             data-color="${mat.color || '#666'}"
             title="${tooltip}">
          ${priceBadge}
          ${brandBadge}
          ${noTextureBadge}
          <div class="material-swatch-label">${mat.name}</div>
        </div>
      `;
      }).join('');
    }

    function showMaterialCategory(category, btn) {
      // Update tab buttons
      document.querySelectorAll('.material-tab').forEach(t => t.classList.remove('active'));
      btn.classList.add('active');

      // Render materials for category
      renderMaterials(category);
    }

    // ==========================================
    // Product Catalog from Website/Store
    // ==========================================
    let storeProducts = [];
    let currentProductCategory = 'countertops';
    let selectedStoreProduct = null;

    // Load products from the search index
    async function loadStoreProducts() {
      try {
        // Try to load from the website's search index
        const basePath = window.location.protocol === 'file:'
          ? window.location.href.replace(/\/tools\/room-designer\/.*$/, '')
          : '';
        const response = await fetch(basePath + '/data/search-index.json');
        const data = await response.json();
        storeProducts = data.products || [];

        // Populate brand filter
        const brands = [...new Set(storeProducts.map(p => p.brand).filter(Boolean))];
        const brandSelect = document.getElementById('productBrandFilter');
        if (brandSelect) {
          brandSelect.innerHTML = '<option value="">All Brands</option>' +
            brands.map(b => `<option value="${b}">${formatBrandName(b)}</option>`).join('');
        }

        // Populate type filter
        const types = [...new Set(storeProducts.map(p => p.type).filter(Boolean))];
        const typeSelect = document.getElementById('productTypeFilter');
        if (typeSelect) {
          typeSelect.innerHTML = '<option value="">All Types</option>' +
            types.map(t => `<option value="${t}">${t}</option>`).join('');
        }

        renderStoreProducts();
      } catch (e) {
        console.warn('Could not load store products:', e);
        const grid = document.getElementById('productCatalogGrid');
        if (grid) {
          grid.innerHTML = '<div class="loading-products">Products unavailable offline</div>';
        }
      }
    }

    // Format brand name for display
    function formatBrandName(brand) {
      const brandNames = {
        'msi-surfaces': 'MSI Surfaces',
        'cosentino': 'Cosentino',
        'radianz-quartz': 'Radianz',
        'lx-hausys': 'LX Hausys',
        'cambria': 'Cambria',
        'daltile': 'Daltile',
        'bedrosians': 'Bedrosians'
      };
      return brandNames[brand] || brand.replace(/-/g, ' ').replace(/\b\w/g, c => c.toUpperCase());
    }

    // Show products by category
    function showProductCategory(category, btn) {
      // Update tabs
      document.querySelectorAll('#productCategoryTabs .material-tab').forEach(t => t.classList.remove('active'));
      btn.classList.add('active');
      currentProductCategory = category;
      renderStoreProducts();
    }

    // Filter store products based on search and dropdowns
    function filterStoreProducts() {
      renderStoreProducts();
    }

    // Render products in the grid
    function renderStoreProducts() {
      const grid = document.getElementById('productCatalogGrid');
      if (!grid) return;

      const searchTerm = (document.getElementById('productSearchInput')?.value || '').toLowerCase();
      const brandFilter = document.getElementById('productBrandFilter')?.value || '';
      const typeFilter = document.getElementById('productTypeFilter')?.value || '';

      // Filter products
      let filtered = storeProducts.filter(p => {
        // Category filter
        if (currentProductCategory === 'countertops' && p.category !== 'countertops') return false;
        if (currentProductCategory === 'tile' && p.category !== 'tile' && !p.type?.toLowerCase().includes('tile')) return false;
        if (currentProductCategory === 'flooring' && p.category !== 'flooring') return false;
        if (currentProductCategory === 'sinks' && !p.type?.toLowerCase().includes('sink')) return false;

        // Search filter
        if (searchTerm && !p.name.toLowerCase().includes(searchTerm) &&
            !p.brand?.toLowerCase().includes(searchTerm) &&
            !p.type?.toLowerCase().includes(searchTerm)) return false;

        // Brand filter
        if (brandFilter && p.brand !== brandFilter) return false;

        // Type filter
        if (typeFilter && p.type !== typeFilter) return false;

        return true;
      });

      // Limit to 50 for performance
      filtered = filtered.slice(0, 50);

      if (filtered.length === 0) {
        grid.innerHTML = '<div class="loading-products">No products found</div>';
        return;
      }

      grid.innerHTML = filtered.map(product => `
        <div class="product-card ${selectedStoreProduct?.slug === product.slug ? 'selected' : ''}"
             onclick="selectStoreProduct('${product.slug}')"
             draggable="true"
             ondragstart="dragStoreProduct(event, '${product.slug}')">
          <img class="product-card-image" src="${product.primaryImage}" alt="${product.name}" loading="lazy"
               onerror="this.src='data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><rect fill=%22%23333%22 width=%22100%22 height=%22100%22/><text x=%2250%22 y=%2255%22 text-anchor=%22middle%22 fill=%22%23666%22 font-size=%2210%22>${encodeURIComponent(product.name.substring(0, 8))}</text></svg>'">
          <div class="product-card-name">${product.name}</div>
          <div class="product-card-meta">${product.type || ''} ${product.brand ? 'â€¢ ' + formatBrandName(product.brand) : ''}</div>
        </div>
      `).join('');
    }

    // Select a store product
    function selectStoreProduct(slug) {
      const product = storeProducts.find(p => p.slug === slug);
      if (!product) return;

      selectedStoreProduct = product;
      renderStoreProducts();

      // Update hint
      const hint = document.querySelector('.product-hint');
      if (hint) {
        hint.innerHTML = `<strong>${product.name}</strong> selected. Click an element to apply.`;
        hint.style.color = 'var(--gold)';
      }
    }

    // Drag store product
    function dragStoreProduct(event, slug) {
      const product = storeProducts.find(p => p.slug === slug);
      if (product) {
        event.dataTransfer.effectAllowed = 'copy';
        event.dataTransfer.setData('text/plain', JSON.stringify({
          type: 'store-product',
          product: product
        }));
        console.log('Dragging store product:', product.name);
      }
    }

    // Apply store product as material to element
    function applyStoreProductToElement(element) {
      if (!selectedStoreProduct) return false;

      const product = selectedStoreProduct;
      console.log('Applying store product to element:', product.name, 'Element type:', element.type);

      // Store complete product info on element for 3D rendering
      element.storeProduct = {
        name: product.name,
        slug: product.slug,
        brand: product.brand,
        image: product.primaryImage,
        type: product.type
      };

      // Apply product as material
      element.materialId = product.slug;
      element.materialName = product.name;
      element.materialBrand = product.brand;
      element.texture = product.primaryImage;
      element.label = product.name; // Update label to product name

      // Extract color from product primaryColor if available (for fallback)
      const colorMap = {
        'White': '#f5f5f5',
        'Black': '#2a2a2a',
        'Gray': '#808080',
        'Beige': '#d4c4a8',
        'Brown': '#8b7355',
        'Gold': '#d4a574',
        'Blue': '#4a6b8c',
        'Green': '#4a6b4a'
      };
      element.color = colorMap[product.primaryColor] || '#a0a0a0';

      // Update quote/pricing
      if (product.price) {
        element.priceOverride = parseFloat(product.price) || 0;
      }

      // Load texture for 2D canvas
      if (product.primaryImage) {
        const img = new Image();
        img.crossOrigin = 'anonymous';
        img.onload = () => {
          element.textureImg = img;
          console.log('Texture image loaded for 2D:', product.primaryImage);
          draw();
          // Force 3D scene rebuild to show new texture
          if (currentView === '3d') {
            console.log('Rebuilding 3D scene with new texture');
            init3D();
            render3D();
          }
        };
        img.onerror = () => {
          console.warn('Failed to load product image:', product.primaryImage);
          draw();
        };
        img.src = product.primaryImage;
      } else {
        // No image, still update views
        draw();
        if (currentView === '3d') {
          init3D();
          render3D();
        }
      }

      // Clear selection
      const prevProduct = selectedStoreProduct.name;
      selectedStoreProduct = null;
      renderStoreProducts();

      const hint = document.querySelector('.product-hint');
      if (hint) {
        hint.innerHTML = `Applied <strong>${prevProduct}</strong>!`;
        hint.style.color = 'var(--success)';
        setTimeout(() => {
          hint.innerHTML = 'Click product to apply as material';
          hint.style.color = '';
        }, 2000);
      }

      showSnapFeedback(`Applied ${prevProduct} to ${element.type}`);
      calculateQuote(); // Update pricing
      return true;
    }

    // Initialize product catalog on load
    document.addEventListener('DOMContentLoaded', () => {
      setTimeout(loadStoreProducts, 500);
    });

    function selectMaterial(materialId) {
      // Find material in all categories
      for (const [cat, materials] of Object.entries(MATERIALS)) {
        const mat = materials.find(m => m.id === materialId);
        if (mat) {
          selectedMaterial = { ...mat, category: cat };
          break;
        }
      }

      // Update UI
      renderMaterials(currentMaterialCategory);

      // Update hint
      const hint = document.querySelector('.material-hint');
      if (hint && selectedMaterial) {
        hint.innerHTML = `<strong>${selectedMaterial.name}</strong> selected. Click an element to apply.`;
        hint.style.borderColor = 'var(--gold)';
      }
    }

    function applyMaterialToElement(element) {
      if (!selectedMaterial) return false;

      // Apply the material
      element.color = selectedMaterial.color;
      element.materialId = selectedMaterial.id;
      element.materialName = selectedMaterial.name;
      element.materialPrice = selectedMaterial.price || null;
      element.materialBrand = selectedMaterial.brand || null;

      // Recalculate quote with new material pricing
      calculateQuote();

      // Resolve texture URL using helper
      const textureUrl = resolveAssetUrl(selectedMaterial.url);

      // Store resolved texture URL
      element.texture = textureUrl || null;

      // Load texture image if URL exists
      if (textureUrl) {
        const img = new Image();
        img.crossOrigin = 'anonymous';
        img.onload = () => {
          console.log('Texture loaded successfully:', textureUrl);
          element.textureImg = img;
          draw();
          update3DScene();
        };
        img.onerror = (err) => {
          console.warn('Failed to load texture:', textureUrl, err);
          // Clear texture reference on error
          element.texture = null;
          element.textureImg = null;
          // Fallback: use solid color
          draw();
          showToast(`Could not load texture image, using solid color`, 'error');
        };
        // Set a timeout to handle hung requests
        const loadTimeout = setTimeout(() => {
          if (!img.complete) {
            console.warn('Texture load timeout:', textureUrl);
            element.texture = null;
            element.textureImg = null;
            draw();
          }
        }, 10000);
        img.onload = () => {
          clearTimeout(loadTimeout);
          console.log('Texture loaded successfully:', textureUrl);
          element.textureImg = img;
          draw();
          update3DScene();
        };
        img.src = textureUrl;
      } else {
        // No texture URL - material only has color (this is normal for some materials)
        element.textureImg = null;
        element.texture = null;
        console.log('Material has no texture URL, using color:', element.color);
      }

      // Clear selection after applying
      const prevMaterial = selectedMaterial.name;
      selectedMaterial = null;
      renderMaterials(currentMaterialCategory);

      // Reset hint
      const hint = document.querySelector('.material-hint');
      if (hint) {
        hint.innerHTML = `Applied <strong>${prevMaterial}</strong>! Click material, then element to apply.`;
        hint.style.borderColor = 'var(--success)';
        setTimeout(() => {
          hint.innerHTML = 'Click material, then click element to apply';
          hint.style.borderColor = 'var(--border)';
        }, 2000);
      }

      return true;
    }

    // ===== CABINET CATALOG =====
    function renderCabinetCatalog() {
      const catalog = CABINET_CATALOGS[currentCatalog];
      if (!catalog) return;

      const list = document.getElementById('cabinetCatalogList');
      const cabinets = catalog.cabinets[currentCabinetCategory] || [];
      const series = catalog.series[currentCabinetSeries] || { color: '#8B4513' };

      if (cabinets.length === 0) {
        list.innerHTML = '<div style="padding: 20px; text-align: center; color: var(--text-muted); font-size: 11px;">No cabinets in this category</div>';
        return;
      }

      list.innerHTML = cabinets.map(cab => `
        <div class="cabinet-catalog-item"
             draggable="true"
             ondragstart="dragCatalogCabinet(event, '${cab.sku}')"
             onclick="addCatalogCabinet('${cab.sku}')">
          <div class="cabinet-item-info">
            <span class="cabinet-item-sku">${cab.sku}</span>
            <span class="cabinet-item-name">${cab.name}</span>
            <span class="cabinet-item-size">${cab.width}' Ã— ${cab.height}'</span>
            ${cab.price ? `<span class="cabinet-item-price">$${cab.price}</span>` : ''}
          </div>
          <button class="cabinet-item-add" onclick="event.stopPropagation(); addCatalogCabinet('${cab.sku}')" title="Add to canvas">+</button>
        </div>
      `).join('');
    }

    function changeCatalog(catalogId) {
      currentCatalog = catalogId;
      const catalog = CABINET_CATALOGS[catalogId];

      // Update series dropdown
      const seriesSelect = document.getElementById('seriesSelect');
      const seriesDiv = document.getElementById('catalogSeries');

      if (catalog && Object.keys(catalog.series).length > 0) {
        seriesDiv.style.display = 'block';
        seriesSelect.innerHTML = Object.entries(catalog.series).map(([id, s]) =>
          `<option value="${id}">${s.name}</option>`
        ).join('');
        currentCabinetSeries = Object.keys(catalog.series)[0];
      } else {
        seriesDiv.style.display = catalogId === 'custom' ? 'none' : 'block';
      }

      renderCabinetCatalog();
    }

    function changeSeries(seriesId) {
      currentCabinetSeries = seriesId;
      renderCabinetCatalog();
    }

    function showCabinetCategory(category, btn) {
      currentCabinetCategory = category;
      document.querySelectorAll('#cabinetCategoryTabs .material-tab').forEach(t => t.classList.remove('active'));
      btn.classList.add('active');
      renderCabinetCatalog();
    }

    function getCatalogCabinet(sku) {
      const catalog = CABINET_CATALOGS[currentCatalog];
      if (!catalog) return null;

      for (const category of Object.values(catalog.cabinets)) {
        const cab = category.find(c => c.sku === sku);
        if (cab) return cab;
      }
      return null;
    }

    function addCatalogCabinet(sku) {
      const cab = getCatalogCabinet(sku);
      if (!cab) return;

      const catalog = CABINET_CATALOGS[currentCatalog];
      const series = catalog.series[currentCabinetSeries] || { color: '#8B4513', name: 'Default' };

      // Calculate position (center of visible area)
      const centerX = (canvas.width / 2 - panX) / pixelsPerFoot;
      const centerY = (canvas.height / 2 - panY) / pixelsPerFoot;

      const element = {
        id: Date.now() + Math.random(),
        type: cab.type,
        x: centerX * pixelsPerFoot,
        y: centerY * pixelsPerFoot,
        width: cab.width,
        height: cab.height,
        rotation: 0,
        color: series.color,
        label: `${cab.name} (${series.name})`,
        sku: cab.sku,
        catalog: currentCatalog,
        series: currentCabinetSeries,
        // Store original SKU dimensions for linear fill calculation
        skuWidth: cab.width,  // Original box width (e.g., 3 for 36" cabinet)
        skuHeight: cab.height, // Original box depth
        skuName: cab.name,
        // Cabinet settings
        construction: cabinetSettings.construction,
        doorStyle: cabinetSettings.doorStyle,
        doorOverlay: cabinetSettings.doorOverlay,
        floorLevel: cabinetSettings.currentFloor
      };

      elements.push(element);
      selectedElement = element;
      updateProperties();
      calculateQuote();
      saveUndoState();
      draw();
    }

    function dragCatalogCabinet(e, sku) {
      e.dataTransfer.setData('catalog-cabinet', sku);
      e.dataTransfer.effectAllowed = 'copy';
    }

    function importCabinetList() {
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = '.csv,.json,.txt';
      input.onchange = async (e) => {
        const file = e.target.files[0];
        if (!file) return;

        const text = await file.text();
        let cabinets = [];

        try {
          if (file.name.endsWith('.json')) {
            // JSON format: array of cabinet objects
            cabinets = JSON.parse(text);
          } else {
            // CSV format: sku,name,width,height,type
            const lines = text.split('\n').filter(l => l.trim());
            const hasHeader = lines[0].toLowerCase().includes('sku') || lines[0].toLowerCase().includes('name');

            (hasHeader ? lines.slice(1) : lines).forEach(line => {
              const parts = line.split(',').map(p => p.trim().replace(/"/g, ''));
              if (parts.length >= 4) {
                cabinets.push({
                  sku: parts[0] || `CUSTOM-${Date.now()}`,
                  name: parts[1] || 'Custom Cabinet',
                  width: parseFloat(parts[2]) || 2,
                  height: parseFloat(parts[3]) || 2,
                  depth: parseFloat(parts[4]) || 2,
                  type: parts[5] || 'base-cabinet'
                });
              }
            });
          }

          if (cabinets.length > 0) {
            CABINET_CATALOGS.custom.cabinets.imported = cabinets;
            currentCatalog = 'custom';
            currentCabinetCategory = 'imported';
            document.getElementById('catalogSelect').value = 'custom';

            // Add imported tab if not exists
            const tabs = document.getElementById('cabinetCategoryTabs');
            if (!tabs.innerHTML.includes('imported')) {
              tabs.innerHTML += '<button class="material-tab" onclick="showCabinetCategory(\'imported\', this)">Imported</button>';
            }

            renderCabinetCatalog();
            alert(`Imported ${cabinets.length} cabinets successfully!`);
          } else {
            alert('No valid cabinet data found in file.');
          }
        } catch (err) {
          console.error('Import error:', err);
          alert('Error importing file. Please check the format.\n\nExpected CSV format:\nsku,name,width,height,depth,type\nB24,Base 24",2,2,2,base-cabinet');
        }
      };
      input.click();
    }

    function selectFloorPlan(id) {
      currentFloorPlan = id;
      const plan = FLOOR_PLANS.find(p => p.id === id);

      // Clear existing walls
      walls = [];

      // Add walls based on floor plan
      if (plan && plan.walls) {
        plan.walls.forEach(w => {
          if (w.type === 'full') {
            // Full room walls
            addWall(0, 0, roomWidth * pixelsPerFoot, CONFIG.WALL_THICKNESS);
            addWall(0, 0, CONFIG.WALL_THICKNESS, roomDepth * pixelsPerFoot);
            addWall(0, roomDepth * pixelsPerFoot - CONFIG.WALL_THICKNESS, roomWidth * pixelsPerFoot, CONFIG.WALL_THICKNESS);
            addWall(roomWidth * pixelsPerFoot - CONFIG.WALL_THICKNESS, 0, CONFIG.WALL_THICKNESS, roomDepth * pixelsPerFoot);
          } else if (w.type === 'rect') {
            const x = w.x * roomWidth * pixelsPerFoot;
            const y = w.y * roomDepth * pixelsPerFoot;
            const width = w.w * roomWidth * pixelsPerFoot;
            const height = w.h * roomDepth * pixelsPerFoot;
            // Add as a filled area indicator
            walls.push({ x, y, width, height, type: 'area' });
          }
        });
      }

      renderFloorPlans();
      draw();
    }

    function addWall(x, y, width, height) {
      walls.push({
        id: Date.now() + Math.random(),
        x, y, width, height,
        type: 'wall',
        color: '#444'
      });
    }

    function fitToScreen() {
      const wrapper = document.getElementById('canvasWrapper');
      const padding = 80;
      const availableWidth = wrapper.clientWidth - padding;
      const availableHeight = wrapper.clientHeight - padding;

      const scaleX = availableWidth / roomWidth;
      const scaleY = availableHeight / roomDepth;

      pixelsPerFoot = Math.min(scaleX, scaleY, 80);
      pixelsPerFoot = Math.max(pixelsPerFoot, CONFIG.MIN_PIXELS_PER_FOOT);

      // Center the room in the canvas
      panX = (wrapper.clientWidth - roomWidth * pixelsPerFoot) / 2;
      panY = (wrapper.clientHeight - roomDepth * pixelsPerFoot) / 2;

      document.getElementById('scaleMode').value = 'fit';
      updateCanvasSize();
    }

    function updateScale() {
      const mode = document.getElementById('scaleMode').value;
      if (mode === 'fit') {
        fitToScreen();
      } else {
        pixelsPerFoot = parseInt(mode);
        // Re-center when changing scale
        const wrapper = document.getElementById('canvasWrapper');
        panX = (wrapper.clientWidth - roomWidth * pixelsPerFoot) / 2;
        panY = (wrapper.clientHeight - roomDepth * pixelsPerFoot) / 2;
        updateCanvasSize();
      }
    }

    function updateCanvasSize() {
      const wrapper = document.getElementById('canvasWrapper');

      // Guard against missing elements (e.g., after share link error overlay)
      if (!wrapper || !canvas) return;

      // Canvas fills entire workspace
      canvas.width = wrapper.clientWidth;
      canvas.height = wrapper.clientHeight;

      const sizeEl = document.getElementById('canvasSize');
      if (sizeEl) {
        sizeEl.textContent = `${roomWidth}' Ã— ${roomDepth}'`;
      }

      draw();
    }

    function setupEventListeners() {
      canvas.addEventListener('mousedown', onMouseDown);
      canvas.addEventListener('mousemove', onMouseMove);
      canvas.addEventListener('mouseup', onMouseUp);
      canvas.addEventListener('mouseleave', onMouseUp);
      canvas.addEventListener('contextmenu', onContextMenu);
      canvas.addEventListener('dblclick', onDoubleClick);
      canvas.addEventListener('wheel', onWheel, { passive: false });

      document.addEventListener('keydown', onKeyDown);
      document.addEventListener('keyup', onKeyUp);

      document.addEventListener('click', (e) => {
        if (!e.target.closest('.context-menu')) {
          hideContextMenu();
        }
      });

      window.addEventListener('resize', () => {
        updateCanvasSize();
        const scaleMode = document.getElementById('scaleMode');
        if (scaleMode && scaleMode.value === 'fit') {
          fitToScreen();
        }
      });
    }

    function setupDragDrop() {
      document.addEventListener('dragstart', (e) => {
        if (e.target.classList.contains('element-item')) {
          e.dataTransfer.setData('element-type', e.target.dataset.type);
          e.dataTransfer.effectAllowed = 'copy';
          e.target.style.opacity = '0.5';
          isHtmlDragging = true;
        }
      });

      document.addEventListener('dragend', (e) => {
        if (e.target.classList.contains('element-item')) {
          e.target.style.opacity = '1';
        }
        isHtmlDragging = false;
      });

      canvas.addEventListener('dragover', (e) => {
        e.preventDefault();
        e.dataTransfer.dropEffect = 'copy';
        isHtmlDragging = true;
      });
      canvas.addEventListener('dragleave', () => {
        isHtmlDragging = false;
      });
      canvas.addEventListener('drop', (e) => {
        isHtmlDragging = false;
        onDrop(e);
      });
    }

    // ===== DRAWING =====
    function draw() {
      if (!ctx) return;

      // Clear entire canvas with dark background
      ctx.fillStyle = '#0d0d15';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Apply pan transformation
      ctx.save();
      ctx.translate(panX, panY);

      // Draw infinite grid
      drawGrid();

      // Draw room boundary (the actual room shape)
      drawRoomBoundary();

      // Draw floor plan areas
      drawFloorPlanAreas();

      // Draw walls
      drawWalls();

      // Draw elements
      drawElements();

      // Draw snap guides when dragging cabinets
      drawSnapGuides();

      // Draw work triangle overlay if enabled
      drawWorkTriangle();

      // Draw layout tool preview
      drawLayoutToolPreview();

      ctx.restore();

      document.getElementById('elementCount').textContent = `${elements.length} element${elements.length !== 1 ? 's' : ''}`;
      calculateQuote();

      // Update element layer list panel
      updateElementList();
    }

    // Draw snap guides when dragging cabinets near walls
    function drawSnapGuides() {
      if (!isDragging || !selectedElement) return;

      const isCabinetType = ['base-cabinet', 'wall-cabinet', 'tall-cabinet', 'corner-cabinet',
                             'drawer-base', 'sink-base', 'lazy-susan',
                             'island', 'countertop', 'sink', 'stove', 'dishwasher',
                             'refrigerator', 'oven'].includes(selectedElement.type);

      if (!isCabinetType) return;

      const snapZone = pixelsPerFoot * 0.75; // Match the snap distance
      const roomW = roomWidth * pixelsPerFoot;
      const roomH = roomDepth * pixelsPerFoot;

      const elX = selectedElement.x;
      const elY = selectedElement.y;
      const elW = selectedElement.width * pixelsPerFoot;
      const elH = selectedElement.height * pixelsPerFoot;

      ctx.save();
      ctx.setLineDash([8, 4]);
      ctx.lineWidth = 2;

      // Back wall snap guide (top)
      if (Math.abs(elY) < snapZone) {
        ctx.strokeStyle = '#4CAF50';
        ctx.beginPath();
        ctx.moveTo(-50, 0);
        ctx.lineTo(roomW + 50, 0);
        ctx.stroke();
        // Highlight indicator
        ctx.fillStyle = 'rgba(76, 175, 80, 0.2)';
        ctx.fillRect(-50, 0, roomW + 100, snapZone);
      }

      // Left wall snap guide
      if (Math.abs(elX) < snapZone) {
        ctx.strokeStyle = '#2196F3';
        ctx.beginPath();
        ctx.moveTo(0, -50);
        ctx.lineTo(0, roomH + 50);
        ctx.stroke();
        ctx.fillStyle = 'rgba(33, 150, 243, 0.2)';
        ctx.fillRect(0, -50, snapZone, roomH + 100);
      }

      // Right wall snap guide
      if (Math.abs((elX + elW) - roomW) < snapZone) {
        ctx.strokeStyle = '#FF9800';
        ctx.beginPath();
        ctx.moveTo(roomW, -50);
        ctx.lineTo(roomW, roomH + 50);
        ctx.stroke();
        ctx.fillStyle = 'rgba(255, 152, 0, 0.2)';
        ctx.fillRect(roomW - snapZone, -50, snapZone, roomH + 100);
      }

      // Front wall snap guide (bottom)
      if (Math.abs((elY + elH) - roomH) < snapZone) {
        ctx.strokeStyle = '#9C27B0';
        ctx.beginPath();
        ctx.moveTo(-50, roomH);
        ctx.lineTo(roomW + 50, roomH);
        ctx.stroke();
        ctx.fillStyle = 'rgba(156, 39, 176, 0.2)';
        ctx.fillRect(-50, roomH - snapZone, roomW + 100, snapZone);
      }

      // Corner indicators for corner cabinets
      const isCornerCabinet = ['corner-cabinet', 'lazy-susan'].includes(selectedElement.type);
      if (isCornerCabinet) {
        const cornerZone = pixelsPerFoot * 1.0;

        // Top-left corner
        if (Math.abs(elX) < cornerZone && Math.abs(elY) < cornerZone) {
          ctx.fillStyle = 'rgba(76, 175, 80, 0.4)';
          ctx.beginPath();
          ctx.arc(0, 0, cornerZone, 0, Math.PI / 2);
          ctx.lineTo(0, 0);
          ctx.fill();
        }

        // Top-right corner
        if (Math.abs((elX + elW) - roomW) < cornerZone && Math.abs(elY) < cornerZone) {
          ctx.fillStyle = 'rgba(255, 152, 0, 0.4)';
          ctx.beginPath();
          ctx.arc(roomW, 0, cornerZone, Math.PI / 2, Math.PI);
          ctx.lineTo(roomW, 0);
          ctx.fill();
        }

        // Bottom-left corner
        if (Math.abs(elX) < cornerZone && Math.abs((elY + elH) - roomH) < cornerZone) {
          ctx.fillStyle = 'rgba(33, 150, 243, 0.4)';
          ctx.beginPath();
          ctx.arc(0, roomH, cornerZone, -Math.PI / 2, 0);
          ctx.lineTo(0, roomH);
          ctx.fill();
        }

        // Bottom-right corner
        if (Math.abs((elX + elW) - roomW) < cornerZone && Math.abs((elY + elH) - roomH) < cornerZone) {
          ctx.fillStyle = 'rgba(156, 39, 176, 0.4)';
          ctx.beginPath();
          ctx.arc(roomW, roomH, cornerZone, Math.PI, Math.PI * 1.5);
          ctx.lineTo(roomW, roomH);
          ctx.fill();
        }
      }

      ctx.restore();
    }

    // Toggle work triangle visualization
    function toggleWorkTriangle() {
      showWorkTriangle = !showWorkTriangle;
      const btn = document.querySelector('.validation-toggle');
      if (btn) {
        btn.classList.toggle('active', showWorkTriangle);
      }
      if (showWorkTriangle) {
        runValidation();
      }
      draw();
    }

    function drawGrid() {
      const gridSize = pixelsPerFoot / CONFIG.GRID_SUBDIVISIONS;
      const roomW = roomWidth * pixelsPerFoot;
      const roomH = roomDepth * pixelsPerFoot;

      // Calculate visible area for grid
      const startX = -panX - pixelsPerFoot;
      const startY = -panY - pixelsPerFoot;
      const endX = canvas.width - panX + pixelsPerFoot;
      const endY = canvas.height - panY + pixelsPerFoot;

      // Sub-grid (faint lines)
      ctx.strokeStyle = 'rgba(255,255,255,0.02)';
      ctx.lineWidth = 1;

      const gridStartX = Math.floor(startX / gridSize) * gridSize;
      const gridStartY = Math.floor(startY / gridSize) * gridSize;

      for (let x = gridStartX; x < endX; x += gridSize) {
        ctx.beginPath();
        ctx.moveTo(x, startY);
        ctx.lineTo(x, endY);
        ctx.stroke();
      }
      for (let y = gridStartY; y < endY; y += gridSize) {
        ctx.beginPath();
        ctx.moveTo(startX, y);
        ctx.lineTo(endX, y);
        ctx.stroke();
      }

      // Main grid (1ft lines)
      ctx.strokeStyle = 'rgba(255,255,255,0.06)';
      const mainStartX = Math.floor(startX / pixelsPerFoot) * pixelsPerFoot;
      const mainStartY = Math.floor(startY / pixelsPerFoot) * pixelsPerFoot;

      for (let x = mainStartX; x < endX; x += pixelsPerFoot) {
        ctx.beginPath();
        ctx.moveTo(x, startY);
        ctx.lineTo(x, endY);
        ctx.stroke();
      }
      for (let y = mainStartY; y < endY; y += pixelsPerFoot) {
        ctx.beginPath();
        ctx.moveTo(startX, y);
        ctx.lineTo(endX, y);
        ctx.stroke();
      }
    }

    // Room resize state
    let isResizingRoom = false;
    let roomResizeHandle = null; // 'e', 's', 'se' (east, south, southeast corner)
    let roomResizeStart = { x: 0, y: 0, width: 0, depth: 0 };
    const ROOM_HANDLE_SIZE = 16;

    // Get room resize handles (only right, bottom, and bottom-right corner)
    function getRoomResizeHandles() {
      const roomW = roomWidth * pixelsPerFoot;
      const roomH = roomDepth * pixelsPerFoot;
      const hs = ROOM_HANDLE_SIZE;

      return {
        e: { x: roomW, y: roomH / 2, cursor: 'ew-resize' },    // Right edge center
        s: { x: roomW / 2, y: roomH, cursor: 'ns-resize' },    // Bottom edge center
        se: { x: roomW, y: roomH, cursor: 'nwse-resize' }      // Bottom-right corner
      };
    }

    // Check if point is on a room resize handle
    function getRoomHandleAtPosition(worldX, worldY) {
      const handles = getRoomResizeHandles();
      const hs = ROOM_HANDLE_SIZE + 6; // Slightly larger hit area

      for (const [name, handle] of Object.entries(handles)) {
        if (worldX >= handle.x - hs/2 && worldX <= handle.x + hs/2 &&
            worldY >= handle.y - hs/2 && worldY <= handle.y + hs/2) {
          return { name, ...handle };
        }
      }
      return null;
    }

    function drawRoomBoundary() {
      const roomW = roomWidth * pixelsPerFoot;
      const roomH = roomDepth * pixelsPerFoot;

      // Room floor (lighter area)
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, roomW, roomH);

      // Room border with measurements
      ctx.strokeStyle = '#4a4a6a';
      ctx.lineWidth = 3;
      ctx.strokeRect(0, 0, roomW, roomH);

      // Corner markers (static - top-left, top-right, bottom-left)
      const markerSize = 12;
      ctx.fillStyle = '#6366f1';
      ctx.fillRect(-markerSize/2, -markerSize/2, markerSize, markerSize);
      ctx.fillRect(roomW - markerSize/2, -markerSize/2, markerSize, markerSize);
      ctx.fillRect(-markerSize/2, roomH - markerSize/2, markerSize, markerSize);

      // Room resize handles (interactive - right edge, bottom edge, bottom-right corner)
      const handles = getRoomResizeHandles();
      const hs = ROOM_HANDLE_SIZE;

      // Right edge handle (east)
      ctx.fillStyle = isResizingRoom && roomResizeHandle === 'e' ? '#22c55e' : '#f97316';
      ctx.fillRect(handles.e.x - hs/2, handles.e.y - hs, hs, hs * 2);
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 2;
      ctx.strokeRect(handles.e.x - hs/2, handles.e.y - hs, hs, hs * 2);
      // Arrow indicator
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 12px Inter';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('âŸ·', handles.e.x, handles.e.y);

      // Bottom edge handle (south)
      ctx.fillStyle = isResizingRoom && roomResizeHandle === 's' ? '#22c55e' : '#f97316';
      ctx.fillRect(handles.s.x - hs, handles.s.y - hs/2, hs * 2, hs);
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 2;
      ctx.strokeRect(handles.s.x - hs, handles.s.y - hs/2, hs * 2, hs);
      // Arrow indicator
      ctx.fillText('âŸ·', handles.s.x, handles.s.y);
      ctx.save();
      ctx.translate(handles.s.x, handles.s.y);
      ctx.rotate(Math.PI / 2);
      ctx.fillText('âŸ·', 0, 0);
      ctx.restore();

      // Bottom-right corner handle (southeast) - main resize handle
      ctx.fillStyle = isResizingRoom && roomResizeHandle === 'se' ? '#22c55e' : '#ef4444';
      ctx.beginPath();
      ctx.moveTo(roomW - hs * 1.5, roomH);
      ctx.lineTo(roomW, roomH);
      ctx.lineTo(roomW, roomH - hs * 1.5);
      ctx.closePath();
      ctx.fill();
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 2;
      ctx.stroke();
      // Diagonal resize indicator
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 14px Inter';
      ctx.fillText('â¤¡', roomW - hs * 0.6, roomH - hs * 0.4);

      // Dimension labels along edges
      ctx.fillStyle = 'rgba(255,255,255,0.6)';
      ctx.font = `bold ${Math.max(12, pixelsPerFoot / 3)}px Inter`;
      ctx.textAlign = 'center';

      // Top dimension
      ctx.fillText(`${roomWidth}'`, roomW / 2, -10);
      // Left dimension
      ctx.save();
      ctx.translate(-10, roomH / 2);
      ctx.rotate(-Math.PI / 2);
      ctx.fillText(`${roomDepth}'`, 0, 0);
      ctx.restore();

      // Foot markers along room edges
      ctx.fillStyle = 'rgba(255,255,255,0.4)';
      ctx.font = `${Math.max(9, pixelsPerFoot / 5)}px Inter`;
      for (let x = pixelsPerFoot; x < roomW; x += pixelsPerFoot) {
        ctx.fillText(`${Math.round(x / pixelsPerFoot)}'`, x, -25);
        // Tick mark
        ctx.strokeStyle = 'rgba(255,255,255,0.3)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, -6);
        ctx.stroke();
      }
      for (let y = pixelsPerFoot; y < roomH; y += pixelsPerFoot) {
        ctx.save();
        ctx.translate(-25, y);
        ctx.rotate(-Math.PI / 2);
        ctx.fillText(`${Math.round(y / pixelsPerFoot)}'`, 0, 0);
        ctx.restore();
        // Tick mark
        ctx.strokeStyle = 'rgba(255,255,255,0.3)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(-6, y);
        ctx.stroke();
      }
    }

    function drawFloorPlanAreas() {
      walls.filter(w => w.type === 'area').forEach(area => {
        ctx.fillStyle = 'rgba(60, 60, 80, 0.6)';
        ctx.fillRect(area.x, area.y, area.width, area.height);
        ctx.strokeStyle = '#666';
        ctx.lineWidth = 2;
        ctx.strokeRect(area.x, area.y, area.width, area.height);
      });
    }

    function drawWalls() {
      walls.filter(w => w.type === 'wall').forEach(wall => {
        ctx.fillStyle = wall.color;
        ctx.fillRect(wall.x, wall.y, wall.width, wall.height);
      });
    }

    // ===== RENDERING HELPER FUNCTIONS =====

    // Adjust a hex color by amount (-255 to 255)
    function adjustColor(color, amount) {
      if (!color || color.charAt(0) !== '#') return color;
      let r = parseInt(color.slice(1, 3), 16);
      let g = parseInt(color.slice(3, 5), 16);
      let b = parseInt(color.slice(5, 7), 16);
      r = Math.max(0, Math.min(255, r + amount));
      g = Math.max(0, Math.min(255, g + amount));
      b = Math.max(0, Math.min(255, b + amount));
      return `#${r.toString(16).padStart(2,'0')}${g.toString(16).padStart(2,'0')}${b.toString(16).padStart(2,'0')}`;
    }

    // Draw wood grain pattern
    function drawWoodGrain(ctx, x, y, w, h, baseColor, opacity = 1) {
      // Guard against invalid dimensions
      w = Math.abs(w);
      h = Math.abs(h);
      if (w < 1 || h < 1) return;

      const seed = Math.floor(x * 7 + y * 13) % 1000;
      const rand = (n) => ((seed + n * 31) % 100) / 100;

      ctx.save();
      ctx.globalAlpha = opacity;

      // Subtle wood grain lines
      ctx.strokeStyle = 'rgba(0,0,0,0.12)';
      ctx.lineWidth = 0.8;

      const grainCount = Math.floor(h / 6);
      for (let i = 0; i < grainCount; i++) {
        const gy = y + 4 + i * (h - 8) / grainCount;
        const waveAmp = 1 + rand(i) * 2;
        const waveFreq = 0.02 + rand(i + 50) * 0.03;

        ctx.beginPath();
        ctx.moveTo(x + 2, gy);

        for (let gx = x + 2; gx < x + w - 2; gx += 3) {
          const yOffset = Math.sin((gx - x) * waveFreq + rand(i + 100) * Math.PI) * waveAmp;
          ctx.lineTo(gx, gy + yOffset);
        }
        ctx.stroke();
      }

      // Occasional darker grain knots
      ctx.fillStyle = 'rgba(0,0,0,0.08)';
      const knotCount = Math.floor(w * h / 3000);
      for (let k = 0; k < knotCount; k++) {
        const kx = x + rand(k * 3) * w * 0.8 + w * 0.1;
        const ky = y + rand(k * 5) * h * 0.8 + h * 0.1;
        const kr = 2 + rand(k * 7) * 4;
        ctx.beginPath();
        ctx.ellipse(kx, ky, Math.abs(kr), Math.abs(kr * 0.6), rand(k * 11) * Math.PI, 0, Math.PI * 2);
        ctx.fill();
      }

      ctx.restore();
    }

    // Draw a single cabinet door with shaker style
    function drawCabinetDoor(ctx, x, y, w, h, color) {
      // Guard against invalid dimensions
      w = Math.abs(w);
      h = Math.abs(h);
      if (w < 1 || h < 1) return;

      // Door background
      ctx.fillStyle = color;
      ctx.fillRect(x, y, w, h);

      // Wood grain
      drawWoodGrain(ctx, x, y, w, h, color, 0.5);

      // Shaker panel inset
      const inset = Math.min(10, w * 0.1, h * 0.08);
      const px = x + inset;
      const py = y + inset;
      const pw = w - inset * 2;
      const ph = h - inset * 2;

      // Panel shadow (inset effect)
      ctx.fillStyle = 'rgba(0,0,0,0.15)';
      ctx.fillRect(px, py, pw, 2);
      ctx.fillRect(px, py, 2, ph);

      // Panel highlight
      ctx.fillStyle = 'rgba(255,255,255,0.1)';
      ctx.fillRect(px, py + ph - 2, pw, 2);
      ctx.fillRect(px + pw - 2, py, 2, ph);

      // Inner panel darker
      ctx.fillStyle = 'rgba(0,0,0,0.05)';
      ctx.fillRect(px + 2, py + 2, pw - 4, ph - 4);

      // Edge highlights
      ctx.fillStyle = 'rgba(255,255,255,0.1)';
      ctx.fillRect(x, y, w, 2);
      ctx.fillRect(x, y, 2, h);

      ctx.fillStyle = 'rgba(0,0,0,0.12)';
      ctx.fillRect(x, y + h - 2, w, 2);
      ctx.fillRect(x + w - 2, y, 2, h);

      // Handle
      const handleLen = Math.min(18, h * 0.3);
      const handleX = x + w - 8;
      const handleY = y + h / 2 - handleLen / 2;
      ctx.fillStyle = 'rgba(180,180,180,0.85)';
      ctx.fillRect(handleX, handleY, 3, handleLen);
      ctx.fillStyle = 'rgba(255,255,255,0.3)';
      ctx.fillRect(handleX, handleY, 1, handleLen);
    }

    // Draw countertop surface with material-specific patterns
    function drawCountertopSurface(ctx, x, y, w, h, color, materialName) {
      const name = (materialName || '').toLowerCase();
      const seed = Math.floor(x * 11 + y * 17) % 1000;
      const rand = (n) => ((seed + n * 23) % 100) / 100;

      // Determine material type from name
      let materialType = 'granite'; // default
      if (name.includes('marble') || name.includes('calacatta') || name.includes('carrara') || name.includes('statuario')) {
        materialType = 'marble';
      } else if (name.includes('quartz') || name.includes('silestone') || name.includes('caesarstone')) {
        materialType = 'quartz';
      } else if (name.includes('quartzite') || name.includes('taj') || name.includes('fantasy')) {
        materialType = 'quartzite';
      } else if (name.includes('concrete') || name.includes('cement')) {
        materialType = 'concrete';
      } else if (name.includes('butcher') || name.includes('wood') || name.includes('walnut') || name.includes('maple')) {
        materialType = 'wood';
      }

      ctx.save();

      switch (materialType) {
        case 'marble':
          // Marble: Dramatic veining on light background
          // Base with subtle variation
          const marbleGrad = ctx.createLinearGradient(x, y, x + w, y + h);
          marbleGrad.addColorStop(0, color);
          marbleGrad.addColorStop(0.5, adjustColor(color, 8));
          marbleGrad.addColorStop(1, adjustColor(color, -5));
          ctx.fillStyle = marbleGrad;
          ctx.fillRect(x, y, w, h);

          // Primary dramatic veins
          ctx.strokeStyle = 'rgba(80,80,90,0.35)';
          ctx.lineWidth = 2.5;
          for (let i = 0; i < 3; i++) {
            ctx.beginPath();
            const startX = x + rand(i) * w * 0.3;
            const startY = y + rand(i + 10) * h;
            ctx.moveTo(startX, startY);

            // Create flowing vein path
            const cp1x = x + w * (0.2 + rand(i + 20) * 0.3);
            const cp1y = y + h * rand(i + 30);
            const cp2x = x + w * (0.5 + rand(i + 40) * 0.3);
            const cp2y = y + h * rand(i + 50);
            const endX = x + w - rand(i + 60) * w * 0.2;
            const endY = y + rand(i + 70) * h;

            ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, endX, endY);
            ctx.stroke();

            // Feathered edges on main veins
            ctx.strokeStyle = 'rgba(80,80,90,0.15)';
            ctx.lineWidth = 5;
            ctx.stroke();
          }

          // Secondary thinner veins
          ctx.strokeStyle = 'rgba(100,100,110,0.2)';
          ctx.lineWidth = 1;
          for (let i = 0; i < 6; i++) {
            ctx.beginPath();
            ctx.moveTo(x + rand(i + 80) * w, y + rand(i + 90) * h);
            ctx.quadraticCurveTo(
              x + w * rand(i + 100),
              y + h * rand(i + 110),
              x + rand(i + 120) * w,
              y + rand(i + 130) * h
            );
            ctx.stroke();
          }
          break;

        case 'quartz':
          // Quartz: Uniform with subtle sparkle/flecks
          ctx.fillStyle = color;
          ctx.fillRect(x, y, w, h);

          // Fine uniform speckling
          const speckleCount = Math.floor(w * h / 40);
          for (let i = 0; i < speckleCount; i++) {
            const sx = x + rand(i) * w;
            const sy = y + rand(i + 500) * h;
            const brightness = rand(i + 1000) > 0.5 ? 'rgba(255,255,255,' : 'rgba(0,0,0,';
            const alpha = 0.05 + rand(i + 1500) * 0.1;
            ctx.fillStyle = brightness + alpha + ')';
            ctx.fillRect(sx, sy, 1.5, 1.5);
          }

          // Occasional larger sparkle spots
          ctx.fillStyle = 'rgba(255,255,255,0.25)';
          for (let i = 0; i < speckleCount / 20; i++) {
            const sx = x + rand(i + 2000) * w;
            const sy = y + rand(i + 2500) * h;
            ctx.beginPath();
            ctx.arc(sx, sy, 1, 0, Math.PI * 2);
            ctx.fill();
          }
          break;

        case 'quartzite':
          // Quartzite: Natural flowing patterns with crystalline look
          ctx.fillStyle = color;
          ctx.fillRect(x, y, w, h);

          // Flowing wave patterns
          ctx.strokeStyle = 'rgba(255,255,255,0.15)';
          ctx.lineWidth = 3;
          for (let i = 0; i < 5; i++) {
            ctx.beginPath();
            const startY = y + (i / 5) * h + rand(i) * h * 0.1;
            ctx.moveTo(x, startY);

            for (let px = 0; px <= w; px += 20) {
              const py = startY + Math.sin((px / w) * Math.PI * (2 + rand(i + 10))) * h * 0.1 * rand(i + 20);
              ctx.lineTo(x + px, py);
            }
            ctx.stroke();
          }

          // Crystalline shimmer
          ctx.fillStyle = 'rgba(255,255,255,0.08)';
          for (let i = 0; i < 30; i++) {
            const cx = x + rand(i + 300) * w;
            const cy = y + rand(i + 400) * h;
            ctx.beginPath();
            ctx.moveTo(cx, cy - 3);
            ctx.lineTo(cx + 2, cy);
            ctx.lineTo(cx, cy + 3);
            ctx.lineTo(cx - 2, cy);
            ctx.closePath();
            ctx.fill();
          }
          break;

        case 'concrete':
          // Concrete: Matte with subtle texture
          ctx.fillStyle = color;
          ctx.fillRect(x, y, w, h);

          // Subtle aggregate texture
          ctx.fillStyle = 'rgba(0,0,0,0.03)';
          for (let i = 0; i < w * h / 100; i++) {
            const cx = x + rand(i) * w;
            const cy = y + rand(i + 500) * h;
            ctx.beginPath();
            ctx.arc(cx, cy, 1 + rand(i + 1000) * 2, 0, Math.PI * 2);
            ctx.fill();
          }

          // Subtle variation patches
          for (let i = 0; i < 4; i++) {
            ctx.fillStyle = rand(i) > 0.5 ? 'rgba(0,0,0,0.02)' : 'rgba(255,255,255,0.02)';
            ctx.beginPath();
            ctx.ellipse(
              x + rand(i + 100) * Math.abs(w),
              y + rand(i + 200) * Math.abs(h),
              Math.abs(rand(i + 300) * w * 0.3) || 1,
              Math.abs(rand(i + 400) * h * 0.3) || 1,
              rand(i + 500) * Math.PI,
              0, Math.PI * 2
            );
            ctx.fill();
          }
          break;

        case 'wood':
          // Wood countertop: butcher block style
          drawWoodGrain(ctx, x, y, w, h, color);

          // Butcher block strips
          const stripWidth = pixelsPerFoot * 0.25;
          ctx.strokeStyle = 'rgba(0,0,0,0.1)';
          ctx.lineWidth = 1;
          for (let sx = x + stripWidth; sx < x + w; sx += stripWidth) {
            ctx.beginPath();
            ctx.moveTo(sx, y);
            ctx.lineTo(sx, y + h);
            ctx.stroke();
          }
          break;

        default: // granite
          // Granite: Speckled with various mineral colors
          ctx.fillStyle = color;
          ctx.fillRect(x, y, w, h);

          // Multi-colored speckles (mineral flecks)
          const mineralColors = [
            'rgba(0,0,0,0.3)',
            'rgba(255,255,255,0.25)',
            'rgba(150,150,150,0.2)',
            'rgba(100,80,60,0.15)',
            'rgba(60,60,70,0.2)'
          ];

          const graniteSpeckles = Math.floor(w * h / 25);
          for (let i = 0; i < graniteSpeckles; i++) {
            const gx = x + rand(i) * w;
            const gy = y + rand(i + 500) * h;
            const colorIdx = Math.floor(rand(i + 1000) * mineralColors.length);
            ctx.fillStyle = mineralColors[colorIdx];
            const size = 1 + rand(i + 1500) * 2;
            ctx.fillRect(gx, gy, size, size);
          }

          // Larger mineral clusters
          for (let i = 0; i < graniteSpeckles / 30; i++) {
            const cx = x + rand(i + 2000) * w;
            const cy = y + rand(i + 2500) * h;
            const ccolor = mineralColors[Math.floor(rand(i + 3000) * mineralColors.length)];
            ctx.fillStyle = ccolor;
            ctx.beginPath();
            ctx.arc(cx, cy, 2 + rand(i + 3500) * 3, 0, Math.PI * 2);
            ctx.fill();
          }
      }

      // Edge profile (bullnose/eased edge look)
      // Top edge highlight
      ctx.fillStyle = 'rgba(255,255,255,0.2)';
      ctx.fillRect(x, y, w, 3);
      ctx.fillRect(x, y, 3, h);

      // Bottom edge shadow
      ctx.fillStyle = 'rgba(0,0,0,0.25)';
      ctx.fillRect(x, y + h - 3, w, 3);
      ctx.fillRect(x + w - 3, y, 3, h);

      // Outer border
      ctx.strokeStyle = 'rgba(255,255,255,0.15)';
      ctx.lineWidth = 1;
      ctx.strokeRect(x + 1, y + 1, w - 2, h - 2);

      ctx.restore();
    }

    // Draw architectural details for each element type
    function drawElementDetails(el, x, y, w, h) {
      ctx.strokeStyle = 'rgba(255,255,255,0.4)';
      ctx.fillStyle = 'rgba(255,255,255,0.1)';
      ctx.lineWidth = 1;

      const type = el.type;
      const padding = Math.min(w, h) * 0.08;

      // Check if element has a loaded texture image
      const hasTexture = el.textureImg && el.textureImg.complete && el.textureImg.naturalWidth > 0;

      switch(type) {
        case 'base-cabinet':
        case 'wall-cabinet':
          // Determine cabinet style from material or default to shaker
          const cabinetStyle = el.materialName?.toLowerCase().includes('flat') ? 'flat' : 'shaker';
          const isWallCab = type === 'wall-cabinet';

          // Toe kick dimensions for base cabinets (4" tall, 3" recessed from front)
          const toeKickH = isWallCab ? 0 : Math.max(8, h * 0.15);
          const toeKickRecess = isWallCab ? 0 : Math.max(5, w * 0.06);

          // Cabinet body height (excluding toe kick)
          const cabinetBodyH = h - toeKickH;

          // Draw toe kick recess FIRST (at the front/bottom of cabinet)
          if (!isWallCab && toeKickH > 0) {
            // Dark recessed void under cabinet
            ctx.fillStyle = '#0d0d12';
            ctx.fillRect(x + toeKickRecess, y + cabinetBodyH, w - toeKickRecess * 2, toeKickH);

            // Shadow line at top of toe kick (under cabinet overhang)
            ctx.fillStyle = 'rgba(0,0,0,0.7)';
            ctx.fillRect(x + toeKickRecess, y + cabinetBodyH, w - toeKickRecess * 2, 3);

            // Cabinet overhang edge
            ctx.fillStyle = adjustColor(el.color, -40);
            ctx.fillRect(x, y + cabinetBodyH - 2, w, 2);
          }

          // Draw wood grain background on cabinet body (only if no texture)
          if (!hasTexture) {
            drawWoodGrain(ctx, x, y, w, cabinetBodyH, el.color);
          }

          // Calculate door layout (doors are on the cabinet body, not toe kick)
          const doorCount = Math.max(1, Math.floor(w / (pixelsPerFoot * 1.5)));
          const doorWidth = (w - padding * 2) / doorCount;

          for (let i = 0; i < doorCount; i++) {
            const dx = x + padding + i * doorWidth;
            const dy = y + padding;
            const dw = doorWidth - 4;
            const dh = cabinetBodyH - padding * 2; // Door height stops at toe kick

            // Door frame shadow
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.fillRect(dx + 3, dy + 3, dw, dh);

            // Door face
            ctx.fillStyle = el.color;
            ctx.fillRect(dx, dy, dw, dh);

            // Wood grain on door (only if no texture loaded)
            if (!hasTexture) {
              drawWoodGrain(ctx, dx + 2, dy + 2, dw - 4, dh - 4, el.color, 0.6);
            }

            if (cabinetStyle === 'shaker') {
              // Shaker style recessed panel
              const panelInset = Math.min(12, dw * 0.12);
              const px = dx + panelInset;
              const py = dy + panelInset;
              const pw = dw - panelInset * 2;
              const ph = dh - panelInset * 2;

              // Panel recess shadow (top-left inside)
              ctx.fillStyle = 'rgba(0,0,0,0.2)';
              ctx.fillRect(px, py, pw, 3);
              ctx.fillRect(px, py, 3, ph);

              // Panel recess highlight (bottom-right inside)
              ctx.fillStyle = 'rgba(255,255,255,0.15)';
              ctx.fillRect(px, py + ph - 3, pw, 3);
              ctx.fillRect(px + pw - 3, py, 3, ph);

              // Inner panel (slightly darker)
              ctx.fillStyle = 'rgba(0,0,0,0.08)';
              ctx.fillRect(px + 3, py + 3, pw - 6, ph - 6);

              // Panel outer frame highlight
              ctx.strokeStyle = 'rgba(255,255,255,0.12)';
              ctx.lineWidth = 1;
              ctx.strokeRect(dx + 2, dy + 2, dw - 4, dh - 4);
            } else {
              // Flat/slab style - just edge detail
              ctx.strokeStyle = 'rgba(255,255,255,0.1)';
              ctx.lineWidth = 1;
              ctx.strokeRect(dx + 2, dy + 2, dw - 4, dh - 4);
            }

            // Door edge highlights
            ctx.fillStyle = 'rgba(255,255,255,0.12)';
            ctx.fillRect(dx, dy, dw, 2); // top
            ctx.fillRect(dx, dy, 2, dh); // left

            ctx.fillStyle = 'rgba(0,0,0,0.15)';
            ctx.fillRect(dx, dy + dh - 2, dw, 2); // bottom
            ctx.fillRect(dx + dw - 2, dy, 2, dh); // right

            // Door handle - bar pull style
            const handleLen = Math.min(24, dh * 0.35);
            const handleX = dx + dw - 10;
            const handleY = dy + dh / 2 - handleLen / 2;

            // Handle shadow
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.fillRect(handleX + 2, handleY + 2, 4, handleLen);

            // Handle body (brushed nickel look)
            const handleGrad = ctx.createLinearGradient(handleX, 0, handleX + 4, 0);
            handleGrad.addColorStop(0, 'rgba(200,200,200,0.9)');
            handleGrad.addColorStop(0.5, 'rgba(240,240,240,0.95)');
            handleGrad.addColorStop(1, 'rgba(180,180,180,0.9)');
            ctx.fillStyle = handleGrad;
            ctx.fillRect(handleX, handleY, 4, handleLen);

            // Handle ends (rounded caps)
            ctx.fillStyle = 'rgba(160,160,160,0.9)';
            ctx.beginPath();
            ctx.arc(handleX + 2, handleY, 3, 0, Math.PI * 2);
            ctx.arc(handleX + 2, handleY + handleLen, 3, 0, Math.PI * 2);
            ctx.fill();
          }

          // Side panel edges visible
          if (!isWallCab) {
            ctx.fillStyle = adjustColor(el.color, -25);
            ctx.fillRect(x, y, 2, cabinetBodyH);
            ctx.fillRect(x + w - 2, y, 2, cabinetBodyH);
          }
          break;

        case 'drawer-base': {
          // Drawer base cabinet - 3-4 stacked drawer fronts
          const dbToeKickH = Math.max(8, h * 0.15);
          const dbToeKickRecess = Math.max(5, w * 0.06);
          const dbBodyH = h - dbToeKickH;

          // Draw toe kick recess
          ctx.fillStyle = '#0d0d12';
          ctx.fillRect(x + dbToeKickRecess, y + dbBodyH, w - dbToeKickRecess * 2, dbToeKickH);
          ctx.fillStyle = 'rgba(0,0,0,0.7)';
          ctx.fillRect(x + dbToeKickRecess, y + dbBodyH, w - dbToeKickRecess * 2, 3);
          ctx.fillStyle = adjustColor(el.color, -40);
          ctx.fillRect(x, y + dbBodyH - 2, w, 2);

          // Draw wood grain background
          if (!hasTexture) {
            drawWoodGrain(ctx, x, y, w, dbBodyH, el.color);
          }

          // Calculate drawer layout (3-4 drawers)
          const numDrawers = w > pixelsPerFoot * 2 ? 4 : 3;
          const drawerHeight = (dbBodyH - padding * 2 - (numDrawers - 1) * 3) / numDrawers;

          for (let i = 0; i < numDrawers; i++) {
            const dx = x + padding;
            const dy = y + padding + i * (drawerHeight + 3);
            const dw = w - padding * 2;
            const dh = drawerHeight;

            // Drawer shadow
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.fillRect(dx + 3, dy + 3, dw, dh);

            // Drawer face
            ctx.fillStyle = el.color;
            ctx.fillRect(dx, dy, dw, dh);

            // Drawer panel detail (shaker style)
            const panelInset = Math.min(8, dw * 0.08);
            ctx.fillStyle = 'rgba(0,0,0,0.15)';
            ctx.fillRect(dx + panelInset, dy + panelInset, 2, dh - panelInset * 2);
            ctx.fillRect(dx + panelInset, dy + panelInset, dw - panelInset * 2, 2);
            ctx.fillStyle = 'rgba(255,255,255,0.1)';
            ctx.fillRect(dx + dw - panelInset - 2, dy + panelInset, 2, dh - panelInset * 2);
            ctx.fillRect(dx + panelInset, dy + dh - panelInset - 2, dw - panelInset * 2, 2);

            // Drawer edge highlights
            ctx.fillStyle = 'rgba(255,255,255,0.12)';
            ctx.fillRect(dx, dy, dw, 2);
            ctx.fillRect(dx, dy, 2, dh);
            ctx.fillStyle = 'rgba(0,0,0,0.15)';
            ctx.fillRect(dx, dy + dh - 2, dw, 2);
            ctx.fillRect(dx + dw - 2, dy, 2, dh);

            // Centered bar pull handle
            const handleLen = Math.min(dw * 0.4, 40);
            const handleX = dx + dw / 2 - handleLen / 2;
            const handleY = dy + dh / 2 - 2;

            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.fillRect(handleX + 2, handleY + 2, handleLen, 4);

            const handleGrad = ctx.createLinearGradient(0, handleY, 0, handleY + 4);
            handleGrad.addColorStop(0, 'rgba(220,220,220,0.95)');
            handleGrad.addColorStop(0.5, 'rgba(250,250,250,0.95)');
            handleGrad.addColorStop(1, 'rgba(190,190,190,0.9)');
            ctx.fillStyle = handleGrad;
            ctx.fillRect(handleX, handleY, handleLen, 4);
          }

          // Side panel edges
          ctx.fillStyle = adjustColor(el.color, -25);
          ctx.fillRect(x, y, 2, dbBodyH);
          ctx.fillRect(x + w - 2, y, 2, dbBodyH);
          break;
        }

        case 'sink-base': {
          // Sink base cabinet - false drawer front at top, open interior
          const sbToeKickH = Math.max(8, h * 0.15);
          const sbToeKickRecess = Math.max(5, w * 0.06);
          const sbBodyH = h - sbToeKickH;

          // Draw toe kick recess
          ctx.fillStyle = '#0d0d12';
          ctx.fillRect(x + sbToeKickRecess, y + sbBodyH, w - sbToeKickRecess * 2, sbToeKickH);
          ctx.fillStyle = 'rgba(0,0,0,0.7)';
          ctx.fillRect(x + sbToeKickRecess, y + sbBodyH, w - sbToeKickRecess * 2, 3);
          ctx.fillStyle = adjustColor(el.color, -40);
          ctx.fillRect(x, y + sbBodyH - 2, w, 2);

          // Draw wood grain background
          if (!hasTexture) {
            drawWoodGrain(ctx, x, y, w, sbBodyH, el.color);
          }

          // False drawer front at top (non-functional)
          const falseDrawerH = Math.min(sbBodyH * 0.18, 20);
          const fdx = x + padding;
          const fdy = y + padding;
          const fdw = w - padding * 2;

          ctx.fillStyle = 'rgba(0,0,0,0.3)';
          ctx.fillRect(fdx + 3, fdy + 3, fdw, falseDrawerH);
          ctx.fillStyle = el.color;
          ctx.fillRect(fdx, fdy, fdw, falseDrawerH);
          ctx.fillStyle = 'rgba(255,255,255,0.12)';
          ctx.fillRect(fdx, fdy, fdw, 2);
          ctx.fillStyle = 'rgba(0,0,0,0.1)';
          ctx.fillRect(fdx, fdy + falseDrawerH - 2, fdw, 2);

          // False drawer handle
          const fhandleLen = Math.min(fdw * 0.4, 35);
          const fhandleX = fdx + fdw / 2 - fhandleLen / 2;
          const fhandleY = fdy + falseDrawerH / 2 - 2;
          ctx.fillStyle = 'rgba(200,200,200,0.9)';
          ctx.fillRect(fhandleX, fhandleY, fhandleLen, 3);

          // Double door section below
          const doorsY = fdy + falseDrawerH + 4;
          const doorsH = sbBodyH - padding * 2 - falseDrawerH - 4;
          const doorW = (fdw - 4) / 2;

          for (let i = 0; i < 2; i++) {
            const ddx = fdx + i * (doorW + 4);
            const ddy = doorsY;
            const ddw = doorW;
            const ddh = doorsH;

            // Door shadow
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.fillRect(ddx + 3, ddy + 3, ddw, ddh);

            // Door face
            ctx.fillStyle = el.color;
            ctx.fillRect(ddx, ddy, ddw, ddh);

            // Shaker panel
            const panelInset = Math.min(10, ddw * 0.1);
            ctx.fillStyle = 'rgba(0,0,0,0.15)';
            ctx.fillRect(ddx + panelInset, ddy + panelInset, 2, ddh - panelInset * 2);
            ctx.fillRect(ddx + panelInset, ddy + panelInset, ddw - panelInset * 2, 2);
            ctx.fillStyle = 'rgba(255,255,255,0.1)';
            ctx.fillRect(ddx + ddw - panelInset - 2, ddy + panelInset, 2, ddh - panelInset * 2);
            ctx.fillRect(ddx + panelInset, ddy + ddh - panelInset - 2, ddw - panelInset * 2, 2);

            // Door edge highlights
            ctx.fillStyle = 'rgba(255,255,255,0.12)';
            ctx.fillRect(ddx, ddy, ddw, 2);
            ctx.fillRect(ddx, ddy, 2, ddh);
            ctx.fillStyle = 'rgba(0,0,0,0.15)';
            ctx.fillRect(ddx, ddy + ddh - 2, ddw, 2);
            ctx.fillRect(ddx + ddw - 2, ddy, 2, ddh);

            // Door handle
            const dhandleLen = Math.min(20, ddh * 0.3);
            const dhandleX = i === 0 ? ddx + ddw - 10 : ddx + 6;
            const dhandleY = ddy + ddh / 2 - dhandleLen / 2;
            ctx.fillStyle = 'rgba(200,200,200,0.9)';
            ctx.fillRect(dhandleX, dhandleY, 4, dhandleLen);
          }

          // Side panel edges
          ctx.fillStyle = adjustColor(el.color, -25);
          ctx.fillRect(x, y, 2, sbBodyH);
          ctx.fillRect(x + w - 2, y, 2, sbBodyH);
          break;
        }

        case 'lazy-susan': {
          // Lazy Susan corner cabinet - L-shape with rotating shelves
          const lsToeKickH = Math.max(8, h * 0.12);
          const lsToeKickRecess = Math.max(5, w * 0.05);
          const lsBodyH = h - lsToeKickH;
          const lsArmW = w * 0.48;
          const lsArmH = h * 0.48;

          // L-shape shadow
          ctx.fillStyle = 'rgba(0,0,0,0.35)';
          ctx.beginPath();
          ctx.moveTo(x + padding + 4, y + padding + 4);
          ctx.lineTo(x + padding + 4, y + h - padding + 4);
          ctx.lineTo(x + lsArmW + 4, y + h - padding + 4);
          ctx.lineTo(x + lsArmW + 4, y + lsArmH + 4);
          ctx.lineTo(x + w - padding + 4, y + lsArmH + 4);
          ctx.lineTo(x + w - padding + 4, y + padding + 4);
          ctx.closePath();
          ctx.fill();

          // L-shape cabinet body
          ctx.fillStyle = el.color;
          ctx.beginPath();
          ctx.moveTo(x + padding, y + padding);
          ctx.lineTo(x + padding, y + h - padding);
          ctx.lineTo(x + lsArmW, y + h - padding);
          ctx.lineTo(x + lsArmW, y + lsArmH);
          ctx.lineTo(x + w - padding, y + lsArmH);
          ctx.lineTo(x + w - padding, y + padding);
          ctx.closePath();
          ctx.fill();

          // Wood grain
          ctx.save();
          ctx.beginPath();
          ctx.moveTo(x + padding, y + padding);
          ctx.lineTo(x + padding, y + h - padding);
          ctx.lineTo(x + lsArmW, y + h - padding);
          ctx.lineTo(x + lsArmW, y + lsArmH);
          ctx.lineTo(x + w - padding, y + lsArmH);
          ctx.lineTo(x + w - padding, y + padding);
          ctx.closePath();
          ctx.clip();
          drawWoodGrain(ctx, x, y, w, h, el.color, 0.5);
          ctx.restore();

          // Diagonal door
          ctx.fillStyle = adjustColor(el.color, -10);
          ctx.beginPath();
          ctx.moveTo(x + lsArmW + 4, y + lsArmH + 4);
          ctx.lineTo(x + lsArmW + 4, y + h - padding - 4);
          ctx.lineTo(x + w - padding - 4, y + lsArmH + 4);
          ctx.closePath();
          ctx.fill();

          // Lazy Susan circles (showing rotating shelf)
          ctx.strokeStyle = 'rgba(255,255,255,0.25)';
          ctx.lineWidth = 2;
          const lsCenter = { x: x + w * 0.35, y: y + h * 0.65 };
          const lsRadius = Math.min(w, h) * 0.22;
          ctx.beginPath();
          ctx.arc(lsCenter.x, lsCenter.y, lsRadius, 0, Math.PI * 2);
          ctx.stroke();
          ctx.beginPath();
          ctx.arc(lsCenter.x, lsCenter.y, lsRadius * 0.6, 0, Math.PI * 2);
          ctx.stroke();

          // Rotating indicator
          ctx.strokeStyle = 'rgba(255,255,255,0.15)';
          ctx.setLineDash([4, 4]);
          ctx.beginPath();
          ctx.moveTo(lsCenter.x, lsCenter.y - lsRadius);
          ctx.lineTo(lsCenter.x, lsCenter.y + lsRadius);
          ctx.moveTo(lsCenter.x - lsRadius, lsCenter.y);
          ctx.lineTo(lsCenter.x + lsRadius, lsCenter.y);
          ctx.stroke();
          ctx.setLineDash([]);

          // Handle on diagonal
          const lsHandleX = x + w * 0.6;
          const lsHandleY = y + h * 0.45;
          ctx.fillStyle = 'rgba(200,200,200,0.85)';
          ctx.fillRect(lsHandleX, lsHandleY, 15, 4);
          break;
        }

        case 'tall-cabinet':
          // Toe kick for tall cabinet
          const tallToeH = Math.max(8, h * 0.08);
          const tallToeRecess = Math.max(5, w * 0.06);
          const tallBodyH = h - tallToeH;

          // Draw toe kick recess first
          ctx.fillStyle = '#0d0d12';
          ctx.fillRect(x + tallToeRecess, y + tallBodyH, w - tallToeRecess * 2, tallToeH);
          ctx.fillStyle = 'rgba(0,0,0,0.7)';
          ctx.fillRect(x + tallToeRecess, y + tallBodyH, w - tallToeRecess * 2, 3);
          ctx.fillStyle = adjustColor(el.color, -40);
          ctx.fillRect(x, y + tallBodyH - 2, w, 2);

          // Draw wood grain background on cabinet body
          drawWoodGrain(ctx, x, y, w, tallBodyH, el.color);

          // Two-section tall cabinet (upper 38%, lower 62% of body)
          const tallMidY = y + tallBodyH * 0.38;
          const sectionGap = 4;

          // Upper section (shorter - for wall cabinet style items)
          const upperH = tallMidY - y - padding - sectionGap/2;
          drawCabinetDoor(ctx, x + padding, y + padding, w - padding * 2, upperH, el.color);

          // Lower section (taller - for base items/pantry)
          const lowerY = tallMidY + sectionGap/2;
          const lowerH = tallBodyH - (tallMidY - y) - padding - sectionGap/2;
          drawCabinetDoor(ctx, x + padding, lowerY, w - padding * 2, lowerH, el.color);

          // Side panel edges
          ctx.fillStyle = adjustColor(el.color, -25);
          ctx.fillRect(x, y, 2, tallBodyH);
          ctx.fillRect(x + w - 2, y, 2, tallBodyH);
          break;

        case 'fridge-cabinet': {
          // Fridge enclosure cabinet - frame with opening for fridge and cabinet above
          const fridgeCabPadding = 4;
          const panelWidth = w * 0.08; // Side panels
          const topCabinetH = h * 0.25; // Cabinet above fridge
          const fridgeOpeningH = h * 0.70; // Opening for fridge
          const toeKickH = h * 0.05;

          // Draw outer frame/panels
          ctx.fillStyle = el.color || '#8B4513';

          // Left panel
          ctx.fillRect(x, y, panelWidth, h - toeKickH);
          // Right panel
          ctx.fillRect(x + w - panelWidth, y, panelWidth, h - toeKickH);
          // Top cabinet section
          ctx.fillRect(x, y, w, topCabinetH);

          // Draw cabinet door on top section
          drawCabinetDoor(ctx, x + fridgeCabPadding, y + fridgeCabPadding, w - fridgeCabPadding * 2, topCabinetH - fridgeCabPadding * 2, el.color);

          // Fridge opening (dark recess)
          ctx.fillStyle = '#1a1a1a';
          ctx.fillRect(x + panelWidth, y + topCabinetH, w - panelWidth * 2, fridgeOpeningH);

          // Fridge icon in opening
          ctx.fillStyle = '#888';
          const fridgeIconX = x + panelWidth + (w - panelWidth * 2) * 0.15;
          const fridgeIconY = y + topCabinetH + fridgeOpeningH * 0.1;
          const fridgeIconW = (w - panelWidth * 2) * 0.7;
          const fridgeIconH = fridgeOpeningH * 0.8;
          ctx.fillRect(fridgeIconX, fridgeIconY, fridgeIconW, fridgeIconH);
          // Fridge handle
          ctx.fillStyle = '#555';
          ctx.fillRect(fridgeIconX + fridgeIconW - 8, fridgeIconY + fridgeIconH * 0.2, 4, fridgeIconH * 0.3);
          ctx.fillRect(fridgeIconX + fridgeIconW - 8, fridgeIconY + fridgeIconH * 0.6, 4, fridgeIconH * 0.3);

          // Toe kick
          ctx.fillStyle = '#0d0d12';
          ctx.fillRect(x + panelWidth * 0.5, y + h - toeKickH, w - panelWidth, toeKickH);

          // Panel edges/shadows
          ctx.fillStyle = adjustColor(el.color, -25);
          ctx.fillRect(x + panelWidth - 2, y + topCabinetH, 2, fridgeOpeningH);
          ctx.fillRect(x + w - panelWidth, y + topCabinetH, 2, fridgeOpeningH);
          break;
        }

        case 'island':
          // Island with countertop overhang and cabinet base with toe kick
          const counterOverhang = 10; // Countertop overhangs the base
          const islandToeH = 6; // Toe kick height
          const islandToeRecess = 5; // Toe kick recessed from cabinet face

          // Cabinet base dimensions (inside the countertop overhang)
          const islandBaseX = x + counterOverhang;
          const islandBaseY = y + counterOverhang;
          const islandBaseW = w - counterOverhang * 2;
          const islandBaseH = h - counterOverhang * 2;

          // Cabinet body (above toe kick)
          const islandCabH = islandBaseH - islandToeH;

          // Draw toe kick recess FIRST (all 4 sides since island is accessible from all sides)
          ctx.fillStyle = '#0d0d12';
          // Front (bottom in Y)
          ctx.fillRect(islandBaseX + islandToeRecess, islandBaseY + islandCabH, islandBaseW - islandToeRecess * 2, islandToeH);
          // Back (top in Y)
          ctx.fillRect(islandBaseX + islandToeRecess, islandBaseY, islandBaseW - islandToeRecess * 2, islandToeH);
          // Left
          ctx.fillRect(islandBaseX, islandBaseY + islandToeRecess, islandToeH, islandBaseH - islandToeRecess * 2);
          // Right
          ctx.fillRect(islandBaseX + islandBaseW - islandToeH, islandBaseY + islandToeRecess, islandToeH, islandBaseH - islandToeRecess * 2);

          // Shadow lines at toe kick edges
          ctx.fillStyle = 'rgba(0,0,0,0.6)';
          ctx.fillRect(islandBaseX + islandToeRecess, islandBaseY + islandCabH, islandBaseW - islandToeRecess * 2, 2);
          ctx.fillRect(islandBaseX + islandToeRecess, islandBaseY + islandToeH - 2, islandBaseW - islandToeRecess * 2, 2);

          // Cabinet body (between toe kicks)
          const cabBodyX = islandBaseX + islandToeH;
          const cabBodyY = islandBaseY + islandToeH;
          const cabBodyW = islandBaseW - islandToeH * 2;
          const cabBodyH = islandCabH - islandToeH;

          // Cabinet base color
          ctx.fillStyle = adjustColor(el.color, -30);
          ctx.fillRect(cabBodyX, cabBodyY, cabBodyW, cabBodyH);

          // Draw cabinet doors on the cabinet body
          const islandDoorCount = Math.max(2, Math.floor(cabBodyW / (pixelsPerFoot * 1.2)));
          const islandDoorW = (cabBodyW - 8) / islandDoorCount;

          for (let i = 0; i < islandDoorCount; i++) {
            const idx = cabBodyX + 4 + i * islandDoorW;
            const idy = cabBodyY + 4;
            const idw = islandDoorW - 4;
            const idh = cabBodyH - 8;

            // Door panel
            ctx.fillStyle = adjustColor(el.color, -20);
            ctx.fillRect(idx, idy, idw, idh);

            // Shaker panel inset
            const inset = Math.min(8, idw * 0.1);
            ctx.strokeStyle = 'rgba(0,0,0,0.2)';
            ctx.lineWidth = 1;
            ctx.strokeRect(idx + inset, idy + inset, idw - inset * 2, idh - inset * 2);

            // Handle
            ctx.fillStyle = 'rgba(180,180,180,0.8)';
            ctx.fillRect(idx + idw - 8, idy + idh/2 - 8, 3, 16);
          }

          // Draw countertop surface LAST (on top, with overhang)
          if (!hasTexture) {
            drawCountertopSurface(ctx, x, y, w, h, el.color, el.materialName);
          } else {
            // Just edge highlights for textured countertop
            ctx.fillStyle = 'rgba(255,255,255,0.2)';
            ctx.fillRect(x, y, w, 3);
            ctx.fillRect(x, y, 3, h);
            ctx.fillStyle = 'rgba(0,0,0,0.25)';
            ctx.fillRect(x, y + h - 3, w, 3);
            ctx.fillRect(x + w - 3, y, 3, h);
          }

          break;

        case 'countertop':
          // Draw countertop with material-specific patterns (only if no texture)
          if (!hasTexture) {
            drawCountertopSurface(ctx, x, y, w, h, el.color, el.materialName);
          } else {
            // Just add edge profile for textured countertops
            ctx.fillStyle = 'rgba(255,255,255,0.15)';
            ctx.fillRect(x, y, w, 3);
            ctx.fillRect(x, y, 3, h);
            ctx.fillStyle = 'rgba(0,0,0,0.2)';
            ctx.fillRect(x, y + h - 3, w, 3);
            ctx.fillRect(x + w - 3, y, 3, h);
          }

          // Draw seams if present
          if (el.seams && el.seams.length > 0) {
            el.seams.forEach(seam => {
              const seamX = x + w * seam.position;
              // Seam line (dashed)
              ctx.save();
              ctx.setLineDash([6, 4]);
              ctx.strokeStyle = '#dc3545';
              ctx.lineWidth = 2;
              ctx.beginPath();
              ctx.moveTo(seamX, y + 2);
              ctx.lineTo(seamX, y + h - 2);
              ctx.stroke();
              ctx.restore();

              // Seam marker (small diamond)
              ctx.fillStyle = '#dc3545';
              ctx.beginPath();
              ctx.moveTo(seamX, y - 6);
              ctx.lineTo(seamX + 5, y);
              ctx.lineTo(seamX, y + 6);
              ctx.lineTo(seamX - 5, y);
              ctx.closePath();
              ctx.fill();
            });
          }
          break;

        case 'surface-stainless':
          // Stainless steel with brushed effect
          ctx.fillStyle = '#C0C0C0';
          ctx.fillRect(x, y, w, h);
          // Brushed lines
          ctx.strokeStyle = 'rgba(255,255,255,0.3)';
          ctx.lineWidth = 1;
          for (let ly = y + 3; ly < y + h; ly += 4) {
            ctx.beginPath();
            ctx.moveTo(x + 2, ly);
            ctx.lineTo(x + w - 2, ly);
            ctx.stroke();
          }
          // Metallic highlight
          ctx.fillStyle = 'rgba(255,255,255,0.15)';
          ctx.fillRect(x, y, w, 4);
          ctx.fillRect(x, y, 4, h);
          // Shadow edge
          ctx.fillStyle = 'rgba(0,0,0,0.15)';
          ctx.fillRect(x, y + h - 3, w, 3);
          ctx.fillRect(x + w - 3, y, 3, h);
          break;

        case 'surface-solid':
          // Solid surface (Corian-style) - smooth matte
          ctx.fillStyle = el.color || '#E8E4E0';
          ctx.fillRect(x, y, w, h);
          // Subtle seamless look
          ctx.fillStyle = 'rgba(255,255,255,0.1)';
          ctx.fillRect(x + 1, y + 1, w - 2, 2);
          ctx.fillStyle = 'rgba(0,0,0,0.1)';
          ctx.fillRect(x + 1, y + h - 3, w - 2, 2);
          break;

        case 'surface-laminate':
          // Laminate/Formica with edge banding
          ctx.fillStyle = el.color || '#D4C4A8';
          ctx.fillRect(x, y, w, h);
          // Dark edge banding
          ctx.strokeStyle = '#4A4A4A';
          ctx.lineWidth = 2;
          ctx.strokeRect(x, y, w, h);
          // Subtle pattern if no texture
          if (!hasTexture) {
            ctx.fillStyle = 'rgba(0,0,0,0.03)';
            for (let px = x; px < x + w; px += 8) {
              ctx.fillRect(px, y, 4, h);
            }
          }
          break;

        case 'surface-butcherblock':
          // Butcher block with wood grain
          ctx.fillStyle = el.color || '#C4A76C';
          ctx.fillRect(x, y, w, h);
          // Wood strips
          ctx.strokeStyle = 'rgba(139,69,19,0.4)';
          ctx.lineWidth = 1;
          for (let sx = x + 6; sx < x + w; sx += 6) {
            ctx.beginPath();
            ctx.moveTo(sx, y + 2);
            ctx.lineTo(sx, y + h - 2);
            ctx.stroke();
          }
          // Highlights
          ctx.fillStyle = 'rgba(255,255,255,0.1)';
          ctx.fillRect(x, y, w, 3);
          break;

        case 'surface-concrete':
          // Concrete with industrial look
          ctx.fillStyle = el.color || '#808080';
          ctx.fillRect(x, y, w, h);
          // Aggregate texture spots
          ctx.fillStyle = 'rgba(0,0,0,0.1)';
          for (let i = 0; i < 20; i++) {
            const spotX = x + 5 + Math.random() * (w - 10);
            const spotY = y + 5 + Math.random() * (h - 10);
            ctx.beginPath();
            ctx.arc(spotX, spotY, 2 + Math.random() * 2, 0, Math.PI * 2);
            ctx.fill();
          }
          // Light aggregate
          ctx.fillStyle = 'rgba(255,255,255,0.1)';
          for (let i = 0; i < 15; i++) {
            const spotX = x + 5 + Math.random() * (w - 10);
            const spotY = y + 5 + Math.random() * (h - 10);
            ctx.beginPath();
            ctx.arc(spotX, spotY, 1 + Math.random() * 2, 0, Math.PI * 2);
            ctx.fill();
          }
          break;

        case 'backsplash':
          // If texture is loaded, just add subtle edge detail
          if (hasTexture) {
            ctx.strokeStyle = 'rgba(255,255,255,0.2)';
            ctx.lineWidth = 1;
            ctx.strokeRect(x + 1, y + 1, w - 2, h - 2);
            break;
          }

          // Draw backsplash with material-specific pattern
          const bsName = (el.materialName || '').toLowerCase();
          const bsSeed = Math.floor(x * 13 + y * 19) % 1000;
          const bsRand = (n) => ((bsSeed + n * 29) % 100) / 100;

          // Determine tile style from material name
          let tileStyle = 'subway'; // default
          if (bsName.includes('mosaic') || bsName.includes('penny')) {
            tileStyle = 'mosaic';
          } else if (bsName.includes('herringbone')) {
            tileStyle = 'herringbone';
          } else if (bsName.includes('hexagon') || bsName.includes('hex')) {
            tileStyle = 'hexagon';
          } else if (bsName.includes('arabesque') || bsName.includes('lantern')) {
            tileStyle = 'arabesque';
          } else if (bsName.includes('chevron')) {
            tileStyle = 'chevron';
          } else if (bsName.includes('marble') || bsName.includes('granite') || bsName.includes('quartz') || bsName.includes('slab')) {
            tileStyle = 'slab';
          }

          switch (tileStyle) {
            case 'subway':
              // Classic subway tile (3x6 ratio)
              const subwayH = Math.max(12, h / 4);
              const subwayW = subwayH * 2;
              let subwayRow = 0;

              for (let ty = y; ty < y + h; ty += subwayH) {
                const offset = (subwayRow % 2) * (subwayW / 2);
                for (let tx = x - offset; tx < x + w + subwayW; tx += subwayW) {
                  if (tx + subwayW > x && tx < x + w) {
                    const tileX = Math.max(tx, x);
                    const tileW = Math.min(tx + subwayW, x + w) - tileX;
                    const tileY = Math.max(ty, y);
                    const tileH = Math.min(ty + subwayH, y + h) - tileY;

                    // Tile face with subtle variation
                    const variation = (bsRand(tx + ty) - 0.5) * 10;
                    ctx.fillStyle = adjustColor(el.color, variation);
                    ctx.fillRect(tileX + 1, tileY + 1, tileW - 2, tileH - 2);

                    // Tile bevel highlight (top/left)
                    ctx.fillStyle = 'rgba(255,255,255,0.15)';
                    ctx.fillRect(tileX + 1, tileY + 1, tileW - 2, 2);
                    ctx.fillRect(tileX + 1, tileY + 1, 2, tileH - 2);

                    // Tile bevel shadow (bottom/right)
                    ctx.fillStyle = 'rgba(0,0,0,0.1)';
                    ctx.fillRect(tileX + 1, tileY + tileH - 3, tileW - 2, 2);
                    ctx.fillRect(tileX + tileW - 3, tileY + 1, 2, tileH - 2);
                  }
                }
                subwayRow++;
              }
              // Grout lines
              ctx.strokeStyle = 'rgba(100,100,100,0.4)';
              ctx.lineWidth = 1;
              ctx.strokeRect(x, y, w, h);
              break;

            case 'mosaic':
              // Small mosaic tiles
              const mosaicSize = Math.max(8, Math.min(w, h) / 8);
              for (let ty = y; ty < y + h; ty += mosaicSize) {
                for (let tx = x; tx < x + w; tx += mosaicSize) {
                  const variation = (bsRand(tx * 3 + ty * 7) - 0.5) * 20;
                  ctx.fillStyle = adjustColor(el.color, variation);
                  ctx.fillRect(tx + 0.5, ty + 0.5, mosaicSize - 1, mosaicSize - 1);

                  // Slight 3D effect
                  ctx.fillStyle = 'rgba(255,255,255,0.1)';
                  ctx.fillRect(tx + 0.5, ty + 0.5, mosaicSize - 1, 1);
                }
              }
              break;

            case 'herringbone':
              // Herringbone pattern
              const hbW = Math.max(8, w / 12);
              const hbH = hbW * 3;
              ctx.save();
              ctx.beginPath();
              ctx.rect(x, y, w, h);
              ctx.clip();

              for (let row = -2; row < h / (hbH/2) + 2; row++) {
                for (let col = -2; col < w / hbW + 2; col++) {
                  const isEven = (row + col) % 2 === 0;
                  const tx = x + col * hbW;
                  const ty = y + row * (hbH / 2);

                  ctx.save();
                  ctx.translate(tx + hbW/2, ty + hbH/4);
                  ctx.rotate(isEven ? Math.PI/4 : -Math.PI/4);

                  const variation = (bsRand(row * 5 + col * 11) - 0.5) * 15;
                  ctx.fillStyle = adjustColor(el.color, variation);
                  ctx.fillRect(-hbW/2 + 1, -hbH/4 + 1, hbW - 2, hbH/2 - 2);

                  ctx.restore();
                }
              }
              ctx.restore();
              break;

            case 'hexagon':
              // Hexagon tiles
              const hexR = Math.max(10, Math.min(w, h) / 6);
              const hexH = hexR * Math.sqrt(3);
              let hexRow = 0;

              for (let ty = y - hexH; ty < y + h + hexH; ty += hexH * 0.75) {
                const offset = (hexRow % 2) * (hexR * 1.5);
                for (let tx = x - hexR + offset; tx < x + w + hexR * 2; tx += hexR * 3) {
                  const variation = (bsRand(hexRow * 7 + tx) - 0.5) * 15;
                  ctx.fillStyle = adjustColor(el.color, variation);
                  ctx.beginPath();
                  for (let i = 0; i < 6; i++) {
                    const angle = (Math.PI / 3) * i - Math.PI / 6;
                    const hx = tx + hexR * Math.cos(angle);
                    const hy = ty + hexR * Math.sin(angle);
                    if (i === 0) ctx.moveTo(hx, hy);
                    else ctx.lineTo(hx, hy);
                  }
                  ctx.closePath();
                  ctx.fill();
                  ctx.strokeStyle = 'rgba(100,100,100,0.3)';
                  ctx.lineWidth = 1;
                  ctx.stroke();
                }
                hexRow++;
              }
              break;

            case 'slab':
              // Full slab (like matching countertop)
              drawCountertopSurface(ctx, x, y, w, h, el.color, el.materialName);
              break;

            default:
              // Default grid tiles
              const defTileSize = Math.max(15, Math.min(w, h) / 4);
              for (let ty = y; ty < y + h; ty += defTileSize) {
                for (let tx = x; tx < x + w; tx += defTileSize) {
                  const variation = (bsRand(tx + ty * 3) - 0.5) * 12;
                  ctx.fillStyle = adjustColor(el.color, variation);
                  ctx.fillRect(tx + 1, ty + 1, defTileSize - 2, defTileSize - 2);

                  ctx.fillStyle = 'rgba(255,255,255,0.1)';
                  ctx.fillRect(tx + 1, ty + 1, defTileSize - 2, 2);
                  ctx.fillRect(tx + 1, ty + 1, 2, defTileSize - 2);
                }
              }
          }
          break;

        case 'sink':
        case 'sink-double':
        case 'sink-farmhouse': {
          const isDouble = el.type === 'sink-double';
          const isFarmhouse = el.type === 'sink-farmhouse';
          const basinPadding = Math.min(w, h) * 0.12;

          // Outer rim
          ctx.strokeStyle = isFarmhouse ? 'rgba(200,180,140,0.8)' : 'rgba(180,180,180,0.8)';
          ctx.lineWidth = isFarmhouse ? 4 : 2;
          ctx.strokeRect(x + basinPadding/2, y + basinPadding/2, w - basinPadding, h - basinPadding);

          if (isDouble) {
            // Double basin
            const basinW = (w - basinPadding * 2 - 6) / 2;
            // Left basin
            ctx.fillStyle = 'rgba(60,60,60,0.4)';
            ctx.fillRect(x + basinPadding, y + basinPadding, basinW, h - basinPadding * 2);
            // Right basin
            ctx.fillRect(x + basinPadding + basinW + 6, y + basinPadding, basinW, h - basinPadding * 2);
            // Divider
            ctx.fillStyle = 'rgba(180,180,180,0.6)';
            ctx.fillRect(x + w/2 - 3, y + basinPadding, 6, h - basinPadding * 2);
            // Drains
            ctx.fillStyle = 'rgba(50,50,50,0.7)';
            ctx.beginPath();
            ctx.arc(x + basinPadding + basinW/2, y + h/2, Math.min(w, h) * 0.05, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x + w - basinPadding - basinW/2, y + h/2, Math.min(w, h) * 0.05, 0, Math.PI * 2);
            ctx.fill();
          } else {
            // Single basin
            ctx.fillStyle = isFarmhouse ? 'rgba(245,245,220,0.5)' : 'rgba(60,60,60,0.4)';
            ctx.fillRect(x + basinPadding, y + basinPadding, w - basinPadding * 2, h - basinPadding * 2);
            // Inner basin shadow
            ctx.fillStyle = isFarmhouse ? 'rgba(200,180,140,0.3)' : 'rgba(40,40,40,0.3)';
            ctx.fillRect(x + basinPadding + 4, y + basinPadding + 4, w - basinPadding * 2 - 8, h - basinPadding * 2 - 8);
            // Drain
            ctx.fillStyle = 'rgba(50,50,50,0.7)';
            ctx.beginPath();
            ctx.arc(x + w/2, y + h/2 + 5, Math.min(w, h) * 0.06, 0, Math.PI * 2);
            ctx.fill();
          }

          // Faucet (centered at back)
          ctx.fillStyle = 'rgba(200,200,200,0.9)';
          ctx.fillRect(x + w/2 - 8, y + basinPadding/2 - 6, 16, 8);
          // Faucet spout
          ctx.beginPath();
          ctx.arc(x + w/2, y + basinPadding/2 - 6, 8, Math.PI, 0);
          ctx.fill();
          // Handles
          ctx.fillStyle = 'rgba(180,180,180,0.8)';
          ctx.beginPath();
          ctx.arc(x + w/2 - 20, y + basinPadding/2, 5, 0, Math.PI * 2);
          ctx.fill();
          ctx.beginPath();
          ctx.arc(x + w/2 + 20, y + basinPadding/2, 5, 0, Math.PI * 2);
          ctx.fill();
          break;
        }

        case 'stove':
          // Draw stove burners
          ctx.strokeStyle = 'rgba(50,50,50,0.8)';
          ctx.lineWidth = 2;
          const burnerRadius = Math.min(w, h) * 0.15;
          const positions = [
            [x + w * 0.3, y + h * 0.35],
            [x + w * 0.7, y + h * 0.35],
            [x + w * 0.3, y + h * 0.7],
            [x + w * 0.7, y + h * 0.7]
          ];
          positions.forEach(([bx, by]) => {
            // Outer ring
            ctx.beginPath();
            ctx.arc(bx, by, burnerRadius, 0, Math.PI * 2);
            ctx.stroke();
            // Inner ring
            ctx.beginPath();
            ctx.arc(bx, by, burnerRadius * 0.6, 0, Math.PI * 2);
            ctx.stroke();
            // Grate lines
            ctx.beginPath();
            ctx.moveTo(bx - burnerRadius, by);
            ctx.lineTo(bx + burnerRadius, by);
            ctx.moveTo(bx, by - burnerRadius);
            ctx.lineTo(bx, by + burnerRadius);
            ctx.stroke();
          });
          // Control panel area
          ctx.fillStyle = 'rgba(40,40,40,0.5)';
          ctx.fillRect(x + padding, y + padding, w - padding * 2, h * 0.12);
          break;

        case 'refrigerator':
          // Draw refrigerator doors
          ctx.strokeStyle = 'rgba(150,150,150,0.5)';
          ctx.lineWidth = 2;
          const fridgeMid = y + h * 0.65;
          // Upper section (freezer)
          ctx.strokeRect(x + padding, y + padding, w - padding * 2, fridgeMid - y - padding * 1.5);
          // Lower section (fridge)
          ctx.strokeRect(x + padding, fridgeMid, w - padding * 2, y + h - fridgeMid - padding);
          // Handles
          ctx.fillStyle = 'rgba(200,200,200,0.6)';
          ctx.fillRect(x + w - padding - 6, y + (fridgeMid - y) / 2 - 12, 3, 24);
          ctx.fillRect(x + w - padding - 6, fridgeMid + (y + h - fridgeMid) / 2 - 15, 3, 30);
          // Ice dispenser
          ctx.fillStyle = 'rgba(60,60,60,0.4)';
          ctx.fillRect(x + w * 0.3, y + padding + 10, w * 0.4, 15);
          break;

        case 'dishwasher':
          // Draw dishwasher front
          ctx.strokeStyle = 'rgba(120,120,120,0.5)';
          ctx.lineWidth = 1.5;
          // Main door
          ctx.strokeRect(x + padding, y + padding, w - padding * 2, h - padding * 2);
          // Control panel
          ctx.fillStyle = 'rgba(60,60,60,0.4)';
          ctx.fillRect(x + padding + 4, y + padding + 4, w - padding * 2 - 8, h * 0.12);
          // Handle
          ctx.fillStyle = 'rgba(180,180,180,0.6)';
          ctx.fillRect(x + padding + 8, y + h * 0.18, w - padding * 2 - 16, 4);
          break;

        case 'flooring': {
          // Draw realistic wood plank flooring with grain direction support
          const grainDir = el.grainDirection || 0;
          const floorSeed = (el.x * 11 + el.y * 13) % 50;

          // Save context for rotation if needed
          ctx.save();

          // For diagonal directions, we'll use rotation
          if (grainDir === 45 || grainDir === 135) {
            // Clip to element bounds
            ctx.beginPath();
            ctx.rect(x, y, w, h);
            ctx.clip();

            // Rotate around center
            const cx = x + w / 2;
            const cy = y + h / 2;
            ctx.translate(cx, cy);
            ctx.rotate(grainDir * Math.PI / 180);
            ctx.translate(-cx, -cy);

            // Expand drawing area to cover after rotation
            const diagonal = Math.sqrt(w * w + h * h);
            const expandedX = cx - diagonal / 2;
            const expandedY = cy - diagonal / 2;
            const expandedW = diagonal;
            const expandedH = diagonal;

            drawPlanks(expandedX, expandedY, expandedW, expandedH, 0);
          } else if (grainDir === 90) {
            // Vertical planks - swap dimensions conceptually
            drawPlanks(x, y, w, h, 90);
          } else {
            // Horizontal planks (default)
            drawPlanks(x, y, w, h, 0);
          }

          ctx.restore();

          // Helper function to draw planks
          function drawPlanks(px, py, pw, ph, dir) {
            const plankLong = pixelsPerFoot * 2;
            const plankShort = pixelsPerFoot * 0.35;

            let rowNum = 0;
            if (dir === 90) {
              // Vertical planks
              for (let colX = px; colX < px + pw; colX += plankShort) {
                const colOffset = (rowNum % 3) * (plankLong / 3);
                let plankNum = 0;

                for (let rowY = py - colOffset; rowY < py + ph; rowY += plankLong) {
                  if (rowY + plankLong < py) continue;
                  if (rowY > py + ph) break;

                  const drawX = Math.max(colX, px);
                  const drawW = Math.min(colX + plankShort, px + pw) - drawX;
                  const drawY = Math.max(rowY, py);
                  const drawH = Math.min(rowY + plankLong, py + ph) - drawY;

                  if (drawW > 0 && drawH > 0) {
                    drawSinglePlank(drawX, drawY, drawW, drawH, rowNum, plankNum, true);
                  }
                  plankNum++;
                }
                rowNum++;
              }
            } else {
              // Horizontal planks
              for (let rowY = py; rowY < py + ph; rowY += plankShort) {
                const rowOffset = (rowNum % 3) * (plankLong / 3);
                let plankNum = 0;

                for (let colX = px - rowOffset; colX < px + pw; colX += plankLong) {
                  if (colX + plankLong < px) continue;
                  if (colX > px + pw) break;

                  const drawX = Math.max(colX, px);
                  const drawW = Math.min(colX + plankLong, px + pw) - drawX;
                  const drawY = Math.max(rowY, py);
                  const drawH = Math.min(rowY + plankShort, py + ph) - drawY;

                  if (drawW > 0 && drawH > 0) {
                    drawSinglePlank(drawX, drawY, drawW, drawH, rowNum, plankNum, false);
                  }
                  plankNum++;
                }
                rowNum++;
              }
            }
          }

          function drawSinglePlank(drawX, drawY, drawW, drawH, rowNum, plankNum, vertical) {
            // Plank base with slight color variation
            const variation = ((floorSeed + rowNum * 7 + plankNum * 3) % 20 - 10) / 100;
            ctx.fillStyle = `rgba(${variation > 0 ? 255 : 0},${variation > 0 ? 255 : 0},${variation > 0 ? 255 : 0},${Math.abs(variation)})`;
            ctx.fillRect(drawX, drawY, drawW, drawH);

            // Plank border (groove between planks)
            ctx.strokeStyle = 'rgba(0,0,0,0.2)';
            ctx.lineWidth = 1;
            ctx.strokeRect(drawX + 0.5, drawY + 0.5, drawW - 1, drawH - 1);

            // Wood grain lines
            ctx.strokeStyle = 'rgba(0,0,0,0.06)';
            ctx.lineWidth = 0.5;

            if (vertical) {
              // Vertical grain
              const grainCount = Math.floor(drawW / 4);
              for (let g = 0; g < grainCount; g++) {
                const gx = drawX + 2 + g * (drawW - 4) / Math.max(1, grainCount);
                const wave = Math.sin((floorSeed + plankNum + g) * 0.5) * 2;
                ctx.beginPath();
                ctx.moveTo(gx, drawY + 2);
                ctx.bezierCurveTo(
                  gx + wave, drawY + drawH * 0.3,
                  gx - wave, drawY + drawH * 0.7,
                  gx + wave * 0.5, drawY + drawH - 2
                );
                ctx.stroke();
              }
            } else {
              // Horizontal grain
              const grainCount = Math.floor(drawH / 4);
              for (let g = 0; g < grainCount; g++) {
                const gy = drawY + 2 + g * (drawH - 4) / Math.max(1, grainCount);
                const wave = Math.sin((floorSeed + plankNum + g) * 0.5) * 2;
                ctx.beginPath();
                ctx.moveTo(drawX + 2, gy);
                ctx.bezierCurveTo(
                  drawX + drawW * 0.3, gy + wave,
                  drawX + drawW * 0.7, gy - wave,
                  drawX + drawW - 2, gy + wave * 0.5
                );
                ctx.stroke();
              }
            }

            // Subtle knot marks occasionally
            if ((floorSeed + rowNum + plankNum) % 7 === 0) {
              ctx.fillStyle = 'rgba(0,0,0,0.08)';
              ctx.beginPath();
              ctx.ellipse(
                drawX + Math.abs(drawW) * 0.6,
                drawY + Math.abs(drawH) * 0.5,
                vertical ? 5 : 3, vertical ? 3 : 5, vertical ? 0.8 : 0.3, 0, Math.PI * 2
              );
              ctx.fill();
            }
          }
          break;
        }

        case 'tile': {
          // Draw realistic tile pattern with grout lines and variation
          // Supports diagonal orientation (45Â° or 135Â°)
          const tileGrainDir = el.grainDirection || 0;
          const tileSz = Math.min(pixelsPerFoot * 0.5, Math.min(w, h) / 3);
          const groutWidth = 2;
          const tileSeed = (el.x * 17 + el.y * 23) % 100;

          ctx.save();

          // Clip to element bounds
          ctx.beginPath();
          ctx.rect(x, y, w, h);
          ctx.clip();

          // For diagonal tiles, rotate the pattern
          if (tileGrainDir === 45 || tileGrainDir === 135) {
            const cx = x + w / 2;
            const cy = y + h / 2;
            ctx.translate(cx, cy);
            ctx.rotate(tileGrainDir * Math.PI / 180);
            ctx.translate(-cx, -cy);

            // Expand drawing area to cover after rotation
            const diagonal = Math.sqrt(w * w + h * h);
            const expandX = cx - diagonal / 2;
            const expandY = cy - diagonal / 2;
            drawTileGrid(expandX, expandY, diagonal, diagonal);
          } else {
            drawTileGrid(x, y, w, h);
          }

          ctx.restore();

          function drawTileGrid(startX, startY, gridW, gridH) {
            // Draw tiles
            let tileRow = 0;
            for (let ty = startY; ty < startY + gridH; ty += tileSz) {
              let tileCol = 0;
              for (let tx = startX; tx < startX + gridW; tx += tileSz) {
                const tileW = tileSz - groutWidth;
                const tileH = tileSz - groutWidth;

                if (tileW > 0 && tileH > 0) {
                  // Subtle color variation per tile
                  const variation = ((tileSeed + tileRow * 5 + tileCol * 3) % 15) / 100;
                  ctx.fillStyle = `rgba(255,255,255,${0.02 + variation * 0.03})`;
                  ctx.fillRect(tx + 1, ty + 1, tileW, tileH);

                  // Tile surface texture (subtle speckling)
                  ctx.fillStyle = 'rgba(255,255,255,0.03)';
                  for (let s = 0; s < 3; s++) {
                    const sx = tx + 5 + ((tileSeed + tileCol + s * 7) % Math.max(1, tileW - 10));
                    const sy = ty + 5 + ((tileSeed + tileRow + s * 11) % Math.max(1, tileH - 10));
                    ctx.beginPath();
                    ctx.arc(sx, sy, 1, 0, Math.PI * 2);
                    ctx.fill();
                  }

                  // Light reflection on tile edge (top-left highlight)
                  ctx.fillStyle = 'rgba(255,255,255,0.08)';
                  ctx.fillRect(tx + 1, ty + 1, tileW, 1);
                  ctx.fillRect(tx + 1, ty + 1, 1, tileH);
                }
                tileCol++;
              }
              tileRow++;
            }

            // Grout lines (darker)
            ctx.strokeStyle = 'rgba(100,100,100,0.4)';
            ctx.lineWidth = groutWidth;
            for (let tx = startX; tx <= startX + gridW; tx += tileSz) {
              ctx.beginPath();
              ctx.moveTo(tx, startY);
              ctx.lineTo(tx, startY + gridH);
              ctx.stroke();
            }
            for (let ty = startY; ty <= startY + gridH; ty += tileSz) {
              ctx.beginPath();
              ctx.moveTo(startX, ty);
              ctx.lineTo(startX + gridW, ty);
              ctx.stroke();
            }
          }
          break;
        }

        case 'door':
          // Draw door with swing arc
          ctx.strokeStyle = 'rgba(255,255,255,0.4)';
          ctx.lineWidth = 1.5;
          // Door panel
          ctx.fillStyle = 'rgba(180,140,100,0.3)';
          ctx.fillRect(x, y, w * 0.1, h);
          // Swing arc
          ctx.beginPath();
          ctx.arc(x, y + h, w * 0.9, -Math.PI/2, 0);
          ctx.stroke();
          // Door line
          ctx.beginPath();
          ctx.moveTo(x, y + h);
          ctx.lineTo(x + w * 0.9, y + h);
          ctx.stroke();
          break;

        case 'window':
          // Draw window with transparent glass effect showing "outside"
          // Outer frame (white)
          ctx.strokeStyle = 'rgba(255,255,255,0.9)';
          ctx.lineWidth = 4;
          ctx.strokeRect(x + 2, y + 2, w - 4, h - 4);

          // Sky gradient background (simulated outdoor view)
          const skyGradient = ctx.createLinearGradient(x, y, x, y + h);
          skyGradient.addColorStop(0, 'rgba(135,206,250,0.7)'); // Light sky blue
          skyGradient.addColorStop(0.6, 'rgba(176,224,230,0.6)'); // Powder blue
          skyGradient.addColorStop(1, 'rgba(144,238,144,0.5)'); // Light green (trees/ground)
          ctx.fillStyle = skyGradient;
          ctx.fillRect(x + 6, y + 6, w - 12, h - 12);

          // Glass reflection effect (diagonal shine)
          ctx.strokeStyle = 'rgba(255,255,255,0.3)';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(x + w * 0.2, y + 4);
          ctx.lineTo(x + 4, y + h * 0.3);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(x + w * 0.35, y + 4);
          ctx.lineTo(x + 4, y + h * 0.5);
          ctx.stroke();

          // Center divider (mullion)
          ctx.strokeStyle = 'rgba(255,255,255,0.8)';
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.moveTo(x + w/2, y + 4);
          ctx.lineTo(x + w/2, y + h - 4);
          ctx.stroke();

          // Horizontal divider for classic look
          ctx.beginPath();
          ctx.moveTo(x + 4, y + h/2);
          ctx.lineTo(x + w - 4, y + h/2);
          ctx.stroke();
          break;

        case 'wall':
        case 'wall-wood-2x4':
        case 'wall-wood-2x6':
          // Wall section with hatch pattern
          ctx.strokeStyle = 'rgba(255,255,255,0.2)';
          ctx.lineWidth = 1;
          const step = 8;
          for (let i = 0; i < Math.max(w, h) * 2; i += step) {
            ctx.beginPath();
            ctx.moveTo(x + i, y);
            ctx.lineTo(x, y + i);
            ctx.stroke();
          }
          // Wood grain for wood walls
          if (type.includes('wood')) {
            ctx.strokeStyle = 'rgba(139,69,19,0.3)';
            ctx.lineWidth = 0.5;
            for (let g = 0; g < 3; g++) {
              ctx.beginPath();
              ctx.moveTo(x + g * w/3, y);
              ctx.lineTo(x + g * w/3, y + h);
              ctx.stroke();
            }
          }
          break;

        case 'wall-steel':
        case 'wall-aluminum':
          // Metal stud pattern
          ctx.strokeStyle = type.includes('steel') ? 'rgba(112,128,144,0.6)' : 'rgba(192,192,192,0.6)';
          ctx.lineWidth = 2;
          const studSpacing = pixelsPerFoot * 1.33; // 16" on center
          for (let sx = x; sx <= x + w; sx += studSpacing) {
            ctx.beginPath();
            ctx.moveTo(sx, y);
            ctx.lineTo(sx, y + h);
            ctx.stroke();
          }
          // Track at top and bottom
          ctx.fillStyle = type.includes('steel') ? 'rgba(112,128,144,0.4)' : 'rgba(192,192,192,0.4)';
          ctx.fillRect(x, y, w, 4);
          ctx.fillRect(x, y + h - 4, w, 4);
          break;

        case 'wall-concrete':
          // Concrete texture
          ctx.fillStyle = 'rgba(128,128,128,0.3)';
          ctx.fillRect(x, y, w, h);
          // Aggregate speckles
          ctx.fillStyle = 'rgba(100,100,100,0.4)';
          for (let i = 0; i < 10; i++) {
            const cx = x + (Math.random() * w);
            const cy = y + (Math.random() * h);
            ctx.beginPath();
            ctx.arc(cx, cy, Math.random() * 3 + 1, 0, Math.PI * 2);
            ctx.fill();
          }
          break;

        case 'wall-brick':
          // Brick pattern
          const brickH = pixelsPerFoot * 0.25;
          const brickW = pixelsPerFoot * 0.67;
          ctx.strokeStyle = 'rgba(139,69,19,0.5)';
          ctx.lineWidth = 1;
          let brickRow = 0;
          for (let by = y; by < y + h; by += brickH) {
            const offset = (brickRow % 2) * (brickW / 2);
            for (let bx = x - offset; bx < x + w; bx += brickW) {
              if (bx + brickW > x && bx < x + w) {
                ctx.strokeRect(Math.max(bx, x), by, Math.min(brickW, x + w - bx), brickH);
              }
            }
            brickRow++;
          }
          break;

        case 'wall-block':
          // CMU block pattern
          const blockH = pixelsPerFoot * 0.67;
          const blockW = pixelsPerFoot * 1.33;
          ctx.strokeStyle = 'rgba(80,80,80,0.5)';
          ctx.lineWidth = 2;
          let blockRow = 0;
          for (let by = y; by < y + h; by += blockH) {
            const offset = (blockRow % 2) * (blockW / 2);
            for (let bx = x - offset; bx < x + w; bx += blockW) {
              if (bx + blockW > x && bx < x + w) {
                ctx.strokeRect(Math.max(bx, x), by, Math.min(blockW, x + w - bx), blockH);
              }
            }
            blockRow++;
          }
          break;

        case 'steel-beam':
          // Steel I-Beam cross-section (horizontal beam)
          ctx.fillStyle = el.color || '#4A4A4A';
          ctx.fillRect(x, y, w, h);
          // Flange highlights
          ctx.fillStyle = 'rgba(255,255,255,0.15)';
          ctx.fillRect(x, y, w, h * 0.2);
          ctx.fillRect(x, y + h * 0.8, w, h * 0.2);
          // Web line
          ctx.strokeStyle = 'rgba(0,0,0,0.3)';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(x, y + h/2);
          ctx.lineTo(x + w, y + h/2);
          ctx.stroke();
          break;

        case 'steel-column':
          // Steel column (square HSS)
          ctx.fillStyle = el.color || '#4A4A4A';
          ctx.fillRect(x, y, w, h);
          // Highlight edges
          ctx.fillStyle = 'rgba(255,255,255,0.2)';
          ctx.fillRect(x, y, w * 0.2, h);
          ctx.fillStyle = 'rgba(0,0,0,0.2)';
          ctx.fillRect(x + w * 0.8, y, w * 0.2, h);
          // Center (hollow indicator)
          ctx.fillStyle = 'rgba(0,0,0,0.3)';
          ctx.fillRect(x + w * 0.25, y + h * 0.25, w * 0.5, h * 0.5);
          break;

        case 'wood-beam':
          // Wood beam (solid timber)
          ctx.fillStyle = el.color || '#8B6914';
          ctx.fillRect(x, y, w, h);
          // Wood grain lines
          ctx.strokeStyle = 'rgba(0,0,0,0.2)';
          ctx.lineWidth = 1;
          for (let gx = x + w * 0.2; gx < x + w; gx += w * 0.25) {
            ctx.beginPath();
            ctx.moveTo(gx, y);
            ctx.lineTo(gx, y + h);
            ctx.stroke();
          }
          // Highlight
          ctx.fillStyle = 'rgba(255,255,255,0.1)';
          ctx.fillRect(x, y, w, h * 0.15);
          break;

        case 'wood-post':
          // Wood post (4x4 or 6x6)
          ctx.fillStyle = el.color || '#8B6914';
          ctx.fillRect(x, y, w, h);
          // Wood grain
          ctx.strokeStyle = 'rgba(0,0,0,0.15)';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(x + w * 0.3, y);
          ctx.lineTo(x + w * 0.3, y + h);
          ctx.moveTo(x + w * 0.5, y);
          ctx.lineTo(x + w * 0.5, y + h);
          ctx.moveTo(x + w * 0.7, y);
          ctx.lineTo(x + w * 0.7, y + h);
          ctx.stroke();
          break;

        case 'concrete-beam':
          // Concrete beam
          ctx.fillStyle = el.color || '#707070';
          ctx.fillRect(x, y, w, h);
          // Aggregate texture
          ctx.fillStyle = 'rgba(0,0,0,0.15)';
          for (let i = 0; i < 8; i++) {
            const cx = x + Math.random() * w;
            const cy = y + Math.random() * h;
            ctx.beginPath();
            ctx.arc(cx, cy, 2 + Math.random() * 3, 0, Math.PI * 2);
            ctx.fill();
          }
          // Form line
          ctx.strokeStyle = 'rgba(0,0,0,0.2)';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(x, y + h/2);
          ctx.lineTo(x + w, y + h/2);
          ctx.stroke();
          break;

        case 'concrete-column':
          // Concrete column
          ctx.fillStyle = el.color || '#707070';
          ctx.fillRect(x, y, w, h);
          // Aggregate spots
          ctx.fillStyle = 'rgba(0,0,0,0.12)';
          for (let i = 0; i < 6; i++) {
            const cx = x + w * 0.15 + Math.random() * w * 0.7;
            const cy = y + h * 0.15 + Math.random() * h * 0.7;
            ctx.beginPath();
            ctx.arc(cx, cy, 2 + Math.random() * 2, 0, Math.PI * 2);
            ctx.fill();
          }
          // Chamfer indicators at corners
          ctx.strokeStyle = 'rgba(0,0,0,0.3)';
          ctx.lineWidth = 2;
          const chamfer = Math.min(w, h) * 0.1;
          ctx.beginPath();
          ctx.moveTo(x, y + chamfer);
          ctx.lineTo(x + chamfer, y);
          ctx.moveTo(x + w - chamfer, y);
          ctx.lineTo(x + w, y + chamfer);
          ctx.moveTo(x + w, y + h - chamfer);
          ctx.lineTo(x + w - chamfer, y + h);
          ctx.moveTo(x + chamfer, y + h);
          ctx.lineTo(x, y + h - chamfer);
          ctx.stroke();
          break;

        case 'header':
          // Header/Lintel
          ctx.fillStyle = el.color || '#CD853F';
          ctx.fillRect(x, y, w, h);
          // Wood grain
          ctx.strokeStyle = 'rgba(0,0,0,0.2)';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(x, y + h/2);
          ctx.lineTo(x + w, y + h/2);
          ctx.stroke();
          // Highlight
          ctx.fillStyle = 'rgba(255,255,255,0.15)';
          ctx.fillRect(x, y, w, h * 0.2);
          break;

        case 'lvl-beam':
          // LVL (Laminated Veneer Lumber) beam
          ctx.fillStyle = el.color || '#DEB887';
          ctx.fillRect(x, y, w, h);
          // Lamination lines
          ctx.strokeStyle = 'rgba(139,105,20,0.3)';
          ctx.lineWidth = 1;
          const lamSpacing = Math.max(4, h / 8);
          for (let ly = y + lamSpacing; ly < y + h; ly += lamSpacing) {
            ctx.beginPath();
            ctx.moveTo(x, ly);
            ctx.lineTo(x + w, ly);
            ctx.stroke();
          }
          break;

        case 'double-door':
          // Double door with two panels
          ctx.strokeStyle = 'rgba(255,255,255,0.4)';
          ctx.lineWidth = 1.5;
          ctx.fillStyle = 'rgba(180,140,100,0.3)';
          // Left door
          ctx.fillRect(x, y, w * 0.05, h);
          ctx.beginPath();
          ctx.arc(x, y + h, w * 0.45, -Math.PI/2, 0);
          ctx.stroke();
          // Right door
          ctx.fillRect(x + w * 0.95, y, w * 0.05, h);
          ctx.beginPath();
          ctx.arc(x + w, y + h, w * 0.45, Math.PI, -Math.PI/2);
          ctx.stroke();
          break;

        case 'sliding-door':
          // Sliding glass door with outdoor view
          // Outdoor background (green/blue gradient)
          const slidingGrad = ctx.createLinearGradient(x, y, x, y + h);
          slidingGrad.addColorStop(0, 'rgba(135,206,235,0.4)'); // Sky blue
          slidingGrad.addColorStop(0.6, 'rgba(135,206,235,0.3)');
          slidingGrad.addColorStop(0.6, 'rgba(144,238,144,0.3)'); // Light green
          slidingGrad.addColorStop(1, 'rgba(34,139,34,0.3)'); // Forest green
          ctx.fillStyle = slidingGrad;
          ctx.fillRect(x, y, w, h);
          ctx.strokeStyle = 'rgba(100,100,100,0.6)';
          ctx.lineWidth = 2;
          ctx.strokeRect(x, y, w, h);
          // Sliding panels
          ctx.strokeStyle = 'rgba(80,80,80,0.5)';
          ctx.beginPath();
          ctx.moveTo(x + w/2, y);
          ctx.lineTo(x + w/2, y + h);
          ctx.stroke();
          // Arrow indicating slide direction
          ctx.fillStyle = 'rgba(255,255,255,0.6)';
          ctx.beginPath();
          ctx.moveTo(x + w * 0.35, y + h/2);
          ctx.lineTo(x + w * 0.25, y + h/2 - 5);
          ctx.lineTo(x + w * 0.25, y + h/2 + 5);
          ctx.fill();
          break;

        case 'glass-door':
          // Single glass door with outdoor view
          const glassDoorGrad = ctx.createLinearGradient(x, y, x, y + h);
          glassDoorGrad.addColorStop(0, 'rgba(135,206,235,0.35)');
          glassDoorGrad.addColorStop(0.65, 'rgba(135,206,235,0.25)');
          glassDoorGrad.addColorStop(0.65, 'rgba(144,238,144,0.25)');
          glassDoorGrad.addColorStop(1, 'rgba(34,139,34,0.25)');
          ctx.fillStyle = glassDoorGrad;
          ctx.fillRect(x, y, w, h);
          // Frame
          ctx.strokeStyle = 'rgba(255,255,255,0.9)';
          ctx.lineWidth = 3;
          ctx.strokeRect(x, y, w, h);
          // Handle
          ctx.fillStyle = 'rgba(200,200,200,0.8)';
          ctx.fillRect(x + w - 10, y + h/2 - 15, 5, 30);
          break;

        case 'french-door':
          // French door with grid and outdoor view
          const frenchDoorGrad = ctx.createLinearGradient(x, y, x, y + h);
          frenchDoorGrad.addColorStop(0, 'rgba(135,206,235,0.35)');
          frenchDoorGrad.addColorStop(0.6, 'rgba(135,206,235,0.25)');
          frenchDoorGrad.addColorStop(0.6, 'rgba(144,238,144,0.25)');
          frenchDoorGrad.addColorStop(1, 'rgba(34,139,34,0.3)');
          ctx.fillStyle = frenchDoorGrad;
          ctx.fillRect(x, y, w, h);
          // Frame
          ctx.strokeStyle = 'rgba(245,245,220,0.9)';
          ctx.lineWidth = 4;
          ctx.strokeRect(x, y, w, h);
          // Center divider
          ctx.beginPath();
          ctx.moveTo(x + w/2, y);
          ctx.lineTo(x + w/2, y + h);
          ctx.stroke();
          // Grid lines
          ctx.lineWidth = 1.5;
          for (let gy = 1; gy < 4; gy++) {
            ctx.beginPath();
            ctx.moveTo(x, y + gy * h/4);
            ctx.lineTo(x + w, y + gy * h/4);
            ctx.stroke();
          }
          break;

        case 'window-large':
          // Large picture window
          const pictureWinGrad = ctx.createLinearGradient(x, y, x, y + h);
          pictureWinGrad.addColorStop(0, 'rgba(135,206,250,0.5)');
          pictureWinGrad.addColorStop(0.55, 'rgba(135,206,250,0.4)');
          pictureWinGrad.addColorStop(0.55, 'rgba(144,238,144,0.35)');
          pictureWinGrad.addColorStop(1, 'rgba(34,139,34,0.4)');
          ctx.fillStyle = pictureWinGrad;
          ctx.fillRect(x, y, w, h);
          // White frame
          ctx.strokeStyle = 'rgba(255,255,255,0.95)';
          ctx.lineWidth = 4;
          ctx.strokeRect(x, y, w, h);
          break;

        case 'window-bay':
          // Bay window (angled trapezoid shape)
          const bayDepth = h * 0.3;
          const bayGrad = ctx.createLinearGradient(x, y, x, y + h);
          bayGrad.addColorStop(0, 'rgba(135,206,250,0.45)');
          bayGrad.addColorStop(0.5, 'rgba(135,206,250,0.35)');
          bayGrad.addColorStop(0.5, 'rgba(144,238,144,0.3)');
          bayGrad.addColorStop(1, 'rgba(34,139,34,0.35)');
          ctx.fillStyle = bayGrad;
          // Draw trapezoid shape
          ctx.beginPath();
          ctx.moveTo(x + bayDepth, y);
          ctx.lineTo(x + w - bayDepth, y);
          ctx.lineTo(x + w, y + h);
          ctx.lineTo(x, y + h);
          ctx.closePath();
          ctx.fill();
          // Frame
          ctx.strokeStyle = 'rgba(255,255,255,0.9)';
          ctx.lineWidth = 3;
          ctx.stroke();
          // Interior lines for panes
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(x + w * 0.33, y + h * 0.1);
          ctx.lineTo(x + w * 0.25, y + h);
          ctx.moveTo(x + w * 0.67, y + h * 0.1);
          ctx.lineTo(x + w * 0.75, y + h);
          ctx.stroke();
          break;

        case 'entry-archway':
          // Archway opening - shows as a transparent passthrough
          // Supports multiple arch styles: round, pointed, flat, elliptical
          const archFrameWidth = Math.max(4, w * 0.08);
          const archStyle2D = el.archwayStyle || 'round';

          // Calculate arch-specific proportions
          let archTopY, archCurveHeight;
          if (archStyle2D === 'flat') {
            archTopY = y + archFrameWidth * 2;
            archCurveHeight = 0;
          } else if (archStyle2D === 'pointed') {
            archTopY = y;
            archCurveHeight = h * 0.4;
          } else if (archStyle2D === 'elliptical') {
            archTopY = y + h * 0.15;
            archCurveHeight = h * 0.2;
          } else { // round
            archTopY = y + h * 0.3;
            archCurveHeight = h * 0.3;
          }

          // Draw "through" view - darker to simulate depth/another room
          ctx.fillStyle = 'rgba(60,60,70,0.4)';
          ctx.beginPath();
          ctx.moveTo(x + archFrameWidth, y + h);
          if (archStyle2D === 'flat') {
            ctx.lineTo(x + archFrameWidth, archTopY);
            ctx.lineTo(x + w - archFrameWidth, archTopY);
          } else if (archStyle2D === 'pointed') {
            ctx.lineTo(x + archFrameWidth, y + h * 0.35);
            ctx.lineTo(x + w/2, archTopY + archFrameWidth);
            ctx.lineTo(x + w - archFrameWidth, y + h * 0.35);
          } else if (archStyle2D === 'elliptical') {
            ctx.lineTo(x + archFrameWidth, archTopY + archCurveHeight);
            ctx.quadraticCurveTo(x + w/2, archTopY, x + w - archFrameWidth, archTopY + archCurveHeight);
          } else { // round
            ctx.lineTo(x + archFrameWidth, y + h * 0.35);
            ctx.quadraticCurveTo(x + w/2, y + archFrameWidth, x + w - archFrameWidth, y + h * 0.35);
          }
          ctx.lineTo(x + w - archFrameWidth, y + h);
          ctx.closePath();
          ctx.fill();

          // Inner shadow for depth
          ctx.fillStyle = 'rgba(40,40,50,0.3)';
          ctx.beginPath();
          ctx.moveTo(x + archFrameWidth, y + h);
          if (archStyle2D === 'flat') {
            ctx.lineTo(x + archFrameWidth, archTopY);
            ctx.lineTo(x + archFrameWidth + 8, archTopY + 3);
          } else if (archStyle2D === 'pointed') {
            ctx.lineTo(x + archFrameWidth, y + h * 0.35);
            ctx.lineTo(x + archFrameWidth + 8, y + h * 0.38);
          } else {
            ctx.lineTo(x + archFrameWidth, y + h * 0.35);
            ctx.lineTo(x + archFrameWidth + 8, y + h * 0.38);
          }
          ctx.lineTo(x + archFrameWidth + 8, y + h);
          ctx.closePath();
          ctx.fill();

          // Arch frame (outer edge - golden/wood color)
          ctx.strokeStyle = 'rgba(218,165,32,0.9)';
          ctx.lineWidth = archFrameWidth;
          ctx.beginPath();
          ctx.moveTo(x + archFrameWidth/2, y + h);
          if (archStyle2D === 'flat') {
            ctx.lineTo(x + archFrameWidth/2, archTopY - archFrameWidth/2);
            ctx.lineTo(x + w - archFrameWidth/2, archTopY - archFrameWidth/2);
          } else if (archStyle2D === 'pointed') {
            ctx.lineTo(x + archFrameWidth/2, y + h * 0.3);
            ctx.lineTo(x + w/2, y);
            ctx.lineTo(x + w - archFrameWidth/2, y + h * 0.3);
          } else if (archStyle2D === 'elliptical') {
            const ellipseY = archTopY + archCurveHeight * 0.5;
            ctx.lineTo(x + archFrameWidth/2, ellipseY);
            ctx.quadraticCurveTo(x + w/2, y - archFrameWidth, x + w - archFrameWidth/2, ellipseY);
          } else { // round
            ctx.lineTo(x + archFrameWidth/2, y + h * 0.3);
            ctx.quadraticCurveTo(x + w/2, y, x + w - archFrameWidth/2, y + h * 0.3);
          }
          ctx.lineTo(x + w - archFrameWidth/2, y + h);
          ctx.stroke();

          // Inner edge highlight
          ctx.strokeStyle = 'rgba(255,235,180,0.5)';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(x + archFrameWidth, y + h);
          if (archStyle2D === 'flat') {
            ctx.lineTo(x + archFrameWidth, archTopY);
            ctx.lineTo(x + w - archFrameWidth, archTopY);
          } else if (archStyle2D === 'pointed') {
            ctx.lineTo(x + archFrameWidth, y + h * 0.35);
            ctx.lineTo(x + w/2, archTopY + archFrameWidth);
            ctx.lineTo(x + w - archFrameWidth, y + h * 0.35);
          } else if (archStyle2D === 'elliptical') {
            ctx.lineTo(x + archFrameWidth, archTopY + archCurveHeight);
            ctx.quadraticCurveTo(x + w/2, archTopY, x + w - archFrameWidth, archTopY + archCurveHeight);
          } else { // round
            ctx.lineTo(x + archFrameWidth, y + h * 0.35);
            ctx.quadraticCurveTo(x + w/2, y + archFrameWidth, x + w - archFrameWidth, y + h * 0.35);
          }
          ctx.lineTo(x + w - archFrameWidth, y + h);
          ctx.stroke();
          break;

        case 'garage-door':
          // Garage door with sections
          ctx.fillStyle = 'rgba(169,169,169,0.4)';
          ctx.fillRect(x, y, w, h);
          ctx.strokeStyle = 'rgba(100,100,100,0.6)';
          ctx.lineWidth = 2;
          ctx.strokeRect(x, y, w, h);
          // Panel sections
          const panelH = h / 4;
          for (let py = y + panelH; py < y + h; py += panelH) {
            ctx.beginPath();
            ctx.moveTo(x, py);
            ctx.lineTo(x + w, py);
            ctx.stroke();
          }
          // Handle
          ctx.fillStyle = 'rgba(80,80,80,0.6)';
          ctx.fillRect(x + w/2 - 10, y + h - panelH/2 - 3, 20, 6);
          break;

        case 'corner-cabinet':
          // Draw L-shaped corner cabinet with realistic cabinet details
          const ccArmW = w * 0.48;
          const ccArmH = h * 0.48;

          // L-shape shadow
          ctx.fillStyle = 'rgba(0,0,0,0.35)';
          ctx.beginPath();
          ctx.moveTo(x + padding + 4, y + padding + 4);
          ctx.lineTo(x + padding + 4, y + h - padding + 4);
          ctx.lineTo(x + ccArmW + 4, y + h - padding + 4);
          ctx.lineTo(x + ccArmW + 4, y + ccArmH + 4);
          ctx.lineTo(x + w - padding + 4, y + ccArmH + 4);
          ctx.lineTo(x + w - padding + 4, y + padding + 4);
          ctx.closePath();
          ctx.fill();

          // L-shape cabinet body
          ctx.fillStyle = el.color;
          ctx.beginPath();
          ctx.moveTo(x + padding, y + padding);
          ctx.lineTo(x + padding, y + h - padding);
          ctx.lineTo(x + ccArmW, y + h - padding);
          ctx.lineTo(x + ccArmW, y + ccArmH);
          ctx.lineTo(x + w - padding, y + ccArmH);
          ctx.lineTo(x + w - padding, y + padding);
          ctx.closePath();
          ctx.fill();

          // Wood grain on L-shape
          ctx.save();
          ctx.beginPath();
          ctx.moveTo(x + padding, y + padding);
          ctx.lineTo(x + padding, y + h - padding);
          ctx.lineTo(x + ccArmW, y + h - padding);
          ctx.lineTo(x + ccArmW, y + ccArmH);
          ctx.lineTo(x + w - padding, y + ccArmH);
          ctx.lineTo(x + w - padding, y + padding);
          ctx.closePath();
          ctx.clip();
          drawWoodGrain(ctx, x, y, w, h, el.color, 0.5);
          ctx.restore();

          // Diagonal door panel
          ctx.fillStyle = adjustColor(el.color, -10);
          ctx.beginPath();
          ctx.moveTo(x + ccArmW + 4, y + ccArmH + 4);
          ctx.lineTo(x + ccArmW + 4, y + h - padding - 4);
          ctx.lineTo(x + w - padding - 4, y + ccArmH + 4);
          ctx.closePath();
          ctx.fill();

          // Door panel shaker inset
          ctx.strokeStyle = 'rgba(0,0,0,0.2)';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(x + ccArmW + 14, y + ccArmH + 14);
          ctx.lineTo(x + ccArmW + 14, y + h - padding - 14);
          ctx.lineTo(x + w - padding - 14, y + ccArmH + 14);
          ctx.closePath();
          ctx.stroke();

          // Edge highlights on L-shape
          ctx.fillStyle = 'rgba(255,255,255,0.12)';
          ctx.fillRect(x + padding, y + padding, w - padding * 2, 2);
          ctx.fillRect(x + padding, y + padding, 2, h - padding * 2);

          ctx.fillStyle = 'rgba(0,0,0,0.15)';
          ctx.fillRect(x + padding, y + h - padding - 2, ccArmW - padding, 2);
          ctx.fillRect(x + w - padding - 2, y + padding, 2, ccArmH);

          // Lazy Susan circle indicator (inside cabinet)
          ctx.strokeStyle = 'rgba(255,255,255,0.2)';
          ctx.lineWidth = 1;
          const lsCenter = { x: x + w * 0.5, y: y + h * 0.5 };
          const lsRadius = Math.min(w, h) * 0.18;
          ctx.beginPath();
          ctx.arc(lsCenter.x, lsCenter.y, lsRadius, 0, Math.PI * 2);
          ctx.stroke();
          ctx.beginPath();
          ctx.arc(lsCenter.x, lsCenter.y, lsRadius * 0.5, 0, Math.PI * 2);
          ctx.stroke();

          // Handle on diagonal door
          const handleAngle = Math.PI / 4;
          const handleLen = 16;
          ctx.save();
          ctx.translate(x + ccArmW + (w - ccArmW) * 0.6, y + ccArmH + (h - ccArmH) * 0.4);
          ctx.rotate(handleAngle);
          // Handle shadow
          ctx.fillStyle = 'rgba(0,0,0,0.3)';
          ctx.fillRect(-1.5 + 2, -handleLen/2 + 2, 3, handleLen);
          // Handle body
          ctx.fillStyle = 'rgba(180,180,180,0.85)';
          ctx.fillRect(-1.5, -handleLen/2, 3, handleLen);
          ctx.fillStyle = 'rgba(255,255,255,0.3)';
          ctx.fillRect(-1.5, -handleLen/2, 1, handleLen);
          ctx.restore();

          // Toe kick
          ctx.fillStyle = 'rgba(0,0,0,0.5)';
          ctx.fillRect(x + padding + 2, y + h - padding - 3, ccArmW - padding - 4, 3);
          ctx.fillRect(x + ccArmW, y + ccArmH + 2, 3, h - ccArmH - padding - 4);
          break;

        case 'microwave':
          // Draw microwave front
          ctx.strokeStyle = 'rgba(100,100,100,0.6)';
          ctx.lineWidth = 1.5;
          // Door frame
          ctx.strokeRect(x + padding, y + padding, w * 0.75 - padding, h - padding * 2);
          // Glass window
          ctx.fillStyle = 'rgba(20,20,20,0.4)';
          ctx.fillRect(x + padding + 4, y + padding + 4, w * 0.75 - padding - 8, h - padding * 2 - 8);
          // Control panel
          ctx.fillStyle = 'rgba(60,60,60,0.5)';
          ctx.fillRect(x + w * 0.78, y + padding, w * 0.2 - padding, h - padding * 2);
          // Buttons
          ctx.fillStyle = 'rgba(100,100,100,0.6)';
          for (let i = 0; i < 3; i++) {
            ctx.fillRect(x + w * 0.82, y + padding + 8 + i * 12, 8, 8);
          }
          // Handle
          ctx.fillStyle = 'rgba(180,180,180,0.6)';
          ctx.fillRect(x + w * 0.72, y + h/2 - 10, 3, 20);
          break;

        case 'range-hood':
          // Draw range hood (trapezoidal shape from above)
          ctx.strokeStyle = 'rgba(120,120,120,0.6)';
          ctx.lineWidth = 2;
          // Outer shape
          ctx.beginPath();
          ctx.moveTo(x + padding, y + h - padding);
          ctx.lineTo(x + w * 0.2, y + padding);
          ctx.lineTo(x + w * 0.8, y + padding);
          ctx.lineTo(x + w - padding, y + h - padding);
          ctx.closePath();
          ctx.stroke();
          // Filter lines
          ctx.strokeStyle = 'rgba(150,150,150,0.4)';
          ctx.lineWidth = 1;
          const filterLines = 4;
          for (let i = 1; i < filterLines; i++) {
            const yPos = y + padding + (h - padding * 2) * (i / filterLines);
            ctx.beginPath();
            ctx.moveTo(x + w * 0.25, yPos);
            ctx.lineTo(x + w * 0.75, yPos);
            ctx.stroke();
          }
          // Vent duct indicator
          ctx.fillStyle = 'rgba(80,80,80,0.4)';
          ctx.beginPath();
          ctx.arc(x + w/2, y + h * 0.3, Math.min(w, h) * 0.12, 0, Math.PI * 2);
          ctx.fill();
          break;

        case 'oven':
          // Draw wall oven
          ctx.strokeStyle = 'rgba(100,100,100,0.5)';
          ctx.lineWidth = 1.5;
          // Outer frame
          ctx.strokeRect(x + padding, y + padding, w - padding * 2, h - padding * 2);
          // Glass window
          ctx.fillStyle = 'rgba(30,30,30,0.5)';
          ctx.fillRect(x + padding + 6, y + h * 0.25, w - padding * 2 - 12, h * 0.5);
          // Window reflection
          ctx.strokeStyle = 'rgba(255,255,255,0.15)';
          ctx.beginPath();
          ctx.moveTo(x + padding + 10, y + h * 0.3);
          ctx.lineTo(x + w - padding - 20, y + h * 0.3);
          ctx.stroke();
          // Control panel
          ctx.fillStyle = 'rgba(50,50,50,0.6)';
          ctx.fillRect(x + padding + 6, y + padding + 4, w - padding * 2 - 12, h * 0.12);
          // Control knobs
          ctx.fillStyle = 'rgba(120,120,120,0.7)';
          const knobCount = 4;
          for (let i = 0; i < knobCount; i++) {
            const kx = x + padding + 15 + i * (w - padding * 2 - 30) / (knobCount - 1);
            ctx.beginPath();
            ctx.arc(kx, y + padding + 10, 4, 0, Math.PI * 2);
            ctx.fill();
          }
          // Handle
          ctx.fillStyle = 'rgba(180,180,180,0.6)';
          ctx.fillRect(x + w * 0.3, y + h * 0.78, w * 0.4, 3);
          break;

        case 'crown-molding':
          // Crown molding - ornate profile along wall
          ctx.fillStyle = el.color || '#F5F5F5';
          ctx.fillRect(x, y, w, h);
          // Ornate shadow lines
          ctx.strokeStyle = 'rgba(0,0,0,0.2)';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(x, y + h * 0.3);
          ctx.lineTo(x + w, y + h * 0.3);
          ctx.moveTo(x, y + h * 0.6);
          ctx.lineTo(x + w, y + h * 0.6);
          ctx.stroke();
          // Top highlight
          ctx.strokeStyle = 'rgba(255,255,255,0.5)';
          ctx.beginPath();
          ctx.moveTo(x, y + 2);
          ctx.lineTo(x + w, y + 2);
          ctx.stroke();
          // Label
          ctx.fillStyle = 'rgba(0,0,0,0.4)';
          ctx.font = '8px Inter';
          ctx.fillText('Crown', x + 4, y + h - 3);
          break;

        case 'baseboard':
          // Baseboard molding along floor - shadow in FRONT (inside room)
          // First draw shadow (offset outward into room)
          ctx.fillStyle = 'rgba(0,0,0,0.15)';
          ctx.fillRect(x + 2, y + h, w, 4); // Shadow extends into room (below baseboard in plan view)
          // Main baseboard body
          ctx.fillStyle = el.color || '#F5F5F5';
          ctx.fillRect(x, y, w, h);
          // Profile detail lines
          ctx.strokeStyle = 'rgba(0,0,0,0.15)';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(x, y + h * 0.2);
          ctx.lineTo(x + w, y + h * 0.2);
          ctx.moveTo(x, y + h * 0.5);
          ctx.lineTo(x + w, y + h * 0.5);
          ctx.stroke();
          // Top highlight
          ctx.strokeStyle = 'rgba(255,255,255,0.3)';
          ctx.beginPath();
          ctx.moveTo(x, y + 1);
          ctx.lineTo(x + w, y + 1);
          ctx.stroke();
          break;

        case 'chair-rail':
          // Chair rail at mid-height
          ctx.fillStyle = el.color || '#F5F5F5';
          ctx.fillRect(x, y, w, h);
          // Curved profile suggestion
          ctx.strokeStyle = 'rgba(0,0,0,0.2)';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(x, y + h * 0.4);
          ctx.lineTo(x + w, y + h * 0.4);
          ctx.stroke();
          // Top highlight
          ctx.strokeStyle = 'rgba(255,255,255,0.4)';
          ctx.beginPath();
          ctx.moveTo(x, y + 1);
          ctx.lineTo(x + w, y + 1);
          ctx.stroke();
          break;

        case 'fireplace-niche': {
          // Fireplace recess/opening
          const fpPad = padding * 1.5;
          // Outer surround
          ctx.fillStyle = '#4a4a4a';
          ctx.fillRect(x, y, w, h);
          // Inner opening (darker)
          ctx.fillStyle = '#1a1a1a';
          ctx.fillRect(x + fpPad, y + fpPad, w - fpPad * 2, h - fpPad * 2);
          // Fire glow effect
          const glowGrad = ctx.createRadialGradient(
            x + w/2, y + h * 0.7, 0,
            x + w/2, y + h * 0.7, Math.min(w, h) * 0.4
          );
          glowGrad.addColorStop(0, 'rgba(255, 100, 0, 0.7)');
          glowGrad.addColorStop(0.5, 'rgba(255, 50, 0, 0.4)');
          glowGrad.addColorStop(1, 'rgba(0, 0, 0, 0)');
          ctx.fillStyle = glowGrad;
          ctx.fillRect(x + fpPad, y + fpPad, w - fpPad * 2, h - fpPad * 2);
          // Log shapes
          ctx.fillStyle = '#2d1b0e';
          ctx.beginPath();
          ctx.ellipse(x + w * 0.35, y + h * 0.8, w * 0.12, h * 0.06, 0.1, 0, Math.PI * 2);
          ctx.fill();
          ctx.beginPath();
          ctx.ellipse(x + w * 0.65, y + h * 0.78, w * 0.1, h * 0.05, -0.1, 0, Math.PI * 2);
          ctx.fill();
          // Mantel suggestion (top)
          ctx.fillStyle = '#5a4a3a';
          ctx.fillRect(x - 4, y - 6, w + 8, 8);
          break;
        }

        case 'tv-niche': {
          // TV recess/media niche
          const tvPad = padding;
          // Wall frame
          ctx.fillStyle = '#3a3a3a';
          ctx.fillRect(x, y, w, h);
          // Recessed area
          ctx.fillStyle = '#1a1a1a';
          ctx.fillRect(x + tvPad, y + tvPad, w - tvPad * 2, h - tvPad * 2);
          // TV screen
          const screenPad = tvPad * 2;
          ctx.fillStyle = '#111';
          ctx.fillRect(x + screenPad, y + screenPad, w - screenPad * 2, h - screenPad * 2);
          // Screen reflection
          ctx.fillStyle = 'rgba(60, 60, 80, 0.3)';
          ctx.fillRect(x + screenPad + 4, y + screenPad + 4, (w - screenPad * 2) * 0.6, (h - screenPad * 2) * 0.3);
          // TV stand indicator
          ctx.fillStyle = '#2a2a2a';
          ctx.fillRect(x + w * 0.4, y + h - tvPad - 4, w * 0.2, 4);
          break;
        }

        case 'wall-niche':
        case 'shower-niche': {
          // Decorative wall niche
          const nichePad = padding;
          // Frame
          ctx.fillStyle = '#e8e4dc';
          ctx.fillRect(x, y, w, h);
          // Inner recess (shadow)
          ctx.fillStyle = '#c5c0b5';
          ctx.fillRect(x + nichePad, y + nichePad, w - nichePad * 2, h - nichePad * 2);
          // Back of niche
          ctx.fillStyle = '#b5b0a5';
          ctx.fillRect(x + nichePad + 2, y + nichePad + 2, w - nichePad * 2 - 4, h - nichePad * 2 - 4);
          // Shadow on left and top inside
          ctx.fillStyle = 'rgba(0,0,0,0.15)';
          ctx.fillRect(x + nichePad, y + nichePad, 3, h - nichePad * 2);
          ctx.fillRect(x + nichePad, y + nichePad, w - nichePad * 2, 3);
          // Highlight on right and bottom inside
          ctx.fillStyle = 'rgba(255,255,255,0.2)';
          ctx.fillRect(x + w - nichePad - 3, y + nichePad, 3, h - nichePad * 2);
          ctx.fillRect(x + nichePad, y + h - nichePad - 3, w - nichePad * 2, 3);
          break;
        }

        case 'grab-bar': {
          // ADA grab bar
          const barRadius = Math.min(h * 0.4, 6);
          // Mounting plates
          ctx.fillStyle = '#888';
          ctx.beginPath();
          ctx.arc(x + barRadius * 2, y + h/2, barRadius * 1.5, 0, Math.PI * 2);
          ctx.arc(x + w - barRadius * 2, y + h/2, barRadius * 1.5, 0, Math.PI * 2);
          ctx.fill();
          // Bar body
          const barGrad = ctx.createLinearGradient(x, y, x, y + h);
          barGrad.addColorStop(0, '#d0d0d0');
          barGrad.addColorStop(0.3, '#f0f0f0');
          barGrad.addColorStop(0.7, '#c0c0c0');
          barGrad.addColorStop(1, '#a0a0a0');
          ctx.fillStyle = barGrad;
          ctx.beginPath();
          ctx.roundRect(x + barRadius * 2, y + h/2 - barRadius, w - barRadius * 4, barRadius * 2, barRadius);
          ctx.fill();
          // Highlight
          ctx.strokeStyle = 'rgba(255,255,255,0.5)';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(x + barRadius * 3, y + h/2 - barRadius + 2);
          ctx.lineTo(x + w - barRadius * 3, y + h/2 - barRadius + 2);
          ctx.stroke();
          break;
        }

        // ===== BATHROOM ELEMENTS =====
        case 'toilet': {
          // Toilet (top-down view)
          const tankW = w * 0.7;
          const tankH = h * 0.35;
          const bowlW = w * 0.85;
          const bowlH = h * 0.65;

          // Tank
          ctx.fillStyle = 'rgba(255,255,255,0.9)';
          ctx.strokeStyle = 'rgba(180,180,180,0.8)';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.roundRect(x + (w - tankW) / 2, y, tankW, tankH, 4);
          ctx.fill();
          ctx.stroke();

          // Bowl (elongated oval)
          ctx.beginPath();
          ctx.ellipse(x + w / 2, y + tankH + bowlH / 2, bowlW / 2, bowlH / 2, 0, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();

          // Seat opening
          ctx.strokeStyle = 'rgba(150,150,150,0.6)';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.ellipse(x + w / 2, y + tankH + bowlH / 2 + 2, bowlW / 2 - 6, bowlH / 2 - 6, 0, 0, Math.PI * 2);
          ctx.stroke();

          // Flush handle
          ctx.fillStyle = 'rgba(192,192,192,0.8)';
          ctx.fillRect(x + (w - tankW) / 2 - 6, y + tankH * 0.4, 8, 4);
          break;
        }

        case 'bathtub':
        case 'bathtub-freestanding': {
          // Bathtub (top-down view)
          const rimWidth = 6;

          // Outer rim
          ctx.fillStyle = 'rgba(255,255,255,0.95)';
          ctx.strokeStyle = 'rgba(180,180,180,0.8)';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.roundRect(x, y, w, h, 8);
          ctx.fill();
          ctx.stroke();

          // Inner basin
          ctx.fillStyle = 'rgba(240,240,250,0.9)';
          ctx.strokeStyle = 'rgba(200,200,200,0.6)';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.roundRect(x + rimWidth, y + rimWidth, w - rimWidth * 2, h - rimWidth * 2, 6);
          ctx.fill();
          ctx.stroke();

          // Drain
          ctx.fillStyle = 'rgba(128,128,128,0.7)';
          ctx.beginPath();
          ctx.arc(x + w / 2, y + h - rimWidth - 15, 8, 0, Math.PI * 2);
          ctx.fill();

          // Faucet area
          ctx.fillStyle = 'rgba(192,192,192,0.8)';
          ctx.beginPath();
          ctx.arc(x + w / 2, y + rimWidth + 10, 10, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillRect(x + w / 2 - 20, y + rimWidth + 5, 12, 6);
          ctx.fillRect(x + w / 2 + 8, y + rimWidth + 5, 12, 6);
          break;
        }

        case 'vanity-24':
        case 'vanity-30':
        case 'vanity-36':
        case 'vanity-48':
        case 'vanity-60':
        case 'vanity-72': {
          // Bathroom vanity (top-down view)
          const isDouble = w > pixelsPerFoot * 4;

          // Counter
          ctx.fillStyle = el.color || 'rgba(232,224,216,0.95)';
          ctx.strokeStyle = 'rgba(180,180,180,0.8)';
          ctx.lineWidth = 2;
          ctx.fillRect(x, y, w, h);
          ctx.strokeRect(x, y, w, h);

          // Sink basin(s)
          const sinkPadding = w * 0.15;
          const sinkW = isDouble ? (w - sinkPadding * 3) / 2 : w - sinkPadding * 2;
          const sinkH = h * 0.5;
          const sinkY = y + (h - sinkH) / 2;

          ctx.fillStyle = 'rgba(255,255,255,0.9)';
          ctx.strokeStyle = 'rgba(200,200,200,0.8)';
          ctx.lineWidth = 1;

          if (isDouble) {
            // Left sink
            ctx.beginPath();
            ctx.ellipse(x + sinkPadding + sinkW / 2, sinkY + sinkH / 2, sinkW / 2, sinkH / 2, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            // Right sink
            ctx.beginPath();
            ctx.ellipse(x + w - sinkPadding - sinkW / 2, sinkY + sinkH / 2, sinkW / 2, sinkH / 2, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
          } else {
            // Single sink
            ctx.beginPath();
            ctx.ellipse(x + w / 2, sinkY + sinkH / 2, sinkW / 2, sinkH / 2, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
          }

          // Faucet(s)
          ctx.fillStyle = 'rgba(192,192,192,0.9)';
          if (isDouble) {
            ctx.beginPath();
            ctx.arc(x + sinkPadding + sinkW / 2, y + 8, 5, 0, Math.PI * 2);
            ctx.arc(x + w - sinkPadding - sinkW / 2, y + 8, 5, 0, Math.PI * 2);
            ctx.fill();
          } else {
            ctx.beginPath();
            ctx.arc(x + w / 2, y + 8, 6, 0, Math.PI * 2);
            ctx.fill();
          }
          break;
        }

        case 'shower-bench': {
          // Built-in shower bench (top-down view)
          ctx.fillStyle = el.color || 'rgba(212,212,212,0.9)';
          ctx.strokeStyle = 'rgba(160,160,160,0.8)';
          ctx.lineWidth = 2;
          ctx.fillRect(x, y, w, h);
          ctx.strokeRect(x, y, w, h);

          // Seat indication lines
          ctx.strokeStyle = 'rgba(180,180,180,0.5)';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(x + 4, y + 4);
          ctx.lineTo(x + 4, y + h - 4);
          ctx.moveTo(x + w - 4, y + 4);
          ctx.lineTo(x + w - 4, y + h - 4);
          ctx.stroke();
          break;
        }

        case 'towel-warmer': {
          // Wall-mounted towel warmer (front view)
          ctx.strokeStyle = 'rgba(192,192,192,0.9)';
          ctx.lineWidth = 3;

          // Vertical rails
          ctx.beginPath();
          ctx.moveTo(x + 4, y);
          ctx.lineTo(x + 4, y + h);
          ctx.moveTo(x + w - 4, y);
          ctx.lineTo(x + w - 4, y + h);
          ctx.stroke();

          // Horizontal bars
          const numBars = Math.max(4, Math.floor(h / 15));
          ctx.lineWidth = 2;
          for (let i = 0; i < numBars; i++) {
            const barY = y + 8 + (i * (h - 16) / (numBars - 1));
            ctx.beginPath();
            ctx.moveTo(x + 4, barY);
            ctx.lineTo(x + w - 4, barY);
            ctx.stroke();
          }
          break;
        }

        // ===== LAUNDRY ELEMENTS =====
        case 'washer': {
          // Front-loading washer (top-down view)
          ctx.fillStyle = 'rgba(240,240,240,0.95)';
          ctx.strokeStyle = 'rgba(180,180,180,0.8)';
          ctx.lineWidth = 2;
          ctx.fillRect(x, y, w, h);
          ctx.strokeRect(x, y, w, h);

          // Door circle
          const doorRadius = Math.min(w, h) * 0.35;
          ctx.fillStyle = 'rgba(74,96,128,0.4)';
          ctx.strokeStyle = 'rgba(160,160,160,0.8)';
          ctx.beginPath();
          ctx.arc(x + w / 2, y + h * 0.55, doorRadius, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();

          // Control panel
          ctx.fillStyle = 'rgba(60,60,60,0.7)';
          ctx.fillRect(x + 6, y + 6, w - 12, h * 0.15);

          // Dial
          ctx.fillStyle = 'rgba(192,192,192,0.9)';
          ctx.beginPath();
          ctx.arc(x + w * 0.25, y + 6 + h * 0.075, 8, 0, Math.PI * 2);
          ctx.fill();
          break;
        }

        case 'dryer': {
          // Front-loading dryer (top-down view)
          ctx.fillStyle = 'rgba(232,232,232,0.95)';
          ctx.strokeStyle = 'rgba(180,180,180,0.8)';
          ctx.lineWidth = 2;
          ctx.fillRect(x, y, w, h);
          ctx.strokeRect(x, y, w, h);

          // Door circle (solid)
          const dryerDoorRadius = Math.min(w, h) * 0.35;
          ctx.fillStyle = 'rgba(216,216,216,0.9)';
          ctx.strokeStyle = 'rgba(160,160,160,0.8)';
          ctx.beginPath();
          ctx.arc(x + w / 2, y + h * 0.55, dryerDoorRadius, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();

          // Control panel
          ctx.fillStyle = 'rgba(70,70,70,0.7)';
          ctx.fillRect(x + 6, y + 6, w - 12, h * 0.15);

          // Dials
          ctx.fillStyle = 'rgba(192,192,192,0.9)';
          ctx.beginPath();
          ctx.arc(x + w * 0.25, y + 6 + h * 0.075, 7, 0, Math.PI * 2);
          ctx.arc(x + w * 0.75, y + 6 + h * 0.075, 7, 0, Math.PI * 2);
          ctx.fill();
          break;
        }

        case 'utility-sink':
        case 'laundry-sink': {
          // Deep utility sink (top-down view)
          ctx.fillStyle = 'rgba(245,245,245,0.95)';
          ctx.strokeStyle = 'rgba(180,180,180,0.8)';
          ctx.lineWidth = 2;
          ctx.fillRect(x, y, w, h);
          ctx.strokeRect(x, y, w, h);

          // Basin
          const basinPad = 8;
          ctx.fillStyle = 'rgba(232,232,232,0.9)';
          ctx.strokeStyle = 'rgba(200,200,200,0.8)';
          ctx.lineWidth = 1;
          ctx.fillRect(x + basinPad, y + basinPad, w - basinPad * 2, h - basinPad * 2);
          ctx.strokeRect(x + basinPad, y + basinPad, w - basinPad * 2, h - basinPad * 2);

          // Drain
          ctx.fillStyle = 'rgba(128,128,128,0.7)';
          ctx.beginPath();
          ctx.arc(x + w / 2, y + h / 2, 6, 0, Math.PI * 2);
          ctx.fill();

          // Faucet
          ctx.fillStyle = 'rgba(176,176,176,0.9)';
          ctx.beginPath();
          ctx.arc(x + w / 2, y + basinPad + 8, 8, 0, Math.PI * 2);
          ctx.fill();
          break;
        }

        case 'drying-rack': {
          // Drying rack (top-down view)
          ctx.strokeStyle = 'rgba(192,192,192,0.8)';
          ctx.lineWidth = 2;

          // Frame
          ctx.strokeRect(x, y, w, h);

          // Rods
          const numRods = Math.max(4, Math.floor(h / 12));
          ctx.lineWidth = 1.5;
          for (let i = 0; i < numRods; i++) {
            const rodY = y + 4 + (i * (h - 8) / (numRods - 1));
            ctx.beginPath();
            ctx.moveTo(x + 3, rodY);
            ctx.lineTo(x + w - 3, rodY);
            ctx.stroke();
          }
          break;
        }

        // ===== CLOSET ELEMENTS =====
        case 'closet-rod': {
          // Clothing rod (top-down view shows as line)
          ctx.strokeStyle = 'rgba(192,192,192,0.9)';
          ctx.lineWidth = 4;
          ctx.beginPath();
          ctx.moveTo(x, y + h / 2);
          ctx.lineTo(x + w, y + h / 2);
          ctx.stroke();

          // End brackets
          ctx.fillStyle = 'rgba(128,128,128,0.8)';
          ctx.fillRect(x, y + h / 2 - 6, 8, 12);
          ctx.fillRect(x + w - 8, y + h / 2 - 6, 8, 12);
          break;
        }

        case 'closet-shelf': {
          // Closet shelf (top-down view)
          ctx.fillStyle = el.color || 'rgba(232,232,232,0.9)';
          ctx.strokeStyle = 'rgba(200,200,200,0.8)';
          ctx.lineWidth = 1;
          ctx.fillRect(x, y, w, h);
          ctx.strokeRect(x, y, w, h);

          // Front edge
          ctx.fillStyle = 'rgba(210,210,210,0.9)';
          ctx.fillRect(x, y + h - 4, w, 4);
          break;
        }

        case 'drawer-unit': {
          // Multi-drawer unit (top-down view)
          ctx.fillStyle = el.color || 'rgba(245,240,230,0.95)';
          ctx.strokeStyle = 'rgba(180,180,180,0.8)';
          ctx.lineWidth = 2;
          ctx.fillRect(x, y, w, h);
          ctx.strokeRect(x, y, w, h);

          // Drawer fronts
          const numDrawers = Math.max(3, Math.floor(h / 20));
          const drawerH = (h - 8) / numDrawers;
          ctx.strokeStyle = 'rgba(160,160,160,0.6)';
          ctx.lineWidth = 1;
          for (let i = 0; i < numDrawers; i++) {
            const dY = y + 4 + i * drawerH;
            ctx.strokeRect(x + 4, dY, w - 8, drawerH - 2);

            // Handle
            ctx.fillStyle = 'rgba(192,192,192,0.8)';
            ctx.fillRect(x + w / 2 - 10, dY + drawerH / 2 - 2, 20, 4);
          }
          break;
        }

        case 'shoe-rack': {
          // Shoe rack (top-down view)
          ctx.fillStyle = el.color || 'rgba(222,184,135,0.9)';
          ctx.strokeStyle = 'rgba(180,160,140,0.8)';
          ctx.lineWidth = 2;
          ctx.fillRect(x, y, w, h);
          ctx.strokeRect(x, y, w, h);

          // Shelves
          const numShelves = Math.max(3, Math.floor(h / 18));
          ctx.strokeStyle = 'rgba(160,140,120,0.6)';
          ctx.lineWidth = 1;
          for (let i = 1; i < numShelves; i++) {
            const shelfY = y + (i * h / numShelves);
            ctx.beginPath();
            ctx.moveTo(x + 4, shelfY);
            ctx.lineTo(x + w - 4, shelfY);
            ctx.stroke();
          }
          break;
        }

        case 'closet-island': {
          // Closet island (top-down view)
          ctx.fillStyle = el.color || 'rgba(245,240,230,0.95)';
          ctx.strokeStyle = 'rgba(180,180,180,0.8)';
          ctx.lineWidth = 2;
          ctx.fillRect(x, y, w, h);
          ctx.strokeRect(x, y, w, h);

          // Top surface (different color)
          ctx.fillStyle = 'rgba(232,224,216,0.9)';
          ctx.fillRect(x + 2, y + 2, w - 4, h - 4);

          // Drawer indication
          ctx.strokeStyle = 'rgba(200,190,180,0.6)';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(x + w / 4, y + 4);
          ctx.lineTo(x + w / 4, y + h - 4);
          ctx.moveTo(x + w * 3 / 4, y + 4);
          ctx.lineTo(x + w * 3 / 4, y + h - 4);
          ctx.stroke();
          break;
        }

        case 'jewelry-cabinet': {
          // Jewelry cabinet (front view in 2D)
          ctx.fillStyle = el.color || 'rgba(245,240,230,0.95)';
          ctx.strokeStyle = 'rgba(180,180,180,0.8)';
          ctx.lineWidth = 2;
          ctx.fillRect(x, y, w, h);
          ctx.strokeRect(x, y, w, h);

          // Mirror
          ctx.fillStyle = 'rgba(200,210,220,0.7)';
          ctx.fillRect(x + 6, y + 6, w - 12, h - 12);

          // Mirror shine
          ctx.strokeStyle = 'rgba(255,255,255,0.4)';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(x + w * 0.2, y + 6);
          ctx.lineTo(x + 6, y + h * 0.3);
          ctx.stroke();
          break;
        }
      }

      ctx.lineWidth = 1;
    }

    function drawElements() {
      // Define z-order for element types (lower = drawn first = below)
      // Layer 0-9: Floor level (flooring, rugs)
      // Layer 10-19: Base level (cabinets, appliances on floor)
      // Layer 20-29: Counter level (countertops, sinks)
      // Layer 30-39: Above counter (backsplash, upper cabs)
      // Layer 40-49: Wall fixtures (windows, doors, niches)
      // Layer 50-59: Walls and partitions
      // Layer 60+: Annotations, labels
      const zOrder = {
        // Floor level
        'flooring': 0,
        'tile': 1,
        'rug': 2,
        'threshold': 3,
        'fireplace-hearth': 4,

        // Base level
        'island': 10,
        'base-cabinet': 11,
        'drawer-base': 11,
        'sink-base': 11,
        'corner-cabinet': 12,
        'lazy-susan': 12,
        'tall-cabinet': 13,
        'pantry': 13,
        'refrigerator': 14,
        'oven': 14,
        'dishwasher': 14,
        'stove': 15,
        'range': 15,
        'cooktop': 16,

        // Counter level
        'countertop': 20,
        'bar-top': 21,
        'wall-cap': 21,
        'sink': 22,
        'sink-double': 22,
        'sink-farmhouse': 22,

        // Above counter
        'backsplash': 30,
        'wall-cabinet': 31,
        'range-hood': 32,
        'microwave': 32,

        // Wall fixtures
        'window': 40,
        'bay-window': 40,
        'picture-window': 40,
        'door': 41,
        'sliding-door': 41,
        'french-door': 41,
        'glass-door': 41,
        'wall-niche': 42,
        'shower-niche': 42,
        'fireplace-niche': 43,
        'tv-niche': 43,
        'grab-bar': 44,

        // Walls and partitions
        'wall': 50,
        'wall-block': 50,
        'wall-concrete': 50,
        'wall-framed': 50,
        'pony-wall': 51,
        'pony-wall-bar': 51,
        'knee-wall': 51,

        // Fixtures and accessories (bathroom)
        'toilet': 45,
        'bathtub': 45,
        'bathtub-freestanding': 45,
        'shower': 45,
        'vanity-24': 46,
        'vanity-30': 46,
        'vanity-36': 46,
        'vanity-48': 46,
        'vanity-60': 46,
        'vanity-72': 46,
        'shower-bench': 44,
        'towel-warmer': 47,

        // Laundry elements
        'washer': 14,
        'dryer': 14,
        'utility-sink': 22,
        'laundry-sink': 22,
        'drying-rack': 47,

        // Closet elements
        'closet-rod': 35,
        'closet-shelf': 36,
        'drawer-unit': 13,
        'shoe-rack': 12,
        'closet-island': 11,
        'jewelry-cabinet': 46,

        // Decorative
        'crown-molding': 55,
        'mantel': 55,
        'fireplace-surround': 55
      };

      // Filter out hidden elements based on visibility settings
      const visibleElements = elements.filter(el => {
        if (el.hidden) return false;
        const category = getElementCategory(el.type);
        return !hiddenCategories[category];
      });

      // Sort elements by z-order, then by custom zIndex override, then selected last
      const sortedElements = [...visibleElements].sort((a, b) => {
        // Selected element always draws last (on top)
        if (a === selectedElement) return 1;
        if (b === selectedElement) return -1;

        // Get base z-order from type
        const aBase = zOrder[a.type] ?? 25;
        const bBase = zOrder[b.type] ?? 25;

        // Apply custom zIndex offset if set (from send to back/bring to front)
        const aZ = aBase + (a.zIndexOffset || 0);
        const bZ = bBase + (b.zIndexOffset || 0);

        return aZ - bZ;
      });

      sortedElements.forEach(el => {
        drawElement(el, el === selectedElement);
      });
    }

    // Get element category for visibility toggles
    function getElementCategory(type) {
      const categories = {
        cabinets: ['base-cabinet', 'drawer-base', 'sink-base', 'corner-cabinet', 'lazy-susan', 'wall-cabinet', 'tall-cabinet', 'pantry', 'island', 'vanity'],
        countertops: ['countertop', 'countertop-l', 'countertop-u', 'bar-top', 'wall-cap', 'backsplash', 'surface-stainless', 'surface-solid', 'surface-laminate', 'surface-butcherblock', 'surface-concrete', 'window-sill'],
        appliances: ['refrigerator', 'stove', 'range', 'cooktop', 'oven', 'dishwasher', 'microwave', 'range-hood'],
        sinks: ['sink', 'sink-double', 'sink-farmhouse'],
        flooring: ['flooring', 'tile', 'rug', 'threshold'],
        walls: ['wall', 'wall-block', 'wall-concrete', 'wall-framed', 'wall-wood-2x4', 'wall-wood-2x6', 'wall-brick', 'wall-steel', 'wall-aluminum', 'pony-wall', 'pony-wall-bar', 'knee-wall', 'shower-wall', 'wall-tile', 'accent-wall'],
        windows: ['window', 'window-large', 'bay-window', 'picture-window'],
        doors: ['door', 'double-door', 'sliding-door', 'french-door', 'glass-door', 'entry-archway', 'garage-door'],
        niches: ['wall-niche', 'shower-niche', 'fireplace-niche', 'tv-niche', 'niche-surround'],
        fixtures: ['toilet', 'bathtub', 'bathtub-freestanding', 'shower', 'grab-bar', 'shower-pan', 'shower-curb', 'shower-bench', 'towel-warmer'],
        bathroom: ['vanity-24', 'vanity-30', 'vanity-36', 'vanity-48', 'vanity-60', 'vanity-72'],
        laundry: ['washer', 'dryer', 'utility-sink', 'laundry-sink', 'drying-rack'],
        closet: ['closet-rod', 'closet-shelf', 'drawer-unit', 'shoe-rack', 'closet-island', 'jewelry-cabinet'],
        decorative: ['crown-molding', 'mantel', 'fireplace-surround', 'fireplace-hearth'],
        structural: ['steel-beam', 'steel-column', 'wood-beam', 'wood-post', 'concrete-beam', 'concrete-column', 'header', 'lvl-beam', 'baseboard', 'chair-rail']
      };

      for (const [category, types] of Object.entries(categories)) {
        if (types.includes(type)) return category;
      }
      return 'other';
    }

    // Track hidden categories
    let hiddenCategories = {};

    function toggleCategoryVisibility(category, visible) {
      if (visible) {
        delete hiddenCategories[category];
      } else {
        hiddenCategories[category] = true;
      }
      draw();
      update3DScene();
    }

    function showAllCategories() {
      hiddenCategories = {};
      // Reset all checkboxes
      document.querySelectorAll('.visibility-toggle input[type="checkbox"]').forEach(cb => {
        cb.checked = true;
      });
      draw();
      update3DScene();
    }

    function hideElement(el) {
      if (el) {
        el.hidden = true;
        if (el === selectedElement) {
          selectedElement = null;
          updateProperties();
        }
        draw();
        update3DScene();
      }
    }

    function showElement(el) {
      if (el) {
        el.hidden = false;
        draw();
        update3DScene();
      }
    }

    function drawElement(el, isSelected) {
      const x = el.x;
      const y = el.y;
      const w = el.width * pixelsPerFoot;
      const h = el.height * pixelsPerFoot;

      ctx.save();
      ctx.translate(x + w/2, y + h/2);
      ctx.rotate((el.rotation || 0) * Math.PI / 180);
      ctx.translate(-(x + w/2), -(y + h/2));

      // Background with slight shadow
      ctx.shadowColor = 'rgba(0,0,0,0.4)';
      ctx.shadowBlur = 10;
      ctx.shadowOffsetX = 3;
      ctx.shadowOffsetY = 3;

      // Draw base shape with texture or color
      if (el.textureImg) {
        ctx.drawImage(el.textureImg, x, y, w, h);
      } else {
        ctx.fillStyle = el.color;
        ctx.fillRect(x, y, w, h);
      }

      // Reset shadow
      ctx.shadowColor = 'transparent';
      ctx.shadowBlur = 0;
      ctx.shadowOffsetX = 0;
      ctx.shadowOffsetY = 0;

      // Draw architectural details based on element type
      drawElementDetails(el, x, y, w, h);

      // Border
      ctx.strokeStyle = isSelected ? '#6366f1' : 'rgba(255,255,255,0.3)';
      ctx.lineWidth = isSelected ? 3 : 1.5;
      ctx.strokeRect(x, y, w, h);

      // Only show label if element is large enough or selected
      const showLabel = w > 60 || h > 60 || isSelected;
      if (showLabel) {
        // Get display label with fallback
        const typeName = el.type ? el.type.replace(/-/g, ' ').replace(/\b\w/g, c => c.toUpperCase()) : '';
        const displayLabel = el.label || typeName || 'Element';
        const labelFontSize = Math.max(9, Math.min(14, pixelsPerFoot / 3));
        ctx.font = `${labelFontSize}px Inter`;
        const labelWidth = ctx.measureText(displayLabel).width + 8;

        // Label background
        ctx.fillStyle = 'rgba(0,0,0,0.6)';
        ctx.fillRect(x + w/2 - labelWidth/2, y + h - labelFontSize - 8, labelWidth, labelFontSize + 4);

        // Label text
        ctx.fillStyle = 'rgba(255,255,255,0.95)';
        ctx.textAlign = 'center';
        ctx.fillText(displayLabel, x + w/2, y + h - 6);
      }

      // Dimensions (only when selected)
      if (isSelected) {
        ctx.fillStyle = '#6366f1';
        ctx.font = `bold ${Math.max(10, pixelsPerFoot / 4)}px Inter`;
        ctx.fillText(formatSize(el.width, el.height), x + w/2, y - 8);
      }

      // Lock icon (drawn in rotated context)
      if (isSelected && el.locked) {
        ctx.fillStyle = 'rgba(239, 68, 68, 0.9)';
        ctx.font = '14px Inter';
        ctx.fillText('ðŸ”’', x + w - 12, y + 16);
      }

      // Restore context BEFORE drawing handles (handles use world coordinates)
      ctx.restore();

      // Selection handles (8 handles for resize) - drawn in world space
      if (isSelected && !el.locked) {
        const hs = HANDLE_SIZE;
        ctx.fillStyle = '#6366f1';
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;

        // Get all 8 handle positions (already in world coordinates with rotation applied)
        const handles = getResizeHandles(el);
        Object.values(handles).forEach(handle => {
          ctx.fillRect(handle.x - hs/2, handle.y - hs/2, hs, hs);
          ctx.strokeRect(handle.x - hs/2, handle.y - hs/2, hs, hs);
        });
      }

      // Locked element handles - drawn in world space
      if (isSelected && el.locked) {
        const hs = HANDLE_SIZE;
        ctx.fillStyle = '#ef4444';
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        // Use rotated handle positions for locked elements too
        const handles = getResizeHandles(el);
        [handles.nw, handles.ne, handles.sw, handles.se].forEach(handle => {
          ctx.fillRect(handle.x - hs/2, handle.y - hs/2, hs, hs);
          ctx.strokeRect(handle.x - hs/2, handle.y - hs/2, hs, hs);
        });
      }

      // Edge preview indicator for countertops - pulsing dot on front edge
      if (isSelected && (el.type === 'countertop' || el.type === 'countertop-l' || el.type === 'countertop-u')) {
        const rotation = (el.rotation || 0) * Math.PI / 180;
        const cx = x + w / 2;
        const cy = y + h / 2;

        // Calculate indicator position on front edge (bottom of countertop in 2D)
        // Rotate the point based on element rotation
        let indicatorX = cx;
        let indicatorY = y + h + 15; // Below the front edge

        if (rotation !== 0) {
          // Rotate indicator position around center
          const dx = indicatorX - cx;
          const dy = indicatorY - cy;
          indicatorX = cx + dx * Math.cos(rotation) - dy * Math.sin(rotation);
          indicatorY = cy + dx * Math.sin(rotation) + dy * Math.cos(rotation);
        }

        // Store indicator position for click detection
        el._edgeIndicator = { x: indicatorX, y: indicatorY, radius: 14 };

        // Pulsing animation
        const pulse = (Math.sin(Date.now() / 300) + 1) / 2; // 0 to 1
        const baseRadius = 10;
        const pulseRadius = baseRadius + pulse * 4;

        // Outer glow
        const gradient = ctx.createRadialGradient(indicatorX, indicatorY, 0, indicatorX, indicatorY, pulseRadius + 8);
        gradient.addColorStop(0, 'rgba(99, 102, 241, 0.8)');
        gradient.addColorStop(0.5, 'rgba(99, 102, 241, 0.3)');
        gradient.addColorStop(1, 'rgba(99, 102, 241, 0)');
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(indicatorX, indicatorY, pulseRadius + 8, 0, Math.PI * 2);
        ctx.fill();

        // Main indicator dot
        ctx.fillStyle = '#6366f1';
        ctx.beginPath();
        ctx.arc(indicatorX, indicatorY, baseRadius, 0, Math.PI * 2);
        ctx.fill();

        // White border
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.stroke();

        // Eye icon inside
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 10px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('ðŸ‘', indicatorX, indicatorY);

        // Label
        ctx.fillStyle = 'rgba(99, 102, 241, 0.9)';
        ctx.font = '10px Inter, sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('Edge', indicatorX, indicatorY + 22);
      }
    }

    // ===== RESIZE HANDLES =====
    function getResizeHandles(el) {
      const x = el.x;
      const y = el.y;
      const w = el.width * pixelsPerFoot;
      const h = el.height * pixelsPerFoot;
      const rotation = (el.rotation || 0) * Math.PI / 180;
      const cx = x + w / 2;
      const cy = y + h / 2;

      // Helper to rotate a point around the center
      function rotatePoint(px, py) {
        if (rotation === 0) return { x: px, y: py };
        const dx = px - cx;
        const dy = py - cy;
        const cosR = Math.cos(rotation);
        const sinR = Math.sin(rotation);
        return {
          x: cx + dx * cosR - dy * sinR,
          y: cy + dx * sinR + dy * cosR
        };
      }

      // Get rotated handle positions
      const nw = rotatePoint(x, y);
      const n = rotatePoint(x + w/2, y);
      const ne = rotatePoint(x + w, y);
      const e = rotatePoint(x + w, y + h/2);
      const se = rotatePoint(x + w, y + h);
      const s = rotatePoint(x + w/2, y + h);
      const sw = rotatePoint(x, y + h);
      const west = rotatePoint(x, y + h/2);

      return {
        nw: { ...nw, cursor: 'nwse-resize' },
        n:  { ...n, cursor: 'ns-resize' },
        ne: { ...ne, cursor: 'nesw-resize' },
        e:  { ...e, cursor: 'ew-resize' },
        se: { ...se, cursor: 'nwse-resize' },
        s:  { ...s, cursor: 'ns-resize' },
        sw: { ...sw, cursor: 'nesw-resize' },
        w:  { ...west, cursor: 'ew-resize' }
      };
    }

    function getHandleAtPosition(el, worldX, worldY) {
      if (!el || el.locked) return null;

      const handles = getResizeHandles(el);
      const hs = HANDLE_SIZE + 4; // Slightly larger hit area

      for (const [name, handle] of Object.entries(handles)) {
        if (worldX >= handle.x - hs/2 && worldX <= handle.x + hs/2 &&
            worldY >= handle.y - hs/2 && worldY <= handle.y + hs/2) {
          return { name, ...handle };
        }
      }
      return null;
    }

    function getCursorForHandle(handleName) {
      const cursors = {
        nw: 'nwse-resize',
        n: 'ns-resize',
        ne: 'nesw-resize',
        e: 'ew-resize',
        se: 'nwse-resize',
        s: 'ns-resize',
        sw: 'nesw-resize',
        w: 'ew-resize'
      };
      return cursors[handleName] || 'default';
    }

    function applyResize(el, handle, dx, dy) {
      // Transform world-space delta to local-space delta based on rotation
      const rotation = (el.rotation || 0) * Math.PI / 180;
      let localDx = dx;
      let localDy = dy;

      if (rotation !== 0) {
        const cosR = Math.cos(-rotation);
        const sinR = Math.sin(-rotation);
        localDx = dx * cosR - dy * sinR;
        localDy = dx * sinR + dy * cosR;
      }

      // Convert pixel delta to feet
      const dxFeet = localDx / pixelsPerFoot;
      const dyFeet = localDy / pixelsPerFoot;

      // Minimum size in feet
      const minSize = 0.5;

      // Calculate fixed edges (the edges that should NOT move)
      // For each resize, we anchor from the opposite edge
      const originalRight = resizeStart.elX + resizeStart.width * pixelsPerFoot;
      const originalBottom = resizeStart.elY + resizeStart.height * pixelsPerFoot;
      const originalLeft = resizeStart.elX;
      const originalTop = resizeStart.elY;

      // Apply resize based on which handle is being dragged
      // Each case anchors the opposite edge(s) to stay fixed
      switch(handle) {
        case 'nw': // Anchor bottom-right corner
          el.width = Math.max(minSize, resizeStart.width - dxFeet);
          el.height = Math.max(minSize, resizeStart.height - dyFeet);
          break;

        case 'n': // Anchor bottom edge
          el.height = Math.max(minSize, resizeStart.height - dyFeet);
          break;

        case 'ne': // Anchor bottom-left corner
          el.width = Math.max(minSize, resizeStart.width + dxFeet);
          el.height = Math.max(minSize, resizeStart.height - dyFeet);
          break;

        case 'e': // Anchor left edge
          el.width = Math.max(minSize, resizeStart.width + dxFeet);
          break;

        case 'se': // Anchor top-left corner
          el.width = Math.max(minSize, resizeStart.width + dxFeet);
          el.height = Math.max(minSize, resizeStart.height + dyFeet);
          break;

        case 's': // Anchor top edge
          el.height = Math.max(minSize, resizeStart.height + dyFeet);
          break;

        case 'sw': // Anchor top-right corner
          el.width = Math.max(minSize, resizeStart.width - dxFeet);
          el.height = Math.max(minSize, resizeStart.height + dyFeet);
          break;

        case 'w': // Anchor right edge
          el.width = Math.max(minSize, resizeStart.width - dxFeet);
          break;
      }

      // Smart snap to standard dimensions if close, otherwise round to 1/16"
      el.width = snapToStandard(el.width, 'width');
      el.height = snapToStandard(el.height, 'depth');
      el.width = roundToSixteenth(el.width);
      el.height = roundToSixteenth(el.height);

      // NOW recalculate position to keep the anchored edge fixed AFTER snapping
      // This ensures the opposite edge doesn't move when we snap to standard sizes
      switch(handle) {
        case 'nw': // Keep bottom-right fixed
          el.x = originalRight - el.width * pixelsPerFoot;
          el.y = originalBottom - el.height * pixelsPerFoot;
          break;

        case 'n': // Keep bottom fixed
          el.y = originalBottom - el.height * pixelsPerFoot;
          break;

        case 'ne': // Keep bottom-left fixed, x stays at originalLeft
          el.x = originalLeft;
          el.y = originalBottom - el.height * pixelsPerFoot;
          break;

        case 'e': // Keep left fixed
          el.x = originalLeft;
          break;

        case 'se': // Keep top-left fixed
          el.x = originalLeft;
          el.y = originalTop;
          break;

        case 's': // Keep top fixed
          el.y = originalTop;
          break;

        case 'sw': // Keep top-right fixed
          el.x = originalRight - el.width * pixelsPerFoot;
          el.y = originalTop;
          break;

        case 'w': // Keep right fixed
          el.x = originalRight - el.width * pixelsPerFoot;
          break;
      }

      // Show snap indicator if snapped to standard
      const suggested = getSuggestedSize(el.type);
      if (suggested && Math.abs(el.width - suggested.width) < 0.01 && Math.abs(el.height - suggested.height) < 0.01) {
        showSnapFeedback(suggested.note);
      }
    }

    // Show brief feedback when snapping to standard
    function showSnapFeedback(message) {
      const hint = document.querySelector('.material-hint');
      if (hint) {
        const original = hint.innerHTML;
        hint.innerHTML = `ðŸ“ Snapped to: ${message}`;
        hint.style.borderColor = 'var(--success)';
        setTimeout(() => {
          hint.innerHTML = original;
          hint.style.borderColor = 'var(--border)';
        }, 1500);
      }
    }

    // ===== MOUSE EVENTS =====
    // Convert screen coordinates to world coordinates (accounting for pan)
    function screenToWorld(screenX, screenY) {
      return {
        x: screenX - panX,
        y: screenY - panY
      };
    }

    function onMouseDown(e) {
      // Ignore right-click - let context menu handle it
      if (e.button === 2) {
        return;
      }

      const rect = canvas.getBoundingClientRect();
      const screenX = e.clientX - rect.left;
      const screenY = e.clientY - rect.top;
      const { x, y } = screenToWorld(screenX, screenY);

      // Check for edge indicator click on selected countertop
      if (selectedElement && selectedElement._edgeIndicator) {
        const ind = selectedElement._edgeIndicator;
        const dist = Math.sqrt((x - ind.x) ** 2 + (y - ind.y) ** 2);
        if (dist <= ind.radius + 5) {
          showEdgePreviewModal(selectedElement);
          return;
        }
      }

      // Check for room resize handle click (only in select mode)
      if (currentTool === 'select') {
        const roomHandle = getRoomHandleAtPosition(x, y);
        if (roomHandle) {
          isResizingRoom = true;
          roomResizeHandle = roomHandle.name;
          roomResizeStart = {
            x: x,
            y: y,
            width: roomWidth,
            depth: roomDepth
          };
          canvas.style.cursor = roomHandle.cursor;
          return;
        }
      }

      // Pan tool or middle mouse button (unless view is locked)
      if ((currentTool === 'pan' || e.button === 1) && !viewLocked) {
        isPanning = true;
        panStart = { x: screenX - panX, y: screenY - panY };
        canvas.style.cursor = 'grabbing';
        e.preventDefault();
        return;
      }

      // Space + drag to pan (unless view is locked)
      if (spacePressed && !viewLocked) {
        isPanning = true;
        panStart = { x: screenX - panX, y: screenY - panY };
        return;
      }

      if (currentTool === 'wall') {
        isDrawingWall = true;
        wallStart = { x, y };
        return;
      }

      if (currentTool === 'countertop') {
        isDrawingCountertop = true;
        countertopStart = { x, y };
        return;
      }

      if (currentTool === 'layout') {
        startLayoutDraw(x, y);
        return;
      }

      if (currentTool !== 'select') return;

      // Check if clicking on a resize handle of selected element
      if (selectedElement && !selectedElement.locked) {
        const handle = getHandleAtPosition(selectedElement, x, y);
        if (handle) {
          isResizing = true;
          resizeHandle = handle.name;
          resizeStart = {
            x: x,
            y: y,
            width: selectedElement.width,
            height: selectedElement.height,
            elX: selectedElement.x,
            elY: selectedElement.y
          };
          canvas.style.cursor = getCursorForHandle(handle.name);
          return;
        }
      }

      // Get ALL elements at this position (for cycling)
      const elementsAtPoint = [...elements].reverse().filter(el => isPointInElement(x, y, el));

      if (elementsAtPoint.length > 0) {
        const now = Date.now();
        const sameSpot = Math.abs(x - lastClickPos.x) < CLICK_CYCLE_THRESHOLD &&
                         Math.abs(y - lastClickPos.y) < CLICK_CYCLE_THRESHOLD;
        const quickClick = (now - lastClickTime) < CLICK_CYCLE_TIME;

        // Cycle through overlapping elements if clicking same spot quickly
        if (sameSpot && quickClick && elementsAtPoint.length > 1) {
          cycleIndex = (cycleIndex + 1) % elementsAtPoint.length;
          showSnapFeedback(`Element ${cycleIndex + 1} of ${elementsAtPoint.length} at this position`);
        } else {
          cycleIndex = 0;
        }

        lastClickPos = { x, y };
        lastClickTime = now;

        const clicked = elementsAtPoint[cycleIndex];

        // If a material is selected, apply it to the clicked element
        if (selectedMaterial) {
          applyMaterialToElement(clicked);
          selectedElement = clicked;
          updateProperties();
          draw();
          return;
        }

        // If a store product is selected, apply it as material
        if (selectedStoreProduct) {
          applyStoreProductToElement(clicked);
          selectedElement = clicked;
          updateProperties();
          draw();
          return;
        }

        selectedElement = clicked;
        if (!clicked.locked) {
          isDragging = true;
          dragOffset = { x: x - clicked.x, y: y - clicked.y };
          autoRotationApplied = false; // Reset auto-rotation tracking for new drag
          lastSnappedWall = null;
        }
        updateProperties();
      } else {
        selectedElement = null;
        cycleIndex = 0;
        updateProperties();
      }

      draw();
    }

    function onMouseMove(e) {
      const rect = canvas.getBoundingClientRect();
      const screenX = e.clientX - rect.left;
      const screenY = e.clientY - rect.top;
      const { x, y } = screenToWorld(screenX, screenY);

      // Handle panning
      if (isPanning) {
        panX = screenX - panStart.x;
        panY = screenY - panStart.y;
        draw();
        return;
      }

      // Handle room resizing
      if (isResizingRoom && roomResizeHandle) {
        const dx = (x - roomResizeStart.x) / pixelsPerFoot;
        const dy = (y - roomResizeStart.y) / pixelsPerFoot;

        let newWidth = roomResizeStart.width;
        let newDepth = roomResizeStart.depth;

        if (roomResizeHandle === 'e' || roomResizeHandle === 'se') {
          newWidth = Math.max(8, Math.round(roomResizeStart.width + dx));
        }
        if (roomResizeHandle === 's' || roomResizeHandle === 'se') {
          newDepth = Math.max(8, Math.round(roomResizeStart.depth + dy));
        }

        // Update room size
        roomWidth = Math.min(100, newWidth);
        roomDepth = Math.min(100, newDepth);

        // Update UI inputs
        document.getElementById('roomWidth').value = roomWidth;
        document.getElementById('roomDepth').value = roomDepth;

        // Redraw
        if (document.getElementById('scaleMode').value === 'fit') {
          fitToScreen();
        } else {
          updateCanvasSize();
        }
        draw();
        return;
      }

      // Handle layout brush drawing
      if (currentTool === 'layout' && layoutMode.isDrawing) {
        continueLayoutDraw(x, y);
        return;
      }

      // Handle resizing
      if (isResizing && selectedElement && resizeHandle) {
        const dx = x - resizeStart.x;
        const dy = y - resizeStart.y;
        applyResize(selectedElement, resizeHandle, dx, dy);
        updateProperties();
        draw();
        return;
      }

      if (isDrawingWall && wallStart) {
        // Preview wall while drawing
        draw();
        ctx.save();
        ctx.translate(panX, panY);
        ctx.fillStyle = 'rgba(100, 100, 100, 0.5)';
        const wx = Math.min(wallStart.x, x);
        const wy = Math.min(wallStart.y, y);
        const ww = Math.abs(x - wallStart.x) || CONFIG.WALL_THICKNESS;
        const wh = Math.abs(y - wallStart.y) || CONFIG.WALL_THICKNESS;
        ctx.fillRect(wx, wy, ww, wh);
        ctx.restore();
        return;
      }

      if (isDrawingCountertop && countertopStart) {
        // Preview countertop while drawing with measurements
        draw();
        ctx.save();
        ctx.translate(panX, panY);

        const cx = Math.min(countertopStart.x, x);
        const cy = Math.min(countertopStart.y, y);
        const cw = Math.abs(x - countertopStart.x) || pixelsPerFoot * 2;
        const ch = Math.abs(y - countertopStart.y) || pixelsPerFoot * 2;

        // Draw countertop preview
        ctx.fillStyle = 'rgba(112, 128, 144, 0.6)';
        ctx.fillRect(cx, cy, cw, ch);
        ctx.strokeStyle = '#708090';
        ctx.lineWidth = 2;
        ctx.strokeRect(cx, cy, cw, ch);

        // Show measurements
        const widthFt = (cw / pixelsPerFoot).toFixed(1);
        const depthFt = (ch / pixelsPerFoot).toFixed(1);
        const sqft = (widthFt * depthFt).toFixed(1);

        ctx.fillStyle = '#fff';
        ctx.font = 'bold 14px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(`${widthFt}' Ã— ${depthFt}'`, cx + cw/2, cy + ch/2 - 10);
        ctx.font = '12px Arial';
        ctx.fillText(`${sqft} sq ft`, cx + cw/2, cy + ch/2 + 10);

        ctx.restore();
        return;
      }

      // Update cursor when hovering over room resize handles
      if (currentTool === 'select' && !isDragging && !isResizing) {
        const roomHandle = getRoomHandleAtPosition(x, y);
        if (roomHandle) {
          canvas.style.cursor = roomHandle.cursor;
          return;
        }
      }

      // Update cursor when hovering over resize handles
      if (selectedElement && !selectedElement.locked && !isDragging) {
        const handle = getHandleAtPosition(selectedElement, x, y);
        if (handle) {
          canvas.style.cursor = getCursorForHandle(handle.name);
        } else if (isPointInElement(x, y, selectedElement)) {
          canvas.style.cursor = 'move';
        } else {
          canvas.style.cursor = 'default';
        }
      }

      if (!isDragging || !selectedElement || selectedElement.locked) return;

      const gridSnap = pixelsPerFoot / CONFIG.GRID_SUBDIVISIONS;
      let snapX = Math.round((x - dragOffset.x) / gridSnap) * gridSnap;
      let snapY = Math.round((y - dragOffset.y) / gridSnap) * gridSnap;

      // Element-to-element snapping (for placing cabinets together)
      const snapDistance = pixelsPerFoot * 0.5; // Snap within 0.5 feet (more forgiving)
      const elW = selectedElement.width * pixelsPerFoot;
      const elH = selectedElement.height * pixelsPerFoot;

      // Check if this is a cabinet-type element for stricter alignment
      const cabinetTypes = ['base-cabinet', 'drawer-base', 'sink-base', 'wall-cabinet',
                            'tall-cabinet', 'corner-cabinet', 'lazy-susan'];
      const isCabinetElement = cabinetTypes.includes(selectedElement.type);

      elements.forEach(other => {
        if (other.id === selectedElement.id) return;

        const otherX = other.x;
        const otherY = other.y;
        const otherW = other.width * pixelsPerFoot;
        const otherH = other.height * pixelsPerFoot;
        const isOtherCabinet = cabinetTypes.includes(other.type);

        // For cabinets, use tighter snap for edge-to-edge (butt joints)
        const edgeSnapDist = isCabinetElement ? pixelsPerFoot * 0.5 : snapDistance;

        // When both are cabinets, use much larger snap distance for forming runs
        const cabinetRunSnapDist = (isCabinetElement && isOtherCabinet) ? pixelsPerFoot * 0.8 : edgeSnapDist;

        // Snap right edge of selected to left edge of other (place side by side)
        if (Math.abs((snapX + elW) - otherX) < cabinetRunSnapDist) {
          snapX = otherX - elW;
          // When cabinets snap side-by-side, also align their tops to form a run
          if (isCabinetElement && isOtherCabinet) {
            snapY = otherY;
          }
        }
        // Snap left edge of selected to right edge of other
        if (Math.abs(snapX - (otherX + otherW)) < cabinetRunSnapDist) {
          snapX = otherX + otherW;
          // When cabinets snap side-by-side, also align their tops to form a run
          if (isCabinetElement && isOtherCabinet) {
            snapY = otherY;
          }
        }
        // Snap bottom edge of selected to top edge of other
        if (Math.abs((snapY + elH) - otherY) < edgeSnapDist) {
          snapY = otherY - elH;
        }
        // Snap top edge of selected to bottom edge of other
        if (Math.abs(snapY - (otherY + otherH)) < edgeSnapDist) {
          snapY = otherY + otherH;
        }

        // Align tops when close (for cabinet runs along a wall)
        if (Math.abs(snapY - otherY) < snapDistance) {
          snapY = otherY;
        }
        // Align bottoms when close
        if (Math.abs((snapY + elH) - (otherY + otherH)) < snapDistance) {
          snapY = otherY + otherH - elH;
        }
        // Align lefts when close
        if (Math.abs(snapX - otherX) < snapDistance) {
          snapX = otherX;
        }
        // Align rights when close
        if (Math.abs((snapX + elW) - (otherX + otherW)) < snapDistance) {
          snapX = otherX + otherW - elW;
        }
      });

      // Wall snapping for cabinets and countertops
      const wallSnapDistance = pixelsPerFoot * 0.75; // Snap within 0.75 feet of walls (increased for easier snapping)
      const isCabinetType = ['base-cabinet', 'wall-cabinet', 'tall-cabinet', 'corner-cabinet',
                             'drawer-base', 'sink-base', 'lazy-susan',
                             'island', 'countertop', 'sink', 'stove', 'dishwasher',
                             'refrigerator', 'oven'].includes(selectedElement.type);

      // Track which wall we're snapping to for auto-rotation
      let snappedToWall = null;

      if (isCabinetType) {
        // Room boundary walls (in pixels)
        const roomLeftWall = 0;
        const roomTopWall = 0; // Back wall in 3D view
        const roomRightWall = roomWidth * pixelsPerFoot;
        const roomBottomWall = roomDepth * pixelsPerFoot;

        // Snap to back wall (top of 2D canvas = back wall in 3D)
        if (Math.abs(snapY - roomTopWall) < wallSnapDistance) {
          snapY = roomTopWall;
          snappedToWall = 'back';
        }

        // Snap to left wall
        if (Math.abs(snapX - roomLeftWall) < wallSnapDistance) {
          snapX = roomLeftWall;
          snappedToWall = 'left';
        }

        // Snap to right wall (right edge of element to wall)
        if (Math.abs((snapX + elW) - roomRightWall) < wallSnapDistance) {
          snapX = roomRightWall - elW;
          snappedToWall = 'right';
        }

        // Snap to front (bottom edge in 2D - not usually needed but available)
        if (Math.abs((snapY + elH) - roomBottomWall) < wallSnapDistance) {
          snapY = roomBottomWall - elH;
          snappedToWall = 'front';
        }

        // Auto-rotate cabinets so their FRONT (doors) faces INTO the room
        // Only rotate ONCE when first snapping to a different wall
        const autoRotateTypes = ['base-cabinet', 'wall-cabinet', 'tall-cabinet', 'drawer-base', 'sink-base',
                                  'sink', 'stove', 'dishwasher', 'oven'];
        // Note: refrigerator removed from auto-rotate - users can place it any direction

        // Only apply rotation if this is a NEW wall snap (different from last)
        if (snappedToWall && snappedToWall !== lastSnappedWall && autoRotateTypes.includes(selectedElement.type)) {
          lastSnappedWall = snappedToWall;

          // Cabinet BACK goes against wall, FRONT (doors) faces into room
          // rotation=0: front faces DOWN, rotation=90: front faces LEFT
          // rotation=180: front faces UP, rotation=270: front faces RIGHT
          let targetRotation;
          switch(snappedToWall) {
            case 'back':
              targetRotation = 0;
              break;
            case 'left':
              targetRotation = 270;
              break;
            case 'right':
              targetRotation = 90;
              break;
            case 'front':
              targetRotation = 180;
              break;
            default:
              targetRotation = selectedElement.rotation || 0;
          }

          selectedElement.rotation = targetRotation;
          showSnapFeedback(`Snapped to ${snappedToWall} wall`);
        } else if (!snappedToWall) {
          // Reset when not snapped to any wall
          lastSnappedWall = null;
        }

        // Snap to custom drawn walls
        walls.forEach(wall => {
          const wallLeft = wall.x;
          const wallTop = wall.y;
          const wallRight = wall.x + wall.width;
          const wallBottom = wall.y + wall.height;

          // Determine if wall is horizontal or vertical based on aspect ratio
          const isVerticalWall = wall.height > wall.width;

          if (isVerticalWall) {
            // Snap element's right edge to wall's left edge
            if (Math.abs((snapX + elW) - wallLeft) < wallSnapDistance) {
              snapX = wallLeft - elW;
            }
            // Snap element's left edge to wall's right edge
            if (Math.abs(snapX - wallRight) < wallSnapDistance) {
              snapX = wallRight;
            }
          } else {
            // Horizontal wall
            // Snap element's bottom edge to wall's top edge
            if (Math.abs((snapY + elH) - wallTop) < wallSnapDistance) {
              snapY = wallTop - elH;
            }
            // Snap element's top edge to wall's bottom edge
            if (Math.abs(snapY - wallBottom) < wallSnapDistance) {
              snapY = wallBottom;
            }
          }
        });

        // Special corner snap for corner cabinets and lazy-susan
        const isCornerCabinet = ['corner-cabinet', 'lazy-susan'].includes(selectedElement.type);
        if (isCornerCabinet) {
          const cornerSnapDistance = pixelsPerFoot * 1.0; // Larger snap distance for corners

          // Check if near top-left corner (back-left in 3D)
          if (Math.abs(snapX - roomLeftWall) < cornerSnapDistance &&
              Math.abs(snapY - roomTopWall) < cornerSnapDistance) {
            snapX = roomLeftWall;
            snapY = roomTopWall;
            selectedElement.rotation = 0; // L opens toward front-right
            showSnapFeedback('Corner Snap: Back-Left');
          }
          // Check if near top-right corner (back-right in 3D)
          else if (Math.abs((snapX + elW) - roomRightWall) < cornerSnapDistance &&
                   Math.abs(snapY - roomTopWall) < cornerSnapDistance) {
            snapX = roomRightWall - elW;
            snapY = roomTopWall;
            selectedElement.rotation = 270; // L opens toward front-left
            showSnapFeedback('Corner Snap: Back-Right');
          }
          // Check if near bottom-left corner (front-left in 3D)
          else if (Math.abs(snapX - roomLeftWall) < cornerSnapDistance &&
                   Math.abs((snapY + elH) - roomBottomWall) < cornerSnapDistance) {
            snapX = roomLeftWall;
            snapY = roomBottomWall - elH;
            selectedElement.rotation = 90; // L opens toward back-right
            showSnapFeedback('Corner Snap: Front-Left');
          }
          // Check if near bottom-right corner (front-right in 3D)
          else if (Math.abs((snapX + elW) - roomRightWall) < cornerSnapDistance &&
                   Math.abs((snapY + elH) - roomBottomWall) < cornerSnapDistance) {
            snapX = roomRightWall - elW;
            snapY = roomBottomWall - elH;
            selectedElement.rotation = 180; // L opens toward back-left
            showSnapFeedback('Corner Snap: Front-Right');
          }
        }

        // Cabinet-to-cabinet alignment for L and U shaped runs
        // Find adjacent cabinets and align depth with them
        const adjacentCabinets = elements.filter(el => {
          if (el === selectedElement) return false;
          if (!['base-cabinet', 'wall-cabinet', 'tall-cabinet', 'drawer-base', 'sink-base'].includes(el.type)) return false;

          const elX = el.x;
          const elY = el.y;
          const elRight = elX + el.width * pixelsPerFoot;
          const elBottom = elY + el.height * pixelsPerFoot;

          // Check if horizontally adjacent (within 0.5 feet)
          const horizGap = Math.min(
            Math.abs(snapX - elRight),
            Math.abs((snapX + elW) - elX)
          );

          // Check if vertically adjacent
          const vertGap = Math.min(
            Math.abs(snapY - elBottom),
            Math.abs((snapY + elH) - elY)
          );

          return horizGap < pixelsPerFoot * 0.5 || vertGap < pixelsPerFoot * 0.5;
        });

        // If there are adjacent cabinets, help align for L-shape connections
        if (adjacentCabinets.length > 0) {
          adjacentCabinets.forEach(adj => {
            const adjRight = adj.x + adj.width * pixelsPerFoot;
            const adjBottom = adj.y + adj.height * pixelsPerFoot;

            // Snap to form perpendicular L-connection
            // If adjacent cabinet is horizontal (on back wall), connect vertically (on side wall)
            if (Math.abs(adj.y - roomTopWall) < wallSnapDistance) {
              // Adjacent is on back wall, snap our top to their bottom for L
              if (Math.abs(snapY - adjBottom) < pixelsPerFoot * 0.5) {
                snapY = adjBottom;
              }
            }

            // If we're forming an L, snap our edge to their edge
            if (Math.abs(snapX - adjRight) < pixelsPerFoot * 0.3) {
              snapX = adjRight;
            }
            if (Math.abs((snapX + elW) - adj.x) < pixelsPerFoot * 0.3) {
              snapX = adj.x - elW;
            }
          });
        }
      }

      // Allow elements to be placed anywhere (no canvas boundary restriction)
      selectedElement.x = snapX;
      selectedElement.y = snapY;

      draw();
    }

    function onMouseUp(e) {
      // End room resizing
      if (isResizingRoom) {
        isResizingRoom = false;
        roomResizeHandle = null;
        canvas.style.cursor = 'default';

        // Update 3D if in 3D view
        if (currentView === '3d') {
          init3D();
          render3D();
        }

        saveUndoState();
        showSnapFeedback(`Room size: ${roomWidth}' Ã— ${roomDepth}'`);
        return;
      }

      // End resizing
      if (isResizing) {
        isResizing = false;
        resizeHandle = null;
        canvas.style.cursor = 'default';
        calculateQuote();
        saveUndoState();
        return;
      }

      if (isPanning) {
        isPanning = false;
        canvas.style.cursor = currentTool === 'pan' ? 'grab' : (currentTool === 'wall' ? 'crosshair' : 'default');
        return;
      }

      if (isDrawingWall && wallStart) {
        const rect = canvas.getBoundingClientRect();
        const screenX = e.clientX - rect.left;
        const screenY = e.clientY - rect.top;
        const { x, y } = screenToWorld(screenX, screenY);

        const wx = Math.min(wallStart.x, x);
        const wy = Math.min(wallStart.y, y);
        let ww = Math.abs(x - wallStart.x);
        let wh = Math.abs(y - wallStart.y);

        // Make it a proper wall (thin in one dimension)
        if (ww < wh) {
          ww = CONFIG.WALL_THICKNESS;
        } else {
          wh = CONFIG.WALL_THICKNESS;
        }

        if (ww > 10 || wh > 10) {
          addWall(wx, wy, ww, wh);
          saveUndoState();
        }

        isDrawingWall = false;
        wallStart = null;
        draw();
        return;
      }

      if (isDrawingCountertop && countertopStart) {
        const rect = canvas.getBoundingClientRect();
        const screenX = e.clientX - rect.left;
        const screenY = e.clientY - rect.top;
        const { x, y } = screenToWorld(screenX, screenY);

        const cx = Math.min(countertopStart.x, x);
        const cy = Math.min(countertopStart.y, y);
        let cw = Math.abs(x - countertopStart.x);
        let ch = Math.abs(y - countertopStart.y);

        // Minimum size of 1 foot
        if (cw < pixelsPerFoot) cw = pixelsPerFoot * 2;
        if (ch < pixelsPerFoot) ch = pixelsPerFoot * 2;

        // Create countertop element
        const countertop = {
          id: 'countertop-' + Date.now(),
          type: 'countertop',
          x: cx,
          y: cy,
          width: cw / pixelsPerFoot,
          height: ch / pixelsPerFoot,
          color: '#708090',
          label: 'Countertop',
          rotation: 0,
          locked: false
        };

        elements.push(countertop);
        selectedElement = countertop;
        calculateQuote();
        saveUndoState();

        isDrawingCountertop = false;
        countertopStart = null;
        draw();
        updateProperties();
        return;
      }

      // Handle layout brush release
      if (currentTool === 'layout' && layoutMode.isDrawing) {
        finishLayoutDraw();
        return;
      }

      // Save undo state if we were dragging an element
      if (isDragging && selectedElement) {
        saveUndoState();
      }

      isDragging = false;
    }

    function onContextMenu(e) {
      e.preventDefault();

      const rect = canvas.getBoundingClientRect();
      const screenX = e.clientX - rect.left;
      const screenY = e.clientY - rect.top;
      const { x, y } = screenToWorld(screenX, screenY);

      const clicked = [...elements].reverse().find(el => isPointInElement(x, y, el));

      if (clicked) {
        selectedElement = clicked;
        contextMenuElement = clicked;
        showContextMenu(e.clientX, e.clientY, clicked);
        draw();
      }
    }

    function onDoubleClick(e) {
      // If in layout mode, finalize the cabinet run
      if (currentTool === 'layout' && layoutMode.points.length >= 2) {
        finalizeLayoutRun();
        return;
      }

      const rect = canvas.getBoundingClientRect();
      const screenX = e.clientX - rect.left;
      const screenY = e.clientY - rect.top;
      const { x, y } = screenToWorld(screenX, screenY);

      const clicked = [...elements].reverse().find(el => isPointInElement(x, y, el));

      if (clicked) {
        const newLabel = prompt('Enter label:', clicked.label);
        if (newLabel) {
          clicked.label = newLabel;
          draw();
        }
      }
    }

    function isPointInElement(px, py, el) {
      const w = el.width * pixelsPerFoot;
      const h = el.height * pixelsPerFoot;
      const rotation = (el.rotation || 0) * Math.PI / 180;

      // If no rotation, use simple bounds check
      if (rotation === 0) {
        return px >= el.x && px <= el.x + w && py >= el.y && py <= el.y + h;
      }

      // For rotated elements, transform the click point to element's local space
      const cx = el.x + w / 2;
      const cy = el.y + h / 2;

      // Translate point to origin (element center)
      const dx = px - cx;
      const dy = py - cy;

      // Rotate point in opposite direction to get local coordinates
      const cosR = Math.cos(-rotation);
      const sinR = Math.sin(-rotation);
      const localX = dx * cosR - dy * sinR;
      const localY = dx * sinR + dy * cosR;

      // Check if local point is within unrotated bounds (centered at origin)
      return localX >= -w/2 && localX <= w/2 && localY >= -h/2 && localY <= h/2;
    }

    // ===== KEYBOARD EVENTS =====
    let spacePressed = false;

    function onKeyDown(e) {
      if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') return;

      // Space to pan
      if (e.code === 'Space' && !spacePressed) {
        spacePressed = true;
        canvas.style.cursor = 'grab';
        e.preventDefault();
        return;
      }

      switch(e.key.toLowerCase()) {
        case 'v': setTool('select'); break;
        case 'w': setTool('wall'); break;
        case 'c': setTool('countertop'); break;
        case 'h': setTool('pan'); break;
        case 'l': setTool('layout'); break; // L for layout tool
        case 'f': fitToScreen(); break; // F to fit
        case 'delete':
        case 'backspace':
          if (selectedElement && !selectedElement.locked) {
            elements = elements.filter(el => el !== selectedElement);
            selectedElement = null;
            updateProperties();
            draw();
          }
          break;
        case 'r':
          if (selectedElement && !selectedElement.locked) {
            selectedElement.rotation = ((selectedElement.rotation || 0) + 90) % 360;
            updateProperties();
            draw();
          }
          break;
        case 'd':
          if ((e.ctrlKey || e.metaKey) && selectedElement) {
            e.preventDefault();
            duplicateElement(selectedElement);
          }
          break;
        case 'escape':
          // Cancel layout tool if active
          if (currentTool === 'layout' && layoutMode.points.length > 0) {
            layoutMode.points = [];
            showSnapFeedback('Layout cancelled');
          }
          selectedElement = null;
          hideContextMenu();
          updateProperties();
          draw();
          break;
        case '=':
        case '+':
          if (e.ctrlKey || e.metaKey) {
            e.preventDefault();
            zoomIn();
          }
          break;
        case '-':
          if (e.ctrlKey || e.metaKey) {
            e.preventDefault();
            zoomOut();
          }
          break;
        case '0':
          if (e.ctrlKey || e.metaKey) {
            e.preventDefault();
            fitToScreen();
          } else {
            // Plain 0 resets view
            resetView();
          }
          break;
        case 'home':
          // Home key resets view
          e.preventDefault();
          resetView();
          break;
      }
    }

    function onKeyUp(e) {
      if (e.code === 'Space') {
        spacePressed = false;
        canvas.style.cursor = currentTool === 'pan' ? 'grab' : (currentTool === 'wall' ? 'crosshair' : 'default');
      }
    }

    // Track if HTML5 drag is in progress
    let isHtmlDragging = false;

    // Mouse wheel zoom with throttling for smooth trackpad support
    let lastWheelTime = 0;
    let wheelAccumulator = 0;
    let wheelTimeout = null;

    function onWheel(e) {
      // Don't zoom if view is locked or during any drag operation
      if (viewLocked || isDragging || isResizing || isHtmlDragging || isPanning) {
        e.preventDefault();
        return;
      }

      e.preventDefault();

      const now = Date.now();
      const timeDelta = now - lastWheelTime;
      lastWheelTime = now;

      // Detect if this is a trackpad gesture (small, frequent deltas) or mouse wheel (larger, less frequent)
      const isTrackpad = Math.abs(e.deltaY) < 50 && timeDelta < 50;

      // Accumulate for trackpad, apply immediately for mouse wheel
      if (isTrackpad) {
        wheelAccumulator += e.deltaY;

        // Clear existing timeout
        if (wheelTimeout) clearTimeout(wheelTimeout);

        // Apply accumulated zoom after brief pause
        wheelTimeout = setTimeout(() => {
          applyZoom(wheelAccumulator, e.clientX, e.clientY);
          wheelAccumulator = 0;
        }, 16); // ~60fps
      } else {
        // Mouse wheel - apply immediately but with gentler factor
        applyZoom(e.deltaY, e.clientX, e.clientY);
      }
    }

    function applyZoom(deltaY, clientX, clientY) {
      // Safety check - don't zoom if values are invalid
      if (!isFinite(deltaY) || !isFinite(clientX) || !isFinite(clientY)) {
        wheelAccumulator = 0;
        return;
      }

      const rect = canvas.getBoundingClientRect();
      const mouseX = clientX - rect.left;
      const mouseY = clientY - rect.top;

      // Get world position before zoom
      const worldX = (mouseX - panX) / pixelsPerFoot;
      const worldY = (mouseY - panY) / pixelsPerFoot;

      // Safety check for world coordinates
      if (!isFinite(worldX) || !isFinite(worldY)) {
        wheelAccumulator = 0;
        return;
      }

      // Calculate zoom factor - gentler for accumulated trackpad gestures
      const normalizedDelta = Math.max(-100, Math.min(100, deltaY)); // Clamp extreme values
      const zoomFactor = normalizedDelta < 0 ? 1.08 : 0.92;
      const newPixelsPerFoot = Math.max(15, Math.min(100, pixelsPerFoot * zoomFactor));

      // Adjust pan to zoom toward mouse position
      const newPanX = mouseX - worldX * newPixelsPerFoot;
      const newPanY = mouseY - worldY * newPixelsPerFoot;

      // Safety check for new pan values
      if (!isFinite(newPanX) || !isFinite(newPanY)) {
        wheelAccumulator = 0;
        return;
      }

      panX = newPanX;
      panY = newPanY;

      pixelsPerFoot = newPixelsPerFoot;

      document.getElementById('scaleMode').value = 'fit'; // Reset dropdown
      document.getElementById('zoomLevel').textContent = Math.round(pixelsPerFoot / 40 * 100) + '%';

      draw();
    }

    // Reset view to default pan and zoom
    function resetView() {
      panX = 50;
      panY = 50;
      pixelsPerFoot = 40;
      wheelAccumulator = 0;
      if (wheelTimeout) {
        clearTimeout(wheelTimeout);
        wheelTimeout = null;
      }
      document.getElementById('scaleMode').value = 'fit';
      document.getElementById('zoomLevel').textContent = '100%';
      draw();
      showSnapFeedback('View reset');
    }

    // ===== DRAG & DROP =====
    function onDrop(e) {
      e.preventDefault();
      const rect = canvas.getBoundingClientRect();
      const screenX = e.clientX - rect.left;
      const screenY = e.clientY - rect.top;
      const { x, y } = screenToWorld(screenX, screenY);

      console.log('onDrop called at', x, y);

      // Check for element-type (sidebar elements)
      const type = e.dataTransfer.getData('element-type');
      if (type) {
        console.log('Creating element type:', type);
        createElement(type, x, y);
        return;
      }

      // Check for store product or other JSON data
      const jsonData = e.dataTransfer.getData('text/plain');
      console.log('JSON data from drop:', jsonData);
      if (jsonData) {
        try {
          const data = JSON.parse(jsonData);
          console.log('Parsed drop data:', data);
          if (data.type === 'store-product' && data.product) {
            console.log('Handling store product drop:', data.product.name);
            handleStoreProductDrop(data.product, x, y, e);
            return;
          }
        } catch (parseErr) {
          console.log('Not JSON data, ignoring');
        }
      }
    }

    // Handle dropping a store product onto the canvas or an element
    function handleStoreProductDrop(product, x, y, e) {
      console.log('handleStoreProductDrop called', { product: product.name, x, y });

      // Check if dropped on an existing element using world coordinates
      const hitElement = [...elements].reverse().find(el => isPointInElement(x, y, el));
      console.log('Hit element:', hitElement ? hitElement.type : 'none');

      if (hitElement) {
        // Apply product as material/texture to existing element
        console.log('Applying product to existing element');
        applyStoreProductToExistingElement(hitElement, product);
      } else {
        // Create a new element with the product
        console.log('Creating new element from product');
        createElementFromStoreProduct(product, x, y);
      }
    }

    // Apply store product to an existing element
    function applyStoreProductToExistingElement(element, product) {
      // Determine best element type match
      const productType = product.type?.toLowerCase() || '';

      // Get image URL - prefer primaryImage, fall back to images array or image property
      const imageUrl = product.primaryImage || product.images?.[0] || product.image;

      // Store product info on element
      element.storeProduct = {
        name: product.name,
        slug: product.slug,
        brand: product.brand,
        sku: product.sku,
        price: product.price,
        image: imageUrl
      };

      // Also store on element for material panel reference
      element.materialId = product.slug;
      element.materialName = product.name;
      element.materialBrand = product.brand;

      // Apply as texture if product has image
      if (imageUrl) {
        element.texture = imageUrl;
        element.textureImg = null; // Force reload

        console.log('Applying texture to element:', element.type, 'URL:', imageUrl);

        // Load texture image
        const img = new Image();
        img.crossOrigin = 'anonymous';
        img.onload = () => {
          element.textureImg = img;
          console.log('Texture loaded successfully for', element.type);
          draw();
          if (currentView === '3d') {
            console.log('Updating 3D scene with new texture');
            update3DScene();
          }
        };
        img.onerror = (err) => {
          console.warn('Failed to load texture for', element.type, ':', imageUrl, err);
        };
        img.src = imageUrl;
      }

      // Update price if product has price
      if (product.price) {
        element.priceOverride = parseFloat(product.price);
        element.costPrice = parseFloat(product.price);
      }

      // Update label
      element.label = product.name || element.label;

      selectedElement = element;
      updateProperties();
      draw();
      calculateQuote();

      showToast(`Applied ${product.name} to ${element.type}`, 'success');
    }

    // Create new element from store product
    function createElementFromStoreProduct(product, x, y) {
      console.log('createElementFromStoreProduct called', { product: product.name, x, y });
      const productType = product.type?.toLowerCase() || '';
      console.log('Product type:', productType);

      // Map product types to element types
      let elementType = 'stove'; // default fallback (valid appliance type)
      let width = 2.5;
      let height = 2;
      let color = '#4a90d9';

      if (productType.includes('sink')) {
        elementType = 'sink';
        width = 2.75;
        height = 1.75;
      } else if (productType.includes('faucet')) {
        elementType = 'sink'; // Use sink type for faucets
        width = 0.75;
        height = 0.5;
      } else if (productType.includes('range') || productType.includes('stove')) {
        elementType = 'stove';
        width = 2.5;
        height = 2.5;
      } else if (productType.includes('refrigerator') || productType.includes('fridge')) {
        elementType = 'refrigerator';
        width = 3;
        height = 3;
      } else if (productType.includes('dishwasher')) {
        elementType = 'dishwasher';
        width = 2;
        height = 2;
      } else if (productType.includes('microwave')) {
        elementType = 'microwave';
        width = 2;
        height = 1;
      } else if (productType.includes('hood') || productType.includes('vent')) {
        elementType = 'range-hood';
        width = 2.5;
        height = 1.5;
      } else if (productType.includes('cabinet')) {
        elementType = 'base-cabinet';
        width = 3;
        height = 2;
      } else if (productType.includes('countertop') || productType.includes('granite') || productType.includes('quartz')) {
        elementType = 'countertop';
        width = 4;
        height = 2;
      } else if (productType.includes('tile') || productType.includes('backsplash')) {
        elementType = 'backsplash';
        width = 4;
        height = 1.5;
      }

      // Find the color from ELEMENT_TYPES by searching all categories
      let foundColor = color;
      for (const category of Object.values(ELEMENT_TYPES)) {
        const found = category.find(e => e.type === elementType);
        if (found) {
          foundColor = found.color;
          break;
        }
      }

      const gridSnap = pixelsPerFoot / CONFIG.GRID_SUBDIVISIONS;
      const element = {
        id: Date.now() + Math.random(),
        type: elementType,
        x: Math.round(x / gridSnap) * gridSnap,
        y: Math.round(y / gridSnap) * gridSnap,
        width: width,
        height: height,
        color: foundColor,
        label: product.name || 'Store Product',
        rotation: 0,
        locked: false,
        storeProduct: {
          name: product.name,
          slug: product.slug,
          brand: product.brand,
          sku: product.sku,
          price: product.price,
          image: product.images?.[0] || product.image
        },
        priceOverride: product.price ? parseFloat(product.price) : null,
        costPrice: product.price ? parseFloat(product.price) : null,
        priceUnit: 'unit',
        marginPercent: null
      };

      // Apply texture from product image
      if (product.images?.[0] || product.image) {
        const imageUrl = product.images?.[0] || product.image;
        element.texture = imageUrl;

        const img = new Image();
        img.crossOrigin = 'anonymous';
        img.onload = () => {
          element.textureImg = img;
          draw();
          if (currentView === '3d') update3DScene();
        };
        img.src = imageUrl;
      }

      elements.push(element);
      console.log('Element created and added:', element);
      console.log('Total elements now:', elements.length);

      selectedElement = element;
      updateProperties();
      draw();
      calculateQuote();
      saveUndoState();

      showToast(`Added ${product.name} to design`, 'success');
    }

    function createElement(type, x, y) {
      let defaults = null;
      Object.values(ELEMENT_TYPES).forEach(cat => {
        const found = cat.find(el => el.type === type);
        if (found) defaults = found;
      });

      if (!defaults) return;

      const gridSnap = pixelsPerFoot / CONFIG.GRID_SUBDIVISIONS;
      const isCabinet = type.includes('cabinet');
      const element = {
        id: Date.now() + Math.random(),
        type: type,
        x: Math.round(x / gridSnap) * gridSnap,
        y: Math.round(y / gridSnap) * gridSnap,
        width: defaults.width,
        height: defaults.height,
        color: defaults.color,
        label: defaults.label,
        rotation: 0,
        locked: false,
        texture: elementTextures[type] || null,
        textureImg: null,
        floorLevel: cabinetSettings.currentFloor,
        // Cabinet-specific settings
        construction: isCabinet ? cabinetSettings.construction : undefined,
        doorStyle: isCabinet ? cabinetSettings.doorStyle : undefined,
        doorOverlay: isCabinet ? cabinetSettings.doorOverlay : undefined,
        // Pricing fields
        priceOverride: null,
        priceUnit: 'sqft',
        marginPercent: null,
        costPrice: null,
        retailPrice: null
      };

      // Load texture if exists
      if (element.texture) {
        const img = new Image();
        img.onload = () => {
          element.textureImg = img;
          draw();
        };
        img.src = element.texture;
      }

      elements.push(element);
      selectedElement = element;
      updateProperties();
      calculateQuote();
      saveUndoState();
      draw();
    }

    function duplicateElement(el) {
      const gridSnap = pixelsPerFoot / CONFIG.GRID_SUBDIVISIONS;
      const newEl = {
        ...el,
        id: Date.now() + Math.random(),
        x: el.x + gridSnap * 2,
        y: el.y + gridSnap * 2,
        locked: false
      };
      elements.push(newEl);
      selectedElement = newEl;
      updateProperties();
      calculateQuote();
      saveUndoState();
      draw();
    }

    // Quick action wrapper functions
    function duplicateSelectedElement() {
      if (selectedElement && !selectedElement.locked) {
        duplicateElement(selectedElement);
        showSnapFeedback('Element duplicated');
      }
    }

    function rotateSelectedElement(degrees) {
      if (selectedElement && !selectedElement.locked) {
        selectedElement.rotation = ((selectedElement.rotation || 0) + degrees) % 360;
        updateProperties();
        saveUndoState();
        draw();
        update3DScene();
        showSnapFeedback(`Rotated ${degrees}Â°`);
      }
    }

    function flipSelectedElement(axis) {
      if (selectedElement && !selectedElement.locked) {
        // Flip by swapping width/height for some types or adjusting position
        if (axis === 'h') {
          // Horizontal flip - mirror position relative to room center
          const centerX = roomWidth * pixelsPerFoot / 2;
          const elCenterX = selectedElement.x + (selectedElement.width * pixelsPerFoot) / 2;
          const newCenterX = centerX + (centerX - elCenterX);
          selectedElement.x = newCenterX - (selectedElement.width * pixelsPerFoot) / 2;
        } else {
          // Vertical flip
          const centerY = roomDepth * pixelsPerFoot / 2;
          const elCenterY = selectedElement.y + (selectedElement.height * pixelsPerFoot) / 2;
          const newCenterY = centerY + (centerY - elCenterY);
          selectedElement.y = newCenterY - (selectedElement.height * pixelsPerFoot) / 2;
        }
        saveUndoState();
        draw();
        update3DScene();
        showSnapFeedback(`Flipped ${axis === 'h' ? 'horizontally' : 'vertically'}`);
      }
    }

    function bringToFront() {
      if (selectedElement) {
        // Add positive zIndex offset to bring element to front of its layer
        selectedElement.zIndexOffset = (selectedElement.zIndexOffset || 0) + 100;
        saveUndoState();
        draw();
        update3DScene();
        showSnapFeedback('Brought to front');
      }
    }

    function sendToBack() {
      if (selectedElement) {
        // Add negative zIndex offset to push element behind others
        selectedElement.zIndexOffset = (selectedElement.zIndexOffset || 0) - 100;
        saveUndoState();
        draw();
        update3DScene();
        showSnapFeedback('Sent to back');
      }
    }

    function resetLayering() {
      if (selectedElement) {
        selectedElement.zIndexOffset = 0;
        saveUndoState();
        draw();
        update3DScene();
        showSnapFeedback('Layering reset');
      }
    }

    // ===== ITEM PICKER / QUOTE LIST =====
    let itemPickerFilter = 'all';
    let selectedItems = new Set(); // Track multi-selected items for bulk operations

    function updateItemPicker() {
      const listContainer = document.getElementById('itemPickerList');
      const totalDisplay = document.getElementById('itemPickerTotal');
      const itemCountDisplay = document.getElementById('itemCount');
      const subtotalDisplay = document.getElementById('itemSubtotal');

      if (!listContainer) return;

      // Filter elements based on current filter
      const filteredElements = elements.filter(el => {
        if (itemPickerFilter === 'all') return true;
        const category = getElementCategory(el.type);
        return category === itemPickerFilter;
      });

      // Calculate totals by category
      let totalPrice = 0;
      const categoryTotals = {
        cabinets: { count: 0, total: 0 },
        countertops: { count: 0, sqft: 0, total: 0 },
        appliances: { count: 0, total: 0 },
        fixtures: { count: 0, total: 0 },
        flooring: { count: 0, sqft: 0, total: 0 },
        other: { count: 0, total: 0 }
      };

      elements.forEach(el => {
        const price = calculateElementPrice(el);
        totalPrice += price;

        const cat = getElementCategory(el.type);
        const catKey = cat === 'countertops' || cat === 'flooring' ? cat :
                       cat === 'cabinets' ? 'cabinets' :
                       cat === 'appliances' ? 'appliances' :
                       cat === 'fixtures' || cat === 'bathroom' ? 'fixtures' : 'other';

        if (categoryTotals[catKey]) {
          categoryTotals[catKey].count++;
          categoryTotals[catKey].total += price;
          if (catKey === 'countertops' || catKey === 'flooring') {
            categoryTotals[catKey].sqft += (el.width * el.height);
          }
        }
      });

      // Update displays
      if (totalDisplay) totalDisplay.textContent = formatCurrency(totalPrice);
      if (itemCountDisplay) itemCountDisplay.textContent = elements.length;
      if (subtotalDisplay) subtotalDisplay.textContent = formatCurrency(totalPrice);

      // Update category summary
      const categorySummary = document.getElementById('itemCategorySummary');
      if (categorySummary) {
        let summaryHtml = '';
        if (categoryTotals.cabinets.count > 0) {
          summaryHtml += `<div class="summary-row"><span>Cabinets (${categoryTotals.cabinets.count})</span><span>${formatCurrency(categoryTotals.cabinets.total)}</span></div>`;
        }
        if (categoryTotals.countertops.count > 0) {
          summaryHtml += `<div class="summary-row"><span>Countertops (${categoryTotals.countertops.sqft.toFixed(1)} sqft)</span><span>${formatCurrency(categoryTotals.countertops.total)}</span></div>`;
        }
        if (categoryTotals.appliances.count > 0) {
          summaryHtml += `<div class="summary-row"><span>Appliances (${categoryTotals.appliances.count})</span><span>${formatCurrency(categoryTotals.appliances.total)}</span></div>`;
        }
        if (categoryTotals.fixtures.count > 0) {
          summaryHtml += `<div class="summary-row"><span>Fixtures (${categoryTotals.fixtures.count})</span><span>${formatCurrency(categoryTotals.fixtures.total)}</span></div>`;
        }
        if (categoryTotals.flooring.count > 0) {
          summaryHtml += `<div class="summary-row"><span>Flooring (${categoryTotals.flooring.sqft.toFixed(1)} sqft)</span><span>${formatCurrency(categoryTotals.flooring.total)}</span></div>`;
        }
        if (categoryTotals.other.count > 0) {
          summaryHtml += `<div class="summary-row"><span>Other (${categoryTotals.other.count})</span><span>${formatCurrency(categoryTotals.other.total)}</span></div>`;
        }
        categorySummary.innerHTML = summaryHtml;
      }

      // Build list HTML
      if (filteredElements.length === 0) {
        listContainer.innerHTML = `<div class="item-picker-empty">
          ${elements.length === 0 ? 'No items on canvas yet.<br>Drag elements from the left panel.' : 'No items match the filter.'}
        </div>`;
        return;
      }

      let html = '';
      filteredElements.forEach((el, idx) => {
        const isSelected = el === selectedElement;
        const isChecked = selectedItems.has(el.id);
        const typeName = formatElementType(el.type);
        const icon = getElementIcon(el.type);
        const price = calculateElementPrice(el);
        const dims = `${el.width.toFixed(1)}' Ã— ${el.height.toFixed(1)}'`;
        const area = (el.width * el.height).toFixed(1);
        const material = el.materialName || el.storeProduct?.name || '';
        const realIdx = elements.indexOf(el);

        // Get additional info for different element types
        const areaTypes = ['countertop', 'backsplash', 'flooring', 'tile', 'wall-tile', 'bar-top', 'wall-cap'];
        const cabinetTypes = ['base-cabinet', 'wall-cabinet', 'tall-cabinet', 'corner-cabinet', 'island', 'drawer-base', 'sink-base', 'lazy-susan'];

        let detailLine = '';
        if (cabinetTypes.includes(el.type)) {
          // Show SKU and catalog for cabinets
          if (el.sku) {
            detailLine = `<span class="item-sku">${el.sku}</span>`;
            if (el.catalog) {
              const catalogName = el.catalog.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
              detailLine += ` <span class="item-catalog">(${catalogName})</span>`;
            }
          }
        } else if (areaTypes.includes(el.type)) {
          // Show sqft and unit price for area-based items
          let unitPrice = 0;
          if (el.priceOverride) unitPrice = el.priceOverride;
          else if (el.storeProduct?.price) unitPrice = el.storeProduct.price;
          else if (el.materialId && typeof MATERIALS !== 'undefined') {
            for (const cat in MATERIALS) {
              const mat = MATERIALS[cat].find(m => m.id === el.materialId);
              if (mat && (mat.price || mat.pricePerSqFt)) { unitPrice = mat.price || mat.pricePerSqFt; break; }
            }
          }
          else if (typeof CONFIG !== 'undefined') unitPrice = CONFIG.PRICING?.[el.type] || 0;

          detailLine = `<span class="item-sqft">${area} sqft</span>`;
          if (unitPrice > 0) detailLine += ` <span class="item-rate">@ $${unitPrice.toFixed(2)}/sqft</span>`;
        }

        html += `
          <div class="item-picker-item ${isSelected ? 'selected' : ''}"
               onclick="selectItemFromPicker(${realIdx})"
               data-id="${el.id}">
            <div class="item-row-main">
              <input type="checkbox" class="item-checkbox"
                     ${isChecked ? 'checked' : ''}
                     onclick="event.stopPropagation(); toggleItemSelection('${el.id}')">
              <div class="item-icon">${icon}</div>
              <div class="item-details">
                <div class="item-name">${el.label || typeName}</div>
                <div class="item-meta">
                  <span>${dims}</span>
                  ${!areaTypes.includes(el.type) ? `<span>${area} sq ft</span>` : ''}
                </div>
                ${detailLine ? `<div class="item-detail-line">${detailLine}</div>` : ''}
              </div>
              <div class="item-price">${price > 0 ? formatCurrency(price) : '--'}</div>
            </div>
            ${material ? `<div class="item-row-secondary">
              <span class="item-material">${material}</span>
              <span class="item-dims">Layer ${realIdx + 1}</span>
            </div>` : ''}
          </div>
        `;
      });

      listContainer.innerHTML = html;
    }

    function getElementCategory(type) {
      const categories = {
        cabinets: ['base-cabinet', 'wall-cabinet', 'tall-cabinet', 'corner-cabinet', 'island', 'drawer-base', 'sink-base', 'lazy-susan'],
        countertops: ['countertop', 'backsplash', 'bar-top', 'wall-cap'],
        appliances: ['stove', 'range', 'cooktop', 'refrigerator', 'dishwasher', 'microwave', 'oven', 'range-hood'],
        sinks: ['sink', 'sink-double', 'sink-farmhouse'],
        flooring: ['flooring', 'tile', 'shower-pan'],
        fixtures: ['toilet', 'bathtub', 'bathtub-freestanding', 'shower', 'vanity', 'faucet', 'grab-bar', 'shower-bench', 'towel-warmer'],
        bathroom: ['vanity-24', 'vanity-30', 'vanity-36', 'vanity-48', 'vanity-60', 'vanity-72'],
        laundry: ['washer', 'dryer', 'utility-sink', 'laundry-sink', 'drying-rack'],
        closet: ['closet-rod', 'closet-shelf', 'drawer-unit', 'shoe-rack', 'closet-island', 'jewelry-cabinet'],
        windows: ['window', 'window-large', 'window-bay', 'bay-window', 'picture-window'],
        doors: ['door', 'double-door', 'sliding-door', 'french-door', 'glass-door'],
        walls: ['wall', 'pony-wall', 'pony-wall-bar', 'knee-wall', 'accent-wall', 'wall-tile', 'shower-wall'],
        niches: ['wall-niche', 'shower-niche', 'fireplace-niche', 'tv-niche', 'niche-surround', 'fireplace-surround'],
        structural: ['steel-beam', 'wood-beam', 'concrete-beam', 'header', 'lvl-beam', 'steel-column', 'wood-post', 'concrete-column']
      };

      for (const [cat, types] of Object.entries(categories)) {
        if (types.includes(type)) return cat;
      }
      return 'other';
    }

    function getElementIcon(type) {
      const icons = {
        // Cabinets
        'base-cabinet': 'ðŸ—„ï¸',
        'wall-cabinet': 'ðŸ“¦',
        'tall-cabinet': 'ðŸšª',
        'fridge-cabinet': 'ðŸ§Š',
        'corner-cabinet': 'ðŸ“',
        'island': 'ðŸï¸',
        'drawer-base': 'ðŸ—„ï¸',
        'sink-base': 'ðŸ—„ï¸',
        'lazy-susan': 'ðŸ“',
        // Surfaces
        'countertop': 'â¬œ',
        'backsplash': 'ðŸ§±',
        'bar-top': 'â¬œ',
        'wall-cap': 'â¬œ',
        // Sinks
        'sink': 'ðŸš°',
        'sink-double': 'ðŸš°',
        'sink-farmhouse': 'ðŸš°',
        // Appliances
        'stove': 'ðŸ”¥',
        'range': 'ðŸ”¥',
        'cooktop': 'ðŸ”¥',
        'refrigerator': 'ðŸ§Š',
        'dishwasher': 'ðŸ½ï¸',
        'microwave': 'ðŸ“»',
        'oven': 'ðŸ”²',
        'range-hood': 'ðŸ’¨',
        // Flooring
        'flooring': 'ðŸŸ«',
        'tile': 'ðŸ”²',
        'shower-pan': 'ðŸŸ«',
        // Windows/Doors
        'window': 'ðŸªŸ',
        'window-large': 'ðŸªŸ',
        'window-bay': 'ðŸªŸ',
        'bay-window': 'ðŸªŸ',
        'picture-window': 'ðŸªŸ',
        'door': 'ðŸšª',
        'double-door': 'ðŸšª',
        'sliding-door': 'ðŸšª',
        'french-door': 'ðŸšª',
        'glass-door': 'ðŸšª',
        // Walls
        'wall': 'ðŸ§±',
        'pony-wall': 'ðŸ§±',
        'pony-wall-bar': 'ðŸ§±',
        'knee-wall': 'ðŸ§±',
        'accent-wall': 'ðŸ§±',
        'wall-tile': 'ðŸ§±',
        'shower-wall': 'ðŸ§±',
        // Bathroom
        'toilet': 'ðŸš½',
        'bathtub': 'ðŸ›',
        'bathtub-freestanding': 'ðŸ›',
        'shower': 'ðŸš¿',
        'shower-bench': 'ðŸª‘',
        'towel-warmer': 'ðŸ”¥',
        'grab-bar': 'ðŸ›¡ï¸',
        'vanity': 'ðŸªž',
        'vanity-24': 'ðŸªž',
        'vanity-30': 'ðŸªž',
        'vanity-36': 'ðŸªž',
        'vanity-48': 'ðŸªž',
        'vanity-60': 'ðŸªž',
        'vanity-72': 'ðŸªž',
        // Laundry
        'washer': 'ðŸ§º',
        'dryer': 'ðŸŒ€',
        'utility-sink': 'ðŸš°',
        'laundry-sink': 'ðŸš°',
        'drying-rack': 'ðŸ§¥',
        // Closet
        'closet-rod': 'ðŸª',
        'closet-shelf': 'ðŸ“š',
        'drawer-unit': 'ðŸ—„ï¸',
        'shoe-rack': 'ðŸ‘Ÿ',
        'closet-island': 'ðŸï¸',
        'jewelry-cabinet': 'ðŸ’Ž',
        // Niches
        'wall-niche': 'ðŸ•³ï¸',
        'shower-niche': 'ðŸ•³ï¸',
        'fireplace-niche': 'ðŸ”¥',
        'tv-niche': 'ðŸ“º',
        'niche-surround': 'ðŸ–¼ï¸',
        'fireplace-surround': 'ðŸ”¥',
        // Structural
        'steel-beam': 'ðŸ”©',
        'wood-beam': 'ðŸªµ',
        'concrete-beam': 'ðŸ§±',
        'header': 'ðŸ“',
        'lvl-beam': 'ðŸªµ',
        'steel-column': 'ðŸ”©',
        'wood-post': 'ðŸªµ',
        'concrete-column': 'ðŸ§±'
      };
      return icons[type] || 'ðŸ“¦';
    }

    function calculateElementPrice(el) {
      // Use the comprehensive getElementPrice function (defined later in file)
      // This function is called after all main functions are defined

      // Get price info using the comprehensive pricing system
      let priceInfo = { price: 0, source: 'default' };

      // 1) Manual override takes highest priority
      if (el.priceOverride !== null && el.priceOverride !== undefined) {
        priceInfo = { price: el.priceOverride, source: 'override' };
      }
      // 2) Check for cabinet catalog pricing (by SKU)
      else if (el.sku && el.catalog && typeof CABINET_CATALOGS !== 'undefined') {
        const catalog = CABINET_CATALOGS[el.catalog];
        if (catalog) {
          for (const category of Object.values(catalog.cabinets)) {
            const cab = category.find(c => c.sku === el.sku);
            if (cab && cab.price) {
              priceInfo = { price: cab.price, source: 'catalog' };
              break;
            }
          }
        }
      }
      // 3) Check store product price
      else if (el.storeProduct?.price) {
        priceInfo = { price: el.storeProduct.price, source: 'product' };
      }
      // 4) Check for material-specific pricing
      else if (el.materialId && typeof MATERIALS !== 'undefined') {
        for (const category in MATERIALS) {
          const mat = MATERIALS[category].find(m => m.id === el.materialId);
          if (mat && (mat.price || mat.pricePerSqFt)) {
            priceInfo = { price: mat.price || mat.pricePerSqFt, source: 'material' };
            break;
          }
        }
      }
      // 5) Check element's own pricePerSqFt
      else if (el.pricePerSqFt) {
        priceInfo = { price: el.pricePerSqFt, source: 'element' };
      }
      // 6) Check element's own price property
      else if (el.price) {
        priceInfo = { price: el.price, source: 'element' };
      }
      // 7) Check custom prices from Excel import
      else if (el.materialId && typeof PRICING_STATE !== 'undefined' && PRICING_STATE.customPrices?.[el.materialId]) {
        priceInfo = { price: PRICING_STATE.customPrices[el.materialId], source: 'pricelist' };
      }
      // 8) Fall back to default type pricing
      else if (typeof CONFIG !== 'undefined' && CONFIG.PRICING?.[el.type]) {
        priceInfo = { price: CONFIG.PRICING[el.type], source: 'default' };
      }

      let baseCost = priceInfo.price;

      // Calculate based on area for surface elements
      const areaTypes = ['countertop', 'backsplash', 'flooring', 'tile', 'wall-tile', 'bar-top', 'wall-cap'];
      if (areaTypes.includes(el.type)) {
        const area = el.width * el.height;
        baseCost = area * priceInfo.price;
      }

      // Get margin for retail pricing
      let margin = 30; // Default margin
      if (typeof PRICING_STATE !== 'undefined') {
        if (el.marginPercent !== null && el.marginPercent !== undefined) {
          margin = el.marginPercent;
        } else {
          // Get category-specific margin
          const cat = getElementCategory(el.type);
          const catMargins = { cabinets: 25, countertops: 35, appliances: 15, flooring: 30 };
          margin = PRICING_STATE.categoryMargins?.[cat] || catMargins[cat] || PRICING_STATE.globalMargin || 30;
        }
      }

      // Return retail price (cost + margin)
      return baseCost * (1 + margin / 100);
    }

    function formatCurrency(amount) {
      return '$' + amount.toFixed(2).replace(/\B(?=(\d{3})+(?!\d))/g, ',');
    }

    function selectItemFromPicker(idx) {
      if (idx >= 0 && idx < elements.length) {
        selectedElement = elements[idx];
        expandedElementType = selectedElement.type;
        updateProperties();
        updateElementSelector();
        updateItemPicker();
        draw();
      }
    }

    function toggleItemSelection(id) {
      if (selectedItems.has(id)) {
        selectedItems.delete(id);
      } else {
        selectedItems.add(id);
      }
      updateItemPicker();
    }

    function selectAllItems() {
      elements.forEach(el => selectedItems.add(el.id));
      updateItemPicker();
    }

    function deselectAllItems() {
      selectedItems.clear();
      updateItemPicker();
    }

    function deleteSelectedItems() {
      if (selectedItems.size === 0) {
        showToast('No items selected', 'warning');
        return;
      }

      const count = selectedItems.size;
      elements = elements.filter(el => !selectedItems.has(el.id));
      selectedItems.clear();
      selectedElement = null;

      saveUndoState();
      updateProperties();
      updateElementList();
      updateItemPicker();
      draw();
      showToast(`Deleted ${count} item${count > 1 ? 's' : ''}`, 'success');
    }

    function filterItemList() {
      const filterSelect = document.getElementById('itemFilterType');
      itemPickerFilter = filterSelect ? filterSelect.value : 'all';
      updateItemPicker();
    }

    // Update element layer list panel
    function updateElementList() {
      const listContainer = document.getElementById('elementLayerList');
      const countDisplay = document.getElementById('elementCountDisplay');
      if (!listContainer) return;

      // Update count
      if (countDisplay) countDisplay.textContent = elements.length;

      // Also update the element selector dropdown and item picker
      updateElementSelector();
      updateItemPicker();

      // Build list HTML
      if (elements.length === 0) {
        listContainer.innerHTML = '<div style="color: #888; padding: 8px; text-align: center;">No elements yet</div>';
        return;
      }

      // Sort by z-order for display
      const sortedElements = [...elements].sort((a, b) => {
        const aZ = (a.zIndexOffset || 0);
        const bZ = (b.zIndexOffset || 0);
        return bZ - aZ; // Higher z-index first
      });

      let html = '';
      sortedElements.forEach((el, idx) => {
        const isSelected = el === selectedElement;
        const label = el.label || el.materialName || formatElementType(el.type);
        const truncatedLabel = label.length > 20 ? label.substring(0, 18) + '...' : label;
        const layerNum = elements.length - idx;

        html += `
          <div class="element-layer-item ${isSelected ? 'selected' : ''}"
               onclick="selectElementFromList(${elements.indexOf(el)})"
               ondblclick="centerOnElement(${elements.indexOf(el)})"
               style="
                 display: flex;
                 align-items: center;
                 padding: 4px 8px;
                 cursor: pointer;
                 border-radius: 4px;
                 margin-bottom: 2px;
                 background: ${isSelected ? 'var(--gold)' : 'rgba(255,255,255,0.05)'};
                 color: ${isSelected ? '#000' : 'inherit'};
               ">
            <span style="
              width: 12px;
              height: 12px;
              border-radius: 2px;
              background: ${el.color || '#808080'};
              margin-right: 6px;
              flex-shrink: 0;
            "></span>
            <span style="flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">
              ${truncatedLabel}
            </span>
            <span style="font-size: 9px; color: ${isSelected ? '#333' : '#666'}; margin-left: 4px;">
              ${el.hidden ? 'ðŸ‘ï¸â€ðŸ—¨ï¸' : ''}
            </span>
          </div>
        `;
      });

      listContainer.innerHTML = html;
    }

    // Format element type for display
    function formatElementType(type) {
      return type.split('-').map(word =>
        word.charAt(0).toUpperCase() + word.slice(1)
      ).join(' ');
    }

    // Select element from the list
    function selectElementFromList(index) {
      if (index >= 0 && index < elements.length) {
        selectedElement = elements[index];
        updateProperties();
        updateElementList();
        updateElementSelector();
        draw();
      }
    }

    // Update the element selector dropdown in the right panel
    // Track which element type is currently expanded in the selector
    let expandedElementType = null;

    function updateElementSelector() {
      const flatList = document.getElementById('elementFlatList');
      const totalCount = document.getElementById('elementTotalCount');
      const actions = document.getElementById('elementSelectorActions');
      const filterSelect = document.getElementById('elementListFilter');

      if (!flatList) return;

      // Update total count
      if (totalCount) totalCount.textContent = elements.length;

      // Get current filter
      const filter = filterSelect ? filterSelect.value : 'all';

      // Filter elements
      const filteredElements = elements.filter(el => {
        if (filter === 'all') return true;
        const cat = getElementCategory(el.type);
        if (filter === 'cabinets') return cat === 'cabinets';
        if (filter === 'countertops') return cat === 'countertops';
        if (filter === 'appliances') return cat === 'appliances';
        if (filter === 'fixtures') return ['fixtures', 'bathroom'].includes(cat);
        return !['cabinets', 'countertops', 'appliances', 'fixtures', 'bathroom'].includes(cat);
      });

      // Build flat list
      if (elements.length === 0) {
        flatList.innerHTML = '<div class="no-elements-msg">No elements on canvas.<br>Drag items from the left panel.</div>';
        if (actions) actions.style.display = 'none';
        return;
      }

      if (filteredElements.length === 0) {
        flatList.innerHTML = '<div class="no-elements-msg">No elements match filter.</div>';
        if (actions) actions.style.display = 'none';
        return;
      }

      let html = '';
      filteredElements.forEach((el) => {
        const realIdx = elements.indexOf(el);
        const isSelected = selectedElement && selectedElement.id === el.id;
        const icon = getElementIcon(el.type);
        const typeName = el.type.replace(/-/g, ' ').replace(/\b\w/g, c => c.toUpperCase());
        const label = el.label || el.sku || typeName;
        const dims = `${el.width.toFixed(1)}' Ã— ${el.height.toFixed(1)}'`;
        const material = el.materialName || '';

        html += `
          <div class="element-list-item ${isSelected ? 'selected' : ''}"
               onclick="selectAndFocusElement(${realIdx})"
               ondblclick="centerOnElement(${realIdx})"
               data-idx="${realIdx}">
            <span class="element-list-icon">${icon}</span>
            <div class="element-list-info">
              <div class="element-list-name">${label}</div>
              <div class="element-list-meta">${dims}${material ? ' â€¢ ' + material : ''}</div>
            </div>
          </div>
        `;
      });

      flatList.innerHTML = html;

      // Show/hide actions based on selection
      if (actions) {
        actions.style.display = selectedElement ? 'flex' : 'none';
      }

      // Scroll selected element into view
      if (selectedElement) {
        const selectedItem = flatList.querySelector('.element-list-item.selected');
        if (selectedItem) {
          selectedItem.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }
      }
    }

    // Toggle element type expansion
    function toggleElementType(type) {
      if (expandedElementType === type) {
        // Collapse if already expanded
        expandedElementType = null;
      } else {
        // Expand this type
        expandedElementType = type;

        // Auto-select first element of this type if nothing selected
        const firstOfType = elements.find(el => el.type === type);
        if (firstOfType && (!selectedElement || selectedElement.type !== type)) {
          selectedElement = firstOfType;
          updateProperties();
          draw();
        }
      }
      updateElementSelector();
    }

    // Select element by index
    function selectElementByIndex(idx) {
      if (idx >= 0 && idx < elements.length) {
        selectedElement = elements[idx];
        expandedElementType = selectedElement.type;
        updateProperties();
        updateElementList();
        updateElementSelector();
        draw();
      }
    }

    // Select element and focus on it - called from element list
    function selectAndFocusElement(idx) {
      if (idx >= 0 && idx < elements.length) {
        selectedElement = elements[idx];
        expandedElementType = selectedElement.type;

        // Update UI
        updateProperties();
        updateElementList();
        updateElementSelector();
        updateItemPicker();
        draw();

        // Show a brief highlight effect on the canvas
        showSnapFeedback(`Selected: ${formatElementType(selectedElement.type)}`);
      }
    }

    // Handle selection from dropdown (legacy - keeping for compatibility)
    function selectElementFromDropdown() {
      // This function is now replaced by the type selector
      // Keeping for backward compatibility
      if (!selectedElement) return;
      updateProperties();
      updateElementList();
      draw();
    }

    // Focus/center view on selected element
    function focusSelectedElement() {
      if (!selectedElement) return;
      const idx = elements.indexOf(selectedElement);
      if (idx >= 0) {
        centerOnElement(idx);
      }
    }

    // Duplicate selected element
    function duplicateSelectedElement() {
      if (!selectedElement) return;
      const newEl = JSON.parse(JSON.stringify(selectedElement));
      newEl.id = Date.now() + Math.random();
      newEl.x += pixelsPerFoot * 0.5; // Offset slightly
      newEl.y += pixelsPerFoot * 0.5;
      elements.push(newEl);
      selectedElement = newEl;
      saveState();
      updateProperties();
      updateElementList();
      updateElementSelector();
      draw();
      showToast('Element duplicated');
    }

    // Delete selected element
    function deleteSelectedElement() {
      if (!selectedElement) return;
      const idx = elements.indexOf(selectedElement);
      if (idx >= 0) {
        elements.splice(idx, 1);
        selectedElement = null;
        saveState();
        updateProperties();
        updateElementList();
        updateElementSelector();
        draw();
        showToast('Element deleted');
      }
    }

    // Center view on element
    function centerOnElement(index) {
      if (index >= 0 && index < elements.length) {
        const el = elements[index];
        // Calculate center of element
        const centerX = el.x + (el.width * pixelsPerFoot) / 2;
        const centerY = el.y + (el.height * pixelsPerFoot) / 2;

        // Scroll canvas to center on element (if canvas is scrollable)
        const canvas = document.getElementById('canvas');
        if (canvas) {
          const container = canvas.parentElement;
          if (container) {
            container.scrollLeft = centerX - container.clientWidth / 2;
            container.scrollTop = centerY - container.clientHeight / 2;
          }
        }

        selectElementFromList(index);
        showSnapFeedback(`Centered on ${formatElementType(el.type)}`);
      }
    }

    // Move selected element up in layer order (higher z-index)
    function moveLayerUp() {
      if (selectedElement) {
        selectedElement.zIndexOffset = (selectedElement.zIndexOffset || 0) + 10;
        saveUndoState();
        draw();
        update3DScene();
        updateElementList();
        showSnapFeedback('Moved layer up');
      }
    }

    // Move selected element down in layer order (lower z-index)
    function moveLayerDown() {
      if (selectedElement) {
        selectedElement.zIndexOffset = (selectedElement.zIndexOffset || 0) - 10;
        saveUndoState();
        draw();
        update3DScene();
        updateElementList();
        showSnapFeedback('Moved layer down');
      }
    }

    function deleteSelectedElement() {
      if (selectedElement && !selectedElement.locked) {
        elements = elements.filter(el => el !== selectedElement);
        selectedElement = null;
        updateProperties();
        calculateQuote();
        saveUndoState();
        draw();
        update3DScene();
        showSnapFeedback('Element deleted');
      }
    }

    // ===== CONTEXT MENU =====
    function showContextMenu(x, y, element) {
      const menu = document.getElementById('contextMenu');
      menu.style.display = 'block';
      menu.style.left = x + 'px';
      menu.style.top = y + 'px';

      document.getElementById('contextMenuLabel').textContent = element.label;
      document.getElementById('lockText').textContent = element.locked ? 'Unlock' : 'Lock';
    }

    function hideContextMenu() {
      document.getElementById('contextMenu').style.display = 'none';
      contextMenuElement = null;
    }

    function contextAction(action) {
      if (!contextMenuElement) return;

      switch(action) {
        case 'rotate':
          if (!contextMenuElement.locked) {
            contextMenuElement.rotation = ((contextMenuElement.rotation || 0) + 90) % 360;
          }
          break;
        case 'duplicate':
          duplicateElement(contextMenuElement);
          break;
        case 'texture':
          selectedElement = contextMenuElement;
          openMaterialPicker();
          break;
        case 'lock':
          contextMenuElement.locked = !contextMenuElement.locked;
          break;
        case 'front':
          elements = elements.filter(el => el !== contextMenuElement);
          elements.push(contextMenuElement);
          break;
        case 'back':
          elements = elements.filter(el => el !== contextMenuElement);
          elements.unshift(contextMenuElement);
          break;
        case 'delete':
          if (!contextMenuElement.locked) {
            elements = elements.filter(el => el !== contextMenuElement);
            if (selectedElement === contextMenuElement) {
              selectedElement = null;
              updateProperties();
            }
          }
          break;
      }

      hideContextMenu();
      draw();
    }

    // ===== TOOLS =====
    function setTool(tool) {
      try {
        currentTool = tool;
        document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('active'));
        const btn = document.getElementById('tool' + tool.charAt(0).toUpperCase() + tool.slice(1));
        if (btn) btn.classList.add('active');

        // Show/hide layout options panel
        const layoutPanel = document.getElementById('layoutOptionsPanel');
        if (layoutPanel) {
          layoutPanel.style.display = tool === 'layout' ? 'block' : 'none';
        }

        // Reset layout mode when switching tools
        if (tool !== 'layout') {
          resetLayoutMode();
        }

        canvas.style.cursor = (tool === 'wall' || tool === 'countertop' || tool === 'layout') ? 'crosshair' : (tool === 'pan' ? 'grab' : 'default');
        draw();
      } catch (err) {
        console.error('setTool error:', err);
        currentTool = 'select';
      }
    }

    // Layout tool option handlers
    function updateLayoutElementType() {
      const select = document.getElementById('layoutElementType');
      layoutMode.cabinetType = select.value;

      // Auto-adjust depth based on element type
      const depthSelect = document.getElementById('layoutDepth');
      switch (select.value) {
        case 'wall-cabinet':
          depthSelect.value = '1';
          layoutMode.cabinetDepth = 1;
          break;
        case 'base-cabinet':
        case 'drawer-base':
        case 'sink-base':
        case 'corner-cabinet':
        case 'lazy-susan':
          depthSelect.value = '2';
          layoutMode.cabinetDepth = 2;
          break;
        case 'tall-cabinet':
        case 'fridge-cabinet':
          depthSelect.value = '2';
          layoutMode.cabinetDepth = 2;
          break;
        case 'pony-wall':
        case 'knee-wall':
        case 'wall':
          depthSelect.value = '0.5';
          layoutMode.cabinetDepth = 0.5;
          // Add wall thickness option if not present
          if (!depthSelect.querySelector('option[value="0.5"]')) {
            const opt = document.createElement('option');
            opt.value = '0.5';
            opt.textContent = '6" (Wall)';
            depthSelect.insertBefore(opt, depthSelect.firstChild);
          }
          break;
        case 'countertop':
        case 'backsplash':
          depthSelect.value = '2';
          layoutMode.cabinetDepth = 2;
          break;
      }

      showSnapFeedback(`Layout: ${select.options[select.selectedIndex].text}`);
    }

    function updateLayoutDepth() {
      const select = document.getElementById('layoutDepth');
      layoutMode.cabinetDepth = parseFloat(select.value);
      showSnapFeedback(`Depth: ${Math.round(layoutMode.cabinetDepth * 12)}"`);
    }

    function updateLayoutCountertop() {
      const checkbox = document.getElementById('layoutAddCountertop');
      layoutMode.addCountertop = checkbox.checked;
    }

    function updateLayoutWallSnap() {
      const checkbox = document.getElementById('layoutSnapToWalls');
      layoutMode.snapToWalls = checkbox.checked;
    }

    function updateLayoutCornerType() {
      const select = document.getElementById('layoutCornerType');
      layoutMode.cornerType = select.value;
      showSnapFeedback(`Corner: ${select.options[select.selectedIndex].text}`);
    }

    // ===== CABINET LAYOUT TOOL =====
    // ===== DRAFTING-STYLE LAYOUT BRUSH =====
    // Click-drag to draw straight orthogonal cabinet runs
    // Automatically creates corners when direction changes significantly
    const layoutMode = {
      isDrawing: false,     // Currently dragging
      corners: [],          // Corner points (where direction changes)
      currentEnd: null,     // Current endpoint (snapped to orthogonal)
      currentDirection: null, // 'horizontal' or 'vertical'
      points: [],           // Legacy array for backward compatibility
      active: false,        // Legacy flag
      cabinetType: 'base-cabinet',
      cabinetDepth: 2,      // 24" depth (standard base cabinet)
      cornerType: 'corner-cabinet', // How to handle corners
      addCountertop: false, // Don't auto-add countertop - user can add separately
      snapToWalls: true,    // Auto-snap to walls and room boundaries
      gridSnap: 0.5,        // Snap to 6" grid
      turnThreshold: 1.5,   // Feet of movement in perpendicular direction to trigger turn
      minRunLength: 1       // Minimum 1 foot run
    };

    // Snap a value to the grid
    function snapToGrid(val) {
      return Math.round(val / layoutMode.gridSnap) * layoutMode.gridSnap;
    }

    // Snap to walls - find nearest wall edge and snap to it if within threshold
    function snapToWalls(worldX, worldY, direction) {
      const snapThreshold = 1.0; // 1 foot snap threshold
      const depth = layoutMode.cabinetDepth || 2;
      let snappedX = worldX;
      let snappedY = worldY;
      let snappedToWall = null;

      // Get all wall-like elements (including room boundaries)
      const wallElements = elements.filter(el =>
        el.type === 'wall' ||
        el.type === 'pony-wall' ||
        el.type === 'knee-wall' ||
        el.type === 'pony-wall-bar'
      );

      // Also consider room boundaries as virtual walls
      const roomWalls = [
        { edge: 'top', y: 0, isHorizontal: true },
        { edge: 'bottom', y: roomDepth, isHorizontal: true },
        { edge: 'left', x: 0, isHorizontal: false },
        { edge: 'right', x: roomWidth, isHorizontal: false }
      ];

      // Check room boundaries first
      roomWalls.forEach(rw => {
        if (rw.isHorizontal) {
          // Top/bottom walls - snap Y position
          const distToWall = Math.abs(worldY - rw.y);
          const distWithDepth = Math.abs(worldY - depth/2 - rw.y);
          const distWithDepthOther = Math.abs(worldY + depth/2 - rw.y);

          if (distToWall < snapThreshold) {
            // Snap cabinet to be against this wall
            snappedY = rw.edge === 'top' ? depth/2 : rw.y - depth/2;
            snappedToWall = rw.edge + ' wall';
          } else if (distWithDepth < snapThreshold || distWithDepthOther < snapThreshold) {
            snappedY = rw.edge === 'top' ? depth/2 : rw.y - depth/2;
            snappedToWall = rw.edge + ' wall';
          }
        } else {
          // Left/right walls - snap X position
          const distToWall = Math.abs(worldX - rw.x);

          if (distToWall < snapThreshold) {
            snappedX = rw.edge === 'left' ? depth/2 : rw.x - depth/2;
            snappedToWall = rw.edge + ' wall';
          }
        }
      });

      // Check drawn walls
      wallElements.forEach(wall => {
        const wallX = wall.x / pixelsPerFoot;
        const wallY = wall.y / pixelsPerFoot;
        const wallW = wall.width;
        const wallH = wall.height;
        const wallCenterX = wallX + wallW/2;
        const wallCenterY = wallY + wallH/2;

        // Determine if wall is horizontal or vertical
        const wallIsHorizontal = wallW > wallH;

        if (wallIsHorizontal) {
          // Check if we're near the top or bottom edge of this horizontal wall
          const topEdge = wallY;
          const bottomEdge = wallY + wallH;

          // Snap to top edge (place cabinets above wall)
          if (Math.abs(worldY - topEdge) < snapThreshold) {
            snappedY = topEdge - depth/2;
            snappedToWall = wall.label || 'wall';
          }
          // Snap to bottom edge (place cabinets below wall)
          else if (Math.abs(worldY - bottomEdge) < snapThreshold) {
            snappedY = bottomEdge + depth/2;
            snappedToWall = wall.label || 'wall';
          }
        } else {
          // Check if we're near the left or right edge of this vertical wall
          const leftEdge = wallX;
          const rightEdge = wallX + wallW;

          // Snap to left edge
          if (Math.abs(worldX - leftEdge) < snapThreshold) {
            snappedX = leftEdge - depth/2;
            snappedToWall = wall.label || 'wall';
          }
          // Snap to right edge
          else if (Math.abs(worldX - rightEdge) < snapThreshold) {
            snappedX = rightEdge + depth/2;
            snappedToWall = wall.label || 'wall';
          }
        }
      });

      return {
        x: snapToGrid(snappedX),
        y: snapToGrid(snappedY),
        snappedTo: snappedToWall
      };
    }

    // Start drawing layout path on mouse down
    function startLayoutDraw(screenX, screenY) {
      try {
        const rawX = screenX / pixelsPerFoot;
        const rawY = screenY / pixelsPerFoot;

        let worldX, worldY;

        // Try to snap to nearby walls if enabled
        if (layoutMode.snapToWalls) {
          const snapped = snapToWalls(rawX, rawY, null);
          worldX = snapped.x;
          worldY = snapped.y;

          if (snapped.snappedTo) {
            showSnapFeedback(`Snapped to ${snapped.snappedTo}`);
          }
        } else {
          worldX = snapToGrid(rawX);
          worldY = snapToGrid(rawY);
        }

        layoutMode.isDrawing = true;
        layoutMode.corners = [{ x: worldX, y: worldY }];
        layoutMode.currentEnd = { x: worldX, y: worldY };
        layoutMode.currentDirection = null;

        canvas.style.cursor = 'crosshair';
        draw();
      } catch (err) {
        console.error('Layout startDraw error:', err);
        resetLayoutMode();
      }
    }

    // Reset layout mode to clean state
    function resetLayoutMode() {
      layoutMode.isDrawing = false;
      layoutMode.corners = [];
      layoutMode.currentEnd = null;
      layoutMode.currentDirection = null;
      layoutMode.active = false;
      layoutMode.points = [];
      canvas.style.cursor = currentTool === 'layout' ? 'crosshair' : 'default';
    }

    // Continue drawing layout path on mouse move
    function continueLayoutDraw(screenX, screenY) {
      try {
        if (!layoutMode.isDrawing) return;
        if (!layoutMode.corners || layoutMode.corners.length === 0) {
          resetLayoutMode();
          return;
        }

        const worldX = screenX / pixelsPerFoot;
        const worldY = screenY / pixelsPerFoot;

        const lastCorner = layoutMode.corners[layoutMode.corners.length - 1];
        if (!lastCorner) {
          resetLayoutMode();
          return;
        }

        const dx = worldX - lastCorner.x;
        const dy = worldY - lastCorner.y;
        const absDx = Math.abs(dx);
        const absDy = Math.abs(dy);

        // Determine if we should be drawing horizontal or vertical
        if (layoutMode.currentDirection === null) {
          // First movement - determine direction based on which axis has more movement
          if (absDx > 0.5 || absDy > 0.5) {
            layoutMode.currentDirection = absDx > absDy ? 'horizontal' : 'vertical';
          }
        }

        // Check if user is trying to turn (significant movement in perpendicular direction)
        if (layoutMode.currentDirection === 'horizontal' && absDy > layoutMode.turnThreshold && absDx > layoutMode.minRunLength) {
          // User wants to turn from horizontal to vertical
          // First, finalize the horizontal segment
          const endX = snapToGrid(worldX);
          layoutMode.corners.push({ x: endX, y: lastCorner.y });
          layoutMode.currentDirection = 'vertical';
        } else if (layoutMode.currentDirection === 'vertical' && absDx > layoutMode.turnThreshold && absDy > layoutMode.minRunLength) {
          // User wants to turn from vertical to horizontal
          const endY = snapToGrid(worldY);
          layoutMode.corners.push({ x: lastCorner.x, y: endY });
          layoutMode.currentDirection = 'horizontal';
        }

        // Update current end point (constrained to current direction)
        const currentCorner = layoutMode.corners[layoutMode.corners.length - 1];
        if (!currentCorner) {
          resetLayoutMode();
          return;
        }

        if (layoutMode.currentDirection === 'horizontal') {
          layoutMode.currentEnd = {
            x: snapToGrid(worldX),
            y: currentCorner.y
          };
        } else if (layoutMode.currentDirection === 'vertical') {
          layoutMode.currentEnd = {
            x: currentCorner.x,
            y: snapToGrid(worldY)
          };
        } else {
          // No direction yet - show preview in dominant direction
          layoutMode.currentEnd = {
            x: absDx > absDy ? snapToGrid(worldX) : currentCorner.x,
            y: absDy > absDx ? snapToGrid(worldY) : currentCorner.y
          };
        }

        draw();
      } catch (err) {
        console.error('Layout continueDraw error:', err);
        resetLayoutMode();
      }
    }

    // Finish drawing and generate cabinets on mouse up
    function finishLayoutDraw() {
      try {
        if (!layoutMode.isDrawing) return;
        layoutMode.isDrawing = false;

        // Safety check
        if (!layoutMode.corners || layoutMode.corners.length === 0) {
          resetLayoutMode();
          draw();
          return;
        }

        // Add the current end as the final point
        const lastCorner = layoutMode.corners[layoutMode.corners.length - 1];
        if (lastCorner && layoutMode.currentEnd &&
            (layoutMode.currentEnd.x !== lastCorner.x || layoutMode.currentEnd.y !== lastCorner.y)) {
          layoutMode.corners.push({ ...layoutMode.currentEnd });
        }

        // Need at least 2 points to make a run
        if (layoutMode.corners.length < 2) {
          showSnapFeedback('Drag to create a cabinet run');
          resetLayoutMode();
          draw();
          return;
        }

        // Check total path length
        let totalLength = 0;
        for (let i = 0; i < layoutMode.corners.length - 1; i++) {
          const p1 = layoutMode.corners[i];
          const p2 = layoutMode.corners[i + 1];
          if (p1 && p2) {
            totalLength += Math.abs(p2.x - p1.x) + Math.abs(p2.y - p1.y);
          }
        }

        if (totalLength < layoutMode.minRunLength) {
          showSnapFeedback('Drag further to create a cabinet run');
          resetLayoutMode();
          draw();
          return;
        }

        // Generate cabinets along the path
        const newElements = generateCabinetsAlongPath(layoutMode.corners);

        if (!newElements || newElements.length === 0) {
          showSnapFeedback('Could not place cabinets');
          resetLayoutMode();
          draw();
          return;
        }

        // Add elements to canvas
        newElements.forEach(el => elements.push(el));

        // Add countertop
        if (layoutMode.addCountertop && newElements.length > 0) {
          const countertop = generateCountertopForRun(newElements);
          if (countertop) elements.push(countertop);
        }

        const cornerCount = layoutMode.corners.length - 1;
        const shapeDesc = cornerCount === 1 ? 'straight run' :
                          cornerCount === 2 ? 'L-shape' :
                          cornerCount === 3 ? 'U-shape' : `${cornerCount}-turn layout`;
        const counterMsg = layoutMode.addCountertop ? ' + countertop' : '';
        const typeLabel = document.getElementById('layoutElementType')?.options[document.getElementById('layoutElementType')?.selectedIndex]?.text || 'elements';
        showSnapFeedback(`Added ${newElements.length} ${typeLabel} (${shapeDesc})${counterMsg}`);
        saveUndoState();

        // Reset
        resetLayoutMode();
        draw();
        update3DScene();
      } catch (err) {
        console.error('Layout finishDraw error:', err);
        resetLayoutMode();
        draw();
      }
    }

    // Legacy function for compatibility
    function handleLayoutClick(screenX, screenY) {
      startLayoutDraw(screenX, screenY);
    }

    function finalizeLayoutRun() {
      finishLayoutDraw();
    }

    // Generate elements along a path of orthogonal points
    // Handles corners properly with corner cabinets or fillers
    function generateCabinetsAlongPath(points) {
      try {
        if (!points || points.length < 2) return [];

        const elements = [];
        const cabinetWidths = [3, 2.5, 2, 1.5, 1]; // Common widths in feet
        const depth = layoutMode.cabinetDepth || 2;
        const elType = layoutMode.cabinetType || 'base-cabinet';
        const cornerSize = 3; // 36" corner cabinet
        let globalIndex = 0;

      // Get color and label prefix based on element type
      function getElementStyle(type, widthInches) {
        const styles = {
          'base-cabinet': { color: '#8B4513', label: `Base ${widthInches}"` },
          'drawer-base': { color: '#8B5A2B', label: `Drawer ${widthInches}"` },
          'sink-base': { color: '#6B4423', label: `Sink Base ${widthInches}"` },
          'corner-cabinet': { color: '#A0522D', label: 'Corner 36"' },
          'lazy-susan': { color: '#A0522D', label: 'Lazy Susan' },
          'wall-cabinet': { color: '#D2691E', label: `Wall ${widthInches}"` },
          'tall-cabinet': { color: '#5D4037', label: `Tall ${widthInches}"` },
          'pony-wall': { color: '#9E9E9E', label: 'Pony Wall' },
          'knee-wall': { color: '#757575', label: 'Knee Wall' },
          'wall': { color: '#616161', label: 'Wall' },
          'countertop': { color: '#2F4F4F', label: 'Counter' },
          'backsplash': { color: '#708090', label: 'Backsplash' }
        };
        return styles[type] || { color: '#8B4513', label: `${widthInches}"` };
      }

      // Analyze corners - find where we need corner cabinets
      const corners = [];
      for (let i = 1; i < points.length - 1; i++) {
        const prev = points[i - 1];
        const curr = points[i];
        const next = points[i + 1];

        // Determine directions
        const dir1Horiz = Math.abs(curr.x - prev.x) > Math.abs(curr.y - prev.y);
        const dir2Horiz = Math.abs(next.x - curr.x) > Math.abs(next.y - curr.y);

        // If direction changes, it's a corner
        if (dir1Horiz !== dir2Horiz) {
          // Determine corner type based on which quadrant it opens to
          const fromRight = prev.x > curr.x;
          const fromLeft = prev.x < curr.x;
          const fromTop = prev.y < curr.y;
          const fromBottom = prev.y > curr.y;
          const toRight = next.x > curr.x;
          const toLeft = next.x < curr.x;
          const toTop = next.y < curr.y;
          const toBottom = next.y > curr.y;

          corners.push({
            index: i,
            point: curr,
            fromHoriz: dir1Horiz,
            // Determine which way the corner "opens" (where the toe kick faces)
            opensRight: (fromTop && toRight) || (fromBottom && toRight) || (fromLeft && toBottom) || (fromLeft && toTop),
            opensLeft: (fromTop && toLeft) || (fromBottom && toLeft) || (fromRight && toBottom) || (fromRight && toTop),
            opensUp: (fromLeft && toTop) || (fromRight && toTop),
            opensDown: (fromLeft && toBottom) || (fromRight && toBottom)
          });
        }
      }

      // For walls and continuous elements, create one element for the whole segment
      const isContinuous = ['wall', 'pony-wall', 'knee-wall', 'countertop', 'backsplash'].includes(elType);
      const isCabinet = ['base-cabinet', 'drawer-base', 'sink-base', 'wall-cabinet', 'tall-cabinet', 'corner-cabinet', 'lazy-susan'].includes(elType);

      // Process each segment
      for (let segIdx = 0; segIdx < points.length - 1; segIdx++) {
        const p1 = points[segIdx];
        const p2 = points[segIdx + 1];

        // Check if this segment starts or ends at a corner
        const startsAtCorner = corners.find(c => c.index === segIdx);
        const endsAtCorner = corners.find(c => c.index === segIdx + 1);

        // Determine if segment is horizontal or vertical
        const isHorizontal = Math.abs(p2.x - p1.x) > Math.abs(p2.y - p1.y);

        // Calculate run direction and bounds
        const goingRight = p2.x > p1.x;
        const goingDown = p2.y > p1.y;

        // Calculate run length
        let runLength = isHorizontal ? Math.abs(p2.x - p1.x) : Math.abs(p2.y - p1.y);

        // Adjust for corner cabinets at each end
        let startOffset = 0;
        let endOffset = 0;

        if (isCabinet && startsAtCorner) {
          startOffset = cornerSize - depth; // Leave room for corner cabinet
        }
        if (isCabinet && endsAtCorner) {
          endOffset = cornerSize - depth;
        }

        const effectiveLength = runLength - startOffset - endOffset;
        if (effectiveLength < 0.5) continue;

        // Starting position
        let startX, startY;
        if (isHorizontal) {
          startX = goingRight ? p1.x + startOffset : p2.x + endOffset;
          startY = p1.y;
        } else {
          startX = p1.x;
          startY = goingDown ? p1.y + startOffset : p2.y + endOffset;
        }

        if (isContinuous) {
          // Single continuous element
          const style = getElementStyle(elType, Math.round(effectiveLength * 12));
          const el = {
            id: 'el-' + Date.now() + '-' + globalIndex++,
            type: elType,
            x: isHorizontal ? startX * pixelsPerFoot : (startX - depth / 2) * pixelsPerFoot,
            y: isHorizontal ? (startY - depth / 2) * pixelsPerFoot : startY * pixelsPerFoot,
            width: isHorizontal ? effectiveLength : depth,
            height: isHorizontal ? depth : effectiveLength,
            rotation: 0,
            color: style.color,
            label: style.label
          };
          elements.push(el);
        } else {
          // Fill with individual cabinets
          let filled = 0;

          while (filled < effectiveLength - 0.1) {
            const remaining = effectiveLength - filled;
            let bestWidth = 1;

            for (const w of cabinetWidths) {
              if (w <= remaining + 0.05) {
                bestWidth = w;
                break;
              }
            }

            // Calculate position with proper orientation
            // Toe kick should face outward (into the room)
            let elX, elY, rotation = 0;

            if (isHorizontal) {
              elX = (startX + filled) * pixelsPerFoot;
              elY = (startY - depth / 2) * pixelsPerFoot;
              // No rotation needed for horizontal runs
            } else {
              elX = (startX - depth / 2) * pixelsPerFoot;
              elY = (startY + filled) * pixelsPerFoot;
              // No rotation - width/height swap handles orientation
            }

            const style = getElementStyle(elType, Math.round(bestWidth * 12));
            const el = {
              id: 'el-' + Date.now() + '-' + globalIndex++,
              type: elType,
              x: elX,
              y: elY,
              width: isHorizontal ? bestWidth : depth,
              height: isHorizontal ? depth : bestWidth,
              rotation: rotation,
              color: style.color,
              label: style.label
            };

            elements.push(el);
            filled += bestWidth;
          }
        }

        // Add corner element at end of this segment if there's a corner
        if (isCabinet && endsAtCorner && layoutMode.cornerType !== 'none') {
          const corner = endsAtCorner;
          const cornerPoint = corner.point;

          // Position corner element at the corner junction
          const cornerX = (cornerPoint.x - cornerSize / 2) * pixelsPerFoot;
          const cornerY = (cornerPoint.y - cornerSize / 2) * pixelsPerFoot;

          // Determine corner element based on setting
          let cornerElType = layoutMode.cornerType;
          let cornerLabel = 'Corner 36"';
          let cornerColor = '#A0522D';

          if (cornerElType === 'lazy-susan') {
            cornerLabel = 'Lazy Susan';
            cornerColor = '#8B6914';
          } else if (cornerElType === 'blind-corner') {
            cornerLabel = 'Blind Corner';
            cornerColor = '#7B5513';
          } else if (cornerElType === 'filler') {
            cornerLabel = 'Filler';
            cornerColor = '#654321';
          }

          const cornerEl = {
            id: 'el-' + Date.now() + '-corner-' + corner.index,
            type: cornerElType === 'filler' ? 'base-cabinet' : cornerElType,
            x: cornerX,
            y: cornerY,
            width: cornerSize,
            height: cornerSize,
            rotation: 0,
            color: cornerColor,
            label: cornerLabel,
            isCorner: true
          };

          // Only add if we haven't already added this corner
          if (!elements.find(e => e.isCorner && Math.abs(e.x - cornerX) < 10 && Math.abs(e.y - cornerY) < 10)) {
            elements.push(cornerEl);
          }
        }
      }

      return elements;
      } catch (err) {
        console.error('generateCabinetsAlongPath error:', err);
        return [];
      }
    }

    // Generate countertop to cover cabinet run
    function generateCountertopForRun(cabinets) {
      if (!cabinets || cabinets.length === 0) return null;

      // Find bounding box of all cabinets
      let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;

      cabinets.forEach(cab => {
        minX = Math.min(minX, cab.x);
        minY = Math.min(minY, cab.y);
        maxX = Math.max(maxX, cab.x + cab.width * pixelsPerFoot);
        maxY = Math.max(maxY, cab.y + cab.height * pixelsPerFoot);
      });

      // Add overhang (1.5" = 0.125 ft)
      const overhang = 0.125 * pixelsPerFoot;

      return {
        id: 'el-' + Date.now() + '-counter',
        type: 'countertop',
        x: minX - overhang,
        y: minY - overhang,
        width: (maxX - minX + overhang * 2) / pixelsPerFoot,
        height: (maxY - minY + overhang * 2) / pixelsPerFoot,
        rotation: 0,
        color: '#2F4F4F',
        label: 'Countertop',
        material: 'granite',
        edgeProfile: 'eased'
      };
    }

    // Draw the layout tool preview on canvas - drafting style
    function drawLayoutToolPreview() {
      try {
        if (currentTool !== 'layout') return;
        if (!layoutMode.isDrawing && (!layoutMode.corners || layoutMode.corners.length === 0)) return;

      // Build the complete path including current endpoint
      const allPoints = [...layoutMode.corners];
      if (layoutMode.isDrawing && layoutMode.currentEnd) {
        allPoints.push(layoutMode.currentEnd);
      }

      if (allPoints.length === 0) return;

      const depth = layoutMode.cabinetDepth;

      // Draw the center line path (straight orthogonal lines)
      ctx.strokeStyle = '#FF9800';
      ctx.lineWidth = 3;
      ctx.lineCap = 'square';
      ctx.lineJoin = 'miter';
      ctx.setLineDash([]);

      ctx.beginPath();
      allPoints.forEach((p, i) => {
        const screenX = p.x * pixelsPerFoot;
        const screenY = p.y * pixelsPerFoot;
        if (i === 0) {
          ctx.moveTo(screenX, screenY);
        } else {
          ctx.lineTo(screenX, screenY);
        }
      });
      ctx.stroke();

      // Draw cabinet outline preview for each segment
      ctx.strokeStyle = 'rgba(139, 69, 19, 0.9)';
      ctx.fillStyle = 'rgba(139, 69, 19, 0.25)';
      ctx.lineWidth = 2;

      for (let i = 0; i < allPoints.length - 1; i++) {
        const p1 = allPoints[i];
        const p2 = allPoints[i + 1];

        // Determine if horizontal or vertical segment
        const isHorizontal = Math.abs(p2.x - p1.x) > Math.abs(p2.y - p1.y);

        let rect;
        if (isHorizontal) {
          // Horizontal run - depth goes up/down
          const minX = Math.min(p1.x, p2.x);
          const maxX = Math.max(p1.x, p2.x);
          rect = {
            x: minX * pixelsPerFoot,
            y: (p1.y - depth / 2) * pixelsPerFoot,
            w: (maxX - minX) * pixelsPerFoot,
            h: depth * pixelsPerFoot
          };
        } else {
          // Vertical run - depth goes left/right
          const minY = Math.min(p1.y, p2.y);
          const maxY = Math.max(p1.y, p2.y);
          rect = {
            x: (p1.x - depth / 2) * pixelsPerFoot,
            y: minY * pixelsPerFoot,
            w: depth * pixelsPerFoot,
            h: (maxY - minY) * pixelsPerFoot
          };
        }

        // Draw the cabinet rectangle
        ctx.fillRect(rect.x, rect.y, rect.w, rect.h);
        ctx.strokeRect(rect.x, rect.y, rect.w, rect.h);

        // Draw dimension label for this segment
        const segmentLength = isHorizontal ?
          Math.abs(p2.x - p1.x) :
          Math.abs(p2.y - p1.y);

        if (segmentLength >= 1) {
          const midX = ((p1.x + p2.x) / 2) * pixelsPerFoot;
          const midY = ((p1.y + p2.y) / 2) * pixelsPerFoot;

          ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
          ctx.font = 'bold 11px Inter';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';

          // Background for text
          const dimText = formatDimension(segmentLength);
          const textMetrics = ctx.measureText(dimText);
          ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
          ctx.fillRect(midX - textMetrics.width / 2 - 4, midY - 8, textMetrics.width + 8, 16);

          ctx.fillStyle = '#fff';
          ctx.fillText(dimText, midX, midY);
        }

        // Reset fill for next iteration
        ctx.fillStyle = 'rgba(139, 69, 19, 0.25)';
      }

      // Draw corner markers
      allPoints.forEach((p, i) => {
        const screenX = p.x * pixelsPerFoot;
        const screenY = p.y * pixelsPerFoot;

        // Corner square
        ctx.fillStyle = i === 0 ? '#4CAF50' : (i === allPoints.length - 1 && layoutMode.isDrawing ? '#FF5722' : '#2196F3');
        ctx.fillRect(screenX - 6, screenY - 6, 12, 12);

        // Corner border
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.strokeRect(screenX - 6, screenY - 6, 12, 12);

        // Corner number
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 10px Inter';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(i === 0 ? 'S' : (i === allPoints.length - 1 ? 'E' : String(i)), screenX, screenY);
      });

      // Draw direction indicator at current end
      if (layoutMode.isDrawing && layoutMode.currentDirection) {
        const endPoint = allPoints[allPoints.length - 1];
        const endX = endPoint.x * pixelsPerFoot;
        const endY = endPoint.y * pixelsPerFoot;

        ctx.strokeStyle = '#FF9800';
        ctx.lineWidth = 2;
        ctx.setLineDash([4, 4]);

        // Show constraint direction
        ctx.beginPath();
        if (layoutMode.currentDirection === 'horizontal') {
          ctx.moveTo(endX - 30, endY);
          ctx.lineTo(endX + 30, endY);
        } else {
          ctx.moveTo(endX, endY - 30);
          ctx.lineTo(endX, endY + 30);
        }
        ctx.stroke();
        ctx.setLineDash([]);
      }

      // Instructions overlay
      ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
      const boxHeight = layoutMode.isDrawing ? 65 : 45;
      ctx.fillRect(10, 10, 300, boxHeight);

      ctx.fillStyle = '#fff';
      ctx.font = '12px Inter';
      ctx.textAlign = 'left';

      if (layoutMode.isDrawing) {
        ctx.fillText('ðŸ“ Drafting cabinet run...', 20, 28);
        const dirText = layoutMode.currentDirection ?
          `Direction: ${layoutMode.currentDirection.toUpperCase()}` :
          'Move to set direction';
        ctx.fillText(dirText, 20, 44);
        ctx.fillText('Turn: move perpendicular â€¢ Release: place', 20, 60);
      } else {
        ctx.fillText('ðŸ“ Layout Tool - Click & drag to draw', 20, 28);
        ctx.fillText('Straight lines snap to H/V â€¢ Auto-turns at corners', 20, 44);
      }
      } catch (err) {
        console.error('drawLayoutToolPreview error:', err);
        // Don't break the draw loop - just skip the preview
      }
    }

    // Fill room with flooring
    function fillRoomWithFlooring() {
      // Check if flooring already exists
      const existingFlooring = elements.find(el => el.type === 'flooring' && el.width >= roomWidth * 0.9 && el.height >= roomDepth * 0.9);
      if (existingFlooring) {
        // Select existing flooring so user can modify it
        selectedElement = existingFlooring;
        updateProperties();
        showSnapFeedback('Room already has flooring - selected for editing');
        draw();
        return;
      }

      // Create flooring that fills the entire room
      const flooring = {
        id: 'floor-' + Date.now(),
        type: 'flooring',
        x: 0,
        y: 0,
        width: roomWidth,
        height: roomDepth,
        color: '#D2B48C',
        label: 'Room Flooring',
        rotation: 0,
        locked: false,
        grainDirection: 0, // 0 = horizontal, 90 = vertical
        floorLevel: cabinetSettings.currentFloor || 1,
        zIndexOffset: -100 // Keep flooring behind other elements
      };

      // Find flooring color from ELEMENT_TYPES
      const flooringDef = ELEMENT_TYPES.surfaces?.find(e => e.type === 'flooring');
      if (flooringDef) {
        flooring.color = flooringDef.color;
      }

      elements.push(flooring);
      selectedElement = flooring;
      updateProperties();
      saveUndoState();
      draw();
      update3DScene();
      showSnapFeedback('Flooring added - select material in properties');
    }

    // Auto-generate countertops over base cabinets and wall caps over walls
    function generateCountertopsOverCabinets() {
      // Types that can receive countertops/caps
      const baseCabinetTypes = ['base-cabinet', 'drawer-base', 'sink-base', 'corner-cabinet', 'lazy-susan', 'island'];
      const wallTypes = ['pony-wall', 'pony-wall-bar', 'knee-wall', 'wall', 'wall-block', 'wall-concrete', 'wall-brick'];

      const baseCabinets = elements.filter(el => baseCabinetTypes.includes(el.type));
      const capableWalls = elements.filter(el => wallTypes.includes(el.type) &&
        // Only half-height walls get caps (not full walls unless selected)
        (['pony-wall', 'pony-wall-bar', 'knee-wall'].includes(el.type) ||
         (el === selectedElement && wallTypes.includes(el.type)))
      );

      if (baseCabinets.length === 0 && capableWalls.length === 0) {
        showSnapFeedback('No base cabinets or walls found to cover');
        return;
      }

      // Also generate caps for walls
      let wallCapsCreated = generateWallCaps(capableWalls);

      // Group cabinets by their Y position (row) - with 0.5ft tolerance
      const rows = [];
      baseCabinets.forEach(cab => {
        const cabCenterY = cab.y + (cab.height * pixelsPerFoot) / 2;
        let foundRow = rows.find(row => Math.abs(row.y - cabCenterY) < pixelsPerFoot * 0.5);
        if (foundRow) {
          foundRow.cabinets.push(cab);
        } else {
          rows.push({ y: cabCenterY, cabinets: [cab] });
        }
      });

      let countersCreated = 0;

      rows.forEach(row => {
        // Sort cabinets by X position
        row.cabinets.sort((a, b) => a.x - b.x);

        // Find contiguous runs of cabinets
        const runs = [];
        let currentRun = [row.cabinets[0]];

        for (let i = 1; i < row.cabinets.length; i++) {
          const prev = row.cabinets[i - 1];
          const curr = row.cabinets[i];
          const prevRight = prev.x + prev.width * pixelsPerFoot;
          const currLeft = curr.x;
          const gap = currLeft - prevRight;

          // If gap is small (< 6 inches), consider them adjacent
          if (gap < pixelsPerFoot * 0.5) {
            currentRun.push(curr);
          } else {
            runs.push(currentRun);
            currentRun = [curr];
          }
        }
        runs.push(currentRun);

        // Create a countertop for each run
        runs.forEach(run => {
          const leftCab = run[0];
          const rightCab = run[run.length - 1];

          // Calculate bounds with 1.5" overhang
          const overhang = 0.125; // 1.5 inches in feet
          const leftX = leftCab.x / pixelsPerFoot - overhang;
          const rightX = (rightCab.x + rightCab.width * pixelsPerFoot) / pixelsPerFoot + overhang;

          // Find the max depth in the run
          let maxDepth = 0;
          let frontY = Infinity;
          run.forEach(cab => {
            maxDepth = Math.max(maxDepth, cab.height);
            frontY = Math.min(frontY, cab.y / pixelsPerFoot);
          });

          // Countertop positioned to align with cabinet fronts with overhang
          const counterWidth = rightX - leftX;
          const counterDepth = maxDepth + overhang * 2;
          const counterY = frontY - overhang;

          // Check if countertop already exists at this location
          const existingCounter = elements.find(el =>
            el.type === 'countertop' &&
            Math.abs(el.x / pixelsPerFoot - leftX) < 0.5 &&
            Math.abs(el.y / pixelsPerFoot - counterY) < 0.5 &&
            Math.abs(el.width - counterWidth) < 0.5
          );

          if (!existingCounter) {
            const counter = {
              id: Date.now() + Math.random(),
              type: 'countertop',
              x: leftX * pixelsPerFoot,
              y: counterY * pixelsPerFoot,
              width: counterWidth,
              height: counterDepth,
              color: '#708090',
              rotation: 0,
              edgeProfile: 'eased',
              finishedEnds: ['left', 'right']
            };
            elements.push(counter);
            countersCreated++;
          }
        });
      });

      const totalCreated = countersCreated + wallCapsCreated;
      if (totalCreated > 0) {
        saveUndoState();
        draw();
        update3DScene();
        let msg = '';
        if (countersCreated > 0) msg += `${countersCreated} countertop${countersCreated > 1 ? 's' : ''}`;
        if (wallCapsCreated > 0) {
          if (msg) msg += ', ';
          msg += `${wallCapsCreated} wall cap${wallCapsCreated > 1 ? 's' : ''}`;
        }
        showSnapFeedback(`Generated ${msg}`);
      } else {
        showSnapFeedback('Countertops/caps already exist');
      }
    }

    // Generate wall caps over pony walls, knee walls, bar walls, etc.
    function generateWallCaps(walls) {
      if (!walls || walls.length === 0) return 0;

      let capsCreated = 0;
      const overhang = 0.0833; // 1 inch overhang in feet
      const capThickness = 0.125; // 1.5" cap thickness in feet

      walls.forEach(wall => {
        // Get wall dimensions and position
        const wallX = wall.x / pixelsPerFoot;
        const wallY = wall.y / pixelsPerFoot;
        const wallW = wall.width;
        const wallD = wall.height;
        const rotation = wall.rotation || 0;

        // Check if cap already exists at this location
        const existingCap = elements.find(el =>
          (el.type === 'wall-cap' || el.type === 'countertop' || el.type === 'bar-top') &&
          Math.abs(el.x / pixelsPerFoot - (wallX - overhang)) < 0.3 &&
          Math.abs(el.y / pixelsPerFoot - (wallY - overhang)) < 0.3 &&
          Math.abs(el.width - (wallW + overhang * 2)) < 0.3
        );

        if (!existingCap) {
          // Determine cap type based on wall type
          let capType = 'wall-cap';
          let capColor = '#708090';
          if (wall.type === 'pony-wall-bar') {
            capType = 'bar-top';
            capColor = '#8B4513';
          }

          // Get wall height for positioning the cap in 3D
          const wallHeight = wall.wallHeight || (wall.type === 'knee-wall' ? 2 : 3.5);

          const cap = {
            id: Date.now() + Math.random() + capsCreated,
            type: capType,
            x: (wallX - overhang) * pixelsPerFoot,
            y: (wallY - overhang) * pixelsPerFoot,
            width: wallW + overhang * 2,
            height: wallD + overhang * 2,
            color: capColor,
            rotation: rotation,
            edgeProfile: 'eased',
            finishedEnds: ['left', 'right', 'front', 'back'],
            capHeight: wallHeight,          // Height where cap sits
            thickness: capThickness,        // Cap thickness
            parentWallId: wall.id           // Link to parent wall
          };
          elements.push(cap);
          capsCreated++;
        }
      });

      return capsCreated;
    }

    // Generate cap/top for a single selected element (wall, cabinet, etc.)
    function generateCapForSelected() {
      if (!selectedElement) {
        showSnapFeedback('Select an element first');
        return;
      }

      const wallTypes = ['pony-wall', 'pony-wall-bar', 'knee-wall', 'wall', 'wall-block', 'wall-concrete', 'wall-brick'];
      const cabinetTypes = ['base-cabinet', 'drawer-base', 'sink-base', 'corner-cabinet', 'lazy-susan', 'island'];

      if (wallTypes.includes(selectedElement.type)) {
        const created = generateWallCaps([selectedElement]);
        if (created > 0) {
          saveUndoState();
          draw();
          update3DScene();
          showSnapFeedback('Wall cap added');
        } else {
          showSnapFeedback('Cap already exists on this wall');
        }
      } else if (cabinetTypes.includes(selectedElement.type)) {
        // Generate countertop just for this cabinet
        const counter = generateCountertopForRun([selectedElement]);
        if (counter) {
          elements.push(counter);
          saveUndoState();
          draw();
          update3DScene();
          showSnapFeedback('Countertop added');
        }
      } else {
        showSnapFeedback('Select a wall or cabinet first');
      }
    }

    // Alignment menu for selected elements
    function showAlignMenu() {
      // Create a simple dropdown menu for alignment options
      const menu = document.createElement('div');
      menu.id = 'alignMenu';
      menu.className = 'context-menu';
      menu.style.cssText = `
        position: fixed;
        background: rgba(30, 30, 40, 0.95);
        backdrop-filter: blur(20px);
        -webkit-backdrop-filter: blur(20px);
        border: 1px solid rgba(255, 255, 255, 0.15);
        border-radius: 12px;
        padding: 8px 0;
        box-shadow: 0 8px 32px rgba(0,0,0,0.5);
        z-index: 9999;
        min-width: 180px;
      `;

      const options = [
        { label: 'Align Left', icon: 'â«·', action: () => alignElements('left') },
        { label: 'Align Center', icon: 'â«¿', action: () => alignElements('center') },
        { label: 'Align Right', icon: 'â«¸', action: () => alignElements('right') },
        { label: 'Align Top', icon: 'â« ', action: () => alignElements('top') },
        { label: 'Align Middle', icon: 'â”€', action: () => alignElements('middle') },
        { label: 'Align Bottom', icon: 'â«¡', action: () => alignElements('bottom') },
        { divider: true },
        { label: 'Distribute Horizontal', icon: 'â‹¯', action: () => distributeElements('horizontal') },
        { label: 'Distribute Vertical', icon: 'â‹®', action: () => distributeElements('vertical') },
        { divider: true },
        { label: 'Snap to Wall', icon: 'â–£', action: () => snapSelectionToWall() }
      ];

      options.forEach(opt => {
        if (opt.divider) {
          const div = document.createElement('div');
          div.style.cssText = 'height: 1px; background: rgba(255, 255, 255, 0.1); margin: 6px 8px;';
          menu.appendChild(div);
        } else {
          const item = document.createElement('div');
          item.style.cssText = `
            padding: 10px 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 13px;
            color: #e0e0e0;
            transition: all 0.15s ease;
            margin: 2px 6px;
            border-radius: 6px;
          `;
          item.innerHTML = `<span style="width: 18px; text-align: center; font-size: 14px;">${opt.icon}</span>${opt.label}`;
          item.onmouseenter = () => {
            item.style.background = 'rgba(255, 255, 255, 0.1)';
            item.style.color = '#ffffff';
          };
          item.onmouseleave = () => {
            item.style.background = 'transparent';
            item.style.color = '#e0e0e0';
          };
          item.onclick = () => {
            opt.action();
            menu.remove();
          };
          menu.appendChild(item);
        }
      });

      // Position near the Align button
      const btn = document.getElementById('toolAlign');
      const rect = btn.getBoundingClientRect();
      menu.style.left = rect.right + 5 + 'px';
      menu.style.top = rect.top + 'px';

      document.body.appendChild(menu);

      // Close on click outside
      setTimeout(() => {
        document.addEventListener('click', function closeMenu(e) {
          if (!menu.contains(e.target)) {
            menu.remove();
            document.removeEventListener('click', closeMenu);
          }
        });
      }, 10);
    }

    // Align multiple selected elements (or all cabinets if none selected)
    function alignElements(alignment) {
      const cabinetTypes = ['base-cabinet', 'wall-cabinet', 'tall-cabinet', 'corner-cabinet', 'drawer-base', 'sink-base', 'lazy-susan', 'island'];
      const targets = elements.filter(el => cabinetTypes.includes(el.type));

      if (targets.length < 2) {
        showSnapFeedback('Need at least 2 cabinets to align');
        return;
      }

      // Find the reference point based on alignment
      let refValue;
      switch (alignment) {
        case 'left':
          refValue = Math.min(...targets.map(el => el.x));
          targets.forEach(el => el.x = refValue);
          break;
        case 'right':
          refValue = Math.max(...targets.map(el => el.x + el.width * pixelsPerFoot));
          targets.forEach(el => el.x = refValue - el.width * pixelsPerFoot);
          break;
        case 'center':
          const avgX = targets.reduce((sum, el) => sum + el.x + (el.width * pixelsPerFoot) / 2, 0) / targets.length;
          targets.forEach(el => el.x = avgX - (el.width * pixelsPerFoot) / 2);
          break;
        case 'top':
          refValue = Math.min(...targets.map(el => el.y));
          targets.forEach(el => el.y = refValue);
          break;
        case 'bottom':
          refValue = Math.max(...targets.map(el => el.y + el.height * pixelsPerFoot));
          targets.forEach(el => el.y = refValue - el.height * pixelsPerFoot);
          break;
        case 'middle':
          const avgY = targets.reduce((sum, el) => sum + el.y + (el.height * pixelsPerFoot) / 2, 0) / targets.length;
          targets.forEach(el => el.y = avgY - (el.height * pixelsPerFoot) / 2);
          break;
      }

      saveUndoState();
      draw();
      update3DScene();
      showSnapFeedback(`Aligned ${targets.length} elements`);
    }

    // Distribute elements evenly
    function distributeElements(direction) {
      const cabinetTypes = ['base-cabinet', 'wall-cabinet', 'tall-cabinet', 'corner-cabinet', 'drawer-base', 'sink-base', 'lazy-susan', 'island'];
      const targets = elements.filter(el => cabinetTypes.includes(el.type));

      if (targets.length < 3) {
        showSnapFeedback('Need at least 3 cabinets to distribute');
        return;
      }

      if (direction === 'horizontal') {
        targets.sort((a, b) => a.x - b.x);
        const first = targets[0];
        const last = targets[targets.length - 1];
        const totalWidth = targets.reduce((sum, el) => sum + el.width * pixelsPerFoot, 0);
        const availableSpace = (last.x + last.width * pixelsPerFoot) - first.x - totalWidth;
        const gap = availableSpace / (targets.length - 1);

        let currentX = first.x;
        targets.forEach(el => {
          el.x = currentX;
          currentX += el.width * pixelsPerFoot + gap;
        });
      } else {
        targets.sort((a, b) => a.y - b.y);
        const first = targets[0];
        const last = targets[targets.length - 1];
        const totalHeight = targets.reduce((sum, el) => sum + el.height * pixelsPerFoot, 0);
        const availableSpace = (last.y + last.height * pixelsPerFoot) - first.y - totalHeight;
        const gap = availableSpace / (targets.length - 1);

        let currentY = first.y;
        targets.forEach(el => {
          el.y = currentY;
          currentY += el.height * pixelsPerFoot + gap;
        });
      }

      saveUndoState();
      draw();
      update3DScene();
      showSnapFeedback(`Distributed ${targets.length} elements ${direction}ly`);
    }

    // Snap selection to nearest wall
    function snapSelectionToWall() {
      if (!selectedElement) {
        showSnapFeedback('Select an element first');
        return;
      }

      const el = selectedElement;
      const elLeft = el.x / pixelsPerFoot;
      const elRight = elLeft + el.width;
      const elTop = el.y / pixelsPerFoot;
      const elBottom = elTop + el.height;

      // Check distances to room walls
      const distToLeft = elLeft;
      const distToRight = roomWidth - elRight;
      const distToTop = elTop;
      const distToBottom = roomDepth - elBottom;

      // Find minimum distance
      const min = Math.min(distToLeft, distToRight, distToTop, distToBottom);

      if (min === distToLeft) {
        el.x = 0;
      } else if (min === distToRight) {
        el.x = (roomWidth - el.width) * pixelsPerFoot;
      } else if (min === distToTop) {
        el.y = 0;
      } else {
        el.y = (roomDepth - el.height) * pixelsPerFoot;
      }

      saveUndoState();
      draw();
      update3DScene();
      showSnapFeedback('Snapped to wall');
    }

    function toggleSection(header) {
      // Find the sidebar-content, skipping over any tooltip elements
      const section = header.parentElement;
      const content = section.querySelector('.sidebar-content');
      const toggle = header.querySelector('.sidebar-toggle');
      if (content) {
        content.classList.toggle('collapsed');
        toggle.textContent = content.classList.contains('collapsed') ? 'â–¶' : 'â–¼';
      }
    }

    function togglePanelSection(header) {
      // Toggle collapsible panel sections in the right panel
      const section = header.parentElement;
      const content = section.querySelector('.panel-content');
      const toggle = header.querySelector('.panel-toggle');
      if (content) {
        content.classList.toggle('collapsed');
        toggle.textContent = content.classList.contains('collapsed') ? 'â–¶' : 'â–¼';
      }
    }

    // ===== VIEW =====
    function setView(view) {
      currentView = view;
      document.getElementById('view2D').classList.toggle('active', view === '2d');
      document.getElementById('view3D').classList.toggle('active', view === '3d');

      const canvasWrapper = document.getElementById('canvasWrapper');
      const threeContainer = document.getElementById('three-container');

      // Cancel any existing animation when switching views
      if (animationId) {
        cancelAnimationFrame(animationId);
        animationId = null;
      }

      if (view === '3d') {
        canvasWrapper.style.display = 'none';
        threeContainer.classList.add('active');
        init3D();

        // Update renderer size in case container size changed
        if (renderer) {
          const w = threeContainer.clientWidth;
          const h = threeContainer.clientHeight;
          renderer.setSize(w, h);
          camera.aspect = w / h;
          camera.updateProjectionMatrix();
        }

        render3D();
      } else {
        // Cleanup 3D resources when switching to 2D
        cleanup3D();
        canvasWrapper.style.display = 'block';
        threeContainer.classList.remove('active');
      }
    }

    // Helper function to check if 3D mode is active
    function get3DMode() {
      return currentView === '3d';
    }

    // Expose is3DMode as a getter
    Object.defineProperty(window, 'is3DMode', {
      get: function() { return currentView === '3d'; }
    });

    // Toggle between 2D and 3D views
    function toggle3DView() {
      if (currentView === '3d') {
        setView('2d');
      } else {
        setView('3d');
      }
      // Update button text in review room if present
      const toggle3DBtn = document.getElementById('toggle3DBtn');
      if (toggle3DBtn) {
        toggle3DBtn.textContent = currentView === '3d' ? '2D View' : '3D View';
      }
    }

    // Alias for update3DScene - rebuilds the 3D scene with current elements
    function update3DScene() {
      if (currentView === '3d') {
        init3D();
        render3D();
      }
    }

    // ===== DETAILED MODEL PREVIEW =====
    async function previewDetailedCabinetModel() {
      try {
        // Switch to 3D view if not already
        if (currentView !== '3d') {
          setView('3d');
          await new Promise(resolve => setTimeout(resolve, 100)); // Wait for view switch
        }

        const btn = document.getElementById('viewDetailedModel');
        btn.textContent = 'Loading...';
        btn.disabled = true;

        // Load the detailed cabinet model
        const modelClone = await getKitchenCabinetsModel();

        if (modelClone && scene) {
          // Remove any existing preview model
          const existingPreview = scene.getObjectByName('detailedPreviewModel');
          if (existingPreview) {
            scene.remove(existingPreview);
          }

          // Add the loaded model to the scene
          modelClone.name = 'detailedPreviewModel';

          // Calculate bounding box to scale and position model
          const box = new THREE.Box3().setFromObject(modelClone);
          const size = box.getSize(new THREE.Vector3());
          const center = box.getCenter(new THREE.Vector3());

          // Scale model to fit in a 10ft x 10ft area (reasonable kitchen scale)
          const maxDim = Math.max(size.x, size.y, size.z);
          const scale = maxDim > 0 ? 10 / maxDim : 1;
          modelClone.scale.setScalar(scale);

          // Position at center of room
          modelClone.position.set(
            roomWidth / 2 - center.x * scale,
            0 - box.min.y * scale,
            roomDepth / 2 - center.z * scale
          );

          // Add shadows to all meshes
          modelClone.traverse(child => {
            if (child.isMesh) {
              child.castShadow = true;
              child.receiveShadow = true;
            }
          });

          scene.add(modelClone);

          // Position camera to see the model
          if (camera && controls) {
            camera.position.set(roomWidth / 2 + 12, 8, roomDepth / 2 + 12);
            controls.target.set(roomWidth / 2, 3, roomDepth / 2);
            controls.update();
          }

          btn.textContent = 'Model Loaded';
          console.log('Detailed cabinet model added to scene');
        } else {
          btn.textContent = 'Preview Model';
          console.warn('Could not load model or scene not available');
        }
      } catch (error) {
        console.error('Error loading detailed model:', error);
        const btn = document.getElementById('viewDetailedModel');
        btn.textContent = 'Load Failed';
        setTimeout(() => {
          btn.textContent = 'Preview Model';
          btn.disabled = false;
        }, 2000);
      }

      const btn = document.getElementById('viewDetailedModel');
      btn.disabled = false;
    }

    // ===== 3D VIEW =====
    function cleanup3D() {
      if (animationId) {
        cancelAnimationFrame(animationId);
        animationId = null;
      }

      if (scene) {
        // Dispose all objects in scene
        scene.traverse(obj => {
          if (obj.geometry) obj.geometry.dispose();
          if (obj.material) {
            if (Array.isArray(obj.material)) {
              obj.material.forEach(m => m.dispose());
            } else {
              obj.material.dispose();
            }
          }
        });
        scene.clear();
        scene = null;
      }

      if (renderer) {
        renderer.dispose();
        renderer = null;
      }

      if (controls) {
        controls.dispose();
        controls = null;
      }

      const container = document.getElementById('three-container');
      if (container) container.innerHTML = '';
    }

    function init3D() {
      // Clean up existing 3D resources first
      cleanup3D();

      // Preload textures before building scene
      preload3DTextures();

      const container = document.getElementById('three-container');
      const width = container.clientWidth;
      const height = container.clientHeight;

      // Get current theme for background
      const timeOfDay = sceneSettings?.timeOfDay || 'noon';
      const bgColors = {
        morning: 0xFFF8E7,   // Warm cream
        noon: 0xF5F8FA,      // Bright neutral
        evening: 0xFFE8D6,   // Sunset warm
        night: 0x1E2A3A      // Dark blue-gray
      };

      scene = new THREE.Scene();
      scene.background = new THREE.Color(bgColors[timeOfDay] || 0xF5F8FA);

      // Camera
      camera = new THREE.PerspectiveCamera(50, width / height, 0.5, 150);
      camera.position.set(roomWidth * 1.3, 8, roomDepth * 1.3);
      camera.lookAt(roomWidth / 2, 2, roomDepth / 2);

      // Renderer with enhanced quality for better texture visibility
      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setSize(width, height);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 1.2; // Slightly brighter for better texture visibility
      renderer.outputColorSpace = THREE.SRGBColorSpace; // Proper color handling
      container.appendChild(renderer.domElement);

      // Orbit controls with smooth zoom - allows close-up inspection
      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.08;
      controls.target.set(roomWidth / 2, 1.5, roomDepth / 2);
      controls.maxPolarAngle = Math.PI / 2.05;
      controls.minPolarAngle = Math.PI / 12; // Allow flatter angles for detail viewing
      controls.minDistance = 1.5;  // Allow very close zoom for detail inspection (1.5 ft)
      controls.maxDistance = 50; // Allow zooming out further for large rooms

      // Moderate zoom sensitivity for fine control
      controls.zoomSpeed = 0.4;

      // Reduce pan sensitivity
      controls.panSpeed = 0.3;

      // Reduce rotation sensitivity
      controls.rotateSpeed = 0.35;

      // Disable right-click completely - only left-click rotates, middle zooms
      // Shift+Left or middle mouse for panning
      controls.mouseButtons = {
        LEFT: THREE.MOUSE.ROTATE,
        MIDDLE: THREE.MOUSE.DOLLY,
        RIGHT: THREE.MOUSE.PAN  // Allow right-click for panning instead of disabling
      };

      // Handle trackpad pinch-to-zoom more smoothly
      controls.enableZoom = true;
      controls.screenSpacePanning = true;  // Pan in screen space for more intuitive control

      // Enable keyboard controls for panning (arrow keys)
      controls.enableKeys = true;
      controls.keys = {
        LEFT: 37,  // left arrow
        UP: 38,    // up arrow
        RIGHT: 39, // right arrow
        BOTTOM: 40 // down arrow
      };

      // Store initial camera state for reset
      const initialCameraPosition = camera.position.clone();
      const initialTarget = controls.target.clone();

      controls.update();

      // Prevent context menu on 3D view
      container.addEventListener('contextmenu', (e) => e.preventDefault());

      // Add reset view function to window scope
      window.reset3DView = function() {
        camera.position.copy(initialCameraPosition);
        controls.target.copy(initialTarget);
        controls.update();
      };

      // Preset view angles
      window.set3DViewAngle = function(angle) {
        const centerX = roomWidth / 2;
        const centerZ = roomDepth / 2;
        const distance = Math.max(roomWidth, roomDepth) * 1.2;

        switch(angle) {
          case 'top':
            // Bird's eye view - straight down
            camera.position.set(centerX, distance + 8, centerZ + 0.1);
            controls.target.set(centerX, 0, centerZ);
            break;
          case 'front':
            // Front elevation view
            camera.position.set(centerX, 5, roomDepth + distance * 0.8);
            controls.target.set(centerX, 3, centerZ);
            break;
          case 'side':
            // Side elevation view
            camera.position.set(roomWidth + distance * 0.8, 5, centerZ);
            controls.target.set(centerX, 3, centerZ);
            break;
          case 'counter':
            // Counter-level view - eye height looking at countertop
            // Position camera at human eye level (5.5ft) looking at counter height (3ft)
            camera.position.set(centerX, 5.5, roomDepth * 0.8);
            controls.target.set(centerX, 3, centerZ * 0.5);
            break;
          case 'corner':
            // Corner view - diagonal across room for best overall view
            camera.position.set(-2, 6, roomDepth + 2);
            controls.target.set(centerX, 2.5, centerZ);
            break;
          case 'closeup':
            // Close-up of cabinets/counters
            camera.position.set(centerX, 4, roomDepth * 0.3);
            controls.target.set(centerX, 3, 2);
            break;
          default:
            camera.position.copy(initialCameraPosition);
            controls.target.copy(initialTarget);
        }

        controls.update();
      };

      // Cabinet focus mode - hides walls, windows, doors for clear cabinet view
      let cabinetFocusMode = false;
      window.toggleCabinetFocus = function() {
        cabinetFocusMode = !cabinetFocusMode;
        const btn = document.getElementById('focusCabinetsBtn');

        if (cabinetFocusMode) {
          // Hide structural elements, show only cabinets/counters/appliances
          hiddenCategories['walls'] = true;
          hiddenCategories['windows'] = true;
          hiddenCategories['doors'] = true;
          hiddenCategories['niches'] = true;
          hiddenCategories['decorative'] = true;

          // Update UI checkboxes
          document.querySelectorAll('.visibility-toggle input').forEach(cb => {
            const cat = cb.getAttribute('onchange')?.match(/'(\w+)'/)?.[1];
            if (['walls', 'windows', 'doors', 'niches', 'decorative'].includes(cat)) {
              cb.checked = false;
            }
          });

          if (btn) {
            btn.style.background = 'var(--accent-color)';
            btn.style.color = 'white';
          }

          // Set a good view angle for cabinets
          set3DViewAngle('corner');

          showToast('Focus mode: Showing cabinets & countertops only', 'info');
        } else {
          // Restore all visibility
          delete hiddenCategories['walls'];
          delete hiddenCategories['windows'];
          delete hiddenCategories['doors'];
          delete hiddenCategories['niches'];
          delete hiddenCategories['decorative'];

          // Update UI checkboxes
          document.querySelectorAll('.visibility-toggle input').forEach(cb => {
            const cat = cb.getAttribute('onchange')?.match(/'(\w+)'/)?.[1];
            if (['walls', 'windows', 'doors', 'niches', 'decorative'].includes(cat)) {
              cb.checked = true;
            }
          });

          if (btn) {
            btn.style.background = '';
            btn.style.color = '';
          }

          showToast('Showing all elements', 'info');
        }

        // Refresh the view
        draw();
        if (currentView === '3d') update3DScene();
      };

      // === WALKTHROUGH / FIRST-PERSON MODE ===
      let walkthroughMode = false;
      let walkthroughKeys = { w: false, a: false, s: false, d: false, q: false, e: false };
      let walkthroughMoveSpeed = 0.15;
      let walkthroughLookSpeed = 0.002;
      let walkthroughYaw = 0;
      let walkthroughPitch = 0;
      let walkthroughAnimationId = null;

      window.toggleWalkthroughMode = function() {
        walkthroughMode = !walkthroughMode;
        const btn = document.getElementById('walkthroughBtn');
        const normalHint = document.getElementById('threeHint');
        const walkHint = document.getElementById('walkthroughHint');
        const threeContainer = document.getElementById('three-container');

        if (walkthroughMode) {
          // Enter walkthrough mode
          controls.enabled = false;

          // Position camera at eye level (5.5ft) at entrance
          camera.position.set(roomWidth / 2, 5.5, roomDepth - 2);
          walkthroughYaw = 0;
          walkthroughPitch = 0;

          // Show/hide hints
          if (normalHint) normalHint.style.display = 'none';
          if (walkHint) walkHint.style.display = 'flex';

          // Style button
          if (btn) {
            btn.style.background = 'var(--accent-color)';
            btn.style.color = 'white';
          }

          // Enable pointer lock for mouse look
          threeContainer.addEventListener('click', requestPointerLock);
          document.addEventListener('pointerlockchange', onPointerLockChange);
          document.addEventListener('mousemove', onWalkthroughMouseMove);
          document.addEventListener('keydown', onWalkthroughKeyDown);
          document.addEventListener('keyup', onWalkthroughKeyUp);

          // Start animation loop
          walkthroughAnimate();

          showToast('Walkthrough mode: Click to enable mouse look, WASD to move', 'info');
        } else {
          // Exit walkthrough mode
          exitWalkthroughMode();
        }
      };

      function exitWalkthroughMode() {
        walkthroughMode = false;
        controls.enabled = true;

        const btn = document.getElementById('walkthroughBtn');
        const normalHint = document.getElementById('threeHint');
        const walkHint = document.getElementById('walkthroughHint');
        const threeContainer = document.getElementById('three-container');

        if (normalHint) normalHint.style.display = 'flex';
        if (walkHint) walkHint.style.display = 'none';

        if (btn) {
          btn.style.background = '';
          btn.style.color = '';
        }

        // Exit pointer lock
        if (document.pointerLockElement) {
          document.exitPointerLock();
        }

        // Remove event listeners
        threeContainer?.removeEventListener('click', requestPointerLock);
        document.removeEventListener('pointerlockchange', onPointerLockChange);
        document.removeEventListener('mousemove', onWalkthroughMouseMove);
        document.removeEventListener('keydown', onWalkthroughKeyDown);
        document.removeEventListener('keyup', onWalkthroughKeyUp);

        // Stop animation
        if (walkthroughAnimationId) {
          cancelAnimationFrame(walkthroughAnimationId);
          walkthroughAnimationId = null;
        }

        // Reset controls target
        controls.target.set(roomWidth / 2, 2, roomDepth / 2);
        controls.update();

        showToast('Exited walkthrough mode', 'info');
      }

      function requestPointerLock() {
        const threeContainer = document.getElementById('three-container');
        threeContainer?.requestPointerLock();
      }

      function onPointerLockChange() {
        if (!document.pointerLockElement && walkthroughMode) {
          // Still in walkthrough mode but pointer unlocked - show hint
          showToast('Click 3D view to re-enable mouse look', 'info');
        }
      }

      function onWalkthroughMouseMove(e) {
        if (!walkthroughMode || !document.pointerLockElement) return;

        walkthroughYaw -= e.movementX * walkthroughLookSpeed;
        walkthroughPitch -= e.movementY * walkthroughLookSpeed;

        // Clamp pitch to prevent flipping
        walkthroughPitch = Math.max(-Math.PI / 2 + 0.1, Math.min(Math.PI / 2 - 0.1, walkthroughPitch));
      }

      function onWalkthroughKeyDown(e) {
        if (!walkthroughMode) return;

        const key = e.key.toLowerCase();
        if (key === 'w') walkthroughKeys.w = true;
        if (key === 'a') walkthroughKeys.a = true;
        if (key === 's') walkthroughKeys.s = true;
        if (key === 'd') walkthroughKeys.d = true;
        if (key === 'q') walkthroughKeys.q = true;
        if (key === 'e') walkthroughKeys.e = true;
        if (key === 'escape') exitWalkthroughMode();
        if (key === 'shift') walkthroughMoveSpeed = 0.3; // Sprint
      }

      function onWalkthroughKeyUp(e) {
        if (!walkthroughMode) return;

        const key = e.key.toLowerCase();
        if (key === 'w') walkthroughKeys.w = false;
        if (key === 'a') walkthroughKeys.a = false;
        if (key === 's') walkthroughKeys.s = false;
        if (key === 'd') walkthroughKeys.d = false;
        if (key === 'q') walkthroughKeys.q = false;
        if (key === 'e') walkthroughKeys.e = false;
        if (key === 'shift') walkthroughMoveSpeed = 0.15; // Normal speed
      }

      function walkthroughAnimate() {
        if (!walkthroughMode) return;

        walkthroughAnimationId = requestAnimationFrame(walkthroughAnimate);

        // Calculate forward/right vectors based on yaw
        const forward = new THREE.Vector3(
          Math.sin(walkthroughYaw),
          0,
          Math.cos(walkthroughYaw)
        );
        const right = new THREE.Vector3(
          Math.sin(walkthroughYaw + Math.PI / 2),
          0,
          Math.cos(walkthroughYaw + Math.PI / 2)
        );

        // Apply movement
        if (walkthroughKeys.w) {
          camera.position.add(forward.clone().multiplyScalar(-walkthroughMoveSpeed));
        }
        if (walkthroughKeys.s) {
          camera.position.add(forward.clone().multiplyScalar(walkthroughMoveSpeed));
        }
        if (walkthroughKeys.a) {
          camera.position.add(right.clone().multiplyScalar(-walkthroughMoveSpeed));
        }
        if (walkthroughKeys.d) {
          camera.position.add(right.clone().multiplyScalar(walkthroughMoveSpeed));
        }
        if (walkthroughKeys.q) {
          camera.position.y -= walkthroughMoveSpeed * 0.5;
        }
        if (walkthroughKeys.e) {
          camera.position.y += walkthroughMoveSpeed * 0.5;
        }

        // Keep camera within reasonable bounds
        camera.position.x = Math.max(-5, Math.min(roomWidth + 5, camera.position.x));
        camera.position.y = Math.max(1, Math.min(12, camera.position.y));
        camera.position.z = Math.max(-5, Math.min(roomDepth + 5, camera.position.z));

        // Update camera look direction
        const lookTarget = new THREE.Vector3(
          camera.position.x + Math.sin(walkthroughYaw) * Math.cos(walkthroughPitch),
          camera.position.y + Math.sin(walkthroughPitch),
          camera.position.z + Math.cos(walkthroughYaw) * Math.cos(walkthroughPitch)
        );
        camera.lookAt(lookTarget);

        // Render
        renderer.render(scene, camera);
      }

      // === LIGHTING ===
      // === BALANCED LIGHTING SYSTEM ===
      // Reduced intensity for realistic indoor lighting that preserves material colors
      // Goal: Dark colors stay dark, light colors stay visible without washing out
      const lightingPresets = {
        morning: {
          ambient: { color: 0xFFF8F0, intensity: 0.35 },
          hemisphere: { sky: 0xFFE4C4, ground: 0x8B7355, intensity: 0.25 },
          sun: { color: 0xFFE4B5, intensity: 0.6, pos: [25, 12, 15] },
          fill: { color: 0xFFE8D6, intensity: 0.2 },
          exposure: 0.9
        },
        noon: {
          ambient: { color: 0xFFFFFF, intensity: 0.4 },
          hemisphere: { sky: 0xE0F0FF, ground: 0x8B7355, intensity: 0.3 },
          sun: { color: 0xFFFFF8, intensity: 0.7, pos: [15, 25, 15] },
          fill: { color: 0xFFFFFF, intensity: 0.25 },
          exposure: 0.95
        },
        evening: {
          ambient: { color: 0xFFE0C0, intensity: 0.3 },
          hemisphere: { sky: 0xFFA07A, ground: 0x6B4423, intensity: 0.2 },
          sun: { color: 0xFF8C00, intensity: 0.5, pos: [-20, 8, 10] },
          fill: { color: 0xFFD4B8, intensity: 0.25 },
          exposure: 0.85
        },
        night: {
          ambient: { color: 0xC0C8D8, intensity: 0.25 },
          hemisphere: { sky: 0x4169E1, ground: 0x2F3F4F, intensity: 0.15 },
          sun: { color: 0xB0C4DE, intensity: 0.15, pos: [-15, 20, 10] },
          fill: { color: 0xFFF8E0, intensity: 0.35 }, // Interior lights
          exposure: 0.75
        }
      };

      const preset = lightingPresets[timeOfDay] || lightingPresets.noon;

      // Apply exposure setting - controls overall brightness
      renderer.toneMappingExposure = preset.exposure;

      // Ambient light - soft overall illumination (reduced to preserve color contrast)
      const ambient = new THREE.AmbientLight(preset.ambient.color, preset.ambient.intensity);
      ambient.name = 'ambientLight';
      scene.add(ambient);

      // Hemisphere light (subtle sky/ground gradient for natural feel)
      const hemi = new THREE.HemisphereLight(preset.hemisphere.sky, preset.hemisphere.ground, preset.hemisphere.intensity);
      hemi.name = 'hemisphereLight';
      scene.add(hemi);

      // Main directional (sun/moon) with shadows - primary light source
      const sun = new THREE.DirectionalLight(preset.sun.color, preset.sun.intensity);
      sun.name = 'sunLight';
      sun.position.set(...preset.sun.pos);
      sun.castShadow = true;
      sun.shadow.mapSize.width = 2048;
      sun.shadow.mapSize.height = 2048;
      sun.shadow.camera.near = 1;
      sun.shadow.camera.far = 50;
      sun.shadow.camera.left = -25;
      sun.shadow.camera.right = 25;
      sun.shadow.camera.top = 25;
      sun.shadow.camera.bottom = -25;
      sun.shadow.bias = -0.0003;
      scene.add(sun);

      // Fill light - softens shadows, subtle
      const fill = new THREE.DirectionalLight(preset.fill.color, preset.fill.intensity);
      fill.name = 'fillLight';
      fill.position.set(-roomWidth, 12, roomDepth);
      scene.add(fill);

      // Single soft surface light for countertop visibility (reduced)
      const surfaceLight = new THREE.DirectionalLight(0xFFFFFF, 0.15);
      surfaceLight.name = 'surfaceLight';
      surfaceLight.position.set(roomWidth / 2, 10, roomDepth / 2);
      surfaceLight.target.position.set(roomWidth / 2, 0, roomDepth / 2);
      scene.add(surfaceLight);
      scene.add(surfaceLight.target);

      // Subtle rim light for depth separation
      const back = new THREE.DirectionalLight(0xE8F0FF, 0.1);
      back.name = 'backLight';
      back.position.set(roomWidth / 2, 5, -10);
      scene.add(back);

      // === ENVIRONMENT MAP FOR REALISTIC REFLECTIONS ===
      // Time-of-day aware environment for metallic surfaces
      const pmremGenerator = new THREE.PMREMGenerator(renderer);
      pmremGenerator.compileEquirectangularShader();

      // Environment colors based on time of day
      const envColors = {
        morning: { sky: '#FFE4B5', horizon: '#FFF8DC', ground: '#D2B48C' },
        noon: { sky: '#B8D4E8', horizon: '#F5F5F5', ground: '#D4C4B0' },
        evening: { sky: '#FFA07A', horizon: '#FFE4C4', ground: '#8B4513' },
        night: { sky: '#2F4F6F', horizon: '#4A5568', ground: '#2D3748' }
      };

      const envCol = envColors[timeOfDay] || envColors.noon;

      // Create gradient material for environment
      const envCanvas = document.createElement('canvas');
      envCanvas.width = 512;
      envCanvas.height = 256;
      const envCtx = envCanvas.getContext('2d');

      // Create vertical gradient (sky to ground)
      const gradient = envCtx.createLinearGradient(0, 0, 0, 256);
      gradient.addColorStop(0, envCol.sky);
      gradient.addColorStop(0.45, envCol.horizon);
      gradient.addColorStop(0.55, envCol.horizon);
      gradient.addColorStop(1, envCol.ground);
      envCtx.fillStyle = gradient;
      envCtx.fillRect(0, 0, 512, 256);

      // Add soft highlights for depth (reduced for night)
      if (timeOfDay !== 'night') {
        envCtx.fillStyle = 'rgba(255, 255, 255, 0.15)';
        envCtx.fillRect(100, 90, 180, 35);
        envCtx.fillRect(260, 100, 120, 30);
      }

      const envTexture = new THREE.CanvasTexture(envCanvas);
      envTexture.mapping = THREE.EquirectangularReflectionMapping;

      // Generate environment map
      const envMap = pmremGenerator.fromEquirectangular(envTexture).texture;
      scene.environment = envMap;

      // Store for use in materials
      window.roomEnvMap = envMap;

      // Note: Background is already set above based on time of day

      // Resize handler
      window.addEventListener('resize', () => {
        if (!renderer || !camera || !container) return;
        const w = container.clientWidth;
        const h = container.clientHeight;
        if (w > 0 && h > 0) {
          camera.aspect = w / h;
          camera.updateProjectionMatrix();
          renderer.setSize(w, h);
        }
      });
    }

    // Get proper 3D height for element types
    // Can accept element object to use custom heights
    function get3DHeight(typeOrElement) {
      const type = typeof typeOrElement === 'string' ? typeOrElement : typeOrElement?.type;
      const el = typeof typeOrElement === 'object' ? typeOrElement : null;

      // Check for custom 3D height override on the element
      if (el?.height3D !== undefined) {
        return el.height3D;
      }

      // Window-specific height override
      if (el?.windowHeight !== undefined && (type === 'window' || type === 'window-large' || type === 'window-bay' || type === 'bay-window' || type === 'picture-window')) {
        return el.windowHeight;
      }

      // Full-height wall types use room ceiling height
      const fullHeightTypes = [
        'wall', 'wall-block', 'wall-concrete', 'wall-framed',
        'wall-wood-2x4', 'wall-wood-2x6', 'wall-brick'
      ];
      if (fullHeightTypes.includes(type)) {
        // Use element's wallHeight if set, otherwise room ceiling height
        return el?.wallHeight || roomHeight || 8;
      }

      const heights = {
        'base-cabinet': 2.9,      // 35 inches standard
        'drawer-base': 2.9,       // 35 inches (same as base)
        'sink-base': 2.9,         // 35 inches (same as base)
        'wall-cabinet': 2.5,      // 30 inches
        'tall-cabinet': 7,        // 84 inches
        'corner-cabinet': 2.9,
        'lazy-susan': 2.9,        // 35 inches (corner base)
        'island': 3,              // 36 inches with countertop
        'countertop': 0.12,       // 1.5 inch thick
        'backsplash': 1.5,        // 18 inches
        'flooring': 0.05,         // Very thin
        'tile': 0.05,
        'shower-pan': 0.08,       // Shower pan thickness
        'shower-curb': 0.5,       // 6" high curb
        'shower-wall': el?.wallHeight || 7, // Full shower height
        'wall-tile': el?.wallHeight || 8,   // Full wall height
        'accent-wall': el?.wallHeight || 8, // Full wall height
        'sink': 0.3,              // Recessed
        'stove': 3,               // Full range height
        'range': 3,               // Full range height
        'cooktop': 0.2,           // Cooktop inset into counter (~2.5" thick)
        'refrigerator': 5.8,      // 70 inches
        'dishwasher': 2.8,        // 34 inches
        'microwave': 1,           // 12 inches
        'range-hood': 0.5,        // Hood depth
        'oven': 2.4,              // 29 inches
        'door': 6.8,              // 82 inches
        'double-door': 6.8,       // 82 inches
        'sliding-door': 6.8,      // 82 inches
        'french-door': 6.8,       // 82 inches
        'glass-door': 6.8,        // 82 inches
        'entry-archway': 7,       // 84 inches (arched opening)
        'garage-door': 7,         // 84 inches
        'window': 3,              // 36 inches
        'window-large': 5,        // 60 inches (picture)
        'window-bay': 4,          // 48 inches (bay)
        'bay-window': 4,          // 48 inches
        'picture-window': 5,      // 60 inches
        // Niches - these are the opening heights
        'wall-niche': 3,          // 36 inches
        'fireplace-niche': 2.5,   // 30 inches
        'tv-niche': 2.5,          // 30 inches (for TV)
        'shower-niche': 1.5,      // 18 inches (small)
        // ADA grab bars
        'grab-bar': 0.25,         // 3 inches diameter
        // Pony walls (use element's wallHeight if set)
        'pony-wall': el?.wallHeight || 3.5,         // 42 inches
        'pony-wall-bar': el?.wallHeight || 3.5,     // 42 inches
        'knee-wall': el?.wallHeight || 2.5,         // 30 inches

        // Stone caps and ledges
        'wall-cap': el?.thickness || 0.1,           // 1.25" cap thickness
        'bar-top': el?.thickness || 0.125,          // 1.5" bar top thickness
        'window-sill': el?.stoneThickness || 0.06,  // 3/4" sill
        'threshold': el?.stoneThickness || 0.04,    // 1/2" threshold
        'mantel': el?.stoneThickness || 0.1,        // Mantel shelf thickness
        'fireplace-hearth': el?.stoneThickness || 0.125, // Hearth slab
        'fireplace-surround': el?.surroundWidth || 0.67, // Surround width as height
        'niche-surround': el?.surroundWidth || 0.5, // Niche surround

        // Work surfaces (countertop-like materials)
        'surface-stainless': 0.1,       // 1.2" stainless steel work surface
        'surface-solid': 0.1,           // 1.2" solid surface (Corian)
        'surface-laminate': 0.125,      // 1.5" laminate on substrate
        'surface-butcherblock': 0.125,  // 1.5" butcher block
        'surface-concrete': 0.15,       // 1.8" concrete countertop (thicker)

        // Structural elements - beams and columns
        'steel-beam': el?.beamDepth || 0.67,        // 8" I-beam depth (W8 section)
        'steel-column': el?.columnHeight || 8,      // Full height (floor to ceiling)
        'wood-beam': el?.beamDepth || 0.5,          // 6" beam depth
        'wood-post': el?.columnHeight || 8,         // Full height post
        'concrete-beam': el?.beamDepth || 0.83,     // 10" concrete beam
        'concrete-column': el?.columnHeight || 8,   // Full height column
        'header': el?.beamDepth || 0.33,            // 4" header/lintel
        'lvl-beam': el?.beamDepth || 0.92           // 11" LVL beam
      };
      return heights[type] || 1;
    }

    // Get Y position (elevation) for element types
    function get3DYPosition(el, height) {
      // Proper stacking heights for kitchen elements
      // All heights in feet, Y = center of object
      const type = el.type;

      switch(type) {
        // Ground level surfaces (below everything)
        case 'flooring':
        case 'tile':
        case 'shower-pan':
          return 0.025; // Just above floor plane

        case 'shower-curb':
          return height / 2; // Sits on floor

        case 'shower-wall':
        case 'wall-tile':
        case 'accent-wall':
          return height / 2; // Wall panels sit on floor

        // Base level (on floor)
        case 'base-cabinet':
        case 'drawer-base':
        case 'sink-base':
        case 'corner-cabinet':
        case 'lazy-susan':
        case 'island':
          return height / 2; // Base sits on floor

        // Counter height items (on top of base cabinets at ~35")
        case 'countertop': {
          // Smart stacking: detect what's beneath this countertop and sit ON TOP of it
          const ctopCenterX = el.x / pixelsPerFoot + el.width / 2;
          const ctopCenterY = el.y / pixelsPerFoot + el.height / 2;
          const ctopLeft = el.x / pixelsPerFoot;
          const ctopRight = ctopLeft + el.width;
          const ctopTop = el.y / pixelsPerFoot;
          const ctopBottom = ctopTop + el.height;

          // Types of elements countertops can sit on
          const ponyWallTypes = ['pony-wall', 'pony-wall-bar', 'knee-wall'];
          const cabinetTypes = ['base-cabinet', 'drawer-base', 'sink-base', 'corner-cabinet',
                                'lazy-susan', 'island', 'tall-cabinet'];

          // Find any element that this countertop overlaps with
          let bestMatch = null;
          let bestHeight = 0;

          elements.forEach(other => {
            if (other.id === el.id) return;

            // Calculate other element bounds
            const otherLeft = other.x / pixelsPerFoot;
            const otherRight = otherLeft + other.width;
            const otherTop = other.y / pixelsPerFoot;
            const otherBottom = otherTop + other.height;

            // Check for overlap (countertop should overlap at least 50% with the element below)
            const overlapX = Math.max(0, Math.min(ctopRight, otherRight) - Math.max(ctopLeft, otherLeft));
            const overlapY = Math.max(0, Math.min(ctopBottom, otherBottom) - Math.max(ctopTop, otherTop));
            const overlapArea = overlapX * overlapY;
            const ctopArea = el.width * el.height;

            // Need at least 20% overlap to consider sitting on it
            if (overlapArea / ctopArea < 0.2) return;

            if (ponyWallTypes.includes(other.type)) {
              const wallHeight = other.wallHeight || (other.type === 'knee-wall' ? 2.5 : 3.5);
              if (wallHeight > bestHeight) {
                bestHeight = wallHeight;
                bestMatch = other;
              }
            } else if (cabinetTypes.includes(other.type)) {
              // Get the cabinet's height (top surface)
              const cabHeight = other.type === 'tall-cabinet' ? (other.cabinetHeight || 7) :
                               (other.cabinetHeight || 2.9);
              if (cabHeight > bestHeight) {
                bestHeight = cabHeight;
                bestMatch = other;
              }
            }
          });

          if (bestMatch) {
            // Position countertop on top of the detected element
            return bestHeight + height / 2;
          }

          // Default: Base cabinet is 2.9ft (34.8"), counter sits directly on top
          return 2.9 + height / 2;
        }

        case 'sink':
        case 'sink-double':
        case 'sink-farmhouse': {
          // Smart stacking: sink sits IN/ON countertop surface
          const sinkLeft = el.x / pixelsPerFoot;
          const sinkRight = sinkLeft + el.width;
          const sinkTop = el.y / pixelsPerFoot;
          const sinkBottom = sinkTop + el.height;

          // Find countertop that this sink is in
          let counterSurface = 3.02; // Default: 2.9 cabinet + 0.12 counter

          elements.forEach(other => {
            if (other.id === el.id) return;
            if (other.type !== 'countertop') return;

            const otherLeft = other.x / pixelsPerFoot;
            const otherRight = otherLeft + other.width;
            const otherTop = other.y / pixelsPerFoot;
            const otherBottom = otherTop + other.height;

            // Check if sink overlaps with countertop
            const overlapX = Math.max(0, Math.min(sinkRight, otherRight) - Math.max(sinkLeft, otherLeft));
            const overlapY = Math.max(0, Math.min(sinkBottom, otherBottom) - Math.max(sinkTop, otherTop));

            if (overlapX > 0.1 && overlapY > 0.1) {
              // Found a countertop - calculate its surface height
              counterSurface = 2.9 + 0.12; // Standard cabinet + counter
            }
          });

          // Farmhouse sinks show apron, position slightly lower
          if (el.type === 'sink-farmhouse') {
            return counterSurface - 0.1;
          }
          // Regular sinks rim is flush with countertop surface
          return counterSurface - 0.02;
        }

        case 'cooktop': {
          // Cooktop sits IN countertop, flush with surface
          const ctLeft = el.x / pixelsPerFoot;
          const ctRight = ctLeft + el.width;
          const ctTop = el.y / pixelsPerFoot;
          const ctBottom = ctTop + el.height;

          let counterSurface = 3.02;

          elements.forEach(other => {
            if (other.id === el.id) return;
            if (other.type !== 'countertop') return;

            const otherLeft = other.x / pixelsPerFoot;
            const otherRight = otherLeft + other.width;
            const otherTop = other.y / pixelsPerFoot;
            const otherBottom = otherTop + other.height;

            const overlapX = Math.max(0, Math.min(ctRight, otherRight) - Math.max(ctLeft, otherLeft));
            const overlapY = Math.max(0, Math.min(ctBottom, otherBottom) - Math.max(ctTop, otherTop));

            if (overlapX > 0.1 && overlapY > 0.1) {
              counterSurface = 2.9 + 0.12;
            }
          });

          // Cooktop surface is flush with countertop
          return counterSurface;
        }

        case 'stove':
        case 'range':
        case 'dishwasher':
        case 'oven':
          return height / 2; // These are floor-standing appliances

        case 'refrigerator':
          return height / 2; // Floor standing, tall

        // Wall mounted (54" from floor is typical bottom edge)
        case 'wall-cabinet': {
          // Smart stacking: wall cabinet sits above backsplash/countertop with 18" clearance
          const wcLeft = el.x / pixelsPerFoot;
          const wcRight = wcLeft + el.width;
          const wcTop = el.y / pixelsPerFoot;
          const wcBottom = wcTop + el.height;

          // Find backsplash or countertop beneath this wall cabinet
          let surfaceBelowTop = 3.02; // Default counter surface

          elements.forEach(other => {
            if (other.id === el.id) return;

            const otherLeft = other.x / pixelsPerFoot;
            const otherRight = otherLeft + other.width;
            const otherTop = other.y / pixelsPerFoot;
            const otherBottom = otherTop + other.height;

            // Check for horizontal overlap
            const overlapX = Math.max(0, Math.min(wcRight, otherRight) - Math.max(wcLeft, otherLeft));
            if (overlapX < 0.1) return;

            // Check for overlap or adjacency in Y
            const overlapY = Math.max(0, Math.min(wcBottom, otherBottom) - Math.max(wcTop, otherTop));
            const adjacentY = Math.abs(wcBottom - otherTop) < 1 || Math.abs(wcTop - otherBottom) < 1;
            if (overlapY < 0.1 && !adjacentY) return;

            if (other.type === 'backsplash') {
              // Get backsplash top - sits on counter surface (3.02) + backsplash height
              const bsHeight = other.wallHeight || 1.5; // Default 18" backsplash
              const bsTop = 3.02 + bsHeight;
              if (bsTop > surfaceBelowTop) {
                surfaceBelowTop = bsTop;
              }
            } else if (other.type === 'countertop') {
              const counterTop = 3.02;
              if (counterTop > surfaceBelowTop) {
                surfaceBelowTop = counterTop;
              }
            }
          });

          // Wall cabinet sits 1.5 feet (18") above the surface below
          return surfaceBelowTop + 1.5 + height / 2;
        }

        case 'backsplash': {
          // Smart stacking: backsplash sits ON TOP of countertop surface
          const bsLeft = el.x / pixelsPerFoot;
          const bsRight = bsLeft + el.width;
          const bsTop = el.y / pixelsPerFoot;
          const bsBottom = bsTop + el.height;

          // Find countertop beneath this backsplash
          let counterSurfaceHeight = 0;

          elements.forEach(other => {
            if (other.id === el.id) return;
            if (other.type !== 'countertop') return;

            // Calculate other element bounds
            const otherLeft = other.x / pixelsPerFoot;
            const otherRight = otherLeft + other.width;
            const otherTop = other.y / pixelsPerFoot;
            const otherBottom = otherTop + other.height;

            // Check if backsplash is adjacent to or overlapping with countertop
            const overlapX = Math.max(0, Math.min(bsRight, otherRight) - Math.max(bsLeft, otherLeft));
            const adjacentY = Math.abs(bsBottom - otherTop) < 0.5 || Math.abs(bsTop - otherBottom) < 0.5;
            const overlapY = Math.max(0, Math.min(bsBottom, otherBottom) - Math.max(bsTop, otherTop));

            // Consider if there's any horizontal overlap and they're close in Y
            if (overlapX > 0.1 && (overlapY > 0 || adjacentY)) {
              // Calculate countertop's top surface directly (avoid recursive call)
              // Countertop thickness is typically 0.12 ft (1.44 inches)
              const counterThickness = 0.12;
              // Countertop base position is 2.9 ft (on cabinet), or on detected element
              const counterBaseHeight = 2.9; // Standard cabinet height
              const counterSurface = counterBaseHeight + counterThickness;
              if (counterSurface > counterSurfaceHeight) {
                counterSurfaceHeight = counterSurface;
              }
            }
          });

          if (counterSurfaceHeight > 0) {
            // Backsplash sits directly on top of countertop surface
            return counterSurfaceHeight + height / 2;
          }

          // Default: Standard counter surface (2.9 + 0.12 thick counter) + backsplash
          return 3.02 + height / 2;
        }

        case 'range-hood': {
          // Smart stacking: range hood sits above stove/range/cooktop
          const rhLeft = el.x / pixelsPerFoot;
          const rhRight = rhLeft + el.width;
          const rhTop = el.y / pixelsPerFoot;
          const rhBottom = rhTop + el.height;

          // Find stove/range/cooktop beneath this hood
          let applianceTopHeight = 3; // Default: top of stove surface

          elements.forEach(other => {
            if (other.id === el.id) return;

            const stoveTypes = ['stove', 'range', 'cooktop'];
            if (!stoveTypes.includes(other.type)) return;

            const otherLeft = other.x / pixelsPerFoot;
            const otherRight = otherLeft + other.width;
            const otherTop = other.y / pixelsPerFoot;
            const otherBottom = otherTop + other.height;

            // Check for overlap
            const overlapX = Math.max(0, Math.min(rhRight, otherRight) - Math.max(rhLeft, otherLeft));
            const overlapY = Math.max(0, Math.min(rhBottom, otherBottom) - Math.max(rhTop, otherTop));

            if (overlapX > 0.1 && overlapY > 0.1) {
              // Get the top of the appliance
              const appHeight = other.type === 'cooktop' ? 0.1 : 3; // Cooktop is thin, range is tall
              const appTop = other.type === 'cooktop' ? 3.02 + 0.05 : appHeight;
              if (appTop > applianceTopHeight) {
                applianceTopHeight = appTop;
              }
            }
          });

          // Range hood bottom is typically 24-30" above cooktop surface
          // Position hood 2 feet (24") above the cooking surface
          return applianceTopHeight + 2 + height / 2;
        }

        case 'microwave': {
          // Smart stacking: microwave often above stove/range or under wall cabinet
          const mwLeft = el.x / pixelsPerFoot;
          const mwRight = mwLeft + el.width;
          const mwTop = el.y / pixelsPerFoot;
          const mwBottom = mwTop + el.height;

          // Check if there's a stove/range beneath
          let positionHeight = 4.5; // Default position

          elements.forEach(other => {
            if (other.id === el.id) return;

            const otherLeft = other.x / pixelsPerFoot;
            const otherRight = otherLeft + other.width;
            const overlapX = Math.max(0, Math.min(mwRight, otherRight) - Math.max(mwLeft, otherLeft));
            if (overlapX < 0.1) return;

            if (other.type === 'stove' || other.type === 'range') {
              // Over-the-range microwave: positioned above stove
              positionHeight = 4.2; // Bottom of microwave above stove
            }
          });

          return positionHeight + height / 2;
        }

        // Windows - use sillHeight property if available
        case 'window':
        case 'window-large':
        case 'window-bay':
        case 'bay-window':
        case 'picture-window': {
          // sillHeight is the bottom edge from floor (in feet)
          // Default: 2ft (24") for standard window
          const sillHeight = el.sillHeight !== undefined ? el.sillHeight : 2;
          return sillHeight + height / 2; // Position center based on sill
        }

        // Doors and archways - use sillHeight (should be 0 for doors on floor)
        case 'door':
        case 'double-door':
        case 'sliding-door':
        case 'french-door':
        case 'glass-door':
        case 'entry-archway':
        case 'garage-door': {
          const doorSillHeight = el.sillHeight !== undefined ? el.sillHeight : 0;
          return doorSillHeight + height / 2;
        }

        case 'wall':
          return height / 2; // Wall sits on floor

        case 'tall-cabinet':
        case 'fridge-cabinet':
          return height / 2; // Tall cabinets and fridge cabinets sit on floor

        // Pony walls / half walls
        case 'pony-wall':
        case 'pony-wall-bar':
        case 'knee-wall':
          return height / 2; // Sits on floor

        // Niches (typically mounted in wall, use height property)
        case 'wall-niche':
        case 'shower-niche': {
          // Shower niches typically at eye level (~4-5ft)
          return el.nicheFloorHeight !== undefined ? el.nicheFloorHeight + height / 2 : 4 + height / 2;
        }
        case 'fireplace-niche':
        case 'tv-niche': {
          // Fireplace/TV at comfortable viewing height
          return el.nicheFloorHeight !== undefined ? el.nicheFloorHeight + height / 2 : 2 + height / 2;
        }

        // Stone surfaces
        case 'wall-cap':
        case 'bar-top': {
          // Position cap at top of wall it sits on
          // If capHeight is not set, try to find a nearby pony wall to match its height
          let capHeight = el.capHeight;
          if (capHeight === undefined) {
            // Look for overlapping pony wall to inherit height from
            const ponyWallTypes = ['pony-wall', 'pony-wall-bar', 'knee-wall'];
            const capCenterX = el.x / pixelsPerFoot + el.width / 2;
            const capCenterY = el.y / pixelsPerFoot + el.height / 2;

            const nearbyWall = elements.find(other => {
              if (!ponyWallTypes.includes(other.type)) return false;
              const wallCenterX = other.x / pixelsPerFoot + other.width / 2;
              const wallCenterY = other.y / pixelsPerFoot + other.height / 2;
              const distX = Math.abs(capCenterX - wallCenterX);
              const distY = Math.abs(capCenterY - wallCenterY);
              // Check if cap overlaps with wall (within 1 foot tolerance)
              return distX < (el.width + other.width) / 2 + 0.5 &&
                     distY < (el.height + other.height) / 2 + 0.5;
            });

            if (nearbyWall) {
              capHeight = nearbyWall.wallHeight || (nearbyWall.type === 'knee-wall' ? 2.5 : 3.5);
            } else {
              // Default to standard pony wall height (3.5 ft = 42 inches)
              capHeight = 3.5;
            }
          }
          return capHeight + height / 2;
        }

        // Work surfaces (countertop alternatives) - positioned at counter height
        case 'surface-stainless':
        case 'surface-solid':
        case 'surface-laminate':
        case 'surface-butcherblock':
        case 'surface-concrete':
          // These sit at standard counter height (on top of base cabinets)
          return 2.9 + height / 2;

        case 'fireplace-hearth':
        case 'threshold':
          return height / 2; // Floor level
        case 'window-sill': {
          // Window sill follows window sillHeight
          const windowSill = el.sillHeight !== undefined ? el.sillHeight : 2;
          return windowSill;
        }
        case 'mantel':
          return 4 + height / 2; // Above fireplace opening
        case 'fireplace-surround':
        case 'niche-surround':
          return 2.5 + height / 2; // Centered around opening

        // ADA grab bars (33-36" from floor per ADA guidelines)
        case 'grab-bar':
          return el.mountHeight !== undefined ? el.mountHeight + height / 2 : 2.875 + height / 2;

        // Structural beams - positioned at ceiling level (bottom of beam touches ceiling)
        case 'steel-beam':
        case 'wood-beam':
        case 'concrete-beam':
        case 'header':
        case 'lvl-beam': {
          // Beams hang from ceiling - use beamElevation if set, otherwise at ceiling
          const ceilingHeight = roomHeight || 8;
          const beamElevation = el.beamElevation !== undefined ? el.beamElevation : ceilingHeight;
          return beamElevation - height / 2; // Bottom of beam at elevation
        }

        // Structural columns - floor to ceiling
        case 'steel-column':
        case 'wood-post':
        case 'concrete-column':
          return height / 2; // Column sits on floor

        // Bathroom elements - floor standing
        case 'toilet':
        case 'bathtub':
        case 'bathtub-freestanding':
        case 'vanity-24':
        case 'vanity-30':
        case 'vanity-36':
        case 'vanity-48':
        case 'vanity-60':
        case 'vanity-72':
        case 'shower-bench':
          return height / 2; // Floor standing

        case 'towel-warmer':
          return el.mountHeight !== undefined ? el.mountHeight + height / 2 : 3 + height / 2; // Wall mounted ~36" up

        // Laundry elements - floor standing
        case 'washer':
        case 'dryer':
        case 'utility-sink':
        case 'laundry-sink':
        case 'drying-rack':
          return height / 2; // Floor standing

        // Closet elements
        case 'closet-rod':
          return el.mountHeight !== undefined ? el.mountHeight + height / 2 : 5.5 + height / 2; // ~66" from floor

        case 'closet-shelf':
          return el.mountHeight !== undefined ? el.mountHeight + height / 2 : 6 + height / 2; // Above rod

        case 'drawer-unit':
        case 'shoe-rack':
        case 'closet-island':
        case 'jewelry-cabinet':
          return height / 2; // Floor standing

        default:
          return height / 2; // Default: bottom on floor
      }
    }

    // Cache for loaded 3D textures
    const textureCache3D = {};
    const textureLoader = new THREE.TextureLoader();
    textureLoader.setCrossOrigin('anonymous');

    // Preload textures for elements that have them
    function preload3DTextures() {
      const textureUrls = new Set();
      elements.forEach(el => {
        if (el.texture) textureUrls.add(el.texture);
        if (el.storeProduct?.image) textureUrls.add(el.storeProduct.image);
      });

      textureUrls.forEach(url => {
        if (!textureCache3D[url]) {
          console.log('Preloading texture:', url.substring(0, 50) + '...');
          textureLoader.load(url, (texture) => {
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.colorSpace = THREE.SRGBColorSpace;
            textureCache3D[url] = texture;
            console.log('Preloaded texture successfully:', url.substring(0, 50) + '...');
          }, undefined, (err) => {
            console.warn('Failed to preload texture:', url, err);
          });
        }
      });
    }

    function create3DElement(el) {
      const w = el.width;
      const d = el.height; // In 2D, height is depth in 3D
      const h = get3DHeight(el);

      // Parse color
      let color = el.color || '#808080';
      if (typeof color === 'string') {
        if (color.startsWith('#')) {
          color = parseInt(color.replace('#', ''), 16);
        } else if (color.startsWith('rgb')) {
          const match = color.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
          if (match) {
            color = (parseInt(match[1]) << 16) | (parseInt(match[2]) << 8) | parseInt(match[3]);
          } else {
            color = 0x808080;
          }
        } else {
          color = parseInt(color, 16) || 0x808080;
        }
      }

      const group = new THREE.Group();

      // Helper to adjust color brightness (works with numeric colors)
      function adjustColorBrightness(col, amount) {
        const r = Math.max(0, Math.min(255, ((col >> 16) & 0xFF) + amount));
        const g = Math.max(0, Math.min(255, ((col >> 8) & 0xFF) + amount));
        const b = Math.max(0, Math.min(255, (col & 0xFF) + amount));
        return (r << 16) | (g << 8) | b;
      }

      // Helper to create material with optional texture
      function createTexturedMaterial(baseColor, textureUrl, options = {}) {
        // Material settings optimized for accurate color reproduction
        // Higher roughness = less reflective = better color visibility
        const matOptions = {
          color: textureUrl ? 0xFFFFFF : baseColor, // Pure white when textured for accurate colors
          roughness: options.roughness !== undefined ? options.roughness : 0.5,
          metalness: options.metalness !== undefined ? options.metalness : 0.01,
          side: options.side || THREE.FrontSide
        };

        // Don't spread options directly as it may override our texture color
        if (options.transparent) matOptions.transparent = options.transparent;
        if (options.opacity !== undefined) matOptions.opacity = options.opacity;

        const material = new THREE.MeshStandardMaterial(matOptions);

        // Apply environment map only for clearly metallic surfaces (very subtle)
        if (window.roomEnvMap && matOptions.metalness > 0.3) {
          material.envMap = window.roomEnvMap;
          material.envMapIntensity = Math.min(0.3, matOptions.metalness * 0.5);
        }

        // Load texture if available
        if (textureUrl) {
          // Resolve relative URLs to absolute
          let fullUrl = textureUrl;
          if (textureUrl.startsWith('/') && !textureUrl.startsWith('//')) {
            fullUrl = window.location.origin + textureUrl;
          } else if (!textureUrl.startsWith('http') && !textureUrl.startsWith('data:')) {
            fullUrl = window.location.origin + '/' + textureUrl;
          }

          // Also check cache with original URL (in case it was cached with different resolution)
          const cachedTexture = textureCache3D[fullUrl] || textureCache3D[textureUrl];

          if (cachedTexture) {
            material.map = cachedTexture;
            material.color.setHex(0xFFFFFF);
            material.needsUpdate = true;
          } else {
            // Load texture
            textureLoader.load(fullUrl, (texture) => {
              texture.wrapS = THREE.RepeatWrapping;
              texture.wrapT = THREE.RepeatWrapping;
              texture.repeat.set(1, 1);
              texture.colorSpace = THREE.SRGBColorSpace;
              texture.anisotropy = renderer ? renderer.capabilities.getMaxAnisotropy() : 1;

              // Cache with both URLs
              textureCache3D[fullUrl] = texture;
              textureCache3D[textureUrl] = texture;

              material.map = texture;
              material.color.setHex(0xFFFFFF);
              material.needsUpdate = true;

              // Re-render to show texture
              if (renderer && scene && camera) {
                renderer.render(scene, camera);
              }
            },
            undefined,
            (err) => {
              console.warn('Texture load failed:', textureUrl);
              // Keep the base color as fallback
              material.color.setHex(baseColor || 0x808080);
              material.needsUpdate = true;
            });
          }
        }

        return material;
      }

      // Get texture URL from element - check multiple sources
      let textureUrl = null;
      if (el.texture) {
        textureUrl = el.texture;
      } else if (el.textureImg && el.textureImg.src) {
        textureUrl = el.textureImg.src;
      } else if (el.storeProduct && el.storeProduct.image) {
        textureUrl = el.storeProduct.image;
      } else if (el.materialId && el.materialName) {
        // Try to find from store products
        const product = storeProducts.find(p => p.slug === el.materialId);
        if (product && product.primaryImage) {
          textureUrl = product.primaryImage;
          el.texture = textureUrl; // Cache for next time
        }
      } else if (elementTextures && elementTextures[el.type]) {
        textureUrl = elementTextures[el.type];
      }

      // Log texture status for debugging
      if (textureUrl) {
        console.log(`Element ${el.type} (${el.label || 'unnamed'}) has texture:`, textureUrl.substring(0, 60) + '...');
      }

      // Helper to create cabinet with doors
      function createCabinet(width, height, depth, cabinetColor, isWallCab, doorStyle, construction, overlay) {
        const cabGroup = new THREE.Group();

        // Construction affects door gaps
        // Frameless: minimal gaps, doors cover most of face (full overlay default)
        // Framed: visible face frame, doors reveal frame edges
        const isFramed = construction === 'framed';
        const overlayType = overlay || 'full';

        // Gap based on overlay type
        let gap;
        if (isFramed) {
          gap = overlayType === 'inset' ? 0.08 : (overlayType === 'partial' ? 0.06 : 0.04);
        } else {
          gap = overlayType === 'inset' ? 0.06 : 0.02; // Frameless has smaller gaps
        }

        // Cabinet body
        const bodyMat = new THREE.MeshStandardMaterial({ color: 0x2a2a2a, roughness: 0.8 });
        const body = new THREE.Mesh(new THREE.BoxGeometry(width - 0.1, height - 0.1, depth - 0.1), bodyMat);
        body.position.z = -0.02;
        cabGroup.add(body);

        // Face frame for framed cabinets
        if (isFramed) {
          const frameMat = new THREE.MeshStandardMaterial({ color: cabinetColor, roughness: 0.4 });
          const frameW = 0.06; // 1.5" face frame

          // Top rail
          const topFrame = new THREE.Mesh(new THREE.BoxGeometry(width, frameW, 0.04), frameMat);
          topFrame.position.set(0, height/2 - frameW/2 - 0.01, depth/2 - 0.01);
          cabGroup.add(topFrame);

          // Bottom rail
          const botFrame = new THREE.Mesh(new THREE.BoxGeometry(width, frameW, 0.04), frameMat);
          botFrame.position.set(0, -height/2 + frameW/2 + 0.01, depth/2 - 0.01);
          cabGroup.add(botFrame);

          // Left stile
          const leftFrame = new THREE.Mesh(new THREE.BoxGeometry(frameW, height - frameW*2, 0.04), frameMat);
          leftFrame.position.set(-width/2 + frameW/2 + 0.01, 0, depth/2 - 0.01);
          cabGroup.add(leftFrame);

          // Right stile
          const rightFrame = new THREE.Mesh(new THREE.BoxGeometry(frameW, height - frameW*2, 0.04), frameMat);
          rightFrame.position.set(width/2 - frameW/2 - 0.01, 0, depth/2 - 0.01);
          cabGroup.add(rightFrame);
        }

        // Face material
        const faceMat = new THREE.MeshStandardMaterial({ color: cabinetColor, roughness: 0.35, metalness: 0.02 });

        // Door(s)
        const numDoors = Math.max(1, Math.round(width / 1.5));
        const doorW = (width - gap * (numDoors + 1)) / numDoors;
        const doorH = height - gap * 2;

        const style = doorStyle || 'shaker';

        for (let i = 0; i < numDoors; i++) {
          const dx = -width/2 + gap + doorW/2 + i * (doorW + gap);

          // Main door panel
          const door = new THREE.Mesh(new THREE.BoxGeometry(doorW, doorH, 0.06), faceMat);
          door.position.set(dx, 0, depth/2);
          cabGroup.add(door);

          // Door style details
          if (style === 'shaker') {
            // Shaker: flat center panel with raised frame
            const frameMat = new THREE.MeshStandardMaterial({ color: cabinetColor, roughness: 0.3 });
            const fw = 0.08;

            // Top rail
            const top = new THREE.Mesh(new THREE.BoxGeometry(doorW - 0.02, fw, 0.02), frameMat);
            top.position.set(dx, doorH/2 - fw/2 - 0.01, depth/2 + 0.04);
            cabGroup.add(top);

            // Bottom rail
            const bot = new THREE.Mesh(new THREE.BoxGeometry(doorW - 0.02, fw, 0.02), frameMat);
            bot.position.set(dx, -doorH/2 + fw/2 + 0.01, depth/2 + 0.04);
            cabGroup.add(bot);

            // Left stile
            const left = new THREE.Mesh(new THREE.BoxGeometry(fw, doorH - fw*2, 0.02), frameMat);
            left.position.set(dx - doorW/2 + fw/2 + 0.01, 0, depth/2 + 0.04);
            cabGroup.add(left);

            // Right stile
            const right = new THREE.Mesh(new THREE.BoxGeometry(fw, doorH - fw*2, 0.02), frameMat);
            right.position.set(dx + doorW/2 - fw/2 - 0.01, 0, depth/2 + 0.04);
            cabGroup.add(right);
          } else if (style === 'raised') {
            // Raised panel: outer frame with raised center
            const frameMat = new THREE.MeshStandardMaterial({ color: cabinetColor, roughness: 0.3 });
            const fw = 0.1;

            // Frame pieces
            const top = new THREE.Mesh(new THREE.BoxGeometry(doorW - 0.02, fw, 0.02), frameMat);
            top.position.set(dx, doorH/2 - fw/2 - 0.01, depth/2 + 0.04);
            cabGroup.add(top);

            const bot = new THREE.Mesh(new THREE.BoxGeometry(doorW - 0.02, fw, 0.02), frameMat);
            bot.position.set(dx, -doorH/2 + fw/2 + 0.01, depth/2 + 0.04);
            cabGroup.add(bot);

            const left = new THREE.Mesh(new THREE.BoxGeometry(fw, doorH - fw*2, 0.02), frameMat);
            left.position.set(dx - doorW/2 + fw/2 + 0.01, 0, depth/2 + 0.04);
            cabGroup.add(left);

            const right = new THREE.Mesh(new THREE.BoxGeometry(fw, doorH - fw*2, 0.02), frameMat);
            right.position.set(dx + doorW/2 - fw/2 - 0.01, 0, depth/2 + 0.04);
            cabGroup.add(right);

            // Raised center panel
            const raisedW = doorW - fw * 2 - 0.06;
            const raisedH = doorH - fw * 2 - 0.06;
            const raisedMat = new THREE.MeshStandardMaterial({ color: cabinetColor, roughness: 0.25 });
            const raised = new THREE.Mesh(new THREE.BoxGeometry(raisedW, raisedH, 0.04), raisedMat);
            raised.position.set(dx, 0, depth/2 + 0.06);
            cabGroup.add(raised);
          } else if (style === 'flat') {
            // Flat panel: minimal detail, just thin border
            const borderMat = new THREE.MeshStandardMaterial({ color: cabinetColor, roughness: 0.35 });
            const borderW = 0.02;

            // Thin groove around door
            const grooveMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.9 });
            const groove = new THREE.Mesh(new THREE.BoxGeometry(doorW - 0.08, doorH - 0.08, 0.01), grooveMat);
            groove.position.set(dx, 0, depth/2 + 0.03);
            cabGroup.add(groove);
          }
          // 'slab' style = no detail, just plain door

          // Vertical Handle (bar pull)
          const handleMat = new THREE.MeshStandardMaterial({ color: 0xaaaaaa, metalness: 0.9, roughness: 0.15 });
          const handleY = isWallCab ? -doorH * 0.25 : doorH * 0.25;
          const handleX = i < numDoors/2 ? doorW/2 - 0.12 : -doorW/2 + 0.12;
          const handle = new THREE.Mesh(new THREE.CylinderGeometry(0.01, 0.01, 0.3, 8), handleMat);
          handle.position.set(dx + handleX, handleY, depth/2 + 0.09);
          cabGroup.add(handle);
        }

        return cabGroup;
      }

      // === CREATE DETAILED 3D MODELS ===
      switch(el.type) {
        case 'base-cabinet':
        case 'wall-cabinet': {
          const isBaseCab = el.type === 'base-cabinet';

          // Toe kick dimensions (4" tall, 3" recessed)
          const toeKickHeight = isBaseCab ? 0.33 : 0;
          const toeKickRecess = isBaseCab ? 0.25 : 0;

          // Cabinet body height (minus toe kick for base cabinets)
          const bodyHeight = h - toeKickHeight;

          // Create cabinet body at reduced height for base cabinets
          const cab = createCabinet(w, bodyHeight, d, color, !isBaseCab, el.doorStyle, el.construction, el.doorOverlay);

          // Position cabinet body above toe kick
          if (isBaseCab) {
            cab.position.y = toeKickHeight / 2;
          }
          group.add(cab);

          // Create toe kick for base cabinets - proper recessed void
          if (isBaseCab) {
            // Toe kick back panel (visible back of recess)
            const tkBackMat = new THREE.MeshStandardMaterial({ color: 0x0a0a0a, roughness: 0.95 });
            const tkBack = new THREE.Mesh(
              new THREE.BoxGeometry(w - 0.1, toeKickHeight - 0.02, 0.02),
              tkBackMat
            );
            tkBack.position.set(0, -h/2 + toeKickHeight/2, d/2 - toeKickRecess);
            group.add(tkBack);

            // Toe kick bottom (floor of recess)
            const tkBottom = new THREE.Mesh(
              new THREE.BoxGeometry(w - 0.1, 0.02, toeKickRecess - 0.02),
              tkBackMat
            );
            tkBottom.position.set(0, -h/2 + 0.01, d/2 - toeKickRecess/2);
            group.add(tkBottom);

            // Left side panel of toe kick recess
            const tkLeft = new THREE.Mesh(
              new THREE.BoxGeometry(0.02, toeKickHeight - 0.02, toeKickRecess),
              tkBackMat
            );
            tkLeft.position.set(-w/2 + 0.05, -h/2 + toeKickHeight/2, d/2 - toeKickRecess/2);
            group.add(tkLeft);

            // Right side panel of toe kick recess
            const tkRight = new THREE.Mesh(
              new THREE.BoxGeometry(0.02, toeKickHeight - 0.02, toeKickRecess),
              tkBackMat
            );
            tkRight.position.set(w/2 - 0.05, -h/2 + toeKickHeight/2, d/2 - toeKickRecess/2);
            group.add(tkRight);

            // Cabinet overhang lip (bottom edge of cabinet above toe kick)
            const lipMat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.4 });
            const lip = new THREE.Mesh(
              new THREE.BoxGeometry(w, 0.03, 0.04),
              lipMat
            );
            lip.position.set(0, -h/2 + toeKickHeight + 0.015, d/2 - 0.02);
            group.add(lip);
          }
          break;
        }

        case 'drawer-base': {
          // Drawer base cabinet with 3-4 stacked drawer fronts
          const dbToeKickHeight = 0.33;
          const dbToeKickRecess = 0.25;
          const dbBodyHeight = h - dbToeKickHeight;
          const dbIsFramed = el.construction === 'framed';

          const cabinetMat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.4 });
          const bodyMat = new THREE.MeshStandardMaterial({ color: 0x2a2a2a, roughness: 0.8 });
          const handleMat = new THREE.MeshStandardMaterial({ color: 0xaaaaaa, metalness: 0.9, roughness: 0.15 });

          // Face frame for framed construction
          if (dbIsFramed) {
            const frameW = 0.06;
            // Top rail
            const topFrame = new THREE.Mesh(new THREE.BoxGeometry(w, frameW, 0.04), cabinetMat);
            topFrame.position.set(0, dbToeKickHeight/2 + dbBodyHeight/2 - frameW/2, d/2 - 0.01);
            group.add(topFrame);
            // Bottom rail
            const botFrame = new THREE.Mesh(new THREE.BoxGeometry(w, frameW, 0.04), cabinetMat);
            botFrame.position.set(0, dbToeKickHeight/2 - dbBodyHeight/2 + frameW/2, d/2 - 0.01);
            group.add(botFrame);
            // Left stile
            const leftFrame = new THREE.Mesh(new THREE.BoxGeometry(frameW, dbBodyHeight - frameW*2, 0.04), cabinetMat);
            leftFrame.position.set(-w/2 + frameW/2, dbToeKickHeight/2, d/2 - 0.01);
            group.add(leftFrame);
            // Right stile
            const rightFrame = new THREE.Mesh(new THREE.BoxGeometry(frameW, dbBodyHeight - frameW*2, 0.04), cabinetMat);
            rightFrame.position.set(w/2 - frameW/2, dbToeKickHeight/2, d/2 - 0.01);
            group.add(rightFrame);
          }

          // Cabinet body (sides, top, back)
          // Back panel
          const back = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.04, dbBodyHeight - 0.04, 0.03),
            bodyMat
          );
          back.position.set(0, dbToeKickHeight/2, -d/2 + 0.02);
          group.add(back);

          // Left side
          const leftSide = new THREE.Mesh(
            new THREE.BoxGeometry(0.04, dbBodyHeight, d),
            cabinetMat
          );
          leftSide.position.set(-w/2 + 0.02, dbToeKickHeight/2, 0);
          group.add(leftSide);

          // Right side
          const rightSide = new THREE.Mesh(
            new THREE.BoxGeometry(0.04, dbBodyHeight, d),
            cabinetMat
          );
          rightSide.position.set(w/2 - 0.02, dbToeKickHeight/2, 0);
          group.add(rightSide);

          // Top
          const topPanel = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.08, 0.04, d - 0.02),
            cabinetMat
          );
          topPanel.position.set(0, dbToeKickHeight/2 + dbBodyHeight/2 - 0.02, 0);
          group.add(topPanel);

          // Draw stacked drawers (3-4 based on width)
          const numDrawers = w > 1.5 ? 4 : 3;
          const drawerGap = 0.02;
          const totalGapHeight = drawerGap * (numDrawers - 1);
          const drawerHeight = (dbBodyHeight - 0.08 - totalGapHeight) / numDrawers;

          // Get door style from element or default
          const dbDoorStyle = el.doorStyle || 'shaker';

          for (let i = 0; i < numDrawers; i++) {
            const drawerY = dbToeKickHeight/2 + dbBodyHeight/2 - 0.04 - drawerHeight/2 - i * (drawerHeight + drawerGap);

            // Drawer front face - positioned AT the front, not inside
            const drawerFront = new THREE.Mesh(
              new THREE.BoxGeometry(w - 0.06, drawerHeight - 0.02, 0.04),
              cabinetMat
            );
            drawerFront.position.set(0, drawerY, d/2 + 0.02);
            group.add(drawerFront);

            // Drawer detail based on door style
            const frameMat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.3 });

            if (dbDoorStyle === 'shaker') {
              // Shaker: recessed panel with frame
              const frameInset = 0.08;
              const recessedMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.8 });
              // Recessed area (dark)
              const recess = new THREE.Mesh(
                new THREE.BoxGeometry(w - 0.06 - frameInset * 2 + 0.02, drawerHeight - 0.02 - frameInset * 2 + 0.02, 0.01),
                recessedMat
              );
              recess.position.set(0, drawerY, d/2 + 0.03);
              group.add(recess);
              // Raised inner panel
              const frame = new THREE.Mesh(
                new THREE.BoxGeometry(w - 0.06 - frameInset * 2, drawerHeight - 0.02 - frameInset * 2, 0.02),
                frameMat
              );
              frame.position.set(0, drawerY, d/2 + 0.05);
              group.add(frame);
            } else if (dbDoorStyle === 'raised') {
              // Raised panel: beveled center
              const frameInset = 0.1;
              const raisedMat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.25 });
              const raised = new THREE.Mesh(
                new THREE.BoxGeometry(w - 0.06 - frameInset * 2, drawerHeight - 0.02 - frameInset * 2, 0.04),
                raisedMat
              );
              raised.position.set(0, drawerY, d/2 + 0.06);
              group.add(raised);
            }
            // flat/slab style = no additional detail

            // Centered bar pull handle
            const handleLen = Math.min(w * 0.4, 0.4);
            const handle = new THREE.Mesh(
              new THREE.BoxGeometry(handleLen, 0.025, 0.025),
              handleMat
            );
            handle.position.set(0, drawerY, d/2 + 0.08);
            group.add(handle);
          }

          // Toe kick
          const tkBackMat = new THREE.MeshStandardMaterial({ color: 0x0a0a0a, roughness: 0.95 });
          const tkBack = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.1, dbToeKickHeight - 0.02, 0.02),
            tkBackMat
          );
          tkBack.position.set(0, -h/2 + dbToeKickHeight/2, d/2 - dbToeKickRecess);
          group.add(tkBack);

          const tkFloor = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.1, 0.02, dbToeKickRecess - 0.02),
            tkBackMat
          );
          tkFloor.position.set(0, -h/2 + 0.01, d/2 - dbToeKickRecess/2);
          group.add(tkFloor);

          break;
        }

        case 'sink-base': {
          // Sink base cabinet - false drawer front + double doors, open interior
          const sbToeKickHeight = 0.33;
          const sbToeKickRecess = 0.25;
          const sbBodyHeight = h - sbToeKickHeight;
          const sbIsFramed = el.construction === 'framed';
          const sbDoorStyle = el.doorStyle || 'shaker';

          const cabinetMat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.4 });
          const bodyMat = new THREE.MeshStandardMaterial({ color: 0x2a2a2a, roughness: 0.8 });
          const handleMat = new THREE.MeshStandardMaterial({ color: 0xaaaaaa, metalness: 0.9, roughness: 0.15 });

          // Face frame for framed construction
          if (sbIsFramed) {
            const frameW = 0.06;
            const topFrame = new THREE.Mesh(new THREE.BoxGeometry(w, frameW, 0.04), cabinetMat);
            topFrame.position.set(0, sbToeKickHeight/2 + sbBodyHeight/2 - frameW/2, d/2 - 0.01);
            group.add(topFrame);
            const botFrame = new THREE.Mesh(new THREE.BoxGeometry(w, frameW, 0.04), cabinetMat);
            botFrame.position.set(0, sbToeKickHeight/2 - sbBodyHeight/2 + frameW/2, d/2 - 0.01);
            group.add(botFrame);
            const leftFrame = new THREE.Mesh(new THREE.BoxGeometry(frameW, sbBodyHeight - frameW*2, 0.04), cabinetMat);
            leftFrame.position.set(-w/2 + frameW/2, sbToeKickHeight/2, d/2 - 0.01);
            group.add(leftFrame);
            const rightFrame = new THREE.Mesh(new THREE.BoxGeometry(frameW, sbBodyHeight - frameW*2, 0.04), cabinetMat);
            rightFrame.position.set(w/2 - frameW/2, sbToeKickHeight/2, d/2 - 0.01);
            group.add(rightFrame);
            // Center stile for double door
            const centerFrame = new THREE.Mesh(new THREE.BoxGeometry(frameW, sbBodyHeight - frameW*2 - 0.2, 0.04), cabinetMat);
            centerFrame.position.set(0, sbToeKickHeight/2 - 0.1, d/2 - 0.01);
            group.add(centerFrame);
          }

          // Cabinet body - open interior for plumbing
          // Back panel (partial - allows plumbing access)
          const back = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.04, sbBodyHeight * 0.6, 0.03),
            bodyMat
          );
          back.position.set(0, sbToeKickHeight/2 - sbBodyHeight * 0.2, -d/2 + 0.02);
          group.add(back);

          // Left side
          const leftSide = new THREE.Mesh(
            new THREE.BoxGeometry(0.04, sbBodyHeight, d),
            cabinetMat
          );
          leftSide.position.set(-w/2 + 0.02, sbToeKickHeight/2, 0);
          group.add(leftSide);

          // Right side
          const rightSide = new THREE.Mesh(
            new THREE.BoxGeometry(0.04, sbBodyHeight, d),
            cabinetMat
          );
          rightSide.position.set(w/2 - 0.02, sbToeKickHeight/2, 0);
          group.add(rightSide);

          // False drawer front (top, non-functional) - at front face
          const falseDrawerH = 0.2;
          const falseDrawer = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.06, falseDrawerH, 0.04),
            cabinetMat
          );
          falseDrawer.position.set(0, sbToeKickHeight/2 + sbBodyHeight/2 - falseDrawerH/2 - 0.02, d/2 + 0.02);
          group.add(falseDrawer);

          // False drawer shaker detail
          if (sbDoorStyle === 'shaker') {
            const recessMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.8 });
            const fdRecess = new THREE.Mesh(
              new THREE.BoxGeometry(w - 0.16, falseDrawerH - 0.06, 0.01),
              recessMat
            );
            fdRecess.position.set(0, sbToeKickHeight/2 + sbBodyHeight/2 - falseDrawerH/2 - 0.02, d/2 + 0.03);
            group.add(fdRecess);
          }

          // False drawer handle
          const fdHandle = new THREE.Mesh(
            new THREE.BoxGeometry(w * 0.35, 0.02, 0.02),
            handleMat
          );
          fdHandle.position.set(0, sbToeKickHeight/2 + sbBodyHeight/2 - falseDrawerH/2 - 0.02, d/2 + 0.07);
          group.add(fdHandle);

          // Double doors below false drawer
          const doorsHeight = sbBodyHeight - falseDrawerH - 0.08;
          const doorsY = sbToeKickHeight/2 - 0.02;
          const doorW = (w - 0.1) / 2;
          const doorGap = 0.02;

          for (let i = 0; i < 2; i++) {
            const doorX = i === 0 ? -doorW/2 - doorGap/2 : doorW/2 + doorGap/2;

            // Door face - at front
            const door = new THREE.Mesh(
              new THREE.BoxGeometry(doorW, doorsHeight, 0.04),
              cabinetMat
            );
            door.position.set(doorX, doorsY, d/2 + 0.02);
            group.add(door);

            // Door detail based on style
            const frameMat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.3 });
            if (sbDoorStyle === 'shaker') {
              const frameInset = 0.1;
              const recessMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.8 });
              const recess = new THREE.Mesh(
                new THREE.BoxGeometry(doorW - frameInset * 2 + 0.02, doorsHeight - frameInset * 2 + 0.02, 0.01),
                recessMat
              );
              recess.position.set(doorX, doorsY, d/2 + 0.03);
              group.add(recess);
              const frame = new THREE.Mesh(
                new THREE.BoxGeometry(doorW - frameInset * 2, doorsHeight - frameInset * 2, 0.02),
                frameMat
              );
              frame.position.set(doorX, doorsY, d/2 + 0.05);
              group.add(frame);
            } else if (sbDoorStyle === 'raised') {
              const frameInset = 0.1;
              const raisedMat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.25 });
              const raised = new THREE.Mesh(
                new THREE.BoxGeometry(doorW - frameInset * 2, doorsHeight - frameInset * 2, 0.04),
                raisedMat
              );
              raised.position.set(doorX, doorsY, d/2 + 0.06);
              group.add(raised);
            }
            // flat/slab = no detail

            // Door handle (vertical bar)
            const handleX = i === 0 ? doorX + doorW/2 - 0.1 : doorX - doorW/2 + 0.1;
            const handle = new THREE.Mesh(
              new THREE.CylinderGeometry(0.012, 0.012, 0.3, 8),
              handleMat
            );
            handle.position.set(handleX, doorsY, d/2 + 0.08);
            group.add(handle);
          }

          // Toe kick
          const tkMat = new THREE.MeshStandardMaterial({ color: 0x0a0a0a, roughness: 0.95 });
          const tkBack = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.1, sbToeKickHeight - 0.02, 0.02),
            tkMat
          );
          tkBack.position.set(0, -h/2 + sbToeKickHeight/2, d/2 - sbToeKickRecess);
          group.add(tkBack);

          const tkFloor = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.1, 0.02, sbToeKickRecess - 0.02),
            tkMat
          );
          tkFloor.position.set(0, -h/2 + 0.01, d/2 - sbToeKickRecess/2);
          group.add(tkFloor);

          break;
        }

        case 'lazy-susan': {
          // LAZY SUSAN CORNER CABINET - L-shaped with rotating shelves inside
          // Similar to corner cabinet but with bi-fold doors revealing lazy susan mechanism

          const cabinetMat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.4 });
          const bodyMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.9 });
          const handleMat = new THREE.MeshStandardMaterial({ color: 0xc0c0c0, metalness: 0.8, roughness: 0.2 });
          const shelfMat = new THREE.MeshStandardMaterial({ color: 0x8B7355, roughness: 0.5 }); // Wood colored shelves
          const doorMat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.35 });

          // Cabinet dimensions
          const toeKickHeight = 0.33;
          const toeKickRecess = 0.25;
          const cabinetBodyHeight = h - toeKickHeight;
          const armDepth = 2; // Standard 24" arm depth
          const panelThickness = 0.06;

          const bodyYOffset = toeKickHeight / 2;

          // Create L-shaped cabinet body using THREE.Shape
          const lsShape = new THREE.Shape();
          lsShape.moveTo(-w/2, -d/2);
          lsShape.lineTo(-w/2, -d/2 + armDepth);
          lsShape.lineTo(-w/2 + armDepth, -d/2 + armDepth);
          lsShape.lineTo(-w/2 + armDepth, d/2);
          lsShape.lineTo(w/2, d/2);
          lsShape.lineTo(w/2, -d/2);
          lsShape.closePath();

          const lsExtrudeSettings = { depth: cabinetBodyHeight, bevelEnabled: false };
          const lsGeometry = new THREE.ExtrudeGeometry(lsShape, lsExtrudeSettings);
          lsGeometry.rotateX(-Math.PI / 2);
          lsGeometry.translate(0, -cabinetBodyHeight/2, 0);

          const cabinetBody = new THREE.Mesh(lsGeometry, cabinetMat);
          cabinetBody.position.y = bodyYOffset;
          group.add(cabinetBody);

          // Dark interior panels
          const backPanel = new THREE.Mesh(
            new THREE.BoxGeometry(w - armDepth - 0.1, cabinetBodyHeight - 0.1, panelThickness),
            bodyMat
          );
          backPanel.position.set(armDepth/2, bodyYOffset, -d/2 + armDepth - panelThickness/2);
          group.add(backPanel);

          const sidePanel = new THREE.Mesh(
            new THREE.BoxGeometry(panelThickness, cabinetBodyHeight - 0.1, d - armDepth - 0.1),
            bodyMat
          );
          sidePanel.position.set(-w/2 + armDepth - panelThickness/2, bodyYOffset, armDepth/2);
          group.add(sidePanel);

          // LAZY SUSAN ROTATING SHELVES - visible through diagonal opening
          const shelfRadius = Math.min(w, d) * 0.42;
          const shelfCenterX = 0;  // Center of cabinet opening
          const shelfCenterZ = 0;
          const numShelves = 2;

          // Center pole (chrome/metal)
          const poleMat = new THREE.MeshStandardMaterial({ color: 0x888888, metalness: 0.7, roughness: 0.3 });
          const centerPole = new THREE.Mesh(
            new THREE.CylinderGeometry(0.025, 0.025, cabinetBodyHeight - 0.2, 16),
            poleMat
          );
          centerPole.position.set(shelfCenterX, bodyYOffset, shelfCenterZ);
          group.add(centerPole);

          // Create kidney/pie-shaped lazy susan shelves
          for (let s = 0; s < numShelves; s++) {
            const shelfY = bodyYOffset - cabinetBodyHeight/2 + 0.5 + s * (cabinetBodyHeight * 0.4);

            // Create pie-shaped shelf (270 degrees)
            const pieShape = new THREE.Shape();
            const pieAngleStart = Math.PI * 0.75;  // Start at back-left
            const pieAngleEnd = Math.PI * 2.25;    // 270 degrees
            const segments = 32;

            pieShape.moveTo(0, 0);
            for (let i = 0; i <= segments; i++) {
              const angle = pieAngleStart + (pieAngleEnd - pieAngleStart) * (i / segments);
              pieShape.lineTo(Math.cos(angle) * shelfRadius, Math.sin(angle) * shelfRadius);
            }
            pieShape.lineTo(0, 0);

            const shelfGeom = new THREE.ExtrudeGeometry(pieShape, { depth: 0.025, bevelEnabled: false });
            shelfGeom.rotateX(-Math.PI / 2);

            const shelf = new THREE.Mesh(shelfGeom, shelfMat);
            shelf.position.set(shelfCenterX, shelfY, shelfCenterZ);
            shelf.rotation.y = Math.PI / 4; // Rotate to face opening
            group.add(shelf);

            // Shelf rim (edge)
            const rimMat = new THREE.MeshStandardMaterial({ color: 0x665544, roughness: 0.6 });
            const rimCurve = new THREE.EllipseCurve(0, 0, shelfRadius, shelfRadius, pieAngleStart, pieAngleEnd, false);
            const rimPoints = rimCurve.getPoints(32);
            const rimGeom = new THREE.BufferGeometry().setFromPoints(
              rimPoints.map(p => new THREE.Vector3(p.x, 0, p.y))
            );
            const rim = new THREE.Line(rimGeom, new THREE.LineBasicMaterial({ color: 0x444444 }));
            rim.position.set(shelfCenterX, shelfY + 0.015, shelfCenterZ);
            rim.rotation.y = Math.PI / 4;
            group.add(rim);
          }

          // DIAGONAL BI-FOLD DOORS (characteristic of lazy susan cabinets)
          const diagP1 = { x: -w/2 + armDepth, z: d/2 };
          const diagP2 = { x: w/2, z: -d/2 + armDepth };
          const diagDoorWidth = Math.sqrt(Math.pow(diagP2.x - diagP1.x, 2) + Math.pow(diagP1.z - diagP2.z, 2));
          const doorHeight = cabinetBodyHeight - 0.15;
          const halfDoorWidth = (diagDoorWidth - 0.1) / 2;

          const diagCenterX = (diagP1.x + diagP2.x) / 2;
          const diagCenterZ = (diagP1.z + diagP2.z) / 2;

          // Create two doors (bi-fold style)
          for (let doorIdx = 0; doorIdx < 2; doorIdx++) {
            const doorGroup = new THREE.Group();

            // Door panel
            const doorPanel = new THREE.Mesh(
              new THREE.BoxGeometry(halfDoorWidth, doorHeight, panelThickness),
              doorMat
            );
            doorGroup.add(doorPanel);

            // Shaker inset
            const insetW = halfDoorWidth - 0.15;
            const insetH = doorHeight - 0.2;
            const inset = new THREE.Mesh(
              new THREE.BoxGeometry(insetW, insetH, 0.02),
              new THREE.MeshStandardMaterial({ color: adjustColorBrightness(color, -10), roughness: 0.5 })
            );
            inset.position.z = panelThickness/2 + 0.01;
            doorGroup.add(inset);

            // Handle
            const handle = new THREE.Mesh(
              new THREE.CylinderGeometry(0.01, 0.01, 0.2, 8),
              handleMat
            );
            handle.rotation.x = Math.PI / 2;
            const handleXPos = doorIdx === 0 ? halfDoorWidth/2 - 0.08 : -halfDoorWidth/2 + 0.08;
            handle.position.set(handleXPos, 0, panelThickness/2 + 0.03);
            doorGroup.add(handle);

            // Position door
            const doorXOffset = doorIdx === 0 ? -halfDoorWidth/2 - 0.02 : halfDoorWidth/2 + 0.02;
            doorGroup.rotation.y = Math.PI / 4;

            // Calculate position along diagonal
            const offsetDir = doorIdx === 0 ? -1 : 1;
            const offsetAmount = halfDoorWidth/2 + 0.02;
            doorGroup.position.set(
              diagCenterX + offsetDir * offsetAmount * Math.cos(Math.PI/4) * 0.5,
              bodyYOffset,
              diagCenterZ + offsetDir * offsetAmount * Math.sin(Math.PI/4) * 0.5
            );
            group.add(doorGroup);
          }

          // TOE KICK
          const tkMat = new THREE.MeshStandardMaterial({ color: 0x080808, roughness: 0.95 });
          const tkHeight = toeKickHeight - 0.02;

          const tkShape = new THREE.Shape();
          tkShape.moveTo(-w/2 + toeKickRecess, -d/2 + toeKickRecess);
          tkShape.lineTo(-w/2 + toeKickRecess, -d/2 + armDepth - toeKickRecess);
          tkShape.lineTo(-w/2 + armDepth - toeKickRecess, -d/2 + armDepth - toeKickRecess);
          tkShape.lineTo(-w/2 + armDepth - toeKickRecess, d/2 - toeKickRecess);
          tkShape.lineTo(w/2 - toeKickRecess, d/2 - toeKickRecess);
          tkShape.lineTo(w/2 - toeKickRecess, -d/2 + toeKickRecess);
          tkShape.closePath();

          const tkExtrudeSettings = { depth: tkHeight, bevelEnabled: false };
          const tkGeometry = new THREE.ExtrudeGeometry(tkShape, tkExtrudeSettings);
          tkGeometry.rotateX(-Math.PI / 2);
          tkGeometry.translate(0, -h/2 + tkHeight/2, 0);

          const toeKick = new THREE.Mesh(tkGeometry, tkMat);
          group.add(toeKick);

          // Floor shadow
          const tkFloor = new THREE.Mesh(
            new THREE.PlaneGeometry(w, d),
            new THREE.MeshStandardMaterial({ color: 0x0a0a0a, roughness: 1 })
          );
          tkFloor.rotation.x = -Math.PI / 2;
          tkFloor.position.y = -h/2 + 0.01;
          group.add(tkFloor);

          break;
        }

        case 'corner-cabinet': {
          // L-SHAPED CORNER CABINET - Sits in corner with diagonal door
          // Standard corner cabinet: 36" x 36" footprint, arms are 24" deep
          // Cabinet sits in back-left corner with diagonal door facing front-right

          const cabinetMat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.4 });
          const bodyMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.9 });
          const handleMat = new THREE.MeshStandardMaterial({ color: 0xc0c0c0, metalness: 0.8, roughness: 0.2 });
          const doorMat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.35 });
          const frameMat = new THREE.MeshStandardMaterial({ color: adjustColorBrightness(color, -15), roughness: 0.45 });

          // Cabinet dimensions
          const toeKickHeight = 0.33; // 4" toe kick
          const toeKickRecess = 0.25; // 3" recess
          const cabinetBodyHeight = h - toeKickHeight;
          const armDepth = 2; // Standard 24" arm depth
          const panelThickness = 0.06; // 3/4" panels

          // Y offset for body (centered on cabinet body, not including toe kick)
          const bodyYOffset = toeKickHeight / 2;

          // Create L-shaped cabinet using THREE.Shape for proper geometry
          const lShape = new THREE.Shape();
          // Start at back-left corner and trace L-shape clockwise
          // In local coords: back is -Z, left is -X, front is +Z, right is +X
          lShape.moveTo(-w/2, -d/2);                    // Back-left corner (into walls)
          lShape.lineTo(-w/2, -d/2 + armDepth);         // Along left wall
          lShape.lineTo(-w/2 + armDepth, -d/2 + armDepth); // Turn at inside corner
          lShape.lineTo(-w/2 + armDepth, d/2);          // Forward along inside of left arm
          lShape.lineTo(w/2, d/2);                      // Across front (this is where diagonal will be)
          lShape.lineTo(w/2, -d/2);                     // Along right edge to back wall
          lShape.lineTo(-w/2, -d/2);                    // Close back to start

          // Extrude L-shape for cabinet body
          const extrudeSettings = {
            depth: cabinetBodyHeight,
            bevelEnabled: false
          };
          const lGeometry = new THREE.ExtrudeGeometry(lShape, extrudeSettings);
          lGeometry.rotateX(-Math.PI / 2); // Rotate to stand upright
          lGeometry.translate(0, -cabinetBodyHeight/2, 0); // Center vertically

          const cabinetBody = new THREE.Mesh(lGeometry, cabinetMat);
          cabinetBody.position.y = bodyYOffset;
          group.add(cabinetBody);

          // Dark interior back panels (visible through diagonal opening)
          // Back panel
          const backPanel = new THREE.Mesh(
            new THREE.BoxGeometry(w - armDepth - 0.1, cabinetBodyHeight - 0.1, panelThickness),
            bodyMat
          );
          backPanel.position.set(armDepth/2, bodyYOffset, -d/2 + armDepth - panelThickness/2);
          group.add(backPanel);

          // Side interior panel
          const sidePanel = new THREE.Mesh(
            new THREE.BoxGeometry(panelThickness, cabinetBodyHeight - 0.1, d - armDepth - 0.1),
            bodyMat
          );
          sidePanel.position.set(-w/2 + armDepth - panelThickness/2, bodyYOffset, armDepth/2);
          group.add(sidePanel);

          // DIAGONAL DOOR - angled at 45Â° across the open corner
          // Door spans from inside corner to the front edges of both arms
          const diagP1 = { x: -w/2 + armDepth, z: d/2 };  // End of left arm (front-left)
          const diagP2 = { x: w/2, z: -d/2 + armDepth };  // End of back arm (back-right)

          // Door dimensions
          const diagDoorWidth = Math.sqrt(Math.pow(diagP2.x - diagP1.x, 2) + Math.pow(diagP1.z - diagP2.z, 2));
          const doorHeight = cabinetBodyHeight - 0.15;

          // Create door with shaker-style panel
          const doorGroup = new THREE.Group();

          // Door frame/face
          const doorFace = new THREE.Mesh(
            new THREE.BoxGeometry(diagDoorWidth - 0.08, doorHeight, panelThickness),
            doorMat
          );
          doorGroup.add(doorFace);

          // Shaker inset panel (recessed center)
          const insetWidth = diagDoorWidth - 0.35;
          const insetHeight = doorHeight - 0.25;
          const inset = new THREE.Mesh(
            new THREE.BoxGeometry(insetWidth, insetHeight, 0.02),
            new THREE.MeshStandardMaterial({ color: adjustColorBrightness(color, -8), roughness: 0.5 })
          );
          inset.position.z = panelThickness/2 + 0.01;
          doorGroup.add(inset);

          // Shaker frame lines (grooves)
          const grooveMat = new THREE.MeshStandardMaterial({ color: 0x000000, transparent: true, opacity: 0.15 });
          const grooveDepth = 0.005;
          // Top groove
          const topGroove = new THREE.Mesh(new THREE.BoxGeometry(insetWidth + 0.02, 0.02, grooveDepth), grooveMat);
          topGroove.position.set(0, insetHeight/2 + 0.01, panelThickness/2 + 0.015);
          doorGroup.add(topGroove);
          // Bottom groove
          const botGroove = new THREE.Mesh(new THREE.BoxGeometry(insetWidth + 0.02, 0.02, grooveDepth), grooveMat);
          botGroove.position.set(0, -insetHeight/2 - 0.01, panelThickness/2 + 0.015);
          doorGroup.add(botGroove);
          // Left groove
          const leftGroove = new THREE.Mesh(new THREE.BoxGeometry(0.02, insetHeight + 0.02, grooveDepth), grooveMat);
          leftGroove.position.set(-insetWidth/2 - 0.01, 0, panelThickness/2 + 0.015);
          doorGroup.add(leftGroove);
          // Right groove
          const rightGroove = new THREE.Mesh(new THREE.BoxGeometry(0.02, insetHeight + 0.02, grooveDepth), grooveMat);
          rightGroove.position.set(insetWidth/2 + 0.01, 0, panelThickness/2 + 0.015);
          doorGroup.add(rightGroove);

          // Door handle (bar pull)
          const handleLength = 0.25;
          const handle = new THREE.Mesh(
            new THREE.CylinderGeometry(0.012, 0.012, handleLength, 8),
            handleMat
          );
          handle.rotation.x = Math.PI / 2;
          handle.position.set(diagDoorWidth/2 - 0.2, 0, panelThickness/2 + 0.04);
          doorGroup.add(handle);

          // Handle mounting posts
          const postGeom = new THREE.CylinderGeometry(0.008, 0.008, 0.04, 6);
          const post1 = new THREE.Mesh(postGeom, handleMat);
          post1.position.set(diagDoorWidth/2 - 0.2, handleLength/2 - 0.02, panelThickness/2 + 0.02);
          doorGroup.add(post1);
          const post2 = new THREE.Mesh(postGeom, handleMat);
          post2.position.set(diagDoorWidth/2 - 0.2, -handleLength/2 + 0.02, panelThickness/2 + 0.02);
          doorGroup.add(post2);

          // Position and rotate door group
          const diagCenterX = (diagP1.x + diagP2.x) / 2;
          const diagCenterZ = (diagP1.z + diagP2.z) / 2;
          doorGroup.rotation.y = Math.PI / 4; // 45 degree angle (door faces front-right)
          doorGroup.position.set(diagCenterX, bodyYOffset, diagCenterZ);
          group.add(doorGroup);

          // TOE KICK - L-shaped recessed base
          const tkMat = new THREE.MeshStandardMaterial({ color: 0x080808, roughness: 0.95 });
          const tkHeight = toeKickHeight - 0.02;

          // Create L-shaped toe kick using shape (smaller than cabinet by recess amount)
          const tkShape = new THREE.Shape();
          tkShape.moveTo(-w/2 + toeKickRecess, -d/2 + toeKickRecess);
          tkShape.lineTo(-w/2 + toeKickRecess, -d/2 + armDepth - toeKickRecess);
          tkShape.lineTo(-w/2 + armDepth - toeKickRecess, -d/2 + armDepth - toeKickRecess);
          tkShape.lineTo(-w/2 + armDepth - toeKickRecess, d/2 - toeKickRecess);
          tkShape.lineTo(w/2 - toeKickRecess, d/2 - toeKickRecess);
          tkShape.lineTo(w/2 - toeKickRecess, -d/2 + toeKickRecess);
          tkShape.closePath();

          const tkExtrudeSettings = { depth: tkHeight, bevelEnabled: false };
          const tkGeometry = new THREE.ExtrudeGeometry(tkShape, tkExtrudeSettings);
          tkGeometry.rotateX(-Math.PI / 2);
          tkGeometry.translate(0, -h/2 + tkHeight/2, 0);

          const toeKick = new THREE.Mesh(tkGeometry, tkMat);
          group.add(toeKick);

          // Floor under toe kick (visible shadow catcher)
          const tkFloor = new THREE.Mesh(
            new THREE.PlaneGeometry(w, d),
            new THREE.MeshStandardMaterial({ color: 0x0a0a0a, roughness: 1 })
          );
          tkFloor.rotation.x = -Math.PI / 2;
          tkFloor.position.y = -h/2 + 0.01;
          group.add(tkFloor);

          break;
        }

        case 'tall-cabinet': {
          // Tall pantry cabinet with two door sections
          const tallMat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.4 });

          // Main cabinet body (dark interior)
          const bodyMat = new THREE.MeshStandardMaterial({
            color: 0x2a2a2a,
            roughness: 0.8
          });
          const body = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.08, h - 0.08, d - 0.1),
            bodyMat
          );
          body.position.z = -0.02;
          group.add(body);

          // Cabinet face material
          const faceMat = new THREE.MeshStandardMaterial({
            color: color,
            roughness: 0.35,
            metalness: 0.02
          });

          // Door calculation
          const numDoors = Math.max(1, Math.round(w / 1.5));
          const doorGap = 0.03;
          const totalGaps = doorGap * (numDoors + 1);
          const doorWidth = (w - totalGaps) / numDoors;
          const doorHeight = h - doorGap * 2;

          for (let i = 0; i < numDoors; i++) {
            // Door panel (main)
            const door = new THREE.Mesh(
              new THREE.BoxGeometry(doorWidth, doorHeight, 0.06),
              faceMat
            );
            const doorX = -w/2 + doorGap + doorWidth/2 + i * (doorWidth + doorGap);
            door.position.set(doorX, 0, d/2);
            group.add(door);

            // SHAKER FRAME DETAIL
            const frameW = 0.1;
            const frameD = 0.02;
            const frameMat = new THREE.MeshStandardMaterial({
              color: color,
              roughness: 0.3,
              metalness: 0.01
            });

            // Top rail
            const topRail = new THREE.Mesh(
              new THREE.BoxGeometry(doorWidth - 0.04, frameW, frameD),
              frameMat
            );
            topRail.position.set(doorX, doorHeight/2 - frameW/2 - 0.02, d/2 + 0.04);
            group.add(topRail);

            // Bottom rail
            const bottomRail = new THREE.Mesh(
              new THREE.BoxGeometry(doorWidth - 0.04, frameW, frameD),
              frameMat
            );
            bottomRail.position.set(doorX, -doorHeight/2 + frameW/2 + 0.02, d/2 + 0.04);
            group.add(bottomRail);

            // Left stile
            const leftStile = new THREE.Mesh(
              new THREE.BoxGeometry(frameW, doorHeight - frameW * 2 - 0.04, frameD),
              frameMat
            );
            leftStile.position.set(doorX - doorWidth/2 + frameW/2 + 0.02, 0, d/2 + 0.04);
            group.add(leftStile);

            // Right stile
            const rightStile = new THREE.Mesh(
              new THREE.BoxGeometry(frameW, doorHeight - frameW * 2 - 0.04, frameD),
              frameMat
            );
            rightStile.position.set(doorX + doorWidth/2 - frameW/2 - 0.02, 0, d/2 + 0.04);
            group.add(rightStile);

            // Recessed center panel
            const panelMat = new THREE.MeshStandardMaterial({
              color: color,
              roughness: 0.45
            });
            const panelWidth = doorWidth - frameW * 2 - 0.08;
            const panelHeight = doorHeight - frameW * 2 - 0.08;
            const centerPanel = new THREE.Mesh(
              new THREE.BoxGeometry(panelWidth, panelHeight, 0.015),
              panelMat
            );
            centerPanel.position.set(doorX, 0, d/2 + 0.02);
            group.add(centerPanel);

            // HANDLE/PULL
            const handleMat = new THREE.MeshStandardMaterial({
              color: 0xAAAAAA,
              roughness: 0.15,
              metalness: 0.9
            });

            const handleY = el.type === 'wall-cabinet' ? -doorHeight * 0.25 : doorHeight * 0.25;
            const handleSide = (i < numDoors / 2) ? 1 : -1;
            const handleX = doorX + handleSide * (doorWidth/2 - 0.15);

            // Vertical bar pull
            const pullLength = 0.35;
            const pull = new THREE.Mesh(
              new THREE.CylinderGeometry(0.012, 0.012, pullLength, 8),
              handleMat
            );
            // No rotation - vertical by default
            pull.position.set(handleX, handleY, d/2 + 0.1);
            group.add(pull);

            // Pull standoffs (top and bottom of vertical pull)
            const standoffMat = new THREE.MeshStandardMaterial({
              color: 0x888888,
              roughness: 0.2,
              metalness: 0.85
            });
            [-pullLength/2 + 0.04, pullLength/2 - 0.04].forEach(yOffset => {
              const standoff = new THREE.Mesh(
                new THREE.CylinderGeometry(0.015, 0.015, 0.035, 8),
                standoffMat
              );
              standoff.rotation.x = Math.PI / 2;
              standoff.position.set(handleX, handleY + yOffset, d/2 + 0.08);
              group.add(standoff);
            });
          }

          // Toe kick for tall cabinet - proper recessed void
          const toeKickHeight = 0.33;
          const toeKickRecess = 0.25;

          // Toe kick back panel (visible back of recess)
          const tkBackMat = new THREE.MeshStandardMaterial({ color: 0x0a0a0a, roughness: 0.95 });
          const tkBack = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.1, toeKickHeight - 0.02, 0.02),
            tkBackMat
          );
          tkBack.position.set(0, -h/2 + toeKickHeight/2, d/2 - toeKickRecess);
          group.add(tkBack);

          // Toe kick bottom (floor of recess)
          const tkBottom = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.1, 0.02, toeKickRecess - 0.02),
            tkBackMat
          );
          tkBottom.position.set(0, -h/2 + 0.01, d/2 - toeKickRecess/2);
          group.add(tkBottom);

          // Left side panel of toe kick recess
          const tkLeft = new THREE.Mesh(
            new THREE.BoxGeometry(0.02, toeKickHeight - 0.02, toeKickRecess),
            tkBackMat
          );
          tkLeft.position.set(-w/2 + 0.05, -h/2 + toeKickHeight/2, d/2 - toeKickRecess/2);
          group.add(tkLeft);

          // Right side panel of toe kick recess
          const tkRight = new THREE.Mesh(
            new THREE.BoxGeometry(0.02, toeKickHeight - 0.02, toeKickRecess),
            tkBackMat
          );
          tkRight.position.set(w/2 - 0.05, -h/2 + toeKickHeight/2, d/2 - toeKickRecess/2);
          group.add(tkRight);

          // Cabinet overhang lip (bottom edge of cabinet above toe kick)
          const lipMat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.4 });
          const lip = new THREE.Mesh(
            new THREE.BoxGeometry(w, 0.03, 0.04),
            lipMat
          );
          lip.position.set(0, -h/2 + toeKickHeight + 0.015, d/2 - 0.02);
          group.add(lip);
          break;
        }

        case 'fridge-cabinet': {
          // Fridge cabinet - enclosure that goes up and over refrigerator
          // Has side panels, cabinet above, and open space for fridge
          const fridgeCabMat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.4 });

          // Dimensions
          const panelWidth = 0.15;  // Side panel thickness
          const topCabinetH = h * 0.25;  // Cabinet section above fridge
          const fridgeOpeningH = h * 0.65;  // Opening for fridge
          const toeKickHeight = h * 0.10;  // Toe kick area
          const fridgeOpeningW = w - panelWidth * 2;  // Width of fridge opening

          // Dark interior material for opening
          const interiorMat = new THREE.MeshStandardMaterial({
            color: 0x1a1a1a,
            roughness: 0.9
          });

          // === LEFT SIDE PANEL ===
          const leftPanel = new THREE.Mesh(
            new THREE.BoxGeometry(panelWidth, h - toeKickHeight, d),
            fridgeCabMat
          );
          leftPanel.position.set(-w/2 + panelWidth/2, toeKickHeight/2, 0);
          group.add(leftPanel);

          // === RIGHT SIDE PANEL ===
          const rightPanel = new THREE.Mesh(
            new THREE.BoxGeometry(panelWidth, h - toeKickHeight, d),
            fridgeCabMat
          );
          rightPanel.position.set(w/2 - panelWidth/2, toeKickHeight/2, 0);
          group.add(rightPanel);

          // === TOP CABINET SECTION (above fridge opening) ===
          const topCabinet = new THREE.Mesh(
            new THREE.BoxGeometry(fridgeOpeningW, topCabinetH, d),
            fridgeCabMat
          );
          topCabinet.position.set(0, h/2 - topCabinetH/2, 0);
          group.add(topCabinet);

          // === CABINET DOOR ON TOP SECTION ===
          const doorMat = new THREE.MeshStandardMaterial({
            color: color,
            roughness: 0.35,
            metalness: 0.02
          });

          const doorGap = 0.03;
          const doorW = fridgeOpeningW - doorGap * 2;
          const doorH = topCabinetH - doorGap * 2;

          // Door panel
          const topDoor = new THREE.Mesh(
            new THREE.BoxGeometry(doorW, doorH, 0.06),
            doorMat
          );
          topDoor.position.set(0, h/2 - topCabinetH/2, d/2);
          group.add(topDoor);

          // Shaker frame detail on door
          const frameW = 0.08;
          const frameD = 0.02;
          const frameMat = new THREE.MeshStandardMaterial({
            color: color,
            roughness: 0.3,
            metalness: 0.01
          });

          // Top rail
          const topRail = new THREE.Mesh(
            new THREE.BoxGeometry(doorW - 0.04, frameW, frameD),
            frameMat
          );
          topRail.position.set(0, h/2 - doorGap - frameW/2 - 0.02, d/2 + 0.04);
          group.add(topRail);

          // Bottom rail
          const bottomRail = new THREE.Mesh(
            new THREE.BoxGeometry(doorW - 0.04, frameW, frameD),
            frameMat
          );
          bottomRail.position.set(0, h/2 - topCabinetH + doorGap + frameW/2 + 0.02, d/2 + 0.04);
          group.add(bottomRail);

          // Left stile
          const leftStile = new THREE.Mesh(
            new THREE.BoxGeometry(frameW, doorH - frameW * 2 - 0.04, frameD),
            frameMat
          );
          leftStile.position.set(-doorW/2 + frameW/2 + 0.02, h/2 - topCabinetH/2, d/2 + 0.04);
          group.add(leftStile);

          // Right stile
          const rightStile = new THREE.Mesh(
            new THREE.BoxGeometry(frameW, doorH - frameW * 2 - 0.04, frameD),
            frameMat
          );
          rightStile.position.set(doorW/2 - frameW/2 - 0.02, h/2 - topCabinetH/2, d/2 + 0.04);
          group.add(rightStile);

          // Door handle (centered, horizontal bar)
          const handleMat = new THREE.MeshStandardMaterial({
            color: 0xAAAAAA,
            roughness: 0.15,
            metalness: 0.9
          });
          const handleLength = 0.3;
          const handle = new THREE.Mesh(
            new THREE.CylinderGeometry(0.012, 0.012, handleLength, 8),
            handleMat
          );
          handle.rotation.z = Math.PI / 2;  // Horizontal
          handle.position.set(0, h/2 - topCabinetH + doorGap + 0.1, d/2 + 0.1);
          group.add(handle);

          // Handle standoffs
          const standoffMat = new THREE.MeshStandardMaterial({
            color: 0x888888,
            roughness: 0.2,
            metalness: 0.85
          });
          [-handleLength/2 + 0.04, handleLength/2 - 0.04].forEach(xOffset => {
            const standoff = new THREE.Mesh(
              new THREE.CylinderGeometry(0.015, 0.015, 0.035, 8),
              standoffMat
            );
            standoff.rotation.x = Math.PI / 2;
            standoff.position.set(xOffset, h/2 - topCabinetH + doorGap + 0.1, d/2 + 0.08);
            group.add(standoff);
          });

          // === FRIDGE OPENING (dark recess) ===
          // Back panel of fridge space
          const fridgeBack = new THREE.Mesh(
            new THREE.BoxGeometry(fridgeOpeningW - 0.02, fridgeOpeningH, 0.02),
            interiorMat
          );
          fridgeBack.position.set(0, h/2 - topCabinetH - fridgeOpeningH/2, -d/2 + 0.02);
          group.add(fridgeBack);

          // Bottom of fridge space (above toe kick)
          const fridgeBottom = new THREE.Mesh(
            new THREE.BoxGeometry(fridgeOpeningW - 0.02, 0.02, d - 0.1),
            interiorMat
          );
          fridgeBottom.position.set(0, h/2 - topCabinetH - fridgeOpeningH - 0.01, 0);
          group.add(fridgeBottom);

          // === TOE KICK ===
          const tkMat = new THREE.MeshStandardMaterial({ color: 0x0a0a0a, roughness: 0.95 });
          const toeKickRecess = 0.2;

          // Toe kick back
          const tkBack = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.1, toeKickHeight - 0.02, 0.02),
            tkMat
          );
          tkBack.position.set(0, -h/2 + toeKickHeight/2, d/2 - toeKickRecess);
          group.add(tkBack);

          // Toe kick bottom
          const tkBottom = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.1, 0.02, toeKickRecess - 0.02),
            tkMat
          );
          tkBottom.position.set(0, -h/2 + 0.01, d/2 - toeKickRecess/2);
          group.add(tkBottom);

          // Left toe kick side
          const tkLeft = new THREE.Mesh(
            new THREE.BoxGeometry(0.02, toeKickHeight - 0.02, toeKickRecess),
            tkMat
          );
          tkLeft.position.set(-w/2 + 0.05, -h/2 + toeKickHeight/2, d/2 - toeKickRecess/2);
          group.add(tkLeft);

          // Right toe kick side
          const tkRight = new THREE.Mesh(
            new THREE.BoxGeometry(0.02, toeKickHeight - 0.02, toeKickRecess),
            tkMat
          );
          tkRight.position.set(w/2 - 0.05, -h/2 + toeKickHeight/2, d/2 - toeKickRecess/2);
          group.add(tkRight);

          // Lip above toe kick
          const lipMat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.4 });
          const lip = new THREE.Mesh(
            new THREE.BoxGeometry(w, 0.03, 0.04),
            lipMat
          );
          lip.position.set(0, -h/2 + toeKickHeight + 0.015, d/2 - 0.02);
          group.add(lip);

          break;
        }

        case 'island': {
          // Kitchen island with overhang and proper toe kick
          const baseMat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.4 });

          // Toe kick dimensions
          const toeKickHeight = 0.33;
          const toeKickRecess = 0.25;
          const bodyHeight = h - toeKickHeight - 0.12; // Minus toe kick and countertop

          // Base cabinet portion (raised above toe kick)
          const base = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.4, bodyHeight, d - 0.4),
            baseMat
          );
          base.position.y = -h/2 + toeKickHeight + bodyHeight/2;
          group.add(base);

          // Countertop with overhang
          const counterMat = new THREE.MeshStandardMaterial({
            color: 0x4a4a4a,
            roughness: 0.15,
            metalness: 0.1
          });
          const counter = new THREE.Mesh(
            new THREE.BoxGeometry(w, 0.12, d),
            counterMat
          );
          counter.position.y = h/2 - 0.06;
          group.add(counter);

          // Add door details on front (adjusted for toe kick)
          const doorMat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.35 });
          const numDoors = Math.round(w / 2);
          const doorW = (w - 0.5) / numDoors - 0.05;
          const doorH = bodyHeight - 0.1;
          for (let i = 0; i < numDoors; i++) {
            const door = new THREE.Mesh(
              new THREE.BoxGeometry(doorW, doorH, 0.05),
              doorMat
            );
            door.position.set(-w/2 + 0.25 + doorW/2 + i * (doorW + 0.05), -h/2 + toeKickHeight + bodyHeight/2, d/2 - 0.2);
            group.add(door);
          }

          // Toe kick void on all four sides (island is free-standing)
          const tkBackMat = new THREE.MeshStandardMaterial({ color: 0x0a0a0a, roughness: 0.95 });

          // Front toe kick
          const tkFront = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.5, toeKickHeight - 0.02, 0.02),
            tkBackMat
          );
          tkFront.position.set(0, -h/2 + toeKickHeight/2, d/2 - 0.2 - toeKickRecess);
          group.add(tkFront);

          // Back toe kick
          const tkBackPanel = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.5, toeKickHeight - 0.02, 0.02),
            tkBackMat
          );
          tkBackPanel.position.set(0, -h/2 + toeKickHeight/2, -d/2 + 0.2 + toeKickRecess);
          group.add(tkBackPanel);

          // Left toe kick
          const tkLeftPanel = new THREE.Mesh(
            new THREE.BoxGeometry(0.02, toeKickHeight - 0.02, d - 0.5),
            tkBackMat
          );
          tkLeftPanel.position.set(-w/2 + 0.2 + toeKickRecess, -h/2 + toeKickHeight/2, 0);
          group.add(tkLeftPanel);

          // Right toe kick
          const tkRightPanel = new THREE.Mesh(
            new THREE.BoxGeometry(0.02, toeKickHeight - 0.02, d - 0.5),
            tkBackMat
          );
          tkRightPanel.position.set(w/2 - 0.2 - toeKickRecess, -h/2 + toeKickHeight/2, 0);
          group.add(tkRightPanel);

          // Toe kick floor
          const tkFloor = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.5, 0.02, d - 0.5),
            tkBackMat
          );
          tkFloor.position.set(0, -h/2 + 0.01, 0);
          group.add(tkFloor);

          // Cabinet overhang lip (all around)
          const lipMat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.4 });

          // Front lip
          const lipFront = new THREE.Mesh(new THREE.BoxGeometry(w - 0.4, 0.03, 0.04), lipMat);
          lipFront.position.set(0, -h/2 + toeKickHeight + 0.015, d/2 - 0.2);
          group.add(lipFront);

          // Back lip
          const lipBack = new THREE.Mesh(new THREE.BoxGeometry(w - 0.4, 0.03, 0.04), lipMat);
          lipBack.position.set(0, -h/2 + toeKickHeight + 0.015, -d/2 + 0.2);
          group.add(lipBack);

          // Left lip
          const lipLeft = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.03, d - 0.4), lipMat);
          lipLeft.position.set(-w/2 + 0.2, -h/2 + toeKickHeight + 0.015, 0);
          group.add(lipLeft);

          // Right lip
          const lipRight = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.03, d - 0.4), lipMat);
          lipRight.position.set(w/2 - 0.2, -h/2 + toeKickHeight + 0.015, 0);
          group.add(lipRight);

          break;
        }

        case 'countertop': {
          // Realistic countertop with texture support and detailed edge profiles
          // Higher roughness preserves color accuracy, lower metalness reduces glare
          const ctopMat = createTexturedMaterial(color, textureUrl, {
            roughness: 0.45,   // Higher roughness for color accuracy
            metalness: 0.01    // Minimal metalness to reduce wash-out
          });

          // Thickness handling: 2cm vs 3cm
          const thickness = el.thickness || '3cm';
          const is2cm = thickness === '2cm';
          const edgeBuildStyle = el.edgeBuildStyle || 'mitered';

          // Slab thickness in feet: 3cm = ~0.1 ft (1.2"), 2cm = ~0.065 ft (0.78")
          const slabThickness = is2cm ? 0.065 : 0.1;
          // For 2cm counters, add plywood and drop edge to create full thickness appearance
          const totalVisibleHeight = is2cm ? 0.1 : slabThickness; // 2cm appears same as 3cm with buildup

          // Seam gap for clean butting between adjacent countertops
          const seamGap = 0.01;
          const slabW = w - seamGap;
          const slabD = d - seamGap;
          const edgeProfile = el.edgeProfile || 'eased';

          // For 2cm counters: add plywood underlayment
          if (is2cm) {
            const plywoodMat = new THREE.MeshStandardMaterial({
              color: 0xD4A76A, // Plywood color
              roughness: 0.8,
              metalness: 0
            });

            // Plywood thickness (3/4" = 0.0625 ft)
            const plywoodThickness = 0.0625;

            // Plywood sheet under the stone (visible from below/back)
            const plywood = new THREE.Mesh(
              new THREE.BoxGeometry(slabW - 0.1, plywoodThickness, slabD - 0.3),
              plywoodMat
            );
            plywood.position.set(0, -slabThickness/2 - plywoodThickness/2 + 0.02, -0.1);
            group.add(plywood);

            // Drop edge strips (laminated, mitered, or stacked)
            const dropEdgeMat = createTexturedMaterial(color, textureUrl, {
              roughness: 0.1,
              metalness: 0.08
            });

            // Drop height creates appearance of 4cm (1.5") thick stone
            const dropHeight = 0.035; // ~0.4" additional drop for 4cm look

            if (edgeBuildStyle === 'laminated') {
              // Laminated edge - seamless 4cm look, no visible joint
              // Stone strip laminated to underside with polished, invisible seam
              const lamEdge = new THREE.Mesh(
                new THREE.BoxGeometry(slabW, dropHeight, 0.06),
                dropEdgeMat
              );
              lamEdge.position.set(0, -slabThickness/2 - dropHeight/2, slabD/2 - 0.03);
              group.add(lamEdge);
              // No visible seam line for laminated

            } else if (edgeBuildStyle === 'mitered') {
              // Mitered edge - 45Â° angled seam, nearly invisible
              const miterEdge = new THREE.Mesh(
                new THREE.BoxGeometry(slabW, dropHeight, 0.05),
                dropEdgeMat
              );
              miterEdge.position.set(0, -slabThickness/2 - dropHeight/2, slabD/2 - 0.025);
              group.add(miterEdge);

              // Subtle 45Â° seam line (barely visible)
              const miterSeamMat = new THREE.MeshStandardMaterial({ color: 0x555555, roughness: 0.4, transparent: true, opacity: 0.6 });
              const miterSeam = new THREE.Mesh(
                new THREE.BoxGeometry(slabW + 0.005, 0.002, 0.055),
                miterSeamMat
              );
              // Position seam at the 45Â° joint angle
              miterSeam.rotation.x = Math.PI * 0.25; // 45Â° angle
              miterSeam.position.set(0, -slabThickness/2 - 0.002, slabD/2 - 0.015);
              group.add(miterSeam);

            } else {
              // Stacked edge - vertical seam visible at joint
              const stackedEdge = new THREE.Mesh(
                new THREE.BoxGeometry(slabW, dropHeight, 0.06),
                dropEdgeMat
              );
              stackedEdge.position.set(0, -slabThickness/2 - dropHeight/2, slabD/2 - 0.03);
              group.add(stackedEdge);

              // Visible horizontal seam line (vertical cut joint)
              const seamMat = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.6 });
              const seam = new THREE.Mesh(
                new THREE.BoxGeometry(slabW + 0.01, 0.004, 0.065),
                seamMat
              );
              seam.position.set(0, -slabThickness/2 + 0.002, slabD/2 - 0.03);
              group.add(seam);
            }
          }

          // Adjust h to use actual slab thickness for edge profile calculations
          const effectiveH = slabThickness;

          // Create edge profile geometry based on type
          function createEdgeGeometry(profile, length) {
            const shape = new THREE.Shape();
            const t = effectiveH; // Use actual slab thickness (accounts for 2cm vs 3cm)

            switch(profile) {
              case 'pencil':
                // Pencil round - small rounded top, eased bottom
                shape.moveTo(0, 0);
                shape.lineTo(t, 0);
                shape.lineTo(t, t * 0.75);
                shape.quadraticCurveTo(t, t, t * 0.85, t);
                shape.lineTo(0, t);
                shape.lineTo(0, 0);
                break;

              case 'quarter-round':
                // Quarter round - larger radius than pencil
                shape.moveTo(0, 0);
                shape.lineTo(t, 0);
                shape.lineTo(t, t * 0.5);
                shape.quadraticCurveTo(t, t, t * 0.5, t);
                shape.lineTo(0, t);
                shape.lineTo(0, 0);
                break;

              case 'half-bullnose':
                // Rounded top edge, square bottom
                shape.moveTo(0, 0);
                shape.lineTo(t, 0);
                shape.lineTo(t, t * 0.6);
                shape.quadraticCurveTo(t, t, t * 0.6, t);
                shape.lineTo(0, t);
                shape.lineTo(0, 0);
                break;

              case 'full-bullnose':
                // Fully rounded edge
                shape.moveTo(t * 0.3, 0);
                shape.lineTo(t * 0.7, 0);
                shape.quadraticCurveTo(t, 0, t, t * 0.3);
                shape.lineTo(t, t * 0.7);
                shape.quadraticCurveTo(t, t, t * 0.7, t);
                shape.lineTo(t * 0.3, t);
                shape.quadraticCurveTo(0, t, 0, t * 0.7);
                shape.lineTo(0, t * 0.3);
                shape.quadraticCurveTo(0, 0, t * 0.3, 0);
                break;

              case 'ogee':
                // S-curve profile
                shape.moveTo(0, 0);
                shape.lineTo(t, 0);
                shape.lineTo(t, t * 0.5);
                shape.bezierCurveTo(t, t * 0.7, t * 0.8, t * 0.8, t * 0.6, t * 0.85);
                shape.bezierCurveTo(t * 0.4, t * 0.9, t * 0.2, t, 0, t);
                shape.lineTo(0, 0);
                break;

              case 'double-ogee':
                // Double S-curve profile
                shape.moveTo(0, 0);
                shape.lineTo(t, 0);
                shape.lineTo(t, t * 0.3);
                shape.bezierCurveTo(t, t * 0.4, t * 0.85, t * 0.45, t * 0.7, t * 0.5);
                shape.bezierCurveTo(t * 0.55, t * 0.55, t * 0.55, t * 0.65, t * 0.7, t * 0.7);
                shape.bezierCurveTo(t * 0.85, t * 0.75, t * 0.9, t * 0.85, t * 0.6, t * 0.9);
                shape.bezierCurveTo(t * 0.3, t * 0.95, t * 0.1, t, 0, t);
                shape.lineTo(0, 0);
                break;

              case 'cove':
                // Inward concave curve
                shape.moveTo(0, 0);
                shape.lineTo(t, 0);
                shape.lineTo(t, t * 0.7);
                shape.quadraticCurveTo(t * 0.7, t, 0, t);
                shape.lineTo(0, 0);
                break;

              case 'mitered':
                // 45-degree mitered edge (creates thicker appearance)
                shape.moveTo(0, 0);
                shape.lineTo(t, 0);
                shape.lineTo(t, t * 0.85);
                shape.lineTo(t * 0.85, t);
                shape.lineTo(0, t);
                shape.lineTo(0, 0);
                break;

              case 'bevel':
              case 'quarter-bevel':
                // 45-degree bevel
                shape.moveTo(0, 0);
                shape.lineTo(t, 0);
                shape.lineTo(t, t * 0.7);
                shape.lineTo(t * 0.7, t);
                shape.lineTo(0, t);
                shape.lineTo(0, 0);
                break;

              case 'dupont':
                // Complex multi-step profile
                shape.moveTo(0, 0);
                shape.lineTo(t, 0);
                shape.lineTo(t, t * 0.4);
                shape.lineTo(t * 0.85, t * 0.5);
                shape.quadraticCurveTo(t * 0.7, t * 0.6, t * 0.7, t * 0.75);
                shape.lineTo(t * 0.7, t);
                shape.lineTo(0, t);
                shape.lineTo(0, 0);
                break;

              case 'waterfall':
                // Mitered edge for waterfall effect
                shape.moveTo(0, 0);
                shape.lineTo(t, 0);
                shape.lineTo(t, t);
                shape.lineTo(t * 0.05, t);
                shape.lineTo(0, t * 0.95);
                shape.lineTo(0, 0);
                break;

              case 'eased':
              default:
                // Simple eased/softened corners
                shape.moveTo(0, 0);
                shape.lineTo(t, 0);
                shape.lineTo(t, t * 0.9);
                shape.quadraticCurveTo(t, t, t * 0.9, t);
                shape.lineTo(0, t);
                shape.lineTo(0, 0);
                break;
            }

            const extrudeSettings = {
              steps: 1,
              depth: length,
              bevelEnabled: false
            };

            return new THREE.ExtrudeGeometry(shape, extrudeSettings);
          }

          // Main slab body (slightly inset from edges for profile geometry)
          const bodyInset = effectiveH * 0.1;
          const mainBody = new THREE.Mesh(
            new THREE.BoxGeometry(slabW - bodyInset * 2, effectiveH, slabD - bodyInset * 2),
            ctopMat
          );
          group.add(mainBody);

          // Front edge with profile - slightly more polished than top
          const frontEdgeMat = createTexturedMaterial(color, textureUrl, {
            roughness: 0.15,
            metalness: 0.03
          });

          try {
            const frontEdgeGeo = createEdgeGeometry(edgeProfile, slabW);
            const frontEdge = new THREE.Mesh(frontEdgeGeo, frontEdgeMat);
            frontEdge.rotation.y = Math.PI / 2;
            frontEdge.rotation.x = -Math.PI / 2;
            frontEdge.position.set(-slabW/2, effectiveH/2, slabD/2);
            group.add(frontEdge);
          } catch(e) {
            // Fallback to simple box if edge geometry fails
            const frontEdge = new THREE.Mesh(
              new THREE.BoxGeometry(slabW, effectiveH, bodyInset),
              frontEdgeMat
            );
            frontEdge.position.set(0, 0, slabD/2 - bodyInset/2);
            group.add(frontEdge);
          }

          // Side edges for finished ends
          if (el.finishedEnds) {
            if (el.finishedEnds.includes('left')) {
              try {
                const leftEdgeGeo = createEdgeGeometry(edgeProfile, slabD);
                const leftEdge = new THREE.Mesh(leftEdgeGeo, frontEdgeMat);
                leftEdge.rotation.z = Math.PI / 2;
                leftEdge.rotation.y = Math.PI;
                leftEdge.position.set(-slabW/2, -effectiveH/2, slabD/2);
                group.add(leftEdge);
              } catch(e) {
                const leftEdge = new THREE.Mesh(
                  new THREE.BoxGeometry(bodyInset, effectiveH, slabD),
                  frontEdgeMat
                );
                leftEdge.position.set(-slabW/2 + bodyInset/2, 0, 0);
                group.add(leftEdge);
              }
            }
            if (el.finishedEnds.includes('right')) {
              try {
                const rightEdgeGeo = createEdgeGeometry(edgeProfile, slabD);
                const rightEdge = new THREE.Mesh(rightEdgeGeo, frontEdgeMat);
                rightEdge.rotation.z = -Math.PI / 2;
                rightEdge.position.set(slabW/2, effectiveH/2, -slabD/2);
                group.add(rightEdge);
              } catch(e) {
                const rightEdge = new THREE.Mesh(
                  new THREE.BoxGeometry(bodyInset, effectiveH, slabD),
                  frontEdgeMat
                );
                rightEdge.position.set(slabW/2 - bodyInset/2, 0, 0);
                group.add(rightEdge);
              }
            }
          }

          // Back edge (usually against wall, simple)
          const backEdge = new THREE.Mesh(
            new THREE.BoxGeometry(slabW, effectiveH, bodyInset),
            ctopMat
          );
          backEdge.position.set(0, 0, -slabD/2 + bodyInset/2);
          group.add(backEdge);

          // Top surface - use same material as main body for consistent texture
          // The top surface thin layer adds subtle depth but should match texture
          const topMat = createTexturedMaterial(color, textureUrl, {
            roughness: 0.2,  // Smooth but not mirror-like
            metalness: 0.01  // Minimal metalness for natural stone look
          });
          const topSurface = new THREE.Mesh(
            new THREE.BoxGeometry(slabW - 0.02, 0.003, slabD - 0.02),
            topMat
          );
          topSurface.position.y = effectiveH/2 + 0.002;
          group.add(topSurface);

          // Render seams as subtle grooves in the countertop
          if (el.seams && el.seams.length > 0) {
            const seamMat = new THREE.MeshStandardMaterial({
              color: 0x333333,
              roughness: 0.9,
              metalness: 0
            });

            el.seams.forEach(seam => {
              const seamX = -slabW/2 + slabW * seam.position;
              const seamGroove = new THREE.Mesh(
                new THREE.BoxGeometry(0.008, effectiveH + 0.01, slabD),
                seamMat
              );
              seamGroove.position.set(seamX, 0, 0);
              group.add(seamGroove);
            });
          }

          // Render backsplash if enabled
          if (el.backsplash && el.backsplash.height > 0) {
            const bsHeight = el.backsplash.height / 12; // Convert inches to feet
            const bsThickness = 0.04; // ~0.5 inch thick

            // Use same texture as countertop or a different material
            const bsMat = createTexturedMaterial(color, textureUrl, {
              roughness: 0.15,
              metalness: 0.05
            });

            // Main backsplash panel - sits behind countertop, on top of counter surface
            const bsPanel = new THREE.Mesh(
              new THREE.BoxGeometry(slabW, bsHeight, bsThickness),
              bsMat
            );
            // Position: centered on counter width, height starts at top of counter, against back wall
            bsPanel.position.set(0, h/2 + bsHeight/2, -slabD/2 + bsThickness/2);
            group.add(bsPanel);

            // Top edge detail (eased edge on backsplash)
            const bsTopEdge = new THREE.Mesh(
              new THREE.BoxGeometry(slabW + 0.01, 0.015, bsThickness + 0.02),
              createTexturedMaterial(color, textureUrl, { roughness: 0.1, metalness: 0.1 })
            );
            bsTopEdge.position.set(0, h/2 + bsHeight - 0.0075, -slabD/2 + bsThickness/2);
            group.add(bsTopEdge);

            // Side returns if finished ends are enabled
            if (el.finishedEnds) {
              if (el.finishedEnds.includes('left')) {
                const leftReturn = new THREE.Mesh(
                  new THREE.BoxGeometry(bsThickness, bsHeight, 0.15),
                  bsMat
                );
                leftReturn.position.set(-slabW/2 + bsThickness/2, h/2 + bsHeight/2, -slabD/2 + 0.075);
                group.add(leftReturn);
              }
              if (el.finishedEnds.includes('right')) {
                const rightReturn = new THREE.Mesh(
                  new THREE.BoxGeometry(bsThickness, bsHeight, 0.15),
                  bsMat
                );
                rightReturn.position.set(slabW/2 - bsThickness/2, h/2 + bsHeight/2, -slabD/2 + 0.075);
                group.add(rightReturn);
              }
            }
          }

          // Render waterfall edges (vertical stone panels dropping down from countertop)
          if (el.edgeProfile === 'waterfall' && el.waterfallSides && el.waterfallSides.length > 0) {
            const waterfallMat = createTexturedMaterial(color, textureUrl, {
              roughness: 0.1,
              metalness: 0.08
            });

            // Waterfall drop height (default to floor = counter height)
            const dropHeight = el.waterfallDropFeet || 2.9; // Default counter height from floor

            // For 2cm stone, waterfall gets laminated edges on all visible sides
            const wfThickness = is2cm ? 0.065 : slabThickness;
            const wfEdgeThickness = is2cm ? 0.035 : 0; // Laminated edge build for 2cm

            el.waterfallSides.forEach(side => {
              let wfPanel, wfW, wfD, wfPosX, wfPosZ, wfRotY = 0;

              switch(side) {
                case 'left':
                  wfW = slabD;
                  wfD = wfThickness;
                  wfPosX = -slabW/2 - wfThickness/2;
                  wfPosZ = 0;
                  wfRotY = 0;
                  break;
                case 'right':
                  wfW = slabD;
                  wfD = wfThickness;
                  wfPosX = slabW/2 + wfThickness/2;
                  wfPosZ = 0;
                  wfRotY = 0;
                  break;
                case 'front':
                  wfW = slabW;
                  wfD = wfThickness;
                  wfPosX = 0;
                  wfPosZ = slabD/2 + wfThickness/2;
                  wfRotY = 0;
                  break;
                case 'back':
                  wfW = slabW;
                  wfD = wfThickness;
                  wfPosX = 0;
                  wfPosZ = -slabD/2 - wfThickness/2;
                  wfRotY = 0;
                  break;
              }

              // Main waterfall panel (vertical drop)
              wfPanel = new THREE.Mesh(
                new THREE.BoxGeometry(wfW, dropHeight, wfD),
                waterfallMat
              );
              wfPanel.position.set(wfPosX, -dropHeight/2, wfPosZ);
              group.add(wfPanel);

              // For 2cm stone, add laminated edge build on visible sides
              if (is2cm && wfEdgeThickness > 0) {
                // Front face laminated strip (if front/back waterfall, this is the bottom)
                const lamStripMat = createTexturedMaterial(color, textureUrl, {
                  roughness: 0.1,
                  metalness: 0.08
                });

                // Side laminated strips for left/right waterfalls
                if (side === 'left' || side === 'right') {
                  // Front facing strip
                  const frontStrip = new THREE.Mesh(
                    new THREE.BoxGeometry(wfEdgeThickness, dropHeight, slabD),
                    lamStripMat
                  );
                  const stripX = side === 'left' ? wfPosX - wfThickness/2 - wfEdgeThickness/2 : wfPosX + wfThickness/2 + wfEdgeThickness/2;
                  frontStrip.position.set(stripX, -dropHeight/2, 0);
                  group.add(frontStrip);
                }
              }

              // Add mitered seam at top where waterfall meets countertop
              const miterJointMat = new THREE.MeshStandardMaterial({
                color: 0x444444,
                roughness: 0.3,
                transparent: true,
                opacity: 0.5
              });
              const miterJoint = new THREE.Mesh(
                new THREE.BoxGeometry(wfW + 0.01, 0.003, wfD + 0.01),
                miterJointMat
              );
              miterJoint.position.set(wfPosX, 0, wfPosZ);
              group.add(miterJoint);
            });
          }
          break;
        }

        case 'countertop-l': {
          // L-shaped countertop
          const lMat = createTexturedMaterial(color, textureUrl, {
            roughness: 0.1,
            metalness: 0.08
          });
          const thickness = 0.1; // 3cm thickness

          // L-shape: main arm along width, secondary arm along depth
          // Main horizontal arm (full width, partial depth)
          const armDepth = d * 0.4; // Arm is 40% of total depth
          const mainArm = new THREE.Mesh(
            new THREE.BoxGeometry(w, thickness, armDepth),
            lMat
          );
          mainArm.position.set(0, 0, d/2 - armDepth/2);
          group.add(mainArm);

          // Vertical arm (partial width, full depth)
          const armWidth = w * 0.4;
          const vertArm = new THREE.Mesh(
            new THREE.BoxGeometry(armWidth, thickness, d - armDepth),
            lMat
          );
          vertArm.position.set(-w/2 + armWidth/2, 0, -armDepth/2);
          group.add(vertArm);

          // Top highlight
          const topMat = createTexturedMaterial(color, textureUrl, {
            roughness: 0.05,
            metalness: 0.15
          });
          const topMain = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.02, 0.005, armDepth - 0.02),
            topMat
          );
          topMain.position.set(0, thickness/2, d/2 - armDepth/2);
          group.add(topMain);

          const topVert = new THREE.Mesh(
            new THREE.BoxGeometry(armWidth - 0.02, 0.005, d - armDepth - 0.02),
            topMat
          );
          topVert.position.set(-w/2 + armWidth/2, thickness/2, -armDepth/2);
          group.add(topVert);
          break;
        }

        case 'countertop-u': {
          // U-shaped countertop
          const uMat = createTexturedMaterial(color, textureUrl, {
            roughness: 0.1,
            metalness: 0.08
          });
          const thickness = 0.1; // 3cm thickness

          // U-shape: back arm full width, two side arms
          const armDepth = d * 0.3; // Back arm depth
          const sideWidth = w * 0.25; // Side arm width

          // Back arm (full width, partial depth)
          const backArm = new THREE.Mesh(
            new THREE.BoxGeometry(w, thickness, armDepth),
            uMat
          );
          backArm.position.set(0, 0, -d/2 + armDepth/2);
          group.add(backArm);

          // Left side arm
          const leftArm = new THREE.Mesh(
            new THREE.BoxGeometry(sideWidth, thickness, d - armDepth),
            uMat
          );
          leftArm.position.set(-w/2 + sideWidth/2, 0, armDepth/2);
          group.add(leftArm);

          // Right side arm
          const rightArm = new THREE.Mesh(
            new THREE.BoxGeometry(sideWidth, thickness, d - armDepth),
            uMat
          );
          rightArm.position.set(w/2 - sideWidth/2, 0, armDepth/2);
          group.add(rightArm);

          // Top highlights
          const topMat = createTexturedMaterial(color, textureUrl, {
            roughness: 0.05,
            metalness: 0.15
          });
          const topBack = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.02, 0.005, armDepth - 0.02),
            topMat
          );
          topBack.position.set(0, thickness/2, -d/2 + armDepth/2);
          group.add(topBack);

          const topLeft = new THREE.Mesh(
            new THREE.BoxGeometry(sideWidth - 0.02, 0.005, d - armDepth - 0.02),
            topMat
          );
          topLeft.position.set(-w/2 + sideWidth/2, thickness/2, armDepth/2);
          group.add(topLeft);

          const topRight = new THREE.Mesh(
            new THREE.BoxGeometry(sideWidth - 0.02, 0.005, d - armDepth - 0.02),
            topMat
          );
          topRight.position.set(w/2 - sideWidth/2, thickness/2, armDepth/2);
          group.add(topRight);
          break;
        }

        case 'surface-stainless': {
          // Stainless steel work surface with realistic reflections
          const ssMat = new THREE.MeshStandardMaterial({
            color: 0xD8D8D8,
            roughness: 0.15,
            metalness: 0.9,
            envMap: window.roomEnvMap || null,
            envMapIntensity: 1.2
          });
          const ssTop = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), ssMat);
          group.add(ssTop);

          // Add subtle brushed texture lines
          const lineMat = new THREE.MeshStandardMaterial({
            color: 0xC0C0C0,
            roughness: 0.3,
            metalness: 0.85,
            envMap: window.roomEnvMap || null,
            envMapIntensity: 0.8
          });
          for (let lz = -d/2 + 0.15; lz < d/2; lz += 0.15) {
            const brushLine = new THREE.Mesh(new THREE.BoxGeometry(w - 0.05, h + 0.002, 0.01), lineMat);
            brushLine.position.set(0, 0.001, lz);
            group.add(brushLine);
          }

          // Welded edge (slightly raised rim)
          const rimMat = new THREE.MeshStandardMaterial({
            color: 0xE0E0E0,
            roughness: 0.2,
            metalness: 0.85,
            envMap: window.roomEnvMap || null,
            envMapIntensity: 1.0
          });
          const frontRim = new THREE.Mesh(new THREE.BoxGeometry(w, h + 0.02, 0.02), rimMat);
          frontRim.position.set(0, 0.01, d/2);
          group.add(frontRim);
          break;
        }

        case 'surface-solid': {
          // Solid surface (Corian-style) - matte, seamless look
          const solidMat = createTexturedMaterial(color, textureUrl, {
            roughness: 0.4,
            metalness: 0.02
          });
          const solidTop = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), solidMat);
          group.add(solidTop);

          // Integrated edge (slightly rounded)
          const edgeMat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.35, metalness: 0.01 });
          const frontEdge = new THREE.Mesh(new THREE.BoxGeometry(w - 0.02, h, 0.03), edgeMat);
          frontEdge.position.set(0, 0, d/2 + 0.01);
          group.add(frontEdge);
          break;
        }

        case 'surface-laminate': {
          // Laminate/Formica - thin top layer on substrate
          // Substrate (particle board)
          const substrateMat = new THREE.MeshStandardMaterial({ color: 0xC4A76C, roughness: 0.8 });
          const substrate = new THREE.Mesh(new THREE.BoxGeometry(w, h * 0.85, d), substrateMat);
          substrate.position.y = -h * 0.075;
          group.add(substrate);

          // Laminate top
          const lamMat = createTexturedMaterial(color, textureUrl, {
            roughness: 0.25,
            metalness: 0.05
          });
          const lamTop = new THREE.Mesh(new THREE.BoxGeometry(w + 0.01, h * 0.15, d + 0.01), lamMat);
          lamTop.position.y = h * 0.425;
          group.add(lamTop);

          // Edge banding
          const edgeBandMat = new THREE.MeshStandardMaterial({ color: 0x4A4A4A, roughness: 0.3 });
          const frontBand = new THREE.Mesh(new THREE.BoxGeometry(w + 0.01, h, 0.02), edgeBandMat);
          frontBand.position.set(0, 0, d/2 + 0.01);
          group.add(frontBand);
          break;
        }

        case 'surface-butcherblock': {
          // Butcher block - wood strips
          const bbMat = createTexturedMaterial(color, textureUrl, {
            roughness: 0.55,
            metalness: 0.0
          });
          const bbTop = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), bbMat);
          group.add(bbTop);

          // Wood strip lines (end grain or edge grain pattern)
          const stripMat = new THREE.MeshStandardMaterial({ color: 0x8B6914, roughness: 0.7 });
          const stripWidth = 0.15;
          for (let sx = -w/2 + stripWidth; sx < w/2; sx += stripWidth) {
            const strip = new THREE.Mesh(new THREE.BoxGeometry(0.005, h + 0.002, d - 0.02), stripMat);
            strip.position.set(sx, 0.001, 0);
            group.add(strip);
          }
          break;
        }

        case 'surface-concrete': {
          // Concrete countertop - industrial look
          const concMat = createTexturedMaterial(color, textureUrl, {
            roughness: 0.7,
            metalness: 0.05
          });
          const concTop = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), concMat);
          group.add(concTop);

          // Add subtle aggregate texture spots
          const aggMat = new THREE.MeshStandardMaterial({ color: 0x909090, roughness: 0.8 });
          for (let i = 0; i < 15; i++) {
            const agg = new THREE.Mesh(new THREE.SphereGeometry(0.02 + Math.random() * 0.02, 6, 6), aggMat);
            agg.position.set(
              (Math.random() - 0.5) * (w - 0.1),
              h/2 + 0.01,
              (Math.random() - 0.5) * (d - 0.1)
            );
            agg.scale.y = 0.3;
            group.add(agg);
          }
          break;
        }

        case 'backsplash': {
          // Tile backsplash with texture support
          const bsMat = createTexturedMaterial(color, textureUrl, {
            roughness: 0.25,
            metalness: 0.02
          });
          const bs = new THREE.Mesh(
            new THREE.BoxGeometry(w, h, 0.08),
            bsMat
          );
          group.add(bs);

          // Subtle grout lines
          const groutMat = new THREE.MeshStandardMaterial({ color: 0xCCCCCC, roughness: 0.9 });
          const tileSize = 0.5;
          for (let x = -w/2 + tileSize; x < w/2; x += tileSize) {
            const vGrout = new THREE.Mesh(
              new THREE.BoxGeometry(0.01, h - 0.1, 0.01),
              groutMat
            );
            vGrout.position.set(x, 0, 0.05);
            group.add(vGrout);
          }
          break;
        }

        case 'flooring': {
          // Wood plank flooring with texture support and grain direction
          const floorGrainDir = el.grainDirection || 0;
          const plankMat = createTexturedMaterial(color, textureUrl, {
            roughness: 0.6,
            metalness: 0.0
          });

          // Apply texture rotation based on grain direction
          if (plankMat.map) {
            plankMat.map.rotation = floorGrainDir * Math.PI / 180;
            plankMat.map.center.set(0.5, 0.5);
          }

          const floorBase = new THREE.Mesh(
            new THREE.BoxGeometry(w, h, d),
            plankMat
          );
          group.add(floorBase);

          // Plank grooves - adjust based on grain direction
          const grooveMat = new THREE.MeshStandardMaterial({ color: 0x3a2a1a, roughness: 0.9 });
          const plankW = 0.5;

          if (floorGrainDir === 90) {
            // Vertical planks - grooves run along Z axis
            for (let pz = -d/2 + plankW; pz < d/2; pz += plankW) {
              const groove = new THREE.Mesh(
                new THREE.BoxGeometry(w + 0.01, h + 0.01, 0.008),
                grooveMat
              );
              groove.position.set(0, 0.002, pz);
              group.add(groove);
            }
          } else if (floorGrainDir === 45 || floorGrainDir === 135) {
            // Diagonal planks
            const angle = floorGrainDir * Math.PI / 180;
            const diagonal = Math.sqrt(w * w + d * d);
            for (let p = -diagonal/2 + plankW; p < diagonal/2; p += plankW) {
              const groove = new THREE.Mesh(
                new THREE.BoxGeometry(diagonal, h + 0.01, 0.008),
                grooveMat
              );
              groove.rotation.y = -angle;
              groove.position.set(
                p * Math.sin(angle),
                0.002,
                p * Math.cos(angle)
              );
              group.add(groove);
            }
          } else {
            // Horizontal planks (default) - grooves run along X axis
            for (let px = -w/2 + plankW; px < w/2; px += plankW) {
              const groove = new THREE.Mesh(
                new THREE.BoxGeometry(0.008, h + 0.01, d + 0.01),
                grooveMat
              );
              groove.position.set(px, 0.002, 0);
              group.add(groove);
            }
          }
          break;
        }

        case 'tile': {
          // Tile floor/surface with texture support and direction
          const tileDir = el.grainDirection || 0;
          const tileMat = createTexturedMaterial(color, textureUrl, {
            roughness: 0.3,
            metalness: 0.05
          });

          // Apply texture rotation based on tile direction
          if (tileMat.map) {
            tileMat.map.rotation = tileDir * Math.PI / 180;
            tileMat.map.center.set(0.5, 0.5);
          }

          const tileBase = new THREE.Mesh(
            new THREE.BoxGeometry(w, h, d),
            tileMat
          );
          group.add(tileBase);

          // Grout lines - create a group that can be rotated
          const groutGroup = new THREE.Group();
          const tileGroutMat = new THREE.MeshStandardMaterial({ color: 0x888888, roughness: 0.9 });
          const tileSz = 0.5;

          if (tileDir === 45 || tileDir === 135) {
            // Diagonal tiles - rotate grout lines
            const diagonal = Math.sqrt(w * w + d * d);
            for (let t = -diagonal/2 + tileSz; t < diagonal/2; t += tileSz) {
              const line1 = new THREE.Mesh(
                new THREE.BoxGeometry(0.015, h + 0.005, diagonal + 0.5),
                tileGroutMat
              );
              line1.position.set(t, 0.003, 0);
              groutGroup.add(line1);

              const line2 = new THREE.Mesh(
                new THREE.BoxGeometry(diagonal + 0.5, h + 0.005, 0.015),
                tileGroutMat
              );
              line2.position.set(0, 0.003, t);
              groutGroup.add(line2);
            }
            groutGroup.rotation.y = tileDir * Math.PI / 180;
          } else {
            // Standard grid pattern
            for (let tx = -w/2 + tileSz; tx < w/2; tx += tileSz) {
              const vLine = new THREE.Mesh(
                new THREE.BoxGeometry(0.015, h + 0.005, d + 0.005),
                tileGroutMat
              );
              vLine.position.set(tx, 0.003, 0);
              groutGroup.add(vLine);
            }
            for (let tz = -d/2 + tileSz; tz < d/2; tz += tileSz) {
              const hLine = new THREE.Mesh(
                new THREE.BoxGeometry(w + 0.005, h + 0.005, 0.015),
                tileGroutMat
              );
              hLine.position.set(0, 0.003, tz);
              groutGroup.add(hLine);
            }
          }
          group.add(groutGroup);
          break;
        }

        // ===== SHOWER COMPONENTS =====
        case 'shower-pan': {
          // Shower pan/base with slope and drain
          const panMat = createTexturedMaterial(color, textureUrl, {
            roughness: 0.6,
            metalness: 0.1
          });

          // Main pan surface (slightly recessed in center for slope)
          const panBase = new THREE.Mesh(
            new THREE.BoxGeometry(w, 0.08, d),
            panMat
          );
          panBase.receiveShadow = true;
          group.add(panBase);

          // Drain in center
          const drainMat = new THREE.MeshStandardMaterial({
            color: 0x666666,
            roughness: 0.3,
            metalness: 0.8
          });
          const drain = new THREE.Mesh(
            new THREE.CylinderGeometry(0.15, 0.15, 0.02, 16),
            drainMat
          );
          drain.rotation.x = Math.PI / 2;
          drain.position.set(0, 0.05, 0);
          group.add(drain);

          // Drain grate
          const grateMat = new THREE.MeshStandardMaterial({ color: 0x888888, metalness: 0.7 });
          for (let gi = -2; gi <= 2; gi++) {
            const grate = new THREE.Mesh(
              new THREE.BoxGeometry(0.25, 0.01, 0.015),
              grateMat
            );
            grate.position.set(0, 0.055, gi * 0.04);
            group.add(grate);
          }
          break;
        }

        case 'shower-curb': {
          // Shower curb/threshold
          const curbMat = createTexturedMaterial(color, textureUrl, {
            roughness: 0.5,
            metalness: 0.05
          });

          // Main curb body
          const curb = new THREE.Mesh(
            new THREE.BoxGeometry(w, 0.5, d),  // 6" high curb
            curbMat
          );
          curb.castShadow = true;
          curb.receiveShadow = true;
          group.add(curb);

          // Rounded top edge
          const edgeRadius = 0.05;
          const edgeShape = new THREE.Shape();
          edgeShape.absarc(0, 0, edgeRadius, 0, Math.PI, false);
          const edgeGeom = new THREE.ExtrudeGeometry(edgeShape, { steps: 1, depth: w, bevelEnabled: false });
          const edge = new THREE.Mesh(edgeGeom, curbMat);
          edge.rotation.y = Math.PI / 2;
          edge.position.set(w/2, 0.25 - edgeRadius, d/2);
          group.add(edge);
          break;
        }

        case 'shower-wall':
        case 'wall-tile':
        case 'accent-wall': {
          // Vertical wall panel with tile texture
          const isShower = el.type === 'shower-wall';
          const panelThickness = isShower ? 0.05 : 0.04;

          const panelMat = createTexturedMaterial(color, textureUrl, {
            roughness: isShower ? 0.15 : 0.3,
            metalness: isShower ? 0.1 : 0.05
          });

          // Main panel (vertical orientation)
          const panelHeight = el.wallHeight || (isShower ? 7 : 8);
          const panel = new THREE.Mesh(
            new THREE.BoxGeometry(w, panelHeight, panelThickness),
            panelMat
          );
          panel.position.y = panelHeight / 2 - h / 2;
          panel.castShadow = true;
          panel.receiveShadow = true;
          group.add(panel);

          // Add grout lines for tile look
          if (el.showGrout !== false) {
            const groutMat = new THREE.MeshStandardMaterial({ color: 0x9a9a9a, roughness: 0.9 });
            const tileSz = el.tileSize || 0.5;

            // Vertical grout lines
            for (let tx = -w/2 + tileSz; tx < w/2; tx += tileSz) {
              const vGrout = new THREE.Mesh(
                new THREE.BoxGeometry(0.01, panelHeight - 0.1, 0.005),
                groutMat
              );
              vGrout.position.set(tx, panelHeight/2 - h/2, panelThickness/2 + 0.003);
              group.add(vGrout);
            }

            // Horizontal grout lines
            for (let ty = tileSz; ty < panelHeight; ty += tileSz) {
              const hGrout = new THREE.Mesh(
                new THREE.BoxGeometry(w - 0.05, 0.01, 0.005),
                groutMat
              );
              hGrout.position.set(0, ty - h/2, panelThickness/2 + 0.003);
              group.add(hGrout);
            }
          }

          // Add trim for shower walls
          if (isShower) {
            const trimMat = new THREE.MeshStandardMaterial({ color: 0xC0C0C0, roughness: 0.3, metalness: 0.5 });

            // Top trim/cap
            const topTrim = new THREE.Mesh(
              new THREE.BoxGeometry(w + 0.02, 0.02, panelThickness + 0.02),
              trimMat
            );
            topTrim.position.set(0, panelHeight - h/2, 0);
            group.add(topTrim);

            // Side trims
            [-1, 1].forEach(side => {
              const sideTrim = new THREE.Mesh(
                new THREE.BoxGeometry(0.02, panelHeight, panelThickness + 0.02),
                trimMat
              );
              sideTrim.position.set(side * (w/2 + 0.01), panelHeight/2 - h/2, 0);
              group.add(sideTrim);
            });
          }
          break;
        }

        // ===== STONE CAPS & LEDGES =====
        case 'wall-cap':
        case 'bar-top': {
          // Stone cap/ledge for pony walls, bars, entryways
          // Enhanced rendering with visible overhang and edge profiles
          const isBarTop = el.type === 'bar-top';
          const capThickness = el.thickness || el.stoneThickness || (isBarTop ? 0.125 : 0.1);
          const overhang = el.overhang || (isBarTop ? 0.12 : 0.06); // How much cap extends beyond wall

          // Material with accurate color/texture display
          const capMat = createTexturedMaterial(color, textureUrl, {
            roughness: 0.35,
            metalness: 0.03
          });

          // Main cap surface with overhang on all visible sides
          const capWidth = w + overhang * 2;
          const capDepth = d + overhang;
          const cap = new THREE.Mesh(
            new THREE.BoxGeometry(capWidth, capThickness, capDepth),
            capMat
          );
          cap.position.set(0, 0, overhang / 2);
          cap.castShadow = true;
          cap.receiveShadow = true;
          group.add(cap);

          // Edge profile
          const edgeProfile = el.edgeProfile || 'eased';
          const edgeRadius = capThickness * 0.4;

          if (edgeProfile === 'bullnose' || edgeProfile === 'half-bullnose' || edgeProfile === 'full-bullnose') {
            // Front bullnose edge - rounded profile
            const frontEdge = new THREE.Mesh(
              new THREE.CylinderGeometry(edgeRadius, edgeRadius, capWidth, 16, 1, false, 0, Math.PI),
              capMat
            );
            frontEdge.rotation.x = Math.PI / 2;
            frontEdge.rotation.z = Math.PI / 2;
            frontEdge.position.set(0, -capThickness / 2 + edgeRadius * 0.3, d / 2 + overhang);
            frontEdge.castShadow = true;
            group.add(frontEdge);

            // Side bullnose edges (left and right)
            [-1, 1].forEach(side => {
              const sideEdge = new THREE.Mesh(
                new THREE.CylinderGeometry(edgeRadius * 0.8, edgeRadius * 0.8, capDepth - 0.04, 12, 1, false, 0, Math.PI),
                capMat
              );
              sideEdge.rotation.x = 0;
              sideEdge.rotation.z = side * Math.PI / 2;
              sideEdge.position.set(side * (capWidth / 2 - edgeRadius * 0.3), -capThickness / 2 + edgeRadius * 0.3, overhang / 2);
              group.add(sideEdge);
            });
          } else if (edgeProfile === 'ogee') {
            // Ogee profile - decorative S-curve (simplified as layered boxes)
            const ogeeStep1 = new THREE.Mesh(
              new THREE.BoxGeometry(capWidth - 0.02, capThickness * 0.15, 0.02),
              capMat
            );
            ogeeStep1.position.set(0, -capThickness * 0.4, d / 2 + overhang + 0.01);
            group.add(ogeeStep1);

            const ogeeStep2 = new THREE.Mesh(
              new THREE.BoxGeometry(capWidth - 0.04, capThickness * 0.1, 0.015),
              capMat
            );
            ogeeStep2.position.set(0, -capThickness * 0.52, d / 2 + overhang + 0.02);
            group.add(ogeeStep2);
          } else {
            // Eased edge - subtle chamfer
            const easedEdge = new THREE.Mesh(
              new THREE.BoxGeometry(capWidth, capThickness * 0.2, 0.015),
              capMat
            );
            easedEdge.rotation.x = Math.PI / 6;
            easedEdge.position.set(0, -capThickness * 0.42, d / 2 + overhang + 0.008);
            group.add(easedEdge);
          }

          // Underside detail for depth and shadow
          const undersideMat = new THREE.MeshStandardMaterial({
            color: adjustColorBrightness(color, -35),
            roughness: 0.65
          });

          // Front underside reveal
          const frontReveal = new THREE.Mesh(
            new THREE.BoxGeometry(capWidth - 0.04, 0.025, 0.025),
            undersideMat
          );
          frontReveal.position.set(0, -capThickness / 2 - 0.012, d / 2 + overhang - 0.012);
          group.add(frontReveal);

          // Side reveals for depth
          [-1, 1].forEach(side => {
            const sideReveal = new THREE.Mesh(
              new THREE.BoxGeometry(0.025, 0.02, capDepth - 0.06),
              undersideMat
            );
            sideReveal.position.set(side * (capWidth / 2 - 0.015), -capThickness / 2 - 0.01, overhang / 2);
            group.add(sideReveal);
          });

          break;
        }

        case 'window-sill':
        case 'threshold': {
          // Window sill or door threshold - with visible depth and edge profile
          const isWindowSill = el.type === 'window-sill';
          const slabThickness = el.stoneThickness || (isWindowSill ? 0.08 : 0.04);
          const overhang = isWindowSill ? 0.08 : 0.02; // How much sill sticks out from wall

          const slabMat = createTexturedMaterial(color, textureUrl, {
            roughness: 0.35,
            metalness: 0.05
          });

          // Main slab with overhang for visibility
          const slab = new THREE.Mesh(
            new THREE.BoxGeometry(w + (isWindowSill ? 0.1 : 0), slabThickness, d + overhang),
            slabMat
          );
          slab.position.set(0, 0, overhang / 2);
          slab.castShadow = true;
          slab.receiveShadow = true;
          group.add(slab);

          // Edge profile based on type
          const edgeProfile = el.edgeProfile || 'eased';
          const edgeRadius = slabThickness * 0.4;

          if (edgeProfile === 'bullnose' || edgeProfile === 'half-bullnose') {
            // Bullnose front edge
            const frontEdge = new THREE.Mesh(
              new THREE.CylinderGeometry(edgeRadius, edgeRadius, w + (isWindowSill ? 0.1 : 0), 12, 1, false, 0, Math.PI),
              slabMat
            );
            frontEdge.rotation.x = Math.PI / 2;
            frontEdge.rotation.z = Math.PI / 2;
            frontEdge.position.set(0, -slabThickness / 2 + edgeRadius * 0.5, d / 2 + overhang);
            group.add(frontEdge);
          } else {
            // Eased edge (chamfer)
            const easedEdge = new THREE.Mesh(
              new THREE.BoxGeometry(w + (isWindowSill ? 0.08 : 0), slabThickness * 0.25, 0.015),
              slabMat
            );
            easedEdge.rotation.x = Math.PI / 6; // Slight angle
            easedEdge.position.set(0, -slabThickness * 0.4, d / 2 + overhang + 0.008);
            group.add(easedEdge);
          }

          // For window sill, add subtle return sides for depth
          if (isWindowSill && d > 0.2) {
            const returnDepth = 0.06;
            // Left return
            const leftReturn = new THREE.Mesh(
              new THREE.BoxGeometry(returnDepth, slabThickness, d * 0.8),
              slabMat
            );
            leftReturn.position.set(-w / 2 - returnDepth / 2 + 0.02, 0, -d * 0.1);
            group.add(leftReturn);

            // Right return
            const rightReturn = new THREE.Mesh(
              new THREE.BoxGeometry(returnDepth, slabThickness, d * 0.8),
              slabMat
            );
            rightReturn.position.set(w / 2 + returnDepth / 2 - 0.02, 0, -d * 0.1);
            group.add(rightReturn);
          }

          // Underside shadow detail for depth
          const undersideMat = new THREE.MeshStandardMaterial({
            color: adjustColorBrightness(color, -40),
            roughness: 0.7
          });
          const underside = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.02, 0.01, 0.03),
            undersideMat
          );
          underside.position.set(0, -slabThickness / 2 - 0.005, d / 2 + overhang - 0.015);
          group.add(underside);

          break;
        }

        case 'mantel': {
          // Fireplace mantel/shelf
          const mantelThickness = el.stoneThickness || 0.1;
          const mantelMat = createTexturedMaterial(color, textureUrl, {
            roughness: 0.5,
            metalness: 0
          });

          // Main mantel shelf
          const mantelShelf = new THREE.Mesh(
            new THREE.BoxGeometry(w, mantelThickness, d),
            mantelMat
          );
          group.add(mantelShelf);

          // Corbels/brackets on each end
          const corbelMat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.6 });
          const leftCorbel = new THREE.Mesh(
            new THREE.BoxGeometry(0.15, 0.25, d * 0.8),
            corbelMat
          );
          leftCorbel.position.set(-w / 2 + 0.1, -0.175, 0);
          group.add(leftCorbel);

          const rightCorbel = new THREE.Mesh(
            new THREE.BoxGeometry(0.15, 0.25, d * 0.8),
            corbelMat
          );
          rightCorbel.position.set(w / 2 - 0.1, -0.175, 0);
          group.add(rightCorbel);
          break;
        }

        // ===== STONE SURROUNDS WITH RECESSED VOID =====
        case 'niche-surround':
        case 'fireplace-surround': {
          // Stone surround with proper recessed dark void and stone ledges wrapping into the recess
          const isFireplace = el.type === 'fireplace-surround';
          const frameW = el.frameWidth || 0.15; // ~2" frame width on face
          const frameD = el.stoneThickness || 0.1; // Stone face thickness
          const recessDepth = el.nicheDepth || (isFireplace ? 1.0 : 0.5); // Depth of void (6" standard, 12" fireplace)

          // Opening dimensions (inside the frame)
          const openingW = w - frameW * 2;
          const openingH = h - frameW * 2;

          // Stone material with texture
          const surroundMat = createTexturedMaterial(color, textureUrl, {
            roughness: 0.35,
            metalness: 0.08
          });

          // Darker interior material for the void
          const voidMat = new THREE.MeshStandardMaterial({
            color: 0x0a0a0a,
            roughness: 0.95,
            metalness: 0
          });

          // === RECESSED VOID (dark box behind the frame) ===
          // Back wall of void
          const backWall = new THREE.Mesh(
            new THREE.PlaneGeometry(openingW, openingH),
            voidMat
          );
          backWall.position.set(0, 0, -recessDepth);
          group.add(backWall);

          // Left void wall
          const leftVoid = new THREE.Mesh(
            new THREE.PlaneGeometry(recessDepth, openingH),
            voidMat
          );
          leftVoid.rotation.y = Math.PI / 2;
          leftVoid.position.set(-openingW / 2, 0, -recessDepth / 2);
          group.add(leftVoid);

          // Right void wall
          const rightVoid = new THREE.Mesh(
            new THREE.PlaneGeometry(recessDepth, openingH),
            voidMat
          );
          rightVoid.rotation.y = -Math.PI / 2;
          rightVoid.position.set(openingW / 2, 0, -recessDepth / 2);
          group.add(rightVoid);

          // Top void ceiling
          const topVoid = new THREE.Mesh(
            new THREE.PlaneGeometry(openingW, recessDepth),
            voidMat
          );
          topVoid.rotation.x = Math.PI / 2;
          topVoid.position.set(0, openingH / 2, -recessDepth / 2);
          group.add(topVoid);

          // Bottom void floor
          const bottomVoid = new THREE.Mesh(
            new THREE.PlaneGeometry(openingW, recessDepth),
            voidMat
          );
          bottomVoid.rotation.x = -Math.PI / 2;
          bottomVoid.position.set(0, -openingH / 2, -recessDepth / 2);
          group.add(bottomVoid);

          // === STONE FRAME (Front Face) ===
          // Top stone piece (face)
          const topFace = new THREE.Mesh(
            new THREE.BoxGeometry(w, frameW, frameD),
            surroundMat
          );
          topFace.position.set(0, h / 2 - frameW / 2, frameD / 2);
          topFace.castShadow = true;
          group.add(topFace);

          // Bottom stone piece (face) - wider for fireplace hearth ledge
          const bottomFaceH = isFireplace ? frameW * 1.5 : frameW;
          const bottomFace = new THREE.Mesh(
            new THREE.BoxGeometry(w, bottomFaceH, isFireplace ? frameD * 1.5 : frameD),
            surroundMat
          );
          bottomFace.position.set(0, -h / 2 + bottomFaceH / 2, isFireplace ? frameD * 0.75 : frameD / 2);
          bottomFace.castShadow = true;
          group.add(bottomFace);

          // Left stone piece (face)
          const leftFace = new THREE.Mesh(
            new THREE.BoxGeometry(frameW, openingH, frameD),
            surroundMat
          );
          leftFace.position.set(-w / 2 + frameW / 2, 0, frameD / 2);
          leftFace.castShadow = true;
          group.add(leftFace);

          // Right stone piece (face)
          const rightFace = new THREE.Mesh(
            new THREE.BoxGeometry(frameW, openingH, frameD),
            surroundMat
          );
          rightFace.position.set(w / 2 - frameW / 2, 0, frameD / 2);
          rightFace.castShadow = true;
          group.add(rightFace);

          // === STONE LEDGES (Returns into the recess - visible from front) ===
          const ledgeDepth = Math.min(recessDepth * 0.3, 0.25); // How far ledges go into void

          // Top ledge (stone sill at top of opening, goes into void)
          const topLedge = new THREE.Mesh(
            new THREE.BoxGeometry(openingW, frameD * 0.6, ledgeDepth),
            surroundMat
          );
          topLedge.position.set(0, openingH / 2 - frameD * 0.3, -ledgeDepth / 2);
          topLedge.castShadow = true;
          topLedge.receiveShadow = true;
          group.add(topLedge);

          // Bottom ledge/sill (most visible - like a window sill)
          const sillThickness = frameD * 0.8;
          const sillDepth = ledgeDepth * 1.2;
          const bottomSill = new THREE.Mesh(
            new THREE.BoxGeometry(openingW + 0.02, sillThickness, sillDepth),
            surroundMat
          );
          bottomSill.position.set(0, -openingH / 2 + sillThickness / 2, -sillDepth / 2 + 0.01);
          bottomSill.castShadow = true;
          bottomSill.receiveShadow = true;
          group.add(bottomSill);

          // Left inside ledge (return into void)
          const leftLedge = new THREE.Mesh(
            new THREE.BoxGeometry(frameD * 0.5, openingH - sillThickness * 2, ledgeDepth),
            surroundMat
          );
          leftLedge.position.set(-openingW / 2 + frameD * 0.25, 0, -ledgeDepth / 2);
          leftLedge.castShadow = true;
          group.add(leftLedge);

          // Right inside ledge (return into void)
          const rightLedge = new THREE.Mesh(
            new THREE.BoxGeometry(frameD * 0.5, openingH - sillThickness * 2, ledgeDepth),
            surroundMat
          );
          rightLedge.position.set(openingW / 2 - frameD * 0.25, 0, -ledgeDepth / 2);
          rightLedge.castShadow = true;
          group.add(rightLedge);

          // === EDGE DETAIL (Eased edge on front of sill) ===
          const edgeProfile = el.edgeProfile || 'eased';
          if (edgeProfile !== 'square' && edgeProfile !== 'flat') {
            const edgeRadius = sillThickness * 0.4;
            // Small rounded edge on the front of bottom sill
            const sillEdge = new THREE.Mesh(
              new THREE.CylinderGeometry(edgeRadius * 0.3, edgeRadius * 0.3, openingW, 8, 1, false, 0, Math.PI),
              surroundMat
            );
            sillEdge.rotation.x = Math.PI / 2;
            sillEdge.rotation.z = Math.PI / 2;
            sillEdge.position.set(0, -openingH / 2 + sillThickness * 0.15, frameD * 0.3);
            group.add(sillEdge);
          }

          break;
        }

        case 'fireplace-hearth': {
          // Hearth stone (floor piece in front of fireplace)
          const hearthThickness = el.stoneThickness || 0.08;
          const hearthMat = createTexturedMaterial(color, textureUrl, {
            roughness: 0.35,
            metalness: 0.05
          });

          // Main hearth slab
          const hearth = new THREE.Mesh(
            new THREE.BoxGeometry(w, hearthThickness, d),
            hearthMat
          );
          group.add(hearth);

          // Raised edge at back
          const backEdge = new THREE.Mesh(
            new THREE.BoxGeometry(w, 0.15, hearthThickness),
            hearthMat
          );
          backEdge.position.set(0, 0.035, -d / 2 + hearthThickness / 2);
          group.add(backEdge);

          // Bullnose front edge
          const edgeRadius = hearthThickness / 2;
          const frontEdge = new THREE.Mesh(
            new THREE.CylinderGeometry(edgeRadius, edgeRadius, w, 12, 1, false, 0, Math.PI),
            hearthMat
          );
          frontEdge.rotation.z = Math.PI / 2;
          frontEdge.rotation.y = Math.PI / 2;
          frontEdge.position.set(0, 0, d / 2);
          group.add(frontEdge);
          break;
        }

        case 'sink':
        case 'sink-double':
        case 'sink-farmhouse': {
          // Determine sink style
          const isDouble = el.type === 'sink-double';
          const isFarmhouse = el.type === 'sink-farmhouse';
          const isUndermount = el.mountType === 'undermount' || !isFarmhouse;

          // Get sink color/finish from element property
          const sinkFinish = el.sinkColor || (isFarmhouse ? 'white' : 'stainless');

          // Sink finish color configurations
          const sinkFinishes = {
            stainless: { color: 0xD8D8D8, roughness: 0.25, metalness: 0.85, basinColor: 0x3a3a3a, basinMetal: 0.6 },
            black: { color: 0x2A2A2A, roughness: 0.35, metalness: 0.4, basinColor: 0x1a1a1a, basinMetal: 0.3 },
            white: { color: 0xFFFEF7, roughness: 0.6, metalness: 0.05, basinColor: 0xF8F8F0, basinMetal: 0 },
            graphite: { color: 0x4A4A4A, roughness: 0.4, metalness: 0.3, basinColor: 0x2a2a2a, basinMetal: 0.2 },
            bisque: { color: 0xF5E6D3, roughness: 0.5, metalness: 0.05, basinColor: 0xE8D8C8, basinMetal: 0 },
            bronze: { color: 0x5C4033, roughness: 0.35, metalness: 0.7, basinColor: 0x3a2a20, basinMetal: 0.5 }
          };

          const finish = sinkFinishes[sinkFinish] || sinkFinishes.stainless;

          // Materials based on selected finish with environment maps for reflections
          const sinkMat = new THREE.MeshStandardMaterial({
            color: finish.color,
            roughness: finish.roughness,
            metalness: finish.metalness,
            envMap: finish.metalness > 0.3 ? window.roomEnvMap : null,
            envMapIntensity: finish.metalness > 0.5 ? 1.0 : 0.5
          });

          const basinMat = new THREE.MeshStandardMaterial({
            color: finish.basinColor,
            roughness: finish.roughness + 0.1,
            metalness: finish.basinMetal,
            envMap: finish.basinMetal > 0.3 ? window.roomEnvMap : null,
            envMapIntensity: 0.6
          });

          // Chrome for faucets - adjust based on sink finish
          const chromeFinishes = {
            stainless: { color: 0xE0E0E0, metalness: 0.95 },
            black: { color: 0x1a1a1a, metalness: 0.7 },
            white: { color: 0xE0E0E0, metalness: 0.95 },
            graphite: { color: 0x3a3a3a, metalness: 0.8 },
            bisque: { color: 0xE0E0E0, metalness: 0.95 },
            bronze: { color: 0x5C4033, metalness: 0.8 }
          };
          const chromeConfig = chromeFinishes[sinkFinish] || chromeFinishes.stainless;

          const chromeMat = new THREE.MeshStandardMaterial({
            color: chromeConfig.color,
            roughness: 0.05,
            metalness: chromeConfig.metalness,
            envMap: window.roomEnvMap || null,
            envMapIntensity: 1.5 // Chrome is highly reflective
          });

          // Sink depth (how deep the basin goes)
          const basinDepth = isFarmhouse ? 0.75 : 0.6;

          if (isFarmhouse) {
            // Farmhouse/Apron sink - visible front face
            // Outer shell
            const shell = new THREE.Mesh(
              new THREE.BoxGeometry(w, basinDepth, d),
              sinkMat
            );
            shell.position.y = -basinDepth/2 + 0.05;
            group.add(shell);

            // Apron front (visible below counter)
            const apron = new THREE.Mesh(
              new THREE.BoxGeometry(w + 0.02, basinDepth + 0.1, 0.08),
              sinkMat
            );
            apron.position.set(0, -basinDepth/2, d/2);
            group.add(apron);

            // Inner basin
            const innerBasin = new THREE.Mesh(
              new THREE.BoxGeometry(w - 0.12, basinDepth - 0.1, d - 0.12),
              basinMat
            );
            innerBasin.position.y = -basinDepth/2 + 0.02;
            group.add(innerBasin);

            // Drain
            const drain = new THREE.Mesh(
              new THREE.CylinderGeometry(0.04, 0.04, 0.05, 16),
              chromeMat
            );
            drain.position.set(0, -basinDepth + 0.1, 0);
            group.add(drain);

          } else if (isDouble) {
            // Double basin sink
            const rimThickness = 0.06;
            const dividerWidth = 0.08;

            // Outer rim
            const rim = new THREE.Mesh(
              new THREE.BoxGeometry(w, rimThickness, d),
              sinkMat
            );
            rim.position.y = rimThickness/2;
            group.add(rim);

            // Left basin
            const leftBasinW = (w - dividerWidth) / 2 - 0.08;
            const leftBasin = new THREE.Mesh(
              new THREE.BoxGeometry(leftBasinW, basinDepth, d - 0.12),
              basinMat
            );
            leftBasin.position.set(-w/4 - dividerWidth/4, -basinDepth/2 + rimThickness, 0);
            group.add(leftBasin);

            // Right basin
            const rightBasin = new THREE.Mesh(
              new THREE.BoxGeometry(leftBasinW, basinDepth, d - 0.12),
              basinMat
            );
            rightBasin.position.set(w/4 + dividerWidth/4, -basinDepth/2 + rimThickness, 0);
            group.add(rightBasin);

            // Center divider
            const divider = new THREE.Mesh(
              new THREE.BoxGeometry(dividerWidth, basinDepth * 0.8, d - 0.15),
              sinkMat
            );
            divider.position.set(0, -basinDepth/2 + rimThickness + 0.05, 0);
            group.add(divider);

            // Drains
            const leftDrain = new THREE.Mesh(
              new THREE.CylinderGeometry(0.03, 0.03, 0.04, 16),
              chromeMat
            );
            leftDrain.position.set(-w/4 - dividerWidth/4, -basinDepth + rimThickness + 0.05, 0);
            group.add(leftDrain);

            const rightDrain = new THREE.Mesh(
              new THREE.CylinderGeometry(0.03, 0.03, 0.04, 16),
              chromeMat
            );
            rightDrain.position.set(w/4 + dividerWidth/4, -basinDepth + rimThickness + 0.05, 0);
            group.add(rightDrain);

          } else {
            // Single basin sink (undermount or drop-in)
            const rimThickness = isUndermount ? 0.03 : 0.06;
            const wallThickness = 0.04; // Thickness of sink walls

            // Outer sink shell/body (shiny material - visible part)
            const shellOuter = new THREE.Mesh(
              new THREE.BoxGeometry(w, basinDepth, d),
              sinkMat
            );
            shellOuter.position.y = -basinDepth/2 + rimThickness;
            group.add(shellOuter);

            // Top rim/lip (always visible, thinner for undermount)
            const rim = new THREE.Mesh(
              new THREE.BoxGeometry(w + 0.02, rimThickness, d + 0.02),
              sinkMat
            );
            rim.position.y = rimThickness/2;
            group.add(rim);

            // Inner basin cutout (dark interior)
            const innerBasinMat = new THREE.MeshStandardMaterial({
              color: 0x1a1a1a,
              roughness: 0.6,
              metalness: 0.2
            });

            // Main basin interior (recessed dark area)
            const basinInterior = new THREE.Mesh(
              new THREE.BoxGeometry(w - wallThickness * 2, basinDepth - 0.05, d - wallThickness * 2),
              innerBasinMat
            );
            basinInterior.position.y = -basinDepth/2 + rimThickness - 0.02;
            group.add(basinInterior);

            // Basin bottom (slightly reflective)
            const basinBottomMat = new THREE.MeshStandardMaterial({
              color: finish.basinColor,
              roughness: 0.4,
              metalness: finish.basinMetal + 0.2
            });
            const basinBottom = new THREE.Mesh(
              new THREE.BoxGeometry(w - wallThickness * 2.5, 0.02, d - wallThickness * 2.5),
              basinBottomMat
            );
            basinBottom.position.y = -basinDepth + rimThickness + 0.04;
            group.add(basinBottom);

            // Drain at bottom
            const drain = new THREE.Mesh(
              new THREE.CylinderGeometry(0.04, 0.035, 0.08, 16),
              chromeMat
            );
            drain.position.set(0, -basinDepth + rimThickness + 0.06, 0);
            group.add(drain);

            // Drain ring (decorative)
            const drainRing = new THREE.Mesh(
              new THREE.TorusGeometry(0.045, 0.008, 8, 24),
              chromeMat
            );
            drainRing.rotation.x = Math.PI / 2;
            drainRing.position.set(0, -basinDepth + rimThickness + 0.1, 0);
            group.add(drainRing);
          }

          // Faucet (common to all sink types)
          const faucetBase = new THREE.Mesh(
            new THREE.CylinderGeometry(0.04, 0.06, 0.12, 16),
            chromeMat
          );
          faucetBase.position.set(0, 0.15, -d/2 + 0.12);
          group.add(faucetBase);

          // Faucet neck
          const neck = new THREE.Mesh(
            new THREE.CylinderGeometry(0.022, 0.022, 0.45, 12),
            chromeMat
          );
          neck.position.set(0, 0.38, -d/2 + 0.12);
          group.add(neck);

          // Faucet spout (curved)
          const spout = new THREE.Mesh(
            new THREE.TorusGeometry(0.12, 0.018, 8, 16, Math.PI * 0.55),
            chromeMat
          );
          spout.rotation.x = Math.PI;
          spout.rotation.z = Math.PI / 2;
          spout.position.set(0, 0.52, -d/2 + 0.2);
          group.add(spout);

          // Handles
          const handleMat = new THREE.MeshStandardMaterial({
            color: 0xCCCCCC,
            roughness: 0.1,
            metalness: 0.9
          });

          // Left handle
          const leftHandle = new THREE.Mesh(
            new THREE.CylinderGeometry(0.025, 0.03, 0.08, 12),
            handleMat
          );
          leftHandle.position.set(-0.15, 0.12, -d/2 + 0.12);
          group.add(leftHandle);

          // Right handle
          const rightHandle = new THREE.Mesh(
            new THREE.CylinderGeometry(0.025, 0.03, 0.08, 12),
            handleMat
          );
          rightHandle.position.set(0.15, 0.12, -d/2 + 0.12);
          group.add(rightHandle);

          break;
        }

        case 'stove':
        case 'range':
        case 'cooktop': {
          // Professional range/stove/cooktop
          const stoveMat = new THREE.MeshStandardMaterial({
            color: 0x2a2a2a,
            roughness: 0.3,
            metalness: 0.5
          });

          // Main body
          const stoveBody = new THREE.Mesh(
            new THREE.BoxGeometry(w, h, d),
            stoveMat
          );
          group.add(stoveBody);

          // Cooktop surface (glass or steel)
          const cooktopMat = new THREE.MeshStandardMaterial({
            color: 0x1a1a1a,
            roughness: 0.1,
            metalness: 0.4
          });
          const cooktop = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.08, 0.04, d - 0.15),
            cooktopMat
          );
          cooktop.position.y = h/2 - 0.02;
          group.add(cooktop);

          // Burner grates
          const grateMat = new THREE.MeshStandardMaterial({
            color: 0x1a1a1a,
            roughness: 0.6,
            metalness: 0.3
          });

          const burnerLayout = [
            [-w * 0.25, -d * 0.2], [w * 0.25, -d * 0.2],
            [-w * 0.25, d * 0.2], [w * 0.25, d * 0.2]
          ];

          burnerLayout.forEach(([bx, bz]) => {
            // Grate
            const grate = new THREE.Mesh(
              new THREE.BoxGeometry(0.5, 0.04, 0.5),
              grateMat
            );
            grate.position.set(bx, h/2 + 0.02, bz);
            group.add(grate);

            // Burner ring
            const ringMat = new THREE.MeshStandardMaterial({
              color: 0x333333,
              roughness: 0.5,
              metalness: 0.4
            });
            const ring = new THREE.Mesh(
              new THREE.TorusGeometry(0.15, 0.02, 8, 24),
              ringMat
            );
            ring.rotation.x = Math.PI / 2;
            ring.position.set(bx, h/2, bz);
            group.add(ring);
          });

          // Control knobs
          const knobMat = new THREE.MeshStandardMaterial({
            color: 0x3a3a3a,
            roughness: 0.4,
            metalness: 0.3
          });
          for (let i = 0; i < 5; i++) {
            const knob = new THREE.Mesh(
              new THREE.CylinderGeometry(0.04, 0.04, 0.03, 16),
              knobMat
            );
            knob.rotation.x = Math.PI / 2;
            knob.position.set(-w/2 + 0.2 + i * 0.18, h/2 - 0.3, d/2 + 0.02);
            group.add(knob);
          }

          // Oven door
          const ovenDoorMat = new THREE.MeshStandardMaterial({
            color: 0x2a2a2a,
            roughness: 0.25,
            metalness: 0.45
          });
          const ovenDoor = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.15, h * 0.5, 0.05),
            ovenDoorMat
          );
          ovenDoor.position.set(0, -h * 0.15, d/2);
          group.add(ovenDoor);

          // Oven window
          const glassMat = new THREE.MeshStandardMaterial({
            color: 0x111111,
            roughness: 0.05,
            metalness: 0.1,
            transparent: true,
            opacity: 0.85
          });
          const ovenWindow = new THREE.Mesh(
            new THREE.BoxGeometry(w * 0.6, h * 0.35, 0.02),
            glassMat
          );
          ovenWindow.position.set(0, -h * 0.15, d/2 + 0.04);
          group.add(ovenWindow);

          // Oven handle
          const handleMat = new THREE.MeshStandardMaterial({
            color: 0xB0B0B0,
            roughness: 0.15,
            metalness: 0.85
          });
          const ovenHandle = new THREE.Mesh(
            new THREE.CylinderGeometry(0.02, 0.02, w * 0.7, 12),
            handleMat
          );
          ovenHandle.rotation.z = Math.PI / 2;
          ovenHandle.position.set(0, h * 0.12, d/2 + 0.08);
          group.add(ovenHandle);
          break;
        }

        case 'refrigerator': {
          // French door refrigerator
          const fridgeMat = new THREE.MeshStandardMaterial({
            color: 0xD5D5D5,
            roughness: 0.25,
            metalness: 0.55
          });

          // Main body
          const fridgeBody = new THREE.Mesh(
            new THREE.BoxGeometry(w, h, d),
            fridgeMat
          );
          group.add(fridgeBody);

          // Upper doors (French style - two doors)
          const doorMat = new THREE.MeshStandardMaterial({
            color: 0xE0E0E0,
            roughness: 0.2,
            metalness: 0.6
          });

          const upperDoorH = h * 0.65;
          const doorW = (w - 0.15) / 2;

          // Left upper door
          const leftDoor = new THREE.Mesh(
            new THREE.BoxGeometry(doorW, upperDoorH, 0.04),
            doorMat
          );
          leftDoor.position.set(-doorW/2 - 0.02, h * 0.15, d/2 + 0.02);
          group.add(leftDoor);

          // Right upper door
          const rightDoor = new THREE.Mesh(
            new THREE.BoxGeometry(doorW, upperDoorH, 0.04),
            doorMat
          );
          rightDoor.position.set(doorW/2 + 0.02, h * 0.15, d/2 + 0.02);
          group.add(rightDoor);

          // Freezer drawer
          const freezerDrawer = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.12, h * 0.28, 0.04),
            doorMat
          );
          freezerDrawer.position.set(0, -h * 0.33, d/2 + 0.02);
          group.add(freezerDrawer);

          // Handles
          const handleMat = new THREE.MeshStandardMaterial({
            color: 0xA0A0A0,
            roughness: 0.15,
            metalness: 0.9
          });

          // Left handle
          const leftHandle = new THREE.Mesh(
            new THREE.BoxGeometry(0.04, 0.7, 0.06),
            handleMat
          );
          leftHandle.position.set(-0.08, h * 0.15, d/2 + 0.08);
          group.add(leftHandle);

          // Right handle
          const rightHandle = new THREE.Mesh(
            new THREE.BoxGeometry(0.04, 0.7, 0.06),
            handleMat
          );
          rightHandle.position.set(0.08, h * 0.15, d/2 + 0.08);
          group.add(rightHandle);

          // Freezer handle
          const freezerHandle = new THREE.Mesh(
            new THREE.BoxGeometry(w * 0.6, 0.04, 0.06),
            handleMat
          );
          freezerHandle.position.set(0, -h * 0.2, d/2 + 0.08);
          group.add(freezerHandle);

          // Water/ice dispenser
          const dispenserMat = new THREE.MeshStandardMaterial({
            color: 0x2a2a2a,
            roughness: 0.3
          });
          const dispenser = new THREE.Mesh(
            new THREE.BoxGeometry(0.3, 0.25, 0.02),
            dispenserMat
          );
          dispenser.position.set(0, h * 0.25, d/2 + 0.05);
          group.add(dispenser);
          break;
        }

        case 'dishwasher': {
          // Built-in dishwasher
          const dwMat = new THREE.MeshStandardMaterial({
            color: 0xD0D0D0,
            roughness: 0.25,
            metalness: 0.55
          });

          const dwBody = new THREE.Mesh(
            new THREE.BoxGeometry(w, h, d),
            dwMat
          );
          group.add(dwBody);

          // Control panel
          const dwPanel = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.1, 0.25, 0.02),
            new THREE.MeshStandardMaterial({ color: 0x404040 })
          );
          dwPanel.position.set(0, h/2 - 0.2, d/2 + 0.02);
          group.add(dwPanel);

          // Handle
          const dwHandle = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.4, 0.05, 0.08),
            new THREE.MeshStandardMaterial({ color: 0x808080, metalness: 0.8 })
          );
          dwHandle.position.set(0, h/2 - 0.45, d/2 + 0.06);
          group.add(dwHandle);
          break;
        }

        case 'microwave':
          const mwMat = new THREE.MeshStandardMaterial({ color: 0x3a3a3a, roughness: 0.4, metalness: 0.3 });
          const mwBody = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), mwMat);
          group.add(mwBody);

          // Glass door
          const mwGlass = new THREE.Mesh(
            new THREE.BoxGeometry(w * 0.6, h - 0.15, 0.02),
            new THREE.MeshStandardMaterial({ color: 0x111111, transparent: true, opacity: 0.8 })
          );
          mwGlass.position.set(-w * 0.15, 0, d/2 + 0.02);
          group.add(mwGlass);
          break;

        case 'range-hood':
          // Trapezoidal range hood
          const hoodMat = new THREE.MeshStandardMaterial({ color: 0x808080, metalness: 0.6, roughness: 0.3 });
          const hoodShape = new THREE.Shape();
          hoodShape.moveTo(-w/2, 0);
          hoodShape.lineTo(-w/3, h);
          hoodShape.lineTo(w/3, h);
          hoodShape.lineTo(w/2, 0);
          hoodShape.closePath();

          const extrudeSettings = { depth: d, bevelEnabled: false };
          const hoodGeom = new THREE.ExtrudeGeometry(hoodShape, extrudeSettings);
          hoodGeom.rotateX(Math.PI / 2);
          hoodGeom.translate(0, h/2, -d/2);
          const hood = new THREE.Mesh(hoodGeom, hoodMat);
          group.add(hood);
          break;

        case 'oven':
          const ovenMat = new THREE.MeshStandardMaterial({ color: 0x2a2a2a, roughness: 0.3, metalness: 0.4 });
          const ovenBody = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), ovenMat);
          group.add(ovenBody);

          // Glass door
          const ovenGlass = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.2, h * 0.6, 0.02),
            new THREE.MeshStandardMaterial({ color: 0x1a1a1a, transparent: true, opacity: 0.7 })
          );
          ovenGlass.position.set(0, -h * 0.1, d/2 + 0.02);
          group.add(ovenGlass);

          // Handle
          const ovenHandle = new THREE.Mesh(
            new THREE.BoxGeometry(w * 0.6, 0.05, 0.1),
            new THREE.MeshStandardMaterial({ color: 0xA0A0A0, metalness: 0.7 })
          );
          ovenHandle.position.set(0, h * 0.3, d/2 + 0.08);
          group.add(ovenHandle);
          break;

        case 'door': {
          // Standard interior/exterior door with full frame
          const doorColor = el.color ? parseInt(el.color.replace('#', ''), 16) : 0xDEB887;
          const doorMat2 = new THREE.MeshStandardMaterial({ color: doorColor, roughness: 0.6 });
          const doorFrameMat = new THREE.MeshStandardMaterial({ color: 0xFFFFFF, roughness: 0.5 });
          const frameWidth = 0.08;
          const frameDepth = 0.18;

          // Door panel (slightly recessed from frame)
          const doorPanel = new THREE.Mesh(
            new THREE.BoxGeometry(w - frameWidth * 2, h - frameWidth, 0.08),
            doorMat2
          );
          doorPanel.position.set(0, -frameWidth / 2, 0);
          doorPanel.castShadow = true;
          group.add(doorPanel);

          // Door panel detail (raised panel effect)
          const panelDetailMat = new THREE.MeshStandardMaterial({
            color: adjustColorBrightness(doorColor, -20),
            roughness: 0.5
          });
          const panelInset = new THREE.Mesh(
            new THREE.BoxGeometry(w * 0.6, h * 0.35, 0.02),
            panelDetailMat
          );
          panelInset.position.set(0, h * 0.15, 0.05);
          group.add(panelInset);

          const panelInset2 = new THREE.Mesh(
            new THREE.BoxGeometry(w * 0.6, h * 0.35, 0.02),
            panelDetailMat
          );
          panelInset2.position.set(0, -h * 0.25, 0.05);
          group.add(panelInset2);

          // Frame - top
          const frameTop = new THREE.Mesh(
            new THREE.BoxGeometry(w + frameWidth * 2, frameWidth, frameDepth),
            doorFrameMat
          );
          frameTop.position.set(0, h / 2, 0);
          group.add(frameTop);

          // Frame - left
          const frameLeft = new THREE.Mesh(
            new THREE.BoxGeometry(frameWidth, h, frameDepth),
            doorFrameMat
          );
          frameLeft.position.set(-w / 2 - frameWidth / 2, 0, 0);
          group.add(frameLeft);

          // Frame - right
          const frameRight = new THREE.Mesh(
            new THREE.BoxGeometry(frameWidth, h, frameDepth),
            doorFrameMat
          );
          frameRight.position.set(w / 2 + frameWidth / 2, 0, 0);
          group.add(frameRight);

          // Door handle (lever style)
          const handleMat = new THREE.MeshStandardMaterial({
            color: 0xC0C0C0,
            metalness: 0.8,
            roughness: 0.2
          });

          // Handle plate
          const handlePlate = new THREE.Mesh(
            new THREE.BoxGeometry(0.06, 0.15, 0.02),
            handleMat
          );
          handlePlate.position.set(w / 2 - 0.15, 0, 0.06);
          group.add(handlePlate);

          // Handle lever
          const handleLever = new THREE.Mesh(
            new THREE.BoxGeometry(0.12, 0.03, 0.03),
            handleMat
          );
          handleLever.position.set(w / 2 - 0.12, 0, 0.08);
          group.add(handleLever);

          break;
        }

        case 'window':
        case 'window-large':
        case 'window-bay':
        case 'bay-window':
        case 'picture-window': {
          // Professional Window with proper architectural details
          // Supports: double-hung, single-hung, casement, sliding, fixed, picture
          const windowStyle = el.windowStyle || 'double-hung';
          const mullionPattern = el.mullionPattern || 'standard'; // standard, colonial, prairie, none
          const frameColor = el.frameColor ? parseInt(el.frameColor.replace('#', ''), 16) : 0xFFFFFF;

          // Standard window dimensions (based on architectural standards)
          const frameThickness = 0.1; // ~1.25" frame depth
          const frameWidth = 0.125; // ~1.5" frame profile
          const sashWidth = 0.08; // ~1" sash profile
          const muntinWidth = 0.025; // 5/8" muntin (grille) bars

          // Materials
          const frameMat = new THREE.MeshStandardMaterial({
            color: frameColor,
            roughness: 0.35,
            metalness: 0.15
          });
          const sashMat = new THREE.MeshStandardMaterial({
            color: frameColor,
            roughness: 0.4,
            metalness: 0.1
          });
          const muntinMat = new THREE.MeshStandardMaterial({
            color: frameColor,
            roughness: 0.45,
            metalness: 0.05
          });
          const hardwareMat = new THREE.MeshStandardMaterial({
            color: 0xC0C0C0,
            roughness: 0.2,
            metalness: 0.9
          });
          const weatherstripMat = new THREE.MeshStandardMaterial({
            color: 0x333333,
            roughness: 0.8
          });

          // === MAIN FRAME (Jamb, Head, Sill) ===
          // Head (top jamb)
          const headJamb = new THREE.Mesh(
            new THREE.BoxGeometry(w + 0.05, frameWidth, frameThickness),
            frameMat
          );
          headJamb.position.set(0, h/2 - frameWidth/2, 0);
          headJamb.castShadow = true;
          group.add(headJamb);

          // Side jambs
          [-1, 1].forEach(side => {
            const sideJamb = new THREE.Mesh(
              new THREE.BoxGeometry(frameWidth, h - frameWidth, frameThickness),
              frameMat
            );
            sideJamb.position.set(side * (w/2 - frameWidth/2), -frameWidth/2, 0);
            sideJamb.castShadow = true;
            group.add(sideJamb);
          });

          // Sill (sloped for water drainage)
          const sillHeight = frameWidth * 1.2;
          const sillDepth = frameThickness + 0.15;
          const sillMat = new THREE.MeshStandardMaterial({ color: 0xF5F5F0, roughness: 0.45 });
          const sill = new THREE.Mesh(
            new THREE.BoxGeometry(w + 0.2, sillHeight, sillDepth),
            sillMat
          );
          sill.position.set(0, -h/2 + sillHeight/2, sillDepth/2 - frameThickness/2);
          sill.castShadow = true;
          group.add(sill);

          // Sill nose (drip edge)
          const sillNose = new THREE.Mesh(
            new THREE.BoxGeometry(w + 0.22, 0.02, 0.03),
            sillMat
          );
          sillNose.position.set(0, -h/2 + 0.02, sillDepth - frameThickness/2 + 0.01);
          group.add(sillNose);

          // Calculate glass/sash area
          const openingWidth = w - frameWidth * 2;
          const openingHeight = h - frameWidth - sillHeight;
          const outdoorZ = -frameThickness/2 + 0.01;

          // === OUTDOOR VIEW ===
          const outdoorPalette = OUTDOOR_COLORS[sceneSettings.timeOfDay] || OUTDOOR_COLORS.noon;

          if (textureUrl) {
            const viewMat = createTexturedMaterial(0xFFFFFF, textureUrl, {
              roughness: 0.1,
              side: THREE.DoubleSide
            });
            const viewPane = new THREE.Mesh(
              new THREE.PlaneGeometry(openingWidth - 0.1, openingHeight - 0.1),
              viewMat
            );
            viewPane.position.set(0, (openingHeight - h)/2 + sillHeight/2, outdoorZ);
            group.add(viewPane);
          } else {
            // Sky
            const skyMat = new THREE.MeshBasicMaterial({ color: outdoorPalette.sky, side: THREE.DoubleSide });
            const skyPane = new THREE.Mesh(
              new THREE.PlaneGeometry(openingWidth - 0.05, openingHeight - 0.05),
              skyMat
            );
            skyPane.position.set(0, (openingHeight - h)/2 + sillHeight/2, outdoorZ);
            group.add(skyPane);

            // Horizon
            const horizonMat = new THREE.MeshBasicMaterial({ color: outdoorPalette.horizon });
            const horizonPane = new THREE.Mesh(
              new THREE.PlaneGeometry(openingWidth - 0.05, openingHeight * 0.35),
              horizonMat
            );
            horizonPane.position.set(0, -h/2 + sillHeight + openingHeight * 0.17, outdoorZ + 0.002);
            group.add(horizonPane);

            // Trees and sky elements
            if (sceneSettings.timeOfDay !== 'night') {
              const treeMat = new THREE.MeshBasicMaterial({ color: 0x228B22 });
              for (let t = 0; t < 3; t++) {
                const treeSize = 0.12 + Math.random() * 0.12;
                const tree = new THREE.Mesh(new THREE.ConeGeometry(treeSize, treeSize * 2, 6), treeMat);
                tree.position.set((t - 1) * openingWidth * 0.3, -h/2 + sillHeight + openingHeight * 0.25, outdoorZ + 0.005);
                group.add(tree);
              }
              if (sceneSettings.timeOfDay === 'noon') {
                const sunMat = new THREE.MeshBasicMaterial({ color: 0xFFFF99 });
                const sun = new THREE.Mesh(new THREE.CircleGeometry(0.12, 16), sunMat);
                sun.position.set(openingWidth * 0.25, h/2 - frameWidth - openingHeight * 0.25, outdoorZ + 0.003);
                group.add(sun);
              }
            } else {
              const starMat = new THREE.MeshBasicMaterial({ color: 0xFFFFFF });
              for (let i = 0; i < 10; i++) {
                const star = new THREE.Mesh(new THREE.SphereGeometry(0.015, 4, 4), starMat);
                star.position.set(
                  (Math.random() - 0.5) * openingWidth * 0.8,
                  h/2 - frameWidth - openingHeight * 0.3 - Math.random() * openingHeight * 0.4,
                  outdoorZ + 0.003
                );
                group.add(star);
              }
              const moonMat = new THREE.MeshBasicMaterial({ color: 0xFFFACD });
              const moon = new THREE.Mesh(new THREE.CircleGeometry(0.1, 16), moonMat);
              moon.position.set(openingWidth * 0.3, h/2 - frameWidth - openingHeight * 0.25, outdoorZ + 0.004);
              group.add(moon);
            }
          }

          // === SASH AND GLASS based on window style ===
          const glassColor = sceneSettings.timeOfDay === 'night' ? 0x2a3a5a : 0xADD8E6;
          const glassMat = new THREE.MeshStandardMaterial({
            color: glassColor,
            transparent: true,
            opacity: 0.12,
            roughness: 0.02,
            metalness: 0.35
          });

          // Function to create muntin/grille pattern
          const createMuntinPattern = (sashW, sashH, centerX, centerY, zPos) => {
            if (mullionPattern === 'none' || el.type === 'picture-window') return;

            const muntinGroup = new THREE.Group();

            if (mullionPattern === 'colonial') {
              // Colonial: 6 over 6 or 4 over 4 pattern
              const cols = sashW > 1.5 ? 3 : 2;
              const rows = sashH > 1.5 ? 3 : 2;

              // Vertical muntins
              for (let c = 1; c < cols; c++) {
                const vMuntin = new THREE.Mesh(
                  new THREE.BoxGeometry(muntinWidth, sashH - sashWidth * 2, muntinWidth),
                  muntinMat
                );
                vMuntin.position.set(centerX - sashW/2 + sashWidth + c * (sashW - sashWidth * 2) / cols, centerY, zPos + 0.02);
                muntinGroup.add(vMuntin);
              }

              // Horizontal muntins
              for (let r = 1; r < rows; r++) {
                const hMuntin = new THREE.Mesh(
                  new THREE.BoxGeometry(sashW - sashWidth * 2, muntinWidth, muntinWidth),
                  muntinMat
                );
                hMuntin.position.set(centerX, centerY - sashH/2 + sashWidth + r * (sashH - sashWidth * 2) / rows, zPos + 0.02);
                muntinGroup.add(hMuntin);
              }
            } else if (mullionPattern === 'prairie') {
              // Prairie: border pattern with clear center
              const borderInset = Math.min(sashW, sashH) * 0.2;

              // Inner frame
              const borderW = sashW - sashWidth * 2 - borderInset * 2;
              const borderH = sashH - sashWidth * 2 - borderInset * 2;

              // Top border line
              const topBorder = new THREE.Mesh(
                new THREE.BoxGeometry(sashW - sashWidth * 2, muntinWidth, muntinWidth),
                muntinMat
              );
              topBorder.position.set(centerX, centerY + borderH/2 + borderInset/2, zPos + 0.02);
              muntinGroup.add(topBorder);

              // Bottom border line
              const botBorder = new THREE.Mesh(
                new THREE.BoxGeometry(sashW - sashWidth * 2, muntinWidth, muntinWidth),
                muntinMat
              );
              botBorder.position.set(centerX, centerY - borderH/2 - borderInset/2, zPos + 0.02);
              muntinGroup.add(botBorder);

              // Side border lines
              [-1, 1].forEach(side => {
                const sideBorder = new THREE.Mesh(
                  new THREE.BoxGeometry(muntinWidth, sashH - sashWidth * 2, muntinWidth),
                  muntinMat
                );
                sideBorder.position.set(centerX + side * (borderW/2 + borderInset/2), centerY, zPos + 0.02);
                muntinGroup.add(sideBorder);
              });
            } else {
              // Standard: single cross divider
              const vMuntin = new THREE.Mesh(
                new THREE.BoxGeometry(muntinWidth * 1.5, sashH - sashWidth * 2, muntinWidth * 1.5),
                muntinMat
              );
              vMuntin.position.set(centerX, centerY, zPos + 0.02);
              muntinGroup.add(vMuntin);
            }

            group.add(muntinGroup);
          };

          if (windowStyle === 'double-hung' || windowStyle === 'single-hung') {
            // Two sashes - upper and lower
            const sashH = (openingHeight - 0.02) / 2;
            const upperSashY = h/2 - frameWidth - sashH/2;
            const lowerSashY = -h/2 + sillHeight + sashH/2;

            // Upper sash (fixed in single-hung, operable in double-hung)
            const upperSashGroup = new THREE.Group();

            // Upper sash frame
            const upperTop = new THREE.Mesh(new THREE.BoxGeometry(openingWidth, sashWidth, frameThickness * 0.6), sashMat);
            upperTop.position.set(0, sashH/2 - sashWidth/2, 0);
            upperSashGroup.add(upperTop);

            const upperBot = new THREE.Mesh(new THREE.BoxGeometry(openingWidth, sashWidth, frameThickness * 0.6), sashMat);
            upperBot.position.set(0, -sashH/2 + sashWidth/2, 0);
            upperSashGroup.add(upperBot);

            [-1, 1].forEach(side => {
              const upperSide = new THREE.Mesh(new THREE.BoxGeometry(sashWidth, sashH, frameThickness * 0.6), sashMat);
              upperSide.position.set(side * (openingWidth/2 - sashWidth/2), 0, 0);
              upperSashGroup.add(upperSide);
            });

            // Upper glass
            const upperGlass = new THREE.Mesh(
              new THREE.PlaneGeometry(openingWidth - sashWidth * 2 - 0.02, sashH - sashWidth * 2 - 0.02),
              glassMat
            );
            upperGlass.position.z = 0.02;
            upperSashGroup.add(upperGlass);

            upperSashGroup.position.set(0, upperSashY, -0.01);
            group.add(upperSashGroup);
            createMuntinPattern(openingWidth, sashH, 0, upperSashY, -0.01);

            // Lower sash (always operable)
            const lowerSashGroup = new THREE.Group();

            const lowerTop = new THREE.Mesh(new THREE.BoxGeometry(openingWidth, sashWidth, frameThickness * 0.6), sashMat);
            lowerTop.position.set(0, sashH/2 - sashWidth/2, 0);
            lowerSashGroup.add(lowerTop);

            const lowerBot = new THREE.Mesh(new THREE.BoxGeometry(openingWidth, sashWidth, frameThickness * 0.6), sashMat);
            lowerBot.position.set(0, -sashH/2 + sashWidth/2, 0);
            lowerSashGroup.add(lowerBot);

            [-1, 1].forEach(side => {
              const lowerSide = new THREE.Mesh(new THREE.BoxGeometry(sashWidth, sashH, frameThickness * 0.6), sashMat);
              lowerSide.position.set(side * (openingWidth/2 - sashWidth/2), 0, 0);
              lowerSashGroup.add(lowerSide);
            });

            // Lower glass
            const lowerGlass = new THREE.Mesh(
              new THREE.PlaneGeometry(openingWidth - sashWidth * 2 - 0.02, sashH - sashWidth * 2 - 0.02),
              glassMat
            );
            lowerGlass.position.z = 0.02;
            lowerSashGroup.add(lowerGlass);

            lowerSashGroup.position.set(0, lowerSashY, 0.02);
            group.add(lowerSashGroup);
            createMuntinPattern(openingWidth, sashH, 0, lowerSashY, 0.02);

            // Meeting rail (where sashes overlap)
            const meetingRail = new THREE.Mesh(
              new THREE.BoxGeometry(openingWidth, sashWidth * 0.6, frameThickness * 0.3),
              sashMat
            );
            meetingRail.position.set(0, (upperSashY + lowerSashY) / 2, 0.02);
            group.add(meetingRail);

            // Window lock (at meeting rail)
            const lockBase = new THREE.Mesh(
              new THREE.BoxGeometry(0.04, 0.025, 0.015),
              hardwareMat
            );
            lockBase.position.set(0, (upperSashY + lowerSashY) / 2 + 0.03, frameThickness/2 + 0.02);
            group.add(lockBase);

            const lockLever = new THREE.Mesh(
              new THREE.BoxGeometry(0.05, 0.015, 0.01),
              hardwareMat
            );
            lockLever.position.set(0.02, (upperSashY + lowerSashY) / 2 + 0.035, frameThickness/2 + 0.03);
            group.add(lockLever);

          } else if (windowStyle === 'casement') {
            // Side-hinged window with crank operator
            const sashGroup = new THREE.Group();

            // Sash frame (all 4 sides)
            const sashInnerW = openingWidth - 0.02;
            const sashInnerH = openingHeight - 0.02;

            const sTop = new THREE.Mesh(new THREE.BoxGeometry(sashInnerW, sashWidth, frameThickness * 0.5), sashMat);
            sTop.position.set(0, sashInnerH/2 - sashWidth/2, 0);
            sashGroup.add(sTop);

            const sBot = new THREE.Mesh(new THREE.BoxGeometry(sashInnerW, sashWidth, frameThickness * 0.5), sashMat);
            sBot.position.set(0, -sashInnerH/2 + sashWidth/2, 0);
            sashGroup.add(sBot);

            [-1, 1].forEach(side => {
              const sSide = new THREE.Mesh(new THREE.BoxGeometry(sashWidth, sashInnerH, frameThickness * 0.5), sashMat);
              sSide.position.set(side * (sashInnerW/2 - sashWidth/2), 0, 0);
              sashGroup.add(sSide);
            });

            // Glass
            const casementGlass = new THREE.Mesh(
              new THREE.PlaneGeometry(sashInnerW - sashWidth * 2 - 0.02, sashInnerH - sashWidth * 2 - 0.02),
              glassMat
            );
            casementGlass.position.z = 0.01;
            sashGroup.add(casementGlass);

            sashGroup.position.set(0, (openingHeight - h)/2 + sillHeight/2, 0.01);
            group.add(sashGroup);

            createMuntinPattern(sashInnerW, sashInnerH, 0, (openingHeight - h)/2 + sillHeight/2, 0.01);

            // Hinges (on one side)
            [0.25, 0.75].forEach(hPos => {
              const hinge = new THREE.Mesh(
                new THREE.BoxGeometry(0.02, 0.08, 0.025),
                hardwareMat
              );
              hinge.position.set(-openingWidth/2 + 0.02, -h/2 + sillHeight + openingHeight * hPos, frameThickness/2);
              group.add(hinge);
            });

            // Crank operator (at bottom)
            const crankBase = new THREE.Mesh(
              new THREE.BoxGeometry(0.06, 0.03, 0.02),
              hardwareMat
            );
            crankBase.position.set(openingWidth/4, -h/2 + sillHeight + 0.15, frameThickness/2 + 0.02);
            group.add(crankBase);

            const crankHandle = new THREE.Mesh(
              new THREE.CylinderGeometry(0.008, 0.008, 0.08, 8),
              hardwareMat
            );
            crankHandle.rotation.z = Math.PI / 2;
            crankHandle.position.set(openingWidth/4 + 0.04, -h/2 + sillHeight + 0.15, frameThickness/2 + 0.03);
            group.add(crankHandle);

          } else if (windowStyle === 'sliding') {
            // Two panels, one slides horizontally
            const panelW = (openingWidth + 0.02) / 2;

            // Fixed panel (left)
            const fixedPanel = new THREE.Group();

            const fTop = new THREE.Mesh(new THREE.BoxGeometry(panelW, sashWidth, frameThickness * 0.5), sashMat);
            fTop.position.set(0, openingHeight/2 - sashWidth/2, 0);
            fixedPanel.add(fTop);

            const fBot = new THREE.Mesh(new THREE.BoxGeometry(panelW, sashWidth, frameThickness * 0.5), sashMat);
            fBot.position.set(0, -openingHeight/2 + sashWidth/2, 0);
            fixedPanel.add(fBot);

            [-1, 1].forEach(side => {
              const fSide = new THREE.Mesh(new THREE.BoxGeometry(sashWidth, openingHeight, frameThickness * 0.5), sashMat);
              fSide.position.set(side * (panelW/2 - sashWidth/2), 0, 0);
              fixedPanel.add(fSide);
            });

            const fGlass = new THREE.Mesh(
              new THREE.PlaneGeometry(panelW - sashWidth * 2 - 0.02, openingHeight - sashWidth * 2 - 0.02),
              glassMat
            );
            fGlass.position.z = 0.01;
            fixedPanel.add(fGlass);

            fixedPanel.position.set(-panelW/2 + 0.01, (openingHeight - h)/2 + sillHeight/2, -0.01);
            group.add(fixedPanel);

            // Sliding panel (right, in front)
            const slidePanel = new THREE.Group();

            const sTop = new THREE.Mesh(new THREE.BoxGeometry(panelW, sashWidth, frameThickness * 0.5), sashMat);
            sTop.position.set(0, openingHeight/2 - sashWidth/2, 0);
            slidePanel.add(sTop);

            const sBot = new THREE.Mesh(new THREE.BoxGeometry(panelW, sashWidth, frameThickness * 0.5), sashMat);
            sBot.position.set(0, -openingHeight/2 + sashWidth/2, 0);
            slidePanel.add(sBot);

            [-1, 1].forEach(side => {
              const sSide = new THREE.Mesh(new THREE.BoxGeometry(sashWidth, openingHeight, frameThickness * 0.5), sashMat);
              sSide.position.set(side * (panelW/2 - sashWidth/2), 0, 0);
              slidePanel.add(sSide);
            });

            const sGlass = new THREE.Mesh(
              new THREE.PlaneGeometry(panelW - sashWidth * 2 - 0.02, openingHeight - sashWidth * 2 - 0.02),
              glassMat
            );
            sGlass.position.z = 0.01;
            slidePanel.add(sGlass);

            slidePanel.position.set(panelW/2 - 0.01, (openingHeight - h)/2 + sillHeight/2, 0.02);
            group.add(slidePanel);

            // Track (top and bottom)
            const trackMat = new THREE.MeshStandardMaterial({ color: 0x666666, roughness: 0.4, metalness: 0.5 });

            const topTrack = new THREE.Mesh(
              new THREE.BoxGeometry(openingWidth, 0.02, frameThickness * 0.4),
              trackMat
            );
            topTrack.position.set(0, h/2 - frameWidth - 0.01, 0);
            group.add(topTrack);

            const botTrack = new THREE.Mesh(
              new THREE.BoxGeometry(openingWidth, 0.02, frameThickness * 0.4),
              trackMat
            );
            botTrack.position.set(0, -h/2 + sillHeight + 0.01, 0);
            group.add(botTrack);

            // Sliding latch
            const latch = new THREE.Mesh(
              new THREE.BoxGeometry(0.04, 0.06, 0.015),
              hardwareMat
            );
            latch.position.set(panelW - sashWidth, (openingHeight - h)/2 + sillHeight/2, frameThickness/2 + 0.02);
            group.add(latch);

          } else {
            // Fixed/picture window - single pane, no operable hardware
            const fixedGlass = new THREE.Mesh(
              new THREE.PlaneGeometry(openingWidth - 0.05, openingHeight - 0.05),
              glassMat
            );
            fixedGlass.position.set(0, (openingHeight - h)/2 + sillHeight/2, 0.01);
            group.add(fixedGlass);

            // Simple glazing bead around glass
            const beadMat = new THREE.MeshStandardMaterial({ color: frameColor, roughness: 0.5 });
            const beadW = 0.025;

            const topBead = new THREE.Mesh(new THREE.BoxGeometry(openingWidth, beadW, beadW), beadMat);
            topBead.position.set(0, h/2 - frameWidth - beadW/2, 0.02);
            group.add(topBead);

            const botBead = new THREE.Mesh(new THREE.BoxGeometry(openingWidth, beadW, beadW), beadMat);
            botBead.position.set(0, -h/2 + sillHeight + beadW/2, 0.02);
            group.add(botBead);

            [-1, 1].forEach(side => {
              const sideBead = new THREE.Mesh(new THREE.BoxGeometry(beadW, openingHeight, beadW), beadMat);
              sideBead.position.set(side * (openingWidth/2 - beadW/2), (openingHeight - h)/2 + sillHeight/2, 0.02);
              group.add(sideBead);
            });
          }

          // === INTERIOR TRIM (Casing) ===
          const trimMat = new THREE.MeshStandardMaterial({ color: 0xF0EDE8, roughness: 0.55 });
          const casingWidth = 0.09; // 2.25" trim
          const casingThick = 0.02; // 1/2" proud of wall

          // Head casing (with decorative profile)
          const headCasing = new THREE.Mesh(
            new THREE.BoxGeometry(w + casingWidth * 2, casingWidth, casingThick),
            trimMat
          );
          headCasing.position.set(0, h/2 + casingWidth/2, frameThickness/2 + casingThick/2);
          group.add(headCasing);

          // Head casing cap (crown detail)
          const headCap = new THREE.Mesh(
            new THREE.BoxGeometry(w + casingWidth * 2 + 0.02, 0.015, casingThick + 0.01),
            trimMat
          );
          headCap.position.set(0, h/2 + casingWidth, frameThickness/2 + casingThick/2);
          group.add(headCap);

          // Side casings
          [-1, 1].forEach(side => {
            const sideCasing = new THREE.Mesh(
              new THREE.BoxGeometry(casingWidth, h + casingWidth, casingThick),
              trimMat
            );
            sideCasing.position.set(side * (w/2 + casingWidth/2), -casingWidth/2, frameThickness/2 + casingThick/2);
            group.add(sideCasing);
          });

          // Stool (interior sill extension)
          const stoolMat = new THREE.MeshStandardMaterial({ color: 0xFAF8F5, roughness: 0.4 });
          const stool = new THREE.Mesh(
            new THREE.BoxGeometry(w + casingWidth * 2 + 0.05, 0.025, 0.12),
            stoolMat
          );
          stool.position.set(0, -h/2 + sillHeight * 0.5, frameThickness/2 + 0.05);
          group.add(stool);

          // Apron (trim below stool)
          const apron = new THREE.Mesh(
            new THREE.BoxGeometry(w + casingWidth * 2, casingWidth * 0.6, casingThick),
            trimMat
          );
          apron.position.set(0, -h/2 + sillHeight * 0.5 - casingWidth * 0.35, frameThickness/2 + casingThick/2);
          group.add(apron);

          break;
        }

        case 'wall': {
          // Wall segment (drywall)
          // In 2D: width is the thin dimension (thickness), height is the long dimension (length)
          // Need to handle both horizontal and vertical walls
          const rotation = el.rotation || 0;
          const isVertical = rotation === 90 || rotation === 270 || rotation === -90;

          // Determine wall dimensions based on orientation
          let wallLength, wallThickness;
          if (isVertical) {
            // Wall runs along Z axis (top-to-bottom in 2D = into room in 3D)
            wallLength = d;  // The 2D height = wall length
            wallThickness = Math.max(w, 0.35);
          } else {
            // Wall runs along X axis (left-to-right in 2D)
            wallLength = w > d ? w : d;  // Use larger dimension as length
            wallThickness = Math.max(w < d ? w : d, 0.35);
          }

          const wallMat = new THREE.MeshStandardMaterial({
            color: el.color ? parseInt(el.color.replace('#', '0x')) : 0xF5F5DC,
            roughness: 0.8,
            side: THREE.DoubleSide
          });

          // Create wall mesh - length along X, height along Y, thickness along Z
          const wallMesh = new THREE.Mesh(
            new THREE.BoxGeometry(wallLength, h, wallThickness),
            wallMat
          );
          wallMesh.castShadow = true;
          wallMesh.receiveShadow = true;

          // Rotate for vertical walls
          if (isVertical) {
            wallMesh.rotation.y = Math.PI / 2;
          }

          group.add(wallMesh);
          break;
        }

        case 'wall-wood-2x4':
        case 'wall-wood-2x6': {
          // Wood framed wall
          const woodColor = el.type.includes('2x4') ? 0xDEB887 : 0xCD853F;
          const studWidth = el.type.includes('2x4') ? 0.1 : 0.15;
          const woodMat = new THREE.MeshStandardMaterial({ color: woodColor, roughness: 0.7 });

          // Studs (vertical)
          const studSpacing = 1.33; // 16" on center
          for (let sx = -w/2 + studSpacing/2; sx <= w/2; sx += studSpacing) {
            const stud = new THREE.Mesh(
              new THREE.BoxGeometry(studWidth, h - 0.2, d * 0.8),
              woodMat
            );
            stud.position.set(sx, 0, 0);
            group.add(stud);
          }

          // Top and bottom plates
          const plateMat = new THREE.MeshStandardMaterial({ color: woodColor, roughness: 0.6 });
          const topPlate = new THREE.Mesh(new THREE.BoxGeometry(w, 0.1, d * 0.8), plateMat);
          topPlate.position.y = h/2 - 0.05;
          group.add(topPlate);

          const botPlate = new THREE.Mesh(new THREE.BoxGeometry(w, 0.1, d * 0.8), plateMat);
          botPlate.position.y = -h/2 + 0.05;
          group.add(botPlate);
          break;
        }

        case 'wall-steel':
        case 'wall-aluminum': {
          // Metal stud wall
          const metalColor = el.type.includes('steel') ? 0x708090 : 0xC0C0C0;
          const metalMat = new THREE.MeshStandardMaterial({
            color: metalColor,
            roughness: 0.3,
            metalness: 0.7
          });

          // C-channel studs
          const studSpacing = 1.33;
          for (let sx = -w/2 + studSpacing/2; sx <= w/2; sx += studSpacing) {
            const stud = new THREE.Mesh(
              new THREE.BoxGeometry(0.05, h - 0.15, d * 0.7),
              metalMat
            );
            stud.position.set(sx, 0, 0);
            group.add(stud);
          }

          // Track (top and bottom)
          const trackMat = new THREE.MeshStandardMaterial({
            color: metalColor,
            roughness: 0.25,
            metalness: 0.8
          });
          const topTrack = new THREE.Mesh(new THREE.BoxGeometry(w, 0.08, d * 0.8), trackMat);
          topTrack.position.y = h/2 - 0.04;
          group.add(topTrack);

          const botTrack = new THREE.Mesh(new THREE.BoxGeometry(w, 0.08, d * 0.8), trackMat);
          botTrack.position.y = -h/2 + 0.04;
          group.add(botTrack);
          break;
        }

        case 'wall-concrete': {
          // Poured Concrete Wall with realistic form details
          // Features: form tie holes, construction joints, panel lines

          const concreteColor = el.color ? parseInt(el.color.replace('#', ''), 16) : 0x8C8C8C;

          // Main concrete material with slight roughness variation
          const concreteMat = new THREE.MeshStandardMaterial({
            color: concreteColor,
            roughness: 0.92,
            metalness: 0.02
          });

          // Darker concrete for recesses
          const concreteRecessMat = new THREE.MeshStandardMaterial({
            color: adjustColorBrightness(concreteColor, -20),
            roughness: 0.95,
            metalness: 0
          });

          // Form tie hole material (rust-stained)
          const tieHoleMat = new THREE.MeshStandardMaterial({
            color: 0x5C4033,
            roughness: 0.85,
            metalness: 0.1
          });

          // Base concrete wall
          const concreteWall = new THREE.Mesh(
            new THREE.BoxGeometry(w, h, d),
            concreteMat
          );
          concreteWall.castShadow = true;
          concreteWall.receiveShadow = true;
          group.add(concreteWall);

          // Form panel lines (typical 4' x 8' panels)
          const panelWidth = 4;  // 4 feet wide panels
          const panelHeight = 8; // 8 feet tall panels

          // Vertical panel joints
          const jointMat = new THREE.MeshStandardMaterial({
            color: adjustColorBrightness(concreteColor, -15),
            roughness: 0.9
          });

          for (let px = -w/2 + panelWidth; px < w/2; px += panelWidth) {
            const vJoint = new THREE.Mesh(
              new THREE.BoxGeometry(0.015, h, 0.02),
              jointMat
            );
            vJoint.position.set(px, 0, d/2 + 0.008);
            group.add(vJoint);
          }

          // Horizontal pour joints (every 8-10 feet typically)
          for (let py = -h/2 + panelHeight; py < h/2; py += panelHeight) {
            const hJoint = new THREE.Mesh(
              new THREE.BoxGeometry(w + 0.01, 0.02, 0.015),
              jointMat
            );
            hJoint.position.set(0, py, d/2 + 0.008);
            group.add(hJoint);
          }

          // Form tie holes - grid pattern (typically 2' horizontal x 2' vertical spacing)
          const tieSpacingH = 2;  // 2 feet horizontal
          const tieSpacingV = 2;  // 2 feet vertical
          const tieHoleRadius = 0.02; // ~1/2" diameter

          for (let ty = -h/2 + 1; ty < h/2 - 0.5; ty += tieSpacingV) {
            for (let tx = -w/2 + 1; tx < w/2 - 0.5; tx += tieSpacingH) {
              // Circular tie hole depression
              const tieHole = new THREE.Mesh(
                new THREE.CylinderGeometry(tieHoleRadius, tieHoleRadius, 0.03, 8),
                tieHoleMat
              );
              tieHole.rotation.x = Math.PI / 2;
              tieHole.position.set(tx, ty, d/2 + 0.01);
              group.add(tieHole);

              // Rust stain below tie hole
              const rustStain = new THREE.Mesh(
                new THREE.BoxGeometry(0.015, 0.08, 0.005),
                new THREE.MeshStandardMaterial({
                  color: 0x6B4423,
                  transparent: true,
                  opacity: 0.4,
                  roughness: 1
                })
              );
              rustStain.position.set(tx, ty - 0.06, d/2 + 0.005);
              group.add(rustStain);
            }
          }

          // Subtle surface texture variation (aggregate shadow)
          const textureMat = new THREE.MeshStandardMaterial({
            color: adjustColorBrightness(concreteColor, -8),
            transparent: true,
            opacity: 0.3,
            roughness: 1
          });

          // Random aggregate spots
          for (let i = 0; i < Math.min(w * h * 2, 50); i++) {
            const spotX = (Math.random() - 0.5) * w * 0.9;
            const spotY = (Math.random() - 0.5) * h * 0.9;
            const spotSize = 0.02 + Math.random() * 0.03;

            const spot = new THREE.Mesh(
              new THREE.CircleGeometry(spotSize, 6),
              textureMat
            );
            spot.position.set(spotX, spotY, d/2 + 0.003);
            group.add(spot);
          }

          break;
        }

        case 'wall-brick': {
          // Brick Wall with realistic running bond pattern
          // Standard brick: 2.25" x 3.625" x 8" (0.1875' x 0.3' x 0.67')
          // With 3/8" mortar joints

          const brickHeight = 0.1875 + 0.03;  // 2.25" + mortar = ~3" courses
          const brickWidth = 0.67;             // 8" brick length
          const mortarJoint = 0.03;            // 3/8" mortar

          // Brick colors with variation for realism
          const brickBaseColor = el.color ? parseInt(el.color.replace('#', ''), 16) : 0xB22222;
          const brickColors = [
            brickBaseColor,
            adjustColorBrightness(brickBaseColor, 10),
            adjustColorBrightness(brickBaseColor, -10),
            adjustColorBrightness(brickBaseColor, 5),
            adjustColorBrightness(brickBaseColor, -15)
          ];

          // Create materials for each color variation
          const brickMats = brickColors.map(c => new THREE.MeshStandardMaterial({
            color: c,
            roughness: 0.88,
            metalness: 0.02
          }));

          // Mortar material
          const mortarMat = new THREE.MeshStandardMaterial({
            color: 0xC8C8C8,
            roughness: 0.85,
            metalness: 0
          });

          // Base wall (mortar color background)
          const baseWall = new THREE.Mesh(
            new THREE.BoxGeometry(w, h, d),
            mortarMat
          );
          group.add(baseWall);

          // Calculate courses and bricks
          const numCourses = Math.ceil(h / brickHeight);
          const bricksPerRow = Math.ceil(w / brickWidth);

          // Individual brick dimensions
          const singleBrickW = brickWidth - mortarJoint;
          const singleBrickH = brickHeight - mortarJoint;
          const singleBrickD = d - mortarJoint * 2;

          // Create individual bricks with running bond
          for (let row = 0; row < numCourses; row++) {
            // Running bond offset
            const rowOffset = (row % 2) * (brickWidth / 2);
            const brickY = -h/2 + brickHeight/2 + row * brickHeight;

            if (brickY - singleBrickH/2 > h/2) continue;

            for (let col = -1; col <= bricksPerRow; col++) {
              const brickX = -w/2 + brickWidth/2 + col * brickWidth - rowOffset;

              // Skip bricks outside bounds
              if (brickX + singleBrickW/2 < -w/2 || brickX - singleBrickW/2 > w/2) continue;

              // Calculate clipped dimensions
              let actualW = singleBrickW;
              let actualX = brickX;
              let actualH = singleBrickH;
              let actualY = brickY;

              // Clip edges
              if (brickX - singleBrickW/2 < -w/2) {
                const clip = (-w/2) - (brickX - singleBrickW/2);
                actualW -= clip;
                actualX += clip / 2;
              }
              if (brickX + singleBrickW/2 > w/2) {
                const clip = (brickX + singleBrickW/2) - (w/2);
                actualW -= clip;
                actualX -= clip / 2;
              }
              if (brickY + singleBrickH/2 > h/2) {
                const clip = (brickY + singleBrickH/2) - (h/2);
                actualH -= clip;
                actualY -= clip / 2;
              }

              if (actualW < 0.05 || actualH < 0.03) continue;

              // Random color variation for natural look
              const colorIdx = (row * 7 + col * 3) % brickMats.length;
              const brick = new THREE.Mesh(
                new THREE.BoxGeometry(actualW, actualH, singleBrickD),
                brickMats[colorIdx]
              );
              brick.position.set(actualX, actualY, 0);
              brick.castShadow = true;
              brick.receiveShadow = true;
              group.add(brick);
            }
          }

          // Visible mortar lines on front face
          // Horizontal bed joints
          for (let row = 1; row < numCourses; row++) {
            const jointY = -h/2 + row * brickHeight;
            if (jointY > h/2) continue;

            const hJoint = new THREE.Mesh(
              new THREE.BoxGeometry(w + 0.01, mortarJoint * 1.5, 0.01),
              mortarMat
            );
            hJoint.position.set(0, jointY, d/2 + 0.002);
            group.add(hJoint);
          }

          // Vertical head joints
          for (let row = 0; row < numCourses; row++) {
            const rowOffset = (row % 2) * (brickWidth / 2);
            const jointY = -h/2 + brickHeight/2 + row * brickHeight;

            for (let col = 0; col <= bricksPerRow; col++) {
              const jointX = -w/2 + col * brickWidth - rowOffset;
              if (jointX < -w/2 || jointX > w/2) continue;

              const vJoint = new THREE.Mesh(
                new THREE.BoxGeometry(mortarJoint * 1.5, singleBrickH + 0.01, 0.01),
                mortarMat
              );
              vJoint.position.set(jointX, jointY, d/2 + 0.002);
              group.add(vJoint);
            }
          }

          break;
        }

        case 'wall-block': {
          // CMU (Concrete Masonry Unit) Block Wall
          // Standard CMU: 8" x 8" x 16" nominal (0.67' x 0.67' x 1.33')
          // Actual: 7.625" x 7.625" x 15.625" with 3/8" mortar joints

          const cmuHeight = 0.67;  // 8" in feet
          const cmuWidth = 1.33;   // 16" in feet
          const mortarJoint = 0.03; // 3/8" mortar joint

          // CMU concrete colors with slight variation for realism
          const cmuBaseColor = el.color ? parseInt(el.color.replace('#', ''), 16) : 0x808080;
          const cmuMat = new THREE.MeshStandardMaterial({
            color: cmuBaseColor,
            roughness: 0.92,
            metalness: 0.02
          });

          // Slightly darker color for depth/shadow blocks
          const cmuDarkMat = new THREE.MeshStandardMaterial({
            color: adjustColorBrightness(cmuBaseColor, -15),
            roughness: 0.95,
            metalness: 0.02
          });

          // Mortar material (light gray cement)
          const mortarMat = new THREE.MeshStandardMaterial({
            color: 0xB8B8B8,
            roughness: 0.85,
            metalness: 0
          });

          // Calculate number of courses (rows) and blocks per row
          const numCourses = Math.ceil(h / cmuHeight);
          const blocksPerRow = Math.ceil(w / cmuWidth);

          // Create the base wall with mortar color (visible in joints)
          const baseWall = new THREE.Mesh(
            new THREE.BoxGeometry(w, h, d),
            mortarMat
          );
          group.add(baseWall);

          // Individual block dimensions (slightly smaller than nominal for mortar gaps)
          const blockW = cmuWidth - mortarJoint;
          const blockH = cmuHeight - mortarJoint;
          const blockD = d - mortarJoint * 2;

          // Create individual CMU blocks with running bond pattern
          for (let row = 0; row < numCourses; row++) {
            // Running bond: offset every other row by half block
            const rowOffset = (row % 2) * (cmuWidth / 2);
            const blockY = -h/2 + cmuHeight/2 + row * cmuHeight;

            // Skip if block would be above wall height
            if (blockY - blockH/2 > h/2) continue;

            for (let col = -1; col <= blocksPerRow; col++) {
              const blockX = -w/2 + cmuWidth/2 + col * cmuWidth - rowOffset;

              // Skip blocks that are completely outside the wall width
              if (blockX + blockW/2 < -w/2 || blockX - blockW/2 > w/2) continue;

              // Calculate clipped block dimensions for edge blocks
              let actualBlockW = blockW;
              let actualBlockX = blockX;

              // Clip left edge
              if (blockX - blockW/2 < -w/2) {
                const clipAmount = (-w/2) - (blockX - blockW/2);
                actualBlockW -= clipAmount;
                actualBlockX += clipAmount / 2;
              }

              // Clip right edge
              if (blockX + blockW/2 > w/2) {
                const clipAmount = (blockX + blockW/2) - (w/2);
                actualBlockW -= clipAmount;
                actualBlockX -= clipAmount / 2;
              }

              // Clip top edge
              let actualBlockH = blockH;
              let actualBlockY = blockY;
              if (blockY + blockH/2 > h/2) {
                const clipAmount = (blockY + blockH/2) - (h/2);
                actualBlockH -= clipAmount;
                actualBlockY -= clipAmount / 2;
              }

              // Skip very small fragments
              if (actualBlockW < 0.1 || actualBlockH < 0.1) continue;

              // Alternate between normal and slightly darker blocks for texture
              const useDark = (row + col) % 7 === 0 || (row + col) % 11 === 0;
              const blockMaterial = useDark ? cmuDarkMat : cmuMat;

              // Main block face (front)
              const block = new THREE.Mesh(
                new THREE.BoxGeometry(actualBlockW, actualBlockH, blockD),
                blockMaterial
              );
              block.position.set(actualBlockX, actualBlockY, 0);
              block.castShadow = true;
              block.receiveShadow = true;
              group.add(block);

              // Add subtle face texture - horizontal score line typical in CMU
              if (actualBlockW > 0.5) {
                const scoreMat = new THREE.MeshStandardMaterial({
                  color: adjustColorBrightness(cmuBaseColor, -25),
                  roughness: 1
                });
                const scoreLine = new THREE.Mesh(
                  new THREE.BoxGeometry(actualBlockW - 0.08, 0.01, 0.005),
                  scoreMat
                );
                scoreLine.position.set(actualBlockX, actualBlockY, blockD/2 + 0.003);
                group.add(scoreLine);
              }
            }
          }

          // Add exposed mortar joint lines on front face for better visibility
          // Horizontal joints
          for (let row = 1; row < numCourses; row++) {
            const jointY = -h/2 + row * cmuHeight;
            if (jointY > h/2) continue;

            const hJoint = new THREE.Mesh(
              new THREE.BoxGeometry(w + 0.01, mortarJoint * 1.2, 0.01),
              mortarMat
            );
            hJoint.position.set(0, jointY, d/2 + 0.002);
            group.add(hJoint);
          }

          // Vertical joints (staggered for running bond)
          for (let row = 0; row < numCourses; row++) {
            const rowOffset = (row % 2) * (cmuWidth / 2);
            const jointY = -h/2 + cmuHeight/2 + row * cmuHeight;

            for (let col = 0; col <= blocksPerRow; col++) {
              const jointX = -w/2 + col * cmuWidth - rowOffset;

              // Skip joints outside wall bounds
              if (jointX < -w/2 || jointX > w/2) continue;

              const jointH = Math.min(cmuHeight - mortarJoint, (h/2 - (jointY - cmuHeight/2)) + cmuHeight);
              if (jointH < 0.1) continue;

              const vJoint = new THREE.Mesh(
                new THREE.BoxGeometry(mortarJoint * 1.2, jointH, 0.01),
                mortarMat
              );
              vJoint.position.set(jointX, jointY, d/2 + 0.002);
              group.add(vJoint);
            }
          }

          // Add end cap detail showing hollow cores (if wall depth allows)
          if (d >= 0.5) {
            const endCapMat = new THREE.MeshStandardMaterial({
              color: adjustColorBrightness(cmuBaseColor, -10),
              roughness: 0.9
            });

            // Left end cap with core holes
            const leftEndCap = new THREE.Mesh(
              new THREE.BoxGeometry(0.02, h, d - mortarJoint * 2),
              endCapMat
            );
            leftEndCap.position.set(-w/2 - 0.01, 0, 0);
            group.add(leftEndCap);

            // Right end cap
            const rightEndCap = new THREE.Mesh(
              new THREE.BoxGeometry(0.02, h, d - mortarJoint * 2),
              endCapMat
            );
            rightEndCap.position.set(w/2 + 0.01, 0, 0);
            group.add(rightEndCap);

            // Add hollow core indicators on ends (visible from side)
            const coreMat = new THREE.MeshStandardMaterial({
              color: 0x4a4a4a,
              roughness: 1
            });

            for (let row = 0; row < numCourses; row++) {
              const coreY = -h/2 + cmuHeight/2 + row * cmuHeight;
              if (coreY + cmuHeight/2 > h/2) continue;

              // Two cores per block (typical 2-core CMU)
              for (let coreOffset of [-0.18, 0.18]) {
                // Left side cores
                const leftCore = new THREE.Mesh(
                  new THREE.BoxGeometry(0.015, cmuHeight - 0.15, 0.25),
                  coreMat
                );
                leftCore.position.set(-w/2 - 0.005, coreY, coreOffset);
                group.add(leftCore);

                // Right side cores
                const rightCore = new THREE.Mesh(
                  new THREE.BoxGeometry(0.015, cmuHeight - 0.15, 0.25),
                  coreMat
                );
                rightCore.position.set(w/2 + 0.005, coreY, coreOffset);
                group.add(rightCore);
              }
            }
          }

          break;
        }

        // ===== STRUCTURAL ELEMENTS - BEAMS & COLUMNS =====
        case 'steel-beam': {
          // Steel I-Beam (Wide Flange)
          // Standard beam oriented horizontally, spanning across room
          const beamColor = el.color ? parseInt(el.color.replace('#', ''), 16) : 0x4A4A4A;
          const steelMat = new THREE.MeshStandardMaterial({
            color: beamColor,
            roughness: 0.4,
            metalness: 0.85
          });

          // I-beam dimensions (W8x31 typical)
          const flangeWidth = d;              // Flange width (depth in 2D)
          const webHeight = h * 0.7;          // Web height
          const flangeThickness = h * 0.15;   // Flange thickness
          const webThickness = 0.03;          // Web thickness (~3/8")

          // Top flange
          const topFlange = new THREE.Mesh(
            new THREE.BoxGeometry(w, flangeThickness, flangeWidth),
            steelMat
          );
          topFlange.position.y = h/2 - flangeThickness/2;
          topFlange.castShadow = true;
          group.add(topFlange);

          // Bottom flange
          const botFlange = new THREE.Mesh(
            new THREE.BoxGeometry(w, flangeThickness, flangeWidth),
            steelMat
          );
          botFlange.position.y = -h/2 + flangeThickness/2;
          botFlange.castShadow = true;
          group.add(botFlange);

          // Web (vertical center piece)
          const web = new THREE.Mesh(
            new THREE.BoxGeometry(w, webHeight, webThickness),
            steelMat
          );
          web.castShadow = true;
          group.add(web);

          // Edge highlights (subtle rust/weathering)
          const rustMat = new THREE.MeshStandardMaterial({
            color: 0x5C4033,
            roughness: 0.9,
            transparent: true,
            opacity: 0.2
          });
          const rustEdge = new THREE.Mesh(
            new THREE.BoxGeometry(w, 0.01, flangeWidth),
            rustMat
          );
          rustEdge.position.y = h/2 + 0.005;
          group.add(rustEdge);

          break;
        }

        case 'steel-column': {
          // Steel Box Column (HSS - Hollow Structural Section)
          const columnColor = el.color ? parseInt(el.color.replace('#', ''), 16) : 0x4A4A4A;
          const steelMat = new THREE.MeshStandardMaterial({
            color: columnColor,
            roughness: 0.4,
            metalness: 0.85
          });

          // Square HSS column
          const wallThickness = 0.02; // ~1/4" wall

          // Outer shell
          const outer = new THREE.Mesh(
            new THREE.BoxGeometry(w, h, d),
            steelMat
          );
          outer.castShadow = true;
          outer.receiveShadow = true;
          group.add(outer);

          // Hollow interior (dark)
          const innerMat = new THREE.MeshStandardMaterial({
            color: 0x1a1a1a,
            roughness: 0.9
          });

          // Top opening showing hollow
          const topHole = new THREE.Mesh(
            new THREE.BoxGeometry(w - wallThickness*4, 0.01, d - wallThickness*4),
            innerMat
          );
          topHole.position.y = h/2;
          group.add(topHole);

          // Base plate
          const basePlate = new THREE.Mesh(
            new THREE.BoxGeometry(w * 1.3, 0.04, d * 1.3),
            steelMat
          );
          basePlate.position.y = -h/2 - 0.02;
          basePlate.castShadow = true;
          group.add(basePlate);

          break;
        }

        case 'wood-beam': {
          // Solid Wood Beam (Glulam or Solid Timber)
          const woodColor = el.color ? parseInt(el.color.replace('#', ''), 16) : 0x8B6914;
          const woodMat = createTexturedMaterial(woodColor, textureUrl, {
            roughness: 0.7,
            metalness: 0
          });

          // Main beam body
          const beam = new THREE.Mesh(
            new THREE.BoxGeometry(w, h, d),
            woodMat
          );
          beam.castShadow = true;
          beam.receiveShadow = true;
          group.add(beam);

          // Wood grain lines (darker grooves)
          const grainMat = new THREE.MeshStandardMaterial({
            color: adjustColorBrightness(woodColor, -30),
            roughness: 0.9
          });

          // Horizontal grain lines on bottom face
          const grainSpacing = 0.15;
          for (let gz = -d/2 + grainSpacing; gz < d/2; gz += grainSpacing + Math.random() * 0.1) {
            const grain = new THREE.Mesh(
              new THREE.BoxGeometry(w - 0.05, 0.005, 0.008),
              grainMat
            );
            grain.position.set(0, -h/2 - 0.002, gz);
            group.add(grain);
          }

          // End grain (visible at beam ends)
          const endGrainMat = new THREE.MeshStandardMaterial({
            color: adjustColorBrightness(woodColor, 10),
            roughness: 0.6
          });

          // Left end
          const leftEnd = new THREE.Mesh(
            new THREE.BoxGeometry(0.01, h - 0.02, d - 0.02),
            endGrainMat
          );
          leftEnd.position.x = -w/2 - 0.005;
          group.add(leftEnd);

          // Right end
          const rightEnd = new THREE.Mesh(
            new THREE.BoxGeometry(0.01, h - 0.02, d - 0.02),
            endGrainMat
          );
          rightEnd.position.x = w/2 + 0.005;
          group.add(rightEnd);

          break;
        }

        case 'wood-post': {
          // Wood Post (4x4, 6x6)
          const woodColor = el.color ? parseInt(el.color.replace('#', ''), 16) : 0x8B6914;
          const woodMat = createTexturedMaterial(woodColor, textureUrl, {
            roughness: 0.7,
            metalness: 0
          });

          // Main post body
          const post = new THREE.Mesh(
            new THREE.BoxGeometry(w, h, d),
            woodMat
          );
          post.castShadow = true;
          post.receiveShadow = true;
          group.add(post);

          // Vertical grain lines
          const grainMat = new THREE.MeshStandardMaterial({
            color: adjustColorBrightness(woodColor, -25),
            roughness: 0.9
          });

          for (let side = 0; side < 4; side++) {
            const rotation = side * Math.PI / 2;
            const offsetX = side === 1 ? w/2 + 0.002 : (side === 3 ? -w/2 - 0.002 : 0);
            const offsetZ = side === 0 ? d/2 + 0.002 : (side === 2 ? -d/2 - 0.002 : 0);

            for (let i = 0; i < 3; i++) {
              const grain = new THREE.Mesh(
                new THREE.BoxGeometry(0.005, h - 0.1, 0.005),
                grainMat
              );
              const offset = (i - 1) * (side % 2 === 0 ? w : d) * 0.25;
              grain.position.set(
                offsetX + (side % 2 === 0 ? offset : 0),
                0,
                offsetZ + (side % 2 === 1 ? offset : 0)
              );
              group.add(grain);
            }
          }

          break;
        }

        case 'concrete-beam': {
          // Reinforced Concrete Beam
          const concreteColor = el.color ? parseInt(el.color.replace('#', ''), 16) : 0x707070;
          const concreteMat = new THREE.MeshStandardMaterial({
            color: concreteColor,
            roughness: 0.9,
            metalness: 0.02
          });

          // Main beam body
          const beam = new THREE.Mesh(
            new THREE.BoxGeometry(w, h, d),
            concreteMat
          );
          beam.castShadow = true;
          beam.receiveShadow = true;
          group.add(beam);

          // Form lines (horizontal pour joints)
          const formMat = new THREE.MeshStandardMaterial({
            color: adjustColorBrightness(concreteColor, -15),
            roughness: 0.95
          });

          const formLine = new THREE.Mesh(
            new THREE.BoxGeometry(w + 0.01, 0.01, d + 0.01),
            formMat
          );
          formLine.position.y = 0;
          group.add(formLine);

          // Aggregate texture spots
          const spotMat = new THREE.MeshStandardMaterial({
            color: adjustColorBrightness(concreteColor, -10),
            roughness: 1
          });

          for (let i = 0; i < Math.min(w * 8, 20); i++) {
            const spotX = (Math.random() - 0.5) * w * 0.9;
            const spotY = (Math.random() - 0.5) * h * 0.8;
            const spot = new THREE.Mesh(
              new THREE.SphereGeometry(0.015 + Math.random() * 0.01, 6, 6),
              spotMat
            );
            spot.position.set(spotX, spotY, d/2 + 0.005);
            group.add(spot);
          }

          break;
        }

        case 'concrete-column': {
          // Reinforced Concrete Column
          const concreteColor = el.color ? parseInt(el.color.replace('#', ''), 16) : 0x707070;
          const concreteMat = new THREE.MeshStandardMaterial({
            color: concreteColor,
            roughness: 0.9,
            metalness: 0.02
          });

          // Square or rectangular column
          const column = new THREE.Mesh(
            new THREE.BoxGeometry(w, h, d),
            concreteMat
          );
          column.castShadow = true;
          column.receiveShadow = true;
          group.add(column);

          // Chamfered edges (typical on concrete columns)
          const chamferMat = new THREE.MeshStandardMaterial({
            color: adjustColorBrightness(concreteColor, -10),
            roughness: 0.85
          });

          const chamferSize = 0.02;
          const edges = [
            { pos: [-w/2, 0, -d/2], rot: [0, Math.PI/4, 0] },
            { pos: [w/2, 0, -d/2], rot: [0, -Math.PI/4, 0] },
            { pos: [-w/2, 0, d/2], rot: [0, -Math.PI/4, 0] },
            { pos: [w/2, 0, d/2], rot: [0, Math.PI/4, 0] }
          ];

          edges.forEach(edge => {
            const chamfer = new THREE.Mesh(
              new THREE.BoxGeometry(chamferSize, h - 0.1, chamferSize),
              chamferMat
            );
            chamfer.position.set(...edge.pos);
            chamfer.rotation.set(...edge.rot);
            group.add(chamfer);
          });

          break;
        }

        case 'header':
        case 'lvl-beam': {
          // Header/Lintel or LVL (Laminated Veneer Lumber) Beam
          const isLVL = el.type === 'lvl-beam';
          const woodColor = el.color ? parseInt(el.color.replace('#', ''), 16) : (isLVL ? 0xDEB887 : 0xCD853F);
          const woodMat = createTexturedMaterial(woodColor, textureUrl, {
            roughness: 0.65,
            metalness: 0
          });

          // Main beam body
          const beam = new THREE.Mesh(
            new THREE.BoxGeometry(w, h, d),
            woodMat
          );
          beam.castShadow = true;
          beam.receiveShadow = true;
          group.add(beam);

          if (isLVL) {
            // LVL lamination lines (horizontal layers)
            const lamMat = new THREE.MeshStandardMaterial({
              color: adjustColorBrightness(woodColor, -20),
              roughness: 0.8
            });

            const layerHeight = 0.06; // ~3/4" layers
            for (let ly = -h/2 + layerHeight; ly < h/2; ly += layerHeight) {
              const lamLine = new THREE.Mesh(
                new THREE.BoxGeometry(w + 0.01, 0.005, d + 0.01),
                lamMat
              );
              lamLine.position.y = ly;
              group.add(lamLine);
            }
          } else {
            // Regular header - single piece with grain
            const grainMat = new THREE.MeshStandardMaterial({
              color: adjustColorBrightness(woodColor, -25),
              roughness: 0.9
            });

            // Horizontal grain line
            const grain = new THREE.Mesh(
              new THREE.BoxGeometry(w - 0.05, 0.01, 0.005),
              grainMat
            );
            grain.position.set(0, 0, d/2 + 0.002);
            group.add(grain);
          }

          // End grain
          const endMat = new THREE.MeshStandardMaterial({
            color: adjustColorBrightness(woodColor, 15),
            roughness: 0.55
          });

          const leftEnd = new THREE.Mesh(
            new THREE.BoxGeometry(0.01, h - 0.02, d - 0.02),
            endMat
          );
          leftEnd.position.x = -w/2 - 0.005;
          group.add(leftEnd);

          const rightEnd = new THREE.Mesh(
            new THREE.BoxGeometry(0.01, h - 0.02, d - 0.02),
            endMat
          );
          rightEnd.position.x = w/2 + 0.005;
          group.add(rightEnd);

          break;
        }

        // ===== PONY WALLS & HALF WALLS =====
        case 'pony-wall':
        case 'pony-wall-bar':
        case 'knee-wall': {
          // Half-height wall with proper framing construction
          // Shows: drywall both sides, visible studs at ends, top/bottom plates
          const ponyHeight = el.wallHeight || (el.type === 'knee-wall' ? 2.5 : 3.5);
          const ponyDepth = d || 0.5;
          const isBarHeight = el.type === 'pony-wall-bar';
          const baseY = -h / 2;

          // Construction dimensions (standard framing)
          const studWidth = 0.125; // 1.5" stud face
          const studDepth = ponyDepth - 0.08; // Stud depth (leave room for drywall both sides)
          const plateHeight = 0.125; // 1.5" plate thickness
          const drywallThickness = 0.04; // ~1/2" drywall

          // Materials
          const drywallMat = createTexturedMaterial(el.materialColor || 0xF5F5F0, textureUrl, {
            roughness: 0.85
          });
          const drywallTopMat = new THREE.MeshStandardMaterial({
            color: 0xE0E0E0,
            roughness: 0.9
          });
          const studMat = new THREE.MeshStandardMaterial({
            color: 0xD4B896, // Wood color
            roughness: 0.75
          });
          const cornerBeadMat = new THREE.MeshStandardMaterial({
            color: 0xDDDDDD,
            roughness: 0.6,
            metalness: 0.1
          });

          // === FRAMING (visible at ends) ===
          // Bottom plate (sole plate)
          const bottomPlate = new THREE.Mesh(
            new THREE.BoxGeometry(w, plateHeight, studDepth),
            studMat
          );
          bottomPlate.position.set(0, baseY + plateHeight/2, 0);
          group.add(bottomPlate);

          // Top plate (double top plate is standard)
          const topPlate1 = new THREE.Mesh(
            new THREE.BoxGeometry(w, plateHeight, studDepth),
            studMat
          );
          topPlate1.position.set(0, baseY + ponyHeight - plateHeight * 1.5, 0);
          group.add(topPlate1);

          const topPlate2 = new THREE.Mesh(
            new THREE.BoxGeometry(w, plateHeight, studDepth),
            studMat
          );
          topPlate2.position.set(0, baseY + ponyHeight - plateHeight * 0.5, 0);
          group.add(topPlate2);

          // End studs (king studs at each end - visible from the side)
          const studHeight = ponyHeight - plateHeight * 3;
          [-1, 1].forEach(side => {
            const endStud = new THREE.Mesh(
              new THREE.BoxGeometry(studWidth, studHeight, studDepth),
              studMat
            );
            endStud.position.set(
              side * (w/2 - studWidth/2),
              baseY + plateHeight + studHeight/2,
              0
            );
            group.add(endStud);
          });

          // Interior studs (at 16" on center, partially visible through drywall texture)
          const studSpacing = 1.33; // 16" OC
          const numStuds = Math.floor((w - studWidth * 2) / studSpacing);
          for (let s = 1; s <= numStuds; s++) {
            const studX = -w/2 + studWidth + s * studSpacing;
            if (studX < w/2 - studWidth) {
              const interiorStud = new THREE.Mesh(
                new THREE.BoxGeometry(studWidth, studHeight, studDepth),
                studMat
              );
              interiorStud.position.set(studX, baseY + plateHeight + studHeight/2, 0);
              group.add(interiorStud);
            }
          }

          // === DRYWALL SHEATHING ===
          // Front drywall panel
          const frontDrywall = new THREE.Mesh(
            new THREE.BoxGeometry(w, ponyHeight - plateHeight, drywallThickness),
            drywallMat
          );
          frontDrywall.position.set(0, baseY + plateHeight + (ponyHeight - plateHeight)/2, ponyDepth/2 - drywallThickness/2);
          frontDrywall.castShadow = true;
          frontDrywall.receiveShadow = true;
          group.add(frontDrywall);

          // Back drywall panel
          const backDrywall = new THREE.Mesh(
            new THREE.BoxGeometry(w, ponyHeight - plateHeight, drywallThickness),
            drywallMat
          );
          backDrywall.position.set(0, baseY + plateHeight + (ponyHeight - plateHeight)/2, -ponyDepth/2 + drywallThickness/2);
          backDrywall.castShadow = true;
          backDrywall.receiveShadow = true;
          group.add(backDrywall);

          // === TOP SURFACE / CAP ===
          // If a countertop material is applied, show a proper stone cap
          // Otherwise show drywall finish ready for a separate cap element
          if (textureUrl || el.storeProduct || el.materialId) {
            // Stone cap with applied material
            const capThickness = el.capThickness || 0.1; // 1.25" default
            const capOverhang = 0.08; // 1" overhang on each side
            const capMat = createTexturedMaterial(color, textureUrl, {
              roughness: 0.35,
              metalness: 0.02
            });

            // Main cap surface
            const stoneCap = new THREE.Mesh(
              new THREE.BoxGeometry(w + capOverhang * 2, capThickness, ponyDepth + capOverhang * 2),
              capMat
            );
            stoneCap.position.set(0, baseY + ponyHeight + capThickness / 2, 0);
            stoneCap.castShadow = true;
            stoneCap.receiveShadow = true;
            group.add(stoneCap);

            // Front edge detail (slight lip/drip edge)
            const edgeMat = new THREE.MeshStandardMaterial({
              color: adjustColorBrightness(color, -20),
              roughness: 0.5
            });
            const frontEdge = new THREE.Mesh(
              new THREE.BoxGeometry(w + capOverhang * 2, 0.02, 0.02),
              edgeMat
            );
            frontEdge.position.set(0, baseY + ponyHeight + capThickness - 0.01, ponyDepth / 2 + capOverhang);
            group.add(frontEdge);
          } else {
            // Plain drywall top (no material applied yet)
            const topSurface = new THREE.Mesh(
              new THREE.BoxGeometry(w, 0.02, ponyDepth),
              drywallTopMat
            );
            topSurface.position.set(0, baseY + ponyHeight, 0);
            topSurface.receiveShadow = true;
            group.add(topSurface);
          }

          // === CORNER BEADS (metal edges at corners) ===
          const beadSize = 0.02;
          // Top front corner bead
          const topFrontBead = new THREE.Mesh(
            new THREE.BoxGeometry(w, beadSize, beadSize),
            cornerBeadMat
          );
          topFrontBead.position.set(0, baseY + ponyHeight - beadSize/2, ponyDepth/2 - beadSize/2);
          group.add(topFrontBead);

          // Top back corner bead
          const topBackBead = new THREE.Mesh(
            new THREE.BoxGeometry(w, beadSize, beadSize),
            cornerBeadMat
          );
          topBackBead.position.set(0, baseY + ponyHeight - beadSize/2, -ponyDepth/2 + beadSize/2);
          group.add(topBackBead);

          // Vertical corner beads at ends
          [-1, 1].forEach(side => {
            // Front vertical
            const frontVertBead = new THREE.Mesh(
              new THREE.BoxGeometry(beadSize, ponyHeight - plateHeight, beadSize),
              cornerBeadMat
            );
            frontVertBead.position.set(
              side * (w/2 - beadSize/2),
              baseY + plateHeight + (ponyHeight - plateHeight)/2,
              ponyDepth/2 - beadSize/2
            );
            group.add(frontVertBead);

            // Back vertical
            const backVertBead = new THREE.Mesh(
              new THREE.BoxGeometry(beadSize, ponyHeight - plateHeight, beadSize),
              cornerBeadMat
            );
            backVertBead.position.set(
              side * (w/2 - beadSize/2),
              baseY + plateHeight + (ponyHeight - plateHeight)/2,
              -ponyDepth/2 + beadSize/2
            );
            group.add(backVertBead);
          });

          // === END CAPS (close off the stud cavity at ends) ===
          [-1, 1].forEach(side => {
            const endCap = new THREE.Mesh(
              new THREE.BoxGeometry(drywallThickness, ponyHeight - plateHeight, ponyDepth - drywallThickness * 2),
              drywallMat
            );
            endCap.position.set(
              side * (w/2 + drywallThickness/2),
              baseY + plateHeight + (ponyHeight - plateHeight)/2,
              0
            );
            endCap.castShadow = true;
            group.add(endCap);
          });

          // === BASEBOARD (optional, at floor level) ===
          const baseboardMat = new THREE.MeshStandardMaterial({
            color: 0xFFFFFF,
            roughness: 0.5
          });
          const baseboardHeight = 0.25; // 3" baseboard
          // Front baseboard
          const frontBaseboard = new THREE.Mesh(
            new THREE.BoxGeometry(w + 0.02, baseboardHeight, 0.03),
            baseboardMat
          );
          frontBaseboard.position.set(0, baseY + baseboardHeight/2, ponyDepth/2 + 0.015);
          group.add(frontBaseboard);

          // Back baseboard
          const backBaseboard = new THREE.Mesh(
            new THREE.BoxGeometry(w + 0.02, baseboardHeight, 0.03),
            baseboardMat
          );
          backBaseboard.position.set(0, baseY + baseboardHeight/2, -ponyDepth/2 - 0.015);
          group.add(backBaseboard);

          break;
        }

        // ===== WALL NICHES & RECESSES =====
        case 'wall-niche':
        case 'fireplace-niche':
        case 'tv-niche':
        case 'shower-niche': {
          // Simple recessed niche - dark opening with depth
          const nicheDepth = el.nicheDepth || 0.5; // 6" default recess
          const isFireplace = el.type === 'fireplace-niche';
          const isTV = el.type === 'tv-niche';
          const isShower = el.type === 'shower-niche';

          // Simple dark interior color
          const interiorColor = isFireplace ? 0x1A1A1A : (isTV ? 0x0A0A0A : (isShower ? 0x3A3A3A : 0x252530));

          // Materials
          const interiorMat = new THREE.MeshStandardMaterial({
            color: interiorColor,
            roughness: 0.9,
            side: THREE.DoubleSide
          });
          const sideMat = new THREE.MeshStandardMaterial({
            color: adjustColorBrightness(interiorColor, 20),
            roughness: 0.85,
            side: THREE.DoubleSide
          });

          // === RECESSED BOX INTERIOR ===
          // Back wall (the dark back of the niche)
          const backWall = new THREE.Mesh(
            new THREE.PlaneGeometry(w, h),
            interiorMat
          );
          backWall.position.set(0, 0, -nicheDepth);
          group.add(backWall);

          // Left side wall
          const leftWall = new THREE.Mesh(
            new THREE.PlaneGeometry(nicheDepth, h),
            sideMat
          );
          leftWall.rotation.y = Math.PI / 2;
          leftWall.position.set(-w/2, 0, -nicheDepth/2);
          group.add(leftWall);

          // Right side wall
          const rightWall = new THREE.Mesh(
            new THREE.PlaneGeometry(nicheDepth, h),
            sideMat
          );
          rightWall.rotation.y = -Math.PI / 2;
          rightWall.position.set(w/2, 0, -nicheDepth/2);
          group.add(rightWall);

          // Top wall (ceiling of niche)
          const topWall = new THREE.Mesh(
            new THREE.PlaneGeometry(w, nicheDepth),
            sideMat
          );
          topWall.rotation.x = Math.PI / 2;
          topWall.position.set(0, h/2, -nicheDepth/2);
          group.add(topWall);

          // Bottom wall (floor of niche)
          const bottomWall = new THREE.Mesh(
            new THREE.PlaneGeometry(w, nicheDepth),
            sideMat
          );
          bottomWall.rotation.x = -Math.PI / 2;
          bottomWall.position.set(0, -h/2, -nicheDepth/2);
          group.add(bottomWall);

          // === SIMPLE TRIM FRAME ===
          const trimWidth = 0.06;
          const trimDepth = 0.03;
          const trimMat = new THREE.MeshStandardMaterial({
            color: 0xF0F0F0,
            roughness: 0.4
          });

          // Top trim
          const topTrim = new THREE.Mesh(
            new THREE.BoxGeometry(w + trimWidth * 2, trimWidth, trimDepth),
            trimMat
          );
          topTrim.position.set(0, h/2 + trimWidth/2, trimDepth/2);
          group.add(topTrim);

          // Bottom trim
          const bottomTrim = new THREE.Mesh(
            new THREE.BoxGeometry(w + trimWidth * 2, trimWidth, trimDepth),
            trimMat
          );
          bottomTrim.position.set(0, -h/2 - trimWidth/2, trimDepth/2);
          group.add(bottomTrim);

          // Left trim
          const leftTrim = new THREE.Mesh(
            new THREE.BoxGeometry(trimWidth, h, trimDepth),
            trimMat
          );
          leftTrim.position.set(-w/2 - trimWidth/2, 0, trimDepth/2);
          group.add(leftTrim);

          // Right trim
          const rightTrim = new THREE.Mesh(
            new THREE.BoxGeometry(trimWidth, h, trimDepth),
            trimMat
          );
          rightTrim.position.set(w/2 + trimWidth/2, 0, trimDepth/2);
          group.add(rightTrim);

          // === TYPE-SPECIFIC SIMPLE ADDITIONS ===
          if (isFireplace) {
            // Fire glow at bottom
            const fireMat = new THREE.MeshBasicMaterial({
              color: 0xFF4500,
              transparent: true,
              opacity: 0.7
            });
            const fire = new THREE.Mesh(
              new THREE.SphereGeometry(0.2, 8, 8),
              fireMat
            );
            fire.scale.set(2, 0.8, 0.5);
            fire.position.set(0, -h/2 + 0.2, -nicheDepth * 0.6);
            group.add(fire);

          } else if (isTV) {
            // TV screen rectangle
            const screenMat = new THREE.MeshStandardMaterial({
              color: 0x050505,
              roughness: 0.05,
              metalness: 0.3
            });
            const tvW = w * 0.85;
            const tvH = tvW * 0.5625; // 16:9
            const screen = new THREE.Mesh(
              new THREE.BoxGeometry(tvW, tvH, 0.03),
              screenMat
            );
            screen.position.set(0, 0, -nicheDepth/2);
            group.add(screen);

          } else if (isShower) {
            // Simple shelf
            const shelfMat = new THREE.MeshStandardMaterial({
              color: 0x808080,
              roughness: 0.3
            });
            const shelf = new THREE.Mesh(
              new THREE.BoxGeometry(w - 0.04, 0.02, nicheDepth - 0.04),
              shelfMat
            );
            shelf.position.set(0, 0, -nicheDepth/2);
            group.add(shelf);
          }

          // === STONE SURROUND WITH INTERIOR LEDGES (if applied) ===
          if (el.surroundColor || el.hasStoneSurround || el.texture || el.storeProduct) {
            // Get material texture if available
            const stoneTextureUrl = el.texture || el.storeProduct?.image || null;
            const stoneColor = el.surroundColor || el.color || 0x708090;

            const surroundMat = stoneTextureUrl
              ? createTexturedMaterial(stoneColor, stoneTextureUrl, { roughness: 0.35, metalness: 0.05 })
              : new THREE.MeshStandardMaterial({
                  color: stoneColor,
                  roughness: 0.35,
                  metalness: 0.05
                });

            const surrW = 0.12; // Frame width (~1.5")
            const surrD = el.stoneThickness || 0.1; // Frame depth/thickness
            const returnDepth = Math.min(nicheDepth * 0.4, 0.3); // How far stone goes INTO recess

            // === STONE FACE FRAME ===
            // Top stone piece
            const topSurr = new THREE.Mesh(
              new THREE.BoxGeometry(w + surrW * 2 + trimWidth * 2, surrW, surrD),
              surroundMat
            );
            topSurr.position.set(0, h/2 + trimWidth + surrW/2, surrD/2);
            topSurr.castShadow = true;
            group.add(topSurr);

            // Bottom stone piece (wider for hearth/sill effect)
            const botHeight = isFireplace ? surrW * 1.5 : surrW;
            const botSurr = new THREE.Mesh(
              new THREE.BoxGeometry(w + surrW * 2 + trimWidth * 2, botHeight, isFireplace ? surrD * 2 : surrD),
              surroundMat
            );
            botSurr.position.set(0, -h/2 - trimWidth - botHeight/2, isFireplace ? surrD : surrD/2);
            botSurr.castShadow = true;
            group.add(botSurr);

            // Side stone pieces
            [-1, 1].forEach(side => {
              const sideSurr = new THREE.Mesh(
                new THREE.BoxGeometry(surrW, h + trimWidth * 2, surrD),
                surroundMat
              );
              sideSurr.position.set(side * (w/2 + trimWidth + surrW/2), 0, surrD/2);
              sideSurr.castShadow = true;
              group.add(sideSurr);
            });

            // === STONE RETURNS/LEDGES INTO RECESS ===
            // These wrap around the inside of the opening to show stone depth

            // Top inside ledge (header return)
            const topLedge = new THREE.Mesh(
              new THREE.BoxGeometry(w, surrD * 0.6, returnDepth),
              surroundMat
            );
            topLedge.position.set(0, h/2 - surrD * 0.3, -returnDepth/2);
            topLedge.castShadow = true;
            topLedge.receiveShadow = true;
            group.add(topLedge);

            // Bottom sill (most visible ledge - like a window sill)
            const sillThickness = surrD * 0.8;
            const sillReturn = returnDepth * 1.2;
            const bottomSill = new THREE.Mesh(
              new THREE.BoxGeometry(w + 0.02, sillThickness, sillReturn),
              surroundMat
            );
            bottomSill.position.set(0, -h/2 + sillThickness/2, -sillReturn/2 + 0.01);
            bottomSill.castShadow = true;
            bottomSill.receiveShadow = true;
            group.add(bottomSill);

            // Left side return
            const leftReturn = new THREE.Mesh(
              new THREE.BoxGeometry(surrD * 0.5, h - sillThickness * 2, returnDepth),
              surroundMat
            );
            leftReturn.position.set(-w/2 + surrD * 0.25, 0, -returnDepth/2);
            leftReturn.castShadow = true;
            group.add(leftReturn);

            // Right side return
            const rightReturn = new THREE.Mesh(
              new THREE.BoxGeometry(surrD * 0.5, h - sillThickness * 2, returnDepth),
              surroundMat
            );
            rightReturn.position.set(w/2 - surrD * 0.25, 0, -returnDepth/2);
            rightReturn.castShadow = true;
            group.add(rightReturn);

            // === EDGE DETAIL (Bullnose on sill) ===
            const edgeProfile = el.edgeProfile || 'eased';
            if (edgeProfile !== 'square') {
              const edgeRadius = sillThickness * 0.3;
              const sillEdge = new THREE.Mesh(
                new THREE.CylinderGeometry(edgeRadius, edgeRadius, w, 8, 1, false, 0, Math.PI),
                surroundMat
              );
              sillEdge.rotation.x = Math.PI / 2;
              sillEdge.rotation.z = Math.PI / 2;
              sillEdge.position.set(0, -h/2 + sillThickness * 0.2, surrD * 0.35);
              group.add(sillEdge);
            }
          }

          break;
        }

        // ===== ADA GRAB BARS =====
        case 'grab-bar': {
          // ADA compliant grab bar (stainless steel look)
          const barLength = w;
          const barRadius = 0.0625; // 1.5" diameter (ADA spec: 1.25-2")

          // Bar material - brushed stainless steel
          const barMat = new THREE.MeshStandardMaterial({
            color: 0xC0C0C0,
            metalness: 0.8,
            roughness: 0.3
          });

          // Main bar tube
          const barGeo = new THREE.CylinderGeometry(barRadius, barRadius, barLength - 0.2, 16);
          barGeo.rotateZ(Math.PI / 2); // Rotate to horizontal
          const bar = new THREE.Mesh(barGeo, barMat);
          bar.castShadow = true;
          group.add(bar);

          // Mounting flanges (ends)
          const flangeMat = new THREE.MeshStandardMaterial({
            color: 0x888888,
            metalness: 0.6,
            roughness: 0.4
          });

          // Left flange
          const leftFlange = new THREE.Mesh(
            new THREE.CylinderGeometry(barRadius * 2, barRadius * 2, 0.05, 16),
            flangeMat
          );
          leftFlange.rotateZ(Math.PI / 2);
          leftFlange.position.set(-barLength / 2 + 0.05, 0, 0);
          group.add(leftFlange);

          // Right flange
          const rightFlange = new THREE.Mesh(
            new THREE.CylinderGeometry(barRadius * 2, barRadius * 2, 0.05, 16),
            flangeMat
          );
          rightFlange.rotateZ(Math.PI / 2);
          rightFlange.position.set(barLength / 2 - 0.05, 0, 0);
          group.add(rightFlange);

          // Mounting plates (against wall)
          const plateMat = new THREE.MeshStandardMaterial({
            color: 0x666666,
            metalness: 0.5,
            roughness: 0.5
          });

          const leftPlate = new THREE.Mesh(
            new THREE.BoxGeometry(0.15, 0.15, 0.02),
            plateMat
          );
          leftPlate.position.set(-barLength / 2 + 0.1, 0, -barRadius - 0.01);
          group.add(leftPlate);

          const rightPlate = new THREE.Mesh(
            new THREE.BoxGeometry(0.15, 0.15, 0.02),
            plateMat
          );
          rightPlate.position.set(barLength / 2 - 0.1, 0, -barRadius - 0.01);
          group.add(rightPlate);

          break;
        }

        case 'double-door': {
          // Double door with full frame
          const doorColor = el.color ? parseInt(el.color.replace('#', ''), 16) : 0xDEB887;
          const doorMat = new THREE.MeshStandardMaterial({ color: doorColor, roughness: 0.6 });
          const dblFrameMat = new THREE.MeshStandardMaterial({ color: 0xFFFFFF, roughness: 0.5 });
          const frameWidth = 0.08;
          const frameDepth = 0.18;
          const doorGap = 0.03; // Gap between doors
          const doorW = (w - doorGap) / 2 - frameWidth;

          // Left door panel
          const leftDoor = new THREE.Mesh(
            new THREE.BoxGeometry(doorW, h - frameWidth, 0.08),
            doorMat
          );
          leftDoor.position.set(-doorW / 2 - doorGap / 2, -frameWidth / 2, 0);
          leftDoor.castShadow = true;
          group.add(leftDoor);

          // Right door panel
          const rightDoor = new THREE.Mesh(
            new THREE.BoxGeometry(doorW, h - frameWidth, 0.08),
            doorMat
          );
          rightDoor.position.set(doorW / 2 + doorGap / 2, -frameWidth / 2, 0);
          rightDoor.castShadow = true;
          group.add(rightDoor);

          // Panel details on each door
          const panelMat = new THREE.MeshStandardMaterial({
            color: adjustColorBrightness(doorColor, -20),
            roughness: 0.5
          });
          [-1, 1].forEach(side => {
            const panelTop = new THREE.Mesh(
              new THREE.BoxGeometry(doorW * 0.7, h * 0.3, 0.02),
              panelMat
            );
            panelTop.position.set(side * (doorW / 2 + doorGap / 2), h * 0.15, 0.05);
            group.add(panelTop);

            const panelBottom = new THREE.Mesh(
              new THREE.BoxGeometry(doorW * 0.7, h * 0.3, 0.02),
              panelMat
            );
            panelBottom.position.set(side * (doorW / 2 + doorGap / 2), -h * 0.25, 0.05);
            group.add(panelBottom);
          });

          // Frame - top
          const topFrame = new THREE.Mesh(
            new THREE.BoxGeometry(w + frameWidth * 2, frameWidth, frameDepth),
            dblFrameMat
          );
          topFrame.position.set(0, h / 2, 0);
          group.add(topFrame);

          // Frame - left
          const leftFrame = new THREE.Mesh(
            new THREE.BoxGeometry(frameWidth, h, frameDepth),
            dblFrameMat
          );
          leftFrame.position.set(-w / 2 - frameWidth / 2, 0, 0);
          group.add(leftFrame);

          // Frame - right
          const rightFrame = new THREE.Mesh(
            new THREE.BoxGeometry(frameWidth, h, frameDepth),
            dblFrameMat
          );
          rightFrame.position.set(w / 2 + frameWidth / 2, 0, 0);
          group.add(rightFrame);

          // Handles (lever style)
          const handleMat = new THREE.MeshStandardMaterial({
            color: 0xC0C0C0,
            metalness: 0.8,
            roughness: 0.2
          });

          // Left door handle
          const leftHandlePlate = new THREE.Mesh(
            new THREE.BoxGeometry(0.05, 0.12, 0.02),
            handleMat
          );
          leftHandlePlate.position.set(-doorGap / 2 - 0.08, 0, 0.06);
          group.add(leftHandlePlate);

          const leftLever = new THREE.Mesh(
            new THREE.BoxGeometry(0.1, 0.025, 0.025),
            handleMat
          );
          leftLever.position.set(-doorGap / 2 - 0.12, 0, 0.08);
          group.add(leftLever);

          // Right door handle
          const rightHandlePlate = new THREE.Mesh(
            new THREE.BoxGeometry(0.05, 0.12, 0.02),
            handleMat
          );
          rightHandlePlate.position.set(doorGap / 2 + 0.08, 0, 0.06);
          group.add(rightHandlePlate);

          const rightLever = new THREE.Mesh(
            new THREE.BoxGeometry(0.1, 0.025, 0.025),
            handleMat
          );
          rightLever.position.set(doorGap / 2 + 0.12, 0, 0.08);
          group.add(rightLever);

          break;
        }

        case 'sliding-door':
        case 'glass-door':
        case 'french-door': {
          // Professional door variants with proper architectural details
          const isSliding = el.type === 'sliding-door';
          const isFrench = el.type === 'french-door';

          // Materials based on door type
          const frameColor = isSliding ? 0x8A8A8A : (isFrench ? 0xF5F0E6 : 0xFFFFFF);
          const frameMat = new THREE.MeshStandardMaterial({
            color: frameColor,
            roughness: isSliding ? 0.3 : 0.45,
            metalness: isSliding ? 0.6 : 0.1
          });
          const hardwareMat = new THREE.MeshStandardMaterial({
            color: 0xC0C0C0,
            roughness: 0.15,
            metalness: 0.9
          });
          const rubberMat = new THREE.MeshStandardMaterial({
            color: 0x1a1a1a,
            roughness: 0.9
          });

          // Frame dimensions
          const frameDepth = 0.15; // 3.5" frame depth
          const frameWidth = isSliding ? 0.08 : 0.12; // Frame profile width

          // Outdoor palette
          const outdoorPalette = OUTDOOR_COLORS[sceneSettings.timeOfDay] || OUTDOOR_COLORS.noon;

          // === OUTDOOR VIEW (behind door) ===
          const skyMat = new THREE.MeshBasicMaterial({ color: outdoorPalette.sky, side: THREE.DoubleSide });
          const skyPane = new THREE.Mesh(
            new THREE.PlaneGeometry(w - frameWidth * 2 - 0.1, h - frameWidth * 2),
            skyMat
          );
          skyPane.position.z = -frameDepth/2 + 0.01;
          group.add(skyPane);

          const horizonMat = new THREE.MeshBasicMaterial({ color: outdoorPalette.horizon });
          const horizonPane = new THREE.Mesh(
            new THREE.PlaneGeometry(w - frameWidth * 2 - 0.1, h * 0.35),
            horizonMat
          );
          horizonPane.position.set(0, -h * 0.32, -frameDepth/2 + 0.015);
          group.add(horizonPane);

          if (sceneSettings.timeOfDay !== 'night') {
            const treeMat = new THREE.MeshBasicMaterial({ color: 0x228B22 });
            for (let i = 0; i < 4; i++) {
              const treeH = 0.4 + Math.random() * 0.25;
              const tree = new THREE.Mesh(new THREE.ConeGeometry(treeH * 0.4, treeH, 6), treeMat);
              tree.position.set((i - 1.5) * w * 0.25, -h * 0.15 + Math.random() * 0.1, -frameDepth/2 + 0.02);
              group.add(tree);
            }
          } else {
            const starMat = new THREE.MeshBasicMaterial({ color: 0xFFFFFF });
            for (let i = 0; i < 12; i++) {
              const star = new THREE.Mesh(new THREE.SphereGeometry(0.015, 4, 4), starMat);
              star.position.set(
                (Math.random() - 0.5) * (w - 0.3),
                h * 0.1 + Math.random() * h * 0.35,
                -frameDepth/2 + 0.02
              );
              group.add(star);
            }
            const moonMat = new THREE.MeshBasicMaterial({ color: 0xFFFACD });
            const moon = new THREE.Mesh(new THREE.CircleGeometry(0.1, 16), moonMat);
            moon.position.set(w * 0.3, h * 0.3, -frameDepth/2 + 0.02);
            group.add(moon);
          }

          // Glass material
          const glassColor = sceneSettings.timeOfDay === 'night' ? 0x2a3a5a : 0xADD8E6;
          const glassMat = new THREE.MeshStandardMaterial({
            color: glassColor,
            transparent: true,
            opacity: 0.15,
            roughness: 0.02,
            metalness: 0.3
          });

          if (isSliding) {
            // === SLIDING PATIO DOOR ===
            // Aluminum frame system with tracks

            // Main frame (jambs, head, sill)
            // Head
            const head = new THREE.Mesh(
              new THREE.BoxGeometry(w, frameWidth, frameDepth),
              frameMat
            );
            head.position.set(0, h/2 - frameWidth/2, 0);
            head.castShadow = true;
            group.add(head);

            // Side jambs
            [-1, 1].forEach(side => {
              const jamb = new THREE.Mesh(
                new THREE.BoxGeometry(frameWidth, h - frameWidth, frameDepth),
                frameMat
              );
              jamb.position.set(side * (w/2 - frameWidth/2), -frameWidth/2, 0);
              jamb.castShadow = true;
              group.add(jamb);
            });

            // Sill/track assembly
            const sillMat = new THREE.MeshStandardMaterial({ color: 0x666666, roughness: 0.4, metalness: 0.5 });
            const sill = new THREE.Mesh(
              new THREE.BoxGeometry(w, 0.06, frameDepth + 0.1),
              sillMat
            );
            sill.position.set(0, -h/2 + 0.03, 0.05);
            group.add(sill);

            // Track channels in sill
            [-1, 1].forEach((track, idx) => {
              const trackChannel = new THREE.Mesh(
                new THREE.BoxGeometry(w - frameWidth * 2, 0.015, 0.025),
                new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.5 })
              );
              trackChannel.position.set(0, -h/2 + 0.045, track * 0.025);
              group.add(trackChannel);
            });

            // Panel dimensions
            const panelW = (w - frameWidth * 2) / 2 + 0.02;
            const panelH = h - frameWidth - 0.06;
            const stileWidth = 0.05; // Vertical frame members
            const railHeight = 0.06; // Horizontal frame members

            // Fixed panel (left/exterior)
            const fixedPanelGroup = new THREE.Group();

            // Stiles (vertical members)
            [-1, 1].forEach(side => {
              const stile = new THREE.Mesh(
                new THREE.BoxGeometry(stileWidth, panelH, 0.04),
                frameMat
              );
              stile.position.set(side * (panelW/2 - stileWidth/2), 0, 0);
              fixedPanelGroup.add(stile);
            });

            // Rails (horizontal members)
            [-1, 1].forEach(pos => {
              const rail = new THREE.Mesh(
                new THREE.BoxGeometry(panelW, railHeight, 0.04),
                frameMat
              );
              rail.position.set(0, pos * (panelH/2 - railHeight/2), 0);
              fixedPanelGroup.add(rail);
            });

            // Glass
            const fixedGlass = new THREE.Mesh(
              new THREE.PlaneGeometry(panelW - stileWidth * 2 - 0.02, panelH - railHeight * 2 - 0.02),
              glassMat
            );
            fixedGlass.position.z = 0.01;
            fixedPanelGroup.add(fixedGlass);

            fixedPanelGroup.position.set(-panelW/2 + 0.01, -frameWidth/2 - 0.03 + panelH/2, -0.025);
            group.add(fixedPanelGroup);

            // Sliding panel (right/interior) - slightly in front
            const slidePanelGroup = new THREE.Group();

            [-1, 1].forEach(side => {
              const stile = new THREE.Mesh(
                new THREE.BoxGeometry(stileWidth, panelH, 0.04),
                frameMat
              );
              stile.position.set(side * (panelW/2 - stileWidth/2), 0, 0);
              slidePanelGroup.add(stile);
            });

            [-1, 1].forEach(pos => {
              const rail = new THREE.Mesh(
                new THREE.BoxGeometry(panelW, railHeight, 0.04),
                frameMat
              );
              rail.position.set(0, pos * (panelH/2 - railHeight/2), 0);
              slidePanelGroup.add(rail);
            });

            const slideGlass = new THREE.Mesh(
              new THREE.PlaneGeometry(panelW - stileWidth * 2 - 0.02, panelH - railHeight * 2 - 0.02),
              glassMat
            );
            slideGlass.position.z = 0.01;
            slidePanelGroup.add(slideGlass);

            // Handle on sliding panel
            const handlePlate = new THREE.Mesh(
              new THREE.BoxGeometry(0.025, 0.2, 0.015),
              hardwareMat
            );
            handlePlate.position.set(-panelW/2 + stileWidth + 0.03, 0, 0.03);
            slidePanelGroup.add(handlePlate);

            const handleGrip = new THREE.Mesh(
              new THREE.BoxGeometry(0.02, 0.12, 0.025),
              hardwareMat
            );
            handleGrip.position.set(-panelW/2 + stileWidth + 0.045, 0, 0.04);
            slidePanelGroup.add(handleGrip);

            // Rollers (visible at bottom)
            [-0.15, 0.15].forEach(rx => {
              const roller = new THREE.Mesh(
                new THREE.CylinderGeometry(0.015, 0.015, 0.02, 12),
                new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.6 })
              );
              roller.rotation.x = Math.PI / 2;
              roller.position.set(rx * panelW, -panelH/2 + 0.01, 0.02);
              slidePanelGroup.add(roller);
            });

            slidePanelGroup.position.set(panelW/2 - 0.01, -frameWidth/2 - 0.03 + panelH/2, 0.025);
            group.add(slidePanelGroup);

            // Interlock (where panels meet)
            const interlock = new THREE.Mesh(
              new THREE.BoxGeometry(0.02, panelH - 0.1, 0.06),
              frameMat
            );
            interlock.position.set(0, -frameWidth/2 - 0.03 + panelH/2, 0);
            group.add(interlock);

            // Weather stripping
            const weatherStrip = new THREE.Mesh(
              new THREE.BoxGeometry(0.01, panelH, 0.02),
              rubberMat
            );
            weatherStrip.position.set(-w/2 + frameWidth + 0.005, -frameWidth/2 - 0.03 + panelH/2, 0);
            group.add(weatherStrip);

          } else if (isFrench) {
            // === FRENCH DOORS (Double doors with true divided lites) ===
            const doorColor = el.color ? parseInt(el.color.replace('#', ''), 16) : 0xF5F0E6;
            const doorMat = new THREE.MeshStandardMaterial({
              color: doorColor,
              roughness: 0.5
            });

            // Frame (jambs, head)
            const head = new THREE.Mesh(
              new THREE.BoxGeometry(w + 0.05, frameWidth, frameDepth),
              frameMat
            );
            head.position.set(0, h/2 - frameWidth/2, 0);
            head.castShadow = true;
            group.add(head);

            [-1, 1].forEach(side => {
              const jamb = new THREE.Mesh(
                new THREE.BoxGeometry(frameWidth, h, frameDepth),
                frameMat
              );
              jamb.position.set(side * (w/2 + frameWidth/2 - 0.025), 0, 0);
              jamb.castShadow = true;
              group.add(jamb);
            });

            // Threshold
            const thresholdMat = new THREE.MeshStandardMaterial({ color: 0x8B7355, roughness: 0.6 });
            const threshold = new THREE.Mesh(
              new THREE.BoxGeometry(w, 0.04, frameDepth + 0.08),
              thresholdMat
            );
            threshold.position.set(0, -h/2 + 0.02, 0.04);
            group.add(threshold);

            // Door panels (2)
            const panelW = (w - 0.08) / 2;
            const panelH = h - frameWidth - 0.04;
            const stileWidth = 0.06;
            const topRailH = 0.08;
            const botRailH = 0.25; // Larger bottom rail (kick area)
            const muntinW = 0.025;

            // Calculate lite (glass pane) grid - 10 lite pattern (2 cols x 5 rows)
            const liteCols = 2;
            const liteRows = 5;

            [-1, 1].forEach((side, doorIdx) => {
              const doorGroup = new THREE.Group();

              // Stiles (vertical members)
              [-1, 1].forEach(stSide => {
                const stile = new THREE.Mesh(
                  new THREE.BoxGeometry(stileWidth, panelH, 0.045),
                  doorMat
                );
                stile.position.set(stSide * (panelW/2 - stileWidth/2), 0, 0);
                stile.castShadow = true;
                doorGroup.add(stile);
              });

              // Top rail
              const topRail = new THREE.Mesh(
                new THREE.BoxGeometry(panelW, topRailH, 0.045),
                doorMat
              );
              topRail.position.set(0, panelH/2 - topRailH/2, 0);
              topRail.castShadow = true;
              doorGroup.add(topRail);

              // Bottom rail (kick panel)
              const botRail = new THREE.Mesh(
                new THREE.BoxGeometry(panelW, botRailH, 0.045),
                doorMat
              );
              botRail.position.set(0, -panelH/2 + botRailH/2, 0);
              botRail.castShadow = true;
              doorGroup.add(botRail);

              // Raised panel detail on bottom rail
              const kickPanel = new THREE.Mesh(
                new THREE.BoxGeometry(panelW - stileWidth * 2 - 0.04, botRailH - 0.06, 0.015),
                new THREE.MeshStandardMaterial({ color: adjustColorBrightness(doorColor, -15), roughness: 0.45 })
              );
              kickPanel.position.set(0, -panelH/2 + botRailH/2, 0.03);
              doorGroup.add(kickPanel);

              // Glass area
              const glassAreaW = panelW - stileWidth * 2;
              const glassAreaH = panelH - topRailH - botRailH;
              const glassAreaY = -botRailH/2 + topRailH/2;

              // Muntins (grille bars)
              // Vertical muntins
              for (let c = 1; c < liteCols; c++) {
                const vMuntin = new THREE.Mesh(
                  new THREE.BoxGeometry(muntinW, glassAreaH, muntinW),
                  doorMat
                );
                vMuntin.position.set(-glassAreaW/2 + c * glassAreaW/liteCols, glassAreaY, 0.02);
                doorGroup.add(vMuntin);
              }

              // Horizontal muntins
              for (let r = 1; r < liteRows; r++) {
                const hMuntin = new THREE.Mesh(
                  new THREE.BoxGeometry(glassAreaW, muntinW, muntinW),
                  doorMat
                );
                hMuntin.position.set(0, glassAreaY - glassAreaH/2 + r * glassAreaH/liteRows, 0.02);
                doorGroup.add(hMuntin);
              }

              // Glass panes (individual lites)
              const liteW = (glassAreaW - muntinW * (liteCols - 1)) / liteCols - 0.01;
              const liteH = (glassAreaH - muntinW * (liteRows - 1)) / liteRows - 0.01;

              for (let c = 0; c < liteCols; c++) {
                for (let r = 0; r < liteRows; r++) {
                  const lite = new THREE.Mesh(
                    new THREE.PlaneGeometry(liteW, liteH),
                    glassMat
                  );
                  const liteX = -glassAreaW/2 + liteW/2 + c * (liteW + muntinW) + 0.005;
                  const liteY = glassAreaY + glassAreaH/2 - liteH/2 - r * (liteH + muntinW) - 0.005;
                  lite.position.set(liteX, liteY, 0.01);
                  doorGroup.add(lite);
                }
              }

              // Hinges (3 per door)
              [0.85, 0, -0.85].forEach((hy, hi) => {
                const hinge = new THREE.Mesh(
                  new THREE.BoxGeometry(0.02, 0.1, 0.025),
                  hardwareMat
                );
                hinge.position.set(side * (panelW/2 - stileWidth/2), panelH * 0.4 * hy, 0.035);
                doorGroup.add(hinge);
              });

              // Handle (opposite side from hinges)
              if (doorIdx === 0) {
                // Active door - lever handle
                const handlePlate = new THREE.Mesh(
                  new THREE.BoxGeometry(0.045, 0.18, 0.015),
                  hardwareMat
                );
                handlePlate.position.set(panelW/2 - stileWidth - 0.05, 0, 0.035);
                doorGroup.add(handlePlate);

                const handleLever = new THREE.Mesh(
                  new THREE.CylinderGeometry(0.012, 0.012, 0.12, 8),
                  hardwareMat
                );
                handleLever.rotation.z = Math.PI / 2;
                handleLever.position.set(panelW/2 - stileWidth - 0.02, 0.02, 0.05);
                doorGroup.add(handleLever);

                // Deadbolt
                const deadbolt = new THREE.Mesh(
                  new THREE.CylinderGeometry(0.018, 0.018, 0.02, 12),
                  hardwareMat
                );
                deadbolt.rotation.x = Math.PI / 2;
                deadbolt.position.set(panelW/2 - stileWidth - 0.05, 0.15, 0.035);
                doorGroup.add(deadbolt);
              }

              doorGroup.position.set(side * (panelW/2 + 0.02), (panelH - h)/2 + frameWidth/2 + 0.02, 0.01);
              group.add(doorGroup);
            });

            // Astragal (center mullion where doors meet)
            const astragal = new THREE.Mesh(
              new THREE.BoxGeometry(0.04, h - frameWidth - 0.04, frameDepth * 0.6),
              frameMat
            );
            astragal.position.set(0, -frameWidth/2 - 0.02, frameDepth * 0.15);
            group.add(astragal);

          } else {
            // === SINGLE GLASS DOOR (Commercial style) ===
            // Aluminum storefront door with push bar

            // Frame
            const head = new THREE.Mesh(
              new THREE.BoxGeometry(w + 0.04, frameWidth, frameDepth),
              frameMat
            );
            head.position.set(0, h/2 - frameWidth/2, 0);
            head.castShadow = true;
            group.add(head);

            [-1, 1].forEach(side => {
              const jamb = new THREE.Mesh(
                new THREE.BoxGeometry(frameWidth, h, frameDepth),
                frameMat
              );
              jamb.position.set(side * (w/2 + frameWidth/2 - 0.02), 0, 0);
              jamb.castShadow = true;
              group.add(jamb);
            });

            // Threshold
            const thresholdMat = new THREE.MeshStandardMaterial({ color: 0x808080, roughness: 0.5, metalness: 0.3 });
            const threshold = new THREE.Mesh(
              new THREE.BoxGeometry(w, 0.03, frameDepth + 0.05),
              thresholdMat
            );
            threshold.position.set(0, -h/2 + 0.015, 0.025);
            group.add(threshold);

            // Door panel
            const doorPanelH = h - frameWidth - 0.03;
            const stileW = 0.06;
            const topRailH = 0.06;
            const botRailH = 0.35; // Kick plate area

            // Door frame (stiles and rails)
            [-1, 1].forEach(side => {
              const stile = new THREE.Mesh(
                new THREE.BoxGeometry(stileW, doorPanelH, 0.05),
                frameMat
              );
              stile.position.set(side * (w/2 - stileW/2), -frameWidth/2 - 0.015, 0.02);
              stile.castShadow = true;
              group.add(stile);
            });

            const topRail = new THREE.Mesh(
              new THREE.BoxGeometry(w, topRailH, 0.05),
              frameMat
            );
            topRail.position.set(0, h/2 - frameWidth - topRailH/2, 0.02);
            group.add(topRail);

            // Bottom rail / kick plate
            const kickPlateMat = new THREE.MeshStandardMaterial({ color: 0x888888, roughness: 0.35, metalness: 0.5 });
            const kickPlate = new THREE.Mesh(
              new THREE.BoxGeometry(w - stileW * 2, botRailH, 0.04),
              kickPlateMat
            );
            kickPlate.position.set(0, -h/2 + 0.03 + botRailH/2, 0.03);
            kickPlate.castShadow = true;
            group.add(kickPlate);

            // Main glass panel
            const glassH = doorPanelH - topRailH - botRailH;
            const glassPane = new THREE.Mesh(
              new THREE.PlaneGeometry(w - stileW * 2 - 0.02, glassH - 0.02),
              glassMat
            );
            glassPane.position.set(0, -h/2 + 0.03 + botRailH + glassH/2, 0.025);
            group.add(glassPane);

            // Push bar (panic bar style)
            const pushBarMat = new THREE.MeshStandardMaterial({ color: 0xC0C0C0, roughness: 0.2, metalness: 0.8 });

            // Bar housing
            const barHousing = new THREE.Mesh(
              new THREE.BoxGeometry(w * 0.7, 0.06, 0.04),
              pushBarMat
            );
            barHousing.position.set(0, 0, frameDepth/2 + 0.02);
            group.add(barHousing);

            // Push bar (touchpad)
            const pushBar = new THREE.Mesh(
              new THREE.BoxGeometry(w * 0.6, 0.04, 0.025),
              pushBarMat
            );
            pushBar.position.set(0, 0, frameDepth/2 + 0.055);
            group.add(pushBar);

            // End caps
            [-1, 1].forEach(side => {
              const endCap = new THREE.Mesh(
                new THREE.BoxGeometry(0.04, 0.08, 0.06),
                pushBarMat
              );
              endCap.position.set(side * w * 0.35, 0, frameDepth/2 + 0.03);
              group.add(endCap);
            });

            // Door closer (at top)
            const closerBody = new THREE.Mesh(
              new THREE.BoxGeometry(0.25, 0.06, 0.08),
              new THREE.MeshStandardMaterial({ color: 0x4a4a4a, roughness: 0.4, metalness: 0.3 })
            );
            closerBody.position.set(w * 0.2, h/2 - frameWidth - 0.08, frameDepth/2 + 0.04);
            group.add(closerBody);

            const closerArm = new THREE.Mesh(
              new THREE.BoxGeometry(0.2, 0.02, 0.025),
              hardwareMat
            );
            closerArm.position.set(w * 0.35, h/2 - frameWidth - 0.06, frameDepth/2 + 0.05);
            closerArm.rotation.z = -0.2;
            group.add(closerArm);

            // Pull handle (outside - cylinder style)
            const pullHandle = new THREE.Mesh(
              new THREE.CylinderGeometry(0.015, 0.015, 0.35, 12),
              hardwareMat
            );
            pullHandle.position.set(w/2 - stileW - 0.08, 0, -frameDepth/2 - 0.04);
            group.add(pullHandle);

            // Handle mounts
            [-1, 1].forEach(pos => {
              const mount = new THREE.Mesh(
                new THREE.CylinderGeometry(0.02, 0.02, 0.04, 12),
                hardwareMat
              );
              mount.rotation.x = Math.PI / 2;
              mount.position.set(w/2 - stileW - 0.08, pos * 0.15, -frameDepth/2 - 0.02);
              group.add(mount);
            });
          }

          break;
        }

        case 'window-large':
        case 'window-bay': {
          // Large picture window or bay window with scenic view
          const isBay = el.type === 'window-bay';
          const windowFrameMat = new THREE.MeshStandardMaterial({ color: 0xFFFFFF, roughness: 0.5 });
          const outdoorPalette = OUTDOOR_COLORS[sceneSettings.timeOfDay] || OUTDOOR_COLORS.noon;

          if (isBay) {
            // Bay window - three angled panes
            const centerW = w * 0.5;
            const sideW = w * 0.3;
            const angle = Math.PI / 6; // 30 degrees

            // Center pane
            const centerFrame = new THREE.Mesh(new THREE.BoxGeometry(centerW, h, 0.1), windowFrameMat);
            group.add(centerFrame);

            // Sky behind center
            const centerSky = new THREE.Mesh(new THREE.BoxGeometry(centerW - 0.15, h - 0.15, 0.01), new THREE.MeshBasicMaterial({ color: outdoorPalette.sky }));
            centerSky.position.z = -0.05;
            group.add(centerSky);

            // Left angled pane
            const leftGroup = new THREE.Group();
            const leftFrame = new THREE.Mesh(new THREE.BoxGeometry(sideW, h, 0.1), windowFrameMat);
            const leftSky = new THREE.Mesh(new THREE.BoxGeometry(sideW - 0.1, h - 0.15, 0.01), new THREE.MeshBasicMaterial({ color: outdoorPalette.sky }));
            leftSky.position.z = -0.05;
            leftGroup.add(leftFrame);
            leftGroup.add(leftSky);
            leftGroup.position.set(-centerW/2 - sideW/2 * Math.cos(angle), 0, -sideW/2 * Math.sin(angle));
            leftGroup.rotation.y = angle;
            group.add(leftGroup);

            // Right angled pane
            const rightGroup = new THREE.Group();
            const rightFrame = new THREE.Mesh(new THREE.BoxGeometry(sideW, h, 0.1), windowFrameMat);
            const rightSky = new THREE.Mesh(new THREE.BoxGeometry(sideW - 0.1, h - 0.15, 0.01), new THREE.MeshBasicMaterial({ color: outdoorPalette.sky }));
            rightSky.position.z = -0.05;
            rightGroup.add(rightFrame);
            rightGroup.add(rightSky);
            rightGroup.position.set(centerW/2 + sideW/2 * Math.cos(angle), 0, -sideW/2 * Math.sin(angle));
            rightGroup.rotation.y = -angle;
            group.add(rightGroup);

            // Sill
            const sillMat = new THREE.MeshStandardMaterial({ color: 0xDEB887, roughness: 0.6 });
            const sill = new THREE.Mesh(new THREE.BoxGeometry(w, 0.1, d + 0.5), sillMat);
            sill.position.set(0, -h/2 - 0.05, 0.2);
            group.add(sill);
          } else {
            // Large picture window
            const windowFrame = new THREE.Mesh(new THREE.BoxGeometry(w, h, 0.15), windowFrameMat);
            group.add(windowFrame);

            // Sky background
            const skyMat = new THREE.MeshBasicMaterial({ color: outdoorPalette.sky });
            const skyPane = new THREE.Mesh(new THREE.BoxGeometry(w - 0.2, h - 0.2, 0.01), skyMat);
            skyPane.position.z = -0.05;
            group.add(skyPane);

            // Horizon
            const horizonMat = new THREE.MeshBasicMaterial({ color: outdoorPalette.horizon });
            const horizonPane = new THREE.Mesh(new THREE.BoxGeometry(w - 0.2, h * 0.35, 0.01), horizonMat);
            horizonPane.position.set(0, -h * 0.3, -0.04);
            group.add(horizonPane);

            // Multiple trees for large window
            if (sceneSettings.timeOfDay !== 'night') {
              const treeMat = new THREE.MeshBasicMaterial({ color: 0x228B22 });
              for (let i = 0; i < 5; i++) {
                const tree = new THREE.Mesh(new THREE.ConeGeometry(0.15 + Math.random() * 0.1, 0.4 + Math.random() * 0.2, 4), treeMat);
                tree.position.set((i - 2) * w * 0.2, -h * 0.12, -0.03);
                group.add(tree);
              }
            }

            // Glass
            const glassColor = sceneSettings.timeOfDay === 'night' ? 0x1a1a3a : 0x87CEEB;
            const glassMat = new THREE.MeshStandardMaterial({
              color: glassColor,
              transparent: true,
              opacity: 0.2,
              roughness: 0.05
            });
            const glass = new THREE.Mesh(new THREE.BoxGeometry(w - 0.15, h - 0.15, 0.02), glassMat);
            glass.position.z = 0.05;
            group.add(glass);
          }
          break;
        }

        case 'entry-archway': {
          // Simplified archway - dark recessed opening with arch trim
          const archStyle = el.archwayStyle || 'round';
          const archColor = el.color ? parseInt(el.color.replace('#', ''), 16) : 0xDAA520;
          const wallDepth = Math.max(0.5, d || 0.67);
          const archRadius = w / 2;

          // Materials
          const interiorMat = new THREE.MeshStandardMaterial({
            color: 0x1A1A1A,
            roughness: 0.9,
            side: THREE.DoubleSide
          });
          const sideMat = new THREE.MeshStandardMaterial({
            color: 0x2A2A2A,
            roughness: 0.85,
            side: THREE.DoubleSide
          });
          const trimMat = new THREE.MeshStandardMaterial({
            color: archColor,
            roughness: 0.5
          });
          const trimDarkMat = new THREE.MeshStandardMaterial({
            color: adjustColorBrightness(archColor, -30),
            roughness: 0.6
          });

          // === DARK INTERIOR OPENING ===
          // Create arch shape for back wall
          const archShape = new THREE.Shape();
          archShape.moveTo(-w/2, -h/2);
          archShape.lineTo(-w/2, h/2 - archRadius);
          // Arch curve at top
          if (archStyle === 'round') {
            archShape.absarc(0, h/2 - archRadius, archRadius, Math.PI, 0, true);
          } else if (archStyle === 'pointed') {
            // Gothic pointed arch
            archShape.quadraticCurveTo(-w/4, h/2 + archRadius * 0.3, 0, h/2 + archRadius * 0.2);
            archShape.quadraticCurveTo(w/4, h/2 + archRadius * 0.3, w/2, h/2 - archRadius);
          } else if (archStyle === 'elliptical') {
            // Segmental arch
            archShape.absellipse(0, h/2 - archRadius * 0.6, archRadius, archRadius * 0.6, Math.PI, 0, true);
          } else {
            // Flat opening
            archShape.lineTo(w/2, h/2 - archRadius);
            archShape.lineTo(w/2, h/2);
            archShape.lineTo(-w/2, h/2);
          }
          archShape.lineTo(w/2, h/2 - archRadius);
          archShape.lineTo(w/2, -h/2);
          archShape.lineTo(-w/2, -h/2);

          // Back wall (dark opening)
          const backGeom = new THREE.ShapeGeometry(archShape);
          const backWall = new THREE.Mesh(backGeom, interiorMat);
          backWall.position.set(0, 0, -wallDepth);
          group.add(backWall);

          // Side walls (reveals)
          // Left wall
          const leftWall = new THREE.Mesh(
            new THREE.PlaneGeometry(wallDepth, h),
            sideMat
          );
          leftWall.rotation.y = Math.PI / 2;
          leftWall.position.set(-w/2, 0, -wallDepth/2);
          group.add(leftWall);

          // Right wall
          const rightWall = new THREE.Mesh(
            new THREE.PlaneGeometry(wallDepth, h),
            sideMat
          );
          rightWall.rotation.y = -Math.PI / 2;
          rightWall.position.set(w/2, 0, -wallDepth/2);
          group.add(rightWall);

          // Floor of opening
          const floorWall = new THREE.Mesh(
            new THREE.PlaneGeometry(w, wallDepth),
            sideMat
          );
          floorWall.rotation.x = -Math.PI / 2;
          floorWall.position.set(0, -h/2, -wallDepth/2);
          group.add(floorWall);

          // === TRIM/CASING ===
          const trimWidth = 0.12;
          const trimDepth = 0.06;

          // Left trim
          const leftTrim = new THREE.Mesh(
            new THREE.BoxGeometry(trimWidth, h - archRadius, trimDepth),
            trimMat
          );
          leftTrim.position.set(-w/2 - trimWidth/2, -archRadius/2, trimDepth/2);
          group.add(leftTrim);

          // Right trim
          const rightTrim = new THREE.Mesh(
            new THREE.BoxGeometry(trimWidth, h - archRadius, trimDepth),
            trimMat
          );
          rightTrim.position.set(w/2 + trimWidth/2, -archRadius/2, trimDepth/2);
          group.add(rightTrim);

          // Arch curve trim (simplified as segments)
          if (archStyle === 'round' || archStyle === 'elliptical') {
            const numSegs = 12;
            for (let i = 0; i < numSegs; i++) {
              const a1 = Math.PI * (i / numSegs);
              const a2 = Math.PI * ((i + 1) / numSegs);
              const r = archRadius + trimWidth/2;

              const x1 = -Math.cos(a1) * r;
              const y1 = (h/2 - archRadius) + Math.sin(a1) * (archStyle === 'elliptical' ? archRadius * 0.6 : archRadius);
              const x2 = -Math.cos(a2) * r;
              const y2 = (h/2 - archRadius) + Math.sin(a2) * (archStyle === 'elliptical' ? archRadius * 0.6 : archRadius);

              const segLen = Math.sqrt((x2-x1)**2 + (y2-y1)**2);
              const segAng = Math.atan2(y2-y1, x2-x1);

              const archSeg = new THREE.Mesh(
                new THREE.BoxGeometry(segLen * 1.1, trimWidth, trimDepth),
                trimMat
              );
              archSeg.position.set((x1+x2)/2, (y1+y2)/2, trimDepth/2);
              archSeg.rotation.z = segAng;
              group.add(archSeg);
            }
          } else {
            // Flat header
            const headerTrim = new THREE.Mesh(
              new THREE.BoxGeometry(w + trimWidth * 2, trimWidth, trimDepth),
              trimMat
            );
            headerTrim.position.set(0, h/2 + trimWidth/2, trimDepth/2);
            group.add(headerTrim);
          }

          // Keystone (decorative center block at top)
          const keystoneMat = new THREE.MeshStandardMaterial({
            color: adjustColorBrightness(archColor, 15),
            roughness: 0.45
          });
          const keystone = new THREE.Mesh(
            new THREE.BoxGeometry(trimWidth * 1.5, trimWidth * 1.8, trimDepth * 1.2),
            keystoneMat
          );
          const keystoneY = archStyle === 'flat' ? h/2 + trimWidth/2 :
                           (archStyle === 'pointed' ? h/2 + archRadius * 0.2 : h/2);
          keystone.position.set(0, keystoneY, trimDepth * 0.6);
          group.add(keystone);

          // Base blocks (plinths at bottom of trim)
          [-1, 1].forEach(side => {
            const plinth = new THREE.Mesh(
              new THREE.BoxGeometry(trimWidth * 1.3, trimWidth * 0.8, trimDepth * 1.1),
              trimDarkMat
            );
            plinth.position.set(side * (w/2 + trimWidth/2), -h/2 + trimWidth * 0.4, trimDepth * 0.55);
            group.add(plinth);
          });

          break;
        }

        case 'garage-door': {
          // Garage door with proper sectional panel construction
          const doorColor = el.color ? parseInt(el.color.replace('#', ''), 16) : 0xD4D4D4;

          // Materials
          const doorMat = new THREE.MeshStandardMaterial({
            color: doorColor,
            roughness: 0.6,
            metalness: 0.1
          });
          const panelMat = new THREE.MeshStandardMaterial({
            color: adjustColorBrightness(doorColor, -15),
            roughness: 0.5
          });
          const recessMat = new THREE.MeshStandardMaterial({
            color: adjustColorBrightness(doorColor, -30),
            roughness: 0.7
          });
          const hardwareMat = new THREE.MeshStandardMaterial({
            color: 0x3A3A3A,
            roughness: 0.3,
            metalness: 0.7
          });
          const frameMat = new THREE.MeshStandardMaterial({
            color: 0x4A4A4A,
            roughness: 0.5
          });
          const weatherMat = new THREE.MeshStandardMaterial({
            color: 0x2A2A2A,
            roughness: 0.9
          });

          // Door dimensions
          const doorDepth = 0.08;
          const frameWidth = 0.15;
          const sections = 4; // Horizontal sections
          const panelsPerSection = 3; // Raised panels per section
          const sectionHeight = h / sections;
          const panelGap = 0.03;

          // === DOOR FRAME (trim around opening) ===
          // Top frame
          const topFrame = new THREE.Mesh(
            new THREE.BoxGeometry(w + frameWidth * 2, frameWidth, doorDepth + 0.1),
            frameMat
          );
          topFrame.position.set(0, h/2 + frameWidth/2, 0);
          topFrame.castShadow = true;
          group.add(topFrame);

          // Left frame
          const leftFrame = new THREE.Mesh(
            new THREE.BoxGeometry(frameWidth, h + frameWidth, doorDepth + 0.1),
            frameMat
          );
          leftFrame.position.set(-w/2 - frameWidth/2, frameWidth/2, 0);
          leftFrame.castShadow = true;
          group.add(leftFrame);

          // Right frame
          const rightFrame = new THREE.Mesh(
            new THREE.BoxGeometry(frameWidth, h + frameWidth, doorDepth + 0.1),
            frameMat
          );
          rightFrame.position.set(w/2 + frameWidth/2, frameWidth/2, 0);
          rightFrame.castShadow = true;
          group.add(rightFrame);

          // === DOOR SECTIONS (4 horizontal panels) ===
          for (let sec = 0; sec < sections; sec++) {
            const secY = h/2 - sectionHeight/2 - sec * sectionHeight;

            // Section base panel
            const sectionPanel = new THREE.Mesh(
              new THREE.BoxGeometry(w - panelGap, sectionHeight - panelGap, doorDepth),
              doorMat
            );
            sectionPanel.position.set(0, secY, 0);
            sectionPanel.castShadow = true;
            sectionPanel.receiveShadow = true;
            group.add(sectionPanel);

            // Raised panels within each section
            const panelWidth = (w - panelGap * 4) / panelsPerSection;
            const panelHeight = sectionHeight - panelGap * 2 - 0.06;

            for (let p = 0; p < panelsPerSection; p++) {
              const panelX = -w/2 + panelGap * 1.5 + panelWidth/2 + p * (panelWidth + panelGap);

              // Raised panel face
              const raisedPanel = new THREE.Mesh(
                new THREE.BoxGeometry(panelWidth - 0.04, panelHeight, 0.02),
                panelMat
              );
              raisedPanel.position.set(panelX, secY, doorDepth/2 + 0.01);
              group.add(raisedPanel);

              // Panel recess (shadow line around raised panel)
              const recessDepth = 0.015;
              // Top recess
              const topRecess = new THREE.Mesh(
                new THREE.BoxGeometry(panelWidth - 0.02, 0.02, recessDepth),
                recessMat
              );
              topRecess.position.set(panelX, secY + panelHeight/2 + 0.01, doorDepth/2 - recessDepth/2);
              group.add(topRecess);

              // Bottom recess
              const botRecess = new THREE.Mesh(
                new THREE.BoxGeometry(panelWidth - 0.02, 0.02, recessDepth),
                recessMat
              );
              botRecess.position.set(panelX, secY - panelHeight/2 - 0.01, doorDepth/2 - recessDepth/2);
              group.add(botRecess);
            }

            // Section joint line (horizontal gap between sections)
            if (sec < sections - 1) {
              const jointLine = new THREE.Mesh(
                new THREE.BoxGeometry(w, 0.01, 0.01),
                weatherMat
              );
              jointLine.position.set(0, secY - sectionHeight/2, doorDepth/2);
              group.add(jointLine);
            }

            // Hardware - Hinges (2 per section side)
            [-1, 1].forEach(side => {
              const hingeY = secY;
              const hinge = new THREE.Mesh(
                new THREE.BoxGeometry(0.05, 0.12, 0.03),
                hardwareMat
              );
              hinge.position.set(side * (w/2 - 0.06), hingeY, doorDepth/2 + 0.02);
              group.add(hinge);

              // Hinge roller bracket
              const bracket = new THREE.Mesh(
                new THREE.BoxGeometry(0.08, 0.04, 0.02),
                hardwareMat
              );
              bracket.position.set(side * (w/2 - 0.06), hingeY - 0.08, doorDepth/2 + 0.015);
              group.add(bracket);
            });
          }

          // === WINDOW PANELS (top section) ===
          const hasWindows = w > 7; // Windows only on wide doors
          if (hasWindows) {
            const windowGlassMat = new THREE.MeshStandardMaterial({
              color: 0x87CEEB,
              transparent: true,
              opacity: 0.3,
              roughness: 0.1
            });
            const windowFrameMat = new THREE.MeshStandardMaterial({
              color: 0x666666,
              roughness: 0.4
            });

            const windowsPerSection = Math.floor((w - 0.5) / 1.5);
            const windowWidth = 0.8;
            const windowHeight = sectionHeight * 0.6;
            const topSecY = h/2 - sectionHeight/2;

            for (let wn = 0; wn < windowsPerSection; wn++) {
              const wnX = -w/2 + 0.5 + windowWidth/2 + wn * (w - 0.5) / windowsPerSection;

              // Window frame
              const wnFrame = new THREE.Mesh(
                new THREE.BoxGeometry(windowWidth + 0.04, windowHeight + 0.04, 0.025),
                windowFrameMat
              );
              wnFrame.position.set(wnX, topSecY, doorDepth/2 + 0.02);
              group.add(wnFrame);

              // Window glass
              const wnGlass = new THREE.Mesh(
                new THREE.BoxGeometry(windowWidth, windowHeight, 0.01),
                windowGlassMat
              );
              wnGlass.position.set(wnX, topSecY, doorDepth/2 + 0.03);
              group.add(wnGlass);

              // Window muntins (cross pattern)
              const muntinMat = new THREE.MeshStandardMaterial({ color: 0x555555, roughness: 0.4 });
              const vMuntin = new THREE.Mesh(
                new THREE.BoxGeometry(0.02, windowHeight, 0.015),
                muntinMat
              );
              vMuntin.position.set(wnX, topSecY, doorDepth/2 + 0.035);
              group.add(vMuntin);

              const hMuntin = new THREE.Mesh(
                new THREE.BoxGeometry(windowWidth, 0.02, 0.015),
                muntinMat
              );
              hMuntin.position.set(wnX, topSecY, doorDepth/2 + 0.035);
              group.add(hMuntin);
            }
          }

          // === BOTTOM SEAL (weather stripping) ===
          const bottomSeal = new THREE.Mesh(
            new THREE.BoxGeometry(w, 0.04, 0.06),
            weatherMat
          );
          bottomSeal.position.set(0, -h/2 + 0.02, doorDepth/2);
          group.add(bottomSeal);

          // === HANDLE (lift handle at bottom) ===
          const handleBase = new THREE.Mesh(
            new THREE.BoxGeometry(0.35, 0.08, 0.04),
            hardwareMat
          );
          handleBase.position.set(0, -h/2 + sectionHeight/2, doorDepth/2 + 0.03);
          group.add(handleBase);

          const handleGrip = new THREE.Mesh(
            new THREE.BoxGeometry(0.25, 0.04, 0.08),
            hardwareMat
          );
          handleGrip.position.set(0, -h/2 + sectionHeight/2, doorDepth/2 + 0.08);
          group.add(handleGrip);

          break;
        }

        case 'crown-molding': {
          // Crown molding with ornate profile
          const moldColor = el.color ? parseInt(el.color.replace('#', '0x')) : 0xF5F5F5;
          const moldMat = new THREE.MeshStandardMaterial({ color: moldColor, roughness: 0.4 });

          // Create crown molding profile shape
          const crownShape = new THREE.Shape();
          const mh = 0.25; // molding height
          const md = 0.2;  // molding depth

          // Ornate crown profile
          crownShape.moveTo(0, 0);
          crownShape.lineTo(md, 0);
          crownShape.lineTo(md, mh * 0.1);
          crownShape.quadraticCurveTo(md * 0.9, mh * 0.2, md * 0.85, mh * 0.3);
          crownShape.quadraticCurveTo(md * 0.75, mh * 0.5, md * 0.6, mh * 0.6);
          crownShape.bezierCurveTo(md * 0.4, mh * 0.75, md * 0.2, mh * 0.9, 0, mh);
          crownShape.lineTo(0, 0);

          const extrudeSettings = { steps: 1, depth: w, bevelEnabled: false };
          const crownGeom = new THREE.ExtrudeGeometry(crownShape, extrudeSettings);
          crownGeom.rotateY(-Math.PI / 2);
          crownGeom.translate(w/2, 0, 0);

          const crown = new THREE.Mesh(crownGeom, moldMat);
          group.add(crown);

          // Shadow line detail
          const shadowMat = new THREE.MeshStandardMaterial({ color: 0xDDDDDD, roughness: 0.5 });
          const shadowLine = new THREE.Mesh(new THREE.BoxGeometry(w, 0.02, 0.02), shadowMat);
          shadowLine.position.set(0, mh * 0.3, md * 0.7);
          group.add(shadowLine);
          break;
        }

        case 'baseboard': {
          // Baseboard with stepped profile
          const bbColor = el.color ? parseInt(el.color.replace('#', '0x')) : 0xF5F5F5;
          const bbMat = new THREE.MeshStandardMaterial({ color: bbColor, roughness: 0.35 });

          // Create baseboard profile
          const bbShape = new THREE.Shape();
          const bbh = 0.5;  // baseboard height (6 inches)
          const bbd = 0.08; // baseboard depth

          bbShape.moveTo(0, 0);
          bbShape.lineTo(bbd, 0);
          bbShape.lineTo(bbd, bbh * 0.7);
          bbShape.lineTo(bbd * 0.7, bbh * 0.75);
          bbShape.lineTo(bbd * 0.7, bbh * 0.85);
          bbShape.lineTo(bbd * 0.5, bbh * 0.9);
          bbShape.lineTo(bbd * 0.5, bbh);
          bbShape.lineTo(0, bbh);
          bbShape.lineTo(0, 0);

          const bbExtrudeSettings = { steps: 1, depth: w, bevelEnabled: false };
          const bbGeom = new THREE.ExtrudeGeometry(bbShape, bbExtrudeSettings);
          bbGeom.rotateY(-Math.PI / 2);
          bbGeom.translate(w/2, -bbh/2, 0);

          const baseboard = new THREE.Mesh(bbGeom, bbMat);
          group.add(baseboard);
          break;
        }

        case 'chair-rail': {
          // Chair rail molding at mid-height
          const crColor = el.color ? parseInt(el.color.replace('#', '0x')) : 0xF5F5F5;
          const crMat = new THREE.MeshStandardMaterial({ color: crColor, roughness: 0.35 });

          // Create chair rail profile
          const crShape = new THREE.Shape();
          const crh = 0.2;  // chair rail height
          const crd = 0.1;  // chair rail depth

          crShape.moveTo(0, 0);
          crShape.lineTo(crd, 0);
          crShape.lineTo(crd, crh * 0.2);
          crShape.quadraticCurveTo(crd * 0.8, crh * 0.4, crd * 0.7, crh * 0.5);
          crShape.lineTo(crd * 0.7, crh * 0.6);
          crShape.quadraticCurveTo(crd * 0.5, crh * 0.8, 0, crh);
          crShape.lineTo(0, 0);

          const crExtrudeSettings = { steps: 1, depth: w, bevelEnabled: false };
          const crGeom = new THREE.ExtrudeGeometry(crShape, crExtrudeSettings);
          crGeom.rotateY(-Math.PI / 2);
          crGeom.translate(w/2, -crh/2, 0);

          const chairRail = new THREE.Mesh(crGeom, crMat);
          group.add(chairRail);
          break;
        }

        // ===== BATHROOM ELEMENTS =====
        case 'toilet': {
          // Elongated toilet with tank
          const porcelainMat = new THREE.MeshStandardMaterial({
            color: 0xFFFFFF,
            roughness: 0.15,
            metalness: 0.05
          });
          const chromeMat = new THREE.MeshStandardMaterial({
            color: 0xC0C0C0,
            roughness: 0.1,
            metalness: 0.9
          });
          const seatMat = new THREE.MeshStandardMaterial({
            color: 0xF5F5F5,
            roughness: 0.3
          });

          // Bowl base
          const bowlBaseH = 0.35;
          const bowlBase = new THREE.Mesh(
            new THREE.CylinderGeometry(w * 0.35, w * 0.4, bowlBaseH, 16),
            porcelainMat
          );
          bowlBase.position.set(0, bowlBaseH / 2 - h / 2, d * 0.1);
          group.add(bowlBase);

          // Bowl (elongated shape)
          const bowlH = 0.5;
          const bowlGeom = new THREE.CylinderGeometry(w * 0.42, w * 0.35, bowlH, 16, 1, false);
          const bowl = new THREE.Mesh(bowlGeom, porcelainMat);
          bowl.position.set(0, bowlBaseH + bowlH / 2 - h / 2, d * 0.1);
          group.add(bowl);

          // Inner bowl (dark)
          const innerBowlMat = new THREE.MeshStandardMaterial({ color: 0x4a6070, roughness: 0.3 });
          const innerBowl = new THREE.Mesh(
            new THREE.CylinderGeometry(w * 0.32, w * 0.28, 0.3, 16),
            innerBowlMat
          );
          innerBowl.position.set(0, bowlBaseH + bowlH - 0.1 - h / 2, d * 0.1);
          group.add(innerBowl);

          // Seat
          const seatH = 0.05;
          const seat = new THREE.Mesh(
            new THREE.CylinderGeometry(w * 0.44, w * 0.44, seatH, 24),
            seatMat
          );
          seat.position.set(0, bowlBaseH + bowlH + seatH / 2 - h / 2, d * 0.1);
          group.add(seat);

          // Tank
          const tankW = w * 0.7;
          const tankH = 1.1;
          const tankD = 0.6;
          const tank = new THREE.Mesh(
            new THREE.BoxGeometry(tankW, tankH, tankD),
            porcelainMat
          );
          tank.position.set(0, bowlBaseH + tankH / 2 - h / 2, -d * 0.3);
          group.add(tank);

          // Tank lid
          const lidMat = new THREE.MeshStandardMaterial({ color: 0xF8F8F8, roughness: 0.2 });
          const tankLid = new THREE.Mesh(
            new THREE.BoxGeometry(tankW + 0.05, 0.08, tankD + 0.05),
            lidMat
          );
          tankLid.position.set(0, bowlBaseH + tankH + 0.04 - h / 2, -d * 0.3);
          group.add(tankLid);

          // Flush handle
          const handle = new THREE.Mesh(
            new THREE.BoxGeometry(0.15, 0.04, 0.04),
            chromeMat
          );
          handle.position.set(-tankW / 2 - 0.05, bowlBaseH + tankH * 0.7 - h / 2, -d * 0.3);
          group.add(handle);

          break;
        }

        case 'bathtub':
        case 'bathtub-freestanding': {
          // Alcove or freestanding bathtub
          const isFreestanding = el.type === 'bathtub-freestanding';
          const tubMat = new THREE.MeshStandardMaterial({
            color: 0xFFFFFF,
            roughness: 0.1,
            metalness: 0.05
          });
          const innerMat = new THREE.MeshStandardMaterial({
            color: 0xE8E8E8,
            roughness: 0.15
          });
          const chromeMat = new THREE.MeshStandardMaterial({
            color: 0xC0C0C0,
            roughness: 0.1,
            metalness: 0.9
          });

          const tubH = isFreestanding ? 1.8 : 1.5;
          const wallThickness = 0.08;

          // Outer tub shell
          const outerTub = new THREE.Mesh(
            new THREE.BoxGeometry(w, tubH, d),
            tubMat
          );
          outerTub.position.set(0, tubH / 2 - h / 2, 0);
          group.add(outerTub);

          // Inner basin (recessed)
          const innerW = w - wallThickness * 2;
          const innerH = tubH - 0.15;
          const innerD = d - wallThickness * 2;
          const innerTub = new THREE.Mesh(
            new THREE.BoxGeometry(innerW, innerH, innerD),
            innerMat
          );
          innerTub.position.set(0, (tubH - innerH) / 2 + tubH / 2 - h / 2, 0);
          group.add(innerTub);

          // Rim
          const rimMat = new THREE.MeshStandardMaterial({ color: 0xFAFAFA, roughness: 0.08 });
          const rim = new THREE.Mesh(
            new THREE.BoxGeometry(w + 0.02, 0.08, d + 0.02),
            rimMat
          );
          rim.position.set(0, tubH + 0.04 - h / 2, 0);
          group.add(rim);

          // Faucet
          const faucetBase = new THREE.Mesh(
            new THREE.CylinderGeometry(0.05, 0.06, 0.08, 16),
            chromeMat
          );
          faucetBase.position.set(0, tubH + 0.1 - h / 2, -d / 2 + 0.2);
          group.add(faucetBase);

          const spout = new THREE.Mesh(
            new THREE.CylinderGeometry(0.025, 0.025, 0.25, 12),
            chromeMat
          );
          spout.rotation.x = Math.PI / 2;
          spout.position.set(0, tubH + 0.15 - h / 2, -d / 2 + 0.32);
          group.add(spout);

          // Drain
          const drainMat = new THREE.MeshStandardMaterial({ color: 0x808080, metalness: 0.7, roughness: 0.3 });
          const drain = new THREE.Mesh(
            new THREE.CylinderGeometry(0.03, 0.03, 0.02, 16),
            drainMat
          );
          drain.position.set(0, 0.1 - h / 2, d / 4);
          group.add(drain);

          if (isFreestanding) {
            // Feet for freestanding tub
            const footMat = new THREE.MeshStandardMaterial({ color: 0xB8860B, roughness: 0.4, metalness: 0.5 });
            const footPositions = [[-w/2 + 0.15, -d/2 + 0.15], [-w/2 + 0.15, d/2 - 0.15], [w/2 - 0.15, -d/2 + 0.15], [w/2 - 0.15, d/2 - 0.15]];
            footPositions.forEach(([fx, fz]) => {
              const foot = new THREE.Mesh(new THREE.SphereGeometry(0.08, 12, 12), footMat);
              foot.position.set(fx, -h / 2 + 0.04, fz);
              group.add(foot);
            });
          }

          break;
        }

        case 'vanity-24':
        case 'vanity-30':
        case 'vanity-36':
        case 'vanity-48':
        case 'vanity-60':
        case 'vanity-72': {
          // Bathroom vanity with sink and mirror
          const vanityMat = new THREE.MeshStandardMaterial({
            color: el.color ? parseInt(el.color.replace('#', ''), 16) : 0x8B7355,
            roughness: 0.6
          });
          const counterMat = new THREE.MeshStandardMaterial({
            color: 0xE8E0D8,
            roughness: 0.25
          });
          const sinkMat = new THREE.MeshStandardMaterial({
            color: 0xFFFFFF,
            roughness: 0.1
          });
          const chromeMat = new THREE.MeshStandardMaterial({
            color: 0xC0C0C0,
            roughness: 0.1,
            metalness: 0.9
          });

          const cabinetH = 2.5;
          const counterH = 0.1;
          const counterOverhang = 0.05;

          // Cabinet body
          const cabinet = new THREE.Mesh(
            new THREE.BoxGeometry(w, cabinetH, d),
            vanityMat
          );
          cabinet.position.set(0, cabinetH / 2 - h / 2, 0);
          group.add(cabinet);

          // Cabinet doors
          const doorMat = new THREE.MeshStandardMaterial({
            color: adjustColorBrightness(el.color ? parseInt(el.color.replace('#', ''), 16) : 0x8B7355, -15),
            roughness: 0.5
          });
          const numDoors = w > 4 ? Math.floor(w / 1.5) : (w > 2 ? 2 : 1);
          const doorW = (w - 0.1) / numDoors;
          for (let di = 0; di < numDoors; di++) {
            const door = new THREE.Mesh(
              new THREE.BoxGeometry(doorW - 0.04, cabinetH - 0.1, 0.03),
              doorMat
            );
            door.position.set(-w / 2 + doorW / 2 + di * doorW + 0.02, cabinetH / 2 - h / 2, d / 2 + 0.02);
            group.add(door);

            // Door handle
            const handleBar = new THREE.Mesh(
              new THREE.BoxGeometry(0.08, 0.02, 0.02),
              chromeMat
            );
            handleBar.position.set(-w / 2 + doorW / 2 + di * doorW + 0.02, cabinetH * 0.6 - h / 2, d / 2 + 0.05);
            group.add(handleBar);
          }

          // Countertop
          const counter = new THREE.Mesh(
            new THREE.BoxGeometry(w + counterOverhang * 2, counterH, d + counterOverhang),
            counterMat
          );
          counter.position.set(0, cabinetH + counterH / 2 - h / 2, counterOverhang / 2);
          group.add(counter);

          // Sink basin(s)
          const isDouble = w >= 5;
          const sinkW = isDouble ? w * 0.35 : w * 0.6;
          const sinkPositions = isDouble ? [-w / 4, w / 4] : [0];

          sinkPositions.forEach(sx => {
            // Basin
            const basin = new THREE.Mesh(
              new THREE.BoxGeometry(sinkW, 0.15, d * 0.5),
              sinkMat
            );
            basin.position.set(sx, cabinetH + 0.02 - h / 2, 0);
            group.add(basin);

            // Faucet
            const faucetBase = new THREE.Mesh(
              new THREE.CylinderGeometry(0.025, 0.03, 0.05, 12),
              chromeMat
            );
            faucetBase.position.set(sx, cabinetH + counterH + 0.03 - h / 2, -d / 4);
            group.add(faucetBase);

            const faucetArm = new THREE.Mesh(
              new THREE.CylinderGeometry(0.015, 0.015, 0.15, 8),
              chromeMat
            );
            faucetArm.position.set(sx, cabinetH + counterH + 0.1 - h / 2, -d / 4);
            group.add(faucetArm);

            const faucetSpout = new THREE.Mesh(
              new THREE.CylinderGeometry(0.012, 0.012, 0.12, 8),
              chromeMat
            );
            faucetSpout.rotation.x = Math.PI / 3;
            faucetSpout.position.set(sx, cabinetH + counterH + 0.16 - h / 2, -d / 4 + 0.06);
            group.add(faucetSpout);
          });

          break;
        }

        case 'shower-bench': {
          // Built-in shower bench
          const benchMat = new THREE.MeshStandardMaterial({
            color: el.color ? parseInt(el.color.replace('#', ''), 16) : 0xD4D4D4,
            roughness: 0.3
          });
          const legMat = new THREE.MeshStandardMaterial({
            color: 0xC0C0C0,
            roughness: 0.3,
            metalness: 0.4
          });

          const benchH = 1.3;
          const seatH = 0.12;
          const seatD = d;

          // Seat top
          const seat = new THREE.Mesh(
            new THREE.BoxGeometry(w, seatH, seatD),
            benchMat
          );
          seat.position.set(0, benchH - h / 2, 0);
          group.add(seat);

          // Support structure
          const supportH = benchH - seatH;
          const support = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.1, supportH, seatD - 0.1),
            benchMat
          );
          support.position.set(0, supportH / 2 - h / 2, 0);
          group.add(support);

          break;
        }

        case 'towel-warmer': {
          // Electric towel warmer rack
          const metalMat = new THREE.MeshStandardMaterial({
            color: 0xC0C0C0,
            roughness: 0.2,
            metalness: 0.85
          });

          const barSpacing = 0.25;
          const numBars = Math.floor((h - 0.3) / barSpacing);
          const barRadius = 0.02;

          // Side rails
          [-1, 1].forEach(side => {
            const rail = new THREE.Mesh(
              new THREE.CylinderGeometry(barRadius, barRadius, h - 0.1, 12),
              metalMat
            );
            rail.position.set(side * (w / 2 - barRadius * 2), 0, 0);
            group.add(rail);
          });

          // Horizontal bars
          for (let bi = 0; bi < numBars; bi++) {
            const barY = -h / 2 + 0.15 + bi * barSpacing;
            const bar = new THREE.Mesh(
              new THREE.CylinderGeometry(barRadius, barRadius, w - barRadius * 4, 12),
              metalMat
            );
            bar.rotation.z = Math.PI / 2;
            bar.position.set(0, barY, 0);
            group.add(bar);
          }

          // Mounting brackets
          const bracketMat = new THREE.MeshStandardMaterial({ color: 0x888888, roughness: 0.3, metalness: 0.6 });
          [-1, 1].forEach(side => {
            const bracket = new THREE.Mesh(
              new THREE.BoxGeometry(0.08, 0.08, 0.04),
              bracketMat
            );
            bracket.position.set(side * (w / 2 - 0.04), h / 3, -d / 2 - 0.01);
            group.add(bracket);
          });

          break;
        }

        // ===== LAUNDRY ELEMENTS =====
        case 'washer': {
          // Front-loading washing machine
          const bodyMat = new THREE.MeshStandardMaterial({
            color: 0xF0F0F0,
            roughness: 0.3,
            metalness: 0.1
          });
          const doorMat = new THREE.MeshStandardMaterial({
            color: 0xE0E0E0,
            roughness: 0.2,
            metalness: 0.15
          });
          const glassMat = new THREE.MeshStandardMaterial({
            color: 0x4a6080,
            transparent: true,
            opacity: 0.6,
            roughness: 0.1
          });
          const chromeMat = new THREE.MeshStandardMaterial({
            color: 0xC0C0C0,
            roughness: 0.1,
            metalness: 0.9
          });

          // Main body
          const body = new THREE.Mesh(
            new THREE.BoxGeometry(w, h, d),
            bodyMat
          );
          group.add(body);

          // Door frame (circle)
          const doorRadius = Math.min(w, h) * 0.35;
          const doorFrame = new THREE.Mesh(
            new THREE.TorusGeometry(doorRadius, 0.04, 12, 24),
            doorMat
          );
          doorFrame.position.set(0, -0.1, d / 2 + 0.01);
          group.add(doorFrame);

          // Door glass
          const glass = new THREE.Mesh(
            new THREE.CircleGeometry(doorRadius - 0.04, 24),
            glassMat
          );
          glass.position.set(0, -0.1, d / 2 + 0.02);
          group.add(glass);

          // Control panel (top)
          const panelMat = new THREE.MeshStandardMaterial({ color: 0x2a2a2a, roughness: 0.4 });
          const panel = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.1, 0.15, d * 0.5),
            panelMat
          );
          panel.position.set(0, h / 2 - 0.1, -d / 4);
          group.add(panel);

          // Dial
          const dial = new THREE.Mesh(
            new THREE.CylinderGeometry(0.06, 0.06, 0.03, 16),
            chromeMat
          );
          dial.rotation.x = Math.PI / 2;
          dial.position.set(-w / 4, h / 2 - 0.08, -d / 4 + d * 0.25 + 0.02);
          group.add(dial);

          // Display
          const displayMat = new THREE.MeshStandardMaterial({ color: 0x004400, emissive: 0x002200 });
          const display = new THREE.Mesh(
            new THREE.BoxGeometry(0.2, 0.06, 0.01),
            displayMat
          );
          display.position.set(w / 6, h / 2 - 0.08, -d / 4 + d * 0.25 + 0.02);
          group.add(display);

          // Door handle
          const handle = new THREE.Mesh(
            new THREE.BoxGeometry(0.08, 0.25, 0.04),
            chromeMat
          );
          handle.position.set(w / 2 - 0.15, -0.1, d / 2 + 0.03);
          group.add(handle);

          break;
        }

        case 'dryer': {
          // Front-loading dryer (similar to washer but with vent)
          const bodyMat = new THREE.MeshStandardMaterial({
            color: 0xE8E8E8,
            roughness: 0.3,
            metalness: 0.1
          });
          const doorMat = new THREE.MeshStandardMaterial({
            color: 0xD8D8D8,
            roughness: 0.2
          });
          const chromeMat = new THREE.MeshStandardMaterial({
            color: 0xC0C0C0,
            roughness: 0.1,
            metalness: 0.9
          });

          // Main body
          const body = new THREE.Mesh(
            new THREE.BoxGeometry(w, h, d),
            bodyMat
          );
          group.add(body);

          // Door (solid, not glass)
          const doorRadius = Math.min(w, h) * 0.35;
          const door = new THREE.Mesh(
            new THREE.CircleGeometry(doorRadius, 24),
            doorMat
          );
          door.position.set(0, -0.1, d / 2 + 0.01);
          group.add(door);

          // Door rim
          const doorRim = new THREE.Mesh(
            new THREE.TorusGeometry(doorRadius, 0.03, 12, 24),
            chromeMat
          );
          doorRim.position.set(0, -0.1, d / 2 + 0.02);
          group.add(doorRim);

          // Control panel
          const panelMat = new THREE.MeshStandardMaterial({ color: 0x3a3a3a, roughness: 0.4 });
          const panel = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.1, 0.15, d * 0.5),
            panelMat
          );
          panel.position.set(0, h / 2 - 0.1, -d / 4);
          group.add(panel);

          // Temperature dial
          const dial = new THREE.Mesh(
            new THREE.CylinderGeometry(0.06, 0.06, 0.03, 16),
            chromeMat
          );
          dial.rotation.x = Math.PI / 2;
          dial.position.set(-w / 4, h / 2 - 0.08, 0);
          group.add(dial);

          // Timer dial
          const timer = new THREE.Mesh(
            new THREE.CylinderGeometry(0.05, 0.05, 0.03, 16),
            chromeMat
          );
          timer.rotation.x = Math.PI / 2;
          timer.position.set(w / 4, h / 2 - 0.08, 0);
          group.add(timer);

          // Door handle
          const handle = new THREE.Mesh(
            new THREE.BoxGeometry(0.08, 0.25, 0.04),
            chromeMat
          );
          handle.position.set(-w / 2 + 0.15, -0.1, d / 2 + 0.03);
          group.add(handle);

          // Vent (back)
          const ventMat = new THREE.MeshStandardMaterial({ color: 0x808080, roughness: 0.5 });
          const vent = new THREE.Mesh(
            new THREE.CylinderGeometry(0.08, 0.08, 0.1, 12),
            ventMat
          );
          vent.rotation.x = Math.PI / 2;
          vent.position.set(0, -h / 3, -d / 2 - 0.05);
          group.add(vent);

          break;
        }

        case 'utility-sink':
        case 'laundry-sink': {
          // Deep utility sink for laundry
          const sinkMat = new THREE.MeshStandardMaterial({
            color: 0xF5F5F5,
            roughness: 0.2
          });
          const basinMat = new THREE.MeshStandardMaterial({
            color: 0xE8E8E8,
            roughness: 0.25
          });
          const legMat = new THREE.MeshStandardMaterial({
            color: 0xC0C0C0,
            roughness: 0.3,
            metalness: 0.6
          });
          const chromeMat = new THREE.MeshStandardMaterial({
            color: 0xB0B0B0,
            roughness: 0.1,
            metalness: 0.9
          });

          const sinkH = 2.9;
          const basinH = 0.8;
          const rimH = 0.08;
          const wallThick = 0.08;

          // Basin (deep tub shape)
          const basinOuter = new THREE.Mesh(
            new THREE.BoxGeometry(w, basinH + rimH, d),
            sinkMat
          );
          basinOuter.position.set(0, sinkH - basinH / 2 - h / 2, 0);
          group.add(basinOuter);

          // Inner basin
          const basinInner = new THREE.Mesh(
            new THREE.BoxGeometry(w - wallThick * 2, basinH, d - wallThick * 2),
            basinMat
          );
          basinInner.position.set(0, sinkH - basinH / 2 + rimH / 2 - h / 2, 0);
          group.add(basinInner);

          // Legs
          const legH = sinkH - basinH - rimH;
          [[-1, -1], [-1, 1], [1, -1], [1, 1]].forEach(([lx, lz]) => {
            const leg = new THREE.Mesh(
              new THREE.BoxGeometry(0.08, legH, 0.08),
              legMat
            );
            leg.position.set(lx * (w / 2 - 0.08), legH / 2 - h / 2, lz * (d / 2 - 0.08));
            group.add(leg);
          });

          // Faucet
          const faucetBase = new THREE.Mesh(
            new THREE.CylinderGeometry(0.04, 0.05, 0.08, 12),
            chromeMat
          );
          faucetBase.position.set(0, sinkH + 0.05 - h / 2, -d / 2 + 0.15);
          group.add(faucetBase);

          const faucetArm = new THREE.Mesh(
            new THREE.CylinderGeometry(0.025, 0.025, 0.35, 8),
            chromeMat
          );
          faucetArm.position.set(0, sinkH + 0.25 - h / 2, -d / 2 + 0.15);
          group.add(faucetArm);

          const spout = new THREE.Mesh(
            new THREE.CylinderGeometry(0.02, 0.02, 0.25, 8),
            chromeMat
          );
          spout.rotation.x = Math.PI / 2.5;
          spout.position.set(0, sinkH + 0.4 - h / 2, -d / 2 + 0.28);
          group.add(spout);

          break;
        }

        case 'drying-rack': {
          // Wall-mounted or freestanding drying rack
          const frameMat = new THREE.MeshStandardMaterial({
            color: 0xE0E0E0,
            roughness: 0.4,
            metalness: 0.3
          });
          const rodMat = new THREE.MeshStandardMaterial({
            color: 0xC0C0C0,
            roughness: 0.25,
            metalness: 0.5
          });

          const numRods = 6;
          const rodSpacing = (h - 0.3) / numRods;
          const rodRadius = 0.015;

          // Side frames
          [-1, 1].forEach(side => {
            const frame = new THREE.Mesh(
              new THREE.BoxGeometry(0.05, h, 0.05),
              frameMat
            );
            frame.position.set(side * (w / 2 - 0.025), 0, 0);
            group.add(frame);
          });

          // Top bar
          const topBar = new THREE.Mesh(
            new THREE.BoxGeometry(w, 0.05, 0.05),
            frameMat
          );
          topBar.position.set(0, h / 2 - 0.025, 0);
          group.add(topBar);

          // Drying rods
          for (let ri = 0; ri < numRods; ri++) {
            const rod = new THREE.Mesh(
              new THREE.CylinderGeometry(rodRadius, rodRadius, w - 0.1, 8),
              rodMat
            );
            rod.rotation.z = Math.PI / 2;
            rod.position.set(0, -h / 2 + 0.15 + ri * rodSpacing, 0);
            group.add(rod);
          }

          break;
        }

        // ===== CLOSET ELEMENTS =====
        case 'closet-rod': {
          // Clothing rod for hanging clothes
          const rodMat = new THREE.MeshStandardMaterial({
            color: 0xC0C0C0,
            roughness: 0.2,
            metalness: 0.8
          });
          const bracketMat = new THREE.MeshStandardMaterial({
            color: 0x808080,
            roughness: 0.3,
            metalness: 0.6
          });

          const rodRadius = 0.0625; // 1.5" diameter rod
          const bracketW = 0.12;

          // Main rod
          const rod = new THREE.Mesh(
            new THREE.CylinderGeometry(rodRadius, rodRadius, w, 16),
            rodMat
          );
          rod.rotation.z = Math.PI / 2;
          group.add(rod);

          // End brackets
          [-1, 1].forEach(side => {
            const bracket = new THREE.Mesh(
              new THREE.BoxGeometry(bracketW, 0.1, 0.08),
              bracketMat
            );
            bracket.position.set(side * (w / 2 - bracketW / 2), 0, -0.06);
            group.add(bracket);
          });

          break;
        }

        case 'closet-shelf': {
          // Wire or solid closet shelf
          const shelfMat = new THREE.MeshStandardMaterial({
            color: el.color ? parseInt(el.color.replace('#', ''), 16) : 0xE8E8E8,
            roughness: 0.4
          });

          const shelfH = 0.03; // Thin shelf

          // Solid shelf
          const shelf = new THREE.Mesh(
            new THREE.BoxGeometry(w, shelfH, d),
            shelfMat
          );
          group.add(shelf);

          // Front lip
          const lipMat = new THREE.MeshStandardMaterial({
            color: adjustColorBrightness(el.color ? parseInt(el.color.replace('#', ''), 16) : 0xE8E8E8, -10),
            roughness: 0.35
          });
          const lip = new THREE.Mesh(
            new THREE.BoxGeometry(w, 0.05, 0.02),
            lipMat
          );
          lip.position.set(0, -0.01, d / 2 + 0.01);
          group.add(lip);

          break;
        }

        case 'drawer-unit': {
          // Multi-drawer storage unit for closets
          const bodyMat = new THREE.MeshStandardMaterial({
            color: el.color ? parseInt(el.color.replace('#', ''), 16) : 0xF5F0E6,
            roughness: 0.6
          });
          const drawerMat = new THREE.MeshStandardMaterial({
            color: adjustColorBrightness(el.color ? parseInt(el.color.replace('#', ''), 16) : 0xF5F0E6, -10),
            roughness: 0.5
          });
          const handleMat = new THREE.MeshStandardMaterial({
            color: 0xC0C0C0,
            roughness: 0.2,
            metalness: 0.7
          });

          const numDrawers = Math.max(3, Math.floor(h / 0.6));
          const drawerH = (h - 0.1) / numDrawers;
          const drawerGap = 0.02;

          // Body
          const body = new THREE.Mesh(
            new THREE.BoxGeometry(w, h, d),
            bodyMat
          );
          group.add(body);

          // Drawers
          for (let di = 0; di < numDrawers; di++) {
            const drawerY = h / 2 - drawerH / 2 - di * drawerH - 0.05;

            // Drawer front
            const drawer = new THREE.Mesh(
              new THREE.BoxGeometry(w - 0.04, drawerH - drawerGap, 0.03),
              drawerMat
            );
            drawer.position.set(0, drawerY, d / 2 + 0.02);
            group.add(drawer);

            // Handle
            const handle = new THREE.Mesh(
              new THREE.BoxGeometry(w * 0.3, 0.03, 0.03),
              handleMat
            );
            handle.position.set(0, drawerY, d / 2 + 0.05);
            group.add(handle);
          }

          break;
        }

        case 'shoe-rack': {
          // Angled shoe rack/cubby
          const frameMat = new THREE.MeshStandardMaterial({
            color: el.color ? parseInt(el.color.replace('#', ''), 16) : 0xDEB887,
            roughness: 0.6
          });
          const shelfMat = new THREE.MeshStandardMaterial({
            color: adjustColorBrightness(el.color ? parseInt(el.color.replace('#', ''), 16) : 0xDEB887, 10),
            roughness: 0.5
          });

          const numShelves = Math.max(3, Math.floor(h / 0.5));
          const shelfSpacing = h / numShelves;
          const shelfAngle = Math.PI / 12; // 15 degrees

          // Side panels
          [-1, 1].forEach(side => {
            const sidePanel = new THREE.Mesh(
              new THREE.BoxGeometry(0.03, h, d),
              frameMat
            );
            sidePanel.position.set(side * (w / 2 - 0.015), 0, 0);
            group.add(sidePanel);
          });

          // Angled shelves
          for (let si = 0; si < numShelves; si++) {
            const shelfY = -h / 2 + shelfSpacing * (si + 0.5);
            const shelf = new THREE.Mesh(
              new THREE.BoxGeometry(w - 0.08, 0.02, d - 0.05),
              shelfMat
            );
            shelf.position.set(0, shelfY, 0);
            shelf.rotation.x = -shelfAngle;
            group.add(shelf);

            // Front lip to keep shoes in place
            const lip = new THREE.Mesh(
              new THREE.BoxGeometry(w - 0.08, 0.04, 0.02),
              shelfMat
            );
            lip.position.set(0, shelfY - 0.05, d / 2 - 0.05);
            group.add(lip);
          }

          break;
        }

        case 'closet-island': {
          // Center island with drawers and top surface
          const bodyMat = new THREE.MeshStandardMaterial({
            color: el.color ? parseInt(el.color.replace('#', ''), 16) : 0xF5F0E6,
            roughness: 0.5
          });
          const topMat = new THREE.MeshStandardMaterial({
            color: 0xE8E0D8,
            roughness: 0.25
          });
          const drawerMat = new THREE.MeshStandardMaterial({
            color: adjustColorBrightness(el.color ? parseInt(el.color.replace('#', ''), 16) : 0xF5F0E6, -15),
            roughness: 0.45
          });
          const handleMat = new THREE.MeshStandardMaterial({
            color: 0xB8860B,
            roughness: 0.25,
            metalness: 0.6
          });

          const baseH = h - 0.12;
          const topH = 0.1;

          // Main body
          const body = new THREE.Mesh(
            new THREE.BoxGeometry(w, baseH, d),
            bodyMat
          );
          body.position.set(0, -topH / 2, 0);
          group.add(body);

          // Top surface
          const top = new THREE.Mesh(
            new THREE.BoxGeometry(w + 0.08, topH, d + 0.08),
            topMat
          );
          top.position.set(0, h / 2 - topH / 2, 0);
          group.add(top);

          // Drawers on all four sides
          const drawerH = baseH / 3 - 0.02;
          for (let di = 0; di < 3; di++) {
            const drawerY = h / 2 - topH - drawerH / 2 - di * (drawerH + 0.02) - 0.02;

            // Front drawers
            const frontDrawer = new THREE.Mesh(
              new THREE.BoxGeometry(w / 2 - 0.04, drawerH - 0.02, 0.03),
              drawerMat
            );
            frontDrawer.position.set(0, drawerY, d / 2 + 0.02);
            group.add(frontDrawer);

            // Front handle
            const frontHandle = new THREE.Mesh(
              new THREE.CylinderGeometry(0.015, 0.015, 0.1, 8),
              handleMat
            );
            frontHandle.rotation.z = Math.PI / 2;
            frontHandle.position.set(0, drawerY, d / 2 + 0.05);
            group.add(frontHandle);
          }

          break;
        }

        case 'jewelry-cabinet': {
          // Mirrored jewelry cabinet
          const bodyMat = new THREE.MeshStandardMaterial({
            color: el.color ? parseInt(el.color.replace('#', ''), 16) : 0xF5F0E6,
            roughness: 0.4
          });
          const mirrorMat = new THREE.MeshStandardMaterial({
            color: 0xE8F0F8,
            roughness: 0.05,
            metalness: 0.9
          });
          const frameMat = new THREE.MeshStandardMaterial({
            color: 0xB8860B,
            roughness: 0.3,
            metalness: 0.5
          });
          const velvetMat = new THREE.MeshStandardMaterial({
            color: 0x4a0020,
            roughness: 0.9
          });

          // Cabinet body
          const cabinet = new THREE.Mesh(
            new THREE.BoxGeometry(w, h, d),
            bodyMat
          );
          group.add(cabinet);

          // Mirror on front
          const mirrorH = h - 0.15;
          const mirrorW = w - 0.1;
          const mirror = new THREE.Mesh(
            new THREE.BoxGeometry(mirrorW, mirrorH, 0.02),
            mirrorMat
          );
          mirror.position.set(0, 0, d / 2 + 0.01);
          group.add(mirror);

          // Mirror frame
          const frameW = 0.04;
          // Top frame
          const topFrame = new THREE.Mesh(
            new THREE.BoxGeometry(mirrorW + frameW * 2, frameW, 0.03),
            frameMat
          );
          topFrame.position.set(0, mirrorH / 2, d / 2 + 0.02);
          group.add(topFrame);
          // Bottom frame
          const bottomFrame = new THREE.Mesh(
            new THREE.BoxGeometry(mirrorW + frameW * 2, frameW, 0.03),
            frameMat
          );
          bottomFrame.position.set(0, -mirrorH / 2, d / 2 + 0.02);
          group.add(bottomFrame);
          // Side frames
          [-1, 1].forEach(side => {
            const sideFrame = new THREE.Mesh(
              new THREE.BoxGeometry(frameW, mirrorH, 0.03),
              frameMat
            );
            sideFrame.position.set(side * (mirrorW / 2 + frameW / 2), 0, d / 2 + 0.02);
            group.add(sideFrame);
          });

          // Handle
          const handle = new THREE.Mesh(
            new THREE.BoxGeometry(0.04, 0.15, 0.04),
            frameMat
          );
          handle.position.set(w / 2 - 0.1, 0, d / 2 + 0.04);
          group.add(handle);

          break;
        }

        default:
          // Default box
          const defaultMat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.5 });
          const defaultMesh = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), defaultMat);
          group.add(defaultMesh);
      }

      // Set shadows for all meshes in group
      group.traverse(child => {
        if (child.isMesh) {
          child.castShadow = true;
          child.receiveShadow = true;
        }
      });

      return { group, height: h };
    }

    function render3D() {
      if (!scene || currentView !== '3d') return;

      // Clear non-lights
      scene.children = scene.children.filter(c => c.type.includes('Light'));

      // Floor
      const floorMat = new THREE.MeshStandardMaterial({
        color: 0xD2B48C, // Tan floor color
        roughness: 0.8
      });
      const floor = new THREE.Mesh(
        new THREE.PlaneGeometry(roomWidth + 4, roomDepth + 4),
        floorMat
      );
      floor.rotation.x = -Math.PI / 2;
      floor.position.set(roomWidth / 2, 0, roomDepth / 2);
      floor.receiveShadow = true;
      scene.add(floor);

      // Room walls (3 walls, open front)
      const wallHeight = roomHeight || 8; // Use room ceiling height setting
      const wallMat = new THREE.MeshStandardMaterial({
        color: 0xFFFAF0, // Ivory walls
        roughness: 0.9,
        side: THREE.DoubleSide
      });

      // Back wall
      const backWall = new THREE.Mesh(
        new THREE.PlaneGeometry(roomWidth, wallHeight),
        wallMat
      );
      backWall.position.set(roomWidth / 2, wallHeight / 2, 0);
      backWall.receiveShadow = true;
      scene.add(backWall);

      // Left wall
      const leftWall = new THREE.Mesh(
        new THREE.PlaneGeometry(roomDepth, wallHeight),
        wallMat
      );
      leftWall.rotation.y = Math.PI / 2;
      leftWall.position.set(0, wallHeight / 2, roomDepth / 2);
      leftWall.receiveShadow = true;
      scene.add(leftWall);

      // Right wall
      const rightWall = new THREE.Mesh(
        new THREE.PlaneGeometry(roomDepth, wallHeight),
        wallMat
      );
      rightWall.rotation.y = -Math.PI / 2;
      rightWall.position.set(roomWidth, wallHeight / 2, roomDepth / 2);
      rightWall.receiveShadow = true;
      scene.add(rightWall);

      // Elements - filter out hidden ones
      const visibleElements3D = elements.filter(el => {
        if (el.hidden) return false;
        const category = getElementCategory(el.type);
        return !hiddenCategories[category];
      });

      visibleElements3D.forEach(el => {
        const { group, height } = create3DElement(el);

        // Convert 2D position to 3D
        // In 2D: origin is top-left, Y goes down
        // In 3D: origin is corner, Z goes forward (into room)
        let xPos = (el.x / pixelsPerFoot) + el.width / 2;
        let zPos = (el.y / pixelsPerFoot) + el.height / 2;
        const yPos = get3DYPosition(el, height);

        // Windows and doors snap to wall surface
        const windowDoorTypes = [
          'window', 'window-large', 'bay-window', 'picture-window',
          'door', 'double-door', 'sliding-door', 'french-door', 'glass-door',
          'entry-archway', 'garage-door'
        ];
        // Niches embed INTO the wall
        const nicheTypes = ['wall-niche', 'fireplace-niche', 'tv-niche', 'shower-niche'];
        const isNiche = nicheTypes.includes(el.type);
        const isWindowDoor = windowDoorTypes.includes(el.type);

        // Grab bars also mount to walls
        const grabBarTypes = ['grab-bar'];
        const isGrabBar = grabBarTypes.includes(el.type);

        // Cabinets and appliances that should auto-rotate when against side/front walls
        const cabinetApplianceTypes = [
          'base-cabinet', 'wall-cabinet', 'tall-cabinet', 'drawer-base', 'sink-base',
          'corner-cabinet', 'lazy-susan', 'fridge-cabinet',
          'refrigerator', 'range', 'dishwasher', 'oven', 'microwave', 'range-hood',
          'countertop', 'backsplash'
        ];
        const isCabinetAppliance = cabinetApplianceTypes.includes(el.type);

        // Check if element is against a side or front wall (not back wall)
        const el2DX = el.x / pixelsPerFoot;
        const el2DY = el.y / pixelsPerFoot;
        const elRightEdge = el2DX + el.width;
        const elBottomEdge = el2DY + el.height;
        const wallThreshold = 0.5; // Within 0.5ft of wall

        // Detect which wall the element is against
        const isAgainstRightWall = (roomWidth - elRightEdge) < wallThreshold;
        const isAgainstLeftWall = el2DX < wallThreshold;
        const isAgainstFrontWall = (roomDepth - elBottomEdge) < wallThreshold;
        const isAgainstBackWall = el2DY < wallThreshold;

        // Auto-rotate cabinets/appliances based on wall position (only if no manual rotation set)
        let autoRotated = false;
        if (isCabinetAppliance && !el.rotation) {
          if (isAgainstRightWall && !isAgainstBackWall) {
            // Right wall - rotate to face left (into room)
            group.rotation.y = -Math.PI / 2;
            autoRotated = true;
          } else if (isAgainstLeftWall && !isAgainstBackWall) {
            // Left wall - rotate to face right (into room)
            group.rotation.y = Math.PI / 2;
            autoRotated = true;
          } else if (isAgainstFrontWall && !isAgainstBackWall) {
            // Front wall - rotate to face back (into room)
            group.rotation.y = Math.PI;
            autoRotated = true;
          }
          // Back wall elements keep default rotation (facing into room)
        }

        if (isWindowDoor || isNiche || isGrabBar) {
          // Determine which wall based on 2D position and rotation
          const rotation = (el.rotation || 0) % 360;
          const normalizedRotation = rotation < 0 ? rotation + 360 : rotation;
          const el2DY = el.y / pixelsPerFoot;
          const el2DX = el.x / pixelsPerFoot;
          const elCenterX = el2DX + el.width / 2;
          const elCenterY = el2DY + el.height / 2;

          // Calculate distances to each wall edge
          const distToBack = el2DY;                                    // Top wall (back in 3D)
          const distToFront = roomDepth - (el2DY + el.height);        // Bottom wall (front in 3D)
          const distToLeft = el2DX;                                    // Left wall
          const distToRight = roomWidth - (el2DX + el.width);         // Right wall

          // Wall detection threshold (how close to wall to snap)
          const threshold = 3;

          // Determine wall primarily by rotation, with position as tiebreaker
          let closestWall;

          // Rotation is the primary indicator of which wall the element faces
          if (normalizedRotation === 90) {
            closestWall = 'left';
          } else if (normalizedRotation === 270) {
            closestWall = 'right';
          } else if (normalizedRotation === 180) {
            closestWall = 'front';
          } else if (normalizedRotation === 0) {
            // No rotation - use position to determine wall
            // Find the wall this element is closest to
            const distances = [
              { wall: 'back', dist: distToBack },
              { wall: 'front', dist: distToFront },
              { wall: 'left', dist: distToLeft },
              { wall: 'right', dist: distToRight }
            ];

            // Sort by distance and pick closest within threshold
            distances.sort((a, b) => a.dist - b.dist);
            closestWall = distances[0].dist <= threshold ? distances[0].wall : 'back';
          } else {
            // Non-standard rotation - use closest wall by position
            const distances = [
              { wall: 'back', dist: distToBack },
              { wall: 'front', dist: distToFront },
              { wall: 'left', dist: distToLeft },
              { wall: 'right', dist: distToRight }
            ];
            distances.sort((a, b) => a.dist - b.dist);
            closestWall = distances[0].wall;
          }

          // Position based on closest wall
          switch (closestWall) {
            case 'back':
              zPos = isNiche ? 0 : 0.1;
              group.rotation.y = 0;
              break;
            case 'front':
              zPos = isNiche ? roomDepth : roomDepth - 0.1;
              group.rotation.y = Math.PI;
              break;
            case 'left':
              zPos = elCenterY;
              xPos = isNiche ? 0 : 0.1;
              group.rotation.y = Math.PI / 2;
              break;
            case 'right':
              zPos = elCenterY;
              xPos = isNiche ? roomWidth : roomWidth - 0.1;
              group.rotation.y = -Math.PI / 2;
              break;
          }
        } else if (!autoRotated) {
          // Only apply manual rotation if not auto-rotated
          group.rotation.y = -(el.rotation || 0) * Math.PI / 180;
        }

        group.position.set(xPos, yPos, zPos);

        // Store element data for tooltips
        group.userData.elementData = el;

        scene.add(group);
      });

      // Update camera target
      controls.target.set(roomWidth / 2, 1.5, roomDepth / 2);
      camera.position.set(roomWidth * 1.2, roomWidth * 0.6, roomDepth * 1.3);
      controls.update();

      // Animation loop with proper ID tracking
      function animate() {
        if (currentView !== '3d') {
          animationId = null;
          return;
        }
        animationId = requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
      }
      animate();

      // Setup 3D tooltip raycasting
      setup3DTooltips();
    }

    // 3D Tooltip system with raycasting
    const raycaster3D = new THREE.Raycaster();
    const mouse3D = new THREE.Vector2();
    let hoveredObject3D = null;

    function setup3DTooltips() {
      const container = document.getElementById('canvas3DContainer');
      if (!container) return;

      container.addEventListener('mousemove', on3DMouseMove);
      container.addEventListener('mouseleave', hide3DTooltip);
    }

    function on3DMouseMove(event) {
      if (!renderer || !camera || !scene || currentView !== '3d') return;

      const container = document.getElementById('canvas3DContainer');
      const rect = container.getBoundingClientRect();

      mouse3D.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
      mouse3D.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

      raycaster3D.setFromCamera(mouse3D, camera);

      // Get all meshes in scene that have userData.elementData
      const intersects = raycaster3D.intersectObjects(scene.children, true);

      let foundElement = null;
      for (const intersect of intersects) {
        // Walk up to find group with element data
        let obj = intersect.object;
        while (obj && !obj.userData?.elementData) {
          obj = obj.parent;
        }
        if (obj?.userData?.elementData) {
          foundElement = obj.userData.elementData;
          break;
        }
      }

      if (foundElement) {
        show3DTooltip(foundElement, event.clientX, event.clientY);
        hoveredObject3D = foundElement;
      } else {
        hide3DTooltip();
        hoveredObject3D = null;
      }
    }

    function show3DTooltip(el, x, y) {
      const tooltip = document.getElementById('tooltip3D');
      const labelEl = document.getElementById('tooltip3DLabel');
      const sizeEl = document.getElementById('tooltip3DSize');

      if (!tooltip) return;

      labelEl.textContent = el.label || el.type;
      sizeEl.textContent = `${formatDimension(el.width)} Ã— ${formatDimension(el.height)}`;

      tooltip.style.display = 'block';
      tooltip.style.left = (x + 15) + 'px';
      tooltip.style.top = (y + 15) + 'px';
    }

    function hide3DTooltip() {
      const tooltip = document.getElementById('tooltip3D');
      if (tooltip) tooltip.style.display = 'none';
    }

    // ===== ZOOM =====
    function zoomIn() {
      const wrapper = document.getElementById('canvasWrapper');
      const centerX = wrapper.clientWidth / 2;
      const centerY = wrapper.clientHeight / 2;

      const worldX = (centerX - panX) / pixelsPerFoot;
      const worldY = (centerY - panY) / pixelsPerFoot;

      pixelsPerFoot = Math.min(pixelsPerFoot * 1.2, 100);

      panX = centerX - worldX * pixelsPerFoot;
      panY = centerY - worldY * pixelsPerFoot;

      updateZoomDisplay();
      draw();
    }

    function zoomOut() {
      const wrapper = document.getElementById('canvasWrapper');
      const centerX = wrapper.clientWidth / 2;
      const centerY = wrapper.clientHeight / 2;

      const worldX = (centerX - panX) / pixelsPerFoot;
      const worldY = (centerY - panY) / pixelsPerFoot;

      pixelsPerFoot = Math.max(pixelsPerFoot / 1.2, 15);

      panX = centerX - worldX * pixelsPerFoot;
      panY = centerY - worldY * pixelsPerFoot;

      updateZoomDisplay();
      draw();
    }

    function updateZoomDisplay() {
      const zoomPercent = Math.round(pixelsPerFoot / 40 * 100);
      document.getElementById('zoomLevel').textContent = zoomPercent + '%';
    }

    // Reset zoom to 100% and center the room
    function resetZoom() {
      const wrapper = document.getElementById('canvasWrapper');
      pixelsPerFoot = 40; // 100%

      // Center the room in the canvas
      panX = (wrapper.clientWidth - roomWidth * pixelsPerFoot) / 2;
      panY = (wrapper.clientHeight - roomDepth * pixelsPerFoot) / 2;

      updateZoomDisplay();
      draw();
      showSnapFeedback('Zoom reset to 100%');
    }

    function toggleViewLock() {
      viewLocked = !viewLocked;
      const btn = document.getElementById('lockViewBtn');
      if (btn) {
        btn.textContent = viewLocked ? 'ðŸ”’' : 'ðŸ”“';
        btn.title = viewLocked ? 'Unlock view (allow pan/zoom)' : 'Lock view (prevent pan/zoom)';
        btn.style.background = viewLocked ? 'var(--gold)' : '';
        btn.style.color = viewLocked ? 'var(--dark-bg)' : '';
      }
      showSnapFeedback(viewLocked ? 'View locked - pan/zoom disabled' : 'View unlocked');
    }

    // ===== ROOM =====
    function updateRoom() {
      roomWidth = parseInt(document.getElementById('roomWidth').value) || 20;
      roomDepth = parseInt(document.getElementById('roomDepth').value) || 16;

      if (document.getElementById('scaleMode').value === 'fit') {
        fitToScreen();
      } else {
        updateCanvasSize();
      }

      if (currentView === '3d') {
        init3D();
        render3D();
      }
    }

    // ===== ROOM TEMPLATES =====
    const ROOM_TEMPLATES = {
      'kitchen-l': {
        name: 'L-Shaped Kitchen',
        roomType: 'kitchen',
        width: 12,
        depth: 10,
        elements: [
          // BACK WALL (y=0) - Fridge on left, then cabinets, DW, sink
          // Work Triangle: Fridge (left) -> Sink (center) -> Range (right wall)
          { type: 'refrigerator', x: 0, y: 0, width: 3, height: 2.5, label: 'Fridge' },
          { type: 'base-cabinet', x: 3, y: 0, width: 2, height: 2, label: 'Base' },
          { type: 'dishwasher', x: 5, y: 0, width: 2, height: 2, label: 'DW' },
          { type: 'sink-base', x: 7, y: 0, width: 3, height: 2, label: 'Sink Base' },
          { type: 'base-cabinet', x: 10, y: 0, width: 2, height: 2, label: 'Base' },
          { type: 'countertop', x: 3, y: 0, width: 9, height: 2, label: 'Counter' },
          { type: 'sink', x: 7.5, y: 0.25, width: 2, height: 1.5, label: 'Sink' },
          { type: 'wall-cabinet', x: 3, y: 0, width: 4, height: 1, label: 'Upper' },
          { type: 'wall-cabinet', x: 7, y: 0, width: 3, height: 1, label: 'Upper' },
          { type: 'wall-cabinet', x: 10, y: 0, width: 2, height: 1, label: 'Upper' },

          // RIGHT WALL (x=10) - Range with hood, cabinets
          { type: 'base-cabinet', x: 10, y: 2, width: 2, height: 2, label: 'Base' },
          { type: 'range', x: 10, y: 4, width: 2, height: 2.5, label: 'Range' },
          { type: 'base-cabinet', x: 10, y: 6.5, width: 2, height: 2, label: 'Base' },
          { type: 'countertop', x: 10, y: 2, width: 2, height: 6.5, label: 'Counter' },
          { type: 'range-hood', x: 10, y: 4, width: 2, height: 1, label: 'Hood' },
          { type: 'wall-cabinet', x: 10, y: 2, width: 2, height: 2, label: 'Upper' },
          { type: 'wall-cabinet', x: 10, y: 6.5, width: 2, height: 2, label: 'Upper' },

          // ISLAND in center of room
          { type: 'island', x: 4, y: 5, width: 4, height: 2.5, label: 'Island' },
        ]
      },
      'kitchen-galley': {
        name: 'Galley Kitchen',
        roomType: 'kitchen',
        width: 12,
        depth: 8,
        elements: [
          // BACK WALL (y=0)
          { type: 'base-cabinet', x: 0, y: 0, width: 2, height: 2, label: 'Base' },
          { type: 'dishwasher', x: 2, y: 0, width: 2, height: 2, label: 'DW' },
          { type: 'sink-base', x: 4, y: 0, width: 3, height: 2, label: 'Sink Base' },
          { type: 'base-cabinet', x: 7, y: 0, width: 2, height: 2, label: 'Base' },
          { type: 'range', x: 9, y: 0, width: 3, height: 2.5, label: 'Range' },
          { type: 'countertop', x: 0, y: 0, width: 12, height: 2, label: 'Counter' },
          { type: 'sink', x: 4.5, y: 0.25, width: 2, height: 1.5, label: 'Sink' },
          { type: 'wall-cabinet', x: 0, y: 0, width: 4, height: 1, label: 'Upper' },
          { type: 'wall-cabinet', x: 4, y: 0, width: 3, height: 1, label: 'Upper' },
          { type: 'wall-cabinet', x: 7, y: 0, width: 2, height: 1, label: 'Upper' },
          { type: 'range-hood', x: 9, y: 0, width: 3, height: 1, label: 'Hood' },

          // FRONT WALL (y=6)
          { type: 'refrigerator', x: 0, y: 6, width: 3, height: 2, label: 'Fridge' },
          { type: 'base-cabinet', x: 3, y: 6, width: 3, height: 2, label: 'Base' },
          { type: 'base-cabinet', x: 6, y: 6, width: 3, height: 2, label: 'Base' },
          { type: 'base-cabinet', x: 9, y: 6, width: 3, height: 2, label: 'Base' },
          { type: 'countertop', x: 3, y: 6, width: 9, height: 2, label: 'Counter' },
          { type: 'wall-cabinet', x: 3, y: 6, width: 9, height: 1, label: 'Uppers' },
        ]
      },
      'kitchen-u': {
        name: 'U-Shaped Kitchen',
        roomType: 'kitchen',
        width: 12,
        depth: 10,
        elements: [
          // BACK WALL (y=0)
          { type: 'base-cabinet', x: 0, y: 0, width: 2, height: 2, label: 'Base' },
          { type: 'dishwasher', x: 2, y: 0, width: 2, height: 2, label: 'DW' },
          { type: 'sink-base', x: 4, y: 0, width: 3, height: 2, label: 'Sink Base' },
          { type: 'base-cabinet', x: 7, y: 0, width: 2, height: 2, label: 'Base' },
          { type: 'range', x: 9, y: 0, width: 3, height: 2.5, label: 'Range' },
          { type: 'countertop', x: 0, y: 0, width: 12, height: 2, label: 'Counter' },
          { type: 'sink', x: 4.5, y: 0.25, width: 2, height: 1.5, label: 'Sink' },
          { type: 'wall-cabinet', x: 0, y: 0, width: 4, height: 1, label: 'Upper' },
          { type: 'wall-cabinet', x: 4, y: 0, width: 3, height: 1, label: 'Upper' },
          { type: 'wall-cabinet', x: 7, y: 0, width: 2, height: 1, label: 'Upper' },
          { type: 'range-hood', x: 9, y: 0, width: 3, height: 1, label: 'Hood' },

          // LEFT WALL (x=0)
          { type: 'refrigerator', x: 0, y: 2, width: 2, height: 3, label: 'Fridge' },
          { type: 'base-cabinet', x: 0, y: 5, width: 2, height: 2, label: 'Base' },
          { type: 'base-cabinet', x: 0, y: 7, width: 2, height: 2, label: 'Base' },
          { type: 'countertop', x: 0, y: 5, width: 2, height: 4, label: 'Counter' },
          { type: 'wall-cabinet', x: 0, y: 5, width: 1, height: 4, label: 'Uppers' },

          // RIGHT WALL (x=10)
          { type: 'base-cabinet', x: 10, y: 2, width: 2, height: 2, label: 'Base' },
          { type: 'base-cabinet', x: 10, y: 4, width: 2, height: 2, label: 'Base' },
          { type: 'base-cabinet', x: 10, y: 6, width: 2, height: 2, label: 'Base' },
          { type: 'countertop', x: 10, y: 2, width: 2, height: 6, label: 'Counter' },
          { type: 'wall-cabinet', x: 11, y: 2, width: 1, height: 6, label: 'Uppers' },
        ]
      },
      'bathroom-master': {
        name: 'Master Bathroom',
        roomType: 'bathroom',
        width: 12,
        depth: 10,
        elements: [
          // Double vanity (back wall)
          { type: 'base-cabinet', x: 0, y: 0, width: 2, height: 1.75 },
          { type: 'base-cabinet', x: 2, y: 0, width: 2, height: 1.75 },
          { type: 'base-cabinet', x: 4, y: 0, width: 2, height: 1.75 },
          { type: 'countertop', x: 0, y: 0, width: 6, height: 1.85, color: '#d4a574' },
          { type: 'sink', x: 0.75, y: 0.2, width: 1.5, height: 1.2 },
          { type: 'sink', x: 3.75, y: 0.2, width: 1.5, height: 1.2 },
          // Toilet (right side)
          { type: 'toilet', x: 10, y: 4, width: 1.5, height: 2.3 },
          // Bathtub (left wall, bottom area)
          { type: 'bathtub', x: 0, y: 6, width: 2.7, height: 5, rotation: 90 },
          // Walk-in shower (right corner)
          { type: 'shower-pan', x: 9, y: 0, width: 3, height: 3 },
          { type: 'shower-wall', x: 9, y: 0, width: 0.3, height: 3 },
          { type: 'shower-niche', x: 10, y: 0.5, width: 1.5, height: 0.5 },
          // Linen closet
          { type: 'tall-cabinet', x: 7, y: 0, width: 2, height: 2 },
        ]
      },
      'bathroom-half': {
        name: 'Half Bathroom',
        roomType: 'bathroom',
        width: 6,
        depth: 5,
        elements: [
          // Vanity
          { type: 'base-cabinet', x: 0, y: 0, width: 2.5, height: 1.75 },
          { type: 'countertop', x: 0, y: 0, width: 2.6, height: 1.85, color: '#d4a574' },
          { type: 'sink', x: 0.3, y: 0.2, width: 2, height: 1.3 },
          // Toilet
          { type: 'toilet', x: 4, y: 0.5, width: 1.5, height: 2.3 },
        ]
      },
      'shower-walkin': {
        name: 'Walk-in Shower',
        roomType: 'shower',
        width: 6,
        depth: 5,
        elements: [
          // Shower pan
          { type: 'shower-pan', x: 0, y: 0, width: 6, height: 5 },
          // Shower walls with tile
          { type: 'shower-wall', x: 0, y: 0, width: 0.3, height: 5 },
          { type: 'shower-wall', x: 0, y: 0, width: 6, height: 0.3 },
          { type: 'shower-wall', x: 5.7, y: 0, width: 0.3, height: 5 },
          // Bench
          { type: 'shower-curb', x: 0.5, y: 3.5, width: 2, height: 1.2 },
          // Niches
          { type: 'shower-niche', x: 2, y: 1, width: 2, height: 0.5 },
          { type: 'shower-niche', x: 2, y: 2, width: 2, height: 0.5 },
          // Curb at entry
          { type: 'shower-curb', x: 0, y: 4.7, width: 3, height: 0.3 },
        ]
      },
      'closet-walkin': {
        name: 'Walk-in Closet',
        roomType: 'closet',
        width: 10,
        depth: 8,
        elements: [
          // Left wall - double hang
          { type: 'tall-cabinet', x: 0, y: 0, width: 1.5, height: 3 },
          { type: 'tall-cabinet', x: 0, y: 3, width: 1.5, height: 2.5 },
          { type: 'tall-cabinet', x: 0, y: 5.5, width: 1.5, height: 2.5 },
          // Back wall - shelving and drawers
          { type: 'tall-cabinet', x: 2, y: 6.5, width: 2, height: 1.5 },
          { type: 'drawer-base', x: 4, y: 6.5, width: 2, height: 1.5 },
          { type: 'tall-cabinet', x: 6, y: 6.5, width: 2, height: 1.5 },
          // Right wall - long hang
          { type: 'tall-cabinet', x: 8.5, y: 0, width: 1.5, height: 4 },
          { type: 'tall-cabinet', x: 8.5, y: 4, width: 1.5, height: 4 },
          // Island/bench
          { type: 'island', x: 3.5, y: 2.5, width: 3, height: 2 },
          { type: 'countertop', x: 3.5, y: 2.5, width: 3, height: 2, color: '#8B4513' },
        ]
      },
      'laundry-room': {
        name: 'Laundry Room',
        roomType: 'laundry',
        width: 10,
        depth: 8,
        elements: [
          // Washer and dryer
          { type: 'dishwasher', x: 0, y: 0, width: 2.3, height: 2.3, label: 'Washer' },
          { type: 'dishwasher', x: 2.5, y: 0, width: 2.3, height: 2.3, label: 'Dryer' },
          // Upper cabinets above W/D
          { type: 'wall-cabinet', x: 0, y: 0, width: 2.5, height: 1 },
          { type: 'wall-cabinet', x: 2.5, y: 0, width: 2.5, height: 1 },
          // Utility sink area
          { type: 'base-cabinet', x: 5.5, y: 0, width: 2, height: 2 },
          { type: 'sink-base', x: 7.5, y: 0, width: 2.5, height: 2 },
          { type: 'countertop', x: 5.5, y: 0, width: 4.5, height: 2.1, color: '#708090' },
          { type: 'sink', x: 7.75, y: 0.25, width: 2, height: 1.5 },
          // Folding counter on opposite wall
          { type: 'base-cabinet', x: 0, y: 6, width: 2, height: 2 },
          { type: 'base-cabinet', x: 2, y: 6, width: 2, height: 2 },
          { type: 'base-cabinet', x: 4, y: 6, width: 2, height: 2 },
          { type: 'countertop', x: 0, y: 6, width: 6, height: 2.1, color: '#708090' },
          // Wall cabinets
          { type: 'wall-cabinet', x: 0, y: 6, width: 2, height: 1 },
          { type: 'wall-cabinet', x: 2, y: 6, width: 2, height: 1 },
          { type: 'wall-cabinet', x: 4, y: 6, width: 2, height: 1 },
          // Tall storage
          { type: 'tall-cabinet', x: 8, y: 6, width: 2, height: 2 },
        ]
      }
    };

    function loadRoomTemplate(templateId) {
      const template = ROOM_TEMPLATES[templateId];
      if (!template) {
        showToast('Template not found', 'error');
        return;
      }

      // Confirm before clearing
      if (elements.length > 0) {
        if (!confirm(`Load "${template.name}" template? This will replace your current design.`)) {
          return;
        }
      }

      // Clear current elements
      elements.length = 0;
      selectedElement = null;

      // Set room dimensions FIRST
      roomWidth = template.width;
      roomDepth = template.depth;
      document.getElementById('roomWidth').value = roomWidth;
      document.getElementById('roomDepth').value = roomDepth;
      document.getElementById('roomType').value = template.roomType;

      // IMPORTANT: Fit to screen BEFORE adding elements
      // This sets pixelsPerFoot correctly for the new room size
      // Elements will use this scale when converting feet to pixels
      fitToScreen();

      // Add template elements (using the correct pixelsPerFoot set by fitToScreen)
      template.elements.forEach(elDef => {
        const el = {
          id: Date.now() + Math.random(),
          type: elDef.type,
          x: elDef.x * pixelsPerFoot,
          y: elDef.y * pixelsPerFoot,
          width: elDef.width,
          height: elDef.height,
          rotation: elDef.rotation || 0,
          color: elDef.color || getDefaultColor(elDef.type),
          category: getElementCategory(elDef.type),
          label: elDef.label || null
        };
        elements.push(el);
      });

      // Update everything (no need to call fitToScreen again)
      saveUndoState();
      updateProperties();
      updateElementList();
      updateItemPicker();
      draw();

      if (currentView === '3d') {
        init3D();
        render3D();
      }

      showToast(`Loaded "${template.name}" template`, 'success');
    }

    function getDefaultColor(type) {
      const colors = {
        'base-cabinet': '#8B7355',
        'wall-cabinet': '#8B7355',
        'tall-cabinet': '#8B7355',
        'fridge-cabinet': '#8B7355',
        'corner-cabinet': '#8B7355',
        'island': '#8B7355',
        'drawer-base': '#8B7355',
        'sink-base': '#8B7355',
        'countertop': '#708090',
        'backsplash': '#A0A0A0',
        'flooring': '#D2B48C',
        'tile': '#E8E8E8',
        'shower-pan': '#D0D0D0',
        'shower-wall': '#E0E0E0',
        'shower-curb': '#808080',
        'bathtub': '#F5F5F5',
        'toilet': '#FFFFFF',
        'sink': '#E8E8E8',
        'refrigerator': '#C0C0C0',
        'range': '#404040',
        'stove': '#404040',
        'dishwasher': '#C0C0C0',
        'range-hood': '#808080',
        'wall': '#E0D5C5',
        'window': '#87CEEB',
        'door': '#8B4513'
      };
      return colors[type] || '#808080';
    }

    function updateRoomHeight() {
      roomHeight = parseInt(document.getElementById('roomHeight').value) || 8;
      if (currentView === '3d') {
        init3D();
        render3D();
      }
    }

    // ===== CABINET SETTINGS =====
    function updateCabinetSettings() {
      // Get values from dropdowns
      cabinetSettings.construction = document.getElementById('cabinetConstruction').value;
      cabinetSettings.doorStyle = document.getElementById('doorStyle').value;
      cabinetSettings.doorOverlay = document.getElementById('doorOverlay').value;

      // Cabinet types that use these settings
      const cabinetTypes = ['base-cabinet', 'wall-cabinet', 'tall-cabinet', 'corner-cabinet',
                           'drawer-base', 'sink-base', 'lazy-susan', 'island'];

      // Update any selected cabinet element with new settings
      if (selectedElement && cabinetTypes.includes(selectedElement.type)) {
        selectedElement.construction = cabinetSettings.construction;
        selectedElement.doorStyle = cabinetSettings.doorStyle;
        selectedElement.doorOverlay = cabinetSettings.doorOverlay;

        // Redraw - must reinitialize 3D to rebuild geometry
        if (currentView === '2d') {
          draw();
        } else {
          init3D(); // Rebuild 3D scene with new cabinet settings
        }
        saveUndoState();
      }

      // Show toast with current settings
      const constructionLabel = cabinetSettings.construction === 'frameless' ? 'Frameless (Euro)' : 'Framed (Face Frame)';
      showToast(`Cabinet settings: ${constructionLabel}, ${cabinetSettings.doorStyle} style`);
    }

    function updateFloorLevel() {
      const floorSelect = document.getElementById('floorLevel');
      const value = floorSelect.value;

      if (value === 'add') {
        // Add new floor
        const newFloorNum = cabinetSettings.floors.length + 1;
        const newFloor = {
          id: newFloorNum,
          name: `Floor ${newFloorNum}`,
          height: (newFloorNum - 1) * 10 // 10 feet per floor
        };
        cabinetSettings.floors.push(newFloor);

        // Add new option to dropdown
        const newOption = document.createElement('option');
        newOption.value = newFloorNum;
        newOption.textContent = `Floor ${newFloorNum}`;
        floorSelect.insertBefore(newOption, floorSelect.lastElementChild);

        // Select the new floor
        floorSelect.value = newFloorNum;
        cabinetSettings.currentFloor = newFloorNum;

        showToast(`Added Floor ${newFloorNum}`);
      } else {
        // Switch to selected floor
        cabinetSettings.currentFloor = parseInt(value);
        showToast(`Switched to Floor ${value}`);
      }

      // Filter elements to show only current floor
      updateFloorVisibility();

      if (currentView === '2d') {
        draw();
      } else {
        render3D();
      }
    }

    function updateTimeOfDay() {
      const timeSelect = document.getElementById('timeOfDay');
      sceneSettings.timeOfDay = timeSelect.value;

      // Lighting presets matching init3D - balanced for color accuracy
      const lightingPresets = {
        morning: {
          bg: 0xFFF8E7,
          ambient: { color: 0xFFF8F0, intensity: 0.35 },
          hemisphere: { sky: 0xFFE4C4, ground: 0x8B7355, intensity: 0.25 },
          sun: { color: 0xFFE4B5, intensity: 0.6, pos: [25, 12, 15] },
          fill: { intensity: 0.2 },
          exposure: 0.9
        },
        noon: {
          bg: 0xF5F8FA,
          ambient: { color: 0xFFFFFF, intensity: 0.4 },
          hemisphere: { sky: 0xE0F0FF, ground: 0x8B7355, intensity: 0.3 },
          sun: { color: 0xFFFFF8, intensity: 0.7, pos: [15, 25, 15] },
          fill: { intensity: 0.25 },
          exposure: 0.95
        },
        evening: {
          bg: 0xFFE8D6,
          ambient: { color: 0xFFE0C0, intensity: 0.3 },
          hemisphere: { sky: 0xFFA07A, ground: 0x6B4423, intensity: 0.2 },
          sun: { color: 0xFF8C00, intensity: 0.5, pos: [-20, 8, 10] },
          fill: { intensity: 0.25 },
          exposure: 0.85
        },
        night: {
          bg: 0x1E2A3A,
          ambient: { color: 0xC0C8D8, intensity: 0.25 },
          hemisphere: { sky: 0x4169E1, ground: 0x2F3F4F, intensity: 0.15 },
          sun: { color: 0xB0C4DE, intensity: 0.15, pos: [-15, 20, 10] },
          fill: { intensity: 0.35 }, // Interior lights
          exposure: 0.75
        }
      };

      if (scene && renderer) {
        const preset = lightingPresets[sceneSettings.timeOfDay] || lightingPresets.noon;

        // Update renderer exposure
        renderer.toneMappingExposure = preset.exposure;

        // Update scene background
        scene.background = new THREE.Color(preset.bg);

        // Update lights by name
        scene.traverse(obj => {
          if (obj.name === 'ambientLight' && obj.isAmbientLight) {
            obj.color.setHex(preset.ambient.color);
            obj.intensity = preset.ambient.intensity;
          }
          if (obj.name === 'hemisphereLight' && obj.isHemisphereLight) {
            obj.color.setHex(preset.hemisphere.sky);
            obj.groundColor.setHex(preset.hemisphere.ground);
            obj.intensity = preset.hemisphere.intensity;
          }
          if (obj.name === 'sunLight' && obj.isDirectionalLight) {
            obj.position.set(...preset.sun.pos);
            obj.color.setHex(preset.sun.color);
            obj.intensity = preset.sun.intensity;
          }
          if (obj.name === 'fillLight' && obj.isDirectionalLight) {
            obj.intensity = preset.fill.intensity;
          }
          // Surface lights stay constant for texture visibility
        });

        // Re-render to show changes
        render3D();
      }

      const timeLabels = {
        morning: 'Morning (Golden Hour)',
        noon: 'Noon (Bright Daylight)',
        evening: 'Evening (Sunset)',
        night: 'Night (Interior Lights)'
      };
      showToast(`Time of day: ${timeLabels[sceneSettings.timeOfDay]}`);
    }

    function updateFloorVisibility() {
      // Mark elements with their floor level if not set
      elements.forEach(el => {
        if (!el.floorLevel) {
          el.floorLevel = 1; // Default to floor 1
        }
      });
    }

    function getElementsForCurrentFloor() {
      return elements.filter(el => !el.floorLevel || el.floorLevel === cabinetSettings.currentFloor);
    }

    // ===== PROPERTIES =====
    function updateProperties() {
      const empty = document.getElementById('propertiesEmpty');
      const content = document.getElementById('propertiesContent');

      if (selectedElement) {
        empty.style.display = 'none';
        content.style.display = 'block';

        document.getElementById('propType').textContent = selectedElement.label;
        // Show decimal value in input, formatted display beside it
        document.getElementById('propWidth').value = selectedElement.width.toFixed(4).replace(/\.?0+$/, '');
        document.getElementById('propHeight').value = selectedElement.height.toFixed(4).replace(/\.?0+$/, '');
        // Show formatted feet-inches display
        const widthDisplay = document.getElementById('propWidthDisplay');
        const heightDisplay = document.getElementById('propHeightDisplay');
        if (widthDisplay) widthDisplay.textContent = formatDimension(selectedElement.width);
        if (heightDisplay) heightDisplay.textContent = formatDimension(selectedElement.height);

        document.getElementById('propColor').value = selectedElement.color;
        document.getElementById('propRotation').textContent = (selectedElement.rotation || 0) + 'Â°';

        const texturePreview = document.getElementById('propTexture');
        if (selectedElement.texture) {
          texturePreview.style.background = `url(${selectedElement.texture}) center/cover`;
        } else {
          texturePreview.style.background = selectedElement.color;
        }

        // Populate standard sizes dropdown
        const standardSizeRow = document.getElementById('standardSizeRow');
        const standardSizeSelect = document.getElementById('propStandardSize');
        const standardSizes = getStandardSizesForType(selectedElement.type);

        if (standardSizes.length > 0) {
          standardSizeRow.style.display = 'flex';
          standardSizeSelect.innerHTML = '<option value="">Custom</option>' +
            standardSizes.map(s => `<option value="${s.width}x${s.height}">${s.label}</option>`).join('');
        } else {
          standardSizeRow.style.display = 'none';
        }

        // Countertop-specific properties (edge profile, backsplash, finished ends)
        const isCountertop = selectedElement.type === 'countertop';
        const edgeProfileRow = document.getElementById('edgeProfileRow');
        const backsplashRow = document.getElementById('backsplashRow');
        const finishedEndsRow = document.getElementById('finishedEndsRow');

        if (edgeProfileRow) {
          edgeProfileRow.style.display = isCountertop ? 'flex' : 'none';
          if (isCountertop) {
            document.getElementById('propEdgeProfile').value = selectedElement.edgeProfile || 'eased';
          }
        }

        if (backsplashRow) {
          backsplashRow.style.display = isCountertop ? 'flex' : 'none';
          if (isCountertop) {
            const bs = selectedElement.backsplash;
            if (!bs) {
              document.getElementById('propBacksplash').value = 'none';
            } else if (bs.type === 'full') {
              document.getElementById('propBacksplash').value = 'full';
            } else {
              document.getElementById('propBacksplash').value = bs.height.toString();
            }
          }
        }

        if (finishedEndsRow) {
          finishedEndsRow.style.display = isCountertop ? 'flex' : 'none';
          if (isCountertop) {
            const ends = selectedElement.finishedEnds || [];
            document.getElementById('propFinishedLeft').checked = ends.includes('left');
            document.getElementById('propFinishedRight').checked = ends.includes('right');
          }
        }

        // Thickness row for countertops (2cm vs 3cm)
        const thicknessRow = document.getElementById('thicknessRow');
        const edgeStyleRow = document.getElementById('edgeStyleRow');
        if (thicknessRow) {
          thicknessRow.style.display = isCountertop ? 'flex' : 'none';
          if (isCountertop) {
            const thickness = selectedElement.thickness || '3cm';
            document.getElementById('propThickness').value = thickness;

            // Show edge style row only for 2cm
            if (edgeStyleRow) {
              edgeStyleRow.style.display = thickness === '2cm' ? 'flex' : 'none';
              if (thickness === '2cm') {
                document.getElementById('propEdgeStyle').value = selectedElement.edgeBuildStyle || 'laminated';
              }
            }
          }
        }

        // Waterfall rows for countertops (only show when waterfall edge profile is selected)
        const waterfallRow = document.getElementById('waterfallRow');
        const waterfallHeightRow = document.getElementById('waterfallHeightRow');
        const edgeProfile = selectedElement.edgeProfile || 'eased';
        const isWaterfall = isCountertop && edgeProfile === 'waterfall';

        if (waterfallRow) {
          waterfallRow.style.display = isWaterfall ? 'flex' : 'none';
          if (isWaterfall) {
            // Populate waterfall side checkboxes
            const sides = selectedElement.waterfallSides || [];
            const leftCb = document.getElementById('propWaterfallLeft');
            const rightCb = document.getElementById('propWaterfallRight');
            const frontCb = document.getElementById('propWaterfallFront');
            const backCb = document.getElementById('propWaterfallBack');
            if (leftCb) leftCb.checked = sides.includes('left');
            if (rightCb) rightCb.checked = sides.includes('right');
            if (frontCb) frontCb.checked = sides.includes('front');
            if (backCb) backCb.checked = sides.includes('back');
          }
        }

        if (waterfallHeightRow) {
          const hasWaterfallSides = selectedElement.waterfallSides && selectedElement.waterfallSides.length > 0;
          waterfallHeightRow.style.display = (isWaterfall && hasWaterfallSides) ? 'flex' : 'none';
          if (isWaterfall && hasWaterfallSides) {
            const dropHeight = selectedElement.waterfallHeight || 3;
            const heightSelect = document.getElementById('propWaterfallHeight');
            if (heightSelect) {
              if (dropHeight === 'floor') {
                heightSelect.value = 'floor';
              } else if ([2.5, 2.9, 3].includes(dropHeight)) {
                heightSelect.value = dropHeight.toString();
              } else {
                heightSelect.value = 'custom';
              }
            }
          }
        }

        // Seams row for countertops
        const seamsRow = document.getElementById('seamsRow');
        if (seamsRow) {
          seamsRow.style.display = isCountertop ? 'flex' : 'none';
          if (isCountertop) {
            const seamCount = selectedElement.seams ? selectedElement.seams.length : 0;
            document.getElementById('seamCount').textContent = seamCount + (seamCount === 1 ? ' seam' : ' seams');
          }
        }

        // Sink-specific properties (color, mount type)
        const isSink = selectedElement.type.startsWith('sink');
        const sinkColorRow = document.getElementById('sinkColorRow');
        const sinkMountRow = document.getElementById('sinkMountRow');

        if (sinkColorRow) {
          sinkColorRow.style.display = isSink ? 'flex' : 'none';
          if (isSink) {
            document.getElementById('propSinkColor').value = selectedElement.sinkColor || 'stainless';
          }
        }

        if (sinkMountRow) {
          sinkMountRow.style.display = isSink ? 'flex' : 'none';
          if (isSink) {
            // Default mount based on sink type
            let defaultMount = 'undermount';
            if (selectedElement.type === 'sink-farmhouse') defaultMount = 'farmhouse';
            document.getElementById('propSinkMount').value = selectedElement.mountType || defaultMount;
          }
        }

        // Window/Door sill height (height from floor)
        const windowDoorTypes = ['window', 'sliding-door', 'french-door', 'glass-door', 'bay-window', 'picture-window'];
        const isWindowOrDoor = windowDoorTypes.includes(selectedElement.type);
        const sillHeightRow = document.getElementById('sillHeightRow');
        const customSillRow = document.getElementById('customSillRow');

        if (sillHeightRow) {
          sillHeightRow.style.display = isWindowOrDoor ? 'flex' : 'none';
          if (isWindowOrDoor) {
            const sillHeight = selectedElement.sillHeight !== undefined ? selectedElement.sillHeight : getDefaultSillHeight(selectedElement.type);
            const select = document.getElementById('propSillHeight');

            // Check if it matches a preset
            const presets = [0, 2, 3, 3.5, 4];
            const matchesPreset = presets.some(p => Math.abs(sillHeight - p) < 0.05);

            if (matchesPreset) {
              select.value = presets.find(p => Math.abs(sillHeight - p) < 0.05).toString();
              if (customSillRow) customSillRow.style.display = 'none';
            } else {
              select.value = 'custom';
              if (customSillRow) {
                customSillRow.style.display = 'flex';
                document.getElementById('propCustomSill').value = sillHeight.toFixed(2);
              }
            }
          }
        }
        if (customSillRow && !isWindowOrDoor) {
          customSillRow.style.display = 'none';
        }

        // Door/Archway height controls
        const doorTypes = ['door', 'double-door', 'sliding-door', 'french-door', 'glass-door', 'entry-archway', 'garage-door'];
        const isDoor = doorTypes.includes(selectedElement.type);
        const isArchway = selectedElement.type === 'entry-archway';
        const doorHeightRow = document.getElementById('doorHeightRow');
        const customDoorHeightRow = document.getElementById('customDoorHeightRow');
        const archwayStyleRow = document.getElementById('archwayStyleRow');

        if (doorHeightRow) {
          doorHeightRow.style.display = isDoor ? 'flex' : 'none';
          if (isDoor) {
            const doorHeight = selectedElement.height3D !== undefined ? selectedElement.height3D : 6.8;
            const select = document.getElementById('propDoorHeight');

            // Check if it matches a preset
            const presets = [6.67, 6.83, 7, 8, 9, 10];
            const matchesPreset = presets.some(p => Math.abs(doorHeight - p) < 0.05);

            if (matchesPreset) {
              select.value = presets.find(p => Math.abs(doorHeight - p) < 0.05).toString();
              if (customDoorHeightRow) customDoorHeightRow.style.display = 'none';
            } else {
              select.value = 'custom';
              if (customDoorHeightRow) {
                customDoorHeightRow.style.display = 'flex';
                document.getElementById('propCustomDoorHeight').value = doorHeight.toFixed(2);
                document.getElementById('propDoorHeightDisplay').textContent = formatDimension(doorHeight);
              }
            }
          }
        }
        if (customDoorHeightRow && !isDoor) {
          customDoorHeightRow.style.display = 'none';
        }

        // Archway style (only for archways)
        if (archwayStyleRow) {
          archwayStyleRow.style.display = isArchway ? 'flex' : 'none';
          if (isArchway) {
            document.getElementById('propArchwayStyle').value = selectedElement.archwayStyle || 'round';
          }
        }

        // Window style and mullion pattern (only for windows)
        const windowTypes = ['window', 'window-large', 'window-bay', 'bay-window', 'picture-window'];
        const isWindow = windowTypes.includes(selectedElement.type);
        const windowStyleRow = document.getElementById('windowStyleRow');
        const mullionPatternRow = document.getElementById('mullionPatternRow');

        if (windowStyleRow) {
          windowStyleRow.style.display = isWindow ? 'flex' : 'none';
          if (isWindow) {
            document.getElementById('propWindowStyle').value = selectedElement.windowStyle || 'double-hung';
          }
        }

        if (mullionPatternRow) {
          mullionPatternRow.style.display = isWindow ? 'flex' : 'none';
          if (isWindow) {
            document.getElementById('propMullionPattern').value = selectedElement.mullionPattern || 'standard';
          }
        }

        // Pony wall / half wall height controls
        const ponyWallTypes = ['pony-wall', 'pony-wall-bar', 'knee-wall'];
        const isPonyWall = ponyWallTypes.includes(selectedElement.type);
        const wallHeightRow = document.getElementById('wallHeightRow');
        const customWallHeightRow = document.getElementById('customWallHeightRow');

        if (wallHeightRow) {
          wallHeightRow.style.display = isPonyWall ? 'flex' : 'none';
          if (isPonyWall) {
            const wallHeight = selectedElement.wallHeight !== undefined ? selectedElement.wallHeight : 3.5;
            const select = document.getElementById('propWallHeight');

            // Check if it matches a preset
            const presets = [2, 2.5, 3, 3.5, 4];
            const matchesPreset = presets.some(p => Math.abs(wallHeight - p) < 0.05);

            if (matchesPreset) {
              select.value = presets.find(p => Math.abs(wallHeight - p) < 0.05).toString();
              if (customWallHeightRow) customWallHeightRow.style.display = 'none';
            } else {
              select.value = 'custom';
              if (customWallHeightRow) {
                customWallHeightRow.style.display = 'flex';
                document.getElementById('propCustomWallHeight').value = wallHeight.toFixed(2);
                document.getElementById('propWallHeightDisplay').textContent = formatDimension(wallHeight);
              }
            }
          }
        }
        if (customWallHeightRow && !isPonyWall) {
          customWallHeightRow.style.display = 'none';
        }

        // Niche depth controls
        const nicheTypes = ['wall-niche', 'fireplace-niche', 'tv-niche', 'shower-niche'];
        const isNiche = nicheTypes.includes(selectedElement.type);
        const nicheDepthRow = document.getElementById('nicheDepthRow');
        const customNicheDepthRow = document.getElementById('customNicheDepthRow');

        if (nicheDepthRow) {
          nicheDepthRow.style.display = isNiche ? 'flex' : 'none';
          if (isNiche) {
            const nicheDepth = selectedElement.nicheDepth !== undefined ? selectedElement.nicheDepth : 0.33;
            const select = document.getElementById('propNicheDepth');

            // Check if it matches a preset
            const presets = [0.25, 0.33, 0.5, 0.67, 1, 1.5];
            const matchesPreset = presets.some(p => Math.abs(nicheDepth - p) < 0.05);

            if (matchesPreset) {
              select.value = presets.find(p => Math.abs(nicheDepth - p) < 0.05).toString();
              if (customNicheDepthRow) customNicheDepthRow.style.display = 'none';
            } else {
              select.value = 'custom';
              if (customNicheDepthRow) {
                customNicheDepthRow.style.display = 'flex';
                document.getElementById('propCustomNicheDepth').value = nicheDepth.toFixed(2);
                document.getElementById('propNicheDepthDisplay').textContent = formatDimension(nicheDepth);
              }
            }
          }
        }
        if (customNicheDepthRow && !isNiche) {
          customNicheDepthRow.style.display = 'none';
        }

        // Stone surface thickness controls
        const stoneSurfaceTypes = ['wall-cap', 'bar-top', 'niche-surround', 'fireplace-surround', 'fireplace-hearth', 'mantel', 'window-sill', 'threshold'];
        const isStoneSurface = stoneSurfaceTypes.includes(selectedElement.type);
        const stoneThicknessRow = document.getElementById('stoneThicknessRow');

        if (stoneThicknessRow) {
          stoneThicknessRow.style.display = isStoneSurface ? 'flex' : 'none';
          if (isStoneSurface) {
            const thickness = selectedElement.stoneThickness !== undefined ? selectedElement.stoneThickness : 0.1;
            const select = document.getElementById('propStoneThickness');
            // Find closest preset
            const presets = [0.0625, 0.1, 0.125, 0.17, 0.25];
            const closestPreset = presets.reduce((prev, curr) =>
              Math.abs(curr - thickness) < Math.abs(prev - thickness) ? curr : prev
            );
            select.value = closestPreset.toString();
          }
        }

        // Cap height control for wall caps and bar tops
        const capTypes = ['wall-cap', 'bar-top'];
        const isCapElement = capTypes.includes(selectedElement.type);
        const capHeightRow = document.getElementById('capHeightRow');
        const customCapHeightRow = document.getElementById('customCapHeightRow');
        const edgePreviewBtnRow = document.getElementById('edgePreviewBtnRow');

        if (capHeightRow) {
          capHeightRow.style.display = isCapElement ? 'flex' : 'none';
          if (isCapElement) {
            const capHeight = selectedElement.capHeight !== undefined ? selectedElement.capHeight : 3.5;
            const select = document.getElementById('propCapHeight');
            const presets = [2, 2.5, 3, 3.5, 4];
            const matchesPreset = presets.some(p => Math.abs(capHeight - p) < 0.05);

            if (matchesPreset) {
              select.value = presets.find(p => Math.abs(capHeight - p) < 0.05).toString();
              if (customCapHeightRow) customCapHeightRow.style.display = 'none';
            } else {
              select.value = 'custom';
              if (customCapHeightRow) {
                customCapHeightRow.style.display = 'flex';
                document.getElementById('propCustomCapHeight').value = capHeight.toFixed(2);
                document.getElementById('propCapHeightDisplay').textContent = formatDimension(capHeight);
              }
            }
          }
        }
        if (customCapHeightRow && !isCapElement) customCapHeightRow.style.display = 'none';

        // Edge preview button for countertops and stone surfaces
        if (edgePreviewBtnRow) {
          const showEdgeBtn = selectedElement.type === 'countertop' || isStoneSurface;
          edgePreviewBtnRow.style.display = showEdgeBtn ? 'flex' : 'none';
        }

        // Flooring/tile grain direction controls
        const flooringTypes = ['flooring', 'tile', 'hardwood', 'laminate', 'vinyl', 'carpet'];
        const isFlooring = flooringTypes.includes(selectedElement.type);
        const grainDirectionRow = document.getElementById('grainDirectionRow');

        if (grainDirectionRow) {
          grainDirectionRow.style.display = isFlooring ? 'flex' : 'none';
          if (isFlooring) {
            const grainDir = selectedElement.grainDirection || 0;
            // Update button states
            document.querySelectorAll('.grain-btn').forEach(btn => {
              btn.classList.toggle('active', parseInt(btn.dataset.dir) === grainDir);
            });
          }
        }

        // Structural element controls (beams and columns)
        const beamTypes = ['steel-beam', 'wood-beam', 'concrete-beam', 'header', 'lvl-beam'];
        const columnTypes = ['steel-column', 'wood-post', 'concrete-column'];
        const isBeam = beamTypes.includes(selectedElement.type);
        const isColumn = columnTypes.includes(selectedElement.type);

        const beamDepthRow = document.getElementById('beamDepthRow');
        const customBeamDepthRow = document.getElementById('customBeamDepthRow');
        const beamElevationRow = document.getElementById('beamElevationRow');
        const customBeamElevationRow = document.getElementById('customBeamElevationRow');
        const columnHeightRow = document.getElementById('columnHeightRow');
        const customColumnHeightRow = document.getElementById('customColumnHeightRow');
        const columnSizeRow = document.getElementById('columnSizeRow');

        // Beam depth control
        if (beamDepthRow) {
          beamDepthRow.style.display = isBeam ? 'flex' : 'none';
          if (isBeam) {
            const beamDepth = selectedElement.beamDepth !== undefined ? selectedElement.beamDepth : getDefaultBeamDepth(selectedElement.type);
            const select = document.getElementById('propBeamDepth');
            const presets = [0.33, 0.5, 0.67, 0.83, 1, 1.17];
            const matchesPreset = presets.some(p => Math.abs(beamDepth - p) < 0.02);

            if (matchesPreset) {
              select.value = presets.find(p => Math.abs(beamDepth - p) < 0.02).toString();
              if (customBeamDepthRow) customBeamDepthRow.style.display = 'none';
            } else {
              select.value = 'custom';
              if (customBeamDepthRow) {
                customBeamDepthRow.style.display = 'flex';
                document.getElementById('propCustomBeamDepth').value = beamDepth.toFixed(2);
                document.getElementById('propBeamDepthDisplay').textContent = formatDimension(beamDepth);
              }
            }
          }
        }
        if (customBeamDepthRow && !isBeam) customBeamDepthRow.style.display = 'none';

        // Beam elevation control
        if (beamElevationRow) {
          beamElevationRow.style.display = isBeam ? 'flex' : 'none';
          if (isBeam) {
            const beamElevation = selectedElement.beamElevation;
            const select = document.getElementById('propBeamElevation');

            if (beamElevation === undefined) {
              select.value = 'ceiling';
              if (customBeamElevationRow) customBeamElevationRow.style.display = 'none';
            } else {
              const presets = [7, 7.5, 8, 9, 10];
              const matchesPreset = presets.some(p => Math.abs(beamElevation - p) < 0.05);

              if (matchesPreset) {
                select.value = presets.find(p => Math.abs(beamElevation - p) < 0.05).toString();
                if (customBeamElevationRow) customBeamElevationRow.style.display = 'none';
              } else {
                select.value = 'custom';
                if (customBeamElevationRow) {
                  customBeamElevationRow.style.display = 'flex';
                  document.getElementById('propCustomBeamElevation').value = beamElevation.toFixed(2);
                  document.getElementById('propBeamElevationDisplay').textContent = formatDimension(beamElevation);
                }
              }
            }
          }
        }
        if (customBeamElevationRow && !isBeam) customBeamElevationRow.style.display = 'none';

        // Column height control
        if (columnHeightRow) {
          columnHeightRow.style.display = isColumn ? 'flex' : 'none';
          if (isColumn) {
            const columnHeight = selectedElement.columnHeight;
            const select = document.getElementById('propColumnHeight');

            if (columnHeight === undefined) {
              select.value = 'ceiling';
              if (customColumnHeightRow) customColumnHeightRow.style.display = 'none';
            } else {
              const presets = [8, 9, 10, 12];
              const matchesPreset = presets.some(p => Math.abs(columnHeight - p) < 0.05);

              if (matchesPreset) {
                select.value = presets.find(p => Math.abs(columnHeight - p) < 0.05).toString();
                if (customColumnHeightRow) customColumnHeightRow.style.display = 'none';
              } else {
                select.value = 'custom';
                if (customColumnHeightRow) {
                  customColumnHeightRow.style.display = 'flex';
                  document.getElementById('propCustomColumnHeight').value = columnHeight.toFixed(2);
                  document.getElementById('propColumnHeightDisplay').textContent = formatDimension(columnHeight);
                }
              }
            }
          }
        }
        if (customColumnHeightRow && !isColumn) customColumnHeightRow.style.display = 'none';

        // Column size control
        if (columnSizeRow) {
          columnSizeRow.style.display = isColumn ? 'flex' : 'none';
          if (isColumn) {
            const colSize = selectedElement.width || 0.5;
            const select = document.getElementById('propColumnSize');
            const presets = [0.33, 0.5, 0.67, 1, 1.33];
            const matchesPreset = presets.some(p => Math.abs(colSize - p) < 0.02);

            if (matchesPreset) {
              select.value = presets.find(p => Math.abs(colSize - p) < 0.02).toString();
            } else {
              select.value = 'custom';
            }
          }
        }

        // Full-height wall controls (walls, masonry, concrete, etc.)
        const fullWallTypes = ['wall', 'wall-block', 'wall-concrete', 'wall-framed', 'wall-wood-2x4', 'wall-wood-2x6', 'wall-brick', 'wall-steel', 'wall-aluminum'];
        const isFullWall = fullWallTypes.includes(selectedElement.type);
        const fullWallHeightRow = document.getElementById('fullWallHeightRow');
        const customFullWallHeightRow = document.getElementById('customFullWallHeightRow');
        const wallThicknessRow = document.getElementById('wallThicknessRow');
        const customWallThicknessRow = document.getElementById('customWallThicknessRow');

        // Full wall height control
        if (fullWallHeightRow) {
          fullWallHeightRow.style.display = isFullWall ? 'flex' : 'none';
          if (isFullWall) {
            const wallHeight = selectedElement.wallHeight;
            const select = document.getElementById('propFullWallHeight');

            if (wallHeight === undefined) {
              select.value = 'ceiling';
              if (customFullWallHeightRow) customFullWallHeightRow.style.display = 'none';
            } else {
              const presets = [8, 9, 10, 12, 14, 16];
              const matchesPreset = presets.some(p => Math.abs(wallHeight - p) < 0.05);

              if (matchesPreset) {
                select.value = presets.find(p => Math.abs(wallHeight - p) < 0.05).toString();
                if (customFullWallHeightRow) customFullWallHeightRow.style.display = 'none';
              } else {
                select.value = 'custom';
                if (customFullWallHeightRow) {
                  customFullWallHeightRow.style.display = 'flex';
                  document.getElementById('propCustomFullWallHeight').value = wallHeight.toFixed(2);
                  document.getElementById('propFullWallHeightDisplay').textContent = formatDimension(wallHeight);
                }
              }
            }
          }
        }
        if (customFullWallHeightRow && !isFullWall) customFullWallHeightRow.style.display = 'none';

        // Wall thickness control
        if (wallThicknessRow) {
          wallThicknessRow.style.display = isFullWall ? 'flex' : 'none';
          if (isFullWall) {
            const thickness = selectedElement.height || 0.5; // In 2D, 'height' is the depth/thickness
            const select = document.getElementById('propWallThickness');
            const presets = [0.33, 0.5, 0.67, 0.83, 1, 1.33];
            const matchesPreset = presets.some(p => Math.abs(thickness - p) < 0.02);

            if (matchesPreset) {
              select.value = presets.find(p => Math.abs(thickness - p) < 0.02).toString();
              if (customWallThicknessRow) customWallThicknessRow.style.display = 'none';
            } else {
              select.value = 'custom';
              if (customWallThicknessRow) {
                customWallThicknessRow.style.display = 'flex';
                document.getElementById('propCustomWallThickness').value = thickness.toFixed(2);
                document.getElementById('propWallThicknessDisplay').textContent = formatDimension(thickness);
              }
            }
          }
        }
        if (customWallThicknessRow && !isFullWall) customWallThicknessRow.style.display = 'none';

        // Update pricing section
        const pricingSection = document.getElementById('pricingSection');
        if (pricingSection && checkPermission('canViewPrices')) {
          pricingSection.style.display = 'block';

          const priceInfo = getElementPrice(selectedElement);
          document.getElementById('propBasePrice').textContent = '$' + priceInfo.price.toFixed(2);
          document.getElementById('propPriceOverride').value = selectedElement.priceOverride || '';
          document.getElementById('propPriceUnit').value = selectedElement.priceUnit || 'sqft';
          document.getElementById('propMargin').value = selectedElement.marginPercent !== null ? selectedElement.marginPercent : '';

          // Calculate and show item total
          const margin = getElementMargin(selectedElement);
          let quantity = 1;
          if (['countertop', 'backsplash', 'flooring', 'tile'].includes(selectedElement.type)) {
            quantity = selectedElement.width * selectedElement.height;
          }
          const cost = priceInfo.price * quantity;
          const retail = cost * (1 + margin / 100);
          document.getElementById('propItemTotal').textContent = '$' + retail.toFixed(2);
        } else if (pricingSection) {
          pricingSection.style.display = 'none';
        }
      } else {
        empty.style.display = 'block';
        content.style.display = 'none';
      }
    }

    function updateSelectedElement() {
      if (!selectedElement || selectedElement.locked) return;

      // Parse dimension input (accepts feet-inches like 3'-6" or decimal 2.5)
      const widthInput = document.getElementById('propWidth').value;
      const heightInput = document.getElementById('propHeight').value;

      selectedElement.width = roundToSixteenth(parseDimension(widthInput)) || 1;
      selectedElement.height = roundToSixteenth(parseDimension(heightInput)) || 1;
      selectedElement.color = document.getElementById('propColor').value;

      // Update display with formatted dimensions
      updateProperties();
      draw();
    }

    // Set grain/tile direction for flooring
    function setGrainDirection(angle) {
      if (!selectedElement || selectedElement.locked) return;

      const isFlooringType = ['flooring', 'tile', 'hardwood', 'laminate', 'vinyl', 'carpet'].includes(selectedElement.type);
      if (!isFlooringType) return;

      selectedElement.grainDirection = angle;

      // Update button states
      document.querySelectorAll('.grain-btn').forEach(btn => {
        btn.classList.toggle('active', parseInt(btn.dataset.dir) === angle);
      });

      saveUndoState();
      draw();
      update3DScene();

      const dirNames = { 0: 'Horizontal', 90: 'Vertical', 45: 'Diagonal (â†˜)', 135: 'Diagonal (â†™)' };
      showSnapFeedback(`Grain direction: ${dirNames[angle] || angle + 'Â°'}`);
    }

    // Get default beam depth based on type
    function getDefaultBeamDepth(type) {
      switch(type) {
        case 'steel-beam': return 0.67;     // W8 beam - 8"
        case 'wood-beam': return 0.5;        // 6" timber
        case 'concrete-beam': return 0.83;   // 10" concrete beam
        case 'header': return 0.33;          // 4" header
        case 'lvl-beam': return 0.92;        // 11" LVL
        default: return 0.67;
      }
    }

    // Update beam depth from dropdown
    function updateBeamDepth() {
      if (!selectedElement || selectedElement.locked) return;

      const select = document.getElementById('propBeamDepth');
      const value = select.value;
      const customRow = document.getElementById('customBeamDepthRow');

      if (value === 'custom') {
        customRow.style.display = 'flex';
        const current = selectedElement.beamDepth || getDefaultBeamDepth(selectedElement.type);
        document.getElementById('propCustomBeamDepth').value = current.toFixed(2);
        document.getElementById('propBeamDepthDisplay').textContent = formatDimension(current);
        return;
      }

      customRow.style.display = 'none';
      const depth = parseFloat(value);
      selectedElement.beamDepth = depth;

      saveUndoState();
      draw();
      update3DScene();
      showSnapFeedback(`Beam depth: ${Math.round(depth * 12)}"`);
    }

    // Apply custom beam depth
    function applyCustomBeamDepth() {
      if (!selectedElement || selectedElement.locked) return;

      const input = document.getElementById('propCustomBeamDepth');
      const depth = parseDimension(input.value);
      if (depth && depth > 0 && depth <= 4) {
        selectedElement.beamDepth = depth;
        document.getElementById('propBeamDepthDisplay').textContent = formatDimension(depth);

        saveUndoState();
        draw();
        update3DScene();
        showSnapFeedback(`Beam depth: ${formatDimension(depth)}`);
      }
    }

    // Update beam elevation from dropdown
    function updateBeamElevation() {
      if (!selectedElement || selectedElement.locked) return;

      const select = document.getElementById('propBeamElevation');
      const value = select.value;
      const customRow = document.getElementById('customBeamElevationRow');

      if (value === 'custom') {
        customRow.style.display = 'flex';
        const current = selectedElement.beamElevation || roomHeight || 8;
        document.getElementById('propCustomBeamElevation').value = current.toFixed(2);
        document.getElementById('propBeamElevationDisplay').textContent = formatDimension(current);
        return;
      }

      customRow.style.display = 'none';

      if (value === 'ceiling') {
        delete selectedElement.beamElevation; // Use room height
        showSnapFeedback('Beam at ceiling level');
      } else {
        selectedElement.beamElevation = parseFloat(value);
        showSnapFeedback(`Beam elevation: ${formatDimension(parseFloat(value))}`);
      }

      saveUndoState();
      draw();
      update3DScene();
    }

    // Apply custom beam elevation
    function applyCustomBeamElevation() {
      if (!selectedElement || selectedElement.locked) return;

      const input = document.getElementById('propCustomBeamElevation');
      const elevation = parseDimension(input.value);
      if (elevation && elevation > 0 && elevation <= 20) {
        selectedElement.beamElevation = elevation;
        document.getElementById('propBeamElevationDisplay').textContent = formatDimension(elevation);

        saveUndoState();
        draw();
        update3DScene();
        showSnapFeedback(`Beam elevation: ${formatDimension(elevation)}`);
      }
    }

    // Update column height from dropdown
    function updateColumnHeight() {
      if (!selectedElement || selectedElement.locked) return;

      const select = document.getElementById('propColumnHeight');
      const value = select.value;
      const customRow = document.getElementById('customColumnHeightRow');

      if (value === 'custom') {
        customRow.style.display = 'flex';
        const current = selectedElement.columnHeight || roomHeight || 8;
        document.getElementById('propCustomColumnHeight').value = current.toFixed(2);
        document.getElementById('propColumnHeightDisplay').textContent = formatDimension(current);
        return;
      }

      customRow.style.display = 'none';

      if (value === 'ceiling') {
        delete selectedElement.columnHeight; // Use room height
        showSnapFeedback('Column: floor to ceiling');
      } else {
        selectedElement.columnHeight = parseFloat(value);
        showSnapFeedback(`Column height: ${formatDimension(parseFloat(value))}`);
      }

      saveUndoState();
      draw();
      update3DScene();
    }

    // Apply custom column height
    function applyCustomColumnHeight() {
      if (!selectedElement || selectedElement.locked) return;

      const input = document.getElementById('propCustomColumnHeight');
      const height = parseDimension(input.value);
      if (height && height > 0 && height <= 20) {
        selectedElement.columnHeight = height;
        document.getElementById('propColumnHeightDisplay').textContent = formatDimension(height);

        saveUndoState();
        draw();
        update3DScene();
        showSnapFeedback(`Column height: ${formatDimension(height)}`);
      }
    }

    // Update column size from dropdown
    function updateColumnSize() {
      if (!selectedElement || selectedElement.locked) return;

      const select = document.getElementById('propColumnSize');
      const value = select.value;

      if (value === 'custom') {
        // Custom sizes can be entered via width/height fields
        showSnapFeedback('Enter custom size in Width/Depth fields');
        return;
      }

      const size = parseFloat(value);
      selectedElement.width = size;
      selectedElement.height = size; // Square column

      updateProperties();
      saveUndoState();
      draw();
      update3DScene();
      showSnapFeedback(`Column size: ${Math.round(size * 12)}"Ã—${Math.round(size * 12)}"`);
    }

    // Update full wall height from dropdown
    function updateFullWallHeight() {
      if (!selectedElement || selectedElement.locked) return;

      const select = document.getElementById('propFullWallHeight');
      const value = select.value;
      const customRow = document.getElementById('customFullWallHeightRow');

      if (value === 'custom') {
        customRow.style.display = 'flex';
        const current = selectedElement.wallHeight || roomHeight || 8;
        document.getElementById('propCustomFullWallHeight').value = current.toFixed(2);
        document.getElementById('propFullWallHeightDisplay').textContent = formatDimension(current);
        return;
      }

      customRow.style.display = 'none';

      if (value === 'ceiling') {
        delete selectedElement.wallHeight; // Use room height
        showSnapFeedback('Wall: floor to ceiling');
      } else {
        selectedElement.wallHeight = parseFloat(value);
        showSnapFeedback(`Wall height: ${formatDimension(parseFloat(value))}`);
      }

      saveUndoState();
      draw();
      update3DScene();
    }

    // Apply custom full wall height
    function applyCustomFullWallHeight() {
      if (!selectedElement || selectedElement.locked) return;

      const input = document.getElementById('propCustomFullWallHeight');
      const height = parseDimension(input.value);
      if (height && height > 0 && height <= 30) {
        selectedElement.wallHeight = height;
        document.getElementById('propFullWallHeightDisplay').textContent = formatDimension(height);

        saveUndoState();
        draw();
        update3DScene();
        showSnapFeedback(`Wall height: ${formatDimension(height)}`);
      }
    }

    // Update wall thickness from dropdown
    function updateWallThickness() {
      if (!selectedElement || selectedElement.locked) return;

      const select = document.getElementById('propWallThickness');
      const value = select.value;
      const customRow = document.getElementById('customWallThicknessRow');

      if (value === 'custom') {
        customRow.style.display = 'flex';
        const current = selectedElement.height || 0.5;
        document.getElementById('propCustomWallThickness').value = current.toFixed(2);
        document.getElementById('propWallThicknessDisplay').textContent = formatDimension(current);
        return;
      }

      customRow.style.display = 'none';
      const thickness = parseFloat(value);
      selectedElement.height = thickness; // In 2D, height is depth/thickness

      updateProperties();
      saveUndoState();
      draw();
      update3DScene();
      showSnapFeedback(`Wall thickness: ${Math.round(thickness * 12)}"`);
    }

    // Apply custom wall thickness
    function applyCustomWallThickness() {
      if (!selectedElement || selectedElement.locked) return;

      const input = document.getElementById('propCustomWallThickness');
      const thickness = parseDimension(input.value);
      if (thickness && thickness > 0 && thickness <= 3) {
        selectedElement.height = thickness;
        document.getElementById('propWallThicknessDisplay').textContent = formatDimension(thickness);

        updateProperties();
        saveUndoState();
        draw();
        update3DScene();
        showSnapFeedback(`Wall thickness: ${formatDimension(thickness)}`);
      }
    }

    // Apply a standard size from dropdown
    function applyStandardSize() {
      if (!selectedElement || selectedElement.locked) return;

      const select = document.getElementById('propStandardSize');
      const value = select.value;
      if (!value) return;

      const [width, height] = value.split('x').map(parseFloat);
      if (width && height) {
        selectedElement.width = width;
        selectedElement.height = height;
        updateProperties();
        draw();
        showSnapFeedback(`Applied standard size: ${formatDimension(width)} Ã— ${formatDimension(height)}`);
      }
    }

    // Get default sill height based on element type (building code compliant)
    function getDefaultSillHeight(type) {
      switch(type) {
        case 'window':
        case 'window-large':
        case 'window-bay':
        case 'bay-window':
        case 'picture-window':
          return 2; // 24" - standard window sill height
        case 'sliding-door':
        case 'french-door':
        case 'glass-door':
        case 'door':
          return 0; // Floor level for doors
        default:
          return 2;
      }
    }

    // Update sill height from dropdown
    function updateSillHeight() {
      if (!selectedElement) return;

      const select = document.getElementById('propSillHeight');
      const value = select.value;
      const customSillRow = document.getElementById('customSillRow');

      if (value === 'custom') {
        customSillRow.style.display = 'flex';
        document.getElementById('propCustomSill').value = selectedElement.sillHeight || getDefaultSillHeight(selectedElement.type);
        return;
      }

      customSillRow.style.display = 'none';
      const sillHeight = parseFloat(value);
      selectedElement.sillHeight = sillHeight;

      // Show building code info
      let codeInfo = '';
      if (sillHeight < 2) {
        codeInfo = ' (Note: Standard min is 24")';
      } else if (sillHeight > 3.67) {
        codeInfo = ' (Warning: May exceed egress max 44")';
      }

      saveUndoState();
      draw();
      showSnapFeedback(`Sill height: ${Math.round(sillHeight * 12)}"${codeInfo}`);
    }

    // Apply custom sill height
    function applyCustomSillHeight() {
      if (!selectedElement) return;

      const input = document.getElementById('propCustomSill');
      const sillHeight = parseFloat(input.value) || 0;

      // Clamp to reasonable values
      selectedElement.sillHeight = Math.max(0, Math.min(8, sillHeight));

      // Building code warnings
      let warning = '';
      if (sillHeight < 2 && selectedElement.type === 'window') {
        warning = ' - Below 24" minimum for safety';
      } else if (sillHeight > 3.67 && selectedElement.type === 'window') {
        warning = ' - Above 44" egress maximum';
      }

      saveUndoState();
      draw();
      showSnapFeedback(`Custom sill: ${Math.round(sillHeight * 12)}"${warning}`);
    }

    // Update door/archway height
    function updateDoorHeight() {
      if (!selectedElement) return;

      const select = document.getElementById('propDoorHeight');
      const value = select.value;
      const customDoorHeightRow = document.getElementById('customDoorHeightRow');

      if (value === 'custom') {
        customDoorHeightRow.style.display = 'flex';
        const currentHeight = selectedElement.height3D || 6.8;
        document.getElementById('propCustomDoorHeight').value = currentHeight.toFixed(2);
        document.getElementById('propDoorHeightDisplay').textContent = formatDimension(currentHeight);
        return;
      }

      customDoorHeightRow.style.display = 'none';
      const doorHeight = parseFloat(value);
      selectedElement.height3D = doorHeight;

      saveUndoState();
      draw();
      update3DScene();
      showSnapFeedback(`Opening height: ${Math.round(doorHeight * 12)}" (${formatDimension(doorHeight)})`);
    }

    // Apply custom door height
    function applyCustomDoorHeight() {
      if (!selectedElement) return;

      const input = document.getElementById('propCustomDoorHeight');
      const doorHeight = parseFloat(input.value) || 6.8;

      // Clamp to reasonable values
      selectedElement.height3D = Math.max(5, Math.min(12, doorHeight));

      document.getElementById('propDoorHeightDisplay').textContent = formatDimension(selectedElement.height3D);

      saveUndoState();
      draw();
      update3DScene();
      showSnapFeedback(`Custom height: ${Math.round(selectedElement.height3D * 12)}"`);
    }

    // Update archway style
    function updateArchwayStyle() {
      if (!selectedElement) return;

      const style = document.getElementById('propArchwayStyle').value;
      selectedElement.archwayStyle = style;

      saveUndoState();
      draw();
      update3DScene();
      showSnapFeedback(`Archway style: ${style}`);
    }

    // Update window style (double-hung, casement, sliding, etc.)
    function updateWindowStyle() {
      if (!selectedElement) return;

      const style = document.getElementById('propWindowStyle').value;
      selectedElement.windowStyle = style;

      saveUndoState();
      draw();
      update3DScene();
      showSnapFeedback(`Window style: ${style.replace('-', ' ')}`);
    }

    // Update window mullion/grille pattern
    function updateMullionPattern() {
      if (!selectedElement) return;

      const pattern = document.getElementById('propMullionPattern').value;
      selectedElement.mullionPattern = pattern;

      saveUndoState();
      draw();
      update3DScene();
      showSnapFeedback(`Mullion pattern: ${pattern}`);
    }

    // Update wall height for pony walls/half walls
    function updateWallHeight() {
      if (!selectedElement) return;

      const select = document.getElementById('propWallHeight');
      const value = select.value;
      const customWallHeightRow = document.getElementById('customWallHeightRow');

      if (value === 'custom') {
        customWallHeightRow.style.display = 'flex';
        const currentHeight = selectedElement.wallHeight || 3.5;
        document.getElementById('propCustomWallHeight').value = currentHeight.toFixed(2);
        document.getElementById('propWallHeightDisplay').textContent = formatDimension(currentHeight);
        return;
      }

      customWallHeightRow.style.display = 'none';
      const wallHeight = parseFloat(value);
      selectedElement.wallHeight = wallHeight;

      // Update any wall-caps linked to this wall
      updateLinkedWallCaps(selectedElement, wallHeight);

      saveUndoState();
      draw();
      update3DScene();
      showSnapFeedback(`Wall height: ${Math.round(wallHeight * 12)}" (${formatDimension(wallHeight)})`);
    }

    // Update any wall-caps that are linked to or overlapping with this pony wall
    function updateLinkedWallCaps(wall, wallHeight) {
      const capTypes = ['wall-cap', 'bar-top'];
      const wallCenterX = wall.x / pixelsPerFoot + wall.width / 2;
      const wallCenterY = wall.y / pixelsPerFoot + wall.height / 2;

      elements.forEach(el => {
        if (!capTypes.includes(el.type)) return;

        // Check if linked by parentWallId
        if (el.parentWallId === wall.id) {
          el.capHeight = wallHeight;
          return;
        }

        // Check if overlapping (for manually placed caps)
        const capCenterX = el.x / pixelsPerFoot + el.width / 2;
        const capCenterY = el.y / pixelsPerFoot + el.height / 2;
        const distX = Math.abs(capCenterX - wallCenterX);
        const distY = Math.abs(capCenterY - wallCenterY);

        // If cap overlaps this wall, update its height
        if (distX < (el.width + wall.width) / 2 + 0.5 &&
            distY < (el.height + wall.height) / 2 + 0.5) {
          el.capHeight = wallHeight;
        }
      });
    }

    // Apply custom wall height
    function applyCustomWallHeight() {
      if (!selectedElement) return;

      const input = document.getElementById('propCustomWallHeight');
      const wallHeight = parseFloat(input.value) || 3.5;

      // Clamp to reasonable values (1ft to 8ft)
      selectedElement.wallHeight = Math.max(1, Math.min(8, wallHeight));

      // Update any wall-caps linked to this wall
      updateLinkedWallCaps(selectedElement, selectedElement.wallHeight);

      // Update display
      document.getElementById('propWallHeightDisplay').textContent = formatDimension(selectedElement.wallHeight);

      saveUndoState();
      draw();
      update3DScene();
      showSnapFeedback(`Wall height: ${Math.round(selectedElement.wallHeight * 12)}" (${formatDimension(selectedElement.wallHeight)})`);
    }

    // Update niche depth for recessed wall elements
    function updateNicheDepth() {
      if (!selectedElement) return;

      const select = document.getElementById('propNicheDepth');
      const value = select.value;
      const customNicheDepthRow = document.getElementById('customNicheDepthRow');

      if (value === 'custom') {
        customNicheDepthRow.style.display = 'flex';
        const currentDepth = selectedElement.nicheDepth || 0.33;
        document.getElementById('propCustomNicheDepth').value = currentDepth.toFixed(2);
        document.getElementById('propNicheDepthDisplay').textContent = formatDimension(currentDepth);
        return;
      }

      customNicheDepthRow.style.display = 'none';
      const nicheDepth = parseFloat(value);
      selectedElement.nicheDepth = nicheDepth;

      saveUndoState();
      draw();
      update3DScene();
      showSnapFeedback(`Niche depth: ${Math.round(nicheDepth * 12)}" (${formatDimension(nicheDepth)})`);
    }

    // Apply custom niche depth
    function applyCustomNicheDepth() {
      if (!selectedElement) return;

      const input = document.getElementById('propCustomNicheDepth');
      const nicheDepth = parseFloat(input.value) || 0.33;

      // Clamp to reasonable values (2" to 3ft)
      selectedElement.nicheDepth = Math.max(0.17, Math.min(3, nicheDepth));

      // Update display
      document.getElementById('propNicheDepthDisplay').textContent = formatDimension(selectedElement.nicheDepth);

      saveUndoState();
      draw();
      update3DScene();
      showSnapFeedback(`Niche depth: ${Math.round(selectedElement.nicheDepth * 12)}" (${formatDimension(selectedElement.nicheDepth)})`);
    }

    // Update stone surface thickness
    function updateStoneThickness() {
      if (!selectedElement) return;

      const select = document.getElementById('propStoneThickness');
      const thickness = parseFloat(select.value);

      selectedElement.stoneThickness = thickness;

      // Convert to inches for display
      const thicknessInches = thickness * 12;
      let thicknessLabel = '';
      if (Math.abs(thicknessInches - 0.75) < 0.1) thicknessLabel = '3/4" (2cm)';
      else if (Math.abs(thicknessInches - 1.25) < 0.1) thicknessLabel = '1.25" (3cm)';
      else if (Math.abs(thicknessInches - 1.5) < 0.1) thicknessLabel = '1.5"';
      else if (Math.abs(thicknessInches - 2) < 0.2) thicknessLabel = '2"';
      else if (Math.abs(thicknessInches - 3) < 0.2) thicknessLabel = '3"';
      else thicknessLabel = thicknessInches.toFixed(1) + '"';

      saveUndoState();
      draw();
      update3DScene();
      showSnapFeedback(`Stone thickness: ${thicknessLabel}`);
    }

    // Update cap height for wall caps and bar tops
    function updateCapHeight() {
      if (!selectedElement) return;

      const select = document.getElementById('propCapHeight');
      const value = select.value;
      const customRow = document.getElementById('customCapHeightRow');

      if (value === 'custom') {
        if (customRow) {
          customRow.style.display = 'flex';
          const currentHeight = selectedElement.capHeight || 3.5;
          document.getElementById('propCustomCapHeight').value = currentHeight.toFixed(2);
          document.getElementById('propCapHeightDisplay').textContent = formatDimension(currentHeight);
        }
        return;
      }

      if (customRow) customRow.style.display = 'none';

      const capHeight = parseFloat(value);
      selectedElement.capHeight = capHeight;

      saveUndoState();
      draw();
      update3DScene();
      showSnapFeedback(`Cap height: ${formatDimension(capHeight)} (${Math.round(capHeight * 12)}")`);
    }

    // Apply custom cap height
    function applyCustomCapHeight() {
      if (!selectedElement) return;

      const input = document.getElementById('propCustomCapHeight');
      const capHeight = parseFloat(input.value) || 3;

      selectedElement.capHeight = Math.max(0.5, Math.min(8, capHeight));

      // Update display
      document.getElementById('propCapHeightDisplay').textContent = formatDimension(selectedElement.capHeight);

      saveUndoState();
      draw();
      update3DScene();
      showSnapFeedback(`Cap height: ${formatDimension(selectedElement.capHeight)} (${Math.round(selectedElement.capHeight * 12)}")`);
    }

    // Update edge profile for countertops
    function updateEdgeProfile() {
      if (!selectedElement || selectedElement.type !== 'countertop') return;

      const profile = document.getElementById('propEdgeProfile').value;
      selectedElement.edgeProfile = profile;

      // Show/hide waterfall controls based on edge profile selection
      const isWaterfall = profile === 'waterfall';
      const waterfallRow = document.getElementById('waterfallRow');
      const waterfallHeightRow = document.getElementById('waterfallHeightRow');

      if (waterfallRow) {
        waterfallRow.style.display = isWaterfall ? 'flex' : 'none';
      }
      if (waterfallHeightRow) {
        // Only show height row if waterfall is selected AND at least one side is checked
        const hasWaterfallSides = selectedElement.waterfallSides && selectedElement.waterfallSides.length > 0;
        waterfallHeightRow.style.display = (isWaterfall && hasWaterfallSides) ? 'flex' : 'none';
      }

      // Clear waterfall sides if not waterfall edge
      if (!isWaterfall) {
        selectedElement.waterfallSides = null;
        selectedElement.waterfallHeight = null;
        selectedElement.waterfallDropFeet = null;
      }

      update3DScene();
      calculateQuote();
      showSnapFeedback(`Edge profile: ${profile}`);
    }

    // Update countertop thickness (2cm vs 3cm)
    function updateCountertopThickness() {
      if (!selectedElement || selectedElement.type !== 'countertop') return;

      const thickness = document.getElementById('propThickness').value;
      const edgeStyle = document.getElementById('propEdgeStyle').value;

      selectedElement.thickness = thickness;
      selectedElement.edgeBuildStyle = thickness === '2cm' ? edgeStyle : null;

      // Show/hide edge style row based on thickness
      const edgeStyleRow = document.getElementById('edgeStyleRow');
      if (edgeStyleRow) {
        edgeStyleRow.style.display = thickness === '2cm' ? 'flex' : 'none';
      }

      update3DScene();
      calculateQuote();

      if (thickness === '2cm') {
        showSnapFeedback(`2cm thickness with ${edgeStyle} edge build`);
      } else {
        showSnapFeedback(`3cm thickness (standard)`);
      }
    }

    // Update backsplash height for countertops
    function updateBacksplash() {
      if (!selectedElement || selectedElement.type !== 'countertop') return;

      const value = document.getElementById('propBacksplash').value;
      if (value === 'none') {
        selectedElement.backsplash = null;
      } else if (value === 'full') {
        selectedElement.backsplash = { height: 18, type: 'full' }; // Full height to upper cabinets
      } else {
        selectedElement.backsplash = { height: parseInt(value), type: 'standard' };
      }
      update3DScene();
      calculateQuote();
      showSnapFeedback(`Backsplash: ${value === 'none' ? 'None' : value + '"'}`);
    }

    // Update finished ends for countertops
    function updateFinishedEnds() {
      if (!selectedElement || selectedElement.type !== 'countertop') return;

      const ends = [];
      if (document.getElementById('propFinishedLeft').checked) ends.push('left');
      if (document.getElementById('propFinishedRight').checked) ends.push('right');
      selectedElement.finishedEnds = ends.length > 0 ? ends : null;
      update3DScene();
      calculateQuote();
    }

    // Update waterfall sides (which sides get waterfall treatment)
    function updateWaterfallSides() {
      if (!selectedElement || selectedElement.type !== 'countertop') return;

      const waterfallSides = [];
      if (document.getElementById('propWaterfallLeft')?.checked) waterfallSides.push('left');
      if (document.getElementById('propWaterfallRight')?.checked) waterfallSides.push('right');
      if (document.getElementById('propWaterfallFront')?.checked) waterfallSides.push('front');
      if (document.getElementById('propWaterfallBack')?.checked) waterfallSides.push('back');

      selectedElement.waterfallSides = waterfallSides.length > 0 ? waterfallSides : null;

      // If any waterfall sides are enabled, ensure waterfall height row is visible
      const waterfallHeightRow = document.getElementById('waterfallHeightRow');
      if (waterfallHeightRow) {
        waterfallHeightRow.style.display = waterfallSides.length > 0 ? 'flex' : 'none';
      }

      update3DScene();
      calculateQuote();

      if (waterfallSides.length > 0) {
        showSnapFeedback(`Waterfall sides: ${waterfallSides.join(', ')}`);
      }
    }

    // Update waterfall drop height
    function updateWaterfallHeight() {
      if (!selectedElement || selectedElement.type !== 'countertop') return;

      const value = document.getElementById('propWaterfallHeight')?.value;

      if (value === 'floor') {
        // Calculate height to floor from counter
        selectedElement.waterfallHeight = 'floor';
        selectedElement.waterfallDropFeet = 3; // Default counter height
      } else if (value === 'custom') {
        const customHeight = prompt('Enter waterfall drop height in feet:', '3');
        if (customHeight && !isNaN(parseFloat(customHeight))) {
          selectedElement.waterfallHeight = parseFloat(customHeight);
          selectedElement.waterfallDropFeet = parseFloat(customHeight);
        }
      } else {
        selectedElement.waterfallHeight = parseFloat(value);
        selectedElement.waterfallDropFeet = parseFloat(value);
      }

      update3DScene();
      calculateQuote();
      showSnapFeedback(`Waterfall drop: ${selectedElement.waterfallHeight === 'floor' ? 'To floor' : selectedElement.waterfallHeight + "'"}`);
    }

    // Update sink properties (color, mount type)
    function updateSinkProperties() {
      if (!selectedElement || !selectedElement.type.startsWith('sink')) return;

      const sinkColor = document.getElementById('propSinkColor').value;
      const mountType = document.getElementById('propSinkMount').value;

      selectedElement.sinkColor = sinkColor;
      selectedElement.mountType = mountType;

      // Update the element color for 2D view based on sink finish
      const sinkColors = {
        stainless: '#C0C0C0',
        black: '#2A2A2A',
        white: '#F5F5F5',
        graphite: '#4A4A4A',
        bisque: '#F5E6D3',
        bronze: '#5C4033'
      };
      selectedElement.color = sinkColors[sinkColor] || '#C0C0C0';

      draw();
      update3DScene();
      calculateQuote();

      const colorNames = {
        stainless: 'Stainless Steel',
        black: 'Matte Black',
        white: 'White',
        graphite: 'Graphite',
        bisque: 'Bisque',
        bronze: 'Oil-Rubbed Bronze'
      };
      showSnapFeedback(`Sink: ${colorNames[sinkColor]} / ${mountType}`);
    }

    // Add a seam to the selected countertop
    function addSeamToCountertop() {
      if (!selectedElement || selectedElement.type !== 'countertop') return;

      // Initialize seams array if needed
      if (!selectedElement.seams) {
        selectedElement.seams = [];
      }

      // Add seam at a position (percentage along the width)
      // Default to middle, or offset from existing seams
      const existingCount = selectedElement.seams.length;
      let newPosition;

      if (existingCount === 0) {
        newPosition = 0.5; // Center
      } else {
        // Add at 1/3 or 2/3 position, cycling through
        const positions = [0.33, 0.67, 0.25, 0.75];
        newPosition = positions[existingCount % positions.length];
      }

      selectedElement.seams.push({
        position: newPosition,  // 0-1, percentage along width
        id: Date.now()
      });

      updateProperties();
      draw();
      update3DScene();
      showSnapFeedback(`Seam added at ${Math.round(newPosition * 100)}%`);
    }

    // Clear all seams from countertop
    function clearSeams() {
      if (!selectedElement || selectedElement.type !== 'countertop') return;

      selectedElement.seams = [];
      updateProperties();
      draw();
      update3DScene();
      showSnapFeedback('All seams removed');
    }

    // Remove a specific seam
    function removeSeam(seamId) {
      if (!selectedElement || !selectedElement.seams) return;

      selectedElement.seams = selectedElement.seams.filter(s => s.id !== seamId);
      updateProperties();
      draw();
      update3DScene();
    }

    // Get standard sizes for element type
    function getStandardSizesForType(type) {
      const sizes = [];

      switch (type) {
        case 'door':
          sizes.push({ label: '2\'-8" (32")', width: 2.667, height: 0.5 });
          sizes.push({ label: '3\'-0" (36")', width: 3, height: 0.5 });
          sizes.push({ label: '2\'-6" (30")', width: 2.5, height: 0.5 });
          break;
        case 'double-door':
          sizes.push({ label: '5\'-0" (60")', width: 5, height: 0.5 });
          sizes.push({ label: '6\'-0" (72")', width: 6, height: 0.5 });
          break;
        case 'sliding-door':
          sizes.push({ label: '6\'-0" (72")', width: 6, height: 0.5 });
          sizes.push({ label: '8\'-0" (96")', width: 8, height: 0.5 });
          sizes.push({ label: '9\'-0" (108")', width: 9, height: 0.5 });
          break;
        case 'entry-archway':
          sizes.push({ label: '3\'-0" (36")', width: 3, height: 0.5 });
          sizes.push({ label: '4\'-0" (48")', width: 4, height: 0.5 });
          sizes.push({ label: '5\'-0" (60")', width: 5, height: 0.5 });
          break;
        case 'garage-door':
          sizes.push({ label: '8\' Single', width: 8, height: 0.5 });
          sizes.push({ label: '9\' Single', width: 9, height: 0.5 });
          sizes.push({ label: '16\' Double', width: 16, height: 0.5 });
          sizes.push({ label: '18\' Double', width: 18, height: 0.5 });
          break;
        case 'window':
          sizes.push({ label: '2\'-0" Ã— 3\'-0"', width: 2, height: 0.5 });
          sizes.push({ label: '3\'-0" Ã— 4\'-0"', width: 3, height: 0.5 });
          sizes.push({ label: '4\'-0" Ã— 5\'-0"', width: 4, height: 0.5 });
          sizes.push({ label: '6\'-0" Picture', width: 6, height: 0.5 });
          break;
        case 'base-cabinet':
          sizes.push({ label: '12" Base', width: 1, height: 2 });
          sizes.push({ label: '15" Base', width: 1.25, height: 2 });
          sizes.push({ label: '18" Base', width: 1.5, height: 2 });
          sizes.push({ label: '24" Base', width: 2, height: 2 });
          sizes.push({ label: '30" Base', width: 2.5, height: 2 });
          sizes.push({ label: '36" Base', width: 3, height: 2 });
          break;
        case 'drawer-base':
          sizes.push({ label: '12" Drawer', width: 1, height: 2 });
          sizes.push({ label: '15" Drawer', width: 1.25, height: 2 });
          sizes.push({ label: '18" Drawer', width: 1.5, height: 2 });
          sizes.push({ label: '24" Drawer', width: 2, height: 2 });
          sizes.push({ label: '30" Drawer', width: 2.5, height: 2 });
          sizes.push({ label: '36" Drawer', width: 3, height: 2 });
          break;
        case 'sink-base':
          sizes.push({ label: '30" Sink Base', width: 2.5, height: 2 });
          sizes.push({ label: '33" Sink Base', width: 2.75, height: 2 });
          sizes.push({ label: '36" Sink Base', width: 3, height: 2 });
          sizes.push({ label: '42" Sink Base', width: 3.5, height: 2 });
          break;
        case 'corner-cabinet':
        case 'lazy-susan':
          sizes.push({ label: '33" Corner', width: 2.75, height: 2.75 });
          sizes.push({ label: '36" Corner', width: 3, height: 3 });
          sizes.push({ label: '39" Corner', width: 3.25, height: 3.25 });
          break;
        case 'wall-cabinet':
          sizes.push({ label: '12" Wall', width: 1, height: 1 });
          sizes.push({ label: '18" Wall', width: 1.5, height: 1 });
          sizes.push({ label: '24" Wall', width: 2, height: 1 });
          sizes.push({ label: '30" Wall', width: 2.5, height: 1 });
          sizes.push({ label: '36" Wall', width: 3, height: 1 });
          break;
        case 'tall-cabinet':
          sizes.push({ label: '18" Pantry', width: 1.5, height: 2 });
          sizes.push({ label: '24" Pantry', width: 2, height: 2 });
          sizes.push({ label: '36" Pantry', width: 3, height: 2 });
          break;
        case 'fridge-cabinet':
          sizes.push({ label: '30" Fridge Cabinet', width: 2.5, height: 7 });
          sizes.push({ label: '36" Fridge Cabinet', width: 3, height: 7 });
          sizes.push({ label: '42" Fridge Cabinet', width: 3.5, height: 7 });
          break;
        case 'island':
          sizes.push({ label: '4\' Ã— 2\' Small', width: 4, height: 2 });
          sizes.push({ label: '5\' Ã— 3\' Medium', width: 5, height: 3 });
          sizes.push({ label: '6\' Ã— 3\' Large', width: 6, height: 3 });
          sizes.push({ label: '8\' Ã— 4\' XL', width: 8, height: 4 });
          break;
        case 'countertop':
          sizes.push({ label: '25" Depth Std', width: 3, height: 2.083 });
          sizes.push({ label: '30" Depth Deep', width: 3, height: 2.5 });
          break;
        case 'sink':
          sizes.push({ label: '25" Single', width: 2.083, height: 1.83 });
          sizes.push({ label: '30" Single', width: 2.5, height: 1.83 });
          sizes.push({ label: '33" Single', width: 2.75, height: 1.83 });
          break;
        case 'sink-double':
          sizes.push({ label: '33" Double', width: 2.75, height: 1.83 });
          sizes.push({ label: '36" Double', width: 3, height: 1.83 });
          sizes.push({ label: '42" Double', width: 3.5, height: 1.83 });
          break;
        case 'sink-farmhouse':
          sizes.push({ label: '30" Farmhouse', width: 2.5, height: 1.75 });
          sizes.push({ label: '33" Farmhouse', width: 2.75, height: 1.75 });
          sizes.push({ label: '36" Farmhouse', width: 3, height: 1.75 });
          break;
        case 'stove':
        case 'range':
          sizes.push({ label: '30" Range', width: 2.5, height: 2.25 });
          sizes.push({ label: '36" Pro Range', width: 3, height: 2.25 });
          sizes.push({ label: '48" Pro Range', width: 4, height: 2.5 });
          break;
        case 'refrigerator':
          sizes.push({ label: '30" Standard', width: 2.5, height: 2.5 });
          sizes.push({ label: '36" Wide', width: 3, height: 2.75 });
          sizes.push({ label: '42" Built-in', width: 3.5, height: 2 });
          break;
        case 'dishwasher':
          sizes.push({ label: '24" Standard', width: 2, height: 2 });
          sizes.push({ label: '18" Compact', width: 1.5, height: 2 });
          break;
      }

      return sizes;
    }

    // ===== MATERIALS =====
    function openMaterialPicker() {
      if (!selectedElement) return;

      document.getElementById('materialModal').classList.add('active');
      renderMaterialCategories();
      renderMaterials('granite');
    }

    function renderMaterialCategories() {
      const container = document.getElementById('materialCategories');
      container.innerHTML = Object.keys(MATERIALS).map(cat => `
        <button class="material-category-btn ${cat === 'granite' ? 'active' : ''}"
                onclick="renderMaterials('${cat}', this)">
          ${cat.charAt(0).toUpperCase() + cat.slice(1)}
        </button>
      `).join('') + `
        <button class="material-category-btn" onclick="renderMaterials('custom', this)">
          My Uploads
        </button>
      `;
    }

    function renderMaterials(category, btn) {
      document.querySelectorAll('.material-category-btn').forEach(b => b.classList.remove('active'));
      if (btn) btn.classList.add('active');

      const container = document.getElementById('materialsGrid');

      if (category === 'custom') {
        container.innerHTML = `
          <div class="upload-material-btn" onclick="document.getElementById('materialUpload').click()">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
              <polyline points="17 8 12 3 7 8"/>
              <line x1="12" y1="3" x2="12" y2="15"/>
            </svg>
            <span>Upload</span>
          </div>
          ${customMaterials.map(m => `
            <div class="material-modal-item"
                 style="background: url(${m.url}) center/cover"
                 onclick="applyMaterial('${m.url}')">
              <div class="material-name">${m.name}</div>
            </div>
          `).join('')}
        `;
      } else {
        const materials = MATERIALS[category] || [];
        container.innerHTML = `
          <div class="upload-material-btn" onclick="document.getElementById('materialUpload').click()">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
              <polyline points="17 8 12 3 7 8"/>
              <line x1="12" y1="3" x2="12" y2="15"/>
            </svg>
            <span>Upload</span>
          </div>
          ${materials.map(m => {
            const priceTier = getMaterialPriceTier(m.price);
            const tierInfo = priceTier ? PRICE_TIERS[priceTier] : null;
            const bgUrl = m.url ? getProxiedUrl(m.url) : null;
            return `
            <div class="material-modal-item ${m.brand === 'Daltile' || m.brand?.includes('Daltile') ? 'daltile-material' : ''}"
                 style="background: ${bgUrl ? `url(${bgUrl})` : m.color} center/cover"
                 onclick="applyMaterial('${m.url || m.color}', '${m.color}')"
                 data-sku="${m.sku || ''}"
                 data-price="${m.price || ''}">
              ${m.price ? `<div class="material-price" style="background: ${tierInfo?.color || '#666'}">$${m.price.toFixed(2)}/sf</div>` : ''}
              ${m.brand ? `<div class="material-brand">${m.brand}</div>` : ''}
              <div class="material-name">${m.name}</div>
            </div>
          `}).join('')}
        `;
      }
    }

    function applyMaterial(urlOrColor, fallbackColor) {
      if (!selectedElement) return;

      if (urlOrColor.startsWith('http') || urlOrColor.startsWith('data:')) {
        selectedElement.texture = urlOrColor;
        const img = new Image();
        img.crossOrigin = 'anonymous';

        // Use proxied URL for MSI images to handle CORS
        const finalUrl = getProxiedUrl(urlOrColor);

        img.onload = () => {
          selectedElement.textureImg = img;
          draw();
          updateProperties();
        };
        img.onerror = () => {
          // Fall back to color
          console.log('Image failed to load:', urlOrColor);
          selectedElement.texture = null;
          selectedElement.color = fallbackColor || '#888';
          draw();
        };
        img.src = finalUrl;
      } else {
        selectedElement.texture = null;
        selectedElement.textureImg = null;
        selectedElement.color = urlOrColor;
        draw();
        updateProperties();
      }

      closeModal('materialModal');
    }

    // Quick upload texture directly from properties panel
    function quickUploadTexture() {
      if (!selectedElement) {
        alert('Please select an element first');
        return;
      }

      const input = document.createElement('input');
      input.type = 'file';
      input.accept = 'image/*';
      input.onchange = (e) => {
        const file = e.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = (event) => {
          const url = event.target.result;

          // Save to custom materials
          customMaterials.push({
            id: Date.now(),
            name: file.name.split('.')[0],
            url: url
          });

          // Apply to selected element
          selectedElement.texture = url;
          selectedElement.materialName = file.name.split('.')[0];

          const img = new Image();
          img.onload = () => {
            selectedElement.textureImg = img;
            draw();
            updateProperties();
          };
          img.src = url;
        };
        reader.readAsDataURL(file);
      };
      input.click();
    }

    // Clear texture from selected element
    function clearTexture() {
      if (!selectedElement) return;

      selectedElement.texture = null;
      selectedElement.textureImg = null;
      selectedElement.materialName = null;
      selectedElement.materialId = null;
      draw();
      updateProperties();
    }

    function handleMaterialUpload(e) {
      const file = e.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = (event) => {
        const url = event.target.result;
        const name = file.name.split('.')[0];

        customMaterials.push({ id: Date.now(), name, url });

        if (selectedElement) {
          applyMaterial(url);
        }
      };
      reader.readAsDataURL(file);
      e.target.value = '';
    }

    function uploadElementTexture(type) {
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = 'image/*';
      input.onchange = (e) => {
        const file = e.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = (event) => {
          elementTextures[type] = event.target.result;
          renderSidebar();
        };
        reader.readAsDataURL(file);
      };
      input.click();
    }

    // ===== PRICING FUNCTIONS =====

    // Calculate total quote from all elements
    function calculateQuoteTotal() {
      // Use cached value if available and recent
      if (window.currentQuoteTotal !== undefined && window.currentQuoteTotal > 0) {
        return window.currentQuoteTotal;
      }

      let total = 0;
      elements.forEach(el => {
        const priceInfo = getElementPrice(el);
        const margin = getElementMargin(el) || 30;
        let cost = priceInfo?.price || 0;

        // Area-based items (countertops, flooring, etc.)
        if (['countertop', 'backsplash', 'flooring', 'tile'].includes(el.type)) {
          cost = (el.width || 1) * (el.height || 1) * cost;
        }

        // Add margin to get retail price
        total += cost * (1 + margin / 100);
      });

      window.currentQuoteTotal = total;
      return total;
    }

    // Get effective price for an element (priority: override -> catalog -> material -> custom -> default)
    function getElementPrice(element) {
      // 1) Manual override takes highest priority
      if (element.priceOverride !== null && element.priceOverride !== undefined) {
        return { price: element.priceOverride, source: 'override' };
      }

      // 2) Check for cabinet catalog pricing (by SKU)
      if (element.sku && element.catalog) {
        const catalog = CABINET_CATALOGS[element.catalog];
        if (catalog) {
          for (const category of Object.values(catalog.cabinets)) {
            const cab = category.find(c => c.sku === element.sku);
            if (cab && cab.price) {
              return { price: cab.price, source: 'catalog' };
            }
          }
        }
      }

      // 3) Check for material-specific pricing
      if (element.materialId) {
        for (const category in MATERIALS) {
          const mat = MATERIALS[category].find(m => m.id === element.materialId);
          if (mat && mat.price) {
            return { price: mat.price, source: 'material' };
          }
        }
      }

      // 4) Check custom prices from Excel import
      if (element.materialId && PRICING_STATE.customPrices[element.materialId]) {
        return { price: PRICING_STATE.customPrices[element.materialId], source: 'pricelist' };
      }

      // 5) Fall back to default type pricing
      return { price: CONFIG.PRICING[element.type] || 0, source: 'default' };
    }

    // Get element category for margin lookup
    function getElementCategory(type) {
      if (type.includes('cabinet') || type === 'island') return 'cabinet';
      if (['countertop', 'backsplash'].includes(type)) return 'countertop';
      if (['flooring', 'tile'].includes(type)) return 'flooring';
      if (['stove', 'refrigerator', 'dishwasher', 'microwave', 'oven', 'range-hood', 'sink'].includes(type)) return 'appliance';
      return 'other';
    }

    // Get effective margin for an element (priority: item -> category -> global)
    function getElementMargin(element) {
      // 1) Per-item margin override
      if (element.marginPercent !== null && element.marginPercent !== undefined) {
        return element.marginPercent;
      }

      // 2) Category-specific margin
      const category = getElementCategory(element.type);
      if (PRICING_STATE.categoryMargins && PRICING_STATE.categoryMargins[category] !== undefined) {
        return PRICING_STATE.categoryMargins[category];
      }

      // 3) Global default margin
      return PRICING_STATE.globalMargin;
    }

    // Get material name from ID
    function getMaterialName(materialId) {
      if (!materialId) return null;
      for (const category in MATERIALS) {
        const mat = MATERIALS[category].find(m => m.id === materialId);
        if (mat) return mat.name;
      }
      return null;
    }

    // Update element price from properties panel
    function updateElementPrice() {
      if (!selectedElement) return;

      const overrideInput = document.getElementById('propPriceOverride');
      const unitSelect = document.getElementById('propPriceUnit');
      const marginInput = document.getElementById('propMargin');

      const override = overrideInput && overrideInput.value ? parseFloat(overrideInput.value) : null;
      const unit = unitSelect ? unitSelect.value : 'sqft';
      const margin = marginInput && marginInput.value ? parseFloat(marginInput.value) : null;

      selectedElement.priceOverride = override;
      selectedElement.priceUnit = unit;
      selectedElement.marginPercent = margin;

      calculateQuote();
      updatePricingDisplay();
    }

    // Update pricing display in properties panel
    function updatePricingDisplay() {
      if (!selectedElement) return;

      const priceInfo = getElementPrice(selectedElement);
      const margin = getElementMargin(selectedElement);

      document.getElementById('propBasePrice').textContent = '$' + priceInfo.price.toFixed(2);

      // Calculate item total
      let quantity = 1;
      if (['countertop', 'backsplash', 'flooring', 'tile'].includes(selectedElement.type)) {
        quantity = selectedElement.width * selectedElement.height;
      }

      const cost = priceInfo.price * quantity;
      const retail = cost * (1 + margin / 100);

      document.getElementById('propItemTotal').textContent = '$' + retail.toFixed(2);
    }

    // Check if action is allowed based on permissions
    function checkPermission(action) {
      if (!SHARE_STATE.isSharedView) return true;
      if (!SHARE_STATE.allowedActions) return true;
      return SHARE_STATE.allowedActions[action] !== false;
    }

    // Toggle between cost and retail view
    function setQuoteView(view) {
      PRICING_STATE.showCostView = (view === 'cost');
      document.getElementById('retailViewBtn').classList.toggle('active', view === 'retail');
      document.getElementById('costViewBtn').classList.toggle('active', view === 'cost');
      calculateQuote();
    }

    // ===== QUOTE (Enhanced with Margins & Linear Fill Calculation) =====
    function calculateQuote() {
      const items = {};
      let totalCost = 0;
      let totalRetail = 0;

      // Filler pricing (per linear foot)
      const FILLER_PRICE_PER_LF = 25; // $25 per linear foot for filler strips
      const MIN_FILLER_WIDTH = 0.125; // 1.5" minimum (anything smaller is ignored)

      elements.forEach(el => {
        const priceInfo = getElementPrice(el);
        const margin = getElementMargin(el);

        let baseCost = 0;
        let quantity = 1;
        let unit = el.priceUnit || 'unit';
        let fillerCost = 0;
        let fillerWidth = 0;
        let boxCount = 1;

        // Calculate based on element type
        if (['countertop', 'backsplash', 'flooring', 'tile'].includes(el.type)) {
          // Square footage pricing
          const sqft = el.width * el.height;
          baseCost = sqft * priceInfo.price;
          quantity = sqft;
          unit = 'sqft';
        } else if (el.skuWidth && el.sku) {
          // Cabinet from catalog with SKU - calculate linear fill
          // If cabinet was resized beyond its original SKU width, calculate box count
          const actualWidth = el.width;
          const skuWidth = el.skuWidth;

          if (actualWidth > skuWidth * 1.1) {
            // Cabinet was stretched - calculate how many boxes needed
            boxCount = Math.floor(actualWidth / skuWidth);
            const remainder = actualWidth - (boxCount * skuWidth);

            // Check if remainder needs a filler
            if (remainder >= MIN_FILLER_WIDTH) {
              fillerWidth = remainder;
              fillerCost = fillerWidth * FILLER_PRICE_PER_LF;
            }

            // Price is per box * number of boxes
            baseCost = priceInfo.price * boxCount;
            quantity = boxCount;
            unit = 'boxes';

            // Store on element for display
            el.boxCount = boxCount;
            el.fillerWidth = fillerWidth;
          } else {
            // Single box
            baseCost = priceInfo.price;
            quantity = 1;
            unit = 'unit';
            el.boxCount = 1;
            el.fillerWidth = 0;
          }
        } else {
          // Standard unit pricing
          baseCost = priceInfo.price;
          quantity = 1;
          unit = 'unit';
        }

        const retailPrice = (baseCost + fillerCost) * (1 + margin / 100);
        const totalBaseCost = baseCost + fillerCost;

        // Store calculated prices on element for display
        el.costPrice = totalBaseCost;
        el.retailPrice = retailPrice;

        // Group items by SKU for cabinets, or type/material for others
        const materialName = getMaterialName(el.materialId);
        const itemKey = el.sku ? `cab-${el.sku}-${el.series || 'default'}` :
                        (el.materialId ? `${el.type}-${el.materialId}` : el.type);
        const itemLabel = el.sku ?
                          `${el.skuName || el.sku}${boxCount > 1 ? ` (Ã—${boxCount})` : ''}` :
                          (materialName ? `${el.label} (${materialName})` : el.label);

        if (!items[itemKey]) {
          items[itemKey] = {
            count: 0,
            costTotal: 0,
            retailTotal: 0,
            label: itemLabel,
            sqft: 0,
            linearFt: 0,
            boxCount: 0,
            fillerTotal: 0,
            margin: margin,
            priceSource: priceInfo.source,
            sku: el.sku || null
          };
        }

        items[itemKey].count++;
        items[itemKey].costTotal += totalBaseCost;
        items[itemKey].retailTotal += retailPrice;
        items[itemKey].boxCount += boxCount;
        items[itemKey].fillerTotal += fillerWidth;

        if (unit === 'sqft') {
          items[itemKey].sqft += quantity;
        }
        if (el.sku) {
          items[itemKey].linearFt += el.width;
        }

        totalCost += totalBaseCost;
        totalRetail += retailPrice;
      });

      // Add filler items to the quote if any exist
      const totalFiller = Object.values(items).reduce((sum, item) => sum + item.fillerTotal, 0);
      if (totalFiller > MIN_FILLER_WIDTH) {
        const fillerMargin = 30;
        const fillerCost = totalFiller * FILLER_PRICE_PER_LF;
        const fillerRetail = fillerCost * (1 + fillerMargin / 100);
        items['filler-strips'] = {
          count: 1,
          costTotal: fillerCost,
          retailTotal: fillerRetail,
          label: `Filler Strips (${(totalFiller * 12).toFixed(1)}")`,
          sqft: 0,
          linearFt: totalFiller,
          boxCount: 0,
          fillerTotal: totalFiller,
          margin: fillerMargin,
          priceSource: 'standard',
          sku: 'FILLER'
        };
        totalCost += fillerCost;
        totalRetail += fillerRetail;
      }

      renderQuoteItems(items, totalCost, totalRetail);
    }

    function renderQuoteItems(items, totalCost, totalRetail) {
      const quoteItems = document.getElementById('quoteItems');
      const showCost = PRICING_STATE.showCostView;
      const canViewPrices = checkPermission('canViewPrices');
      const canViewCosts = checkPermission('canViewCosts');

      if (Object.keys(items).length === 0) {
        quoteItems.innerHTML = `
          <div class="quote-item">
            <span class="quote-item-name">No items yet</span>
            <span class="quote-item-value">$0</span>
          </div>
        `;
      } else {
        quoteItems.innerHTML = Object.entries(items).map(([key, data]) => {
          const displayPrice = showCost && canViewCosts ? data.costTotal : data.retailTotal;
          const sqftInfo = data.sqft > 0 ? ` - ${data.sqft.toFixed(1)} sqft` : '';
          const marginBadge = canViewCosts ? `<span class="margin-badge">${data.margin}%</span>` : '';

          // Show box count for cabinets with SKU
          let quantityInfo = `(${data.count})`;
          if (data.sku && data.boxCount > 0) {
            quantityInfo = data.boxCount > 1
              ? `(${data.boxCount} boxes @ ${(data.linearFt * 12 / data.count).toFixed(0)}" linear)`
              : `(${data.count})`;
          }

          if (!canViewPrices) {
            return `
              <div class="quote-item">
                <span class="quote-item-name">${data.label} ${quantityInfo}${sqftInfo}</span>
              </div>
            `;
          }

          return `
            <div class="quote-item">
              <span class="quote-item-name">
                ${data.label} ${quantityInfo}${sqftInfo}
                ${marginBadge}
              </span>
              <span class="quote-item-value">
                $${displayPrice.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2})}
              </span>
            </div>
          `;
        }).join('');
      }

      // Update totals
      const displayTotal = showCost && canViewCosts ? totalCost : totalRetail;
      const quoteTotalEl = document.getElementById('quoteTotal');
      if (quoteTotalEl) {
        quoteTotalEl.textContent = canViewPrices
          ? '$' + displayTotal.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2})
          : '---';
      }

      // Show/hide cost breakdown
      const costRow = document.getElementById('quoteCostRow');
      const marginRow = document.getElementById('quoteMarginRow');

      if (costRow && marginRow) {
        if (canViewCosts) {
          costRow.style.display = 'flex';
          marginRow.style.display = 'flex';
          document.getElementById('quoteCost').textContent = '$' + totalCost.toLocaleString(undefined, {minimumFractionDigits: 2});
          document.getElementById('quoteMargin').textContent = '$' + (totalRetail - totalCost).toLocaleString(undefined, {minimumFractionDigits: 2});
        } else {
          costRow.style.display = 'none';
          marginRow.style.display = 'none';
        }
      }

      // Store quote total for payment processing and show/hide checkout button
      window.currentQuoteTotal = totalRetail;
      window.currentQuoteCost = totalCost;
      const quoteActions = document.getElementById('quoteActions');
      if (quoteActions) {
        quoteActions.style.display = totalRetail > 0 ? 'block' : 'none';
      }
    }

    // ============ PAYMENT PROCESSING ============

    const STRIPE_PUBLIC_KEY = 'pk_live_51Smr3E3qDbNyHFmdPLN9iXM3rMQv6hKNtXEP5yVpZVRHBFZ5xk0jKvPy4kQMQ6yHVzXSzVBBZlP8rMGKK9TyZ7qJ00q0Y3nKpN';
    const API_BASE = 'https://surprise-granite-email-api.onrender.com';
    let selectedPaymentOption = 'deposit';
    let stripeInstance = null;

    function openPaymentModal() {
      const total = window.currentQuoteTotal || 0;
      if (total <= 0) {
        showToast('Add items to your design before checkout', 'error');
        return;
      }

      // Initialize Stripe if not already
      if (!stripeInstance && typeof Stripe !== 'undefined') {
        stripeInstance = Stripe(STRIPE_PUBLIC_KEY);
      }

      // Calculate payment amounts
      const depositAmount = Math.max(99, total * 0.1); // 10% or minimum $99
      const discountedFull = total * 0.95; // 5% discount for full payment

      // Update modal values
      document.getElementById('paymentDesignName').textContent = document.getElementById('projectName')?.value || 'Kitchen Design';

      // Find primary countertop material
      const countertop = elements.find(el => el.type === 'countertop' && el.materialName);
      document.getElementById('paymentMaterial').textContent = countertop?.materialName || 'Various materials';

      // Calculate total square footage of countertops
      const countertopSqft = elements
        .filter(el => el.type === 'countertop')
        .reduce((sum, el) => sum + (el.width * el.height), 0);
      document.getElementById('paymentSqft').textContent = countertopSqft > 0 ? `${countertopSqft.toFixed(1)} sq ft` : '-';

      document.getElementById('paymentTotal').textContent = '$' + total.toLocaleString(undefined, {minimumFractionDigits: 2});
      document.getElementById('depositAmount').textContent = '$' + depositAmount.toLocaleString(undefined, {minimumFractionDigits: 2});
      document.getElementById('fullAmount').textContent = '$' + discountedFull.toLocaleString(undefined, {minimumFractionDigits: 2});

      // Pre-fill email if user is logged in
      if (window.currentUser?.email) {
        document.getElementById('paymentEmail').value = window.currentUser.email;
      }

      // Reset selection to deposit
      selectPaymentOption('deposit');

      // Show modal
      document.getElementById('paymentModal').style.display = 'flex';
    }

    function closePaymentModal() {
      document.getElementById('paymentModal').style.display = 'none';
    }

    // Close modal when clicking outside
    document.addEventListener('click', (e) => {
      const modal = document.getElementById('paymentModal');
      if (e.target === modal) {
        closePaymentModal();
      }
    });

    function selectPaymentOption(option) {
      selectedPaymentOption = option;
      const total = window.currentQuoteTotal || 0;

      // Update UI
      document.querySelectorAll('.payment-option').forEach(el => el.classList.remove('selected'));
      document.getElementById('option' + option.charAt(0).toUpperCase() + option.slice(1))?.classList.add('selected');

      // Update button text
      const btnText = document.getElementById('paymentBtnText');
      switch(option) {
        case 'deposit':
          const depositAmt = Math.max(99, total * 0.1);
          btnText.textContent = `Pay $${depositAmt.toFixed(2)} Deposit`;
          break;
        case 'consultation':
          btnText.textContent = 'Pay $99 Consultation Fee';
          break;
        case 'full':
          const fullAmt = total * 0.95;
          btnText.textContent = `Pay $${fullAmt.toLocaleString(undefined, {minimumFractionDigits: 2})} (5% off)`;
          break;
      }
    }

    async function processPayment() {
      const email = document.getElementById('paymentEmail').value.trim();
      const phone = document.getElementById('paymentPhone').value.trim();

      if (!email || !email.includes('@')) {
        showToast('Please enter a valid email address', 'error');
        document.getElementById('paymentEmail').focus();
        return;
      }

      const btn = document.getElementById('paymentSubmitBtn');
      const btnText = document.getElementById('paymentBtnText');
      const originalText = btnText.textContent;

      btn.disabled = true;
      btnText.textContent = 'Processing...';

      try {
        const total = window.currentQuoteTotal || 0;
        let amount = 0;
        let itemName = '';
        let description = '';

        switch(selectedPaymentOption) {
          case 'deposit':
            amount = Math.max(99, total * 0.1);
            itemName = 'Design Deposit (10%)';
            description = `Deposit for project: ${document.getElementById('projectName')?.value || 'Kitchen Design'}`;
            break;
          case 'consultation':
            amount = 99;
            itemName = 'Design Consultation';
            description = 'In-home or virtual design consultation';
            break;
          case 'full':
            amount = total * 0.95;
            itemName = 'Full Project Payment (5% discount)';
            description = `Full payment for project: ${document.getElementById('projectName')?.value || 'Kitchen Design'}`;
            break;
        }

        // Save design to localStorage/Supabase before checkout
        const designData = {
          name: document.getElementById('projectName')?.value || 'Kitchen Design',
          roomWidth,
          roomDepth,
          roomHeight,
          elements: JSON.parse(JSON.stringify(elements)),
          quoteTotal: total,
          paymentOption: selectedPaymentOption,
          paymentAmount: amount,
          customerEmail: email,
          customerPhone: phone,
          createdAt: new Date().toISOString()
        };

        // Store design reference for after payment
        localStorage.setItem('sg_pending_design', JSON.stringify(designData));

        // Create checkout session
        const response = await fetch(`${API_BASE}/api/create-checkout-session`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            items: [{
              name: itemName,
              price: Math.round(amount * 100), // Convert to cents
              quantity: 1,
              image: ''
            }],
            customer_email: email,
            success_url: `${window.location.origin}/tools/room-designer/?payment=success&session_id={CHECKOUT_SESSION_ID}`,
            cancel_url: `${window.location.origin}/tools/room-designer/?payment=canceled`,
            metadata: {
              order_source: 'room_designer',
              payment_type: selectedPaymentOption,
              project_total: total.toString(),
              phone: phone
            }
          })
        });

        const data = await response.json();

        if (data.error) {
          throw new Error(data.error);
        }

        // Redirect to Stripe Checkout
        if (data.url) {
          window.location.href = data.url;
        } else if (data.sessionId && stripeInstance) {
          const result = await stripeInstance.redirectToCheckout({ sessionId: data.sessionId });
          if (result.error) {
            throw new Error(result.error.message);
          }
        }

      } catch (error) {
        console.error('Payment error:', error);
        showToast('Payment failed: ' + error.message, 'error');
        btn.disabled = false;
        btnText.textContent = originalText;
      }
    }

    // Approve and Pay - for quote_approval permission
    window.approveAndPay = async function() {
      const btn = document.querySelector('.approve-pay-btn');
      if (!btn) return;

      const originalContent = btn.innerHTML;
      btn.disabled = true;
      btn.innerHTML = `
        <svg class="spinner" viewBox="0 0 24 24" style="width:20px;height:20px;margin-right:8px;animation:spin 1s linear infinite;">
          <circle cx="12" cy="12" r="10" stroke="currentColor" stroke-width="3" fill="none" stroke-dasharray="32" stroke-linecap="round"/>
        </svg>
        Processing...
      `;

      try {
        // Calculate quote total
        const total = calculateQuoteTotal();
        const depositAmount = total * 0.5; // 50% deposit

        if (depositAmount < 1) {
          throw new Error('Quote total is too low for payment');
        }

        // Get project name and share info
        const projectName = document.querySelector('.review-title')?.textContent || 'Design Project';
        const shareId = SHARE_STATE.shareId || window.location.pathname.split('/').pop() || 'unknown';

        // Prompt for email if not already known
        let customerEmail = SHARE_STATE.customerEmail || '';
        if (!customerEmail) {
          customerEmail = prompt('Please enter your email address for order confirmation:');
          if (!customerEmail || !customerEmail.includes('@')) {
            throw new Error('Valid email required to proceed');
          }
        }

        // Create design data for record-keeping
        const approvalData = {
          shareId: shareId,
          projectName: projectName,
          roomWidth,
          roomDepth,
          roomHeight,
          elements: JSON.parse(JSON.stringify(elements)),
          quoteTotal: total,
          depositAmount: depositAmount,
          customerEmail: customerEmail,
          approvedAt: new Date().toISOString(),
          status: 'pending_payment'
        };

        // Store approval reference for after payment
        localStorage.setItem('sg_pending_approval', JSON.stringify(approvalData));

        // Create checkout session for deposit
        const response = await fetch(`${API_BASE}/api/create-checkout-session`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            items: [{
              name: `Design Approval Deposit - ${projectName}`,
              price: Math.round(depositAmount * 100), // Convert to cents
              quantity: 1,
              image: ''
            }],
            customer_email: customerEmail,
            success_url: `${window.location.origin}/tools/room-designer/?approval=success&share_id=${shareId}&session_id={CHECKOUT_SESSION_ID}`,
            cancel_url: `${window.location.href}`,
            metadata: {
              order_source: 'room_designer_approval',
              payment_type: 'quote_approval_deposit',
              share_id: shareId,
              project_name: projectName,
              project_total: total.toString(),
              deposit_amount: depositAmount.toString()
            }
          })
        });

        const data = await response.json();

        if (data.error) {
          throw new Error(data.error);
        }

        // Mark design as approved before redirect
        try {
          await updateShareStatus(shareId, 'approved_pending_payment');
        } catch (e) {
          console.log('Could not update share status:', e);
        }

        // Redirect to Stripe Checkout
        if (data.url) {
          window.location.href = data.url;
        } else if (data.sessionId && stripeInstance) {
          const result = await stripeInstance.redirectToCheckout({ sessionId: data.sessionId });
          if (result.error) {
            throw new Error(result.error.message);
          }
        }

      } catch (error) {
        console.error('Approval payment error:', error);
        showToast('Payment failed: ' + error.message, 'error');
        btn.disabled = false;
        btn.innerHTML = originalContent;
      }
    };

    // Update share status in Supabase
    async function updateShareStatus(shareId, status) {
      if (!window.supabase || !shareId) return;

      try {
        const { createClient } = window.supabase;
        const supabaseClient = window._sgSupabaseClient || createClient(SUPABASE_URL, SUPABASE_ANON_KEY, {
          auth: { persistSession: true, autoRefreshToken: true }
        });

        await supabaseClient
          .from('room_designer_shares')
          .update({
            status: status,
            approved_at: status.includes('approved') ? new Date().toISOString() : null
          })
          .eq('share_id', shareId);

        console.log('Share status updated to:', status);
      } catch (e) {
        console.error('Error updating share status:', e);
      }
    }

    // Check for approval success on page load
    function checkApprovalStatus() {
      const params = new URLSearchParams(window.location.search);
      const approvalStatus = params.get('approval');
      const shareId = params.get('share_id');
      const sessionId = params.get('session_id');

      if (approvalStatus === 'success' && shareId) {
        // Clear the URL params
        window.history.replaceState({}, document.title, window.location.pathname);

        // Load the pending approval data
        const pendingApproval = localStorage.getItem('sg_pending_approval');
        if (pendingApproval) {
          const approvalData = JSON.parse(pendingApproval);
          localStorage.removeItem('sg_pending_approval');

          // Update share status to fully approved
          updateShareStatus(shareId, 'approved_paid');

          // Show success message
          showToast('Design approved and deposit paid successfully!', 'success');

          // Show confirmation modal
          showApprovalConfirmation(approvalData);
        } else {
          showToast('Design approved! Thank you for your payment.', 'success');
        }
      }
    }

    // Show approval confirmation modal
    function showApprovalConfirmation(approvalData) {
      const modal = document.createElement('div');
      modal.className = 'approval-confirmation-modal';
      modal.innerHTML = `
        <div class="approval-confirmation-content">
          <div class="approval-success-icon">
            <svg viewBox="0 0 24 24" fill="none" stroke="#22c55e" stroke-width="2" style="width:64px;height:64px;">
              <path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/>
              <polyline points="22 4 12 14.01 9 11.01"/>
            </svg>
          </div>
          <h2>Design Approved!</h2>
          <p>Thank you for approving your design.</p>
          <div class="approval-details">
            <div class="approval-detail">
              <span class="label">Project:</span>
              <span class="value">${approvalData.projectName || 'Kitchen Design'}</span>
            </div>
            <div class="approval-detail">
              <span class="label">Deposit Paid:</span>
              <span class="value">$${(approvalData.depositAmount || 0).toFixed(2)}</span>
            </div>
            <div class="approval-detail">
              <span class="label">Remaining Balance:</span>
              <span class="value">$${((approvalData.quoteTotal || 0) - (approvalData.depositAmount || 0)).toFixed(2)}</span>
            </div>
          </div>
          <p class="approval-next-steps">Our team will contact you within 24 hours to schedule your project.</p>
          <button class="btn btn-primary" onclick="this.closest('.approval-confirmation-modal').remove()">Close</button>
        </div>
      `;
      document.body.appendChild(modal);

      // Add styles if not present
      if (!document.getElementById('approval-confirmation-styles')) {
        const style = document.createElement('style');
        style.id = 'approval-confirmation-styles';
        style.textContent = `
          .approval-confirmation-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.6);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
          }
          .approval-confirmation-content {
            background: white;
            border-radius: 16px;
            padding: 32px;
            max-width: 400px;
            text-align: center;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
          }
          .approval-success-icon {
            margin-bottom: 16px;
          }
          .approval-confirmation-content h2 {
            margin: 0 0 8px 0;
            color: #22c55e;
          }
          .approval-details {
            background: #f5f5f7;
            border-radius: 8px;
            padding: 16px;
            margin: 16px 0;
            text-align: left;
          }
          .approval-detail {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #e5e5e5;
          }
          .approval-detail:last-child {
            border-bottom: none;
          }
          .approval-detail .label {
            color: #666;
          }
          .approval-detail .value {
            font-weight: 600;
          }
          .approval-next-steps {
            color: #666;
            font-size: 13px;
            margin: 16px 0;
          }
        `;
        document.head.appendChild(style);
      }
    }

    // Check for payment success/cancel on page load
    function checkPaymentStatus() {
      const params = new URLSearchParams(window.location.search);
      const paymentStatus = params.get('payment');
      const sessionId = params.get('session_id');

      if (paymentStatus === 'success') {
        // Clear the URL params
        window.history.replaceState({}, document.title, window.location.pathname);

        // Load the pending design
        const pendingDesign = localStorage.getItem('sg_pending_design');
        if (pendingDesign) {
          try {
            const design = JSON.parse(pendingDesign);
            showToast(`Payment successful! Your ${design.paymentOption === 'deposit' ? 'deposit' : 'payment'} has been processed.`, 'success');

            // Save design to Supabase with payment reference
            if (window.supabaseClient) {
              saveDesignWithPayment(design, sessionId);
            }

            localStorage.removeItem('sg_pending_design');
          } catch (e) {
            showToast('Payment successful!', 'success');
          }
        } else {
          showToast('Payment successful! Thank you for your order.', 'success');
        }
      } else if (paymentStatus === 'canceled') {
        window.history.replaceState({}, document.title, window.location.pathname);
        showToast('Payment was canceled. Your design has been saved.', 'info');
      }
    }

    async function saveDesignWithPayment(design, sessionId) {
      try {
        const { data: { session } } = await window.supabaseClient.auth.getSession();

        const designRecord = {
          name: design.name,
          user_id: session?.user?.id || null,
          customer_email: design.customerEmail,
          customer_phone: design.customerPhone,
          room_data: {
            width: design.roomWidth,
            depth: design.roomDepth,
            height: design.roomHeight,
            elements: design.elements
          },
          quote_total: design.quoteTotal,
          payment_type: design.paymentOption,
          payment_amount: design.paymentAmount,
          stripe_session_id: sessionId,
          status: 'paid_deposit',
          created_at: design.createdAt
        };

        // Insert into designs table (if it exists)
        const { error } = await window.supabaseClient
          .from('room_designs')
          .insert([designRecord]);

        if (error) {
          console.log('Design save note:', error.message);
          // Table might not exist yet - that's okay
        } else {
          console.log('Design saved with payment reference');
        }
      } catch (e) {
        console.log('Design save skipped:', e.message);
      }
    }

    // Call on page load
    document.addEventListener('DOMContentLoaded', () => {
      checkPaymentStatus();
      checkApprovalStatus();
    });

    function generateQuote() {
      const projectName = document.getElementById('projectName').value;
      const roomType = document.getElementById('roomType').value;

      let text = `QUOTE: ${projectName}\nRoom: ${roomType} (${roomWidth}' Ã— ${roomDepth}')\n${'='.repeat(30)}\n\n`;
      elements.forEach(el => {
        text += `${el.label}: ${el.width}' Ã— ${el.height}'\n`;
      });
      text += `\n${'='.repeat(30)}\nTotal: ${document.getElementById('quoteTotal').textContent}`;

      alert(text);
    }

    // ===== MODALS =====
    function openShareModal() {
      document.getElementById('shareModal').classList.add('active');
      // Load active shares if we have a design ID
      if (SHARE_STATE.designId) {
        loadActiveShares();
      }
    }

    function closeModal(id) {
      const modal = document.getElementById(id);
      // Don't allow closing if it's a required modal (for auth)
      if (modal.getAttribute('data-required') === 'true') {
        return;
      }
      modal.classList.remove('active');
    }

    // ===== EDGE PREVIEW MODAL =====
    let edgePreviewScene, edgePreviewCamera, edgePreviewRenderer, edgePreviewControls;
    let edgePreviewElement = null;
    let edgePreviewAnimationId = null;

    function showEdgePreviewModal(element) {
      edgePreviewElement = element;

      const modal = document.getElementById('edgePreviewModal');
      modal.classList.add('active');

      // Update UI with current element settings
      const profile = element.edgeProfile || 'eased';
      const thickness = element.thickness || '3cm';

      document.getElementById('edgeProfileName').textContent = getEdgeProfileLabel(profile);
      document.getElementById('edgeThickness').textContent = thickness;
      document.getElementById('edgeProfileSelect').value = profile;

      // Initialize or update 3D preview
      setTimeout(() => initEdgePreview3D(element), 100);
    }

    function getEdgeProfileLabel(profile) {
      const labels = {
        'eased': 'Eased',
        'pencil': 'Pencil Round',
        'quarter-round': 'Quarter Round',
        'half-bullnose': 'Half Bullnose',
        'full-bullnose': 'Full Bullnose',
        'bevel': 'Bevel',
        'quarter-bevel': 'Quarter Bevel',
        'ogee': 'Ogee',
        'double-ogee': 'Double Ogee',
        'cove': 'Cove',
        'dupont': 'Dupont',
        'mitered': 'Mitered',
        'waterfall': 'Waterfall'
      };
      return labels[profile] || profile;
    }

    function initEdgePreview3D(element) {
      const container = document.getElementById('edgePreview3D');
      if (!container) return;

      // Clear existing
      if (edgePreviewRenderer) {
        container.innerHTML = '';
        if (edgePreviewAnimationId) {
          cancelAnimationFrame(edgePreviewAnimationId);
        }
      }

      // Scene setup
      edgePreviewScene = new THREE.Scene();
      edgePreviewScene.background = new THREE.Color(0x1a1a2e);

      // Camera - positioned to show the edge profile clearly from the front-right
      const aspect = container.clientWidth / container.clientHeight;
      edgePreviewCamera = new THREE.PerspectiveCamera(35, aspect, 0.01, 50);
      // Position camera to view the front edge profile - from front-right, slightly above
      // Looking at the front edge of the countertop to see the profile shape
      edgePreviewCamera.position.set(0.8, 0.4, 1.8);
      edgePreviewCamera.lookAt(0, 0.05, 0.3);

      // Renderer
      edgePreviewRenderer = new THREE.WebGLRenderer({ antialias: true });
      edgePreviewRenderer.setSize(container.clientWidth, container.clientHeight);
      edgePreviewRenderer.shadowMap.enabled = true;
      edgePreviewRenderer.toneMapping = THREE.ACESFilmicToneMapping;
      edgePreviewRenderer.toneMappingExposure = 1.2;
      container.appendChild(edgePreviewRenderer.domElement);

      // Controls - enable zoom and pan for exploring the edge
      edgePreviewControls = new THREE.OrbitControls(edgePreviewCamera, edgePreviewRenderer.domElement);
      edgePreviewControls.enableDamping = true;
      edgePreviewControls.dampingFactor = 0.05;
      // Target the front edge of the countertop
      edgePreviewControls.target.set(0, 0.05, 0.3);
      edgePreviewControls.enableZoom = true;
      edgePreviewControls.minDistance = 0.5;
      edgePreviewControls.maxDistance = 5.0;

      // Enhanced lighting for edge visibility
      const ambient = new THREE.AmbientLight(0xffffff, 0.6);
      edgePreviewScene.add(ambient);

      // Key light from front-right to illuminate the edge profile
      const keyLight = new THREE.DirectionalLight(0xffffff, 1.2);
      keyLight.position.set(2, 3, 4);
      keyLight.castShadow = true;
      edgePreviewScene.add(keyLight);

      // Fill light from opposite side
      const fillLight = new THREE.DirectionalLight(0xffffff, 0.5);
      fillLight.position.set(-3, 2, -2);
      edgePreviewScene.add(fillLight);

      // Rim light from behind to highlight the edge curve
      const rimLight = new THREE.DirectionalLight(0xffffff, 0.4);
      rimLight.position.set(0, 1, -3);
      edgePreviewScene.add(rimLight);

      // Create edge profile sample
      createEdgePreviewMesh(element);

      // Animation loop
      function animate() {
        edgePreviewAnimationId = requestAnimationFrame(animate);
        edgePreviewControls.update();
        edgePreviewRenderer.render(edgePreviewScene, edgePreviewCamera);
      }
      animate();
    }

    function createEdgePreviewMesh(element) {
      // Remove old meshes
      const oldMesh = edgePreviewScene.getObjectByName('edgeSample');
      if (oldMesh) edgePreviewScene.remove(oldMesh);
      const oldGroup = edgePreviewScene.getObjectByName('edgeGroup');
      if (oldGroup) edgePreviewScene.remove(oldGroup);

      const profile = element.edgeProfile || 'eased';
      const color = parseInt(element.color?.replace('#', '') || '708090', 16);
      const textureUrl = element.texture || null;

      // Create material with nice stone-like appearance
      let material;
      if (textureUrl) {
        const textureLoader = new THREE.TextureLoader();
        const texture = textureLoader.load(textureUrl);
        texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
        texture.repeat.set(0.5, 0.5);
        material = new THREE.MeshStandardMaterial({
          map: texture,
          roughness: 0.25,
          metalness: 0.05
        });
      } else {
        material = new THREE.MeshStandardMaterial({
          color: color,
          roughness: 0.25,
          metalness: 0.05
        });
      }

      const group = new THREE.Group();
      group.name = 'edgeGroup';

      // Countertop slab dimensions
      const slabWidth = 2.0;   // Width (left to right)
      const slabDepth = 1.2;   // Depth (front to back)
      const slabThickness = 0.12; // Thickness (1.5" = 0.125 ft scaled up for visibility)

      // Create the main slab body (simple box for the bulk)
      const slabGeometry = new THREE.BoxGeometry(slabWidth, slabThickness, slabDepth);
      const slab = new THREE.Mesh(slabGeometry, material);
      slab.position.y = slabThickness / 2;
      slab.castShadow = true;
      slab.receiveShadow = true;
      group.add(slab);

      // Create the front edge profile using extrusion
      const edgeShape = new THREE.Shape();
      const t = slabThickness; // Use actual thickness for proportional edge

      // Define edge profiles - shape is drawn looking at the edge cross-section
      // X = horizontal (into slab), Y = vertical (thickness)
      switch(profile) {
        case 'pencil': {
          // Small radius on top corner only
          const r = t * 0.15;
          edgeShape.moveTo(0, 0);
          edgeShape.lineTo(slabDepth * 0.3, 0);
          edgeShape.lineTo(slabDepth * 0.3, t - r);
          edgeShape.quadraticCurveTo(slabDepth * 0.3, t, slabDepth * 0.3 - r, t);
          edgeShape.lineTo(0, t);
          break;
        }
        case 'quarter-round': {
          // Quarter-circle on top-front corner
          const r = t * 0.35;
          edgeShape.moveTo(0, 0);
          edgeShape.lineTo(slabDepth * 0.3, 0);
          edgeShape.lineTo(slabDepth * 0.3, t - r);
          edgeShape.quadraticCurveTo(slabDepth * 0.3, t, slabDepth * 0.3 - r, t);
          edgeShape.lineTo(0, t);
          break;
        }
        case 'half-bullnose': {
          // Full half-circle on front edge (top half only)
          const r = t * 0.5;
          edgeShape.moveTo(0, 0);
          edgeShape.lineTo(slabDepth * 0.3 - r, 0);
          edgeShape.lineTo(slabDepth * 0.3 - r, t * 0.4);
          edgeShape.quadraticCurveTo(slabDepth * 0.3, t * 0.5, slabDepth * 0.3, t);
          edgeShape.lineTo(0, t);
          break;
        }
        case 'full-bullnose': {
          // Full semi-circle on entire front edge
          const r = t * 0.5;
          edgeShape.moveTo(0, r);
          edgeShape.lineTo(slabDepth * 0.3 - r, r);
          edgeShape.absarc(slabDepth * 0.3 - r, t * 0.5, r, -Math.PI/2, Math.PI/2, false);
          edgeShape.lineTo(0, t - r);
          break;
        }
        case 'ogee': {
          // Classic S-curve profile
          edgeShape.moveTo(0, 0);
          edgeShape.lineTo(slabDepth * 0.25, 0);
          edgeShape.lineTo(slabDepth * 0.25, t * 0.3);
          edgeShape.bezierCurveTo(
            slabDepth * 0.28, t * 0.5,
            slabDepth * 0.32, t * 0.6,
            slabDepth * 0.28, t * 0.75
          );
          edgeShape.bezierCurveTo(
            slabDepth * 0.24, t * 0.9,
            slabDepth * 0.18, t,
            0, t
          );
          break;
        }
        case 'double-ogee': {
          // Double S-curve
          edgeShape.moveTo(0, 0);
          edgeShape.lineTo(slabDepth * 0.25, 0);
          edgeShape.lineTo(slabDepth * 0.25, t * 0.2);
          edgeShape.bezierCurveTo(slabDepth * 0.28, t * 0.3, slabDepth * 0.30, t * 0.35, slabDepth * 0.28, t * 0.45);
          edgeShape.bezierCurveTo(slabDepth * 0.26, t * 0.55, slabDepth * 0.28, t * 0.65, slabDepth * 0.30, t * 0.75);
          edgeShape.bezierCurveTo(slabDepth * 0.28, t * 0.9, slabDepth * 0.2, t, 0, t);
          break;
        }
        case 'bevel':
        case 'quarter-bevel': {
          // 45-degree chamfer on top-front corner
          const bevelSize = t * 0.25;
          edgeShape.moveTo(0, 0);
          edgeShape.lineTo(slabDepth * 0.3, 0);
          edgeShape.lineTo(slabDepth * 0.3, t - bevelSize);
          edgeShape.lineTo(slabDepth * 0.3 - bevelSize, t);
          edgeShape.lineTo(0, t);
          break;
        }
        case 'cove': {
          // Concave curve (inward scoop)
          edgeShape.moveTo(0, 0);
          edgeShape.lineTo(slabDepth * 0.3, 0);
          edgeShape.lineTo(slabDepth * 0.3, t * 0.4);
          edgeShape.quadraticCurveTo(slabDepth * 0.15, t * 0.6, 0, t);
          break;
        }
        case 'dupont': {
          // Bevel + bullnose + small step
          edgeShape.moveTo(0, 0);
          edgeShape.lineTo(slabDepth * 0.25, 0);
          edgeShape.lineTo(slabDepth * 0.25, t * 0.25);
          edgeShape.lineTo(slabDepth * 0.30, t * 0.35);
          edgeShape.quadraticCurveTo(slabDepth * 0.32, t * 0.5, slabDepth * 0.30, t * 0.65);
          edgeShape.lineTo(slabDepth * 0.25, t * 0.75);
          edgeShape.lineTo(slabDepth * 0.25, t);
          edgeShape.lineTo(0, t);
          break;
        }
        case 'mitered': {
          // Small 45-degree at corner for thicker appearance
          const miterSize = t * 0.12;
          edgeShape.moveTo(0, 0);
          edgeShape.lineTo(slabDepth * 0.3, 0);
          edgeShape.lineTo(slabDepth * 0.3, t - miterSize);
          edgeShape.lineTo(slabDepth * 0.3 - miterSize, t);
          edgeShape.lineTo(0, t);
          break;
        }
        case 'waterfall': {
          // Minimal easing, meant to continue down cabinet side
          edgeShape.moveTo(0, 0);
          edgeShape.lineTo(slabDepth * 0.3, 0);
          edgeShape.lineTo(slabDepth * 0.3, t * 0.95);
          edgeShape.lineTo(slabDepth * 0.3 - t * 0.05, t);
          edgeShape.lineTo(0, t);
          break;
        }
        default: // eased
          // Small chamfer on top-front corner
          const easeSize = t * 0.1;
          edgeShape.moveTo(0, 0);
          edgeShape.lineTo(slabDepth * 0.3, 0);
          edgeShape.lineTo(slabDepth * 0.3, t - easeSize);
          edgeShape.quadraticCurveTo(slabDepth * 0.3, t, slabDepth * 0.3 - easeSize, t);
          edgeShape.lineTo(0, t);
      }
      edgeShape.closePath();

      // Extrude along the width of the slab
      const extrudeSettings = {
        steps: 2,
        depth: slabWidth,
        bevelEnabled: false
      };

      const edgeGeometry = new THREE.ExtrudeGeometry(edgeShape, extrudeSettings);
      const edgeMesh = new THREE.Mesh(edgeGeometry, material);
      edgeMesh.name = 'edgeSample';

      // Position the edge at the front of the slab
      // Extrusion goes along Z, shape is in XY plane
      // Rotate so it aligns with the slab front
      edgeMesh.rotation.y = -Math.PI / 2;
      edgeMesh.position.set(slabWidth / 2, 0, slabDepth / 2);

      edgeMesh.castShadow = true;
      edgeMesh.receiveShadow = true;
      group.add(edgeMesh);

      // Position group so the front edge is centered at origin for easy viewing
      // This puts the front edge profile in the center of view
      group.position.set(-slabWidth / 2, 0, -slabDepth / 2 + 0.15);

      edgePreviewScene.add(group);
    }

    function updateEdgeProfile(profile) {
      if (!edgePreviewElement) return;

      edgePreviewElement.edgeProfile = profile;
      document.getElementById('edgeProfileName').textContent = getEdgeProfileLabel(profile);

      // Update 3D preview
      createEdgePreviewMesh(edgePreviewElement);

      // Update main canvas and 3D view
      draw();
      render3D();
    }

    function rotateEdgePreview(direction) {
      if (!edgePreviewCamera || !edgePreviewControls) return;

      const target = edgePreviewControls.target;

      if (direction === 'reset') {
        // Reset to default view - front-right angle showing edge profile
        edgePreviewCamera.position.set(0.8, 0.4, 1.8);
        edgePreviewControls.target.set(0, 0.05, 0.3);
      } else if (direction === 'left') {
        // Rotate camera around the target
        const angle = 0.4;
        const dx = edgePreviewCamera.position.x - target.x;
        const dz = edgePreviewCamera.position.z - target.z;
        edgePreviewCamera.position.x = target.x + dx * Math.cos(angle) + dz * Math.sin(angle);
        edgePreviewCamera.position.z = target.z - dx * Math.sin(angle) + dz * Math.cos(angle);
      } else if (direction === 'right') {
        // Rotate camera around the target
        const angle = -0.4;
        const dx = edgePreviewCamera.position.x - target.x;
        const dz = edgePreviewCamera.position.z - target.z;
        edgePreviewCamera.position.x = target.x + dx * Math.cos(angle) + dz * Math.sin(angle);
        edgePreviewCamera.position.z = target.z - dx * Math.sin(angle) + dz * Math.cos(angle);
      }
      edgePreviewControls.update();
    }

    function closeEdgePreview() {
      const modal = document.getElementById('edgePreviewModal');
      modal.classList.remove('active');

      // Cleanup
      if (edgePreviewAnimationId) {
        cancelAnimationFrame(edgePreviewAnimationId);
        edgePreviewAnimationId = null;
      }
      if (edgePreviewRenderer) {
        edgePreviewRenderer.dispose();
      }
      edgePreviewElement = null;
    }

    function applyEdgeAndClose() {
      // Edge profile already applied via updateEdgeProfile
      closeEdgePreview();
      updateProperties();
      showSnapFeedback('Edge profile updated');
    }

    function copyShareLink() {
      const input = document.getElementById('shareLink');
      if (input.value) {
        navigator.clipboard.writeText(input.value).then(() => {
          const btn = document.getElementById('copyShareBtn');
          const originalText = btn.textContent;
          btn.textContent = 'Copied!';
          setTimeout(() => btn.textContent = originalText, 2000);
        }).catch(() => {
          input.select();
          document.execCommand('copy');
          alert('Link copied!');
        });
      }
    }

    function setSharePermission(perm, btn) {
      document.querySelectorAll('#shareModal .permission-btn').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
    }

    // ===== PRICE LIST MODAL FUNCTIONS =====
    let pendingPriceData = null;

    function openPriceListModal() {
      document.getElementById('priceListModal').classList.add('active');
      showPriceTab('upload');
      renderCurrentPrices();
    }

    function showPriceTab(tab) {
      document.querySelectorAll('.price-tab').forEach(t => t.style.display = 'none');
      document.querySelectorAll('.price-list-tabs .tab-btn').forEach(b => b.classList.remove('active'));

      document.getElementById('priceTab' + tab.charAt(0).toUpperCase() + tab.slice(1)).style.display = 'block';
      event.target.classList.add('active');
    }

    // Handle price list file upload
    async function handlePriceListUpload(event) {
      const file = event.target.files[0];
      if (!file) return;

      const extension = file.name.split('.').pop().toLowerCase();

      try {
        let data;
        if (extension === 'csv') {
          data = await parseCSVFile(file);
        } else if (['xlsx', 'xls'].includes(extension)) {
          data = await parseExcelFile(file);
        } else {
          throw new Error('Unsupported file format. Please use .xlsx, .xls, or .csv');
        }

        showColumnMapping(data);
      } catch (error) {
        alert('Error parsing file: ' + error.message);
        console.error(error);
      }
    }

    // Parse Excel file using SheetJS
    async function parseExcelFile(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = (e) => {
          try {
            if (typeof XLSX === 'undefined') {
              throw new Error('Excel parser not loaded. Please refresh the page.');
            }
            const data = new Uint8Array(e.target.result);
            const workbook = XLSX.read(data, { type: 'array' });
            const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
            const jsonData = XLSX.utils.sheet_to_json(firstSheet, { header: 1 });

            resolve({
              headers: jsonData[0] || [],
              rows: jsonData.slice(1).filter(row => row.some(cell => cell !== null && cell !== '')),
              raw: jsonData
            });
          } catch (err) {
            reject(err);
          }
        };
        reader.onerror = () => reject(new Error('Failed to read file'));
        reader.readAsArrayBuffer(file);
      });
    }

    // Parse CSV file
    async function parseCSVFile(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = (e) => {
          try {
            const text = e.target.result;
            const lines = text.split(/\r?\n/).filter(line => line.trim());
            const rows = lines.map(line => {
              const matches = line.match(/("([^"]*)"|[^,]+)/g) || [];
              return matches.map(val => val.replace(/^"|"$/g, '').trim());
            });

            resolve({
              headers: rows[0] || [],
              rows: rows.slice(1),
              raw: rows
            });
          } catch (err) {
            reject(err);
          }
        };
        reader.onerror = () => reject(new Error('Failed to read file'));
        reader.readAsText(file);
      });
    }

    function showColumnMapping(data) {
      pendingPriceData = data;

      document.getElementById('priceListDropzone').style.display = 'none';
      document.getElementById('columnMapping').style.display = 'block';

      const headers = data.headers;
      const optionsHtml = '<option value="">-- Select --</option>' +
        headers.map((h, i) => `<option value="${i}">${h}</option>`).join('');

      document.getElementById('mapMaterialId').innerHTML = optionsHtml;
      document.getElementById('mapMaterialName').innerHTML = optionsHtml;
      document.getElementById('mapPrice').innerHTML = optionsHtml;
      document.getElementById('mapUnit').innerHTML = '<option value="">None</option>' +
        headers.map((h, i) => `<option value="${i}">${h}</option>`).join('');

      // Auto-detect columns by name
      headers.forEach((h, i) => {
        const lower = String(h).toLowerCase();
        if (lower.includes('sku') || lower.includes('id') || lower.includes('code') || lower.includes('item')) {
          document.getElementById('mapMaterialId').value = i;
        }
        if (lower.includes('name') || lower.includes('material') || lower.includes('product') || lower.includes('description')) {
          document.getElementById('mapMaterialName').value = i;
        }
        if (lower.includes('price') || lower.includes('cost') || lower.includes('rate') || lower.includes('amount')) {
          document.getElementById('mapPrice').value = i;
        }
        if (lower.includes('unit') || lower.includes('uom')) {
          document.getElementById('mapUnit').value = i;
        }
      });

      updateMappingPreview();
    }

    function updateMappingPreview() {
      if (!pendingPriceData) return;

      const idCol = parseInt(document.getElementById('mapMaterialId').value);
      const nameCol = parseInt(document.getElementById('mapMaterialName').value);
      const priceCol = parseInt(document.getElementById('mapPrice').value);

      const preview = document.getElementById('mappingPreview');
      const sampleRows = pendingPriceData.rows.slice(0, 5);

      preview.innerHTML = `
        <table class="preview-table">
          <thead>
            <tr>
              <th>SKU/ID</th>
              <th>Name</th>
              <th>Price</th>
            </tr>
          </thead>
          <tbody>
            ${sampleRows.map(row => `
              <tr>
                <td>${isNaN(idCol) ? '-' : (row[idCol] || '-')}</td>
                <td>${isNaN(nameCol) ? '-' : (row[nameCol] || '-')}</td>
                <td>${isNaN(priceCol) ? '-' : formatPriceValue(row[priceCol])}</td>
              </tr>
            `).join('')}
          </tbody>
        </table>
        <p class="preview-count" style="margin-top:8px;font-size:12px;color:var(--text-muted);">${pendingPriceData.rows.length} items found</p>
      `;
    }

    function formatPriceValue(value) {
      if (!value) return '-';
      const num = parseFloat(String(value).replace(/[$,]/g, ''));
      return isNaN(num) ? '-' : '$' + num.toFixed(2);
    }

    function applyPriceList() {
      if (!pendingPriceData) return;

      const idCol = parseInt(document.getElementById('mapMaterialId').value);
      const nameCol = parseInt(document.getElementById('mapMaterialName').value);
      const priceCol = parseInt(document.getElementById('mapPrice').value);

      if (isNaN(priceCol)) {
        alert('Please select the Price column');
        return;
      }

      let matched = 0;
      let updated = 0;

      pendingPriceData.rows.forEach(row => {
        const id = !isNaN(idCol) ? String(row[idCol] || '').trim() : null;
        const name = !isNaN(nameCol) ? String(row[nameCol] || '').trim() : null;
        const price = parseFloat(String(row[priceCol] || '').replace(/[$,]/g, ''));

        if (isNaN(price) || price <= 0) return;

        // Store by ID in custom prices
        if (id) {
          PRICING_STATE.customPrices[id] = price;
        }

        // Update MATERIALS object for SKU/name matches
        for (const category in MATERIALS) {
          MATERIALS[category].forEach(mat => {
            if ((mat.sku && mat.sku === id) ||
                (mat.id && mat.id === id) ||
                (mat.name && name && mat.name.toLowerCase() === name.toLowerCase())) {
              mat.price = price;
              matched++;
            }
          });
        }
        updated++;
      });

      PRICING_STATE.activePriceList = 'Custom Import (' + new Date().toLocaleDateString() + ')';

      alert(`Price list applied!\n${updated} prices imported\n${matched} materials updated`);

      closeModal('priceListModal');
      calculateQuote();
      resetPriceUpload();
    }

    function cancelPriceUpload() {
      resetPriceUpload();
    }

    function resetPriceUpload() {
      pendingPriceData = null;
      document.getElementById('priceListDropzone').style.display = 'block';
      document.getElementById('columnMapping').style.display = 'none';
      document.getElementById('priceListFile').value = '';
    }

    function renderCurrentPrices() {
      const list = document.getElementById('currentPricesList');
      if (!list) return;

      let html = '';
      for (const category in MATERIALS) {
        const materials = MATERIALS[category].filter(m => m.price);
        if (materials.length === 0) continue;

        html += `<div class="price-category-header">${category.charAt(0).toUpperCase() + category.slice(1)}</div>`;
        materials.forEach(m => {
          html += `
            <div class="current-price-item">
              <span class="price-item-name">${m.name}</span>
              <span class="price-item-sku">${m.sku || '-'}</span>
              <span class="price-item-value">$${m.price.toFixed(2)}</span>
            </div>
          `;
        });
      }

      list.innerHTML = html || '<p class="empty-state">No priced materials</p>';
    }

    function filterCurrentPrices() {
      const query = document.getElementById('priceSearchInput').value.toLowerCase();
      const items = document.querySelectorAll('.current-price-item');
      items.forEach(item => {
        const name = item.querySelector('.price-item-name').textContent.toLowerCase();
        item.style.display = name.includes(query) ? 'flex' : 'none';
      });
    }

    // ===== MARGIN MODAL FUNCTIONS =====
    function openMarginModal() {
      document.getElementById('globalMarginInput').value = PRICING_STATE.globalMargin;

      // Populate category margins
      document.querySelectorAll('.category-margin-row input').forEach(input => {
        const category = input.dataset.category;
        const value = PRICING_STATE.categoryMargins[category];
        input.value = value !== undefined ? value : PRICING_STATE.globalMargin;
      });

      document.getElementById('marginModal').classList.add('active');
    }

    function applyMargins() {
      PRICING_STATE.globalMargin = parseInt(document.getElementById('globalMarginInput').value) || 30;

      document.querySelectorAll('.category-margin-row input').forEach(input => {
        const category = input.dataset.category;
        const value = parseInt(input.value);
        if (!isNaN(value)) {
          PRICING_STATE.categoryMargins[category] = value;
        }
      });

      closeModal('marginModal');
      calculateQuote();
    }

    // ===== SHARING FUNCTIONS (Supabase) =====

    // ===== PRELOADER FUNCTIONS =====
    // Preloader Steps for Blueprint CAD Animation
    // Minimal preloader
    let preloaderMinTime = 2000;
    let preloaderStartTime = 0;
    let preloaderReady = false;
    let preloaderProgress = 0;
    let preloaderInterval = null;

    function showPreloader(message, companyName) {
      const preloader = document.getElementById('cloudPreloader');
      const companyEl = document.getElementById('preloaderCompanyMain');
      const progressBar = document.getElementById('preloaderProgressBar');

      if (preloader) {
        preloader.classList.remove('loaded');
        preloaderStartTime = Date.now();
        preloaderReady = false;
        preloaderProgress = 0;

        // Set company name
        if (companyEl) {
          companyEl.textContent = companyName || 'Surprise Granite';
        }

        // Reset progress
        if (progressBar) progressBar.style.width = '0%';

        // Clear any existing interval
        if (preloaderInterval) clearInterval(preloaderInterval);

        // Animate progress bar
        preloaderInterval = setInterval(() => {
          preloaderProgress += 2;
          if (progressBar) progressBar.style.width = Math.min(preloaderProgress, 90) + '%';

          if (preloaderProgress >= 90 && preloaderReady) {
            if (progressBar) progressBar.style.width = '100%';
            clearInterval(preloaderInterval);
            setTimeout(hidePreloaderNow, 300);
          }
        }, 40);
      }
    }

    function hidePreloader() {
      preloaderReady = true;
      const elapsed = Date.now() - preloaderStartTime;

      if (elapsed >= preloaderMinTime && preloaderProgress >= 90) {
        const progressBar = document.getElementById('preloaderProgressBar');
        if (progressBar) progressBar.style.width = '100%';
        setTimeout(hidePreloaderNow, 300);
      }
    }

    function hidePreloaderNow() {
      const preloader = document.getElementById('cloudPreloader');
      if (preloaderInterval) {
        clearInterval(preloaderInterval);
        preloaderInterval = null;
      }
      if (preloader) {
        preloader.classList.add('loaded');
      }
    }

    // Get or create Supabase client - use global client for consistent auth
    function getSupabaseClient() {
      // First priority: use the global client from sg-auth.js
      if (window._sgSupabaseClient) {
        window._roomDesignerSupabase = window._sgSupabaseClient;
        return window._sgSupabaseClient;
      }

      // Second priority: use already cached room designer client
      if (window._roomDesignerSupabase) return window._roomDesignerSupabase;

      const SUPABASE_URL = 'https://ypeypgwsycxcagncgdur.supabase.co';
      const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InlwZXlwZ3dzeWN4Y2FnbmNnZHVyIiwicm9sZSI6ImFub24iLCJpYXQiOjE3Njc3NTQ4MjMsImV4cCI6MjA4MzMzMDgyM30.R13pNv2FDtGhfeu7gUcttYNrQAbNYitqR4FIq3O2-ME';

      // Create new client with persistent session storage and explicit headers
      if (window.supabase && window.supabase.createClient) {
        window._roomDesignerSupabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY, {
          auth: {
            persistSession: true,
            autoRefreshToken: true,
            detectSessionInUrl: true,
            storage: window.localStorage
          },
          global: {
            headers: {
              'Accept': 'application/json',
              'Content-Type': 'application/json'
            }
          }
        });
        // Also set as global so other components can use it
        if (!window._sgSupabaseClient) {
          window._sgSupabaseClient = window._roomDesignerSupabase;
        }
        return window._roomDesignerSupabase;
      }
      return null;
    }

    // Get current authenticated user
    function getCurrentUser() {
      // Try sg-auth first
      if (window.sgAuth && typeof window.sgAuth.getUser === 'function') {
        return window.sgAuth.getUser();
      }
      // Try getting from Supabase session
      const supabase = getSupabaseClient();
      if (supabase) {
        // Note: this is sync access to cached session
        const session = supabase.auth?.session;
        if (session?.user) return session.user;
      }
      // Check localStorage for cached user
      try {
        const stored = localStorage.getItem('sb-ypeypgwsycxcagncgdur-auth-token');
        if (stored) {
          const parsed = JSON.parse(stored);
          if (parsed?.user) return parsed.user;
        }
      } catch (e) {}
      return null;
    }

    // Generate cryptographically secure share token
    function generateToken(length = 16) {
      const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZabcdefghjkmnpqrstuvwxyz23456789';
      let token = '';

      // Use Web Crypto API for secure random values
      if (window.crypto && window.crypto.getRandomValues) {
        const randomValues = new Uint32Array(length);
        crypto.getRandomValues(randomValues);
        for (let i = 0; i < length; i++) {
          token += chars.charAt(randomValues[i] % chars.length);
        }
      } else {
        // Fallback for very old browsers - combine multiple entropy sources
        const timestamp = Date.now().toString(36);
        const random = Math.random().toString(36).substring(2);
        const combined = timestamp + random + performance.now().toString(36);
        for (let i = 0; i < length; i++) {
          const index = (combined.charCodeAt(i % combined.length) * (i + 1)) % chars.length;
          token += chars.charAt(index);
        }
        console.warn('Using fallback token generation - crypto API not available');
      }
      return token;
    }

    // ===== AUTHENTICATION FUNCTIONS =====

    // Show login prompt modal
    function showLoginPrompt(message) {
      document.getElementById('loginPromptMessage').textContent = message || 'Sign in to continue.';
      document.getElementById('loginFormContainer').style.display = 'block';
      document.getElementById('loginSuccessContainer').style.display = 'none';
      document.getElementById('loginError').style.display = 'none';
      document.getElementById('loginEmail').value = '';
      document.getElementById('loginPassword').value = '';
      document.getElementById('loginModal').classList.add('active');
      document.getElementById('loginModal').removeAttribute('data-required');
      resetSignInButton();
    }

    // Show required login prompt (non-dismissible, for initial access)
    function showLoginPromptRequired() {
      document.getElementById('loginPromptMessage').innerHTML =
        'Sign in to access the Room Designer.<br><span style="font-size: 12px; opacity: 0.7;">Create professional kitchen & bath layouts with instant quotes.</span>';
      document.getElementById('loginFormContainer').style.display = 'block';
      document.getElementById('loginSuccessContainer').style.display = 'none';
      document.getElementById('loginError').style.display = 'none';
      document.getElementById('loginEmail').value = '';
      document.getElementById('loginPassword').value = '';
      const modal = document.getElementById('loginModal');
      modal.classList.add('active');
      modal.setAttribute('data-required', 'true');
      resetSignInButton();
    }

    // Continue as guest without signing in
    function continueAsGuest() {
      pendingAuthInit = false;
      const loginModal = document.getElementById('loginModal');
      loginModal.removeAttribute('data-required');
      loginModal.classList.remove('active');
      initializeWorkspace();
    }

    // Handle Google OAuth login
    async function handleGoogleLogin() {
      try {
        const supabase = getSupabaseClient();
        if (!supabase) {
          throw new Error('Authentication not available');
        }

        const { data, error } = await supabase.auth.signInWithOAuth({
          provider: 'google',
          options: {
            redirectTo: window.location.origin + '/tools/room-designer/'
          }
        });

        if (error) {
          document.getElementById('loginError').textContent = error.message;
          document.getElementById('loginError').style.display = 'block';
        }
      } catch (err) {
        console.error('Google login error:', err);
        document.getElementById('loginError').textContent = 'Failed to connect with Google. Please try again.';
        document.getElementById('loginError').style.display = 'block';
      }
    }

    // Handle login form submission
    async function handleLogin() {
      const email = document.getElementById('loginEmail').value.trim();
      const password = document.getElementById('loginPassword').value;
      const errorEl = document.getElementById('loginError');
      const btn = document.getElementById('signInBtn');

      if (!email || !password) {
        errorEl.textContent = 'Please enter email and password.';
        errorEl.style.display = 'block';
        return;
      }

      try {
        errorEl.style.display = 'none';

        // Show loading state
        if (btn) {
          btn.classList.add('loading');
          btn.disabled = true;
        }

        if (!window.SgAuth) {
          throw new Error('Auth system not loaded. Please refresh the page.');
        }

        const result = await window.SgAuth.signIn(email, password);

        // Show success
        document.getElementById('loginFormContainer').style.display = 'none';
        document.getElementById('loginSuccessContainer').style.display = 'block';
        document.getElementById('loginWelcome').textContent = `Welcome back, ${result.profile?.full_name || email}!`;

        // Update header UI
        updateAuthUI();

        // If this was a required login to access the tool, continue initialization
        if (pendingAuthInit) {
          pendingAuthInit = false;
          setTimeout(() => {
            closeModal('loginModal');
            initializeWorkspace();
          }, 1000);
        }

      } catch (err) {
        console.error('Login error:', err);
        errorEl.textContent = err.message || 'Login failed. Please try again.';
        errorEl.style.display = 'block';

        // Reset button
        if (btn) {
          btn.classList.remove('loading');
          btn.disabled = false;
        }
      }
    }

    // Reset sign in button state
    function resetSignInButton() {
      const btn = document.getElementById('signInBtn');
      if (btn) {
        btn.classList.remove('loading');
        btn.disabled = false;
      }
    }

    // Update header to show logged-in state
    function updateAuthUI() {
      const user = window.SgAuth?.getUser();
      const profile = window.SgAuth?.getProfile();

      // Update new user menu
      const userAvatarSmall = document.getElementById('userAvatarSmall');
      const userNameDisplay = document.getElementById('userNameDisplay');
      const loggedOutMenu = document.getElementById('loggedOutMenu');
      const loggedInMenu = document.getElementById('loggedInMenu');

      if (user) {
        const name = profile?.full_name?.split(' ')[0] || user.email.split('@')[0];
        const initial = name.charAt(0).toUpperCase();

        if (userAvatarSmall) userAvatarSmall.textContent = initial;
        if (userNameDisplay) userNameDisplay.textContent = name;
        if (loggedOutMenu) loggedOutMenu.style.display = 'none';
        if (loggedInMenu) loggedInMenu.style.display = 'block';
      } else {
        if (userAvatarSmall) userAvatarSmall.textContent = '?';
        if (userNameDisplay) userNameDisplay.textContent = 'Sign In';
        if (loggedOutMenu) loggedOutMenu.style.display = 'block';
        if (loggedInMenu) loggedInMenu.style.display = 'none';
      }

      // Legacy accountBtn support
      const accountBtn = document.getElementById('accountBtn');
      if (accountBtn) {
        if (user) {
          const name = profile?.full_name?.split(' ')[0] || user.email.split('@')[0];
          accountBtn.innerHTML = `
            <span style="width:28px;height:28px;background:var(--gold);border-radius:50%;display:flex;align-items:center;justify-content:center;font-weight:600;color:var(--dark);font-size:12px;">${name.charAt(0).toUpperCase()}</span>
            <span>${name}</span>
          `;
          accountBtn.onclick = () => window.location.href = '/account/';
        } else {
          accountBtn.innerHTML = `
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:20px;height:20px;">
              <path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"/>
              <circle cx="12" cy="7" r="4"/>
            </svg>
            <span>Sign In</span>
          `;
          accountBtn.onclick = () => showLoginPrompt();
        }
      }
    }

    // Toggle user dropdown menu
    function toggleUserMenu() {
      const dropdown = document.getElementById('userDropdown');
      if (dropdown) {
        dropdown.classList.toggle('show');
      }
    }

    // Close user menu
    function closeUserMenu() {
      const dropdown = document.getElementById('userDropdown');
      if (dropdown) {
        dropdown.classList.remove('show');
      }
    }

    // Handle Google Sign In
    async function handleGoogleSignIn() {
      closeUserMenu();
      try {
        // Use SgAuth if available
        if (window.SgAuth && window.SgAuth.signInWithGoogle) {
          await window.SgAuth.signInWithGoogle(window.location.href);
        } else {
          // Fallback to direct Supabase call
          const client = getSupabaseClient();
          if (client) {
            const { error } = await client.auth.signInWithOAuth({
              provider: 'google',
              options: {
                redirectTo: window.location.href
              }
            });
            if (error) throw error;
          }
        }
      } catch (err) {
        console.error('Google sign in error:', err);
        showToast('Error connecting to Google');
      }
    }

    // Handle logout
    async function handleLogout() {
      closeUserMenu();
      try {
        if (window.SgAuth) {
          await window.SgAuth.signOut();
        }
        updateAuthUI();
        showToast('Signed out successfully');
      } catch (err) {
        console.error('Logout error:', err);
        showToast('Error signing out');
      }
    }

    // Close user menu when clicking outside
    document.addEventListener('click', function(e) {
      const menu = document.getElementById('userAccountMenu');
      const dropdown = document.getElementById('userDropdown');
      if (menu && dropdown && !menu.contains(e.target)) {
        dropdown.classList.remove('show');
      }
    });

    // Initialize auth state on load
    function initAuth() {
      if (window.SgAuth) {
        window.SgAuth.onAuthChange((event, data) => {
          console.log('Auth state changed:', event);
          updateAuthUI();

          // When user signs in, clear cached designs so they reload from server
          if (event === 'SIGNED_IN' || event === 'TOKEN_REFRESHED') {
            allDesigns = { my: [], shared: [], recent: [] };
            // If My Designs modal is open, refresh it
            const modal = document.getElementById('myDesignsModal');
            if (modal && modal.classList.contains('active')) {
              loadMyDesigns();
            }
          }
        });
      }

      // Also listen to Supabase auth changes directly
      const supabase = getSupabaseClient();
      if (supabase) {
        supabase.auth.onAuthStateChange((event, session) => {
          console.log('Supabase auth state changed:', event);
          if (event === 'SIGNED_IN' || event === 'TOKEN_REFRESHED') {
            // Clear cached designs to force reload
            allDesigns = { my: [], shared: [], recent: [] };
          }
        });
      }

      // Initial update
      setTimeout(updateAuthUI, 500);
    }

    // ===== TOAST NOTIFICATIONS =====
    function showToast(message, type = 'info') {
      let container = document.getElementById('toastContainer');
      if (!container) {
        container = document.createElement('div');
        container.id = 'toastContainer';
        container.className = 'toast-container';
        document.body.appendChild(container);
      }

      const toast = document.createElement('div');
      toast.className = `toast ${type}`;
      toast.textContent = message;
      container.appendChild(toast);

      // Remove toast after animation
      setTimeout(() => {
        toast.remove();
      }, 3000);
    }

    // Generate share link and save to Supabase
    async function generateShareLink() {
      console.log('=== generateShareLink START ===');

      // Check if user is logged in
      const user = window.SgAuth?.getUser();
      if (!user) {
        showLoginPrompt('Please log in to save and share your designs.');
        return;
      }

      // Get user profile for company name
      let companyName = 'Surprise Granite Marble & Quartz'; // default
      try {
        const profile = await window.SgAuth?.getProfile();
        if (profile && profile.company_name) {
          companyName = profile.company_name;
        } else if (profile && profile.full_name) {
          companyName = profile.full_name;
        }
      } catch (e) {
        console.log('Could not fetch profile:', e);
      }

      const permissionBtn = document.querySelector('#shareModal .permission-btn.active');
      const permission = permissionBtn ? permissionBtn.dataset.permission : 'quote_view';
      console.log('Permission selected:', permission);

      const projectName = document.getElementById('projectName').value || 'Untitled Design';
      const roomType = document.getElementById('roomType').value;

      console.log('Project:', projectName, 'Room:', roomType);
      console.log('Elements count:', elements.length);
      console.log('User:', user.email);
      console.log('Company:', companyName);

      // Calculate quote total
      let quoteTotal = 0;
      elements.forEach(el => {
        const priceInfo = getElementPrice(el);
        const margin = getElementMargin(el) || 30;
        let cost = priceInfo?.price || 0;
        if (['countertop', 'backsplash', 'flooring', 'tile'].includes(el.type)) {
          cost = (el.width || 1) * (el.height || 1) * cost;
        }
        quoteTotal += cost * (1 + margin / 100);
      });

      // Save current room state before creating share data
      saveCurrentRoomState();

      const designData = {
        user_id: user.id,
        name: projectName,
        room_type: roomType,
        room_width: roomWidth,
        room_depth: roomDepth,
        elements: elements.map(el => ({
          ...el,
          textureImg: null
        })),
        settings: {
          walls: walls,
          pricing_config: {
            globalMargin: PRICING_STATE.globalMargin,
            categoryMargins: PRICING_STATE.categoryMargins,
            customPrices: PRICING_STATE.customPrices
          },
          company_name: companyName,
          current_room_id: currentRoomId  // Store in settings, not as top-level column
        },
        // Multi-room support
        rooms: rooms.map(room => ({
          ...room,
          elements: room.elements.map(el => ({ ...el, textureImg: null }))
        })),
        quote_total: quoteTotal,
        share_mode: permission === 'full_collab' ? 'edit' : 'view',
        is_public: false
      };

      try {
        // Use direct fetch to avoid Supabase client issues
        const SUPABASE_URL = 'https://ypeypgwsycxcagncgdur.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InlwZXlwZ3dzeWN4Y2FnbmNnZHVyIiwicm9sZSI6ImFub24iLCJpYXQiOjE3Njc3NTQ4MjMsImV4cCI6MjA4MzMzMDgyM30.R13pNv2FDtGhfeu7gUcttYNrQAbNYitqR4FIq3O2-ME';

        // Get auth token if logged in
        const session = await window.SgAuth?.getSession?.();
        const authToken = session?.access_token || SUPABASE_ANON_KEY;

        const headers = {
          'apikey': SUPABASE_ANON_KEY,
          'Authorization': `Bearer ${authToken}`,
          'Accept': 'application/json',
          'Content-Type': 'application/json',
          'Prefer': 'return=representation'
        };

        let designId = SHARE_STATE.designId;
        let designToken = SHARE_STATE.designToken;
        console.log('Current state - designId:', designId, 'designToken:', designToken);

        // If designId is a local ID (starts with "local-"), we need to create a new one in Supabase
        const isLocalDesign = designId && String(designId).startsWith('local-');
        if (isLocalDesign) {
          console.log('Local design detected, will create new Supabase design');
          designId = null;
          designToken = null;
        }

        // Create or update design in database
        if (!designId) {
          designToken = generateToken(16);
          console.log('Creating new design with token:', designToken);

          const insertData = {
            share_token: designToken,
            ...designData
          };

          const response = await fetch(`${SUPABASE_URL}/rest/v1/room_designs`, {
            method: 'POST',
            headers,
            body: JSON.stringify(insertData)
          });

          if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`Insert failed: ${response.status} - ${errorText}`);
          }

          const data = await response.json();
          console.log('Insert result:', data);

          designId = Array.isArray(data) ? data[0]?.id : data.id;
          SHARE_STATE.designId = designId;
          SHARE_STATE.designToken = designToken;
          console.log('Design created with ID:', designId);
        } else {
          // Update existing design
          const updateData = {
            ...designData,
            updated_at: new Date().toISOString()
          };

          const response = await fetch(`${SUPABASE_URL}/rest/v1/room_designs?id=eq.${designId}`, {
            method: 'PATCH',
            headers,
            body: JSON.stringify(updateData)
          });

          if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`Update failed: ${response.status} - ${errorText}`);
          }
        }

        // Create share record with specific permission
        const shareToken = generateToken(12);
        const shareResponse = await fetch(`${SUPABASE_URL}/rest/v1/room_design_shares`, {
          method: 'POST',
          headers,
          body: JSON.stringify({
            design_id: designId,
            share_token: shareToken,
            permission_level: permission
          })
        });

        if (!shareResponse.ok) {
          const errorText = await shareResponse.text();
          throw new Error(`Share insert failed: ${shareResponse.status} - ${errorText}`);
        }

        // Display share URL
        const shareUrl = `${window.location.origin}${window.location.pathname}?share=${shareToken}`;
        document.getElementById('shareLink').value = shareUrl;
        document.getElementById('copyShareBtn').disabled = false;
        document.getElementById('shareStatusText').textContent = 'Design shared!';

        loadActiveShares();

      } catch (err) {
        console.error('Share error:', err);
        // Fallback to localStorage for local testing
        const token = generateToken(16);

        // Save design to localStorage
        const localDesign = {
          id: token,
          share_token: token,
          name: projectName,
          room_type: roomType,
          room_width: roomWidth,
          room_depth: roomDepth,
          elements: elements.map(el => ({ ...el, textureImg: null })),
          settings: {
            walls: walls,
            pricing_config: {
              globalMargin: PRICING_STATE.globalMargin,
              categoryMargins: PRICING_STATE.categoryMargins,
              customPrices: PRICING_STATE.customPrices
            },
            company_name: companyName
          },
          quote_total: quoteTotal,
          share_mode: permission === 'full_collab' ? 'edit' : 'view',
          permission_level: permission,
          created_at: new Date().toISOString()
        };

        // Store in localStorage
        const localShares = JSON.parse(localStorage.getItem('roomDesignerLocalShares') || '{}');
        localShares[token] = localDesign;
        localStorage.setItem('roomDesignerLocalShares', JSON.stringify(localShares));

        const shareUrl = `${window.location.origin}${window.location.pathname}?share=${token}`;
        document.getElementById('shareLink').value = shareUrl;
        document.getElementById('copyShareBtn').disabled = false;
        document.getElementById('shareStatusText').textContent = 'Link generated (local mode - for testing)';
        showToast('Share link created (local storage mode)', 'info');
      }
    }

    // Helper function to load design data into the canvas
    function loadDesignData(design, permission, shareData = null) {
      console.log('=== loadDesignData START ===');
      console.log('Design:', design);
      console.log('Permission:', permission);

      try {
        // Update preloader with company name
        let companyName = 'Surprise Granite Marble & Quartz';
        if (design.settings && design.settings.company_name) {
          companyName = design.settings.company_name;
        } else if (design.created_by) {
          companyName = design.created_by;
        } else if (design.company_name) {
          companyName = design.company_name;
        }
        const companyEl = document.getElementById('preloaderCompanyMain');
        if (companyEl) {
          companyEl.textContent = companyName;
        }

        // Set share state
        SHARE_STATE.isSharedView = true;
        SHARE_STATE.permission = permission;
        SHARE_STATE.allowedActions = PERMISSION_LEVELS[permission] || PERMISSION_LEVELS.presentation;
        SHARE_STATE.designId = design.id;
        SHARE_STATE.designToken = design.share_token;

        if (shareData) {
          SHARE_STATE.shareId = shareData.id;
          SHARE_STATE.comments = shareData.comments || [];
        }

        // Load design data into form fields
        document.getElementById('projectName').value = design.project_name || 'Shared Design';
        document.getElementById('roomType').value = design.room_type || 'kitchen';
        roomWidth = parseFloat(design.room_width) || 12;
        roomDepth = parseFloat(design.room_depth) || 10;
        document.getElementById('roomWidth').value = roomWidth;
        document.getElementById('roomDepth').value = roomDepth;

        // Load elements and walls
        elements = design.elements || [];
        walls = design.walls || [];

        // Load multi-room data if available
        if (design.rooms && design.rooms.length > 0) {
          rooms = design.rooms.map(room => ({
            ...room,
            elements: room.elements || [],
            walls: room.walls || []
          }));
          currentRoomId = design.settings?.current_room_id || design.current_room_id || rooms[0].id;

          // Load current room data
          const currentRoom = getCurrentRoom();
          if (currentRoom) {
            elements = currentRoom.elements || [];
            walls = currentRoom.walls || [];
            roomWidth = currentRoom.width || roomWidth;
            roomDepth = currentRoom.depth || roomDepth;
          }

          console.log('Loaded multi-room layout with', rooms.length, 'rooms');
          updateRoomList();
        } else {
          // Single room - initialize rooms array
          initializeRooms();
          const firstRoom = getCurrentRoom();
          if (firstRoom) {
            firstRoom.elements = elements;
            firstRoom.walls = walls;
            firstRoom.width = roomWidth;
            firstRoom.depth = roomDepth;
          }
          updateRoomList();
        }

        console.log('Loaded elements:', elements.length);
        console.log('Loaded walls:', walls.length);

        // Ensure elements have required properties
        elements = elements.map(el => ({
          ...el,
          textureImg: null,
          status: el.status || 'pending'
        }));

        // Load pricing config
        if (design.pricing_config) {
          PRICING_STATE.globalMargin = design.pricing_config.globalMargin || 30;
          PRICING_STATE.categoryMargins = design.pricing_config.categoryMargins || {};
          PRICING_STATE.customPrices = design.pricing_config.customPrices || {};
        }

        // Reload textures for elements
        elements.forEach(el => {
          if (el.materialId) {
            loadElementTexture(el);
          }
        });

        selectedElement = null;
        updateProperties();
        calculateQuote();
        draw();

        // Show Review Room UI first
        showReviewRoom(design.project_name, permission);

        // Wait for textures to load, then initialize 3D view
        setTimeout(() => {
          console.log('Initializing 3D view with', elements.length, 'elements');
          // Switch to 3D view first
          setView('3d');
          // Force re-init 3D scene after a short delay
          setTimeout(() => {
            init3D();
            render3D();
            console.log('3D scene initialized');
            // Hide preloader after 3D is ready
            hidePreloader();
            console.log('=== loadDesignData COMPLETE ===');
            // Log view activity
            logActivity('view');
          }, 300);
        }, 800);

      } catch (err) {
        console.error('loadDesignData error:', err);
        alert('Error loading design: ' + err.message);
        hidePreloader();
      }
    }

    // Load shared design from token
    async function loadSharedDesign(shareToken) {
      console.log('=== loadSharedDesign START ===');
      console.log('Token:', shareToken);

      // Show cloud preloader with Remodely AI branding
      showPreloader('Initializing 3D workspace');

      try {
        const supabase = getSupabaseClient();
        console.log('Supabase client:', supabase ? 'available' : 'NOT AVAILABLE');

        if (!supabase) {
          console.warn('Supabase not available for loading shared design, trying localStorage...');

          // Try localStorage fallback
          const localShares = JSON.parse(localStorage.getItem('roomDesignerLocalShares') || '{}');
          const localDesign = localShares[shareToken];

          if (localDesign) {
            console.log('Found design in localStorage:', localDesign.name);
            loadDesignData(localDesign, localDesign.permission_level || 'full_collab');
            showToast('Design loaded from local storage (offline mode)', 'info');
            return;
          }

          hidePreloader();
          showShareLinkError('Cannot load shared design - database connection unavailable. Please try again later.');
          return;
        }

        // Use direct fetch to avoid Supabase client issues
        const SUPABASE_URL = 'https://ypeypgwsycxcagncgdur.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InlwZXlwZ3dzeWN4Y2FnbmNnZHVyIiwicm9sZSI6ImFub24iLCJpYXQiOjE3Njc3NTQ4MjMsImV4cCI6MjA4MzMzMDgyM30.R13pNv2FDtGhfeu7gUcttYNrQAbNYitqR4FIq3O2-ME';
        const headers = {
          'apikey': SUPABASE_ANON_KEY,
          'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
          'Accept': 'application/json',
          'Content-Type': 'application/json'
        };

        // First try to get the share record by share_token
        console.log('Querying room_design_shares for token:', shareToken);
        let shareData = null;
        let shareError = null;

        try {
          const shareRes = await fetch(
            `${SUPABASE_URL}/rest/v1/room_design_shares?share_token=eq.${shareToken}&select=*`,
            { headers }
          );
          const shareResults = await shareRes.json();
          shareData = shareResults.length > 0 ? shareResults[0] : null;
          console.log('Share query result:', shareData);
        } catch (e) {
          shareError = e;
          console.error('Share query error:', e);
        }

        // If not found by share_token, try to find by design token directly
        if (!shareData) {
          console.log('Not found in shares, trying room_designs directly...');

          try {
            const designRes = await fetch(
              `${SUPABASE_URL}/rest/v1/room_designs?share_token=eq.${shareToken}&select=*`,
              { headers }
            );
            const designResults = await designRes.json();
            const directDesign = designResults.length > 0 ? designResults[0] : null;

            console.log('Direct design query result:', directDesign);

            if (directDesign) {
              // Found as a direct design link - load it directly
              loadDesignData(directDesign, 'full_collab');
              return;
            }
          } catch (e) {
            console.error('Design query error:', e);
          }

          // Try localStorage fallback for local testing
          console.log('Trying localStorage fallback...');
          const localShares = JSON.parse(localStorage.getItem('roomDesignerLocalShares') || '{}');
          const localDesign = localShares[shareToken];

          if (localDesign) {
            console.log('Found design in localStorage:', localDesign.name);
            loadDesignData(localDesign, localDesign.permission_level || 'full_collab');
            showToast('Design loaded from local storage', 'info');
            return;
          }

          console.error('Share error:', shareError);
          hidePreloader();
          showShareLinkError('Share link not found or expired. Please ask the designer for a new link.');
          return;
        }

        // Then get the associated design using direct fetch
        console.log('Loading design with id:', shareData.design_id);
        let design = null;
        try {
          const designRes = await fetch(
            `${SUPABASE_URL}/rest/v1/room_designs?id=eq.${shareData.design_id}&select=*`,
            { headers }
          );
          const designResults = await designRes.json();
          design = designResults.length > 0 ? designResults[0] : null;
        } catch (e) {
          console.error('Design fetch error:', e);
        }

        if (!design) {
          console.error('Design not found for id:', shareData.design_id);
          hidePreloader();
          showShareLinkError('Design not found or has been deleted.');
          return;
        }

        // Update access count (fire and forget, don't block on this)
        fetch(`${SUPABASE_URL}/rest/v1/room_design_shares?id=eq.${shareData.id}`, {
          method: 'PATCH',
          headers,
          body: JSON.stringify({
            access_count: (shareData.access_count || 0) + 1,
            last_accessed_at: new Date().toISOString()
          })
        }).catch(e => console.warn('Could not update access count:', e));

        const permission = shareData.permission_level;

        // Use the helper function to load the design
        loadDesignData(design, permission, shareData);

      } catch (err) {
        console.error('Load shared design error:', err);
        hidePreloader();
        showShareLinkError('Error loading shared design: ' + err.message);
      }
    }

    // Show error overlay when share link fails to load
    function showShareLinkError(message) {
      // Hide the main canvas area and show error instead
      const mainArea = document.querySelector('.main');
      if (mainArea) {
        mainArea.innerHTML = `
          <div class="share-error-overlay" style="
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: var(--bg);
            z-index: 1000;
            text-align: center;
            padding: 40px;
          ">
            <svg viewBox="0 0 24 24" fill="none" stroke="var(--text-muted)" stroke-width="1.5" style="width: 80px; height: 80px; margin-bottom: 24px; opacity: 0.5;">
              <circle cx="12" cy="12" r="10"/>
              <path d="M15 9l-6 6M9 9l6 6"/>
            </svg>
            <h2 style="color: var(--text); margin: 0 0 16px 0; font-size: 24px;">Link Unavailable</h2>
            <p style="color: var(--text-muted); margin: 0 0 32px 0; max-width: 400px; line-height: 1.6;">
              ${message}
            </p>
            <div style="display: flex; gap: 12px;">
              <a href="/tools/room-designer/" class="btn btn-primary" style="text-decoration: none;">
                Start New Design
              </a>
              <a href="/" class="btn btn-secondary" style="text-decoration: none;">
                Go to Homepage
              </a>
            </div>
          </div>
        `;
      }
    }

    // Show the Review Room overlay UI
    function showReviewRoom(projectName, permission) {
      const permInfo = PERMISSION_LEVELS[permission];

      // Create review room overlay
      const reviewRoom = document.createElement('div');
      reviewRoom.id = 'reviewRoom';
      reviewRoom.className = 'review-room';
      reviewRoom.innerHTML = `
        <div class="review-header">
          <div class="review-header-left">
            <h2 class="review-title">${projectName || 'Design Review'}</h2>
            <span class="review-permission-badge">${permInfo?.name || permission}</span>
          </div>
          <div class="review-header-right">
            <button class="btn btn-secondary" onclick="toggleReviewPanel()">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:16px;height:16px;">
                <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"/>
              </svg>
              Review Panel
            </button>
            <button class="btn btn-secondary" id="toggle3DBtn" onclick="toggle3DView()">
              2D View
            </button>
            ${permission === 'full_collab' ? `
            <button class="btn btn-secondary" onclick="exitReviewMode()" title="Exit to Editor">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:16px;height:16px;">
                <path d="M18 6L6 18M6 6l12 12"/>
              </svg>
            </button>
            ` : ''}
          </div>
        </div>

        <div class="review-panel" id="reviewPanel">
          <div class="review-panel-header">
            <h3>Design Elements</h3>
            <button class="review-panel-close" onclick="toggleReviewPanel()">Ã—</button>
          </div>

          <div class="review-summary">
            <div class="review-stat">
              <span class="stat-value" id="reviewTotal">$0</span>
              <span class="stat-label">Total Quote</span>
            </div>
            <div class="review-stat">
              <span class="stat-value" id="reviewItemCount">0</span>
              <span class="stat-label">Items</span>
            </div>
            <div class="review-stat">
              <span class="stat-value approved" id="reviewApproved">0</span>
              <span class="stat-label">Approved</span>
            </div>
          </div>

          <div class="review-elements" id="reviewElements">
            <!-- Populated by JS -->
          </div>

          <div class="review-comments-section">
            <h4>Comments</h4>
            <div class="review-comments" id="reviewComments">
              <!-- Populated by JS -->
            </div>
            <div class="review-comment-input">
              <input type="text" id="newCommentInput" placeholder="Add a comment..." onkeypress="if(event.key==='Enter')addReviewComment()">
              <button class="btn btn-primary btn-sm" onclick="addReviewComment()">Send</button>
            </div>
          </div>

          ${permission === 'quote_approval' ? `
          <div class="review-actions quote-approval-actions">
            <div class="approval-summary">
              <p class="approval-note">Review the design above. When ready, approve and pay to confirm your order.</p>
            </div>
            <button class="btn btn-success btn-lg approve-pay-btn" onclick="approveAndPay()">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:20px;height:20px;margin-right:8px;">
                <path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/>
                <polyline points="22 4 12 14.01 9 11.01"/>
              </svg>
              Approve & Pay Deposit
            </button>
            <p class="approval-terms">By clicking above, you approve this design and authorize a 50% deposit charge.</p>
          </div>
          ` : permission === 'full_collab' || permission === 'quote_view' ? `
          <div class="review-actions">
            <button class="btn btn-success" onclick="approveAllElements()">Approve All</button>
            <button class="btn btn-primary" onclick="submitReview()">Submit Review</button>
          </div>
          ` : ''}
        </div>
      `;

      document.body.appendChild(reviewRoom);

      // Apply permission-based UI adjustments
      applyPermissionRestrictions();

      // Populate review elements list
      console.log('Populating review with elements:', elements.length);
      updateReviewElements();
      updateReviewComments();
      updateReviewStats();

      // Auto-open the review panel for quote_view, full_collab, and quote_approval
      if (permission === 'quote_view' || permission === 'full_collab' || permission === 'quote_approval') {
        const panel = document.getElementById('reviewPanel');
        if (panel) {
          panel.classList.add('open');
          console.log('Auto-opened review panel for permission:', permission);
        }
      }
    }

    // Toggle review panel visibility
    function toggleReviewPanel() {
      const panel = document.getElementById('reviewPanel');
      if (panel) {
        panel.classList.toggle('open');
      }
    }

    // Exit review mode and return to normal editor
    function exitReviewMode() {
      const reviewRoom = document.getElementById('reviewRoom');
      if (reviewRoom) {
        reviewRoom.remove();
      }

      // Reset share state
      SHARE_STATE.isSharedView = false;
      SHARE_STATE.permission = 'full_collab';
      SHARE_STATE.allowedActions = PERMISSION_LEVELS.full_collab;

      // Switch back to 2D view
      setView('2d');

      // Re-enable all UI elements
      document.querySelectorAll('[data-permission-hidden]').forEach(el => {
        el.style.display = '';
        el.removeAttribute('data-permission-hidden');
      });

      draw();
    }

    // Update review elements list
    function updateReviewElements() {
      console.log('updateReviewElements called');
      const container = document.getElementById('reviewElements');
      if (!container) {
        console.log('Review elements container not found');
        return;
      }

      const canApprove = SHARE_STATE.permission === 'full_collab' || SHARE_STATE.permission === 'quote_view' || SHARE_STATE.permission === 'quote_approval';
      const canViewPrices = checkPermission('canViewPrices');
      console.log('canApprove:', canApprove, 'canViewPrices:', canViewPrices);

      if (elements.length === 0) {
        container.innerHTML = '<p class="empty-state">No elements in this design</p>';
        return;
      }

      container.innerHTML = elements.map((el, index) => {
        const priceInfo = getElementPrice(el);
        const margin = getElementMargin(el) || 30;
        let cost = priceInfo?.price || 0;
        if (['countertop', 'backsplash', 'flooring', 'tile'].includes(el.type)) {
          cost = (el.width || 1) * (el.height || 1) * cost;
        }
        const retail = cost * (1 + margin / 100);
        const status = el.status || 'pending';
        const statusIcon = status === 'approved' ? 'âœ“' : status === 'rejected' ? 'âœ—' : 'â—‹';
        const statusClass = status;

        return `
          <div class="review-element ${statusClass}" data-index="${index}" onclick="selectReviewElement(${index})">
            <div class="review-element-header">
              <span class="review-element-status ${statusClass}">${statusIcon}</span>
              <span class="review-element-name">${el.label}</span>
              ${canViewPrices ? `<span class="review-element-price">$${(retail || 0).toFixed(2)}</span>` : ''}
            </div>
            <div class="review-element-details">
              <span>${formatDimension(el.width)} Ã— ${formatDimension(el.height)}</span>
              ${el.material ? `<span class="review-element-material">${el.material}</span>` : ''}
            </div>
            ${canApprove ? `
            <div class="review-element-actions">
              <button class="btn-approve" onclick="event.stopPropagation(); setElementStatus(${index}, 'approved')" title="Approve">âœ“</button>
              <button class="btn-reject" onclick="event.stopPropagation(); setElementStatus(${index}, 'rejected')" title="Reject">âœ—</button>
              <button class="btn-comment" onclick="event.stopPropagation(); commentOnElement(${index})" title="Comment">ðŸ’¬</button>
            </div>
            ` : ''}
          </div>
        `;
      }).join('');
    }

    // Select an element from the review panel
    function selectReviewElement(index) {
      if (elements[index]) {
        selectedElement = elements[index];
        updateProperties();
        draw();

        // Highlight in 3D if available
        if (is3DMode) {
          // Could add 3D highlighting here
        }
      }
    }

    // Set element approval status
    async function setElementStatus(index, status) {
      if (elements[index]) {
        elements[index].status = status;
        updateReviewElements();
        updateReviewStats();
        draw();

        // Log activity
        const activityType = status === 'approved' ? 'approve' : 'reject';
        logActivity(activityType, index, elements[index].label);

        // Save status to database
        await saveReviewState();
      }
    }

    // Approve all elements
    async function approveAllElements() {
      elements.forEach(el => el.status = 'approved');
      updateReviewElements();
      updateReviewStats();
      draw();
      await saveReviewState();
    }

    // Comment on specific element
    function commentOnElement(index) {
      const comment = prompt(`Add comment for "${elements[index]?.label}":`);
      if (comment && comment.trim()) {
        const newComment = {
          elementIndex: index,
          elementLabel: elements[index]?.label,
          text: comment.trim(),
          timestamp: new Date().toISOString(),
          author: 'Reviewer'
        };
        SHARE_STATE.comments = SHARE_STATE.comments || [];
        SHARE_STATE.comments.push(newComment);
        updateReviewComments();
        saveReviewState();
      }
    }

    // Add general review comment
    async function addReviewComment() {
      const input = document.getElementById('newCommentInput');
      const text = input?.value?.trim();
      if (!text) return;

      const newComment = {
        text: text,
        timestamp: new Date().toISOString(),
        author: 'Reviewer'
      };

      SHARE_STATE.comments = SHARE_STATE.comments || [];
      SHARE_STATE.comments.push(newComment);
      input.value = '';
      updateReviewComments();

      // Log comment activity
      logActivity('comment', null, null, text);

      await saveReviewState();
    }

    // Update comments display
    function updateReviewComments() {
      const container = document.getElementById('reviewComments');
      if (!container) return;

      const comments = SHARE_STATE.comments || [];

      if (comments.length === 0) {
        container.innerHTML = '<p class="empty-state">No comments yet</p>';
        return;
      }

      container.innerHTML = comments.map(c => `
        <div class="review-comment">
          <div class="comment-header">
            <span class="comment-author">${c.author || 'Anonymous'}</span>
            ${c.elementLabel ? `<span class="comment-element">on ${c.elementLabel}</span>` : ''}
            <span class="comment-time">${new Date(c.timestamp).toLocaleString()}</span>
          </div>
          <div class="comment-text">${c.text}</div>
        </div>
      `).join('');

      container.scrollTop = container.scrollHeight;
    }

    // Update review stats
    function updateReviewStats() {
      console.log('updateReviewStats called, elements:', elements.length);
      console.log('Can view prices:', checkPermission('canViewPrices'));

      const totalEl = document.getElementById('reviewTotal');
      const countEl = document.getElementById('reviewItemCount');
      const approvedEl = document.getElementById('reviewApproved');

      if (totalEl && checkPermission('canViewPrices')) {
        let total = 0;
        elements.forEach(el => {
          if (el.retailPrice) {
            total += el.retailPrice;
          } else {
            const priceInfo = getElementPrice(el);
            const margin = getElementMargin(el);
            let cost = priceInfo?.price || 0;
            if (['countertop', 'backsplash', 'flooring', 'tile'].includes(el.type)) {
              cost = (el.width || 1) * (el.height || 1) * cost;
            }
            total += cost * (1 + (margin || 30) / 100);
          }
        });
        console.log('Calculated total:', total);
        totalEl.textContent = '$' + total.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2});
      } else if (totalEl) {
        totalEl.textContent = 'Hidden';
      }

      if (countEl) countEl.textContent = elements.length;

      if (approvedEl) {
        const approved = elements.filter(el => el.status === 'approved').length;
        approvedEl.textContent = approved;
      }
    }

    // Save review state to database
    async function saveReviewState() {
      if (!SHARE_STATE.shareId) return;

      try {
        const supabase = getSupabaseClient();
        if (!supabase) return;

        // Save element statuses to the design
        await supabase
          .from('room_designs')
          .update({
            elements: elements.map(el => ({
              ...el,
              textureImg: null
            }))
          })
          .eq('id', SHARE_STATE.designId);

        // Save comments to the share record
        await supabase
          .from('room_design_shares')
          .update({
            comments: SHARE_STATE.comments
          })
          .eq('id', SHARE_STATE.shareId);

      } catch (err) {
        console.error('Error saving review state:', err);
      }
    }

    // Submit final review
    async function submitReview() {
      const approved = elements.filter(el => el.status === 'approved').length;
      const rejected = elements.filter(el => el.status === 'rejected').length;
      const pending = elements.filter(el => el.status === 'pending').length;

      const summary = `Review Summary:\n\nâœ“ Approved: ${approved}\nâœ— Rejected: ${rejected}\nâ—‹ Pending: ${pending}\n\nSubmit this review?`;

      if (confirm(summary)) {
        await saveReviewState();
        alert('Review submitted! The design owner will be notified.');
      }
    }

    // Reload texture for an element
    function loadElementTexture(el) {
      if (!el.materialId) return;

      for (const category in MATERIALS) {
        const mat = MATERIALS[category].find(m => m.id === el.materialId);
        if (mat && mat.url) {
          const img = new Image();
          img.crossOrigin = 'anonymous';
          img.onload = () => {
            el.textureImg = img;
            draw();
          };
          img.src = mat.url;
          break;
        }
      }
    }

    // Apply UI restrictions based on permission level
    function applyPermissionRestrictions() {
      const perms = SHARE_STATE.allowedActions;
      if (!perms) return;

      // Hide/disable editing controls
      if (!perms.canEdit) {
        document.body.classList.add('review-readonly');

        document.querySelectorAll('.element-btn, .toolbar-btn').forEach(btn => {
          btn.disabled = true;
          btn.style.opacity = '0.5';
          btn.style.pointerEvents = 'none';
        });

        const propsContent = document.getElementById('propertiesContent');
        if (propsContent) {
          propsContent.querySelectorAll('input, select, button').forEach(el => {
            el.disabled = true;
          });
        }
      }

      // Hide pricing elements in main panel (shown in review panel instead)
      if (!perms.canViewPrices) {
        const quotePanel = document.getElementById('quotePanel');
        if (quotePanel) quotePanel.style.display = 'none';
      }

      // Hide cost view toggle
      if (!perms.canViewCosts) {
        const costBtn = document.getElementById('costViewBtn');
        if (costBtn) costBtn.style.display = 'none';
      }

      // Show presentation mode for presentation permission
      if (SHARE_STATE.permission === 'presentation') {
        document.body.classList.add('presentation-mode');
      }

      // Material view hides most UI
      if (SHARE_STATE.permission === 'material_view') {
        document.body.classList.add('material-view-mode');
      }

      // Auto-open review panel after a delay
      setTimeout(() => {
        const panel = document.getElementById('reviewPanel');
        if (panel) panel.classList.add('open');
      }, 1000);
    }

    function showPermissionNotice(permission) {
      const permInfo = PERMISSION_LEVELS[permission];
      if (!permInfo) return;

      const notice = document.createElement('div');
      notice.className = 'permission-notice';
      notice.innerHTML = `
        <div class="notice-content">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:18px;height:18px;">
            <circle cx="12" cy="12" r="10"/>
            <path d="M12 16v-4"/>
            <path d="M12 8h.01"/>
          </svg>
          <span>Viewing as: <strong>${permInfo.name}</strong></span>
          <button onclick="this.parentElement.parentElement.remove()" style="background:none;border:none;color:inherit;cursor:pointer;font-size:16px;">Ã—</button>
        </div>
      `;
      document.body.appendChild(notice);

      setTimeout(() => notice.remove(), 8000);
    }

    // Load active shares for current design
    async function loadActiveShares() {
      if (!SHARE_STATE.designId) return;

      try {
        const supabase = getSupabaseClient();
        if (!supabase) return;

        const { data, error } = await supabase
          .from('room_design_shares')
          .select('*')
          .eq('design_id', SHARE_STATE.designId)
          .order('created_at', { ascending: false });

        if (error) throw error;

        renderActiveShares(data || []);

        // Also load recent activity
        loadRecentActivity();
      } catch (err) {
        console.error('Load shares error:', err);
      }
    }

    function renderActiveShares(shares) {
      const container = document.getElementById('activeShares');
      const list = document.getElementById('sharesList');
      if (!container || !list) return;

      if (shares.length === 0) {
        container.style.display = 'none';
        return;
      }

      container.style.display = 'block';
      list.innerHTML = shares.map(share => `
        <div class="share-item">
          <div class="share-info">
            <span class="share-permission">${PERMISSION_LEVELS[share.permission_level]?.name || share.permission_level}</span>
            <span class="share-stats">${share.access_count || 0} views</span>
          </div>
          <div class="share-actions">
            <button class="btn btn-sm" onclick="copyToClipboard('${window.location.origin}${window.location.pathname}?share=${share.share_token}')">Copy</button>
            <button class="btn btn-sm btn-danger" onclick="revokeShare('${share.id}')">Revoke</button>
          </div>
        </div>
      `).join('');
    }

    function copyToClipboard(text) {
      navigator.clipboard.writeText(text).then(() => {
        alert('Copied to clipboard!');
      }).catch(() => {
        const temp = document.createElement('textarea');
        temp.value = text;
        document.body.appendChild(temp);
        temp.select();
        document.execCommand('copy');
        document.body.removeChild(temp);
        alert('Copied to clipboard!');
      });
    }

    async function revokeShare(shareId) {
      if (!confirm('Revoke this share link? Anyone with this link will no longer be able to access.')) return;

      try {
        const supabase = getSupabaseClient();
        if (!supabase) return;

        const { error } = await supabase
          .from('room_design_shares')
          .delete()
          .eq('id', shareId);

        if (error) throw error;

        loadActiveShares();
      } catch (err) {
        alert('Error revoking share: ' + err.message);
      }
    }

    // Log activity for notifications
    async function logActivity(type, elementIndex = null, elementName = null, commentText = null) {
      if (!SHARE_STATE.designId) return;

      try {
        const supabase = getSupabaseClient();
        if (!supabase) return;

        await supabase.from('design_activity').insert({
          design_id: SHARE_STATE.designId,
          share_id: SHARE_STATE.shareId,
          activity_type: type,
          element_index: elementIndex,
          element_name: elementName,
          comment_text: commentText
        });
      } catch (err) {
        console.error('Error logging activity:', err);
      }
    }

    // Load recent activity for a design
    async function loadRecentActivity() {
      if (!SHARE_STATE.designId) return;

      try {
        const supabase = getSupabaseClient();
        if (!supabase) return;

        const { data, error } = await supabase
          .from('design_activity')
          .select('*')
          .eq('design_id', SHARE_STATE.designId)
          .order('created_at', { ascending: false })
          .limit(20);

        if (error) throw error;

        renderActivityList(data || []);
      } catch (err) {
        console.error('Error loading activity:', err);
      }
    }

    // Render the activity list
    function renderActivityList(activities) {
      const container = document.getElementById('recentActivity');
      const list = document.getElementById('activityList');
      if (!container || !list) return;

      if (activities.length === 0) {
        container.style.display = 'none';
        return;
      }

      container.style.display = 'block';

      const icons = {
        view: 'ðŸ‘ï¸',
        comment: 'ðŸ’¬',
        approve: 'âœ“',
        reject: 'âœ—'
      };

      const formatTime = (timestamp) => {
        const date = new Date(timestamp);
        const now = new Date();
        const diffMs = now - date;
        const diffMins = Math.floor(diffMs / 60000);
        const diffHours = Math.floor(diffMs / 3600000);
        const diffDays = Math.floor(diffMs / 86400000);

        if (diffMins < 1) return 'Just now';
        if (diffMins < 60) return `${diffMins}m ago`;
        if (diffHours < 24) return `${diffHours}h ago`;
        if (diffDays < 7) return `${diffDays}d ago`;
        return date.toLocaleDateString();
      };

      const getActivityText = (activity) => {
        switch (activity.activity_type) {
          case 'view':
            return 'Someone viewed the design';
          case 'comment':
            return `Comment: "${activity.comment_text?.substring(0, 50)}${activity.comment_text?.length > 50 ? '...' : ''}"`;
          case 'approve':
            return `Approved: ${activity.element_name || 'an element'}`;
          case 'reject':
            return `Rejected: ${activity.element_name || 'an element'}`;
          default:
            return 'Activity';
        }
      };

      list.innerHTML = activities.map(activity => `
        <div class="activity-item">
          <div class="activity-icon ${activity.activity_type}">${icons[activity.activity_type] || 'â€¢'}</div>
          <div class="activity-content">
            <div class="activity-text">${getActivityText(activity)}</div>
            <div class="activity-time">${formatTime(activity.created_at)}</div>
          </div>
        </div>
      `).join('');
    }

    // Check URL for shared design token on page load
    function checkSharedDesignUrl() {
      const urlParams = new URLSearchParams(window.location.search);
      // Check for both 'share' and 'p' parameters
      const shareToken = urlParams.get('share') || urlParams.get('p');

      console.log('Checking shared design URL:', window.location.search);
      console.log('Share token found:', shareToken);

      if (shareToken) {
        console.log('Loading shared design with token:', shareToken);
        loadSharedDesign(shareToken);
      }
    }

    function clearCanvas() {
      if (!confirm('Clear all elements from canvas?\n\nRoom settings will be preserved.\nYour progress will still be auto-saved.')) return;

      elements = [];
      walls = walls.filter(w => w.type === 'area');
      selectedElement = null;

      updateProperties();
      updateElementSelector();
      updateItemPicker();
      calculateQuote();
      saveUndoState(); // This also triggers auto-save
      draw();
      render3D();

      showToast('Canvas cleared', 'info');
    }

    // ===== EXPORT FUNCTIONALITY =====
    function toggleExportMenu() {
      const menu = document.getElementById('exportMenu');
      menu.classList.toggle('show');

      // Close when clicking outside
      const closeHandler = (e) => {
        if (!e.target.closest('.export-dropdown')) {
          menu.classList.remove('show');
          document.removeEventListener('click', closeHandler);
        }
      };

      setTimeout(() => {
        document.addEventListener('click', closeHandler);
      }, 0);
    }

    function exportToPDF() {
      document.getElementById('exportMenu').classList.remove('show');

      const { jsPDF } = window.jspdf;
      const doc = new jsPDF('p', 'mm', 'letter');

      const projectName = document.getElementById('projectName').value || 'Room Design';
      const roomType = document.getElementById('roomType').value;
      const quoteTotal = document.getElementById('quoteTotal').textContent;

      // Header
      doc.setFillColor(184, 154, 91); // Gold color
      doc.rect(0, 0, 216, 35, 'F');

      doc.setTextColor(0, 0, 0);
      doc.setFontSize(24);
      doc.setFont('helvetica', 'bold');
      doc.text('Surprise Granite', 15, 20);

      doc.setFontSize(10);
      doc.setFont('helvetica', 'normal');
      doc.text('Room Design Proposal', 15, 28);

      // Project info
      doc.setTextColor(51, 51, 51);
      doc.setFontSize(16);
      doc.setFont('helvetica', 'bold');
      doc.text(projectName, 15, 50);

      doc.setFontSize(11);
      doc.setFont('helvetica', 'normal');
      doc.setTextColor(102, 102, 102);
      doc.text(`Room Type: ${roomType.charAt(0).toUpperCase() + roomType.slice(1)}`, 15, 58);
      doc.text(`Dimensions: ${roomWidth}' Ã— ${roomDepth}'`, 15, 65);
      doc.text(`Date: ${new Date().toLocaleDateString()}`, 15, 72);

      // Canvas image - 2D floor plan
      const canvas2D = document.getElementById('canvas2d');
      const imgData2D = canvas2D.toDataURL('image/png');
      doc.text('2D Floor Plan', 15, 85);
      doc.addImage(imgData2D, 'PNG', 15, 88, 85, 65);

      // 3D view if available
      if (renderer) {
        renderer.render(scene, camera);
        const imgData3D = renderer.domElement.toDataURL('image/png');
        doc.text('3D Visualization', 110, 85);
        doc.addImage(imgData3D, 'PNG', 110, 88, 85, 65);
      }

      // Elements list
      let yPos = 165;
      doc.setFontSize(14);
      doc.setFont('helvetica', 'bold');
      doc.setTextColor(51, 51, 51);
      doc.text('Design Elements', 15, yPos);
      yPos += 8;

      doc.setFontSize(10);
      doc.setFont('helvetica', 'normal');

      // Table header
      doc.setFillColor(240, 240, 240);
      doc.rect(15, yPos, 180, 8, 'F');
      doc.setTextColor(51, 51, 51);
      doc.text('Item', 18, yPos + 5.5);
      doc.text('Type', 75, yPos + 5.5);
      doc.text('Dimensions', 120, yPos + 5.5);
      doc.text('Material', 155, yPos + 5.5);
      yPos += 10;

      elements.forEach((el, index) => {
        if (yPos > 250) {
          doc.addPage();
          yPos = 20;
        }

        const bgColor = index % 2 === 0 ? [255, 255, 255] : [248, 248, 248];
        doc.setFillColor(...bgColor);
        doc.rect(15, yPos - 4, 180, 8, 'F');

        doc.setTextColor(51, 51, 51);
        doc.text(el.label || 'Element', 18, yPos + 1);
        doc.text(el.type.replace(/-/g, ' '), 75, yPos + 1);
        doc.text(`${el.width}' Ã— ${el.height}'`, 120, yPos + 1);
        doc.text(el.material || '-', 155, yPos + 1);
        yPos += 8;
      });

      // Quote total
      yPos += 10;
      doc.setFillColor(184, 154, 91);
      doc.rect(15, yPos, 180, 15, 'F');
      doc.setTextColor(0, 0, 0);
      doc.setFontSize(14);
      doc.setFont('helvetica', 'bold');
      doc.text('Estimated Total:', 20, yPos + 10);
      doc.text(quoteTotal, 155, yPos + 10);

      // Footer
      doc.setFontSize(8);
      doc.setTextColor(128, 128, 128);
      doc.text('This is an estimate only. Final pricing may vary based on material selection and installation requirements.', 15, 270);
      doc.text('Surprise Granite â€¢ surprisegranite.com â€¢ (623) 466-4177', 15, 276);

      doc.save(`${projectName.replace(/\s+/g, '-')}-proposal.pdf`);
    }

    function exportToJSON() {
      document.getElementById('exportMenu').classList.remove('show');

      const projectName = document.getElementById('projectName').value || 'Room Design';

      const designData = {
        version: '1.0',
        projectName: projectName,
        roomType: document.getElementById('roomType').value,
        roomWidth: roomWidth,
        roomDepth: roomDepth,
        elements: elements.map(el => ({
          id: el.id,
          type: el.type,
          label: el.label,
          x: el.x,
          y: el.y,
          width: el.width,
          height: el.height,
          rotation: el.rotation,
          color: el.color,
          material: el.material,
          materialId: el.materialId,
          category: el.category,
          catalogSku: el.catalogSku
        })),
        walls: walls,
        createdAt: new Date().toISOString()
      };

      const jsonStr = JSON.stringify(designData, null, 2);
      const blob = new Blob([jsonStr], { type: 'application/json' });
      const url = URL.createObjectURL(blob);

      const a = document.createElement('a');
      a.href = url;
      a.download = `${projectName.replace(/\s+/g, '-')}-design.json`;
      a.click();

      URL.revokeObjectURL(url);
    }

    function importFromJSON() {
      document.getElementById('exportMenu').classList.remove('show');

      const input = document.createElement('input');
      input.type = 'file';
      input.accept = '.json';

      input.onchange = (e) => {
        const file = e.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = (event) => {
          try {
            const data = JSON.parse(event.target.result);

            if (!data.version || !data.elements) {
              throw new Error('Invalid design file format');
            }

            // Restore design
            document.getElementById('projectName').value = data.projectName || 'Imported Design';
            document.getElementById('roomType').value = data.roomType || 'kitchen';
            roomWidth = data.roomWidth || 12;
            roomDepth = data.roomDepth || 10;
            document.getElementById('roomWidth').value = roomWidth;
            document.getElementById('roomDepth').value = roomDepth;

            // Restore elements
            elements = data.elements.map(el => ({
              ...el,
              textureImg: null // Will reload texture if needed
            }));

            // Reload textures for elements
            elements.forEach(el => {
              if (el.materialId) {
                const category = Object.keys(MATERIALS).find(cat =>
                  MATERIALS[cat].some(m => m.id === el.materialId)
                );
                if (category) {
                  const material = MATERIALS[category].find(m => m.id === el.materialId);
                  if (material && material.url) {
                    const img = new Image();
                    img.crossOrigin = 'anonymous';
                    img.onload = () => {
                      el.textureImg = img;
                      draw();
                    };
                    img.src = material.url;
                  }
                }
              }
            });

            walls = data.walls || walls;

            selectedElement = null;
            updateProperties();
            calculateQuote();
            saveUndoState();
            draw();
            update3DScene();

            alert('Design loaded successfully!');
          } catch (err) {
            alert('Error loading design: ' + err.message);
          }
        };
        reader.readAsText(file);
      };

      input.click();
    }

    function exportToPNG() {
      document.getElementById('exportMenu').classList.remove('show');

      const projectName = document.getElementById('projectName').value || 'Room Design';
      const currentView = document.querySelector('.view-btn.active').id;

      let canvas;
      if (currentView === 'view3D' && renderer) {
        renderer.render(scene, camera);
        canvas = renderer.domElement;
      } else {
        canvas = document.getElementById('canvas2d');
      }

      const link = document.createElement('a');
      link.download = `${projectName.replace(/\s+/g, '-')}-${currentView === 'view3D' ? '3d' : '2d'}.png`;
      link.href = canvas.toDataURL('image/png');
      link.click();
    }

    function exportToCSV() {
      document.getElementById('exportMenu').classList.remove('show');

      const projectName = document.getElementById('projectName').value || 'Room Design';

      let csv = 'Item,Type,Category,Width (ft),Height (ft),Material,SKU,Notes\n';

      elements.forEach(el => {
        const row = [
          `"${el.label || 'Element'}"`,
          `"${el.type.replace(/-/g, ' ')}"`,
          `"${el.category || ''}"`,
          el.width,
          el.height,
          `"${el.material || ''}"`,
          `"${el.catalogSku || ''}"`,
          `""`
        ];
        csv += row.join(',') + '\n';
      });

      // Summary section
      csv += '\n';
      csv += 'Summary\n';
      csv += `Project,${projectName}\n`;
      csv += `Room Type,${document.getElementById('roomType').value}\n`;
      csv += `Room Dimensions,${roomWidth}' x ${roomDepth}'\n`;
      csv += `Total Elements,${elements.length}\n`;
      csv += `Estimated Total,${document.getElementById('quoteTotal').textContent}\n`;
      csv += `Generated,${new Date().toLocaleString()}\n`;

      const blob = new Blob([csv], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);

      const a = document.createElement('a');
      a.href = url;
      a.download = `${projectName.replace(/\s+/g, '-')}-parts-list.csv`;
      a.click();

      URL.revokeObjectURL(url);
    }

    // ===== MY DESIGNS MODAL =====
    let currentDesignsTab = 'my';
    let allDesigns = { my: [], shared: [], recent: [] };

    function openMyDesignsModal() {
      document.getElementById('myDesignsModal').classList.add('active');
      loadMyDesigns();
    }

    // Save current design to local storage
    function saveDesignLocally() {
      const projectName = document.getElementById('projectName').value || 'Untitled Design';
      const roomType = document.getElementById('roomType').value || 'kitchen';

      const design = {
        id: 'local-' + Date.now(),
        name: projectName,
        room_type: roomType,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString(),
        room_width: roomWidth,
        room_depth: roomDepth,
        elements: elements.map(el => ({
          ...el,
          textureImg: null // Don't save image objects
        })),
        walls: walls,
        rooms: rooms.map(r => ({
          ...r,
          elements: r.elements?.map(el => ({ ...el, textureImg: null })) || []
        }))
      };

      // Get existing designs
      let designs = [];
      try {
        designs = JSON.parse(localStorage.getItem('room_designs') || '[]');
      } catch (e) {}

      // Add new design at the beginning
      designs.unshift(design);

      // Keep only last 20 designs
      designs = designs.slice(0, 20);

      localStorage.setItem('room_designs', JSON.stringify(designs));
      showSnapFeedback('Design saved locally');
      return design;
    }

    // Save design to cloud (Supabase) or locally
    async function saveDesignToCloud() {
      const saveBtn = document.getElementById('saveDesignBtn');
      const saveText = document.getElementById('saveDesignText');

      // Show saving state
      if (saveBtn) saveBtn.disabled = true;
      if (saveText) saveText.textContent = 'Saving...';

      try {
        // Check if user is logged in
        const user = window.SgAuth?.getUser();

        if (!user) {
          // Save locally if not logged in
          saveDesignLocally();
          showToast('Design saved locally. Sign in to save to cloud.', 'info');
          return;
        }

        const projectName = document.getElementById('projectName').value || 'Untitled Design';
        const roomType = document.getElementById('roomType').value || 'kitchen';

        // Save current room state
        saveCurrentRoomState();

        // Calculate quote total
        let quoteTotal = 0;
        elements.forEach(el => {
          const priceInfo = getElementPrice(el);
          const margin = getElementMargin(el) || 30;
          let cost = priceInfo?.price || 0;
          if (['countertop', 'backsplash', 'flooring', 'tile'].includes(el.type)) {
            cost = (el.width || 1) * (el.height || 1) * cost;
          }
          quoteTotal += cost * (1 + margin / 100);
        });

        // Get company name from profile
        let companyName = 'My Design';
        try {
          const profile = await window.SgAuth?.getProfile();
          if (profile?.company_name) {
            companyName = profile.company_name;
          } else if (profile?.full_name) {
            companyName = profile.full_name;
          }
        } catch (e) {
          console.log('Could not fetch profile:', e);
        }

        const designData = {
          user_id: user.id,
          name: projectName,
          room_type: roomType,
          room_width: roomWidth,
          room_depth: roomDepth,
          elements: elements.map(el => ({
            ...el,
            textureImg: null
          })),
          settings: {
            walls: walls,
            pricing_config: {
              globalMargin: PRICING_STATE.globalMargin,
              categoryMargins: PRICING_STATE.categoryMargins,
              customPrices: PRICING_STATE.customPrices
            },
            company_name: companyName,
            current_room_id: currentRoomId
          },
          rooms: rooms.map(room => ({
            ...room,
            elements: room.elements.map(el => ({ ...el, textureImg: null }))
          })),
          quote_total: quoteTotal
        };

        const SUPABASE_URL = 'https://ypeypgwsycxcagncgdur.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InlwZXlwZ3dzeWN4Y2FnbmNnZHVyIiwicm9sZSI6ImFub24iLCJpYXQiOjE3Njc3NTQ4MjMsImV4cCI6MjA4MzMzMDgyM30.R13pNv2FDtGhfeu7gUcttYNrQAbNYitqR4FIq3O2-ME';

        const session = await window.SgAuth?.getSession?.();
        const authToken = session?.access_token || SUPABASE_ANON_KEY;

        const headers = {
          'apikey': SUPABASE_ANON_KEY,
          'Authorization': `Bearer ${authToken}`,
          'Accept': 'application/json',
          'Content-Type': 'application/json',
          'Prefer': 'return=representation'
        };

        let designId = SHARE_STATE.designId;

        // If it's a local design ID, we need to create a new one in Supabase
        const isLocalDesign = designId && String(designId).startsWith('local-');
        if (isLocalDesign) {
          designId = null;
        }

        if (!designId) {
          // Create new design
          const designToken = generateToken(16);
          const insertData = {
            share_token: designToken,
            ...designData
          };

          const response = await fetch(`${SUPABASE_URL}/rest/v1/room_designs`, {
            method: 'POST',
            headers,
            body: JSON.stringify(insertData)
          });

          if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`Save failed: ${response.status} - ${errorText}`);
          }

          const data = await response.json();
          designId = Array.isArray(data) ? data[0]?.id : data.id;
          SHARE_STATE.designId = designId;
          SHARE_STATE.designToken = designToken;

          showToast('Design saved to cloud!', 'success');
        } else {
          // Update existing design
          const updateData = {
            ...designData,
            updated_at: new Date().toISOString()
          };

          const response = await fetch(`${SUPABASE_URL}/rest/v1/room_designs?id=eq.${designId}`, {
            method: 'PATCH',
            headers,
            body: JSON.stringify(updateData)
          });

          if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`Update failed: ${response.status} - ${errorText}`);
          }

          showToast('Design updated!', 'success');
        }

        // Also save locally as backup
        saveDesignLocally();

      } catch (err) {
        console.error('Error saving design:', err);
        // Fall back to local save
        saveDesignLocally();
        showToast('Saved locally. Cloud sync failed: ' + err.message, 'warning');
      } finally {
        // Reset button state
        if (saveBtn) saveBtn.disabled = false;
        if (saveText) saveText.textContent = 'Save';
      }
    }

    function switchDesignsTab(tab, btn) {
      currentDesignsTab = tab;
      document.querySelectorAll('.designs-tab').forEach(t => t.classList.remove('active'));
      btn.classList.add('active');
      renderDesignsGrid();
    }

    async function loadMyDesigns() {
      const grid = document.getElementById('designsGrid');
      const empty = document.getElementById('designsEmpty');
      grid.innerHTML = '<div class="designs-loading">Loading designs...</div>';
      empty.style.display = 'none';

      try {
        const supabase = getSupabaseClient();
        let user = getCurrentUser();

        // If no user but supabase exists, wait a moment for auth to restore
        // This handles the case where auth state is still being restored after login
        if (!user && supabase) {
          // Try to get session directly from Supabase
          try {
            const { data: { session } } = await supabase.auth.getSession();
            if (session?.user) {
              user = session.user;
            }
          } catch (authErr) {
            console.warn('Auth check in loadMyDesigns failed:', authErr);
          }
        }

        if (!supabase || !user) {
          // Load from localStorage
          const localDesigns = JSON.parse(localStorage.getItem('room_designs') || '[]');
          allDesigns.my = localDesigns.map((d, i) => ({
            id: d.id || `local-${i}`,  // Preserve original design ID
            name: d.name || 'Untitled Design',
            room_type: d.room_type || 'kitchen',
            created_at: d.created_at || new Date().toISOString(),
            elements_count: d.elements?.length || 0,
            comments_count: 0,
            preview: d.preview || null,
            isLocal: true,
            originalIndex: i  // Keep index for fallback lookup
          }));
          allDesigns.shared = [];
          allDesigns.recent = JSON.parse(localStorage.getItem('recent_designs') || '[]');
          renderDesignsGrid();
          return;
        }

        // Load user's own designs
        const { data: myDesigns, error: myError } = await supabase
          .from('room_designs')
          .select('*')
          .eq('user_id', user.id)
          .order('updated_at', { ascending: false });

        if (myError) throw myError;

        // Load designs shared with user
        const { data: sharedDesigns, error: sharedError } = await supabase
          .from('room_design_shares')
          .select('*, room_designs(*)')
          .neq('user_id', user.id)
          .order('share_date', { ascending: false });

        // Process designs
        allDesigns.my = (myDesigns || []).map(d => ({
          id: d.id,
          name: d.name || 'Untitled Design',
          room_type: d.room_type || 'kitchen',
          created_at: d.created_at,
          updated_at: d.updated_at,
          elements_count: d.elements?.length || 0,
          comments_count: d.comments_count || 0,
          preview: d.thumbnail_url || d.preview_url,
          share_token: d.share_token
        }));

        allDesigns.shared = (sharedDesigns || []).filter(s => s.room_designs).map(s => ({
          id: s.design_id,
          name: s.room_designs?.name || 'Shared Design',
          room_type: s.room_designs?.room_type || 'kitchen',
          created_at: s.share_date,
          shared_by: s.shared_by_name || 'Someone',
          permission: s.permission_level,
          share_token: s.share_token,
          elements_count: 0,
          comments_count: s.comments_count || 0
        }));

        // Load recent from localStorage
        allDesigns.recent = JSON.parse(localStorage.getItem('recent_designs') || '[]');

        renderDesignsGrid();

      } catch (err) {
        console.error('Error loading designs:', err);
        grid.innerHTML = '<div class="designs-loading">Error loading designs</div>';
      }
    }

    function renderDesignsGrid() {
      const grid = document.getElementById('designsGrid');
      const empty = document.getElementById('designsEmpty');

      const designs = allDesigns[currentDesignsTab] || [];

      if (designs.length === 0) {
        grid.innerHTML = '';
        empty.style.display = 'block';
        return;
      }

      empty.style.display = 'none';

      const formatDate = (date) => {
        const d = new Date(date);
        const now = new Date();
        const diffDays = Math.floor((now - d) / 86400000);
        if (diffDays === 0) return 'Today';
        if (diffDays === 1) return 'Yesterday';
        if (diffDays < 7) return `${diffDays} days ago`;
        return d.toLocaleDateString();
      };

      grid.innerHTML = designs.map((design, idx) => `
        <div class="design-card" onclick="loadDesignFromList('${design.id}', '${design.share_token || ''}', ${design.isLocal || false}, ${design.originalIndex !== undefined ? design.originalIndex : idx})">
          <div class="design-card-preview">
            ${design.preview
              ? `<img src="${design.preview}" alt="${design.name}">`
              : `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                  <rect x="3" y="3" width="18" height="18" rx="2"/>
                  <path d="M3 9h18M9 21V9"/>
                </svg>`
            }
            ${currentDesignsTab === 'shared'
              ? `<span class="design-card-badge">${design.permission || 'View'}</span>`
              : design.share_token
                ? '<span class="design-card-badge">Shared</span>'
                : ''
            }
          </div>
          <div class="design-card-info">
            <div class="design-card-name">${design.name}</div>
            <div class="design-card-meta">
              <span class="design-card-date">
                <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <circle cx="12" cy="12" r="10"/><path d="M12 6v6l4 2"/>
                </svg>
                ${formatDate(design.created_at)}
              </span>
              ${design.comments_count > 0 ? `
                <span class="design-card-comments">
                  <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"/>
                  </svg>
                  ${design.comments_count}
                </span>
              ` : ''}
            </div>
          </div>
        </div>
      `).join('');
    }

    function filterDesigns(query) {
      const designs = allDesigns[currentDesignsTab] || [];
      const filtered = designs.filter(d =>
        d.name.toLowerCase().includes(query.toLowerCase())
      );

      const grid = document.getElementById('designsGrid');
      const empty = document.getElementById('designsEmpty');

      if (filtered.length === 0 && query) {
        grid.innerHTML = '';
        empty.style.display = 'block';
        return;
      }

      // Temporarily override for rendering
      const original = allDesigns[currentDesignsTab];
      allDesigns[currentDesignsTab] = filtered;
      renderDesignsGrid();
      allDesigns[currentDesignsTab] = original;
    }

    // ===== HISTORY STATE MANAGEMENT =====
    // Stores the previous design state when navigating between designs
    let previousDesignState = null;

    function saveCurrentDesignToHistory() {
      // Save current design state so we can restore it on back navigation
      previousDesignState = {
        elements: JSON.parse(JSON.stringify(elements)),
        walls: JSON.parse(JSON.stringify(walls)),
        roomWidth: roomWidth,
        roomDepth: roomDepth,
        projectName: document.getElementById('projectName').value,
        roomType: document.getElementById('roomType').value,
        designId: SHARE_STATE.designId
      };
      // Store in sessionStorage for persistence across page reloads
      sessionStorage.setItem('sg_previous_design', JSON.stringify(previousDesignState));
    }

    function restorePreviousDesign() {
      // Try to get from memory first, then sessionStorage
      let state = previousDesignState;
      if (!state) {
        const stored = sessionStorage.getItem('sg_previous_design');
        if (stored) {
          state = JSON.parse(stored);
        }
      }

      if (state) {
        elements = state.elements || [];
        walls = state.walls || [];
        roomWidth = state.roomWidth || 12;
        roomDepth = state.roomDepth || 14;
        document.getElementById('projectName').value = state.projectName || 'New Design';
        document.getElementById('roomType').value = state.roomType || 'kitchen';
        document.getElementById('roomWidth').value = roomWidth;
        document.getElementById('roomDepth').value = roomDepth;
        SHARE_STATE.designId = state.designId;

        // Reload textures
        elements.forEach(el => {
          if (el.texture) {
            const img = new Image();
            img.crossOrigin = 'anonymous';
            img.onload = () => {
              el.textureImg = img;
              draw();
            };
            img.src = el.texture;
          }
        });

        calculateQuote();
        draw();
        update3DScene();
        showSnapFeedback('Returned to previous design');
        return true;
      }
      return false;
    }

    // Handle browser back/forward navigation
    window.addEventListener('popstate', function(event) {
      console.log('Popstate event:', event.state);

      // Check if we have a previous design to restore
      if (event.state === null || !event.state.shareToken) {
        // Going back to the main page (no share token)
        if (restorePreviousDesign()) {
          // Clear the URL if it has a share token
          if (window.location.search.includes('share=')) {
            history.replaceState({}, '', window.location.pathname);
          }
        }
      } else if (event.state.shareToken) {
        // Navigating to a shared design
        loadSharedDesign(event.state.shareToken);
      } else if (event.state.designId && event.state.isLocal) {
        // Navigating to a local design
        const localDesigns = JSON.parse(localStorage.getItem('room_designs') || '[]');
        const design = localDesigns.find(d => d.id === event.state.designId);
        if (design) {
          loadLocalDesign(design);
        }
      }
    });

    async function loadDesignFromList(id, shareToken, isLocal, originalIndex) {
      closeModal('myDesignsModal');

      if (isLocal) {
        const localDesigns = JSON.parse(localStorage.getItem('room_designs') || '[]');
        // Find design by ID first, then by index as fallback
        let design = localDesigns.find(d => d.id === id);
        if (!design && originalIndex !== undefined && localDesigns[originalIndex]) {
          design = localDesigns[originalIndex];
        }
        if (design) {
          // Save current state to history before loading new design
          saveCurrentDesignToHistory();
          loadLocalDesign(design);
          // Update URL without reload
          history.pushState({ designId: id, isLocal: true }, '', window.location.pathname);
          showSnapFeedback(`Loaded: ${design.name || 'Untitled Design'}`);
        } else {
          showSnapFeedback('Design not found');
        }
        return;
      }

      if (shareToken) {
        // Save current state to history before loading shared design
        saveCurrentDesignToHistory();
        // Load shared design without full page reload
        await loadSharedDesign(shareToken);
        // Update URL with share token (pushState instead of reload)
        history.pushState({ shareToken: shareToken }, '', `?share=${shareToken}`);
        return;
      }

      // Load directly from database
      try {
        const supabase = getSupabaseClient();
        const { data, error } = await supabase
          .from('room_designs')
          .select('*')
          .eq('id', id)
          .single();

        if (error) throw error;
        if (data?.design_data) {
          loadDesignData(data.design_data);
          SHARE_STATE.designId = id;
        }
      } catch (err) {
        console.error('Error loading design:', err);
        showSnapFeedback('Error loading design');
      }
    }

    // Load a locally saved design
    function loadLocalDesign(design) {
      // Restore room dimensions
      if (design.room_width) roomWidth = design.room_width;
      if (design.room_depth) roomDepth = design.room_depth;

      // Restore elements
      if (design.elements) {
        elements = design.elements.map(el => ({
          ...el,
          textureImg: null
        }));

        // Reload textures
        elements.forEach(el => {
          if (el.texture) {
            const img = new Image();
            img.crossOrigin = 'anonymous';
            img.onload = () => {
              el.textureImg = img;
              draw();
            };
            img.src = el.texture;
          }
        });
      }

      // Restore walls
      if (design.walls) {
        walls = design.walls;
      }

      // Update project name
      if (design.name) {
        document.getElementById('projectName').value = design.name;
      }

      // Update room type
      if (design.room_type) {
        document.getElementById('roomType').value = design.room_type;
      }

      // Update UI
      document.getElementById('roomWidth').value = roomWidth;
      document.getElementById('roomDepth').value = roomDepth;

      // Set local design ID for chat
      SHARE_STATE.designId = design.id;

      // Redraw
      updateCanvasSize();
      draw();
      update3DScene();
      calculateQuote();
      updateProperties();

      showSnapFeedback(`Loaded: ${design.name || 'Design'}`);
    }

    // Add recent design tracking
    function trackRecentDesign(design) {
      let recent = JSON.parse(localStorage.getItem('recent_designs') || '[]');
      // Remove if already exists
      recent = recent.filter(r => r.id !== design.id);
      // Add to front
      recent.unshift({
        id: design.id,
        name: design.name,
        share_token: design.share_token,
        created_at: new Date().toISOString()
      });
      // Keep only last 10
      recent = recent.slice(0, 10);
      localStorage.setItem('recent_designs', JSON.stringify(recent));
    }

    // ===== NOTIFICATIONS =====
    function requestNotificationPermission() {
      if ('Notification' in window && Notification.permission === 'default') {
        Notification.requestPermission();
      }
    }

    function showNotification(title, body) {
      // In-app toast
      const toast = document.getElementById('notificationToast');
      document.getElementById('notificationTitle').textContent = title;
      document.getElementById('notificationBody').textContent = body;
      toast.classList.add('show');

      setTimeout(() => {
        toast.classList.remove('show');
      }, 5000);

      // Browser notification
      if ('Notification' in window && Notification.permission === 'granted') {
        new Notification(title, {
          body: body,
          icon: '/images/logo.png',
          badge: '/images/logo.png'
        });
      }
    }

    function hideNotification() {
      document.getElementById('notificationToast').classList.remove('show');
    }

    function playNotificationSound() {
      // Create a simple notification beep
      try {
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const oscillator = audioCtx.createOscillator();
        const gainNode = audioCtx.createGain();

        oscillator.connect(gainNode);
        gainNode.connect(audioCtx.destination);

        oscillator.frequency.value = 800;
        oscillator.type = 'sine';
        gainNode.gain.value = 0.1;

        oscillator.start();
        setTimeout(() => oscillator.stop(), 100);
      } catch (e) {
        // Audio not available
      }
    }

    // Helper function for consistent color from string
    function stringToColor(str) {
      let hash = 0;
      for (let i = 0; i < str.length; i++) {
        hash = str.charCodeAt(i) + ((hash << 5) - hash);
      }
      const hue = hash % 360;
      return `hsl(${hue}, 65%, 45%)`;
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

  </script>
</body>
</html>
