<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Room Designer Pro | Remodely.ai | Surprise Granite</title>
  <link rel="icon" href="https://cdn.prod.website-files.com/6456ce4476abb25581fbad0c/6456ce4476abb269c6fbb176_Surprise-Granite-favicon-32x32px.png">
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">

  <!-- Three.js for 3D -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>

  <!-- Post-processing for enhanced visuals -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/UnpackDepthRGBAShader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/SAOShader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/DepthLimitedBlurShader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/SAOPass.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/FXAAShader.js"></script>

  <!-- Centralized Configuration -->
  <script src="/js/config.js"></script>

  <!-- Supabase -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script src="/js/supabase-init.js"></script>

  <!-- Auth System -->
  <script src="/js/sg-auth.js"></script>
  <script src="/js/auth-state.js"></script>

  <!-- PDF Export -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

  <!-- SheetJS for Excel/CSV parsing -->
  <script src="https://cdn.sheetjs.com/xlsx-0.20.1/package/dist/xlsx.full.min.js"></script>

  <!-- Stripe.js for Payment Processing -->
  <script src="https://js.stripe.com/v3/"></script>

  <!-- Slab Layout Module -->
  <link rel="stylesheet" href="slab-layout.css">

  <style>
    :root {
      --primary: #6366f1;
      --primary-dark: #4f46e5;
      --gold: #f9cb00;
      --gold-dark: #d4ab00;
      --dark: #0f0f1a;
      --dark-deep: #0a0a14;
      --dark-surface: #1a1a2e;
      --dark-elevated: #252540;
      --dark-hover: #2d2d4a;
      --text: #ffffff;
      --text-secondary: rgba(255,255,255,0.7);
      --text-muted: rgba(255,255,255,0.5);
      --border: rgba(255,255,255,0.1);
      --border-color: rgba(255,255,255,0.1);
      --panel-bg: #1a1a2e;
      --hover-bg: #2d2d4a;
      --text-primary: #ffffff;
      --success: #10b981;
      --warning: #f59e0b;
      --error: #ef4444;
      --remodely-gradient: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
    }

    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      font-family: 'Inter', -apple-system, sans-serif;
      background: var(--dark);
      color: var(--text);
      min-height: 100vh;
      overflow: hidden;
    }

    .app {
      height: 100vh;
      max-height: 100vh;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    /* Header - MUST stay at top */
    .header {
      background: linear-gradient(90deg, rgba(30, 30, 46, 0.98) 0%, rgba(26, 26, 38, 0.98) 100%);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      border-bottom: 1px solid var(--border);
      padding: 0 20px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      height: 56px;
      min-height: 56px;
      max-height: 56px;
      flex-shrink: 0;
      flex-grow: 0;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
      position: relative;
      z-index: 100;
    }

    .header-left {
      display: flex;
      align-items: center;
      gap: 20px;
    }

    .logo-group {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .logo {
      display: flex;
      align-items: center;
      gap: 8px;
      text-decoration: none;
    }

    .logo img {
      height: 28px;
    }

    .logo-divider {
      width: 1px;
      height: 24px;
      background: var(--border);
    }

    .powered-by {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 11px;
      color: var(--text-muted);
    }

    .powered-by .remodely-badge {
      background: var(--remodely-gradient);
      padding: 3px 8px;
      border-radius: 4px;
      font-weight: 600;
      font-size: 10px;
      color: white;
    }

    .project-input {
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 6px 12px;
      color: var(--text);
      font-size: 14px;
      font-weight: 500;
      min-width: 200px;
    }

    .project-input:focus {
      outline: none;
      border-color: var(--primary);
    }

    .header-center {
      display: flex;
      gap: 4px;
      background: var(--dark-elevated);
      padding: 4px;
      border-radius: 8px;
    }

    .view-btn {
      padding: 8px 16px;
      background: transparent;
      border: none;
      color: var(--text-muted);
      font-size: 13px;
      font-weight: 500;
      cursor: pointer;
      border-radius: 6px;
      transition: all 0.2s;
    }

    .view-btn:hover {
      color: var(--text);
    }

    .view-btn.active {
      background: var(--primary);
      color: white;
    }

    .header-zoom-controls {
      display: flex;
      align-items: center;
      gap: 2px;
      margin-left: 12px;
      padding-left: 12px;
      border-left: 1px solid var(--border);
    }

    .header-zoom-btn {
      width: 28px;
      height: 28px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: transparent;
      border: none;
      border-radius: 4px;
      color: var(--text-muted);
      cursor: pointer;
      font-size: 16px;
      font-weight: 500;
      transition: all 0.15s ease;
    }

    .header-zoom-btn:hover {
      background: rgba(255, 255, 255, 0.1);
      color: var(--text);
    }

    .header-zoom-level {
      font-size: 11px;
      font-weight: 600;
      color: var(--gold);
      min-width: 40px;
      text-align: center;
      padding: 4px 6px;
      background: rgba(249, 203, 0, 0.1);
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.15s ease;
    }

    .header-zoom-level:hover {
      background: rgba(249, 203, 0, 0.2);
    }

    .header-right {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    /* User Account Menu */
    .user-account-menu {
      position: relative;
    }

    .user-menu-btn {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 12px;
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      border-radius: 8px;
      color: var(--text-primary);
      cursor: pointer;
      font-size: 13px;
      font-weight: 500;
      transition: all 0.2s;
    }

    .user-menu-btn:hover {
      background: var(--hover-bg);
      border-color: var(--gold);
    }

    .user-avatar-small {
      width: 28px;
      height: 28px;
      border-radius: 50%;
      background: linear-gradient(135deg, var(--gold), #cca600);
      color: #1a1a2e;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 700;
      font-size: 12px;
    }

    .user-name-display {
      max-width: 100px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .user-dropdown {
      position: absolute;
      top: 100%;
      right: 0;
      margin-top: 8px;
      background: var(--dark-surface);
      border: 1px solid var(--border);
      border-radius: 10px;
      min-width: 200px;
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
      opacity: 0;
      visibility: hidden;
      transform: translateY(-10px);
      transition: all 0.2s;
      z-index: 9999;
      pointer-events: none;
    }

    .user-dropdown.show {
      opacity: 1;
      visibility: visible;
      transform: translateY(0);
      pointer-events: auto;
    }

    .dropdown-item {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 12px 16px;
      color: var(--text-secondary);
      text-decoration: none;
      font-size: 14px;
      cursor: pointer;
      transition: all 0.2s;
      border: none;
      background: none;
      width: 100%;
      text-align: left;
    }

    .dropdown-item:first-child {
      border-radius: 10px 10px 0 0;
    }

    .dropdown-item:last-child {
      border-radius: 0 0 10px 10px;
    }

    .dropdown-item:hover {
      background: var(--hover-bg);
      color: var(--text-primary);
    }

    .dropdown-item svg {
      opacity: 0.7;
    }

    .dropdown-item:hover svg {
      opacity: 1;
    }

    .dropdown-divider {
      height: 1px;
      background: var(--border-color);
      margin: 4px 0;
    }

    .dropdown-item.logout-item {
      color: #ff6b6b;
    }

    .dropdown-item.logout-item:hover {
      background: rgba(255, 107, 107, 0.1);
      color: #ff6b6b;
    }

    .dropdown-item.google-signin {
      background: #fff;
      color: #3c4043;
      font-weight: 500;
      border-bottom: 1px solid var(--border);
    }

    .dropdown-item.google-signin:hover {
      background: #f8f9fa;
    }

    .dropdown-item.google-signin svg {
      opacity: 1;
    }

    .btn {
      padding: 8px 16px;
      border-radius: 6px;
      font-size: 13px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      gap: 6px;
      border: none;
    }

    .btn-secondary {
      background: var(--dark-elevated);
      color: var(--text);
      border: 1px solid var(--border);
    }

    .btn-secondary:hover {
      background: var(--dark-hover);
    }

    .btn-primary {
      background: var(--gold);
      color: #000;
    }

    .btn-primary:hover {
      background: var(--gold-dark);
    }

    .btn-sm {
      padding: 6px 10px;
      font-size: 11px;
    }

    /* Export Dropdown */
    .export-dropdown {
      position: relative;
    }

    .export-menu {
      position: absolute;
      top: 100%;
      right: 0;
      margin-top: 4px;
      background: var(--dark-surface);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 8px 0;
      min-width: 180px;
      box-shadow: 0 10px 40px rgba(0,0,0,0.4);
      z-index: 1000;
      display: none;
    }

    .export-menu.show {
      display: block;
    }

    .export-menu button {
      width: 100%;
      padding: 10px 16px;
      background: none;
      border: none;
      color: var(--text);
      font-size: 13px;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 10px;
      text-align: left;
    }

    .export-menu button:hover {
      background: var(--dark-hover);
    }

    .export-menu button svg {
      flex-shrink: 0;
      color: var(--text-muted);
    }

    .export-divider {
      height: 1px;
      background: var(--border);
      margin: 8px 0;
    }

    /* Main Layout */
    .main {
      flex: 1;
      display: flex;
      overflow: hidden;
      min-height: 0; /* Prevents flex children from overflowing */
      max-height: calc(100vh - 56px); /* Header height is 56px */
    }

    /* Sidebar */
    .sidebar {
      width: 220px;
      min-width: 220px;
      max-width: 220px;
      background: linear-gradient(180deg, rgba(30, 30, 46, 0.98) 0%, rgba(26, 26, 38, 0.98) 100%);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      border-right: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      flex-shrink: 0;
      flex-grow: 0;
      overflow-y: auto;
      overflow-x: hidden;
      box-shadow: 2px 0 8px rgba(0, 0, 0, 0.15);
      max-height: 100%;
    }

    /* =============================================
       UPGRADED SIDEBAR SECTIONS - Enhanced UX
       ============================================= */
    .sidebar-section {
      border-bottom: 1px solid rgba(255, 255, 255, 0.05);
      transition: background 0.2s ease;
    }

    .sidebar-section:hover {
      background: rgba(255, 255, 255, 0.01);
    }

    .sidebar-header {
      padding: 8px 10px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      cursor: pointer;
      user-select: none;
      transition: all 0.2s ease;
      position: relative;
    }

    .sidebar-header::before {
      content: '';
      position: absolute;
      left: 0;
      top: 50%;
      transform: translateY(-50%);
      width: 3px;
      height: 0;
      background: var(--gold);
      border-radius: 0 2px 2px 0;
      transition: height 0.2s ease;
    }

    .sidebar-header:hover {
      background: rgba(255, 255, 255, 0.03);
    }

    .sidebar-header:hover::before {
      height: 60%;
    }

    .sidebar-section.expanded .sidebar-header::before {
      height: 80%;
    }

    .sidebar-title {
      font-size: 10px;
      font-weight: 600;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.4px;
      transition: color 0.2s ease;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .sidebar-header:hover .sidebar-title {
      color: var(--text);
    }

    .sidebar-section.expanded .sidebar-title {
      color: var(--gold);
    }

    .sidebar-toggle {
      color: var(--text-muted);
      font-size: 10px;
      transition: transform 0.25s ease, color 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      width: 20px;
      height: 20px;
    }

    .sidebar-content.collapsed + .sidebar-header .sidebar-toggle,
    .sidebar-header:has(+ .sidebar-content.collapsed) .sidebar-toggle {
      transform: rotate(-90deg);
    }

    .sidebar-header:hover .sidebar-toggle {
      color: var(--text);
    }

    .sidebar-content {
      padding: 0 8px 8px;
      max-height: 1000px;
      overflow: hidden;
      transition: max-height 0.3s ease, padding 0.3s ease, opacity 0.2s ease;
      opacity: 1;
    }

    .sidebar-content.collapsed {
      max-height: 0;
      padding: 0 8px;
      opacity: 0;
    }

    /* Room List */
    .room-list {
      display: flex;
      flex-direction: column;
      gap: 4px;
      max-height: 200px;
      overflow-y: auto;
    }

    .room-item {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 10px;
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .room-item:hover {
      background: var(--dark-surface);
      border-color: var(--primary);
    }

    .room-item.active {
      background: rgba(249, 203, 0, 0.1);
      border-color: var(--gold);
    }

    .room-icon {
      font-size: 16px;
    }

    .room-name {
      flex: 1;
      font-size: 12px;
      font-weight: 500;
      color: var(--text-primary);
    }

    .room-size {
      font-size: 10px;
      color: var(--text-secondary);
      background: var(--dark);
      padding: 2px 6px;
      border-radius: 4px;
    }

    .room-delete-btn {
      width: 18px;
      height: 18px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: transparent;
      border: none;
      color: var(--text-secondary);
      font-size: 14px;
      cursor: pointer;
      border-radius: 4px;
      opacity: 0;
      transition: all 0.2s;
    }

    .room-item:hover .room-delete-btn {
      opacity: 1;
    }

    .room-delete-btn:hover {
      background: var(--error);
      color: white;
    }

    .room-edit-btn {
      width: 18px;
      height: 18px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: transparent;
      border: none;
      color: var(--text-secondary);
      font-size: 11px;
      cursor: pointer;
      border-radius: 4px;
      opacity: 0;
      transition: all 0.2s;
      margin-right: 4px;
    }

    .room-item:hover .room-edit-btn {
      opacity: 1;
    }

    .room-edit-btn:hover {
      background: var(--primary);
      color: white;
    }

    /* Floor Plans Grid */
    .floorplan-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 8px;
    }

    .floorplan-item {
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 10px;
      cursor: pointer;
      transition: all 0.2s;
      text-align: center;
    }

    .floorplan-item:hover {
      background: var(--dark-hover);
      border-color: var(--primary);
    }

    .floorplan-item.active {
      border-color: var(--primary);
      background: rgba(99, 102, 241, 0.15);
    }

    .floorplan-preview {
      width: 100%;
      height: 40px;
      margin-bottom: 6px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .floorplan-preview svg {
      width: 100%;
      height: 100%;
    }

    .floorplan-name {
      font-size: 10px;
      color: var(--text-secondary);
    }

    /* =============================================
       FAVORITES SECTION
       ============================================= */
    .favorites-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 6px;
      min-height: 60px;
    }

    .favorites-empty, .notes-empty {
      grid-column: 1 / -1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 16px;
      color: var(--text-muted);
      font-size: 11px;
      gap: 4px;
    }

    .favorite-item {
      aspect-ratio: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 6px;
      cursor: pointer;
      transition: all 0.2s;
      position: relative;
    }

    .favorite-item:hover {
      background: var(--dark-hover);
      border-color: var(--gold);
      transform: scale(1.05);
    }

    .favorite-item .fav-icon {
      font-size: 18px;
      margin-bottom: 2px;
    }

    .favorite-item .fav-label {
      font-size: 8px;
      color: var(--text-muted);
      text-align: center;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      width: 100%;
    }

    .favorite-item .fav-remove {
      position: absolute;
      top: -4px;
      right: -4px;
      width: 16px;
      height: 16px;
      background: #ef4444;
      border-radius: 50%;
      display: none;
      align-items: center;
      justify-content: center;
      font-size: 10px;
      color: white;
      cursor: pointer;
    }

    .favorite-item:hover .fav-remove {
      display: flex;
    }

    /* =============================================
       NOTES SECTION
       ============================================= */
    .notes-list {
      display: flex;
      flex-direction: column;
      gap: 6px;
      max-height: 200px;
      overflow-y: auto;
    }

    .note-item {
      display: flex;
      align-items: flex-start;
      gap: 8px;
      padding: 8px;
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .note-item:hover {
      background: var(--dark-hover);
      border-color: var(--gold);
    }

    .note-item.selected {
      border-color: var(--gold);
      background: rgba(249, 203, 0, 0.1);
    }

    .note-color {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      flex-shrink: 0;
      margin-top: 2px;
    }

    .note-content {
      flex: 1;
      min-width: 0;
    }

    .note-text {
      font-size: 11px;
      color: var(--text);
      line-height: 1.3;
      word-break: break-word;
    }

    .note-meta {
      font-size: 9px;
      color: var(--text-muted);
      margin-top: 2px;
    }

    .note-actions {
      display: flex;
      gap: 4px;
      opacity: 0;
      transition: opacity 0.2s;
    }

    .note-item:hover .note-actions {
      opacity: 1;
    }

    .note-action-btn {
      width: 18px;
      height: 18px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(255, 255, 255, 0.1);
      border: none;
      border-radius: 4px;
      color: var(--text-muted);
      cursor: pointer;
      font-size: 10px;
    }

    .note-action-btn:hover {
      background: rgba(255, 255, 255, 0.2);
      color: var(--text);
    }

    /* Note Pin on Canvas */
    .canvas-note-pin {
      position: absolute;
      width: 24px;
      height: 24px;
      background: var(--gold);
      border-radius: 50% 50% 50% 0;
      transform: rotate(-45deg);
      cursor: pointer;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
      z-index: 100;
      transition: transform 0.2s;
    }

    .canvas-note-pin:hover {
      transform: rotate(-45deg) scale(1.1);
    }

    .canvas-note-pin::after {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) rotate(45deg);
      width: 8px;
      height: 8px;
      background: var(--dark-primary);
      border-radius: 50%;
    }

    .canvas-note-pin.red { background: #ef4444; }
    .canvas-note-pin.blue { background: #3b82f6; }
    .canvas-note-pin.green { background: #22c55e; }
    .canvas-note-pin.purple { background: #a855f7; }
    .canvas-note-pin.orange { background: #f97316; }

    /* Note Tooltip */
    .note-tooltip {
      position: absolute;
      background: var(--dark-surface);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 10px;
      max-width: 200px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      z-index: 101;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.2s;
    }

    .note-tooltip.show {
      opacity: 1;
    }

    /* Smart Guides */
    .smart-guide {
      position: absolute;
      background: rgba(99, 102, 241, 0.8);
      pointer-events: none;
      z-index: 50;
    }

    .smart-guide.horizontal {
      height: 1px;
      width: 100%;
    }

    .smart-guide.vertical {
      width: 1px;
      height: 100%;
    }

    .smart-guide-label {
      position: absolute;
      background: rgba(99, 102, 241, 0.9);
      color: white;
      font-size: 9px;
      padding: 2px 4px;
      border-radius: 2px;
      white-space: nowrap;
    }

    /* Element Grouping Indicator */
    .group-indicator {
      position: absolute;
      border: 2px dashed var(--gold);
      border-radius: 4px;
      pointer-events: none;
      z-index: 45;
    }

    .group-badge {
      position: absolute;
      top: -10px;
      left: 4px;
      background: var(--gold);
      color: var(--dark-primary);
      font-size: 9px;
      font-weight: 600;
      padding: 1px 5px;
      border-radius: 3px;
    }

    /* Measurement Overlay */
    .measurement-overlay { position: absolute; pointer-events: none; z-index: 100; }
    .measure-dimension { position: absolute; display: flex; align-items: center; justify-content: center; }
    .measure-dimension.measure-width { height: 1px; background: var(--gold-primary); }
    .measure-dimension.measure-width::before, .measure-dimension.measure-width::after { content: ''; position: absolute; width: 1px; height: 8px; background: var(--gold-primary); }
    .measure-dimension.measure-width::before { left: 0; }
    .measure-dimension.measure-width::after { right: 0; }
    .measure-dimension.measure-height { width: 1px; background: var(--gold-primary); flex-direction: column; }
    .measure-dimension.measure-height::before, .measure-dimension.measure-height::after { content: ''; position: absolute; height: 1px; width: 8px; background: var(--gold-primary); }
    .measure-dimension.measure-height::before { top: 0; }
    .measure-dimension.measure-height::after { bottom: 0; }
    .measure-dimension span { position: absolute; background: var(--dark-surface); color: var(--gold-primary); font-size: 10px; font-weight: 600; padding: 2px 6px; border-radius: 4px; white-space: nowrap; }
    .measure-dimension.measure-width span { top: -18px; }
    .measure-dimension.measure-height span { left: 8px; top: 50%; transform: translateY(-50%); }

    /* Quick Actions Toolbar */
    .quick-actions-toolbar { position: fixed; display: flex; gap: 4px; padding: 6px; background: var(--dark-surface); border: 1px solid var(--border); border-radius: 8px; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3); z-index: 1000; }
    .quick-actions-toolbar button { width: 32px; height: 32px; display: flex; align-items: center; justify-content: center; background: rgba(255, 255, 255, 0.05); border: 1px solid transparent; border-radius: 6px; font-size: 14px; cursor: pointer; transition: all 0.2s; }
    .quick-actions-toolbar button:hover { background: var(--gold-primary); border-color: var(--gold-primary); }

    /* Alignment Toolbar */
    .alignment-toolbar { display: flex; gap: 4px; padding: 8px; background: var(--dark-elevated); border-radius: 8px; }
    .alignment-toolbar button { width: 28px; height: 28px; display: flex; align-items: center; justify-content: center; background: rgba(255, 255, 255, 0.05); border: 1px solid var(--border); border-radius: 4px; font-size: 12px; cursor: pointer; transition: all 0.2s; }
    .alignment-toolbar button:hover { background: var(--gold-primary); color: var(--dark-primary); }

    /* Pro Feature Modals */
    .shortcuts-modal, .stats-modal, .cost-summary-modal, .element-search-modal {
      position: fixed; inset: 0; background: rgba(0,0,0,0.7); display: flex; align-items: center; justify-content: center; z-index: 10000;
    }
    .shortcuts-content, .stats-content, .cost-summary-content, .element-search-content {
      background: var(--dark-surface); border: 1px solid var(--border); border-radius: 12px; max-width: 500px; width: 90%; max-height: 80vh; overflow: hidden;
    }
    .shortcuts-header, .stats-header, .cost-summary-header {
      display: flex; justify-content: space-between; align-items: center; padding: 16px 20px; border-bottom: 1px solid var(--border);
    }
    .shortcuts-header h3, .stats-header h3, .cost-summary-header h3 { margin: 0; font-size: 16px; color: var(--text); }
    .shortcuts-header button, .stats-header button, .cost-summary-header button {
      width: 28px; height: 28px; background: rgba(255,255,255,0.1); border: none; border-radius: 6px; color: var(--text-muted); cursor: pointer; font-size: 18px;
    }
    .shortcuts-header button:hover, .stats-header button:hover, .cost-summary-header button:hover { background: rgba(255,255,255,0.2); color: var(--text); }
    .shortcuts-body, .stats-body, .cost-summary-body { padding: 16px 20px; overflow-y: auto; max-height: 60vh; }
    .shortcut-row { display: flex; align-items: center; gap: 12px; padding: 8px 0; border-bottom: 1px solid rgba(255,255,255,0.05); }
    .shortcut-row:last-child { border-bottom: none; }
    .shortcut-row kbd { min-width: 80px; padding: 4px 8px; background: var(--dark-elevated); border: 1px solid var(--border); border-radius: 4px; font-family: monospace; font-size: 11px; color: var(--gold-primary); text-align: center; }
    .shortcut-row span { color: var(--text-secondary); font-size: 13px; }

    /* Stats Modal */
    .stats-body { display: grid; grid-template-columns: repeat(2, 1fr); gap: 12px; }
    .stat-card { background: var(--dark-elevated); border: 1px solid var(--border); border-radius: 8px; padding: 16px; text-align: center; }
    .stat-value { font-size: 24px; font-weight: 700; color: var(--gold-primary); }
    .stat-label { font-size: 11px; color: var(--text-muted); margin-top: 4px; }
    .stat-breakdown { grid-column: 1 / -1; margin-top: 8px; }
    .stat-breakdown h4 { font-size: 13px; color: var(--text-secondary); margin-bottom: 8px; }
    .stat-breakdown ul { list-style: none; padding: 0; margin: 0; display: grid; grid-template-columns: repeat(2, 1fr); gap: 4px; }
    .stat-breakdown li { font-size: 12px; color: var(--text-muted); padding: 4px 0; }

    /* Cost Summary */
    .cost-table { width: 100%; border-collapse: collapse; font-size: 12px; }
    .cost-table th, .cost-table td { padding: 8px; text-align: left; border-bottom: 1px solid var(--border); }
    .cost-table th { color: var(--text-muted); font-weight: 500; }
    .cost-table td { color: var(--text); }
    .cost-table tfoot tr.subtotal td { color: var(--text-secondary); }
    .cost-table tfoot tr.grand-total td { font-size: 14px; font-weight: 700; color: var(--gold-primary); border-top: 2px solid var(--gold-primary); }

    /* Element Search */
    .element-search-content { padding: 16px; }
    .element-search-content input { width: 100%; padding: 12px 16px; background: var(--dark-elevated); border: 1px solid var(--border); border-radius: 8px; color: var(--text); font-size: 14px; }
    .element-search-content input:focus { outline: none; border-color: var(--gold-primary); }
    .element-search-results { margin-top: 12px; max-height: 300px; overflow-y: auto; }
    .search-result-item { display: flex; align-items: center; gap: 10px; padding: 10px; background: var(--dark-elevated); border-radius: 6px; margin-bottom: 6px; cursor: pointer; transition: all 0.2s; }
    .search-result-item:hover { background: var(--dark-hover); border-left: 3px solid var(--gold-primary); }
    .search-result-icon { font-size: 18px; }
    .search-result-name { flex: 1; font-size: 13px; color: var(--text); }
    .search-result-type { font-size: 11px; color: var(--text-muted); background: rgba(255,255,255,0.05); padding: 2px 8px; border-radius: 4px; }
    .search-empty { text-align: center; padding: 20px; color: var(--text-muted); }

    /* Zoom Controls */
    .zoom-controls {
      position: absolute;
      bottom: 16px;
      right: 16px;
      display: flex;
      align-items: center;
      gap: 4px;
      padding: 6px;
      background: var(--dark-surface);
      border: 1px solid var(--border);
      border-radius: 8px;
      z-index: 100;
    }
    .zoom-controls button {
      width: 28px;
      height: 28px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(255,255,255,0.05);
      border: 1px solid var(--border);
      border-radius: 4px;
      color: var(--text);
      font-size: 16px;
      cursor: pointer;
      transition: all 0.2s;
    }
    .zoom-controls button:hover {
      background: var(--gold-primary);
      color: var(--dark-primary);
      border-color: var(--gold-primary);
    }
    .zoom-controls span {
      min-width: 50px;
      text-align: center;
      font-size: 11px;
      color: var(--text-muted);
    }

    /* Layer Controls (for context menu) */
    .layer-controls {
      display: flex;
      gap: 4px;
      padding: 8px;
    }
    .layer-controls button {
      flex: 1;
      padding: 6px;
      background: rgba(255,255,255,0.05);
      border: 1px solid var(--border);
      border-radius: 4px;
      color: var(--text-muted);
      font-size: 11px;
      cursor: pointer;
      transition: all 0.2s;
    }
    .layer-controls button:hover {
      background: var(--gold-primary);
      color: var(--dark-primary);
    }

    /* Locked Element Indicator */
    .element-locked-badge {
      position: absolute;
      top: -8px;
      right: -8px;
      width: 20px;
      height: 20px;
      background: #ef4444;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 10px;
      z-index: 10;
    }

    /* Project Info Modal */
    .project-info-modal { position: fixed; inset: 0; background: rgba(0,0,0,0.7); display: flex; align-items: center; justify-content: center; z-index: 10000; }
    .project-info-content { background: var(--dark-surface); border: 1px solid var(--border); border-radius: 12px; max-width: 480px; width: 90%; }
    .project-info-header { display: flex; justify-content: space-between; align-items: center; padding: 16px 20px; border-bottom: 1px solid var(--border); }
    .project-info-header h3 { margin: 0; font-size: 16px; color: var(--text); }
    .project-info-header button { width: 28px; height: 28px; background: rgba(255,255,255,0.1); border: none; border-radius: 6px; color: var(--text-muted); cursor: pointer; font-size: 18px; }
    .project-info-body { padding: 20px; }
    .form-group { margin-bottom: 16px; }
    .form-group label { display: block; font-size: 12px; color: var(--text-muted); margin-bottom: 6px; }
    .form-group input, .form-group textarea { width: 100%; padding: 10px 12px; background: var(--dark-elevated); border: 1px solid var(--border); border-radius: 6px; color: var(--text); font-size: 13px; }
    .form-group input:focus, .form-group textarea:focus { outline: none; border-color: var(--gold-primary); }
    .form-row { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }
    .form-actions { display: flex; gap: 12px; justify-content: flex-end; margin-top: 20px; }
    .btn-primary, .btn-secondary { padding: 10px 20px; border-radius: 6px; font-size: 13px; font-weight: 500; cursor: pointer; transition: all 0.2s; }
    .btn-primary { background: var(--gold-primary); color: var(--dark-primary); border: none; }
    .btn-primary:hover { filter: brightness(1.1); }
    .btn-secondary { background: transparent; color: var(--text-muted); border: 1px solid var(--border); }
    .btn-secondary:hover { background: rgba(255,255,255,0.05); color: var(--text); }

    /* Measurement Line Display */
    .measure-line-display { position: absolute; pointer-events: none; z-index: 200; }
    .measure-line { position: absolute; height: 2px; background: var(--gold-primary); transform-origin: left center; }
    .measure-label { position: absolute; background: var(--gold-primary); color: var(--dark-primary); padding: 4px 10px; border-radius: 4px; font-size: 12px; font-weight: 600; white-space: nowrap; transform: translateX(-50%); }
    .measure-point { position: absolute; width: 10px; height: 10px; background: var(--gold-primary); border-radius: 50%; }

    /* Material Preview Panel */
    .material-preview-panel { position: fixed; bottom: 80px; right: 20px; width: 280px; background: var(--dark-surface); border: 1px solid var(--border); border-radius: 12px; box-shadow: 0 8px 32px rgba(0,0,0,0.3); z-index: 500; opacity: 0; transform: translateY(20px); transition: all 0.2s ease; }
    .material-preview-panel.show { opacity: 1; transform: translateY(0); }
    .material-preview-image { height: 120px; background-size: cover; background-position: center; border-radius: 11px 11px 0 0; }
    .material-preview-info { padding: 12px; }
    .material-preview-name { font-size: 14px; font-weight: 600; color: var(--text); margin-bottom: 8px; }
    .material-preview-details { display: flex; flex-wrap: wrap; gap: 6px; }
    .material-preview-details span { font-size: 11px; color: var(--text-muted); background: rgba(255,255,255,0.05); padding: 3px 8px; border-radius: 4px; }
    .material-preview-details .price { background: var(--gold-primary); color: var(--dark-primary); font-weight: 600; }
    .material-preview-close { position: absolute; top: 8px; right: 8px; width: 24px; height: 24px; background: rgba(0,0,0,0.5); border: none; border-radius: 50%; color: white; cursor: pointer; }

    /* Work Triangle Modal */
    .work-triangle-modal { position: fixed; inset: 0; background: rgba(0,0,0,0.7); display: flex; align-items: center; justify-content: center; z-index: 10000; }
    .work-triangle-content { background: var(--dark-surface); border: 1px solid var(--border); border-radius: 12px; max-width: 400px; width: 90%; }
    .work-triangle-header { display: flex; justify-content: space-between; align-items: center; padding: 16px 20px; border-bottom: 1px solid var(--border); }
    .work-triangle-header h3 { margin: 0; font-size: 16px; }
    .work-triangle-header button { width: 28px; height: 28px; background: rgba(255,255,255,0.1); border: none; border-radius: 6px; color: var(--text-muted); cursor: pointer; font-size: 18px; }
    .work-triangle-body { padding: 20px; }
    .triangle-status { padding: 12px 16px; border-radius: 8px; font-size: 13px; font-weight: 500; margin-bottom: 16px; }
    .triangle-status.valid { background: rgba(34, 197, 94, 0.15); color: #22c55e; }
    .triangle-status.invalid { background: rgba(239, 68, 68, 0.15); color: #ef4444; }
    .triangle-measurements { display: grid; gap: 8px; }
    .triangle-leg, .triangle-total { display: flex; justify-content: space-between; padding: 8px 12px; background: var(--dark-elevated); border-radius: 6px; font-size: 12px; }
    .triangle-leg span, .triangle-total span { color: var(--text-muted); }
    .triangle-leg strong, .triangle-total strong { color: var(--text); }
    .triangle-total { border-top: 1px solid var(--border); margin-top: 8px; }
    .triangle-total strong { color: var(--gold-primary); }
    .triangle-guide { margin-top: 16px; padding: 12px; background: rgba(255,255,255,0.03); border-radius: 6px; }
    .triangle-guide p { margin: 0 0 8px; font-size: 12px; color: var(--text-muted); }
    .triangle-guide ul { margin: 0; padding-left: 20px; font-size: 11px; color: var(--text-muted); }

    /* Cabinet Specs Modal */
    .cabinet-specs-modal { position: fixed; inset: 0; background: rgba(0,0,0,0.7); display: flex; align-items: center; justify-content: center; z-index: 10000; }
    .cabinet-specs-content { background: var(--dark-surface); border: 1px solid var(--border); border-radius: 12px; max-width: 320px; width: 90%; }
    .cabinet-specs-header { display: flex; justify-content: space-between; align-items: center; padding: 16px 20px; border-bottom: 1px solid var(--border); }
    .cabinet-specs-header h3 { margin: 0; font-size: 16px; }
    .cabinet-specs-header button { width: 28px; height: 28px; background: rgba(255,255,255,0.1); border: none; border-radius: 6px; color: var(--text-muted); cursor: pointer; font-size: 18px; }
    .cabinet-specs-body { padding: 16px 20px; }
    .spec-row { display: flex; justify-content: space-between; padding: 8px 0; border-bottom: 1px solid rgba(255,255,255,0.05); font-size: 13px; }
    .spec-row:last-child { border-bottom: none; }
    .spec-row span { color: var(--text-muted); }
    .spec-row strong { color: var(--text); }

    /* Comparison Modal */
    .comparison-modal { position: fixed; inset: 0; background: rgba(0,0,0,0.7); display: flex; align-items: center; justify-content: center; z-index: 10000; }
    .comparison-content { background: var(--dark-surface); border: 1px solid var(--border); border-radius: 12px; max-width: 500px; width: 90%; }
    .comparison-header { display: flex; justify-content: space-between; align-items: center; padding: 16px 20px; border-bottom: 1px solid var(--border); }
    .comparison-header h3 { margin: 0; font-size: 16px; }
    .comparison-header button { width: 28px; height: 28px; background: rgba(255,255,255,0.1); border: none; border-radius: 6px; color: var(--text-muted); cursor: pointer; font-size: 18px; }
    .comparison-body { padding: 20px; display: grid; grid-template-columns: repeat(3, 1fr); gap: 12px; }
    .comparison-section h4 { font-size: 12px; margin: 0 0 8px; }
    .comparison-section.added h4 { color: #22c55e; }
    .comparison-section.removed h4 { color: #ef4444; }
    .comparison-section.modified h4 { color: #f59e0b; }
    .comparison-item { font-size: 11px; padding: 6px 8px; background: var(--dark-elevated); border-radius: 4px; margin-bottom: 4px; color: var(--text-muted); }
    .comparison-empty { font-size: 11px; color: var(--text-muted); font-style: italic; }

    /* =============================================
       PRO FEATURES V5.0 - Advanced Capabilities
       ============================================= */

    /* Print Settings Modal */
    .print-settings-modal { position: fixed; inset: 0; background: rgba(0,0,0,0.7); display: flex; align-items: center; justify-content: center; z-index: 10000; }
    .print-settings-content { background: var(--dark-surface); border: 1px solid var(--border); border-radius: 12px; max-width: 400px; width: 90%; }
    .print-settings-header { display: flex; justify-content: space-between; align-items: center; padding: 16px 20px; border-bottom: 1px solid var(--border); }
    .print-settings-header h3 { margin: 0; font-size: 16px; }
    .print-settings-header button { width: 28px; height: 28px; background: rgba(255,255,255,0.1); border: none; border-radius: 6px; color: var(--text-muted); cursor: pointer; font-size: 18px; }
    .print-settings-body { padding: 20px; }
    .print-settings-body .form-group { margin-bottom: 16px; }
    .print-settings-body label { display: block; font-size: 12px; color: var(--text-muted); margin-bottom: 6px; }
    .print-settings-body select { width: 100%; padding: 10px 12px; background: var(--dark-elevated); border: 1px solid var(--border); border-radius: 8px; color: var(--text); font-size: 13px; }
    .print-settings-body .form-group-row { display: flex; gap: 16px; margin-bottom: 16px; }
    .print-settings-body .form-group-row label { display: flex; align-items: center; gap: 8px; font-size: 13px; color: var(--text); cursor: pointer; }
    .print-settings-body .form-group-row input[type="checkbox"] { width: 16px; height: 16px; accent-color: var(--primary); }

    /* Edge Profile Modal */
    .edge-profile-modal { position: fixed; inset: 0; background: rgba(0,0,0,0.7); display: flex; align-items: center; justify-content: center; z-index: 10000; }
    .edge-profile-content { background: var(--dark-surface); border: 1px solid var(--border); border-radius: 12px; max-width: 600px; width: 90%; }
    .edge-profile-header { display: flex; justify-content: space-between; align-items: center; padding: 16px 20px; border-bottom: 1px solid var(--border); }
    .edge-profile-header h3 { margin: 0; font-size: 16px; }
    .edge-profile-header button { width: 28px; height: 28px; background: rgba(255,255,255,0.1); border: none; border-radius: 6px; color: var(--text-muted); cursor: pointer; font-size: 18px; }
    .edge-profile-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(160px, 1fr)); gap: 12px; padding: 20px; }
    .edge-profile-item { background: var(--dark-elevated); border: 1px solid var(--border); border-radius: 10px; padding: 16px; cursor: pointer; transition: all 0.2s; text-align: center; }
    .edge-profile-item:hover { border-color: var(--primary); transform: translateY(-2px); box-shadow: 0 4px 12px rgba(0,0,0,0.3); }
    .edge-profile-icon { font-size: 32px; margin-bottom: 8px; display: block; }
    .edge-profile-name { font-size: 13px; font-weight: 600; color: var(--text); margin-bottom: 4px; }
    .edge-profile-desc { font-size: 11px; color: var(--text-muted); line-height: 1.3; }

    /* Appliance Library Modal */
    .appliance-library-modal { position: fixed; inset: 0; background: rgba(0,0,0,0.7); display: flex; align-items: center; justify-content: center; z-index: 10000; }
    .appliance-library-content { background: var(--dark-surface); border: 1px solid var(--border); border-radius: 12px; max-width: 700px; width: 90%; max-height: 80vh; overflow: hidden; display: flex; flex-direction: column; }
    .appliance-library-header { display: flex; justify-content: space-between; align-items: center; padding: 16px 20px; border-bottom: 1px solid var(--border); flex-shrink: 0; }
    .appliance-library-header h3 { margin: 0; font-size: 16px; }
    .appliance-library-header button { width: 28px; height: 28px; background: rgba(255,255,255,0.1); border: none; border-radius: 6px; color: var(--text-muted); cursor: pointer; font-size: 18px; }
    .appliance-library-body { padding: 20px; overflow-y: auto; }
    .appliance-category { margin-bottom: 24px; }
    .appliance-category h4 { font-size: 13px; color: var(--text-muted); margin: 0 0 12px; text-transform: uppercase; letter-spacing: 0.5px; }
    .appliance-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(140px, 1fr)); gap: 10px; }
    .appliance-item { background: var(--dark-elevated); border: 1px solid var(--border); border-radius: 10px; padding: 14px 12px; cursor: pointer; transition: all 0.2s; text-align: center; }
    .appliance-item:hover { border-color: var(--primary); transform: translateY(-2px); }
    .appliance-icon { font-size: 24px; margin-bottom: 6px; display: block; }
    .appliance-name { font-size: 12px; font-weight: 500; color: var(--text); margin-bottom: 2px; }
    .appliance-size { font-size: 10px; color: var(--text-muted); }

    /* Room Templates Modal */
    .room-templates-modal { position: fixed; inset: 0; background: rgba(0,0,0,0.7); display: flex; align-items: center; justify-content: center; z-index: 10000; }
    .room-templates-content { background: var(--dark-surface); border: 1px solid var(--border); border-radius: 12px; max-width: 700px; width: 90%; }
    .room-templates-header { display: flex; justify-content: space-between; align-items: center; padding: 16px 20px; border-bottom: 1px solid var(--border); }
    .room-templates-header h3 { margin: 0; font-size: 16px; }
    .room-templates-header button { width: 28px; height: 28px; background: rgba(255,255,255,0.1); border: none; border-radius: 6px; color: var(--text-muted); cursor: pointer; font-size: 18px; }
    .room-templates-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(180px, 1fr)); gap: 16px; padding: 20px; }
    .room-template-card { background: var(--dark-elevated); border: 1px solid var(--border); border-radius: 12px; padding: 20px; cursor: pointer; transition: all 0.2s; text-align: center; }
    .room-template-card:hover { border-color: var(--primary); transform: translateY(-3px); box-shadow: 0 8px 24px rgba(0,0,0,0.3); }
    .template-icon { font-size: 36px; margin-bottom: 10px; font-family: monospace; letter-spacing: 2px; color: var(--primary); }
    .template-name { font-size: 14px; font-weight: 600; color: var(--text); margin-bottom: 4px; }
    .template-desc { font-size: 11px; color: var(--text-muted); margin-bottom: 8px; }
    .template-size { font-size: 11px; color: var(--primary); font-weight: 500; }

    /* Color Themes Modal */
    .color-themes-modal { position: fixed; inset: 0; background: rgba(0,0,0,0.7); display: flex; align-items: center; justify-content: center; z-index: 10000; }
    .color-themes-content { background: var(--dark-surface); border: 1px solid var(--border); border-radius: 12px; max-width: 500px; width: 90%; }
    .color-themes-header { display: flex; justify-content: space-between; align-items: center; padding: 16px 20px; border-bottom: 1px solid var(--border); }
    .color-themes-header h3 { margin: 0; font-size: 16px; }
    .color-themes-header button { width: 28px; height: 28px; background: rgba(255,255,255,0.1); border: none; border-radius: 6px; color: var(--text-muted); cursor: pointer; font-size: 18px; }
    .color-themes-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 12px; padding: 20px; }
    .color-theme-card { background: var(--dark-elevated); border: 1px solid var(--border); border-radius: 10px; padding: 16px; cursor: pointer; transition: all 0.2s; }
    .color-theme-card:hover { border-color: var(--primary); transform: scale(1.03); }
    .theme-preview { display: flex; gap: 4px; margin-bottom: 10px; border-radius: 6px; overflow: hidden; }
    .theme-swatch { height: 32px; flex: 1; }
    .theme-swatch.cabinet { border-radius: 6px 0 0 6px; }
    .theme-swatch.accent { border-radius: 0 6px 6px 0; }
    .theme-name { font-size: 12px; font-weight: 500; color: var(--text); text-align: center; }

    /* Clearance Modal */
    .clearance-modal { position: fixed; inset: 0; background: rgba(0,0,0,0.7); display: flex; align-items: center; justify-content: center; z-index: 10000; }
    .clearance-content { background: var(--dark-surface); border: 1px solid var(--border); border-radius: 12px; max-width: 450px; width: 90%; }
    .clearance-header { display: flex; justify-content: space-between; align-items: center; padding: 16px 20px; border-bottom: 1px solid var(--border); }
    .clearance-header h3 { margin: 0; font-size: 16px; }
    .clearance-header button { width: 28px; height: 28px; background: rgba(255,255,255,0.1); border: none; border-radius: 6px; color: var(--text-muted); cursor: pointer; font-size: 18px; }
    .clearance-body { padding: 20px; }
    .clearance-ok { background: rgba(34, 197, 94, 0.15); color: #22c55e; padding: 16px; border-radius: 10px; text-align: center; font-weight: 500; }
    .clearance-issues { margin-bottom: 16px; }
    .clearance-issue { display: flex; align-items: flex-start; gap: 10px; padding: 10px 12px; background: var(--dark-elevated); border-radius: 8px; margin-bottom: 8px; font-size: 13px; }
    .clearance-issue.warning { border-left: 3px solid #f59e0b; }
    .clearance-issue.error { border-left: 3px solid #ef4444; }
    .issue-icon { flex-shrink: 0; }
    .issue-text { color: var(--text-muted); }
    .clearance-standards { background: var(--dark-elevated); border-radius: 10px; padding: 16px; margin-top: 16px; }
    .clearance-standards h4 { font-size: 12px; color: var(--text-muted); margin: 0 0 10px; text-transform: uppercase; }
    .clearance-standards ul { margin: 0; padding: 0 0 0 18px; font-size: 12px; color: var(--text-muted); }
    .clearance-standards li { margin-bottom: 4px; }

    /* Slab Calculator Modal */
    .slab-calc-modal { position: fixed; inset: 0; background: rgba(0,0,0,0.7); display: flex; align-items: center; justify-content: center; z-index: 10000; }
    .slab-calc-content { background: var(--dark-surface); border: 1px solid var(--border); border-radius: 12px; max-width: 500px; width: 90%; }
    .slab-calc-header { display: flex; justify-content: space-between; align-items: center; padding: 16px 20px; border-bottom: 1px solid var(--border); }
    .slab-calc-header h3 { margin: 0; font-size: 16px; }
    .slab-calc-header button { width: 28px; height: 28px; background: rgba(255,255,255,0.1); border: none; border-radius: 6px; color: var(--text-muted); cursor: pointer; font-size: 18px; }
    .slab-calc-body { padding: 20px; }
    .slab-summary { display: grid; grid-template-columns: repeat(3, 1fr); gap: 12px; margin-bottom: 20px; }
    .slab-stat { background: var(--dark-elevated); border-radius: 10px; padding: 16px; text-align: center; }
    .slab-stat .stat-value { font-size: 24px; font-weight: 700; color: var(--primary); display: block; }
    .slab-stat .stat-label { font-size: 11px; color: var(--text-muted); margin-top: 4px; }
    .slab-pieces h4 { font-size: 12px; color: var(--text-muted); margin: 0 0 10px; text-transform: uppercase; }
    .slab-table { width: 100%; border-collapse: collapse; font-size: 12px; }
    .slab-table th, .slab-table td { padding: 10px 8px; text-align: left; border-bottom: 1px solid var(--border); }
    .slab-table th { color: var(--text-muted); font-weight: 500; }
    .slab-table td { color: var(--text); }
    .slab-note { font-size: 11px; color: var(--text-muted); margin-top: 16px; text-align: center; font-style: italic; }

    /* =============================================
       PRO FEATURES V6.0 - Professional Design Tools
       ============================================= */

    /* Annotation System */
    .design-annotation { position: absolute; z-index: 150; }
    .design-annotation.callout { display: flex; align-items: flex-start; gap: 4px; }
    .callout-content { background: var(--dark-surface); border: 2px solid; border-radius: 8px; padding: 8px 12px; font-size: 12px; color: var(--text); max-width: 200px; box-shadow: 0 4px 12px rgba(0,0,0,0.3); }
    .annot-delete { width: 18px; height: 18px; background: rgba(239,68,68,0.2); border: none; border-radius: 50%; color: #ef4444; cursor: pointer; font-size: 12px; opacity: 0; transition: opacity 0.2s; }
    .design-annotation:hover .annot-delete { opacity: 1; }
    .design-annotation.arrow { height: 2px; transform-origin: left center; }
    .arrow-head { position: absolute; right: -6px; top: -4px; border: 5px solid transparent; border-left-width: 8px; }
    .design-annotation.dimension .dim-line { position: absolute; height: 1px; transform-origin: left center; }
    .design-annotation.dimension .dim-label { position: absolute; background: var(--dark-surface); padding: 2px 6px; border-radius: 4px; font-size: 11px; color: #22c55e; font-weight: 600; transform: translateX(-50%); white-space: nowrap; }
    .design-annotation.dimension .dim-end { position: absolute; width: 2px; height: 12px; background: #22c55e; }
    .area-annotation { pointer-events: none; }

    /* Seam Planner */
    .planned-seam { position: absolute; background: repeating-linear-gradient(90deg, #ef4444 0, #ef4444 4px, transparent 4px, transparent 8px); z-index: 140; }
    .planned-seam.vertical { width: 2px; cursor: col-resize; }
    .planned-seam.horizontal { height: 2px; cursor: row-resize; }
    .seam-delete { position: absolute; top: -10px; right: -10px; width: 18px; height: 18px; background: #ef4444; border: none; border-radius: 50%; color: white; cursor: pointer; font-size: 10px; opacity: 0; transition: opacity 0.2s; }
    .planned-seam:hover .seam-delete { opacity: 1; }
    .seam-planner-modal { position: fixed; inset: 0; background: rgba(0,0,0,0.7); display: flex; align-items: center; justify-content: center; z-index: 10000; }
    .seam-planner-content { background: var(--dark-surface); border: 1px solid var(--border); border-radius: 12px; max-width: 450px; width: 90%; }
    .seam-planner-header { display: flex; justify-content: space-between; align-items: center; padding: 16px 20px; border-bottom: 1px solid var(--border); }
    .seam-planner-header h3 { margin: 0; font-size: 16px; }
    .seam-planner-header button { width: 28px; height: 28px; background: rgba(255,255,255,0.1); border: none; border-radius: 6px; color: var(--text-muted); cursor: pointer; font-size: 18px; }
    .seam-planner-body { padding: 20px; }
    .seam-info { font-size: 13px; color: var(--text-muted); margin-bottom: 16px; }
    .seam-info p { margin: 0; }
    .seam-suggestions, .seam-current { margin-top: 16px; }
    .seam-suggestions h4, .seam-current h4 { font-size: 12px; color: var(--text-muted); margin: 0 0 10px; text-transform: uppercase; }
    .seam-suggestion, .seam-item { display: flex; justify-content: space-between; align-items: center; padding: 10px 12px; background: var(--dark-elevated); border-radius: 8px; margin-bottom: 8px; font-size: 13px; }

    /* Fabrication Plan Modal */
    .fabrication-plan-modal { position: fixed; inset: 0; background: rgba(0,0,0,0.8); display: flex; align-items: center; justify-content: center; z-index: 10000; }
    .fabrication-plan-content { background: var(--dark-surface); border: 1px solid var(--border); border-radius: 12px; max-width: 800px; width: 95%; max-height: 90vh; overflow: hidden; display: flex; flex-direction: column; }
    .fabrication-plan-header { display: flex; justify-content: space-between; align-items: center; padding: 16px 20px; border-bottom: 1px solid var(--border); flex-shrink: 0; }
    .fabrication-plan-header h3 { margin: 0; font-size: 18px; }
    .fabrication-plan-header button { width: 32px; height: 32px; background: rgba(255,255,255,0.1); border: none; border-radius: 6px; color: var(--text-muted); cursor: pointer; font-size: 20px; }
    .fabrication-plan-body { padding: 20px; overflow-y: auto; flex: 1; }
    .fab-summary { display: grid; grid-template-columns: repeat(5, 1fr); gap: 12px; margin-bottom: 24px; }
    .fab-stat { background: var(--dark-elevated); border-radius: 10px; padding: 16px 12px; text-align: center; }
    .fab-value { font-size: 24px; font-weight: 700; color: var(--primary); display: block; }
    .fab-label { font-size: 10px; color: var(--text-muted); margin-top: 4px; text-transform: uppercase; }
    .fab-section { margin-bottom: 24px; }
    .fab-section h4 { font-size: 14px; color: var(--text); margin: 0 0 12px; padding-bottom: 8px; border-bottom: 1px solid var(--border); }
    .fab-table { width: 100%; border-collapse: collapse; font-size: 12px; }
    .fab-table th, .fab-table td { padding: 10px 8px; text-align: left; border-bottom: 1px solid var(--border); }
    .fab-table th { color: var(--text-muted); font-weight: 500; background: var(--dark-elevated); }
    .fab-table td { color: var(--text); }
    .fab-note { font-size: 11px; color: var(--text-muted); margin-top: 12px; text-align: center; font-style: italic; }
    .slab-layouts { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 16px; }
    .slab-preview { background: var(--dark-elevated); border-radius: 8px; padding: 12px; }
    .slab-header { font-size: 12px; font-weight: 600; margin-bottom: 8px; color: var(--text); }
    .slab-diagram { background: #f5f5f5; border: 2px solid #999; border-radius: 4px; display: flex; flex-wrap: wrap; align-content: flex-start; min-height: 80px; }
    .slab-piece { background: var(--primary); border: 1px solid rgba(0,0,0,0.3); display: flex; align-items: center; justify-content: center; font-size: 10px; font-weight: bold; color: #fff; }
    .fabrication-plan-footer { padding: 16px 20px; border-top: 1px solid var(--border); display: flex; gap: 12px; justify-content: flex-end; flex-shrink: 0; }
    .fab-export-btn, .fab-copy-btn { display: flex; align-items: center; gap: 6px; padding: 10px 16px; border-radius: 6px; border: none; cursor: pointer; font-size: 13px; font-weight: 500; }
    .fab-export-btn { background: var(--primary); color: var(--dark-deep); }
    .fab-copy-btn { background: rgba(255,255,255,0.1); color: var(--text); }
    .fab-export-btn:hover { opacity: 0.9; }
    .fab-copy-btn:hover { background: rgba(255,255,255,0.15); }
    @media (max-width: 600px) { .fab-summary { grid-template-columns: repeat(3, 1fr); } }
    .seam-suggestion button, .seam-item button { padding: 4px 10px; background: var(--primary); border: none; border-radius: 4px; color: var(--dark-deep); cursor: pointer; font-size: 11px; font-weight: 600; }
    .seam-item button { background: rgba(239,68,68,0.2); color: #ef4444; }
    .no-seams { font-size: 13px; color: var(--text-muted); font-style: italic; }

    /* Backsplash Designer */
    .backsplash-modal { position: fixed; inset: 0; background: rgba(0,0,0,0.7); display: flex; align-items: center; justify-content: center; z-index: 10000; }
    .backsplash-content { background: var(--dark-surface); border: 1px solid var(--border); border-radius: 12px; max-width: 500px; width: 90%; }
    .backsplash-header { display: flex; justify-content: space-between; align-items: center; padding: 16px 20px; border-bottom: 1px solid var(--border); }
    .backsplash-header h3 { margin: 0; font-size: 16px; }
    .backsplash-header button { width: 28px; height: 28px; background: rgba(255,255,255,0.1); border: none; border-radius: 6px; color: var(--text-muted); cursor: pointer; font-size: 18px; }
    .backsplash-body { padding: 20px; }
    .backsplash-section { margin-bottom: 20px; }
    .backsplash-section h4 { font-size: 12px; color: var(--text-muted); margin: 0 0 10px; text-transform: uppercase; }
    .pattern-grid, .size-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(80px, 1fr)); gap: 8px; }
    .pattern-option, .size-option { background: var(--dark-elevated); border: 2px solid var(--border); border-radius: 8px; padding: 12px 8px; cursor: pointer; text-align: center; transition: all 0.2s; }
    .pattern-option:hover, .size-option:hover { border-color: var(--primary); }
    .pattern-option.selected, .size-option.selected { border-color: var(--primary); background: rgba(249,203,0,0.1); }
    .pattern-icon { font-size: 18px; display: block; margin-bottom: 4px; font-family: monospace; }
    .pattern-name, .size-name { font-size: 10px; color: var(--text-muted); }
    .size-preview { display: inline-block; background: var(--primary); margin-bottom: 6px; }
    .coverage-inputs { display: flex; gap: 12px; align-items: flex-end; }
    .coverage-inputs .input-group { flex: 1; }
    .coverage-inputs label { display: block; font-size: 11px; color: var(--text-muted); margin-bottom: 4px; }
    .coverage-inputs input { width: 100%; padding: 8px; background: var(--dark-elevated); border: 1px solid var(--border); border-radius: 6px; color: var(--text); font-size: 13px; }
    .coverage-inputs .calc-btn { padding: 8px 16px; background: var(--primary); border: none; border-radius: 6px; color: var(--dark-deep); font-weight: 600; cursor: pointer; }
    .coverage-result { margin-top: 16px; background: var(--dark-elevated); border-radius: 8px; padding: 12px; }
    .coverage-result .result-row { display: flex; justify-content: space-between; padding: 6px 0; font-size: 13px; }
    .coverage-result .result-row span { color: var(--text-muted); }
    .coverage-result .result-row strong { color: var(--text); }

    /* Lighting Planner */
    .lighting-fixture { position: absolute; width: 24px; height: 24px; background: rgba(249,203,0,0.2); border: 2px solid var(--primary); border-radius: 50%; display: flex; align-items: center; justify-content: center; cursor: move; z-index: 145; }
    .fixture-icon { font-size: 12px; }
    .fixture-delete { position: absolute; top: -8px; right: -8px; width: 16px; height: 16px; background: #ef4444; border: none; border-radius: 50%; color: white; cursor: pointer; font-size: 10px; opacity: 0; transition: opacity 0.2s; }
    .lighting-fixture:hover .fixture-delete { opacity: 1; }
    .lighting-modal { position: fixed; inset: 0; background: rgba(0,0,0,0.7); display: flex; align-items: center; justify-content: center; z-index: 10000; }
    .lighting-content { background: var(--dark-surface); border: 1px solid var(--border); border-radius: 12px; max-width: 500px; width: 90%; }
    .lighting-header { display: flex; justify-content: space-between; align-items: center; padding: 16px 20px; border-bottom: 1px solid var(--border); }
    .lighting-header h3 { margin: 0; font-size: 16px; }
    .lighting-header button { width: 28px; height: 28px; background: rgba(255,255,255,0.1); border: none; border-radius: 6px; color: var(--text-muted); cursor: pointer; font-size: 18px; }
    .lighting-body { padding: 20px; }
    .lighting-section { margin-bottom: 20px; }
    .lighting-section h4 { font-size: 12px; color: var(--text-muted); margin: 0 0 10px; text-transform: uppercase; }
    .fixture-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; }
    .fixture-btn { background: var(--dark-elevated); border: 1px solid var(--border); border-radius: 8px; padding: 12px 8px; cursor: pointer; text-align: center; transition: all 0.2s; }
    .fixture-btn:hover { border-color: var(--primary); background: rgba(249,203,0,0.1); }
    .fixture-type-icon { font-size: 20px; display: block; margin-bottom: 4px; }
    .fixture-type-name { font-size: 11px; color: var(--text); display: block; }
    .fixture-wattage { font-size: 10px; color: var(--text-muted); }
    .lighting-summary { display: grid; grid-template-columns: repeat(2, 1fr); gap: 12px; margin-bottom: 16px; }
    .lighting-summary .summary-stat { background: var(--dark-elevated); border-radius: 10px; padding: 16px; text-align: center; }
    .lighting-summary .stat-value { font-size: 24px; font-weight: 700; color: var(--primary); display: block; }
    .lighting-summary .stat-label { font-size: 11px; color: var(--text-muted); margin-top: 4px; }
    .fixture-breakdown { background: var(--dark-elevated); border-radius: 8px; padding: 12px; }
    .breakdown-row { display: flex; justify-content: space-between; padding: 6px 0; font-size: 13px; border-bottom: 1px solid rgba(255,255,255,0.05); }
    .breakdown-row:last-child { border-bottom: none; }
    .no-lights { font-size: 13px; color: var(--text-muted); font-style: italic; }

    /* Material Takeoff Report */
    .takeoff-modal { position: fixed; inset: 0; background: rgba(0,0,0,0.7); display: flex; align-items: center; justify-content: center; z-index: 10000; overflow-y: auto; padding: 20px; }
    .takeoff-content { background: var(--dark-surface); border: 1px solid var(--border); border-radius: 12px; max-width: 600px; width: 100%; }
    .takeoff-header { display: flex; justify-content: space-between; align-items: center; padding: 16px 20px; border-bottom: 1px solid var(--border); }
    .takeoff-header h3 { margin: 0; font-size: 16px; }
    .takeoff-actions { display: flex; gap: 8px; }
    .takeoff-actions button { padding: 6px 12px; background: var(--dark-elevated); border: 1px solid var(--border); border-radius: 6px; color: var(--text); cursor: pointer; font-size: 12px; }
    .takeoff-actions button:first-child { background: var(--primary); border-color: var(--primary); color: var(--dark-deep); font-weight: 600; }
    .takeoff-body { padding: 20px; max-height: 70vh; overflow-y: auto; }
    .takeoff-section { margin-bottom: 20px; padding-bottom: 16px; border-bottom: 1px solid var(--border); }
    .takeoff-section:last-child { border-bottom: none; margin-bottom: 0; }
    .takeoff-section h4 { font-size: 12px; color: var(--text-muted); margin: 0 0 12px; text-transform: uppercase; }
    .info-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px; }
    .info-grid > div { display: flex; justify-content: space-between; padding: 8px 12px; background: var(--dark-elevated); border-radius: 6px; font-size: 13px; }
    .info-grid span { color: var(--text-muted); }
    .info-grid strong { color: var(--text); }
    .cost-grid { display: grid; gap: 8px; }
    .cost-grid > div { display: flex; justify-content: space-between; padding: 10px 12px; background: var(--dark-elevated); border-radius: 6px; font-size: 13px; }
    .cost-grid > div.total { background: var(--primary); }
    .cost-grid > div.total span, .cost-grid > div.total strong { color: var(--dark-deep); }
    .validation-list { display: grid; gap: 8px; }
    .validation-item { display: flex; align-items: center; gap: 10px; padding: 10px 12px; background: var(--dark-elevated); border-radius: 6px; font-size: 13px; }
    .validation-item.pass { border-left: 3px solid #22c55e; }
    .validation-item.warn { border-left: 3px solid #f59e0b; }

    /* =============================================
       UPGRADED TOOL GRID - Enhanced UX
       ============================================= */
    .tool-grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 6px;
      padding: 4px;
      background: rgba(0, 0, 0, 0.15);
      border-radius: 10px;
    }

    .tool-btn {
      aspect-ratio: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: rgba(255, 255, 255, 0.03);
      border: 1px solid rgba(255, 255, 255, 0.05);
      border-radius: 8px;
      color: var(--text-muted);
      cursor: pointer;
      transition: all 0.2s ease;
      padding: 8px 4px;
      position: relative;
      overflow: hidden;
    }

    .tool-btn::before {
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(135deg, transparent 0%, rgba(255, 255, 255, 0.03) 100%);
      opacity: 0;
      transition: opacity 0.2s ease;
    }

    .tool-btn:hover {
      background: rgba(255, 255, 255, 0.06);
      border-color: rgba(255, 255, 255, 0.1);
      color: var(--text);
      transform: translateY(-1px);
    }

    .tool-btn:hover::before {
      opacity: 1;
    }

    .tool-btn:active {
      transform: translateY(0) scale(0.98);
    }

    .tool-btn.active {
      background: linear-gradient(135deg, var(--primary) 0%, #8b5cf6 100%);
      color: white;
      border-color: transparent;
      box-shadow: 0 4px 12px rgba(99, 102, 241, 0.35);
    }

    .tool-btn.active::after {
      content: '';
      position: absolute;
      bottom: 0;
      left: 50%;
      transform: translateX(-50%);
      width: 20px;
      height: 3px;
      background: white;
      border-radius: 3px 3px 0 0;
      opacity: 0.5;
    }

    .tool-btn svg {
      width: 20px;
      height: 20px;
      margin-bottom: 3px;
      transition: transform 0.2s ease;
    }

    .tool-btn:hover svg {
      transform: scale(1.1);
    }

    .tool-btn span {
      font-size: 9px;
      font-weight: 600;
      letter-spacing: 0.3px;
      text-transform: uppercase;
    }

    /* Tool keyboard shortcut badge */
    .tool-btn[data-shortcut]::after {
      content: attr(data-shortcut);
      position: absolute;
      top: 3px;
      right: 3px;
      font-size: 8px;
      font-weight: 700;
      font-family: monospace;
      color: var(--gold);
      opacity: 0;
      transition: opacity 0.2s ease;
    }

    .tool-btn:hover[data-shortcut]::after {
      opacity: 0.7;
    }

    .tool-btn.active[data-shortcut]::after {
      color: white;
      opacity: 0.6;
    }

    /* Layout Options Panel */
    .layout-options-panel {
      background: var(--dark-elevated);
      border: 1px solid var(--gold);
      border-radius: 8px;
      margin: 8px;
      overflow: hidden;
    }

    .layout-options-header {
      background: linear-gradient(135deg, var(--gold) 0%, #d4a84b 100%);
      color: var(--dark-bg);
      padding: 8px 12px;
      font-weight: 600;
      font-size: 12px;
    }

    .layout-options-content {
      padding: 10px;
    }

    .layout-option-row {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 8px;
    }

    .layout-option-row label {
      font-size: 11px;
      color: var(--text-secondary);
      min-width: 75px;
    }

    .layout-option-row select {
      flex: 1;
      background: var(--dark-bg);
      border: 1px solid var(--border);
      border-radius: 4px;
      color: var(--text);
      padding: 4px 6px;
      font-size: 11px;
    }

    .layout-option-row select:focus {
      border-color: var(--gold);
      outline: none;
    }

    .layout-option-row input[type="checkbox"] {
      accent-color: var(--gold);
    }

    .layout-option-hint {
      font-size: 10px;
      color: var(--text-muted);
      text-align: center;
      padding-top: 4px;
      border-top: 1px solid var(--border);
      margin-top: 4px;
    }

    /* Element Grid */
    .element-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 4px;
      max-height: 320px;
      overflow-y: auto;
      overflow-x: hidden;
      padding-right: 2px;
    }

    /* Scrollbar styling for element grid */
    .element-grid::-webkit-scrollbar {
      width: 6px;
    }

    .element-grid::-webkit-scrollbar-track {
      background: var(--dark-elevated);
      border-radius: 3px;
    }

    .element-grid::-webkit-scrollbar-thumb {
      background: var(--border);
      border-radius: 3px;
    }

    .element-grid::-webkit-scrollbar-thumb:hover {
      background: var(--text-muted);
    }

    .element-item {
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 6px 4px;
      cursor: grab;
      transition: all 0.2s;
      text-align: center;
      position: relative;
      min-width: 0;
      overflow: hidden;
    }

    .element-item:hover {
      background: var(--dark-hover);
      border-color: var(--primary);
    }

    .element-item:active {
      cursor: grabbing;
    }

    .element-item.has-texture {
      border-color: var(--success);
    }

    .element-icon {
      width: 40px;
      height: 40px;
      margin: 0 auto 4px;
      border-radius: 5px;
      background-size: cover;
      background-position: center;
      box-shadow: 0 2px 4px rgba(0,0,0,0.3);
      border: 1px solid rgba(255,255,255,0.1);
      overflow: hidden;
      flex-shrink: 0;
    }

    .element-icon.element-svg {
      background: var(--dark-hover);
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 4px;
    }

    .element-icon.element-svg svg {
      width: 100%;
      height: 100%;
    }

    .element-name {
      font-size: 9px;
      font-weight: 500;
      color: var(--text-secondary);
      line-height: 1.15;
      word-wrap: break-word;
      overflow-wrap: break-word;
      max-width: 100%;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .element-upload-btn {
      position: absolute;
      top: 4px;
      right: 4px;
      width: 16px;
      height: 16px;
      background: var(--dark-surface);
      border: 1px solid var(--border);
      border-radius: 3px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      opacity: 0;
      transition: all 0.2s;
    }

    .element-item:hover .element-upload-btn {
      opacity: 1;
    }

    .element-upload-btn:hover {
      background: var(--primary);
      border-color: var(--primary);
    }

    .element-upload-btn svg {
      width: 10px;
      height: 10px;
      color: var(--text);
    }

    /* Materials Library */
    .materials-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 6px;
    }

    .material-item {
      aspect-ratio: 1;
      border-radius: 6px;
      cursor: pointer;
      border: 2px solid transparent;
      transition: all 0.2s;
      background-size: cover;
      background-position: center;
      position: relative;
    }

    .material-item:hover {
      border-color: var(--primary);
      transform: scale(1.05);
    }

    .material-item.selected {
      border-color: var(--gold);
    }

    .material-item::after {
      content: attr(data-name);
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      padding: 2px 4px;
      font-size: 8px;
      text-align: center;
      border-radius: 0 0 4px 4px;
    }

    .materials-tabs {
      display: flex;
      flex-wrap: wrap;
      gap: 3px;
      margin-bottom: 8px;
    }

    .material-tab {
      padding: 3px 6px;
      font-size: 9px;
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      border-radius: 3px;
      color: var(--text-muted);
      cursor: pointer;
      transition: all 0.2s;
      white-space: nowrap;
    }

    .material-tab:hover {
      color: var(--text);
      border-color: var(--primary);
    }

    .material-tab.active {
      background: var(--primary);
      color: white;
      border-color: var(--primary);
    }

    .material-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 6px;
      max-height: 400px;
      overflow-y: auto;
      overflow-x: hidden;
    }

    .material-swatch {
      aspect-ratio: 1;
      min-height: 70px;
      border-radius: 6px;
      cursor: pointer;
      border: 2px solid transparent;
      transition: all 0.2s;
      background-size: cover;
      background-position: center;
      position: relative;
      overflow: hidden;
    }

    .material-swatch img {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      z-index: 1;
    }

    .material-swatch:hover {
      border-color: var(--primary);
      transform: scale(1.03);
    }

    .material-swatch.selected {
      border-color: var(--gold);
      box-shadow: 0 0 10px rgba(249, 203, 0, 0.4);
    }

    .material-swatch-label {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: linear-gradient(transparent, rgba(0,0,0,0.9));
      padding: 22px 5px 5px;
      font-size: 11px;
      line-height: 1.2;
      text-align: center;
      font-weight: 600;
      z-index: 2;
      color: #fff;
      text-shadow: 0 1px 2px rgba(0,0,0,0.8);
    }

    .material-price-badge {
      position: absolute;
      bottom: 24px;
      right: 4px;
      background: var(--gold);
      color: #000;
      padding: 2px 5px;
      border-radius: 4px;
      font-size: 9px;
      font-weight: 700;
      z-index: 3;
    }

    .material-brand-badge {
      position: absolute;
      top: 4px;
      left: 4px;
      background: rgba(0,0,0,0.8);
      color: #fff;
      padding: 2px 6px;
      border-radius: 4px;
      font-size: 8px;
      font-weight: 600;
      z-index: 3;
      text-transform: uppercase;
      letter-spacing: 0.3px;
    }

    .material-distributor-badge {
      position: absolute;
      top: 2px;
      right: 2px;
      background: rgba(16, 185, 129, 0.9);
      color: #fff;
      font-size: 7px;
      padding: 1px 4px;
      border-radius: 3px;
      z-index: 3;
      font-weight: 600;
      letter-spacing: 0.3px;
      text-transform: uppercase;
    }

    .material-trade-label {
      color: #10b981;
      font-weight: 600;
    }

    .material-distributor-badge img {
      height: 12px;
      margin-right: 3px;
      vertical-align: middle;
    }

    .finish-picker {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
      padding: 4px 0;
    }
    .finish-option {
      padding: 3px 8px;
      font-size: 10px;
      border-radius: 10px;
      background: rgba(255,255,255,0.08);
      color: rgba(255,255,255,0.7);
      border: 1px solid rgba(255,255,255,0.15);
      cursor: pointer;
      transition: all 0.2s;
      text-transform: capitalize;
    }
    .finish-option:hover {
      background: rgba(255,255,255,0.15);
      color: #fff;
    }
    .finish-option.active {
      background: var(--gold);
      color: #1a1a2e;
      border-color: var(--gold);
      font-weight: 600;
    }

    #distributor-loading-indicator {
      grid-column: 1 / -1;
      text-align: center;
      padding: 16px 8px;
      color: var(--gold);
      font-style: italic;
      opacity: 0.7;
      font-size: 12px;
    }

    .material-brand-header {
      grid-column: 1 / -1;
      background: var(--primary);
      color: #fff;
      padding: 6px 10px;
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      border-radius: 4px;
      margin-top: 8px;
    }

    .material-brand-header:first-child {
      margin-top: 0;
    }

    .material-no-texture-badge {
      position: absolute;
      bottom: 22px;
      right: 4px;
      color: rgba(255,255,255,0.5);
      font-size: 8px;
      z-index: 2;
    }

    .material-hint {
      font-size: 10px;
      color: var(--text-muted);
      text-align: center;
      margin-top: 10px;
      padding: 8px;
      background: var(--dark-elevated);
      border-radius: 6px;
      border: 1px dashed var(--border);
    }

    /* Cabinet Catalog */
    .catalog-brand select,
    .catalog-series select {
      width: 100%;
      padding: 8px 12px;
      background: rgba(255, 255, 255, 0.05);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 8px;
      color: var(--text);
      font-size: 12px;
      margin-bottom: 8px;
      cursor: pointer;
      transition: all 0.2s ease;
      appearance: none;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 24 24' fill='none' stroke='%23888' stroke-width='2'%3E%3Cpath d='M6 9l6 6 6-6'/%3E%3C/svg%3E");
      background-repeat: no-repeat;
      background-position: right 10px center;
      padding-right: 30px;
    }

    .catalog-brand select:hover,
    .catalog-series select:hover {
      background: rgba(255, 255, 255, 0.08);
      border-color: rgba(255, 255, 255, 0.2);
    }

    .catalog-brand select:focus,
    .catalog-series select:focus {
      outline: none;
      border-color: var(--primary);
      box-shadow: 0 0 0 3px rgba(249, 203, 0, 0.15);
    }

    .cabinet-catalog-list {
      max-height: 200px;
      overflow-y: auto;
      border: 1px solid var(--border);
      border-radius: 6px;
      background: var(--dark);
    }

    .cabinet-catalog-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 8px 10px;
      border-bottom: 1px solid var(--border);
      cursor: pointer;
      transition: background 0.15s;
    }

    .cabinet-catalog-item:last-child {
      border-bottom: none;
    }

    .cabinet-catalog-item:hover {
      background: var(--dark-elevated);
    }

    .cabinet-catalog-item.dragging {
      opacity: 0.5;
    }

    .cabinet-item-info {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .cabinet-item-sku {
      font-size: 10px;
      color: var(--text-muted);
      font-family: monospace;
    }

    .cabinet-item-name {
      font-size: 11px;
      color: var(--text);
      font-weight: 500;
    }

    .cabinet-item-size {
      font-size: 10px;
      color: var(--primary);
    }

    .cabinet-item-price {
      font-size: 11px;
      font-weight: 600;
      color: var(--success, #22c55e);
      margin-left: auto;
      padding: 2px 6px;
      background: rgba(34, 197, 94, 0.1);
      border-radius: 4px;
    }

    .cabinet-item-add {
      width: 24px;
      height: 24px;
      border-radius: 4px;
      background: var(--primary);
      border: none;
      color: white;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      font-weight: bold;
      transition: background 0.15s;
    }

    .cabinet-item-add:hover {
      background: var(--primary-dark);
    }

    .catalog-actions {
      margin-top: 10px;
      display: flex;
      gap: 6px;
    }

    .catalog-actions .btn {
      flex: 1;
      justify-content: center;
    }

    /* Product Catalog */
    .product-search-bar {
      display: flex;
      gap: 6px;
      margin-bottom: 10px;
    }

    .product-search-bar input {
      flex: 1;
      padding: 6px 10px;
      border: 1px solid var(--border);
      border-radius: 4px;
      background: var(--dark);
      color: var(--text);
      font-size: 12px;
    }

    .product-search-bar .search-icon {
      width: 28px;
      height: 28px;
      border: 1px solid var(--border);
      border-radius: 4px;
      background: var(--dark);
      color: var(--text-muted);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .product-filters {
      display: flex;
      gap: 6px;
      margin-bottom: 10px;
    }

    .product-filters select {
      flex: 1;
      padding: 6px 8px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 6px;
      background: rgba(255, 255, 255, 0.05);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      color: var(--text);
      font-size: 10px;
      cursor: pointer;
      transition: all 0.2s ease;
      appearance: none;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='10' height='10' viewBox='0 0 24 24' fill='none' stroke='%23888' stroke-width='2'%3E%3Cpath d='M6 9l6 6 6-6'/%3E%3C/svg%3E");
      background-repeat: no-repeat;
      background-position: right 6px center;
      padding-right: 22px;
    }

    .product-filters select:hover {
      background: rgba(255, 255, 255, 0.08);
      border-color: rgba(255, 255, 255, 0.2);
    }

    .product-filters select:focus {
      outline: none;
      border-color: var(--primary);
    }

    .product-catalog-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 8px;
      max-height: 240px;
      overflow-y: auto;
      padding: 4px;
      background: var(--dark);
      border-radius: 6px;
      border: 1px solid var(--border);
    }

    .product-card {
      background: var(--dark-elevated);
      border-radius: 6px;
      padding: 6px;
      cursor: pointer;
      transition: all 0.2s;
      border: 2px solid transparent;
    }

    .product-card:hover {
      border-color: var(--primary);
      transform: translateY(-2px);
    }

    .product-card.selected {
      border-color: var(--primary);
      background: rgba(59, 130, 246, 0.1);
    }

    .product-card-image {
      width: 100%;
      aspect-ratio: 1;
      border-radius: 4px;
      object-fit: cover;
      background: var(--dark);
      margin-bottom: 4px;
    }

    .product-card-name {
      font-size: 10px;
      font-weight: 500;
      color: var(--text);
      line-height: 1.2;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .product-card-meta {
      font-size: 9px;
      color: var(--text-muted);
      margin-top: 2px;
    }

    .product-hint {
      text-align: center;
      font-size: 10px;
      color: var(--text-muted);
      margin-top: 8px;
    }

    .loading-products {
      grid-column: 1 / -1;
      text-align: center;
      padding: 20px;
      color: var(--text-muted);
      font-size: 11px;
    }

    /* Marketplace Product Grid */
    .marketplace-product-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 8px;
      max-height: 280px;
      overflow-y: auto;
      padding: 4px;
      background: var(--dark);
      border-radius: 6px;
      border: 1px solid var(--border);
    }

    .marketplace-card {
      background: var(--dark-elevated);
      border-radius: 6px;
      padding: 6px;
      cursor: grab;
      transition: all 0.2s;
      border: 2px solid transparent;
      position: relative;
    }

    .marketplace-card:hover {
      border-color: var(--primary);
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    }

    .marketplace-card.out-of-stock {
      opacity: 0.5;
      pointer-events: none;
    }

    .marketplace-card-img {
      width: 100%;
      height: 80px;
      border-radius: 4px;
      object-fit: cover;
      background: var(--dark);
      margin-bottom: 4px;
    }

    .marketplace-card-name {
      font-size: 10px;
      font-weight: 500;
      color: var(--text);
      line-height: 1.2;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .marketplace-card-brand {
      font-size: 9px;
      color: var(--text-muted);
      margin-top: 1px;
    }

    .marketplace-card-price {
      font-size: 10px;
      font-weight: 600;
      color: var(--primary);
      margin-top: 2px;
    }

    .marketplace-card-badge {
      position: absolute;
      top: 4px;
      right: 4px;
      font-size: 8px;
      padding: 2px 5px;
      border-radius: 3px;
      font-weight: 600;
    }

    .marketplace-badge-instock {
      background: rgba(34, 197, 94, 0.2);
      color: #22c55e;
    }

    .marketplace-badge-low {
      background: rgba(245, 158, 11, 0.2);
      color: #f59e0b;
    }

    .marketplace-badge-out {
      background: rgba(239, 68, 68, 0.2);
      color: #ef4444;
    }

    .marketplace-card-distributor {
      font-size: 8px;
      color: var(--text-muted);
      margin-top: 2px;
      opacity: 0.7;
    }

    .marketplace-stock-filter {
      display: flex;
      align-items: center;
      gap: 4px;
      font-size: 10px;
      color: var(--text-muted);
      cursor: pointer;
      padding: 4px 0;
    }

    .marketplace-stock-filter input[type="checkbox"] {
      width: 12px;
      height: 12px;
      accent-color: var(--primary);
    }

    /* Canvas Area */
    .canvas-area {
      flex: 1;
      display: flex;
      flex-direction: column;
      background: #12121f;
      position: relative;
      overflow: hidden;
    }

    /* =============================================
       UPGRADED CANVAS TOOLBAR - Glassmorphic Design
       ============================================= */
    .canvas-toolbar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px 16px;
      background: linear-gradient(180deg,
        rgba(20, 20, 30, 0.92) 0%,
        rgba(15, 15, 25, 0.95) 100%);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      flex-shrink: 0;
      box-shadow: 0 2px 12px rgba(0, 0, 0, 0.3);
      position: relative;
    }

    .canvas-toolbar::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 50%;
      background: linear-gradient(180deg,
        rgba(255, 255, 255, 0.04) 0%,
        transparent 100%);
      pointer-events: none;
    }

    .toolbar-group {
      display: flex;
      align-items: center;
      gap: 8px;
      position: relative;
      z-index: 1;
    }

    .toolbar-btn-group {
      display: flex;
      align-items: center;
      background: linear-gradient(135deg,
        rgba(40, 40, 55, 0.7) 0%,
        rgba(30, 30, 45, 0.6) 100%);
      border: 1px solid rgba(255, 255, 255, 0.12);
      border-top-color: rgba(255, 255, 255, 0.18);
      border-radius: 10px;
      padding: 4px;
      gap: 3px;
      box-shadow:
        inset 0 1px 1px rgba(255, 255, 255, 0.06),
        0 2px 8px rgba(0, 0, 0, 0.15);
    }

    .toolbar-btn-group .btn {
      border-radius: 7px;
      border: none;
      background: transparent;
    }

    .toolbar-btn-group .btn:hover {
      background: rgba(255, 255, 255, 0.12);
    }

    .toolbar-divider {
      width: 1px;
      height: 28px;
      background: linear-gradient(180deg,
        transparent 0%,
        rgba(255, 255, 255, 0.2) 20%,
        rgba(255, 255, 255, 0.2) 80%,
        transparent 100%);
      margin: 0 12px;
    }

    .zoom-controls {
      display: flex;
      align-items: center;
      gap: 3px;
      background: linear-gradient(135deg,
        rgba(40, 40, 55, 0.7) 0%,
        rgba(30, 30, 45, 0.6) 100%);
      border: 1px solid rgba(255, 255, 255, 0.12);
      border-top-color: rgba(255, 255, 255, 0.18);
      border-radius: 10px;
      padding: 4px;
      box-shadow:
        inset 0 1px 1px rgba(255, 255, 255, 0.06),
        0 2px 8px rgba(0, 0, 0, 0.15);
    }

    .zoom-btn {
      width: 30px;
      height: 30px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: transparent;
      border: none;
      border-radius: 6px;
      color: var(--text-secondary);
      cursor: pointer;
      font-size: 16px;
      font-weight: 500;
      transition: all 0.15s ease;
    }

    .zoom-btn:hover {
      background: rgba(255, 255, 255, 0.08);
      color: var(--text);
    }

    .zoom-btn:active {
      background: rgba(249, 203, 0, 0.15);
      color: var(--gold);
      transform: scale(0.95);
    }

    .zoom-level {
      font-size: 12px;
      font-weight: 600;
      color: var(--gold);
      min-width: 52px;
      text-align: center;
      padding: 6px 10px;
      background: linear-gradient(135deg,
        rgba(249, 203, 0, 0.15) 0%,
        rgba(249, 203, 0, 0.08) 100%);
      border: 1px solid rgba(249, 203, 0, 0.2);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s ease;
      box-shadow: inset 0 1px 1px rgba(255, 255, 255, 0.1);
    }

    .zoom-level:hover {
      background: linear-gradient(135deg,
        rgba(249, 203, 0, 0.25) 0%,
        rgba(249, 203, 0, 0.15) 100%);
      border-color: rgba(249, 203, 0, 0.35);
      box-shadow: 0 2px 8px rgba(249, 203, 0, 0.2);
    }

    .canvas-info {
      display: flex;
      gap: 12px;
      font-size: 11px;
      color: var(--text-muted);
    }

    .canvas-info span {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 5px 12px;
      background: linear-gradient(135deg,
        rgba(255, 255, 255, 0.08) 0%,
        rgba(255, 255, 255, 0.03) 100%);
      border-radius: 8px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      box-shadow: inset 0 1px 1px rgba(255, 255, 255, 0.05);
    }

    .canvas-info span::before {
      content: '';
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: linear-gradient(135deg, var(--gold) 0%, #e6b800 100%);
      box-shadow: 0 0 6px rgba(249, 203, 0, 0.4);
    }

    /* Help Button in Canvas Info */
    .help-btn {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 28px;
      height: 28px;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 6px;
      color: var(--text-muted);
      cursor: pointer;
      transition: all 0.2s ease;
    }
    .help-btn:hover {
      background: rgba(255, 255, 255, 0.1);
      color: var(--gold);
      border-color: var(--gold);
    }

    /* Save Status Indicator */
    .save-status {
      cursor: default;
      transition: all 0.3s ease;
    }
    .save-status::before {
      display: none !important; /* Override the dot */
    }
    .save-status .save-icon {
      flex-shrink: 0;
    }
    .save-status .save-text {
      font-size: 10px;
    }
    .save-status.saved {
      color: #22c55e;
    }
    .save-status.saved .save-icon {
      stroke: #22c55e;
    }
    .save-status.saving {
      color: #f59e0b;
    }
    .save-status.saving .save-icon {
      stroke: #f59e0b;
      animation: pulse 1s ease-in-out infinite;
    }
    .save-status.unsaved {
      color: #ef4444;
    }
    .save-status.unsaved .save-icon {
      stroke: #ef4444;
    }
    .save-status.error {
      color: #ef4444;
    }
    .save-status.error .save-icon {
      stroke: #ef4444;
    }
    .save-status .save-time {
      font-size: 9px;
      opacity: 0.7;
      margin-left: 4px;
    }
    .save-status.saved .save-time {
      color: var(--text-muted);
    }
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    /* Tooltip Enhancement */
    [data-tooltip] {
      position: relative;
    }

    [data-tooltip]::after {
      content: attr(data-tooltip);
      position: absolute;
      bottom: calc(100% + 8px);
      left: 50%;
      transform: translateX(-50%);
      padding: 6px 10px;
      background: rgba(15, 15, 26, 0.95);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 6px;
      font-size: 11px;
      font-weight: 500;
      color: var(--text);
      white-space: nowrap;
      opacity: 0;
      visibility: hidden;
      transition: all 0.15s ease;
      z-index: 1000;
      pointer-events: none;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    }

    [data-tooltip]::before {
      content: '';
      position: absolute;
      bottom: calc(100% + 4px);
      left: 50%;
      transform: translateX(-50%);
      border: 5px solid transparent;
      border-top-color: rgba(15, 15, 26, 0.95);
      opacity: 0;
      visibility: hidden;
      transition: all 0.15s ease;
      z-index: 1001;
    }

    [data-tooltip]:hover::after,
    [data-tooltip]:hover::before {
      opacity: 1;
      visibility: visible;
    }

    .shortcut-key {
      display: inline-block;
      padding: 2px 5px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 3px;
      font-size: 10px;
      font-family: monospace;
      margin-left: 6px;
      color: var(--gold);
    }

    .canvas-wrapper {
      flex: 1;
      position: relative;
      overflow: hidden;
      cursor: crosshair;
    }

    #canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }

    /* 3D View */
    #three-container {
      position: absolute;
      inset: 0;
      display: none;
      overflow: hidden;
    }

    #three-container.active {
      display: block;
    }

    /* =============================================
       UPGRADED 3D VIEW CONTROLS - Modern Design
       ============================================= */
    .three-controls {
      position: absolute;
      bottom: 20px;
      left: 20px;
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
      z-index: 100;
      max-width: calc(100% - 250px);
      background: rgba(15, 15, 26, 0.75);
      backdrop-filter: blur(16px);
      -webkit-backdrop-filter: blur(16px);
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 12px;
      padding: 6px;
    }

    .three-controls button {
      padding: 8px 12px;
      background: transparent;
      border: 1px solid transparent;
      border-radius: 8px;
      color: var(--text-secondary);
      font-size: 11px;
      font-weight: 500;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 6px;
      transition: all 0.15s ease;
      white-space: nowrap;
    }

    .three-controls button:hover {
      background: rgba(255, 255, 255, 0.08);
      color: var(--text);
    }

    .three-controls button:active {
      transform: scale(0.97);
    }

    .three-controls button.active {
      background: linear-gradient(135deg, var(--primary) 0%, #8b5cf6 100%);
      color: white;
      border-color: transparent;
      box-shadow: 0 2px 8px rgba(99, 102, 241, 0.3);
    }

    .three-controls button svg {
      width: 16px;
      height: 16px;
      flex-shrink: 0;
      transition: transform 0.15s ease;
    }

    .three-controls button:hover svg {
      transform: scale(1.1);
    }

    /* 3D Control Groups */
    .three-controls-group {
      display: flex;
      gap: 2px;
      padding: 3px;
      background: rgba(255, 255, 255, 0.03);
      border-radius: 8px;
      margin-right: 4px;
    }

    .three-controls-divider {
      width: 1px;
      height: 28px;
      background: rgba(255, 255, 255, 0.1);
      margin: 0 4px;
      align-self: center;
    }

    .three-hint {
      position: absolute;
      bottom: 20px;
      right: 20px;
      padding: 10px 14px;
      background: rgba(15, 15, 26, 0.8);
      backdrop-filter: blur(16px);
      -webkit-backdrop-filter: blur(16px);
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 10px;
      font-size: 11px;
      color: var(--text-secondary);
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .three-hint span {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .three-hint .hint-key {
      display: inline-block;
      padding: 2px 6px;
      background: rgba(255, 255, 255, 0.08);
      border-radius: 4px;
      font-family: monospace;
      font-size: 10px;
      color: var(--gold);
    }

    .three-hint.walkthrough-hint {
      background: linear-gradient(135deg, rgba(139, 92, 246, 0.95), rgba(59, 130, 246, 0.95));
      color: white;
      font-size: 12px;
      padding: 12px 18px;
      border: 1px solid rgba(255, 255, 255, 0.15);
      box-shadow: 0 8px 24px rgba(99, 102, 241, 0.35);
      animation: walkthroughPulse 2s ease-in-out infinite;
    }

    @keyframes walkthroughPulse {
      0%, 100% { box-shadow: 0 8px 24px rgba(99, 102, 241, 0.35); }
      50% { box-shadow: 0 8px 32px rgba(139, 92, 246, 0.5); }
    }

    /* Lighting Control Panel */
    .lighting-panel {
      position: absolute;
      top: 60px;
      right: 20px;
      width: 280px;
      background: rgba(15, 15, 26, 0.95);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      box-shadow: 0 12px 40px rgba(0, 0, 0, 0.5);
      z-index: 100;
      overflow: hidden;
    }

    .lighting-panel-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 16px;
      background: rgba(99, 102, 241, 0.15);
      border-bottom: 1px solid rgba(255, 255, 255, 0.08);
      font-weight: 600;
      font-size: 13px;
      color: var(--text);
    }

    .lighting-panel-header .close-btn {
      background: none;
      border: none;
      color: var(--text-secondary);
      font-size: 20px;
      cursor: pointer;
      padding: 0 4px;
      line-height: 1;
    }

    .lighting-panel-header .close-btn:hover {
      color: var(--text);
    }

    .lighting-panel-content {
      padding: 16px;
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    .lighting-presets label,
    .lighting-slider label {
      display: block;
      font-size: 11px;
      font-weight: 500;
      color: var(--text-secondary);
      margin-bottom: 8px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .preset-buttons {
      display: flex;
      gap: 8px;
    }

    .preset-btn {
      flex: 1;
      padding: 10px 8px;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 8px;
      font-size: 18px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .preset-btn:hover {
      background: rgba(255, 255, 255, 0.1);
      transform: translateY(-2px);
    }

    .preset-btn.active {
      background: linear-gradient(135deg, var(--primary), #8b5cf6);
      border-color: transparent;
      box-shadow: 0 4px 12px rgba(99, 102, 241, 0.4);
    }

    .lighting-slider {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .lighting-slider input[type="range"] {
      -webkit-appearance: none;
      appearance: none;
      width: 100%;
      height: 6px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 3px;
      outline: none;
    }

    .lighting-slider input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 16px;
      height: 16px;
      background: linear-gradient(135deg, var(--primary), #8b5cf6);
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 0 2px 8px rgba(99, 102, 241, 0.5);
    }

    .lighting-slider span {
      font-size: 11px;
      color: var(--gold);
      text-align: right;
    }

    .lighting-toggle {
      padding-top: 8px;
      border-top: 1px solid rgba(255, 255, 255, 0.08);
    }

    .lighting-toggle label {
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 12px;
      color: var(--text-secondary);
      cursor: pointer;
    }

    .lighting-toggle input[type="checkbox"] {
      width: 16px;
      height: 16px;
      accent-color: var(--primary);
    }

    .hd-badge {
      background: linear-gradient(135deg, #FFD700, #FFA500);
      color: #000;
      padding: 2px 6px;
      border-radius: 4px;
      font-size: 9px;
      font-weight: 600;
      margin-left: 4px;
    }

    .hd-toggle label {
      justify-content: space-between;
    }

    .three-hint.walkthrough-hint strong {
      display: block;
      margin-bottom: 6px;
      font-size: 13px;
      letter-spacing: 0.3px;
    }

    .three-hint.walkthrough-hint .hint-key {
      background: rgba(255, 255, 255, 0.2);
      color: white;
    }

    /* =============================================
       FLOATING QUICK-ACTION TOOLBAR - Glassmorphic
       ============================================= */
    .floating-toolbar {
      position: fixed;
      bottom: 24px;
      left: 50%;
      transform: translateX(-50%) translateY(100px);
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 10px 16px;
      background: linear-gradient(135deg,
        rgba(20, 20, 30, 0.92) 0%,
        rgba(15, 15, 25, 0.95) 50%,
        rgba(25, 25, 35, 0.93) 100%);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      border: 1px solid rgba(255, 255, 255, 0.15);
      border-top-color: rgba(255, 255, 255, 0.25);
      border-left-color: rgba(255, 255, 255, 0.2);
      border-radius: 20px;
      box-shadow:
        0 12px 40px rgba(0, 0, 0, 0.35),
        0 4px 12px rgba(0, 0, 0, 0.2),
        inset 0 1px 2px rgba(255, 255, 255, 0.1),
        inset 0 -1px 2px rgba(0, 0, 0, 0.1);
      z-index: 500;
      opacity: 0;
      visibility: hidden;
      transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
    }

    .floating-toolbar::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 50%;
      background: linear-gradient(180deg,
        rgba(255, 255, 255, 0.06) 0%,
        transparent 100%);
      pointer-events: none;
      border-radius: 20px 20px 0 0;
    }

    .floating-toolbar.visible {
      opacity: 1;
      visibility: visible;
      transform: translateX(-50%) translateY(0);
    }

    .floating-toolbar-group {
      display: flex;
      align-items: center;
      gap: 3px;
      padding: 5px 6px;
      background: linear-gradient(135deg,
        rgba(40, 40, 55, 0.6) 0%,
        rgba(30, 30, 45, 0.5) 100%);
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      box-shadow: inset 0 1px 1px rgba(255, 255, 255, 0.05);
    }

    .floating-toolbar-divider {
      width: 1px;
      height: 32px;
      background: linear-gradient(180deg,
        transparent 0%,
        rgba(255, 255, 255, 0.2) 20%,
        rgba(255, 255, 255, 0.2) 80%,
        transparent 100%);
      margin: 0 8px;
    }

    .float-btn {
      width: 40px;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: linear-gradient(135deg,
        rgba(50, 50, 65, 0.7) 0%,
        rgba(40, 40, 55, 0.6) 100%);
      border: 1px solid rgba(255, 255, 255, 0.12);
      border-radius: 10px;
      color: var(--text-secondary);
      cursor: pointer;
      transition: all 0.2s ease;
      position: relative;
    }

    .float-btn:hover {
      background: linear-gradient(135deg,
        rgba(255, 255, 255, 0.15) 0%,
        rgba(255, 255, 255, 0.08) 100%);
      border-color: rgba(255, 255, 255, 0.2);
      color: var(--text);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
    }

    .float-btn:hover svg {
      transform: scale(1.1);
    }

    .float-btn:active {
      transform: scale(0.95);
      background: rgba(255, 255, 255, 0.2);
    }

    .float-btn.primary {
      background: linear-gradient(135deg, var(--gold) 0%, #e6b800 100%);
      border-color: rgba(255, 255, 255, 0.3);
      color: #000;
      box-shadow: 0 4px 16px rgba(249, 203, 0, 0.3);
    }

    .float-btn.primary:hover {
      background: linear-gradient(135deg, #ffe033 0%, var(--gold) 100%);
      box-shadow: 0 4px 12px rgba(249, 203, 0, 0.35);
    }

    .float-btn.danger:hover {
      background: rgba(239, 68, 68, 0.2);
      color: #ef4444;
    }

    .float-btn svg {
      width: 18px;
      height: 18px;
      transition: transform 0.15s ease;
    }

    .float-btn .shortcut {
      position: absolute;
      bottom: -2px;
      right: 2px;
      font-size: 8px;
      font-weight: 700;
      font-family: monospace;
      color: var(--gold);
      opacity: 0.6;
    }

    .float-btn:hover .shortcut {
      opacity: 1;
    }

    /* Selection info badge */
    .selection-badge {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 6px 12px;
      background: rgba(249, 203, 0, 0.1);
      border: 1px solid rgba(249, 203, 0, 0.2);
      border-radius: 8px;
      font-size: 11px;
      font-weight: 600;
      color: var(--gold);
      margin-right: 4px;
    }

    .selection-badge .count {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      min-width: 18px;
      height: 18px;
      background: var(--gold);
      color: #000;
      border-radius: 9px;
      font-size: 10px;
      font-weight: 700;
    }

    /* Floating toolbar mobile optimization */
    @media (max-width: 600px) {
      .floating-toolbar {
        bottom: 80px !important; /* Above mobile toolbar */
        padding: 6px 10px !important;
        max-width: calc(100% - 24px) !important;
        flex-wrap: wrap !important;
      }

      .floating-toolbar-group {
        padding: 3px 4px !important;
      }

      .floating-toolbar-divider {
        display: none !important;
      }

      .float-btn {
        width: 36px !important;
        height: 36px !important;
        padding: 6px !important;
      }

      .float-btn svg {
        width: 16px !important;
        height: 16px !important;
      }

      .float-btn .shortcut {
        display: none !important;
      }

      .selection-badge {
        display: none !important; /* Too cluttered on mobile */
      }
    }

    /* Right Panel */
    .right-panel {
      width: 260px;
      min-width: 260px;
      max-width: 260px;
      background: linear-gradient(180deg, rgba(30, 30, 46, 0.98) 0%, rgba(26, 26, 38, 0.98) 100%);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      border-left: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      flex-shrink: 0;
      flex-grow: 0;
      overflow-y: auto;
      overflow-x: hidden;
      box-shadow: -2px 0 8px rgba(0, 0, 0, 0.15);
      max-height: 100%;
    }

    .panel-section {
      padding: 8px 10px;
      border-bottom: 1px solid var(--border);
      flex-shrink: 0;
    }

    .panel-section.collapsed .panel-content {
      display: none;
    }

    .panel-section.collapsed .panel-title .toggle-icon {
      transform: rotate(-90deg);
    }

    .panel-title {
      font-size: 10px;
      font-weight: 600;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.3px;
      margin-bottom: 6px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      cursor: pointer;
      user-select: none;
      gap: 6px;
    }

    .panel-title .toggle-icon {
      font-size: 8px;
      transition: transform 0.2s;
      opacity: 0.5;
    }

    .panel-title:hover .toggle-icon {
      opacity: 1;
    }

    /* Element Selector Styles */
    #elementSelectorSection .panel-title {
      display: flex;
      align-items: center;
    }

    .element-total-count {
      background: var(--accent);
      color: white;
      font-size: 10px;
      padding: 2px 6px;
      border-radius: 10px;
      margin-left: auto;
      font-weight: 600;
    }

    .element-type-selector {
      display: flex;
      flex-direction: column;
      gap: 4px;
      max-height: 200px;
      overflow-y: auto;
    }

    .element-type-row {
      display: flex;
      align-items: center;
      padding: 6px 8px;
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.15s ease;
      gap: 8px;
    }

    .element-type-row:hover {
      background: var(--dark-surface);
      border-color: var(--accent);
    }

    .element-type-row.active {
      background: rgba(99, 102, 241, 0.15);
      border-color: var(--accent);
    }

    .element-type-row.has-selection {
      border-left: 3px solid var(--accent);
    }

    .element-type-checkbox {
      width: 16px;
      height: 16px;
      border-radius: 4px;
      border: 2px solid var(--border);
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
    }

    .element-type-row.active .element-type-checkbox {
      background: var(--accent);
      border-color: var(--accent);
    }

    .element-type-row.active .element-type-checkbox::after {
      content: '';
      color: white;
      font-size: 10px;
      font-weight: bold;
    }

    .element-type-label {
      flex: 1;
      font-size: 12px;
      color: var(--text);
      text-transform: capitalize;
    }

    .element-type-count {
      background: var(--dark-surface);
      color: var(--text-muted);
      font-size: 10px;
      padding: 2px 6px;
      border-radius: 8px;
      font-weight: 500;
    }

    .element-type-row.active .element-type-count {
      background: var(--accent);
      color: white;
    }

    .element-instance-list {
      margin-top: 8px;
      padding-top: 8px;
      border-top: 1px solid var(--border);
      max-height: 150px;
      overflow-y: auto;
    }

    .element-instance-item {
      display: flex;
      align-items: center;
      padding: 5px 8px;
      margin-bottom: 3px;
      background: var(--dark-surface);
      border-radius: 4px;
      cursor: pointer;
      font-size: 11px;
      color: var(--text-secondary);
      transition: all 0.1s ease;
    }

    .element-instance-item:hover {
      background: var(--dark-elevated);
      color: var(--text);
    }

    .element-instance-item.selected {
      background: rgba(99, 102, 241, 0.2);
      color: var(--accent);
      font-weight: 500;
    }

    .element-instance-dims {
      margin-left: auto;
      font-size: 10px;
      color: var(--text-muted);
    }

    .element-selector-actions {
      display: flex;
      gap: 6px;
      margin-top: 8px;
      padding-top: 8px;
      border-top: 1px solid var(--border);
    }

    .btn-small {
      padding: 4px 8px;
      font-size: 11px;
      border-radius: 4px;
      border: none;
      cursor: pointer;
      transition: all 0.15s ease;
    }

    .btn-small.btn-primary {
      background: var(--accent);
      color: white;
    }

    .btn-small.btn-secondary {
      background: var(--dark-elevated);
      color: var(--text-secondary);
      border: 1px solid var(--border);
    }

    .btn-small.btn-danger {
      background: var(--error);
      color: white;
    }

    .btn-small:hover {
      opacity: 0.85;
      transform: translateY(-1px);
    }

    .no-elements-msg {
      color: var(--text-muted);
      font-size: 11px;
      text-align: center;
      padding: 12px;
    }

    /* Flat Element List Styles */
    .element-flat-list {
      border: 1px solid var(--border);
      border-radius: 8px;
      background: var(--dark-bg);
      overflow: hidden;
    }

    .element-list-item {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px 12px;
      cursor: pointer;
      border-bottom: 1px solid var(--border);
      transition: all 0.2s ease;
      position: relative;
    }

    .element-list-item:last-child {
      border-bottom: none;
    }

    .element-list-item:hover {
      background: linear-gradient(90deg, var(--dark-elevated), transparent);
      padding-left: 16px;
    }

    .element-list-item.selected {
      background: linear-gradient(90deg, rgba(99, 102, 241, 0.2), rgba(99, 102, 241, 0.05));
      border-left: 3px solid var(--primary);
    }

    .element-list-item.selected::before {
      content: '';
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      width: 3px;
      background: linear-gradient(180deg, var(--primary), #8b5cf6);
    }

    .element-list-icon {
      width: 28px;
      height: 28px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: linear-gradient(135deg, var(--dark-elevated), var(--dark-surface));
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 6px;
      font-size: 12px;
      flex-shrink: 0;
    }

    .element-list-item.selected .element-list-icon {
      background: linear-gradient(135deg, var(--primary), #8b5cf6);
      border-color: transparent;
      color: white;
    }

    .element-list-info {
      flex: 1;
      min-width: 0;
      overflow: hidden;
    }

    .element-list-name {
      font-size: 13px;
      font-weight: 500;
      color: var(--text);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .element-list-meta {
      font-size: 11px;
      color: var(--text-muted);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      margin-top: 2px;
    }

    /* Item Picker / Quote List Styles */
    .item-picker-total {
      background: linear-gradient(135deg, #22c55e, #16a34a);
      color: white;
      font-size: 11px;
      padding: 3px 8px;
      border-radius: 4px;
      font-weight: 600;
    }

    .item-picker-controls {
      margin-bottom: 8px;
    }

    .item-filter {
      width: 100%;
      padding: 6px 8px;
      font-size: 11px;
    }

    .item-picker-list {
      min-height: 100px;
      max-height: 280px;
      overflow-y: auto;
      border: 1px solid var(--border);
      border-radius: 6px;
      background: var(--dark-surface);
      flex: 1 1 auto;
    }

    .item-picker-item {
      display: flex;
      flex-direction: column;
      padding: 8px 10px;
      border-bottom: 1px solid var(--border);
      cursor: pointer;
      transition: all 0.15s ease;
    }

    .item-picker-item:last-child {
      border-bottom: none;
    }

    .item-picker-item:hover {
      background: var(--dark-elevated);
    }

    .item-picker-item.selected {
      background: rgba(99, 102, 241, 0.15);
      border-left: 3px solid var(--accent);
    }

    .item-row-main {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .item-checkbox {
      width: 18px;
      height: 18px;
      cursor: pointer;
      accent-color: var(--accent);
      flex-shrink: 0;
      margin: 0;
      border-radius: 4px;
    }

    .item-checkbox:checked {
      background: var(--accent);
    }

    .item-icon {
      width: 24px;
      height: 24px;
      background: var(--dark-elevated);
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      flex-shrink: 0;
    }

    .item-details {
      flex: 1;
      min-width: 0;
    }

    .item-name {
      font-size: 12px;
      font-weight: 500;
      color: var(--text);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .item-meta {
      font-size: 10px;
      color: var(--text-muted);
      display: flex;
      gap: 8px;
    }

    .item-price {
      font-size: 11px;
      font-weight: 600;
      color: #22c55e;
      white-space: nowrap;
    }

    .item-row-secondary {
      display: flex;
      justify-content: space-between;
      margin-top: 4px;
      padding-left: 46px;
    }

    .item-material {
      font-size: 10px;
      color: var(--accent);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 120px;
    }

    .item-dims {
      font-size: 10px;
      color: var(--text-muted);
    }

    .item-detail-line {
      font-size: 10px;
      margin-top: 2px;
      color: var(--text-muted);
    }

    .item-sku {
      background: rgba(99, 102, 241, 0.2);
      color: var(--accent);
      padding: 1px 4px;
      border-radius: 3px;
      font-family: monospace;
      font-size: 9px;
    }

    .item-catalog {
      color: var(--text-muted);
      font-size: 9px;
    }

    .item-sqft {
      color: #22c55e;
      font-weight: 500;
    }

    .item-rate {
      color: var(--text-muted);
      font-style: italic;
    }

    .item-picker-summary {
      margin-top: 8px;
      padding: 8px;
      background: var(--dark-elevated);
      border-radius: 6px;
    }

    .summary-row {
      display: flex;
      justify-content: space-between;
      font-size: 11px;
      color: var(--text-secondary);
      margin-bottom: 4px;
    }

    .summary-row:last-child {
      margin-bottom: 0;
      font-weight: 600;
      color: var(--text);
    }

    .item-picker-actions {
      display: flex;
      gap: 6px;
      margin-top: 8px;
    }

    .item-picker-empty {
      padding: 20px;
      text-align: center;
      color: var(--text-muted);
      font-size: 12px;
    }

    /* Room Templates Styles */
    #roomTemplatesSection .panel-content {
      max-height: 200px;
      overflow-y: auto;
    }

    .room-templates-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 4px;
    }

    .template-btn {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 6px 4px;
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.15s ease;
      color: var(--text);
    }

    .template-btn:hover {
      background: var(--dark-surface);
      border-color: var(--accent);
      transform: translateY(-1px);
    }

    .template-btn:active {
      transform: translateY(0);
    }

    .template-icon {
      font-size: 16px;
      margin-bottom: 2px;
    }

    .template-name {
      font-size: 9px;
      font-weight: 500;
      color: var(--text-secondary);
    }

    .template-btn:hover .template-name {
      color: var(--accent);
    }

    .template-hint {
      font-size: 8px;
      color: var(--text-muted);
      text-align: center;
      margin-top: 6px;
      margin-bottom: 0;
      opacity: 0.7;
    }

    .room-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 6px;
    }

    .input-group {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .input-label {
      font-size: 10px;
      color: var(--text-muted);
      font-weight: 500;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .input-field {
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 8px 10px;
      color: var(--text);
      font-size: 12px;
      transition: all 0.2s ease;
    }

    .input-field:hover {
      border-color: rgba(255, 255, 255, 0.2);
    }

    .input-field:focus {
      outline: none;
      border-color: var(--primary);
      box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.15);
    }

    select.input-field {
      cursor: pointer;
      appearance: none;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' fill='%238b8b8b' viewBox='0 0 24 24'%3E%3Cpath d='M7 10l5 5 5-5z'/%3E%3C/svg%3E");
      background-repeat: no-repeat;
      background-position: right 8px center;
      padding-right: 28px;
    }

    /* Properties Panel */
    .properties-empty {
      text-align: center;
      padding: 20px 12px;
      color: var(--text-muted);
      font-size: 12px;
      background: rgba(255, 255, 255, 0.02);
      border-radius: 8px;
      border: 1px dashed var(--border);
    }

    .quick-actions {
      display: flex;
      gap: 6px;
    }

    .quick-btn {
      padding: 8px;
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      border-radius: 8px;
      cursor: pointer;
      color: var(--text-secondary);
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .quick-btn:hover {
      background: linear-gradient(135deg, var(--gold), #d4a944);
      color: var(--dark-bg);
      border-color: var(--gold);
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(249, 203, 0, 0.25);
    }

    .quick-btn.danger:hover {
      background: linear-gradient(135deg, #ef4444, #dc2626);
      border-color: #ef4444;
      color: white;
      box-shadow: 0 4px 12px rgba(239, 68, 68, 0.25);
    }

    /* Visibility toggle styles */
    .visibility-toggle {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 4px 6px;
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      border-radius: 4px;
      cursor: pointer;
      font-size: 10px;
      color: var(--text-secondary);
      transition: all 0.15s;
    }

    .visibility-toggle:hover {
      background: rgba(200, 169, 106, 0.1);
      border-color: var(--gold);
    }

    .visibility-toggle input[type="checkbox"] {
      width: 14px;
      height: 14px;
      margin: 0;
      cursor: pointer;
      accent-color: var(--gold);
    }

    .visibility-toggle input[type="checkbox"]:not(:checked) + span {
      text-decoration: line-through;
      opacity: 0.5;
    }

    /* Collapsible panel styles */
    .collapsible-header {
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .collapsible-header:hover {
      color: var(--gold);
    }

    .panel-toggle {
      font-size: 10px;
      transition: transform 0.2s;
    }

    .collapsible-panel .panel-content {
      overflow: hidden;
      transition: max-height 0.3s ease, padding 0.3s ease;
      max-height: 500px;
    }

    .collapsible-panel .panel-content.collapsed {
      max-height: 0;
      padding-top: 0;
      padding-bottom: 0;
    }

    .property-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
      gap: 8px;
    }

    .property-label {
      font-size: 10px;
      color: var(--text-secondary);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      flex-shrink: 1;
      min-width: 0;
    }

    .property-input {
      width: 65px;
      min-width: 50px;
      flex-shrink: 0;
      background: rgba(255, 255, 255, 0.05);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 5px;
      padding: 5px 6px;
      color: var(--text);
      font-size: 11px;
      text-align: right;
      transition: all 0.2s ease;
    }

    .property-input:hover {
      background: rgba(255, 255, 255, 0.08);
      border-color: rgba(255, 255, 255, 0.2);
    }

    .property-input:focus {
      outline: none;
      border-color: var(--primary);
      box-shadow: 0 0 0 3px rgba(249, 203, 0, 0.15);
    }

    .property-select {
      width: 95px;
      min-width: 70px;
      flex-shrink: 0;
      background: rgba(255, 255, 255, 0.05);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 5px;
      padding: 5px 6px;
      color: var(--text);
      font-size: 10px;
      cursor: pointer;
      transition: all 0.2s ease;
      appearance: none;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='10' height='10' viewBox='0 0 24 24' fill='none' stroke='%23888' stroke-width='2'%3E%3Cpath d='M6 9l6 6 6-6'/%3E%3C/svg%3E");
      background-repeat: no-repeat;
      background-position: right 5px center;
      padding-right: 18px;
    }

    .property-select:hover {
      background: rgba(255, 255, 255, 0.08);
      border-color: rgba(255, 255, 255, 0.2);
    }

    .property-select:focus {
      outline: none;
      border-color: var(--primary);
    }

    .checkbox-group {
      display: flex;
      gap: 10px;
      font-size: 10px;
    }

    .checkbox-group label {
      display: flex;
      align-items: center;
      gap: 4px;
      cursor: pointer;
    }

    .checkbox-group input[type="checkbox"] {
      width: 12px;
      height: 12px;
      accent-color: var(--primary);
    }

    .seam-controls {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .seam-btn {
      padding: 3px 8px;
      font-size: 10px;
      background: var(--primary);
      color: white;
      border: none;
      border-radius: 3px;
      cursor: pointer;
    }

    .seam-btn:hover {
      background: var(--accent);
    }

    .seam-btn.seam-clear {
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      color: var(--text-muted);
    }

    .seam-btn.seam-clear:hover {
      border-color: #dc3545;
      color: #dc3545;
    }

    .seam-count {
      font-size: 10px;
      color: var(--text-muted);
    }

    .dimension-display {
      font-size: 10px;
      color: var(--gold);
      margin-left: 6px;
      white-space: nowrap;
      min-width: 50px;
    }

    .color-picker {
      width: 70px;
      height: 26px;
      border: 1px solid var(--border);
      border-radius: 4px;
      cursor: pointer;
      padding: 0;
    }

    .texture-preview {
      width: 70px;
      height: 40px;
      border-radius: 4px;
      background-size: cover;
      background-position: center;
      border: 1px solid var(--border);
      cursor: pointer;
    }

    .texture-preview:hover {
      border-color: var(--primary);
    }

    .texture-controls {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .texture-upload-btn,
    .texture-clear-btn {
      width: 28px;
      height: 28px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      border-radius: 4px;
      cursor: pointer;
      color: var(--text-secondary);
      font-size: 12px;
      padding: 0;
    }

    .texture-upload-btn:hover {
      background: var(--primary);
      border-color: var(--primary);
      color: white;
    }

    .texture-clear-btn:hover {
      background: var(--error);
      border-color: var(--error);
      color: white;
    }

    .texture-upload-btn svg {
      width: 14px;
      height: 14px;
    }

    /* Grain Direction Controls */
    .grain-direction-controls {
      display: flex;
      gap: 4px;
    }

    .grain-btn {
      width: 28px;
      height: 28px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      border-radius: 4px;
      cursor: pointer;
      color: var(--text-secondary);
      font-size: 14px;
      font-weight: bold;
      padding: 0;
      transition: all 0.2s;
    }

    .grain-btn:hover {
      background: var(--primary);
      border-color: var(--primary);
      color: white;
    }

    .grain-btn.active {
      background: var(--gold);
      border-color: var(--gold);
      color: var(--dark-bg);
    }

    /* Validation Panel */
    .validation-section {
      border-bottom: 1px solid var(--border);
      padding-bottom: 8px;
      margin-bottom: 8px;
    }

    .validation-section .panel-title {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .validation-toggle,
    .validation-refresh {
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      border-radius: 4px;
      color: var(--text-secondary);
      cursor: pointer;
      font-size: 12px;
      padding: 2px 6px;
      margin-left: auto;
    }

    .validation-toggle:hover,
    .validation-refresh:hover {
      background: var(--primary);
      color: white;
      border-color: var(--primary);
    }

    .validation-toggle.active {
      background: var(--success);
      color: white;
      border-color: var(--success);
    }

    .validation-content {
      padding: 8px 16px;
      font-size: 11px;
      max-height: 180px;
      overflow-y: auto;
    }

    .validation-hint {
      color: var(--text-muted);
      font-style: italic;
    }

    .validation-ok {
      color: var(--success);
      font-weight: 500;
    }

    .validation-category {
      margin-bottom: 10px;
    }

    .validation-category-title {
      font-weight: 600;
      color: var(--text-secondary);
      margin-bottom: 4px;
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .validation-issue {
      display: flex;
      align-items: flex-start;
      gap: 6px;
      padding: 4px 0;
      border-bottom: 1px solid var(--border);
    }

    .validation-issue:last-child {
      border-bottom: none;
    }

    .validation-icon {
      flex-shrink: 0;
      font-size: 12px;
    }

    .validation-error .validation-icon {
      color: var(--error);
    }

    .validation-warning .validation-icon {
      color: var(--gold);
    }

    .validation-info .validation-icon {
      color: var(--primary);
    }

    .validation-message {
      color: var(--text-secondary);
      line-height: 1.3;
    }

    /* Quote Panel */
    .quote-section {
      flex: 1;
      display: flex;
      flex-direction: column;
      min-height: 0;
    }

    .quote-items {
      flex: 1;
      overflow-y: auto;
      padding: 0 16px;
    }

    .quote-item {
      display: flex;
      justify-content: space-between;
      padding: 8px 0;
      border-bottom: 1px solid var(--border);
      font-size: 11px;
    }

    .quote-item-name {
      color: var(--text-secondary);
    }

    .quote-item-value {
      color: var(--text);
      font-weight: 500;
    }

    .quote-total {
      padding: 12px 16px;
      background: var(--dark-elevated);
      border-top: 1px solid var(--border);
    }

    .quote-total-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .quote-total-label {
      font-size: 12px;
      font-weight: 600;
      color: var(--text);
    }

    .quote-total-value {
      font-size: 18px;
      font-weight: 700;
      color: var(--gold);
    }

    .quote-actions {
      padding-top: 12px;
      border-top: 1px solid var(--border);
    }

    .btn-checkout {
      width: 100%;
      padding: 12px 16px;
      background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%);
      color: white;
      border: none;
      border-radius: 8px;
      font-size: 13px;
      font-weight: 600;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
      box-shadow: 0 2px 8px rgba(34, 197, 94, 0.3);
    }

    .btn-checkout:hover {
      background: linear-gradient(135deg, #16a34a 0%, #15803d 100%);
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(34, 197, 94, 0.4);
    }

    .btn-checkout:disabled {
      background: #4a4a5a;
      cursor: not-allowed;
      box-shadow: none;
      transform: none;
    }

    .quote-disclaimer {
      font-size: 10px;
      color: var(--text-secondary);
      text-align: center;
      margin: 8px 0 0;
      line-height: 1.4;
    }

    /* Payment Modal */
    .payment-modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.7);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10000;
      backdrop-filter: blur(4px);
    }

    .payment-modal {
      background: var(--dark-elevated);
      border-radius: 16px;
      width: 90%;
      max-width: 480px;
      max-height: 90vh;
      overflow-y: auto;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
      border: 1px solid var(--border);
    }

    .payment-modal-header {
      padding: 20px 24px;
      border-bottom: 1px solid var(--border);
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .payment-modal-header h2 {
      font-size: 18px;
      font-weight: 600;
      margin: 0;
      color: var(--text);
    }

    .payment-modal-close {
      background: none;
      border: none;
      color: var(--text-secondary);
      cursor: pointer;
      padding: 4px;
      border-radius: 4px;
      transition: all 0.2s;
    }

    .payment-modal-close:hover {
      color: var(--text);
      background: var(--border);
    }

    .payment-modal-body {
      padding: 24px;
    }

    .payment-summary {
      background: rgba(255, 255, 255, 0.03);
      border-radius: 12px;
      padding: 16px;
      margin-bottom: 20px;
    }

    .payment-summary-row {
      display: flex;
      justify-content: space-between;
      padding: 8px 0;
      font-size: 13px;
    }

    .payment-summary-row.total {
      border-top: 1px solid var(--border);
      margin-top: 8px;
      padding-top: 12px;
      font-weight: 600;
      font-size: 15px;
    }

    .payment-summary-row .label {
      color: var(--text-secondary);
    }

    .payment-summary-row .value {
      color: var(--text);
    }

    .payment-summary-row.total .value {
      color: var(--gold);
    }

    .payment-options {
      margin-bottom: 20px;
    }

    .payment-option {
      background: rgba(255, 255, 255, 0.03);
      border: 2px solid var(--border);
      border-radius: 12px;
      padding: 16px;
      margin-bottom: 12px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .payment-option:hover {
      border-color: var(--accent-color);
      background: rgba(139, 92, 246, 0.05);
    }

    .payment-option.selected {
      border-color: var(--gold);
      background: rgba(212, 175, 55, 0.1);
    }

    .payment-option-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 6px;
    }

    .payment-option-title {
      font-weight: 600;
      font-size: 14px;
      color: var(--text);
    }

    .payment-option-amount {
      font-weight: 700;
      font-size: 16px;
      color: var(--gold);
    }

    .payment-option-desc {
      font-size: 12px;
      color: var(--text-secondary);
      line-height: 1.4;
    }

    .payment-form-group {
      margin-bottom: 16px;
    }

    .payment-form-group label {
      display: block;
      font-size: 12px;
      font-weight: 500;
      color: var(--text-secondary);
      margin-bottom: 6px;
    }

    .payment-form-group input {
      width: 100%;
      padding: 10px 12px;
      background: var(--dark);
      border: 1px solid var(--border);
      border-radius: 8px;
      color: var(--text);
      font-size: 14px;
    }

    .payment-form-group input:focus {
      outline: none;
      border-color: var(--accent-color);
    }

    .payment-submit {
      width: 100%;
      padding: 14px 20px;
      background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%);
      color: white;
      border: none;
      border-radius: 10px;
      font-size: 15px;
      font-weight: 600;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      transition: all 0.2s;
    }

    .payment-submit:hover {
      background: linear-gradient(135deg, #16a34a 0%, #15803d 100%);
    }

    .payment-submit:disabled {
      background: #4a4a5a;
      cursor: not-allowed;
    }

    .payment-secure {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      margin-top: 16px;
      font-size: 11px;
      color: var(--text-secondary);
    }

    .payment-secure svg {
      width: 14px;
      height: 14px;
    }

    /* Context Menu */
    .context-menu {
      position: fixed;
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 6px 0;
      min-width: 160px;
      z-index: 1000;
      box-shadow: 0 8px 32px rgba(0,0,0,0.4);
    }

    .context-menu-item {
      padding: 8px 14px;
      font-size: 12px;
      color: var(--text-secondary);
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .context-menu-item:hover {
      background: var(--dark-hover);
      color: var(--text);
    }

    .context-menu-item.danger {
      color: var(--error);
    }

    .context-menu-item svg {
      width: 14px;
      height: 14px;
    }

    .context-menu-divider {
      height: 1px;
      background: var(--border);
      margin: 4px 0;
    }

    .context-menu-label {
      padding: 6px 14px;
      font-size: 10px;
      color: var(--text-muted);
      text-transform: uppercase;
      font-weight: 600;
    }

    /* Modals */
    .modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.7);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1001;
    }

    .modal-overlay.active {
      display: flex;
    }

    .modal {
      background: var(--dark-surface);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 20px;
      width: 100%;
      max-width: 500px;
      max-height: 80vh;
      overflow-y: auto;
    }

    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 16px;
    }

    .modal-title {
      font-size: 16px;
      font-weight: 600;
    }

    .modal-close {
      width: 28px;
      height: 28px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: var(--dark-elevated);
      border: none;
      border-radius: 4px;
      color: var(--text-muted);
      cursor: pointer;
      font-size: 18px;
    }

    .modal-close:hover {
      background: var(--dark-hover);
      color: var(--text);
    }

    /* Keyboard Shortcuts Modal */
    .shortcut-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .shortcut-item {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 13px;
      color: var(--text-secondary);
    }
    .shortcut-item span {
      flex: 1;
    }
    .shortcut-item kbd,
    .modal-body kbd {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      min-width: 24px;
      height: 24px;
      padding: 0 6px;
      background: linear-gradient(180deg, #3a3a3a 0%, #2a2a2a 100%);
      border: 1px solid #4a4a4a;
      border-radius: 4px;
      font-family: 'SF Mono', 'Monaco', 'Inconsolata', monospace;
      font-size: 11px;
      font-weight: 500;
      color: #fff;
      box-shadow: 0 2px 0 #1a1a1a, inset 0 1px 0 rgba(255,255,255,0.1);
    }
    .modal-title {
      display: flex;
      align-items: center;
    }

    /* Hide close button on required modals */
    .modal-overlay[data-required="true"] .modal-close {
      display: none;
    }

    /* Login Modal Styles */
    .login-modal {
      max-width: 440px !important;
      padding: 32px !important;
    }

    .google-signin-btn {
      width: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 12px;
      padding: 14px 20px;
      background: #fff;
      border: 1px solid #dadce0;
      border-radius: 8px;
      font-size: 15px;
      font-weight: 500;
      color: #3c4043;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .google-signin-btn:hover {
      background: #f8f9fa;
      border-color: #c6c6c6;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    }

    .login-divider {
      display: flex;
      align-items: center;
      margin: 24px 0;
      color: var(--text-muted);
      font-size: 13px;
    }

    .login-divider::before,
    .login-divider::after {
      content: '';
      flex: 1;
      height: 1px;
      background: var(--border);
    }

    .login-divider span {
      padding: 0 16px;
    }

    /* Sign In Button - Clean & Modern */
    .btn-signin {
      position: relative;
      width: 100%;
      height: 50px;
      background: linear-gradient(135deg, var(--gold) 0%, #c9a227 100%);
      border: none;
      border-radius: 8px;
      color: #000;
      font-size: 15px;
      font-weight: 600;
      cursor: pointer;
      overflow: hidden;
      margin-bottom: 16px;
      transition: all 0.2s ease;
    }

    .btn-signin:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(212, 175, 55, 0.4);
    }

    .btn-signin:active {
      transform: translateY(0);
    }

    .btn-signin:disabled {
      opacity: 0.7;
      cursor: not-allowed;
      transform: none;
    }

    .btn-signin-text {
      transition: opacity 0.2s ease;
    }

    .btn-signin.loading .btn-signin-text {
      opacity: 0;
    }

    .btn-signin-loader {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 20px;
      height: 20px;
      margin: -10px 0 0 -10px;
      border: 2px solid rgba(0, 0, 0, 0.2);
      border-top-color: #000;
      border-radius: 50%;
      opacity: 0;
      transition: opacity 0.2s ease;
    }

    .btn-signin.loading .btn-signin-loader {
      opacity: 1;
      animation: spinBtn 0.6s linear infinite;
    }

    @keyframes spinBtn {
      to { transform: rotate(360deg); }
    }

    /* Material Picker Modal */
    .material-categories {
      display: flex;
      gap: 8px;
      margin-bottom: 16px;
      flex-wrap: wrap;
    }

    .material-category-btn {
      padding: 6px 12px;
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      border-radius: 4px;
      color: var(--text-secondary);
      font-size: 11px;
      cursor: pointer;
    }

    .material-category-btn:hover {
      border-color: var(--primary);
    }

    .material-category-btn.active {
      background: var(--primary);
      border-color: var(--primary);
      color: white;
    }

    .materials-modal-grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 10px;
    }

    .material-modal-item {
      aspect-ratio: 1;
      border-radius: 8px;
      cursor: pointer;
      border: 2px solid transparent;
      background-size: cover;
      background-position: center;
      position: relative;
      overflow: hidden;
    }

    .material-modal-item:hover {
      border-color: var(--primary);
    }

    .material-modal-item.selected {
      border-color: var(--gold);
    }

    .material-modal-item .material-name {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.8);
      padding: 4px 6px;
      font-size: 9px;
      text-align: center;
    }

    .material-modal-item .material-price {
      position: absolute;
      top: 4px;
      right: 4px;
      padding: 2px 6px;
      border-radius: 4px;
      font-size: 8px;
      font-weight: 600;
      color: white;
      text-shadow: 0 1px 2px rgba(0,0,0,0.3);
    }

    .material-modal-item .material-brand {
      position: absolute;
      top: 4px;
      left: 4px;
      padding: 2px 5px;
      border-radius: 3px;
      font-size: 7px;
      font-weight: 500;
      background: rgba(0,0,0,0.7);
      color: white;
    }

    .material-modal-item.daltile-material {
      border: 1px solid rgba(99, 102, 241, 0.3);
    }

    .material-modal-item.daltile-material:hover {
      border-color: var(--primary);
      box-shadow: 0 0 0 2px rgba(99, 102, 241, 0.2);
    }

    .upload-material-btn {
      aspect-ratio: 1;
      border-radius: 8px;
      border: 2px dashed var(--border);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      color: var(--text-muted);
      gap: 4px;
    }

    .upload-material-btn:hover {
      border-color: var(--primary);
      color: var(--primary);
    }

    .upload-material-btn svg {
      width: 24px;
      height: 24px;
    }

    .upload-material-btn span {
      font-size: 9px;
    }

    /* Share Modal */
    .share-link-box {
      display: flex;
      gap: 8px;
      margin-bottom: 16px;
    }

    .share-link-input {
      flex: 1;
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 10px 12px;
      color: var(--text);
      font-size: 12px;
    }

    .permission-options {
      display: flex;
      gap: 8px;
      margin-bottom: 16px;
    }

    .permission-btn {
      flex: 1;
      padding: 10px;
      background: var(--dark-elevated);
      border: 2px solid var(--border);
      border-radius: 6px;
      color: var(--text-secondary);
      cursor: pointer;
      text-align: center;
    }

    .permission-btn:hover {
      border-color: var(--primary);
    }

    .permission-btn.active {
      border-color: var(--primary);
      background: rgba(99, 102, 241, 0.1);
      color: var(--text);
    }

    .permission-btn-title {
      font-size: 12px;
      font-weight: 600;
      margin-bottom: 2px;
    }

    .permission-btn-desc {
      font-size: 10px;
      color: var(--text-muted);
    }

    /* Enhanced Share Modal */
    .share-status {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 12px;
      font-size: 12px;
      color: var(--text-secondary);
    }

    .share-status .status-indicator {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--text-muted);
    }

    .permission-section h4 {
      font-size: 12px;
      margin-bottom: 12px;
      color: var(--text-secondary);
    }

    #shareModal .permission-options {
      flex-direction: column;
    }

    #shareModal .permission-btn {
      display: flex;
      align-items: center;
      gap: 12px;
      text-align: left;
    }

    .permission-icon {
      width: 36px;
      height: 36px;
      min-width: 36px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: var(--dark-hover);
      border-radius: 8px;
    }

    .permission-icon svg {
      width: 18px;
      height: 18px;
      stroke: var(--text-secondary);
    }

    .permission-info {
      flex: 1;
    }

    .share-actions {
      margin-top: 16px;
    }

    .active-shares {
      margin-top: 20px;
      padding-top: 16px;
      border-top: 1px solid var(--border);
    }

    .active-shares h4,
    .recent-activity h4 {
      font-size: 12px;
      margin-bottom: 12px;
      color: var(--text-secondary);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .recent-activity {
      margin-top: 16px;
      padding-top: 16px;
      border-top: 1px solid var(--border);
    }

    .activity-list {
      max-height: 200px;
      overflow-y: auto;
    }

    .activity-item {
      display: flex;
      align-items: flex-start;
      gap: 10px;
      padding: 10px;
      background: var(--dark-elevated);
      border-radius: 6px;
      margin-bottom: 6px;
      font-size: 12px;
    }

    .activity-icon {
      width: 28px;
      height: 28px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      flex-shrink: 0;
    }

    .activity-icon.view { background: rgba(99, 102, 241, 0.2); }
    .activity-icon.comment { background: rgba(249, 203, 0, 0.2); }
    .activity-icon.approve { background: rgba(16, 185, 129, 0.2); }
    .activity-icon.reject { background: rgba(239, 68, 68, 0.2); }

    .activity-content {
      flex: 1;
    }

    .activity-text {
      color: var(--text-primary);
      line-height: 1.4;
    }

    .activity-time {
      color: var(--text-muted);
      font-size: 10px;
      margin-top: 2px;
    }

    /* Invite Recipients Picker */
    .invite-recipients-section {
      margin: 20px 0;
      padding: 16px;
      background: rgba(99, 102, 241, 0.04);
      border-radius: 12px;
      border: 1px solid rgba(99, 102, 241, 0.15);
    }

    .invite-chips-container {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-bottom: 8px;
      min-height: 0;
    }

    .invite-chips-container:empty {
      margin-bottom: 0;
    }

    .invite-chip {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 8px 4px 10px;
      background: rgba(99, 102, 241, 0.15);
      border: 1px solid rgba(99, 102, 241, 0.3);
      border-radius: 16px;
      font-size: 12px;
      color: var(--text);
      max-width: 220px;
    }

    .invite-chip-name {
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .invite-chip-remove {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      border: none;
      background: rgba(255, 255, 255, 0.1);
      color: var(--text-muted);
      font-size: 12px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
      padding: 0;
      line-height: 1;
    }

    .invite-chip-remove:hover {
      background: rgba(239, 68, 68, 0.3);
      color: #ef4444;
    }

    .invite-search-wrapper {
      position: relative;
    }

    .invite-search-wrapper input {
      width: 100%;
      padding: 10px 14px;
      background: var(--dark-bg);
      border: 1px solid var(--border);
      border-radius: 8px;
      color: var(--text);
      font-size: 13px;
      outline: none;
      transition: border-color 0.2s;
      box-sizing: border-box;
    }

    .invite-search-wrapper input:focus {
      border-color: var(--primary);
    }

    .invite-search-results {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      border-radius: 8px;
      margin-top: 4px;
      max-height: 200px;
      overflow-y: auto;
      z-index: 1000;
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
    }

    .invite-search-item {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px 12px;
      cursor: pointer;
      border-bottom: 1px solid rgba(255, 255, 255, 0.04);
      transition: background 0.15s;
    }

    .invite-search-item:last-child {
      border-bottom: none;
    }

    .invite-search-item:hover {
      background: rgba(99, 102, 241, 0.1);
    }

    .invite-search-item-info {
      flex: 1;
      min-width: 0;
    }

    .invite-search-item-name {
      font-size: 13px;
      font-weight: 500;
      color: var(--text);
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .invite-search-item-email {
      font-size: 11px;
      color: var(--text-muted);
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .invite-source-badge {
      font-size: 9px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      padding: 2px 6px;
      border-radius: 4px;
      flex-shrink: 0;
    }

    .invite-source-badge.lead {
      background: rgba(249, 168, 37, 0.15);
      color: #f9a825;
    }

    .invite-source-badge.customer {
      background: rgba(16, 185, 129, 0.15);
      color: #10b981;
    }

    .invite-source-badge.manual {
      background: rgba(99, 102, 241, 0.15);
      color: #6366f1;
    }

    .invite-search-empty {
      padding: 16px;
      text-align: center;
      color: var(--text-muted);
      font-size: 12px;
    }

    .invite-send-status {
      margin-top: 10px;
      font-size: 12px;
    }

    .invite-send-status .status-item {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 4px 0;
    }

    .invite-send-status .status-item.success { color: #10b981; }
    .invite-send-status .status-item.failed { color: #ef4444; }
    .invite-send-status .status-item.sending { color: var(--text-muted); }

    /* ============================================
       MOBILE OPTIMIZATIONS FOR SHARE & OVERLAY
       ============================================ */

    /* Share Modal - Mobile */
    @media (max-width: 600px) {
      #shareModal .modal {
        max-width: 100%;
        margin: 0;
        border-radius: 16px 16px 0 0;
        max-height: 90vh;
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
      }

      #shareModal .modal-content {
        max-height: calc(90vh - 60px);
        overflow-y: auto;
        -webkit-overflow-scrolling: touch;
        padding-bottom: 24px;
      }

      .share-link-box {
        flex-direction: column;
        gap: 8px;
      }

      .share-link-input {
        width: 100%;
        font-size: 14px !important;
        padding: 14px 12px !important;
      }

      .share-link-box .btn {
        width: 100%;
        padding: 14px;
        font-size: 15px;
      }

      /* Social share buttons - 2 per row on mobile */
      .social-share-section > div:last-child {
        display: grid !important;
        grid-template-columns: 1fr 1fr;
        gap: 8px !important;
      }

      .social-share-btn {
        padding: 12px 10px !important;
        font-size: 12px !important;
        justify-content: center;
        width: 100%;
      }

      /* Permission options - stack vertically with larger touch targets */
      .permission-options {
        gap: 8px !important;
      }

      #shareModal .permission-btn {
        padding: 14px 12px !important;
        min-height: 64px;
      }

      .permission-icon {
        width: 42px !important;
        height: 42px !important;
        min-width: 42px !important;
      }

      .permission-icon svg {
        width: 22px !important;
        height: 22px !important;
      }

      .permission-btn-title {
        font-size: 14px !important;
      }

      .permission-btn-desc {
        font-size: 11px !important;
      }

      /* Invite section */
      .invite-recipients-section {
        margin: 16px 0;
        padding: 12px;
      }

      #inviteSearchInput {
        font-size: 16px !important; /* Prevent iOS zoom */
        padding: 14px 12px !important;
      }

      .invite-chip {
        padding: 8px 10px 8px 12px;
        font-size: 13px;
      }

      /* Share actions button */
      .share-actions .btn {
        width: 100%;
        padding: 16px;
        font-size: 16px;
        font-weight: 600;
      }
    }

    /* Shared Design View - Customer View Mode */
    .shared-view-banner {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      background: linear-gradient(135deg, #6366f1 0%, #4f46e5 100%);
      color: white;
      padding: 12px 16px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      z-index: 10000;
      box-shadow: 0 2px 12px rgba(0, 0, 0, 0.3);
    }

    .shared-view-banner-info {
      display: flex;
      align-items: center;
      gap: 12px;
      min-width: 0;
      flex: 1;
    }

    .shared-view-banner-title {
      font-weight: 600;
      font-size: 14px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .shared-view-banner-meta {
      font-size: 12px;
      opacity: 0.8;
    }

    .shared-view-banner-actions {
      display: flex;
      gap: 8px;
      flex-shrink: 0;
    }

    .shared-view-banner-btn {
      padding: 8px 16px;
      border-radius: 6px;
      font-size: 13px;
      font-weight: 600;
      border: none;
      cursor: pointer;
      white-space: nowrap;
    }

    .shared-view-banner-btn.primary {
      background: white;
      color: #4f46e5;
    }

    .shared-view-banner-btn.secondary {
      background: rgba(255, 255, 255, 0.15);
      color: white;
    }

    @media (max-width: 600px) {
      .shared-view-banner {
        flex-direction: column;
        gap: 10px;
        padding: 12px;
        text-align: center;
      }

      .shared-view-banner-info {
        flex-direction: column;
        gap: 4px;
      }

      .shared-view-banner-actions {
        width: 100%;
        justify-content: center;
      }

      .shared-view-banner-btn {
        flex: 1;
        padding: 12px 16px;
        font-size: 14px;
      }
    }

    /* Mobile Quote Summary Overlay */
    .mobile-quote-overlay {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: linear-gradient(180deg, transparent 0%, rgba(26, 26, 46, 0.95) 20%, #1a1a2e 100%);
      padding: 60px 16px 24px;
      z-index: 999;
      display: none;
    }

    .mobile-quote-overlay.show {
      display: block;
    }

    .mobile-quote-card {
      background: var(--dark-elevated);
      border-radius: 16px;
      padding: 20px;
      border: 1px solid var(--border);
    }

    .mobile-quote-total {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 16px;
    }

    .mobile-quote-label {
      font-size: 13px;
      color: var(--text-muted);
    }

    .mobile-quote-amount {
      font-size: 28px;
      font-weight: 700;
      color: var(--gold);
    }

    .mobile-quote-actions {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }

    .mobile-quote-actions .btn {
      padding: 14px;
      font-size: 14px;
      font-weight: 600;
      border-radius: 10px;
    }

    .mobile-quote-actions .btn-primary {
      grid-column: span 2;
      background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%);
      padding: 16px;
      font-size: 16px;
    }

    /* Mobile-friendly 3D controls */
    @media (max-width: 600px) {
      .three-controls {
        bottom: 80px !important;
        left: auto !important; /* Reset left positioning */
        right: 12px !important;
        max-width: calc(100% - 24px) !important;
        flex-wrap: wrap !important;
        gap: 6px !important;
        padding: 8px !important;
      }

      .three-controls button {
        width: 40px !important;
        height: 40px !important;
        padding: 6px !important;
        font-size: 10px !important;
      }

      .three-controls button span {
        display: none !important; /* Hide text labels on mobile */
      }

      .three-controls button svg {
        width: 18px !important;
        height: 18px !important;
      }

      .three-controls-group {
        padding: 2px !important;
      }

      .three-controls-divider {
        display: none !important; /* Hide dividers on mobile */
      }

      /* Larger touch targets for canvas interaction */
      #three-container {
        touch-action: pan-x pan-y pinch-zoom;
      }

      /* Hide axis indicator on mobile - takes up too much space */
      .axis-indicator-container {
        display: none !important;
      }

      /* Move 3D hint to top center on mobile */
      .three-hint {
        bottom: auto !important;
        top: 70px !important;
        right: 50% !important;
        transform: translateX(50%) !important;
        font-size: 10px !important;
        padding: 6px 10px !important;
      }
    }

    /* Quote Customer Search */
    .quote-customer-search-wrap {
      position: relative;
      margin-bottom: 12px;
      grid-column: span 2;
    }
    .quote-customer-search-wrap input {
      width: 100%;
      padding: 10px 12px 10px 36px;
      background: var(--dark-bg);
      border: 1px solid var(--border);
      border-radius: 8px;
      color: var(--text);
      font-size: 13px;
    }
    .quote-customer-search-wrap input:focus {
      outline: none;
      border-color: #6366f1;
      box-shadow: 0 0 0 2px rgba(99,102,241,0.15);
    }
    .quote-customer-search-wrap .search-icon {
      position: absolute;
      left: 10px;
      top: 50%;
      transform: translateY(-50%);
      color: var(--text-muted);
      pointer-events: none;
    }
    #quoteCustomerResults {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      border-radius: 8px;
      max-height: 220px;
      overflow-y: auto;
      z-index: 100;
      box-shadow: 0 8px 24px rgba(0,0,0,0.3);
      margin-top: 4px;
    }
    .quote-cust-item {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px 12px;
      cursor: pointer;
      border-bottom: 1px solid rgba(255,255,255,0.04);
      transition: background 0.15s;
    }
    .quote-cust-item:last-child { border-bottom: none; }
    .quote-cust-item:hover { background: var(--dark-hover); }
    .quote-cust-avatar {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      background: rgba(99,102,241,0.15);
      color: #a5b4fc;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 13px;
      font-weight: 600;
      flex-shrink: 0;
    }
    .quote-cust-info { flex: 1; min-width: 0; }
    .quote-cust-name { font-size: 13px; font-weight: 500; color: var(--text); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .quote-cust-email { font-size: 11px; color: var(--text-muted); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .quote-cust-jobs-badge {
      font-size: 10px;
      padding: 2px 8px;
      border-radius: 10px;
      background: rgba(99,102,241,0.12);
      color: #a5b4fc;
      font-weight: 500;
      white-space: nowrap;
    }
    .quote-customer-selected-banner {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 12px;
      background: rgba(99,102,241,0.08);
      border: 1px solid rgba(99,102,241,0.2);
      border-radius: 8px;
      margin-bottom: 10px;
      grid-column: span 2;
    }
    .quote-customer-selected-banner .name { font-weight: 600; color: var(--text); font-size: 13px; }
    .quote-customer-selected-banner .meta { font-size: 11px; color: var(--text-muted); }
    .quote-customer-selected-banner .clear-btn {
      margin-left: auto;
      background: none;
      border: none;
      color: var(--text-muted);
      cursor: pointer;
      font-size: 16px;
      padding: 2px 6px;
      border-radius: 4px;
    }
    .quote-customer-selected-banner .clear-btn:hover { background: rgba(255,255,255,0.08); color: var(--text); }

    .share-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px;
      background: var(--dark-elevated);
      border-radius: 6px;
      margin-bottom: 8px;
    }

    .share-info {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .share-permission {
      font-size: 11px;
      font-weight: 500;
    }

    .share-stats {
      font-size: 10px;
      color: var(--text-muted);
    }

    .share-item .share-actions {
      display: flex;
      gap: 8px;
      margin-top: 0;
    }

    .share-item .share-actions button {
      margin-left: 0;
      padding: 6px 12px;
      font-size: 11px;
    }

    /* Pricing Section in Properties */
    .pricing-section {
      margin-top: 16px;
      padding-top: 12px;
      border-top: 1px solid var(--border);
    }

    /* Pricing Locked State */
    .pricing-locked {
      position: relative;
      pointer-events: none;
      opacity: 0.3;
      filter: blur(3px);
    }

    .pricing-locked-overlay {
      background: linear-gradient(135deg, rgba(26,26,46,0.95), rgba(22,33,62,0.95));
      border-radius: 12px;
      padding: 24px;
      margin: 12px;
      text-align: center;
    }

    .pricing-locked-content {
      color: var(--text);
    }

    .pricing-locked-content h4 {
      color: #fff;
      font-size: 16px;
      margin-bottom: 8px;
    }

    .pricing-locked-content p {
      color: var(--text-muted);
      font-size: 13px;
      margin-bottom: 16px;
      line-height: 1.5;
    }

    .pricing-locked-content .btn {
      background: linear-gradient(135deg, #f9cb00 0%, #e6b800 100%);
      color: #1a1a2e;
      border: none;
      padding: 12px 24px;
      font-weight: 600;
    }

    .upgrade-plan-btn {
      position: relative;
      width: 100%;
      padding: 14px 16px;
      border: 1px solid rgba(99, 102, 241, 0.3);
      border-radius: 10px;
      background: rgba(99, 102, 241, 0.1);
      color: #fff;
      cursor: pointer;
      transition: all 0.2s ease;
      text-align: left;
    }

    .upgrade-plan-btn:hover {
      background: rgba(99, 102, 241, 0.2);
      border-color: rgba(99, 102, 241, 0.5);
      transform: translateY(-1px);
    }

    .upgrade-plan-btn:disabled {
      opacity: 0.7;
      cursor: not-allowed;
      transform: none;
    }

    .upgrade-plan-featured {
      border-color: #6366f1;
      background: linear-gradient(135deg, rgba(99, 102, 241, 0.2), rgba(79, 70, 229, 0.25));
    }

    .upgrade-plan-featured:hover {
      background: linear-gradient(135deg, rgba(99, 102, 241, 0.3), rgba(79, 70, 229, 0.35));
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    .property-section-title {
      font-size: 10px;
      font-weight: 600;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 10px;
    }

    .price-override-group {
      display: flex;
      gap: 4px;
    }

    .price-input {
      width: 70px !important;
    }

    .margin-input {
      width: 60px !important;
    }

    .property-select-sm {
      width: 50px;
      padding: 5px 4px;
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      border-radius: 4px;
      color: var(--text);
      font-size: 10px;
    }

    .price-result {
      margin-top: 8px;
      padding-top: 8px;
      border-top: 1px dashed var(--border);
    }

    .price-highlight {
      color: var(--gold);
      font-weight: 600;
    }

    /* Enhanced Quote Panel */
    .quote-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .quote-view-toggle {
      display: flex;
      background: var(--dark-elevated);
      border-radius: 4px;
      padding: 2px;
    }

    .toggle-btn {
      padding: 4px 8px;
      font-size: 10px;
      background: transparent;
      border: none;
      color: var(--text-muted);
      cursor: pointer;
      border-radius: 3px;
      transition: all 0.2s;
    }

    .toggle-btn:hover {
      color: var(--text-secondary);
    }

    .toggle-btn.active {
      background: var(--primary);
      color: white;
    }

    .quote-actions {
      display: flex;
      gap: 6px;
      margin: 10px 0;
    }

    .quote-actions .btn {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 10px;
      padding: 6px 8px;
    }

    .quote-summary {
      margin-top: 10px;
    }

    .quote-row {
      display: flex;
      justify-content: space-between;
      padding: 4px 0;
      font-size: 11px;
      color: var(--text-secondary);
    }

    .margin-badge {
      display: inline-block;
      font-size: 9px;
      background: var(--dark-hover);
      padding: 2px 5px;
      border-radius: 3px;
      margin-left: 6px;
      color: var(--text-muted);
    }

    /* Price List Modal */
    .price-list-tabs {
      display: flex;
      gap: 4px;
      margin-bottom: 16px;
      border-bottom: 1px solid var(--border);
      padding-bottom: 8px;
    }

    .tab-btn {
      padding: 8px 16px;
      background: transparent;
      border: none;
      color: var(--text-muted);
      cursor: pointer;
      font-size: 12px;
      border-radius: 4px;
      transition: all 0.2s;
    }

    .tab-btn:hover {
      color: var(--text-secondary);
      background: var(--dark-elevated);
    }

    .tab-btn.active {
      background: var(--dark-elevated);
      color: var(--text);
    }

    .price-tab {
      min-height: 200px;
    }

    .upload-dropzone {
      border: 2px dashed var(--border);
      border-radius: 8px;
      padding: 40px 20px;
      text-align: center;
      cursor: pointer;
      transition: all 0.2s;
    }

    .upload-dropzone:hover {
      border-color: var(--primary);
      background: rgba(99, 102, 241, 0.05);
    }

    .column-mapping {
      padding: 16px 0;
    }

    .mapping-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
    }

    .mapping-row label {
      font-size: 12px;
      color: var(--text-secondary);
    }

    .mapping-row select {
      width: 200px;
    }

    .mapping-preview {
      margin: 16px 0;
      padding: 12px;
      background: var(--dark-elevated);
      border-radius: 6px;
    }

    .preview-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 11px;
    }

    .preview-table th,
    .preview-table td {
      padding: 8px 6px;
      text-align: left;
      border-bottom: 1px solid var(--border);
    }

    .preview-table th {
      background: var(--dark-hover);
      font-weight: 600;
      font-size: 10px;
      text-transform: uppercase;
    }

    .mapping-actions {
      display: flex;
      justify-content: flex-end;
      gap: 8px;
      margin-top: 16px;
    }

    .saved-lists {
      min-height: 100px;
    }

    .price-list-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: var(--dark-elevated);
      border-radius: 6px;
      margin-bottom: 8px;
    }

    .price-list-name {
      font-weight: 500;
      font-size: 13px;
    }

    .price-list-date {
      font-size: 11px;
      color: var(--text-muted);
    }

    .current-prices-header {
      margin-bottom: 12px;
    }

    .search-input {
      width: 100%;
      padding: 10px 12px;
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      border-radius: 6px;
      color: var(--text);
      font-size: 12px;
    }

    .current-prices-list {
      max-height: 300px;
      overflow-y: auto;
    }

    .price-category-header {
      font-size: 11px;
      font-weight: 600;
      color: var(--text-muted);
      text-transform: uppercase;
      padding: 8px 0 4px;
      margin-top: 8px;
      border-bottom: 1px solid var(--border);
    }

    .current-price-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 4px;
      font-size: 11px;
      border-bottom: 1px solid var(--dark-elevated);
    }

    .price-item-name {
      flex: 1;
    }

    .price-item-sku {
      width: 80px;
      color: var(--text-muted);
      font-size: 10px;
    }

    .price-item-value {
      font-weight: 500;
      color: var(--gold);
    }

    .empty-state {
      text-align: center;
      color: var(--text-muted);
      padding: 20px;
      font-size: 12px;
    }

    /* Labor Category Accordion */
    .labor-categories {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .labor-category {
      background: var(--dark-elevated);
      border-radius: 8px;
      overflow: hidden;
      border: 1px solid var(--border);
    }

    .labor-category-header {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 14px 16px;
      cursor: pointer;
      transition: background 0.2s;
      user-select: none;
    }

    .labor-category-header:hover {
      background: var(--dark-hover);
    }

    .labor-category.expanded .labor-category-header {
      border-bottom: 1px solid var(--border);
      background: var(--dark-hover);
    }

    .category-icon {
      font-size: 16px;
      color: var(--gold);
      width: 24px;
      text-align: center;
    }

    .category-title {
      flex: 1;
      font-weight: 600;
      font-size: 14px;
      color: var(--text);
    }

    .category-toggle {
      font-size: 10px;
      color: var(--text-muted);
      transition: transform 0.2s;
    }

    .labor-category.expanded .category-toggle {
      transform: rotate(180deg);
    }

    .labor-category-items {
      display: none;
      padding: 12px 16px;
      background: rgba(0,0,0,0.2);
    }

    .labor-category.expanded .labor-category-items {
      display: block;
    }

    .labor-item {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 10px 0;
      border-bottom: 1px solid var(--border);
    }

    .labor-item:last-child {
      border-bottom: none;
    }

    .labor-item-label {
      flex: 1;
      font-size: 13px;
      color: var(--text-secondary);
    }

    .labor-item-rate {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .labor-item-rate input {
      width: 80px;
      padding: 6px 8px;
      background: var(--dark-surface);
      border: 1px solid var(--border);
      border-radius: 4px;
      color: var(--text);
      font-size: 13px;
      text-align: right;
    }

    .labor-item-rate input:focus {
      outline: none;
      border-color: var(--gold);
    }

    .labor-item-unit {
      font-size: 11px;
      color: var(--text-muted);
      min-width: 50px;
    }

    /* Material Pricing Section */
    .material-pricing-section {
      background: var(--dark-elevated);
      border-radius: 8px;
      padding: 16px;
      border: 1px solid var(--border);
    }

    .material-price-row {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 10px 0;
      border-bottom: 1px solid var(--border);
    }

    .material-price-row:last-child {
      border-bottom: none;
    }

    .material-price-label {
      flex: 1;
      font-size: 13px;
      color: var(--text-secondary);
    }

    .material-price-inputs {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .material-price-inputs input {
      width: 90px;
      padding: 6px 8px;
      background: var(--dark-surface);
      border: 1px solid var(--border);
      border-radius: 4px;
      color: var(--text);
      font-size: 13px;
      text-align: right;
    }

    .material-price-inputs input:focus {
      outline: none;
      border-color: var(--gold);
    }

    .material-price-inputs span {
      font-size: 11px;
      color: var(--text-muted);
    }

    /* Quote Preview Table */
    .quote-preview-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 13px;
    }

    .quote-preview-table thead {
      position: sticky;
      top: 0;
      background: var(--dark-surface);
      z-index: 1;
    }

    .quote-preview-table th {
      text-align: left;
      padding: 12px 10px;
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
      color: var(--text-muted);
      border-bottom: 2px solid var(--border);
    }

    .quote-preview-table td {
      padding: 10px;
      border-bottom: 1px solid var(--border);
      vertical-align: middle;
    }

    .quote-preview-table tbody tr:hover {
      background: rgba(255, 255, 255, 0.03);
    }

    .quote-preview-table .room-header {
      background: linear-gradient(90deg, rgba(99, 102, 241, 0.1) 0%, transparent 100%);
      font-weight: 600;
      color: var(--primary);
    }

    .quote-preview-table .room-header td {
      padding: 8px 10px;
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      border-bottom: 1px solid rgba(99, 102, 241, 0.3);
    }

    .quote-preview-table .room-subtotal {
      background: rgba(255, 255, 255, 0.02);
    }

    .quote-preview-table .room-subtotal td {
      font-weight: 600;
      font-size: 12px;
      color: var(--text-secondary);
    }

    .quote-item-type-icon {
      width: 24px;
      height: 24px;
      border-radius: 6px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
    }

    .quote-item-type-icon.countertop {
      background: rgba(249, 203, 0, 0.15);
      color: var(--gold);
    }

    .quote-item-type-icon.cabinet {
      background: rgba(16, 185, 129, 0.15);
      color: #34d399;
    }

    .quote-item-type-icon.labor {
      background: rgba(99, 102, 241, 0.15);
      color: #818cf8;
    }

    .quote-item-type-icon.other {
      background: rgba(255, 255, 255, 0.1);
      color: var(--text-muted);
    }

    .quote-editable-input {
      width: 100%;
      padding: 6px 8px;
      background: var(--dark-surface);
      border: 1px solid var(--border);
      border-radius: 4px;
      color: var(--text);
      font-size: 13px;
      text-align: right;
    }

    .quote-editable-input:focus {
      outline: none;
      border-color: var(--gold);
      background: var(--dark-elevated);
    }

    .quote-editable-input.modified {
      border-color: var(--warning);
      background: rgba(245, 158, 11, 0.1);
    }

    .quote-margin-badge {
      display: inline-block;
      padding: 2px 6px;
      background: rgba(16, 185, 129, 0.15);
      color: #34d399;
      border-radius: 4px;
      font-size: 11px;
      font-weight: 600;
    }

    .quote-margin-badge.low {
      background: rgba(239, 68, 68, 0.15);
      color: #ef4444;
    }

    .quote-margin-badge.high {
      background: rgba(16, 185, 129, 0.15);
      color: #34d399;
    }

    /* Room Management */
    .room-list {
      max-height: 300px;
      overflow-y: auto;
      padding: 4px;
    }

    .room-list-item {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px 14px;
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      border-radius: 10px;
      margin-bottom: 8px;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .room-list-item:hover {
      border-color: var(--primary);
      background: linear-gradient(135deg, rgba(99,102,241,0.08), rgba(139,92,246,0.08));
      transform: translateX(4px);
    }

    .room-list-item.active {
      border-color: var(--primary);
      background: linear-gradient(135deg, rgba(99,102,241,0.15), rgba(139,92,246,0.15));
      box-shadow: 0 2px 12px rgba(99, 102, 241, 0.2);
    }

    .room-list-item .room-color {
      width: 18px;
      height: 18px;
      border-radius: 5px;
      flex-shrink: 0;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }

    .room-list-item .room-name {
      flex: 1;
      font-weight: 500;
      font-size: 14px;
    }

    .room-list-item .room-count {
      font-size: 11px;
      color: var(--text-muted);
      padding: 3px 10px;
      background: rgba(255, 255, 255, 0.08);
      border-radius: 12px;
      font-weight: 500;
    }

    .room-list-item.active .room-count {
      background: rgba(99, 102, 241, 0.3);
      color: white;
    }

    .room-list-item .room-actions {
      display: flex;
      gap: 4px;
      opacity: 0;
      transition: opacity 0.2s;
    }

    .room-list-item:hover .room-actions {
      opacity: 1;
    }

    .room-list-item .room-actions button {
      width: 28px;
      height: 28px;
      padding: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 6px;
      color: var(--text-muted);
      cursor: pointer;
      transition: all 0.15s;
    }

    .room-list-item .room-actions button:hover {
      background: var(--dark-hover);
      color: var(--text);
      border-color: rgba(255, 255, 255, 0.2);
    }

    .room-list-item .room-actions button.delete:hover {
      background: rgba(239, 68, 68, 0.15);
      border-color: rgba(239, 68, 68, 0.3);
      color: #ef4444;
    }

    /* Room color options */
    .room-colors {
      display: flex;
      gap: 6px;
      padding: 8px 0;
    }

    .room-color-option {
      width: 24px;
      height: 24px;
      border-radius: 6px;
      cursor: pointer;
      border: 2px solid transparent;
      transition: transform 0.15s, border-color 0.15s;
    }

    .room-color-option:hover {
      transform: scale(1.1);
    }

    .room-color-option.selected {
      border-color: white;
    }

    /* Margin Modal */
    .margin-section {
      padding: 8px 0;
    }

    .margin-global {
      margin-bottom: 16px;
    }

    .margin-global label {
      display: block;
      font-size: 12px;
      margin-bottom: 6px;
      color: var(--text-secondary);
    }

    .margin-input-group {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .margin-input-group input {
      width: 80px;
    }

    .margin-symbol {
      font-size: 12px;
      color: var(--text-muted);
    }

    .margin-categories h4 {
      font-size: 12px;
      margin-bottom: 12px;
      color: var(--text-secondary);
    }

    .category-margin-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 0;
      border-bottom: 1px solid var(--dark-elevated);
    }

    .category-margin-row span {
      font-size: 12px;
    }

    .modal-footer {
      display: flex;
      justify-content: flex-end;
      gap: 8px;
      margin-top: 20px;
      padding-top: 16px;
      border-top: 1px solid var(--border);
    }

    /* Permission Notice */
    .permission-notice {
      position: fixed;
      top: 60px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 1002;
      animation: slideDown 0.3s ease;
    }

    .notice-content {
      display: flex;
      align-items: center;
      gap: 10px;
      background: var(--dark-surface);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 12px 16px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.3);
      font-size: 12px;
    }

    @keyframes slideDown {
      from { opacity: 0; transform: translateX(-50%) translateY(-10px); }
      to { opacity: 1; transform: translateX(-50%) translateY(0); }
    }

    /* Presentation Mode */
    body.presentation-mode .sidebar,
    body.presentation-mode .right-panel {
      display: none;
    }

    body.presentation-mode .canvas-container {
      width: 100%;
    }

    /* 3D Axis Indicator (Orientation Key) - Glassmorphic */
    .axis-indicator-container {
      position: absolute;
      bottom: 20px;
      left: 20px;
      width: 100px;
      height: 100px;
      z-index: 100;
      pointer-events: none;
      border-radius: 16px;
      background: linear-gradient(135deg,
        rgba(20, 20, 30, 0.92) 0%,
        rgba(15, 15, 25, 0.95) 50%,
        rgba(25, 25, 35, 0.93) 100%);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      border: 1px solid rgba(255, 255, 255, 0.15);
      border-top-color: rgba(255, 255, 255, 0.25);
      border-left-color: rgba(255, 255, 255, 0.2);
      box-shadow:
        0 8px 32px rgba(0, 0, 0, 0.3),
        0 2px 8px rgba(0, 0, 0, 0.2),
        inset 0 1px 1px rgba(255, 255, 255, 0.08),
        inset 0 -1px 1px rgba(0, 0, 0, 0.1);
      overflow: hidden;
    }

    .axis-indicator-container::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 50%;
      background: linear-gradient(180deg,
        rgba(255, 255, 255, 0.04) 0%,
        transparent 100%);
      pointer-events: none;
      border-radius: 16px 16px 0 0;
    }

    .axis-indicator-container canvas {
      width: 100% !important;
      height: 100% !important;
    }

    .axis-label {
      position: absolute;
      font-size: 11px;
      font-weight: 600;
      text-shadow: 0 1px 2px rgba(0,0,0,0.8);
      pointer-events: none;
    }

    .axis-label-x { color: #ff4444; }
    .axis-label-y { color: #44ff44; }
    .axis-label-z { color: #4488ff; }

    @media (max-width: 600px) {
      /* Hide axis indicator on small screens - too cluttered */
      .axis-indicator-container {
        display: none !important;
      }
      .axis-label { display: none !important; }
    }

    /* Button danger variant */
    .btn-danger {
      background: var(--error);
      color: white;
    }

    .btn-danger:hover {
      background: #dc2626;
    }

    /* ============================================= */
    /* Minimal Professional Loading Screen */
    /* ============================================= */
    .cloud-preloader {
      position: fixed;
      inset: 0;
      background: #0a0a0a;
      z-index: 99999;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      transition: opacity 0.6s ease, visibility 0.6s ease;
    }

    .cloud-preloader.loaded {
      opacity: 0;
      visibility: hidden;
      pointer-events: none;
    }

    /* Main Content */
    .preloader-content {
      text-align: center;
      opacity: 0;
      animation: contentFadeIn 0.8s ease-out 0.2s forwards;
    }

    @keyframes contentFadeIn {
      0% { opacity: 0; transform: translateY(10px); }
      100% { opacity: 1; transform: translateY(0); }
    }

    /* Company Name */
    .preloader-company {
      font-family: 'Inter', -apple-system, sans-serif;
      font-size: 2.5rem;
      font-weight: 700;
      color: #ffffff;
      margin-bottom: 8px;
      letter-spacing: -0.02em;
    }

    .preloader-tagline {
      font-size: 1rem;
      color: rgba(255,255,255,0.4);
      margin-bottom: 48px;
    }

    /* Loading Bar */
    .preloader-loading {
      width: 200px;
      margin: 0 auto;
    }

    .preloader-bar {
      height: 2px;
      background: rgba(255,255,255,0.1);
      border-radius: 2px;
      overflow: hidden;
    }

    .preloader-bar-fill {
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, #6366f1, #8b5cf6);
      border-radius: 2px;
      transition: width 0.3s ease;
    }

    /* Powered By Badge */
    .preloader-powered {
      position: absolute;
      bottom: 40px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      align-items: center;
      gap: 8px;
      opacity: 0;
      animation: poweredFadeIn 0.6s ease-out 0.8s forwards;
    }

    @keyframes poweredFadeIn {
      0% { opacity: 0; }
      100% { opacity: 1; }
    }

    .preloader-powered-icon {
      width: 20px;
      height: 20px;
    }

    .preloader-powered-icon svg {
      width: 20px;
      height: 20px;
    }

    .preloader-powered-text {
      font-size: 12px;
      color: rgba(255,255,255,0.3);
    }

    .preloader-powered-brand {
      color: rgba(255,255,255,0.5);
      font-weight: 600;
    }

    /* Hide old elements */
    .blueprint-grid,
    .blueprint-corners,
    .preloader-main,
    .room-wireframe,
    .steps-flow,
    .progress-section,
    .designer-section,
    .powered-by-section { display: none !important; }

    .cad-element.countertop {
      display: none;
      width: 240px;
      height: 40px;
      bottom: 60px;
      left: 80px;
      border-color: rgba(249, 203, 0, 0.7);
      animation: elementPlace 0.6s ease-out 2s forwards;
    }

    .cad-element.countertop::before { border-color: rgba(249, 203, 0, 0.5); }

    .cad-element.cabinet {
      width: 80px;
      height: 100px;
      bottom: 60px;
      left: 80px;
      border-color: rgba(139, 92, 246, 0.7);
      animation: elementPlace 0.6s ease-out 2.3s forwards;
    }

    .cad-element.cabinet::before { border-color: rgba(139, 92, 246, 0.5); }

    .cad-element.cabinet-2 {
      width: 80px;
      height: 100px;
      bottom: 60px;
      left: 180px;
      border-color: rgba(139, 92, 246, 0.7);
      animation: elementPlace 0.6s ease-out 2.5s forwards;
    }

    .cad-element.island {
      width: 120px;
      height: 80px;
      bottom: 120px;
      left: 180px;
      border-color: rgba(34, 197, 94, 0.7);
      animation: elementPlace 0.6s ease-out 2.7s forwards;
    }

    .cad-element.island::before { border-color: rgba(34, 197, 94, 0.5); }

    .cad-element.appliance {
      width: 50px;
      height: 50px;
      bottom: 60px;
      right: 80px;
      border-color: rgba(239, 68, 68, 0.7);
      animation: elementPlace 0.6s ease-out 2.9s forwards;
    }

    .cad-element.appliance::before { border-color: rgba(239, 68, 68, 0.5); }

    @keyframes elementPlace {
      0% {
        opacity: 0;
        transform: scale(0.8);
        filter: blur(4px);
      }
      50% {
        opacity: 1;
        border-color: inherit;
        box-shadow: 0 0 20px currentColor;
      }
      100% {
        opacity: 1;
        transform: scale(1);
        filter: blur(0);
        box-shadow: 0 0 10px currentColor;
      }
    }

    /* Node Connection Lines - ReactFlow Style */
    .node-connections {
      position: absolute;
      inset: 0;
      pointer-events: none;
      opacity: 0;
      animation: connectionsFadeIn 0.8s ease-out 3.2s forwards;
    }

    @keyframes connectionsFadeIn {
      0% { opacity: 0; }
      100% { opacity: 1; }
    }

    .connection-line {
      position: absolute;
      background: linear-gradient(90deg, rgba(59, 130, 246, 0.6), rgba(139, 92, 246, 0.6));
      height: 2px;
      transform-origin: left center;
      animation: lineGrow 0.5s ease-out forwards;
    }

    .connection-line::after {
      content: '';
      position: absolute;
      right: -4px;
      top: -3px;
      width: 8px;
      height: 8px;
      background: rgba(139, 92, 246, 0.8);
      border-radius: 50%;
      box-shadow: 0 0 10px rgba(139, 92, 246, 0.6);
    }

    @keyframes lineGrow {
      0% { width: 0; }
      100% { width: 100%; }
    }

    /* Right Side Panel */
    .preloader-panel {
      width: 320px;
      display: flex;
      flex-direction: column;
      gap: 24px;
    }

    /* Brand Section */
    /* Designer/Company Section - Main Focus */
    .designer-section {
      text-align: center;
      opacity: 0;
      animation: designerFadeIn 0.8s ease-out 0.8s forwards;
      margin-bottom: 32px;
    }

    @keyframes designerFadeIn {
      0% { opacity: 0; transform: translateY(-20px); }
      100% { opacity: 1; transform: translateY(0); }
    }

    .designer-label {
      font-size: 11px;
      color: rgba(255,255,255,0.5);
      letter-spacing: 3px;
      text-transform: uppercase;
      margin-bottom: 12px;
    }

    .designer-company {
      font-family: 'Inter', -apple-system, sans-serif;
      font-size: 1.8rem;
      font-weight: 800;
      color: #ffffff;
      margin-bottom: 6px;
      line-height: 1.2;
    }

    .designer-tagline {
      font-size: 13px;
      color: rgba(255,255,255,0.5);
    }

    /* Steps Node Flow */
    .steps-flow {
      display: flex;
      flex-direction: column;
      gap: 0;
      position: relative;
    }

    .step-node {
      display: flex;
      align-items: center;
      gap: 16px;
      padding: 12px 16px;
      background: rgba(255,255,255,0.03);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 12px;
      position: relative;
      opacity: 0;
      transform: translateX(-20px);
      transition: all 0.4s ease;
    }

    .step-node.visible {
      opacity: 1;
      transform: translateX(0);
    }

    .step-node.active {
      background: rgba(66, 133, 244, 0.1);
      border-color: rgba(66, 133, 244, 0.4);
      box-shadow: 0 0 30px rgba(66, 133, 244, 0.2);
    }

    .step-node.completed {
      background: rgba(34, 197, 94, 0.08);
      border-color: rgba(34, 197, 94, 0.2);
    }

    .step-node-icon {
      width: 40px;
      height: 40px;
      border-radius: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      background: rgba(255,255,255,0.05);
      border: 1px solid rgba(255,255,255,0.1);
      transition: all 0.3s ease;
    }

    .step-node.active .step-node-icon {
      background: linear-gradient(135deg, rgba(66, 133, 244, 0.3), rgba(52, 168, 83, 0.3));
      border-color: rgba(66, 133, 244, 0.5);
      box-shadow: 0 0 20px rgba(66, 133, 244, 0.4);
    }

    .step-node.completed .step-node-icon {
      background: rgba(34, 197, 94, 0.2);
      border-color: rgba(34, 197, 94, 0.4);
    }

    .step-node-content {
      flex: 1;
    }

    .step-node-title {
      font-size: 13px;
      font-weight: 600;
      color: rgba(255,255,255,0.9);
      margin-bottom: 2px;
    }

    .step-node-desc {
      font-size: 11px;
      color: rgba(255,255,255,0.4);
    }

    .step-node.active .step-node-title {
      color: #4285F4;
    }

    .step-node.completed .step-node-title {
      color: rgba(34, 197, 94, 0.9);
    }

    /* Connection between nodes */
    .step-connector {
      width: 2px;
      height: 16px;
      background: rgba(255,255,255,0.1);
      margin-left: 35px;
      position: relative;
      overflow: hidden;
    }

    .step-connector::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 0%;
      background: linear-gradient(180deg, rgba(66, 133, 244, 0.6), rgba(52, 168, 83, 0.6));
      transition: height 0.3s ease;
    }

    .step-connector.filled::after {
      height: 100%;
    }

    /* Progress Section */
    .progress-section {
      background: rgba(255,255,255,0.03);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 16px;
      padding: 20px;
      opacity: 0;
      animation: progressFadeIn 0.6s ease-out 1.2s forwards;
    }

    @keyframes progressFadeIn {
      0% { opacity: 0; transform: scale(0.95); }
      100% { opacity: 1; transform: scale(1); }
    }

    .progress-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
    }

    .progress-label {
      font-size: 12px;
      font-weight: 600;
      color: rgba(255,255,255,0.7);
      text-transform: uppercase;
      letter-spacing: 2px;
    }

    .progress-percent {
      font-size: 14px;
      font-weight: 700;
      color: #818cf8;
    }

    .progress-bar-container {
      height: 8px;
      background: rgba(255,255,255,0.1);
      border-radius: 8px;
      overflow: hidden;
    }

    .progress-bar-fill {
      height: 100%;
      background: linear-gradient(90deg, #4285F4, #34A853, #FBBC05, #EA4335);
      border-radius: 8px;
      width: 0%;
      transition: width 0.5s cubic-bezier(0.4, 0, 0.2, 1);
      position: relative;
    }

    .progress-bar-fill::after {
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
      animation: shimmer 1.5s infinite;
    }

    @keyframes shimmer {
      0% { transform: translateX(-100%); }
      100% { transform: translateX(100%); }
    }

    /* Powered By Remodely Badge */
    .powered-by-section {
      position: absolute;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      opacity: 0;
      animation: poweredByFadeIn 0.6s ease-out 1.5s forwards;
    }

    @keyframes poweredByFadeIn {
      0% { opacity: 0; transform: translateX(-50%) translateY(10px); }
      100% { opacity: 1; transform: translateX(-50%) translateY(0); }
    }

    .powered-by-badge {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px 20px;
      background: rgba(255,255,255,0.05);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 50px;
      backdrop-filter: blur(10px);
    }

    .powered-by-icon {
      width: 22px;
      height: 22px;
    }

    .powered-by-icon svg {
      width: 22px;
      height: 22px;
    }

    .powered-by-text {
      display: flex;
      align-items: center;
      gap: 5px;
    }

    .powered-by-label {
      font-size: 11px;
      color: rgba(255,255,255,0.4);
    }

    .powered-by-brand {
      font-size: 12px;
      font-weight: 700;
      color: #ffffff;
    }

    /* Scan Line */
    .scan-line {
      position: absolute;
      left: 0;
      right: 0;
      height: 2px;
      background: linear-gradient(90deg, transparent, rgba(66, 133, 244, 0.6), rgba(52, 168, 83, 0.6), rgba(251, 188, 5, 0.6), transparent);
      box-shadow: 0 0 20px rgba(66, 133, 244, 0.4);
      animation: scanDown 4s ease-in-out infinite;
      pointer-events: none;
    }

    @keyframes scanDown {
      0% { top: -2px; opacity: 0; }
      10% { opacity: 1; }
      90% { opacity: 1; }
      100% { top: 100%; opacity: 0; }
    }

    /* Mobile Responsive */
    @media (max-width: 900px) {
      .preloader-main {
        flex-direction: column;
        gap: 30px;
      }

      .room-wireframe {
        width: 300px;
        height: 220px;
      }

      .preloader-panel {
        width: 100%;
        max-width: 350px;
      }

      .cad-element.countertop { width: 180px; height: 30px; left: 60px; }
      .cad-element.cabinet { width: 60px; height: 75px; left: 60px; }
      .cad-element.cabinet-2 { width: 60px; height: 75px; left: 130px; }
      .cad-element.island { width: 90px; height: 60px; left: 130px; }
    }

    /* Review Room */
    .loading-shared {
      pointer-events: none;
    }

    .loading-shared::after {
      display: none; /* Hide old loading, use cloud preloader instead */
      background: rgba(0,0,0,0.9);
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-size: 18px;
      z-index: 9999;
    }

    .review-room {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      z-index: 1000;
    }

    .review-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 20px;
      background: linear-gradient(135deg, var(--dark-surface) 0%, #1a1a35 100%);
      border-bottom: 1px solid var(--border);
      gap: 12px;
    }

    .review-header-left {
      display: flex;
      align-items: center;
      gap: 12px;
      min-width: 0;
      flex: 1;
    }

    .review-back-btn {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 40px;
      height: 40px;
      border-radius: 8px;
      background: rgba(255, 255, 255, 0.1);
      color: var(--text);
      text-decoration: none;
      transition: all 0.2s;
      flex-shrink: 0;
    }

    .review-back-btn:hover {
      background: rgba(255, 255, 255, 0.2);
      color: var(--gold);
    }

    .review-title {
      font-size: 18px;
      font-weight: 600;
      color: var(--gold);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .review-header-right {
      display: flex;
      gap: 8px;
      flex-shrink: 0;
    }

    .review-header-right .btn {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    @media (max-width: 600px) {
      .review-header {
        padding: 10px 12px;
        flex-wrap: wrap;
      }

      .review-header-left {
        gap: 8px;
      }

      .review-back-btn {
        width: 36px;
        height: 36px;
      }

      .review-title {
        font-size: 14px;
        max-width: 120px;
      }

      .review-permission-badge {
        display: none;
      }

      .review-header-right .btn .btn-text {
        display: none;
      }

      .review-header-right .btn {
        padding: 8px 10px;
      }

      .live-indicator span:not(.live-dot) {
        display: none;
      }

      .live-indicator {
        padding: 6px;
      }
    }

    .review-permission-badge {
      padding: 4px 10px;
      background: var(--primary);
      border-radius: 12px;
      font-size: 11px;
      font-weight: 500;
    }

    /* Live Sync Indicator */
    .live-indicator {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 10px;
      border-radius: 12px;
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      transition: all 0.3s ease;
    }

    .live-indicator.connected {
      background: rgba(34, 197, 94, 0.15);
      color: #22c55e;
      border: 1px solid rgba(34, 197, 94, 0.3);
    }

    .live-indicator.disconnected {
      background: rgba(239, 68, 68, 0.15);
      color: #ef4444;
      border: 1px solid rgba(239, 68, 68, 0.3);
    }

    .live-indicator .live-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      animation: livePulse 2s ease-in-out infinite;
    }

    .live-indicator.connected .live-dot {
      background: #22c55e;
    }

    .live-indicator.disconnected .live-dot {
      background: #ef4444;
      animation: none;
    }

    .live-indicator.flash {
      animation: liveFlash 0.5s ease;
    }

    @keyframes livePulse {
      0%, 100% { opacity: 1; transform: scale(1); }
      50% { opacity: 0.5; transform: scale(0.8); }
    }

    @keyframes liveFlash {
      0% { background: rgba(34, 197, 94, 0.15); }
      50% { background: rgba(34, 197, 94, 0.4); }
      100% { background: rgba(34, 197, 94, 0.15); }
    }

    .review-header-right {
      display: flex;
      gap: 8px;
    }

    .review-panel {
      position: fixed;
      top: 56px;
      right: -380px;
      width: 380px;
      height: calc(100vh - 56px);
      background: var(--dark-surface);
      border-left: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      transition: right 0.3s ease;
      z-index: 999;
    }

    .review-panel.open {
      right: 0;
    }

    .review-panel-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 16px;
      border-bottom: 1px solid var(--border);
    }

    .review-panel-header h3 {
      font-size: 14px;
      font-weight: 600;
    }

    .review-panel-close {
      width: 28px;
      height: 28px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: var(--dark-elevated);
      border: none;
      border-radius: 4px;
      color: var(--text-muted);
      cursor: pointer;
      font-size: 18px;
    }

    .review-summary {
      display: flex;
      padding: 16px;
      gap: 16px;
      background: var(--dark-elevated);
      border-bottom: 1px solid var(--border);
    }

    .review-stat {
      flex: 1;
      text-align: center;
    }

    .stat-value {
      display: block;
      font-size: 20px;
      font-weight: 700;
      color: var(--gold);
    }

    .stat-value.approved {
      color: var(--success);
    }

    .stat-label {
      font-size: 10px;
      color: var(--text-muted);
      text-transform: uppercase;
    }

    .review-elements {
      flex: 1;
      overflow-y: auto;
      padding: 12px;
    }

    .review-element {
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 12px;
      margin-bottom: 8px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .review-element:hover {
      border-color: var(--primary);
    }

    .review-element.approved {
      border-color: var(--success);
      background: rgba(16, 185, 129, 0.1);
    }

    .review-element.rejected {
      border-color: var(--error);
      background: rgba(239, 68, 68, 0.1);
    }

    .review-element-header {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 6px;
    }

    .review-element-status {
      width: 20px;
      height: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 50%;
      font-size: 12px;
      background: var(--dark-hover);
    }

    .review-element-status.approved {
      background: var(--success);
      color: white;
    }

    .review-element-status.rejected {
      background: var(--error);
      color: white;
    }

    .review-element-name {
      flex: 1;
      font-weight: 500;
      font-size: 13px;
    }

    .review-element-price {
      font-weight: 600;
      color: var(--gold);
      font-size: 13px;
    }

    .review-element-details {
      display: flex;
      gap: 12px;
      font-size: 11px;
      color: var(--text-muted);
      margin-bottom: 8px;
    }

    .review-element-material {
      color: var(--text-secondary);
    }

    .review-element-actions {
      display: flex;
      gap: 6px;
      padding-top: 8px;
      border-top: 1px solid var(--border);
    }

    .btn-approve, .btn-reject, .btn-comment {
      flex: 1;
      padding: 6px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      transition: all 0.2s;
    }

    .btn-approve {
      background: rgba(16, 185, 129, 0.2);
      color: var(--success);
    }

    .btn-approve:hover {
      background: var(--success);
      color: white;
    }

    .btn-reject {
      background: rgba(239, 68, 68, 0.2);
      color: var(--error);
    }

    .btn-reject:hover {
      background: var(--error);
      color: white;
    }

    .btn-comment {
      background: var(--dark-hover);
      color: var(--text-secondary);
    }

    .btn-comment:hover {
      background: var(--primary);
      color: white;
    }

    /* Chat-style comments section */
    .review-chat-section {
      border-top: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      height: 280px;
    }

    .review-chat-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px 12px;
      background: var(--dark-elevated);
      border-bottom: 1px solid var(--border);
      font-size: 12px;
      font-weight: 600;
    }

    .chat-status {
      font-size: 10px;
      color: #10b981;
      font-weight: 500;
    }

    .chat-status.disconnected {
      color: #ef4444;
    }

    .review-chat-messages {
      flex: 1;
      overflow-y: auto;
      padding: 12px;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .chat-message-row {
      display: flex;
      gap: 8px;
      max-width: 85%;
    }

    .chat-message-row.outbound {
      align-self: flex-end;
      flex-direction: row-reverse;
    }

    .chat-message-row.inbound {
      align-self: flex-start;
    }

    .chat-avatar {
      width: 28px;
      height: 28px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 11px;
      font-weight: 600;
      flex-shrink: 0;
    }

    .chat-message-row.inbound .chat-avatar {
      background: linear-gradient(135deg, #f9cb00, #f59e0b);
      color: #1a1a2e;
    }

    .chat-message-row.outbound .chat-avatar {
      background: linear-gradient(135deg, #6366f1, #8b5cf6);
      color: white;
    }

    .chat-bubble-wrap {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .chat-bubble {
      padding: 8px 12px;
      border-radius: 16px;
      font-size: 13px;
      line-height: 1.4;
      word-wrap: break-word;
    }

    .chat-message-row.inbound .chat-bubble {
      background: var(--dark-elevated);
      color: var(--text);
      border-bottom-left-radius: 4px;
    }

    .chat-message-row.outbound .chat-bubble {
      background: linear-gradient(135deg, #6366f1, #8b5cf6);
      color: white;
      border-bottom-right-radius: 4px;
    }

    .chat-meta {
      font-size: 9px;
      color: var(--text-muted);
      padding: 0 4px;
    }

    .chat-message-row.outbound .chat-meta {
      text-align: right;
    }

    .review-chat-input {
      display: flex;
      gap: 8px;
      padding: 10px 12px;
      background: var(--dark-elevated);
      border-top: 1px solid var(--border);
    }

    .review-chat-input input {
      flex: 1;
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: 20px;
      padding: 8px 14px;
      font-size: 13px;
      color: var(--text);
      outline: none;
    }

    .review-chat-input input:focus {
      border-color: var(--primary);
    }

    .chat-send-btn {
      width: 36px;
      height: 36px;
      border-radius: 50%;
      background: linear-gradient(135deg, #6366f1, #8b5cf6);
      border: none;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      transition: transform 0.15s, opacity 0.15s;
    }

    .chat-send-btn:hover {
      transform: scale(1.05);
    }

    .chat-send-btn:active {
      transform: scale(0.95);
    }

    .chat-empty {
      text-align: center;
      padding: 30px 20px;
      color: var(--text-muted);
    }

    .chat-empty-icon {
      font-size: 32px;
      margin-bottom: 8px;
      opacity: 0.5;
    }

    /* Legacy styles for backwards compatibility */
    .review-comments-section {
      border-top: 1px solid var(--border);
      padding: 12px;
    }

    .review-comment-input {
      display: flex;
      gap: 6px;
    }

    .review-comment-input input {
      flex: 1;
      padding: 8px 10px;
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      border-radius: 6px;
      color: var(--text);
      font-size: 12px;
    }

    .review-actions {
      padding: 12px;
      border-top: 1px solid var(--border);
      display: flex;
      gap: 8px;
    }

    .review-actions .btn {
      flex: 1;
    }

    .btn-success {
      background: var(--success);
      color: white;
    }

    .btn-success:hover {
      background: #059669;
    }

    /* Quote Approval Actions */
    .quote-approval-actions {
      flex-direction: column;
      text-align: center;
      padding: 16px;
    }

    .approval-summary {
      margin-bottom: 12px;
    }

    .approval-note {
      color: var(--text-secondary);
      font-size: 13px;
      margin: 0;
    }

    .approve-pay-btn {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 100%;
      padding: 14px 24px;
      font-size: 16px;
      font-weight: 600;
      background: linear-gradient(135deg, #22c55e, #16a34a);
      border: none;
      border-radius: 8px;
      color: white;
      cursor: pointer;
      transition: all 0.2s;
      box-shadow: 0 4px 12px rgba(34, 197, 94, 0.3);
    }

    .approve-pay-btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 6px 16px rgba(34, 197, 94, 0.4);
      background: linear-gradient(135deg, #16a34a, #15803d);
    }

    .approve-pay-btn:active {
      transform: translateY(0);
    }

    .approve-pay-btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      transform: none;
    }

    .approval-terms {
      color: var(--text-secondary);
      font-size: 11px;
      margin: 12px 0 0 0;
      opacity: 0.8;
    }

    .btn-lg {
      padding: 14px 24px;
      font-size: 16px;
    }

    /* Adjust main content when review room is active */
    body:has(.review-room) .header {
      display: none;
    }

    body:has(.review-room) .main {
      padding-top: 56px;
      margin-top: 0;
      height: 100vh;
      box-sizing: border-box;
    }

    /* Hide sidebar completely in review mode (non-collaborators) */
    body:has(.review-room).view-only-mode .sidebar,
    body:has(.review-room).review-readonly .sidebar {
      display: none !important;
    }

    /* For full collaborators, show sidebar with adjusted position */
    body:has(.review-room):not(.view-only-mode):not(.review-readonly) .sidebar {
      margin-top: 56px;
      height: calc(100vh - 56px);
    }

    body:has(.review-room) .right-panel {
      margin-top: 56px;
      height: calc(100vh - 56px);
    }

    body:has(.review-room) .canvas-area {
      flex: 1 1 auto;
      height: calc(100vh - 56px);
      min-height: 400px;
    }

    body:has(.review-room) .canvas-wrapper {
      flex: 1 1 auto;
      height: 100%;
      min-height: 300px;
    }

    body:has(.review-room) #canvas {
      display: block;
      width: 100%;
      height: 100%;
    }

    body:has(.review-room) .canvas-toolbar {
      display: none;
    }

    body:has(.review-room) .shortcuts-hint {
      display: none;
    }

    /* Hide editing UI in review mode for non-editors */
    body.review-readonly .sidebar {
      display: none;
    }

    body.review-readonly .right-panel .panel-section:not(#quotePanel) {
      display: none;
    }

    /* View-Only Mode - hide all editing UI */
    body.view-only-mode .sidebar {
      display: none !important;
    }

    body.view-only-mode .main {
      margin-left: 0 !important;
    }

    body.view-only-mode .toolbar-btn:not([data-tool="pan"]):not([data-tool="zoom-in"]):not([data-tool="zoom-out"]) {
      display: none !important;
    }

    body.view-only-mode .element-selector,
    body.view-only-mode .item-picker,
    body.view-only-mode #saveDesignBtn,
    body.view-only-mode #shareDesignBtn,
    body.view-only-mode .add-room-btn,
    body.view-only-mode .edit-actions {
      display: none !important;
    }

    body.view-only-mode .right-panel .panel-section:not(#quotePanel) {
      display: none !important;
    }

    /* Hide mobile toolbar in view-only/review mode */
    body.view-only-mode .mobile-toolbar,
    body.review-readonly .mobile-toolbar,
    body:has(.review-room) .mobile-toolbar {
      display: none !important;
    }

    /* Hide all tool buttons in shared view */
    body.view-only-mode .tool-btn,
    body.review-readonly .tool-btn {
      display: none !important;
    }

    /* Hide the entire TOOLS section in shared view */
    body.view-only-mode .tool-grid,
    body.review-readonly .tool-grid,
    body.view-only-mode #toolsSection,
    body.review-readonly #toolsSection {
      display: none !important;
    }

    /* Hide the entire left sidebar in shared view (only show canvas and review panel) */
    body.view-only-mode .left-panel,
    body.review-readonly .left-panel,
    body.view-only-mode .sidebar,
    body.review-readonly .sidebar,
    body.view-only-mode #leftSidebar,
    body.review-readonly #leftSidebar {
      display: none !important;
    }

    /* Viewer Mode Badge */
    .viewer-mode-badge {
      position: fixed;
      top: 12px;
      left: 50%;
      transform: translateX(-50%);
      background: linear-gradient(135deg, #2d3748 0%, #1a202c 100%);
      border: 1px solid var(--accent);
      border-radius: 20px;
      padding: 8px 16px;
      display: flex;
      align-items: center;
      gap: 8px;
      z-index: 10000;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      font-size: 13px;
      color: var(--text-light);
    }

    .viewer-mode-badge .badge-icon {
      font-size: 16px;
    }

    .viewer-mode-badge .badge-text {
      font-weight: 500;
      color: var(--accent);
    }

    .viewer-mode-badge .badge-action {
      background: var(--accent);
      color: #000;
      padding: 4px 10px;
      border-radius: 12px;
      font-size: 11px;
      font-weight: 600;
      margin-left: 4px;
    }

    /* ============================================
       MOBILE REVIEW ROOM & SHARED VIEW
       ============================================ */

    @media (max-width: 768px) {
      /* Review Header - Mobile */
      .review-header {
        flex-direction: row;
        flex-wrap: wrap;
        gap: 8px;
        padding: 10px 12px;
      }

      .review-header-left {
        flex: 1;
        min-width: 0;
        gap: 8px;
      }

      .review-back-btn {
        width: 36px;
        height: 36px;
      }

      .review-title {
        font-size: 14px;
        flex: 1;
        min-width: 0;
      }

      .review-permission-badge {
        display: none;
      }

      .live-indicator span:not(.live-dot) {
        display: none;
      }

      .live-indicator {
        padding: 6px;
        min-width: auto;
      }

      .review-header-right {
        gap: 6px;
      }

      .review-header-right .btn {
        padding: 8px 10px;
        font-size: 12px;
      }

      .review-header-right .btn .btn-text {
        display: none;
      }

      .review-header-right .btn svg {
        width: 18px;
        height: 18px;
      }

      .review-permission-badge-mobile {
        font-size: 10px;
        padding: 3px 8px;
      }

      .live-indicator {
        font-size: 10px;
        padding: 3px 8px;
      }

      .review-header-right {
        width: 100%;
        justify-content: center;
        flex-wrap: wrap;
        gap: 8px;
      }

      .review-header-right .btn {
        padding: 10px 14px;
        font-size: 13px;
      }

      .review-header-right .btn span {
        display: none;
      }

      .review-header-right .btn svg {
        margin: 0;
      }

      /* Review Panel - Full Screen on Mobile */
      .review-panel {
        width: 100%;
        right: -100%;
        top: auto;
        bottom: 0;
        height: 70vh;
        border-radius: 20px 20px 0 0;
        border-left: none;
        border-top: 1px solid var(--border);
      }

      .review-panel.open {
        right: 0;
      }

      .review-panel-header {
        padding: 16px;
        border-radius: 20px 20px 0 0;
      }

      .review-panel-header::before {
        content: '';
        position: absolute;
        top: 8px;
        left: 50%;
        transform: translateX(-50%);
        width: 40px;
        height: 4px;
        background: var(--border);
        border-radius: 2px;
      }

      .review-summary {
        padding: 12px 16px;
        gap: 12px;
      }

      .review-stat {
        flex: 1;
        text-align: center;
      }

      .stat-value {
        font-size: 20px;
      }

      .stat-label {
        font-size: 10px;
      }

      /* Review Elements List */
      .review-elements {
        max-height: calc(70vh - 280px);
        padding: 8px 16px;
      }

      .review-element {
        padding: 12px;
      }

      .review-element-name {
        font-size: 13px;
      }

      .review-element-price {
        font-size: 14px;
      }

      /* Comments Section */
      .review-comments-section {
        padding: 12px 16px;
      }

      .review-comments {
        max-height: 100px;
      }

      .review-comment-input {
        gap: 8px;
      }

      .review-comment-input input {
        font-size: 16px; /* Prevent iOS zoom */
        padding: 12px;
      }

      /* Approval Actions */
      .review-actions {
        padding: 16px;
      }

      .quote-approval-actions {
        padding: 16px;
      }

      .approve-pay-btn {
        width: 100%;
        padding: 16px 24px;
        font-size: 17px;
      }

      .approval-note {
        font-size: 13px;
        text-align: center;
      }

      .approval-terms {
        text-align: center;
        font-size: 10px;
      }

      /* Adjust main content when review room on mobile */
      body:has(.review-room) .main {
        padding-top: 80px; /* Taller header on mobile */
      }

      /* Viewer Mode Badge - Mobile */
      .viewer-mode-badge {
        width: calc(100% - 24px);
        max-width: 400px;
        justify-content: center;
        padding: 10px 16px;
        font-size: 12px;
      }
    }

    @media (max-width: 480px) {
      .review-header-right .btn {
        padding: 10px 12px;
        font-size: 12px;
      }

      .review-panel {
        height: 80vh;
      }

      .stat-value {
        font-size: 18px;
      }

      .approve-pay-btn {
        font-size: 15px;
        padding: 14px 20px;
      }
    }

    /* Keyboard Shortcuts - auto-hide after delay */
    .shortcuts-hint {
      position: fixed;
      bottom: 12px;
      right: 12px;
      background: var(--dark-surface);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 8px 12px;
      font-size: 9px;
      color: var(--text-muted);
      display: flex;
      gap: 12px;
      opacity: 1;
      transition: opacity 0.5s ease-out;
      z-index: 100;
    }

    .shortcuts-hint.hidden {
      opacity: 0;
      pointer-events: none;
    }

    .shortcuts-hint:hover {
      opacity: 1 !important;
      pointer-events: auto !important;
    }

    .shortcut {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .shortcut kbd {
      background: var(--dark-elevated);
      padding: 2px 4px;
      border-radius: 3px;
      font-family: inherit;
      font-size: 9px;
    }

    /* Responsive */
    @media (max-width: 1200px) {
      .sidebar { width: 180px; min-width: 180px; max-width: 180px; }
      .right-panel { width: 220px; min-width: 220px; max-width: 220px; }
      .element-grid { grid-template-columns: repeat(2, 1fr); gap: 3px; }
      .element-icon { width: 36px; height: 36px; }
      .element-name { font-size: 8px; }
    }

    /* Mobile toolbar - MUST be hidden by default on desktop */
    .mobile-toolbar {
      display: none !important;
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: var(--dark-elevated);
      border-top: 1px solid var(--border);
      padding: 8px 16px;
      justify-content: space-around;
      z-index: 1000;
    }

    @media (max-width: 900px) {
      .sidebar, .right-panel { display: none; }
      .header { padding: 8px 12px; }
      .header-left { gap: 8px; }
      .logo { height: 28px; }
      .view-toggle { display: none; }
      .canvas-area { margin: 0; }
      .toolbar { padding: 8px; gap: 4px; }
      .tool-btn { width: 36px; height: 36px; }

      /* Mobile bottom toolbar - only show on narrow screens */
      .mobile-toolbar {
        display: flex !important;
      }

      .canvas-wrapper {
        padding-bottom: 70px; /* Space for mobile toolbar */
      }
    }

    @media (max-width: 600px) {
      .header {
        height: 48px;
        min-height: 48px;
        max-height: 48px;
        padding: 0 8px;
        flex-wrap: nowrap;
        overflow: hidden;
      }
      .header-left { flex-shrink: 0; max-width: 100px; }
      .header-center {
        flex-shrink: 1;
        min-width: 0;
        gap: 2px;
        padding: 2px;
      }
      .header-center .view-btn {
        padding: 6px 10px;
        font-size: 11px;
      }
      .header-zoom-controls { display: none; }
      .header-right { flex-shrink: 0; gap: 4px; }
      .project-name-input { display: none; }
      .user-name-display { display: none; }
      .user-menu-btn { padding: 4px 8px; }
      .notification-hub-btn { width: 36px; height: 36px; }
      .btn { padding: 6px 10px; font-size: 12px; }
      .modal { margin: 10px; max-height: calc(100vh - 20px); }
      .modal-header h3 { font-size: 16px; }
      .shortcuts-hint { display: none; }

      /* Stack header actions */
      .header-actions { gap: 4px; }
      .header-actions .btn span { display: none; }
    }

    @media (max-width: 400px) {
      .logo { display: none; }
      .header-center .view-btn { padding: 4px 8px; font-size: 10px; }
      .project-name-input { display: none; }
      .user-avatar-small { width: 24px; height: 24px; font-size: 10px; }
    }

    /* Touch-friendly adjustments */
    @media (pointer: coarse) {
      .tool-btn { min-width: 44px; min-height: 44px; }
      .btn { min-height: 44px; }
      .element-item { min-height: 60px; }
      .property-row input, .property-row select { min-height: 40px; }
    }

    /* Loading overlay */
    .loading-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.7);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10001;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.2s, visibility 0.2s;
    }

    .loading-overlay.active {
      opacity: 1;
      visibility: visible;
    }

    .loading-spinner {
      width: 48px;
      height: 48px;
      border: 4px solid var(--border);
      border-top-color: var(--gold);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    .loading-text {
      color: var(--text);
      margin-top: 16px;
      font-size: 14px;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    /* Auto-save Indicator */
    .autosave-indicator {
      position: fixed;
      top: 70px;
      right: 20px;
      background: rgba(40, 167, 69, 0.9);
      color: white;
      padding: 8px 14px;
      border-radius: 6px;
      font-size: 12px;
      font-weight: 500;
      display: flex;
      align-items: center;
      gap: 6px;
      z-index: 9999;
      opacity: 0;
      transform: translateX(20px);
      transition: opacity 0.3s, transform 0.3s;
      pointer-events: none;
    }

    .autosave-indicator.show {
      opacity: 1;
      transform: translateX(0);
    }

    .autosave-indicator svg {
      width: 14px;
      height: 14px;
    }

    @media (max-width: 600px) {
      .autosave-indicator {
        top: 56px;
        right: 10px;
        padding: 6px 10px;
        font-size: 11px;
      }
    }

    /* Undo Toast */
    .undo-toast {
      position: fixed;
      bottom: 24px;
      left: 50%;
      transform: translateX(-50%) translateY(100px);
      background: #1f2937;
      color: #fff;
      padding: 12px 16px;
      border-radius: 8px;
      font-size: 13px;
      display: flex;
      align-items: center;
      gap: 12px;
      z-index: 10000;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
      opacity: 0;
      transition: transform 0.3s ease, opacity 0.3s ease;
    }
    .undo-toast.show {
      opacity: 1;
      transform: translateX(-50%) translateY(0);
    }
    .undo-toast span {
      flex: 1;
    }
    .undo-toast button {
      background: #3b82f6;
      color: #fff;
      border: none;
      padding: 6px 12px;
      border-radius: 4px;
      font-size: 12px;
      font-weight: 500;
      cursor: pointer;
      transition: background 0.2s;
    }
    .undo-toast button:hover {
      background: #2563eb;
    }
    .undo-toast button.dismiss {
      background: transparent;
      color: #9ca3af;
      padding: 4px 8px;
      font-size: 16px;
    }
    .undo-toast button.dismiss:hover {
      color: #fff;
      background: rgba(255, 255, 255, 0.1);
    }

    /* Toast Notifications */
    .toast-container {
      position: fixed;
      bottom: 24px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 10000;
      display: flex;
      flex-direction: column;
      gap: 12px;
      pointer-events: none;
    }

    .toast {
      display: flex;
      align-items: center;
      gap: 12px;
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 14px 20px;
      color: var(--text-primary);
      font-size: 14px;
      font-weight: 500;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5), 0 2px 8px rgba(0, 0, 0, 0.3);
      animation: toastIn 0.4s cubic-bezier(0.16, 1, 0.3, 1), toastOut 0.3s ease 2.7s forwards;
      pointer-events: auto;
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
    }

    .toast::before {
      content: '';
      width: 24px;
      height: 24px;
      flex-shrink: 0;
      background-size: contain;
      background-repeat: no-repeat;
      background-position: center;
    }

    .toast.success {
      border-color: rgba(34, 197, 94, 0.5);
      background: linear-gradient(135deg, rgba(34, 197, 94, 0.2), var(--dark-elevated));
    }

    .toast.success::before {
      content: '';
      display: flex;
      align-items: center;
      justify-content: center;
      width: 22px;
      height: 22px;
      background: #22c55e;
      border-radius: 50%;
      font-size: 12px;
      font-weight: 700;
      color: white;
    }

    .toast.error {
      border-color: rgba(239, 68, 68, 0.5);
      background: linear-gradient(135deg, rgba(239, 68, 68, 0.2), var(--dark-elevated));
    }

    .toast.error::before {
      content: '';
      display: flex;
      align-items: center;
      justify-content: center;
      width: 22px;
      height: 22px;
      background: #ef4444;
      border-radius: 50%;
      font-size: 12px;
      font-weight: 700;
      color: white;
    }

    .toast.warning {
      border-color: rgba(249, 203, 0, 0.5);
      background: linear-gradient(135deg, rgba(249, 203, 0, 0.2), var(--dark-elevated));
    }

    .toast.warning::before {
      content: '!';
      display: flex;
      align-items: center;
      justify-content: center;
      width: 22px;
      height: 22px;
      background: #f9cb00;
      border-radius: 50%;
      font-size: 14px;
      font-weight: 700;
      color: #1a1a2e;
    }

    .toast.info {
      border-color: rgba(99, 102, 241, 0.5);
      background: linear-gradient(135deg, rgba(99, 102, 241, 0.2), var(--dark-elevated));
    }

    .toast.info::before {
      content: 'i';
      display: flex;
      align-items: center;
      justify-content: center;
      width: 22px;
      height: 22px;
      background: var(--primary);
      border-radius: 50%;
      font-size: 13px;
      font-weight: 700;
      font-style: italic;
      color: white;
    }

    @keyframes toastIn {
      from { opacity: 0; transform: translateY(24px) scale(0.95); }
      to { opacity: 1; transform: translateY(0) scale(1); }
    }

    @keyframes toastOut {
      from { opacity: 1; transform: translateY(0) scale(1); }
      to { opacity: 0; transform: translateY(-16px) scale(0.95); }
    }

    /* ===== MY DESIGNS MODAL ===== */
    .designs-tabs {
      display: flex;
      gap: 4px;
      padding: 0 0 16px 0;
      border-bottom: 1px solid var(--border-color);
      margin-bottom: 16px;
    }

    .designs-tab {
      padding: 10px 20px;
      background: transparent;
      border: none;
      color: var(--text-secondary);
      font-size: 14px;
      cursor: pointer;
      border-radius: 8px;
      transition: all 0.2s;
    }

    .designs-tab:hover {
      background: var(--dark-hover);
      color: var(--text-primary);
    }

    .designs-tab.active {
      background: var(--accent-color);
      color: white;
    }

    .designs-search {
      position: relative;
      margin-bottom: 16px;
    }

    .designs-search input {
      width: 100%;
      padding: 12px 16px 12px 44px;
      background: var(--dark-hover);
      border: 1px solid var(--border-color);
      border-radius: 10px;
      color: var(--text-primary);
      font-size: 14px;
    }

    .designs-search svg {
      position: absolute;
      left: 14px;
      top: 50%;
      transform: translateY(-50%);
      width: 18px;
      height: 18px;
      stroke: var(--text-muted);
    }

    .designs-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
      gap: 16px;
      max-height: 50vh;
      overflow-y: auto;
      padding: 4px 8px 8px 4px; /* Top/left for hover, right for scrollbar, bottom for shadow */
    }

    .design-card {
      background: var(--dark-hover);
      border: 1px solid var(--border-color);
      border-radius: 12px;
      overflow: hidden;
      cursor: pointer;
      transition: all 0.2s;
    }

    .design-card:hover {
      border-color: var(--accent-color);
      transform: scale(1.02);
      box-shadow: 0 8px 24px rgba(0,0,0,0.3);
      z-index: 10;
      position: relative;
    }

    .design-card-preview {
      height: 140px;
      background: var(--panel-bg);
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      overflow: hidden;
    }

    .design-card-preview img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .design-card-preview svg {
      width: 48px;
      height: 48px;
      stroke: var(--text-muted);
    }

    .design-card-badge {
      position: absolute;
      top: 8px;
      right: 8px;
      padding: 4px 8px;
      background: rgba(0,0,0,0.6);
      backdrop-filter: blur(4px);
      border-radius: 4px;
      font-size: 10px;
      color: white;
      text-transform: uppercase;
    }

    .design-card-info {
      padding: 12px;
    }

    .design-card-name {
      font-weight: 600;
      color: var(--text-primary);
      margin-bottom: 4px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .design-card-customer {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 11px;
      color: var(--gold-primary);
      margin-bottom: 6px;
      padding: 4px 8px;
      background: rgba(249, 203, 0, 0.1);
      border-radius: 4px;
      border-left: 2px solid var(--gold-primary);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .design-card-customer svg {
      flex-shrink: 0;
    }

    .design-card-meta {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 12px;
      color: var(--text-muted);
    }

    .design-card-date {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .design-card-comments {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .design-card-delete {
      position: absolute;
      top: 8px;
      right: 8px;
      width: 32px;
      height: 32px;
      border-radius: 50%;
      background: rgba(239, 68, 68, 0.9);
      border: none;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0;
      transition: opacity 0.2s, transform 0.2s;
      z-index: 10;
    }

    .design-card-delete svg {
      stroke: white;
    }

    .design-card:hover .design-card-delete {
      opacity: 1;
    }

    .design-card-delete:hover {
      background: rgba(220, 38, 38, 1);
      transform: scale(1.1);
    }

    .design-card-badge.local {
      background: #6B7280;
    }

    .design-card-badge.cloud {
      background: #3B82F6;
    }

    .design-card-badge.shared {
      background: #10B981;
    }

    .design-card-details {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      font-size: 11px;
      color: var(--text-muted);
      margin-bottom: 4px;
    }

    .design-card-details span {
      display: flex;
      align-items: center;
      gap: 3px;
    }

    .design-card-room-type svg {
      width: 12px;
      height: 12px;
    }

    .design-card-dims {
      background: var(--panel-bg);
      padding: 2px 6px;
      border-radius: 4px;
    }

    .design-card-elements {
      color: var(--accent-gold);
    }

    .design-card-name {
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 100%;
    }

    .designs-loading, .designs-empty {
      text-align: center;
      padding: 40px;
      color: var(--text-muted);
    }

    .designs-empty svg {
      width: 64px;
      height: 64px;
      margin-bottom: 16px;
      stroke: var(--text-muted);
    }

    .designs-empty p {
      margin-bottom: 16px;
      font-size: 16px;
    }

    /* Notification Toast */
    .notification-toast {
      position: fixed;
      top: 20px;
      right: 20px;
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 16px 20px;
      background: rgba(30, 30, 40, 0.95);
      backdrop-filter: blur(20px);
      border: 1px solid var(--border-color);
      border-radius: 12px;
      box-shadow: 0 8px 32px rgba(0,0,0,0.4);
      z-index: 10000;
      transform: translateX(calc(100% + 40px));
      transition: transform 0.3s ease;
      max-width: 360px;
    }

    .notification-toast.show {
      transform: translateX(0);
    }

    .notification-icon {
      width: 40px;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: var(--accent-color);
      border-radius: 10px;
      flex-shrink: 0;
    }

    .notification-icon svg {
      width: 20px;
      height: 20px;
      stroke: white;
    }

    .notification-content {
      flex: 1;
      min-width: 0;
    }

    .notification-title {
      font-weight: 600;
      color: var(--text-primary);
      font-size: 14px;
      margin-bottom: 2px;
    }

    .notification-body {
      font-size: 13px;
      color: var(--text-secondary);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .notification-close {
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: transparent;
      border: none;
      color: var(--text-muted);
      cursor: pointer;
      font-size: 18px;
      border-radius: 4px;
    }

    .notification-close:hover {
      background: var(--dark-hover);
      color: var(--text-primary);
    }

    /* Comment Notification Toast - appears when customer comments */
    .comment-notification-toast {
      position: fixed !important;
      top: 80px !important;
      right: 20px !important;
      display: flex !important;
      align-items: center;
      gap: 12px;
      padding: 14px 18px;
      background: #2a2040;
      background: linear-gradient(135deg, rgba(139, 92, 246, 0.3), rgba(59, 130, 246, 0.2));
      backdrop-filter: blur(20px);
      border: 2px solid rgba(139, 92, 246, 0.6);
      border-radius: 12px;
      box-shadow: 0 8px 32px rgba(139, 92, 246, 0.4), 0 0 0 1px rgba(255,255,255,0.1);
      z-index: 999999 !important;
      cursor: pointer;
      max-width: 380px;
      min-width: 280px;
      animation: commentSlideIn 0.4s ease-out;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
      color: white;
    }

    .comment-notification-toast:hover {
      transform: translateX(-4px) scale(1.02);
      box-shadow: 0 12px 40px rgba(139, 92, 246, 0.35), 0 0 0 1px rgba(255,255,255,0.1);
    }

    .comment-notification-toast.fade-out {
      animation: commentSlideOut 0.3s ease-in forwards;
    }

    @keyframes commentSlideIn {
      from {
        opacity: 0;
        transform: translateX(100px);
      }
      to {
        opacity: 1;
        transform: translateX(0);
      }
    }

    @keyframes commentSlideOut {
      from {
        opacity: 1;
        transform: translateX(0);
      }
      to {
        opacity: 0;
        transform: translateX(100px);
      }
    }

    .comment-notification-icon {
      font-size: 24px;
      animation: commentBounce 0.6s ease-out;
    }

    @keyframes commentBounce {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.2); }
    }

    .comment-notification-content {
      flex: 1;
      min-width: 0;
    }

    .comment-notification-title {
      font-weight: 600;
      font-size: 13px;
      color: var(--primary-color);
      margin-bottom: 4px;
    }

    .comment-notification-message {
      font-size: 12px;
      color: var(--text-secondary);
      line-height: 1.4;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .comment-notification-action {
      font-size: 12px;
      font-weight: 600;
      color: var(--accent-color);
      padding: 4px 8px;
      background: rgba(249, 203, 0, 0.15);
      border-radius: 6px;
      white-space: nowrap;
    }

    /* ========================================
       GAMING-STYLE NOTIFICATION HUB
       Single unified notification center
       ======================================== */

    .notification-hub {
      position: relative;
    }

    .notification-hub-btn {
      position: relative;
      width: 40px;
      height: 40px;
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      border-radius: 10px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s ease;
    }

    .notification-hub-btn:hover {
      background: var(--dark-hover);
      border-color: var(--gold);
      transform: scale(1.05);
    }

    .notification-hub-btn.has-notifications {
      border-color: #ef4444;
      animation: hubGlow 2s infinite;
    }

    @keyframes hubGlow {
      0%, 100% { box-shadow: 0 0 5px rgba(239, 68, 68, 0.3); }
      50% { box-shadow: 0 0 15px rgba(239, 68, 68, 0.6); }
    }

    @keyframes pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.15); }
    }

    .notification-hub-btn svg {
      width: 20px;
      height: 20px;
      color: var(--text-secondary);
      transition: color 0.2s;
    }

    .notification-hub-btn:hover svg,
    .notification-hub-btn.has-notifications svg {
      color: var(--text);
    }

    /* ========== UNIFIED MESSAGING SYSTEM ========== */
    .messaging-hub {
      position: relative;
      margin-right: 8px;
    }

    .messaging-hub-btn {
      position: relative;
      width: 40px;
      height: 40px;
      border-radius: 10px;
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .messaging-hub-btn:hover {
      background: var(--dark-hover);
      border-color: #3b82f6;
      transform: scale(1.05);
    }

    .messaging-hub-btn.has-messages {
      border-color: #3b82f6;
      animation: messageGlow 2s infinite;
    }

    @keyframes messageGlow {
      0%, 100% { box-shadow: 0 0 0 0 rgba(59, 130, 246, 0.4); }
      50% { box-shadow: 0 0 0 8px rgba(59, 130, 246, 0); }
    }

    .messaging-hub-btn svg {
      width: 20px;
      height: 20px;
      color: var(--text-secondary);
      transition: color 0.2s;
    }

    .messaging-hub-btn:hover svg {
      color: var(--text);
    }

    .msg-badge {
      position: absolute;
      top: -4px;
      right: -4px;
      min-width: 18px;
      height: 18px;
      background: #3b82f6;
      border-radius: 9px;
      font-size: 10px;
      font-weight: 700;
      color: white;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0 4px;
    }

    .msg-badge.hidden {
      display: none;
    }

    /* Messaging Panel */
    .messaging-panel {
      position: fixed;
      top: 0;
      right: -420px;
      width: 400px;
      max-width: 100vw;
      height: 100vh;
      background: var(--dark-surface);
      border-left: 1px solid var(--border);
      z-index: 10001;
      display: flex;
      flex-direction: column;
      transition: right 0.3s ease;
      box-shadow: -4px 0 24px rgba(0, 0, 0, 0.3);
    }

    .messaging-panel.open {
      right: 0;
    }

    .messaging-panel-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.5);
      z-index: 10000;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease;
    }

    .messaging-panel-overlay.open {
      opacity: 1;
      pointer-events: auto;
    }

    .msg-panel-header {
      padding: 16px;
      border-bottom: 1px solid var(--border);
      display: flex;
      align-items: center;
      justify-content: space-between;
      background: var(--dark-elevated);
    }

    .msg-panel-title {
      font-size: 16px;
      font-weight: 700;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .msg-panel-close {
      width: 32px;
      height: 32px;
      border-radius: 8px;
      background: transparent;
      border: none;
      color: var(--text-secondary);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
    }

    .msg-panel-close:hover {
      background: var(--dark-hover);
      color: var(--text);
    }

    /* Conversation List */
    .msg-conversations {
      flex: 1;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
    }

    .msg-search {
      padding: 12px;
      border-bottom: 1px solid var(--border);
    }

    .msg-search-input {
      width: 100%;
      padding: 10px 12px;
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      border-radius: 8px;
      color: var(--text);
      font-size: 13px;
    }

    .msg-search-input:focus {
      outline: none;
      border-color: #3b82f6;
    }

    .msg-new-chat-btn {
      margin: 12px;
      padding: 12px;
      background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
      border: none;
      border-radius: 10px;
      color: white;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      transition: all 0.2s;
    }

    .msg-new-chat-btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
    }

    .msg-conversation-list {
      flex: 1;
      overflow-y: auto;
    }

    .msg-conversation-item {
      padding: 12px 16px;
      border-bottom: 1px solid var(--border);
      display: flex;
      align-items: center;
      gap: 12px;
      cursor: pointer;
      transition: background 0.2s;
    }

    .msg-conversation-item:hover {
      background: var(--dark-elevated);
    }

    .msg-conversation-item.active {
      background: rgba(59, 130, 246, 0.1);
      border-left: 3px solid #3b82f6;
    }

    .msg-conversation-item.unread {
      background: rgba(59, 130, 246, 0.05);
    }

    .msg-conv-avatar {
      width: 44px;
      height: 44px;
      border-radius: 50%;
      background: linear-gradient(135deg, #3b82f6, #8b5cf6);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      font-weight: 600;
      color: white;
      flex-shrink: 0;
    }

    .msg-conv-avatar.customer {
      background: linear-gradient(135deg, #f9cb00, #f59e0b);
      color: #1a1a2e;
    }

    .msg-conv-avatar.collaborator {
      background: linear-gradient(135deg, #10b981, #059669);
    }

    .msg-conv-info {
      flex: 1;
      min-width: 0;
    }

    .msg-conv-name {
      font-size: 14px;
      font-weight: 600;
      margin-bottom: 2px;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .msg-conv-name .role-tag {
      font-size: 9px;
      padding: 2px 6px;
      background: var(--dark-elevated);
      border-radius: 4px;
      font-weight: 500;
      color: var(--text-muted);
    }

    .msg-conv-preview {
      font-size: 12px;
      color: var(--text-muted);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .msg-conv-meta {
      text-align: right;
      flex-shrink: 0;
    }

    .msg-conv-time {
      font-size: 11px;
      color: var(--text-muted);
    }

    .msg-conv-unread {
      width: 8px;
      height: 8px;
      background: #3b82f6;
      border-radius: 50%;
      margin-top: 6px;
      margin-left: auto;
    }

    .msg-conv-unread-badge {
      min-width: 18px;
      height: 18px;
      background: var(--gold-primary);
      color: var(--dark-primary);
      border-radius: 9px;
      font-size: 11px;
      font-weight: 600;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0 5px;
      margin-top: 4px;
    }

    .msg-sender-name {
      font-size: 11px;
      font-weight: 600;
      color: var(--gold-primary);
      margin-bottom: 4px;
    }

    .msg-message-meta {
      display: flex;
      align-items: center;
      gap: 6px;
      margin-top: 4px;
    }

    .msg-read-receipt {
      font-size: 11px;
      color: var(--text-muted);
    }

    .msg-message-row.outbound .msg-read-receipt {
      color: var(--gold-primary);
    }

    /* Chat View */
    .msg-chat-view {
      position: absolute;
      inset: 0;
      background: var(--dark-surface);
      display: flex;
      flex-direction: column;
      transform: translateX(100%);
      transition: transform 0.3s ease;
    }

    .msg-chat-view.open {
      transform: translateX(0);
    }

    .msg-chat-header {
      padding: 12px 16px;
      border-bottom: 1px solid var(--border);
      display: flex;
      align-items: center;
      gap: 12px;
      background: var(--dark-elevated);
    }

    .msg-chat-back {
      width: 32px;
      height: 32px;
      border-radius: 8px;
      background: transparent;
      border: none;
      color: var(--text-secondary);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .msg-chat-back:hover {
      background: var(--dark-hover);
      color: var(--text);
    }

    .msg-chat-recipient {
      flex: 1;
    }

    .msg-chat-recipient-name {
      font-size: 14px;
      font-weight: 600;
    }

    .msg-chat-recipient-status {
      font-size: 11px;
      color: var(--text-muted);
    }

    .msg-chat-recipient-status.online {
      color: #10b981;
    }

    .msg-chat-messages {
      flex: 1;
      overflow-y: auto;
      padding: 16px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .msg-message-row {
      display: flex;
      gap: 8px;
      max-width: 85%;
    }

    .msg-message-row.outbound {
      align-self: flex-end;
      flex-direction: row-reverse;
    }

    .msg-message-row.inbound {
      align-self: flex-start;
    }

    .msg-message-bubble {
      padding: 10px 14px;
      border-radius: 18px;
      font-size: 14px;
      line-height: 1.4;
      max-width: 100%;
      word-wrap: break-word;
    }

    .msg-message-row.inbound .msg-message-bubble {
      background: var(--dark-elevated);
      color: var(--text);
      border-bottom-left-radius: 4px;
    }

    .msg-message-row.outbound .msg-message-bubble {
      background: linear-gradient(135deg, #3b82f6, #2563eb);
      color: white;
      border-bottom-right-radius: 4px;
    }

    .msg-message-time {
      font-size: 10px;
      color: var(--text-muted);
      margin-top: 4px;
      text-align: right;
    }

    .msg-message-row.outbound .msg-message-time {
      color: rgba(255,255,255,0.7);
    }

    .msg-chat-input-area {
      padding: 12px 16px;
      border-top: 1px solid var(--border);
      background: var(--dark-elevated);
    }

    .msg-chat-input-wrapper {
      display: flex;
      gap: 8px;
      align-items: flex-end;
    }

    .msg-chat-input {
      flex: 1;
      padding: 10px 14px;
      background: var(--dark-surface);
      border: 1px solid var(--border);
      border-radius: 20px;
      color: var(--text);
      font-size: 14px;
      resize: none;
      max-height: 100px;
      min-height: 40px;
    }

    .msg-chat-input:focus {
      outline: none;
      border-color: #3b82f6;
    }

    .msg-send-btn {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: linear-gradient(135deg, #3b82f6, #2563eb);
      border: none;
      color: white;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
      flex-shrink: 0;
    }

    .msg-send-btn:hover {
      transform: scale(1.05);
      box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
    }

    .msg-send-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }

    /* New Chat Modal */
    .msg-new-chat-modal {
      position: absolute;
      inset: 0;
      background: var(--dark-surface);
      display: flex;
      flex-direction: column;
      transform: translateX(100%);
      transition: transform 0.3s ease;
    }

    .msg-new-chat-modal.open {
      transform: translateX(0);
    }

    .msg-add-recipient {
      padding: 16px;
    }

    .msg-add-recipient label {
      display: block;
      font-size: 12px;
      font-weight: 600;
      color: var(--text-secondary);
      margin-bottom: 8px;
    }

    .msg-email-input-wrapper {
      display: flex;
      gap: 8px;
    }

    .msg-email-input {
      flex: 1;
      padding: 12px;
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      border-radius: 8px;
      color: var(--text);
      font-size: 14px;
    }

    .msg-email-input:focus {
      outline: none;
      border-color: #3b82f6;
    }

    .msg-add-email-btn {
      padding: 12px 16px;
      background: #3b82f6;
      border: none;
      border-radius: 8px;
      color: white;
      font-weight: 600;
      cursor: pointer;
      white-space: nowrap;
    }

    .msg-add-email-btn:hover {
      background: #2563eb;
    }

    .msg-collaborators-section {
      padding: 0 16px 16px;
    }

    .msg-collaborators-title {
      font-size: 12px;
      font-weight: 600;
      color: var(--text-secondary);
      margin-bottom: 12px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .msg-collaborator-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
      max-height: 300px;
      overflow-y: auto;
    }

    .msg-collaborator-item {
      padding: 12px;
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      border-radius: 10px;
      display: flex;
      align-items: center;
      gap: 12px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .msg-collaborator-item:hover {
      border-color: #3b82f6;
      background: rgba(59, 130, 246, 0.1);
    }

    .msg-empty-state {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 32px;
      text-align: center;
    }

    .msg-empty-icon {
      font-size: 48px;
      margin-bottom: 16px;
      opacity: 0.5;
    }

    .msg-empty-text {
      font-size: 16px;
      font-weight: 600;
      margin-bottom: 8px;
    }

    .msg-empty-subtext {
      font-size: 13px;
      color: var(--text-muted);
      max-width: 280px;
    }

    /* Responsive */
    @media (max-width: 480px) {
      .messaging-panel {
        width: 100vw;
        right: -100vw;
      }
    }

    .hub-badge {
      position: absolute;
      top: -4px;
      right: -4px;
      min-width: 18px;
      height: 18px;
      background: linear-gradient(135deg, #ef4444, #dc2626);
      color: white;
      font-size: 10px;
      font-weight: 700;
      border-radius: 9px;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0 5px;
      border: 2px solid var(--dark);
      animation: badgeBounce 0.3s ease;
    }

    @keyframes badgeBounce {
      0% { transform: scale(0); }
      50% { transform: scale(1.3); }
      100% { transform: scale(1); }
    }

    .hub-badge.hidden {
      display: none;
    }

    /* Notification Dropdown Panel */
    .notification-dropdown {
      position: absolute;
      top: calc(100% + 8px);
      right: 0;
      width: 360px;
      max-height: 480px;
      background: var(--dark-surface);
      border: 1px solid var(--border);
      border-radius: 12px;
      box-shadow: 0 20px 50px rgba(0, 0, 0, 0.5);
      z-index: 10000;
      opacity: 0;
      visibility: hidden;
      transform: translateY(-10px) scale(0.95);
      transition: all 0.2s ease;
      overflow: hidden;
    }

    .notification-dropdown.show {
      opacity: 1;
      visibility: visible;
      transform: translateY(0) scale(1);
    }

    .notification-dropdown-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 14px 16px;
      background: linear-gradient(90deg, rgba(99, 102, 241, 0.1), transparent);
      border-bottom: 1px solid var(--border);
    }

    .notification-dropdown-title {
      font-size: 14px;
      font-weight: 600;
      color: var(--text);
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .notification-dropdown-title span {
      font-size: 16px;
    }

    .mark-all-read {
      font-size: 11px;
      color: var(--primary);
      background: none;
      border: none;
      cursor: pointer;
      padding: 4px 8px;
      border-radius: 4px;
      transition: background 0.2s;
    }

    .mark-all-read:hover {
      background: rgba(99, 102, 241, 0.15);
    }

    /* Tab Filter */
    .notification-tabs {
      display: flex;
      padding: 8px 12px;
      gap: 6px;
      border-bottom: 1px solid var(--border);
      background: rgba(0, 0, 0, 0.2);
    }

    .notification-tab {
      padding: 6px 12px;
      font-size: 11px;
      font-weight: 500;
      color: var(--text-muted);
      background: none;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      gap: 5px;
    }

    .notification-tab:hover {
      color: var(--text);
      background: rgba(255, 255, 255, 0.05);
    }

    .notification-tab.active {
      color: var(--gold);
      background: rgba(249, 203, 0, 0.15);
    }

    .notification-tab .tab-count {
      font-size: 9px;
      padding: 2px 5px;
      border-radius: 8px;
      background: rgba(255, 255, 255, 0.1);
    }

    .notification-tab.active .tab-count {
      background: rgba(249, 203, 0, 0.3);
    }

    /* Notification List */
    .notification-list {
      max-height: 340px;
      overflow-y: auto;
      padding: 8px;
    }

    .notification-list::-webkit-scrollbar {
      width: 6px;
    }

    .notification-list::-webkit-scrollbar-thumb {
      background: rgba(255, 255, 255, 0.15);
      border-radius: 3px;
    }

    .notification-item {
      display: flex;
      gap: 12px;
      padding: 12px;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s;
      margin-bottom: 4px;
      position: relative;
    }

    .notification-item:hover {
      background: rgba(255, 255, 255, 0.05);
    }

    .notification-item.unread {
      background: rgba(99, 102, 241, 0.08);
    }

    .notification-item.unread::before {
      content: '';
      position: absolute;
      left: 4px;
      top: 50%;
      transform: translateY(-50%);
      width: 6px;
      height: 6px;
      background: var(--primary);
      border-radius: 50%;
    }

    .notif-icon {
      width: 36px;
      height: 36px;
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      flex-shrink: 0;
    }

    .notif-icon.chat { background: rgba(139, 92, 246, 0.2); }
    .notif-icon.team { background: rgba(16, 185, 129, 0.2); }
    .notif-icon.alert { background: rgba(249, 115, 22, 0.2); }
    .notif-icon.system { background: rgba(99, 102, 241, 0.2); }

    .notif-content {
      flex: 1;
      min-width: 0;
    }

    .notif-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 4px;
    }

    .notif-source {
      font-size: 12px;
      font-weight: 600;
      color: var(--text);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 180px;
    }

    .notif-time {
      font-size: 10px;
      color: var(--text-muted);
      white-space: nowrap;
    }

    .notif-message {
      font-size: 12px;
      color: var(--text-secondary);
      line-height: 1.4;
      display: -webkit-box;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
      overflow: hidden;
    }

    .notif-context {
      font-size: 10px;
      color: var(--text-muted);
      margin-top: 4px;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .notif-context .design-link {
      color: var(--gold);
      font-weight: 500;
    }

    /* Empty State */
    .notification-empty {
      text-align: center;
      padding: 40px 20px;
      color: var(--text-muted);
    }

    .notification-empty-icon {
      font-size: 40px;
      margin-bottom: 12px;
      opacity: 0.4;
    }

    .notification-empty-text {
      font-size: 13px;
    }

    .notification-empty-subtext {
      font-size: 11px;
      opacity: 0.7;
      margin-top: 4px;
    }

    /* Quick Actions Footer */
    .notification-prefs {
      padding: 8px 12px;
      border-top: 1px solid var(--border);
      display: flex;
      gap: 8px;
      justify-content: center;
    }

    .notif-pref-btn {
      display: flex;
      align-items: center;
      gap: 4px;
      padding: 4px 10px;
      border-radius: 12px;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid var(--border);
      color: #888;
      font-size: 11px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .notif-pref-btn:hover {
      background: rgba(255, 255, 255, 0.1);
      color: #aaa;
    }

    .notif-pref-btn.active {
      background: rgba(99, 102, 241, 0.2);
      border-color: var(--primary);
      color: var(--primary);
    }

    .notif-pref-btn svg {
      opacity: 0.7;
    }

    .notif-pref-btn.active svg {
      opacity: 1;
    }

    .notification-footer {
      padding: 10px 12px;
      border-top: 1px solid var(--border);
      background: rgba(0, 0, 0, 0.2);
      display: flex;
      justify-content: center;
    }

    .view-all-btn {
      font-size: 12px;
      color: var(--primary);
      background: none;
      border: none;
      cursor: pointer;
      padding: 6px 12px;
      border-radius: 6px;
      transition: background 0.2s;
    }

    .view-all-btn:hover {
      background: rgba(99, 102, 241, 0.15);
    }

    /* Hide old sections - replaced by hub */
    #designNotificationsSection {
      display: none !important;
    }

    /* Messages Section Styles */
    #messagesSection {
      background: rgba(139, 92, 246, 0.08);
      border: 1px solid rgba(139, 92, 246, 0.3);
      border-radius: 8px;
      margin: 8px;
    }

    #messagesSection .panel-title {
      color: #a78bfa;
      margin-bottom: 0;
      padding: 10px 12px;
      border-bottom: 1px solid rgba(139, 92, 246, 0.2);
    }

    .messages-panel-content {
      padding: 10px 12px;
    }

    .message-badge.has-messages {
      display: inline-block !important;
      animation: badgePulse 2s infinite;
    }

    @keyframes badgePulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.1); }
    }

    .customer-message {
      padding: 8px 10px;
      margin: 6px 0;
      border-radius: 6px;
      font-size: 11px;
      line-height: 1.4;
    }

    .customer-message.inbound {
      background: rgba(139, 92, 246, 0.15);
      border-left: 3px solid #8b5cf6;
      margin-right: 15px;
    }

    .customer-message.outbound {
      background: rgba(16, 185, 129, 0.15);
      border-left: 3px solid #10b981;
      margin-left: 15px;
    }

    .customer-message-header {
      display: flex;
      justify-content: space-between;
      margin-bottom: 4px;
      font-size: 9px;
      color: var(--text-muted);
    }

    .customer-message-author {
      font-weight: 600;
      color: #a78bfa;
    }

    .customer-message-text {
      color: var(--text-primary);
    }

    .customer-message-input {
      display: flex;
      gap: 8px;
      margin-top: 8px;
    }

    .customer-message-input input {
      flex: 1;
      padding: 8px 12px;
      border: 1px solid rgba(139, 92, 246, 0.3);
      border-radius: 6px;
      background: var(--dark-elevated);
      color: var(--text);
      font-size: 11px;
    }

    .customer-message-input input:focus {
      outline: none;
      border-color: #8b5cf6;
    }

    .customer-message-input .btn {
      padding: 8px 14px;
      font-size: 9px;
    }

    /* ========================================
       MESSAGES PANEL - Simple & Visible
       ======================================== */
    #teamChatSection {
      background: rgba(99, 102, 241, 0.05);
      border: 1px solid rgba(99, 102, 241, 0.2);
      border-radius: 8px;
      margin: 8px;
    }

    #teamChatSection .panel-title {
      background: rgba(99, 102, 241, 0.1);
      color: #a5b4fc;
      padding: 10px 12px;
      font-weight: 600;
      font-size: 11px;
      text-transform: none;
    }

    #teamChatSection .panel-content {
      padding: 0;
    }

    /* Message tabs */
    .message-tabs {
      display: flex;
      background: rgba(0, 0, 0, 0.15);
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }

    .message-tab {
      flex: 1;
      padding: 8px 6px;
      font-size: 10px;
      font-weight: 500;
      color: var(--text-muted);
      background: none;
      border: none;
      border-bottom: 2px solid transparent;
      cursor: pointer;
    }

    .message-tab:hover {
      color: var(--text);
    }

    .message-tab.active {
      color: var(--gold);
      border-bottom-color: var(--gold);
    }

    .message-tab .tab-badge {
      font-size: 9px;
      padding: 1px 5px;
      border-radius: 6px;
      background: #ef4444;
      color: white;
      margin-left: 4px;
    }

    .message-tab .tab-badge.hidden {
      display: none;
    }

    #teamChatMessages {
      background: rgba(0, 0, 0, 0.1);
      min-height: 120px;
      max-height: 200px;
      overflow-y: auto;
      padding: 10px;
    }

    /* Chat message bubbles */
    .chat-message {
      display: flex;
      gap: 10px;
      margin-bottom: 12px;
      animation: messageSlide 0.2s ease-out;
    }

    .chat-message.own-message {
      flex-direction: row-reverse;
    }

    .chat-message .avatar {
      width: 28px;
      height: 28px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      font-weight: 600;
      flex-shrink: 0;
    }

    .chat-message .bubble {
      max-width: 80%;
      padding: 10px 12px;
      border-radius: 12px;
      font-size: 12px;
      line-height: 1.5;
    }

    .chat-message.own-message .bubble {
      background: linear-gradient(135deg, rgba(249, 203, 0, 0.2), rgba(234, 179, 8, 0.15));
      border-bottom-right-radius: 4px;
    }

    .chat-message:not(.own-message) .bubble {
      background: rgba(99, 102, 241, 0.15);
      border-bottom-left-radius: 4px;
    }

    .chat-message .meta {
      font-size: 10px;
      color: var(--text-muted);
      margin-bottom: 4px;
    }

    .chat-message.own-message .meta {
      text-align: right;
    }

    @keyframes messageSlide {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }

    /* System messages */
    .chat-system-message {
      text-align: center;
      padding: 6px 12px;
      font-size: 10px;
      color: var(--text-muted);
      font-style: italic;
      background: rgba(255, 255, 255, 0.03);
      border-radius: 12px;
      margin: 8px 0;
    }

    /* Chat input area */
    .chat-input-wrapper {
      display: flex;
      gap: 6px;
      padding: 8px;
      background: rgba(0, 0, 0, 0.15);
      border-top: 1px solid rgba(255, 255, 255, 0.05);
    }

    #teamChatInput {
      flex: 1;
      padding: 8px 12px;
      border: 1px solid rgba(99, 102, 241, 0.3);
      border-radius: 16px;
      background: rgba(0, 0, 0, 0.2);
      color: var(--text);
      font-size: 11px;
    }

    #teamChatInput::placeholder {
      color: rgba(255, 255, 255, 0.3);
    }

    #teamChatInput:focus {
      border-color: var(--primary);
      outline: none;
    }

    #teamChatSection .btn-primary {
      background: var(--primary);
      border: none;
      border-radius: 50%;
      width: 32px;
      height: 32px;
      min-width: 32px;
      padding: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
    }

    #teamChatSection .btn-primary:hover {
      background: var(--primary-dark);
    }

    #teamChatSection .btn-primary svg {
      width: 14px;
      height: 14px;
      color: white;
    }

    /* Online indicator */
    .online-indicator {
      animation: onlinePulse 2s infinite;
      font-weight: 500;
    }

    @keyframes onlinePulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.6; }
    }

    /* Active collaborators */
    #activeCollaborators {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      padding: 8px;
      background: rgba(0, 0, 0, 0.15);
      border-radius: 8px;
      margin-bottom: 10px;
    }

    .collaborator-chip {
      display: flex;
      align-items: center;
      gap: 6px;
      background: rgba(255, 255, 255, 0.08);
      padding: 4px 10px 4px 4px;
      border-radius: 16px;
      font-size: 11px;
      color: var(--text-secondary);
    }

    .collaborator-chip .avatar-small {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 10px;
      font-weight: 600;
      color: white;
    }

    .collaborator-chip.is-you {
      border: 1px solid rgba(249, 203, 0, 0.4);
    }

    /* Team chat notification badge */
    .team-chat-badge {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      min-width: 18px;
      height: 18px;
      padding: 0 5px;
      background: linear-gradient(135deg, #ef4444, #dc2626);
      border-radius: 9px;
      font-size: 10px;
      font-weight: 700;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      animation: badgePulse 2s infinite;
    }

    /* =============================================
       v7.0 - Cabinet Library Modal
       ============================================= */
    .cabinet-library-modal {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.85);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10000;
      padding: 20px;
      overflow-y: auto;
    }

    .cabinet-library-content {
      background: var(--dark-surface);
      border: 1px solid var(--border);
      border-radius: 16px;
      width: 100%;
      max-width: 800px;
      max-height: 90vh;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    .cabinet-library-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 16px 20px;
      border-bottom: 1px solid var(--border);
      background: var(--dark-elevated);
      flex-wrap: wrap;
      gap: 12px;
    }

    .cabinet-library-header h3 {
      margin: 0;
      font-size: 18px;
    }

    .cabinet-library-header .cabinet-library-tabs {
      display: flex;
      gap: 6px;
      flex: 1;
      justify-content: center;
    }

    .cabinet-library-header > button {
      background: none;
      border: none;
      color: var(--text-muted);
      font-size: 24px;
      cursor: pointer;
      padding: 4px 8px;
      line-height: 1;
    }

    .cabinet-library-header > button:hover {
      color: var(--text);
    }

    .cab-tab {
      padding: 8px 16px;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid transparent;
      border-radius: 6px;
      color: var(--text-muted);
      cursor: pointer;
      font-size: 12px;
      font-weight: 500;
      transition: all 0.2s;
    }

    .cab-tab:hover {
      background: rgba(255, 255, 255, 0.1);
      color: var(--text);
    }

    .cab-tab.active {
      background: linear-gradient(135deg, var(--primary), #8b5cf6);
      color: white;
      border-color: var(--primary);
      font-weight: 600;
    }

    .cabinet-library-body {
      flex: 1;
      overflow-y: auto;
      padding: 20px;
    }

    .cabinet-search {
      margin-bottom: 16px;
    }

    .cabinet-search input {
      width: 100%;
      padding: 12px 16px;
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      border-radius: 8px;
      color: var(--text);
      font-size: 14px;
    }

    .cabinet-search input:focus {
      outline: none;
      border-color: var(--primary);
    }

    .cabinet-search input::placeholder {
      color: var(--text-muted);
    }

    .cabinet-library-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
      gap: 12px;
    }

    .cabinet-lib-item {
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 16px 12px;
      cursor: pointer;
      transition: all 0.2s;
      text-align: center;
    }

    .cabinet-lib-item:hover {
      border-color: var(--primary);
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(99, 102, 241, 0.2);
    }

    .cab-lib-icon {
      font-size: 32px;
      margin-bottom: 8px;
      opacity: 0.8;
    }

    .cab-lib-name {
      font-size: 13px;
      font-weight: 600;
      color: var(--text);
      margin-bottom: 4px;
    }

    .cab-lib-dims {
      font-size: 11px;
      color: var(--text-muted);
    }

    .cabinet-library-footer {
      padding: 16px 20px;
      border-top: 1px solid var(--border);
      background: var(--dark-elevated);
    }

    .custom-cabinet-form h4 {
      margin: 0 0 12px;
      font-size: 13px;
      color: var(--text-muted);
      text-transform: uppercase;
    }

    .custom-cab-inputs {
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .custom-cab-inputs input {
      width: 70px;
      padding: 10px 12px;
      background: var(--dark-surface);
      border: 1px solid var(--border);
      border-radius: 6px;
      color: var(--text);
      font-size: 14px;
      text-align: center;
    }

    .custom-cab-inputs input:focus {
      outline: none;
      border-color: var(--primary);
    }

    .custom-cab-inputs input::placeholder {
      color: var(--text-muted);
    }

    .custom-cab-inputs button {
      padding: 10px 20px;
      background: linear-gradient(135deg, var(--primary), #8b5cf6);
      border: none;
      border-radius: 6px;
      color: white;
      font-weight: 600;
      cursor: pointer;
      font-size: 13px;
      transition: all 0.2s;
      margin-left: auto;
    }

    .custom-cab-inputs button:hover {
      transform: scale(1.02);
    }

    /* =============================================
       v7.0 - Commercial Project Modal
       ============================================= */
    .commercial-project-modal {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.85);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10000;
      padding: 20px;
    }

    .commercial-project-content {
      background: var(--dark-surface);
      border: 1px solid var(--border);
      border-radius: 16px;
      width: 100%;
      max-width: 650px;
      max-height: 85vh;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }

    .commercial-project-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 16px 20px;
      border-bottom: 1px solid var(--border);
      background: var(--dark-elevated);
    }

    .commercial-project-header h3 {
      margin: 0;
      font-size: 18px;
    }

    .commercial-project-header > button {
      background: none;
      border: none;
      color: var(--text-muted);
      font-size: 24px;
      cursor: pointer;
      padding: 4px 8px;
      line-height: 1;
    }

    .commercial-project-header > button:hover {
      color: var(--text);
    }

    .commercial-project-body {
      padding: 20px;
      overflow-y: auto;
      flex: 1;
    }

    /* New Project Form */
    .new-project-form {
      max-width: 400px;
      margin: 0 auto;
    }

    .new-project-form h4 {
      margin: 0 0 20px;
      font-size: 16px;
      text-align: center;
      color: var(--text);
    }

    .new-project-form .form-group {
      margin-bottom: 16px;
    }

    .new-project-form .form-group label {
      display: block;
      font-size: 12px;
      color: var(--text-muted);
      margin-bottom: 6px;
      text-transform: uppercase;
    }

    .new-project-form .form-group input {
      width: 100%;
      padding: 12px 14px;
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      border-radius: 8px;
      color: var(--text);
      font-size: 14px;
    }

    .new-project-form .form-group input:focus {
      outline: none;
      border-color: var(--primary);
    }

    .new-project-form .form-group input::placeholder {
      color: var(--text-muted);
    }

    .new-project-form .btn-primary {
      width: 100%;
      margin-top: 8px;
    }

    /* Project Info */
    .project-info {
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 16px;
      margin-bottom: 20px;
    }

    .project-header-info {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
    }

    .project-header-info h4 {
      margin: 0;
      font-size: 16px;
      color: var(--primary);
    }

    .project-status {
      padding: 4px 10px;
      border-radius: 12px;
      font-size: 10px;
      font-weight: 700;
      text-transform: uppercase;
    }

    .project-status.draft {
      background: rgba(251, 191, 36, 0.2);
      color: #fbbf24;
    }

    .project-status.active {
      background: rgba(34, 197, 94, 0.2);
      color: #22c55e;
    }

    .project-status.completed {
      background: rgba(99, 102, 241, 0.2);
      color: #6366f1;
    }

    .project-info p {
      margin: 6px 0;
      font-size: 13px;
      color: var(--text-secondary);
    }

    .project-info p strong {
      color: var(--text);
    }

    /* Rooms Section */
    .rooms-section {
      margin-bottom: 20px;
    }

    .rooms-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
    }

    .rooms-header h4 {
      margin: 0;
      font-size: 13px;
      color: var(--text-muted);
      text-transform: uppercase;
    }

    .rooms-header button {
      padding: 6px 12px;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid var(--border);
      border-radius: 6px;
      color: var(--text-muted);
      font-size: 12px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .rooms-header button:hover {
      background: var(--primary);
      border-color: var(--primary);
      color: var(--dark-deep);
    }

    .rooms-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .no-rooms {
      text-align: center;
      color: var(--text-muted);
      font-size: 13px;
      padding: 20px;
      font-style: italic;
    }

    .room-item {
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 12px 14px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      cursor: pointer;
      transition: all 0.2s;
    }

    .room-item:hover {
      border-color: rgba(255, 255, 255, 0.2);
    }

    .room-item.active {
      border-color: var(--primary);
      background: rgba(99, 102, 241, 0.1);
    }

    .room-item-info {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .room-name {
      font-size: 14px;
      font-weight: 600;
      color: var(--text);
    }

    .room-meta {
      font-size: 11px;
      color: var(--text-muted);
    }

    .room-item-actions {
      display: flex;
      gap: 4px;
    }

    .room-item-actions button {
      width: 28px;
      height: 28px;
      background: rgba(255, 255, 255, 0.05);
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 12px;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .room-item-actions button:hover {
      background: rgba(255, 255, 255, 0.1);
    }

    /* Project Actions */
    .project-actions {
      display: flex;
      gap: 10px;
      padding-top: 16px;
      border-top: 1px solid var(--border);
    }

    .project-actions .btn-secondary {
      flex: 1;
      padding: 10px 16px;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid var(--border);
      border-radius: 8px;
      color: var(--text-muted);
      font-size: 12px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
    }

    .project-actions .btn-secondary:hover {
      background: rgba(255, 255, 255, 0.1);
      color: var(--text);
    }

    .project-actions .btn-primary {
      flex: 1.2;
      padding: 10px 16px;
      background: linear-gradient(135deg, var(--primary), #8b5cf6);
      border: none;
      border-radius: 8px;
      color: white;
      font-size: 12px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
    }

    .project-actions .btn-primary:hover {
      transform: scale(1.02);
    }

    /* =============================================
       v7.0 - PDF Import Modal
       ============================================= */
    .pdf-importer-modal {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.85);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10000;
      padding: 20px;
    }

    .pdf-importer-content {
      background: var(--dark-surface);
      border: 1px solid var(--border);
      border-radius: 16px;
      width: 100%;
      max-width: 550px;
      max-height: 85vh;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }

    .pdf-importer-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 16px 20px;
      border-bottom: 1px solid var(--border);
      background: var(--dark-elevated);
    }

    .pdf-importer-header h3 {
      margin: 0;
      font-size: 18px;
    }

    .pdf-importer-header > button {
      background: none;
      border: none;
      color: var(--text-muted);
      font-size: 24px;
      cursor: pointer;
      padding: 4px 8px;
      line-height: 1;
    }

    .pdf-importer-header > button:hover {
      color: var(--text);
    }

    .pdf-importer-body {
      padding: 20px;
      overflow-y: auto;
      flex: 1;
    }

    .import-dropzone {
      border: 2px dashed var(--border);
      border-radius: 12px;
      padding: 40px 20px;
      text-align: center;
      cursor: pointer;
      transition: all 0.2s;
      margin-bottom: 20px;
    }

    .import-dropzone:hover,
    .import-dropzone.dragover {
      border-color: var(--primary);
      background: rgba(99, 102, 241, 0.05);
    }

    .import-dropzone svg {
      color: var(--text-muted);
      margin-bottom: 12px;
    }

    .import-dropzone p {
      margin: 0 0 16px;
      font-size: 14px;
      color: var(--text-muted);
    }

    .import-dropzone button {
      padding: 10px 24px;
      background: linear-gradient(135deg, var(--primary), #8b5cf6);
      border: none;
      border-radius: 8px;
      color: white;
      font-weight: 600;
      cursor: pointer;
      font-size: 13px;
      transition: all 0.2s;
    }

    .import-dropzone button:hover {
      transform: scale(1.02);
    }

    .pdf-parse-results {
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 16px;
      margin-bottom: 20px;
    }

    .pdf-parse-results h4 {
      margin: 0 0 12px;
      font-size: 14px;
      color: var(--text);
    }

    .pdf-parse-results p {
      margin: 8px 0;
      font-size: 13px;
      color: var(--text-secondary);
    }

    .pdf-parse-results .btn-primary {
      margin-top: 12px;
      width: 100%;
      padding: 12px;
      background: linear-gradient(135deg, #8b5cf6, #6366f1);
      border: none;
      border-radius: 8px;
      color: white;
      font-weight: 600;
      cursor: pointer;
      font-size: 14px;
    }

    .pdf-parse-results .btn-primary:hover {
      transform: scale(1.01);
    }

    .manual-entry-section {
      border-top: 1px solid var(--border);
      padding-top: 20px;
    }

    .manual-entry-section h4 {
      margin: 0 0 8px;
      font-size: 14px;
      color: var(--text);
    }

    .manual-entry-section .help-text {
      margin: 0 0 12px;
      font-size: 12px;
      color: var(--text-muted);
    }

    .manual-entry-section textarea {
      width: 100%;
      padding: 12px;
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      border-radius: 8px;
      color: var(--text);
      font-size: 13px;
      font-family: monospace;
      resize: vertical;
      margin-bottom: 12px;
    }

    .manual-entry-section textarea:focus {
      outline: none;
      border-color: var(--primary);
    }

    .manual-entry-section textarea::placeholder {
      color: var(--text-muted);
    }

    .manual-entry-section button {
      width: 100%;
      padding: 12px;
      background: linear-gradient(135deg, var(--primary), #8b5cf6);
      border: none;
      border-radius: 8px;
      color: white;
      font-weight: 600;
      cursor: pointer;
      font-size: 13px;
    }

    .manual-entry-section button:hover {
      transform: scale(1.01);
    }

    /* =============================================
       v8.0 - Enhanced AI Analysis UI
       ============================================= */

    /* Animated spinner with pulse */
    .ai-spinner {
      width: 48px;
      height: 48px;
      border: 3px solid rgba(99, 102, 241, 0.2);
      border-top-color: var(--primary);
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin: 0 auto 16px;
    }

    .ai-spinner.success {
      border-color: rgba(34, 197, 94, 0.2);
      border-top-color: #22c55e;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    /* Pulse effect for processing */
    .ai-pulse {
      animation: pulse 2s ease-in-out infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    /* Progress bar */
    .ai-progress-bar {
      width: 100%;
      height: 6px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 3px;
      overflow: hidden;
      margin: 16px 0;
    }

    .ai-progress-fill {
      height: 100%;
      background: linear-gradient(90deg, var(--primary), #8b5cf6, #22c55e);
      background-size: 200% 100%;
      animation: progressShimmer 2s ease-in-out infinite;
      transition: width 0.3s ease;
    }

    @keyframes progressShimmer {
      0% { background-position: 200% 0; }
      100% { background-position: -200% 0; }
    }

    /* Enhanced cabinet cards */
    .cabinet-card {
      background: linear-gradient(145deg, rgba(255,255,255,0.05), rgba(255,255,255,0.02));
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 10px;
      padding: 12px;
      margin-bottom: 8px;
      transition: all 0.2s ease;
    }

    .cabinet-card:hover {
      border-color: rgba(99, 102, 241, 0.4);
      transform: translateX(4px);
      background: linear-gradient(145deg, rgba(99,102,241,0.1), rgba(99,102,241,0.05));
    }

    .cabinet-card .cab-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 6px;
    }

    .cabinet-card .cab-number {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      min-width: 28px;
      height: 28px;
      background: linear-gradient(135deg, var(--primary), #8b5cf6);
      border-radius: 6px;
      font-weight: 700;
      font-size: 12px;
      padding: 0 8px;
    }

    .cabinet-card .cab-type {
      font-size: 13px;
      font-weight: 500;
      color: var(--text);
    }

    .cabinet-card .cab-dims {
      font-size: 12px;
      color: var(--text-muted);
      font-family: 'SF Mono', Monaco, monospace;
    }

    .cabinet-card .cab-wall {
      font-size: 10px;
      padding: 2px 8px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 4px;
      color: var(--text-secondary);
    }

    /* Room preview card */
    .room-preview-card {
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      border-radius: 12px;
      overflow: hidden;
      margin-bottom: 12px;
      transition: all 0.2s ease;
    }

    .room-preview-card:hover {
      border-color: var(--primary);
      box-shadow: 0 4px 20px rgba(99, 102, 241, 0.15);
    }

    .room-preview-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 14px 16px;
      background: linear-gradient(135deg, rgba(99,102,241,0.1), rgba(139,92,246,0.1));
      border-bottom: 1px solid var(--border);
    }

    .room-preview-header h4 {
      margin: 0;
      font-size: 15px;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .room-preview-header .room-badge {
      font-size: 11px;
      padding: 3px 8px;
      background: rgba(34, 197, 94, 0.2);
      color: #22c55e;
      border-radius: 4px;
      font-weight: 500;
    }

    .room-preview-body {
      padding: 12px 16px;
      max-height: 200px;
      overflow-y: auto;
    }

    .room-preview-footer {
      padding: 12px 16px;
      border-top: 1px solid var(--border);
      display: flex;
      gap: 8px;
    }

    /* Enhanced buttons */
    .btn-ai-primary {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      padding: 12px 24px;
      background: linear-gradient(135deg, #22c55e, #16a34a);
      border: none;
      border-radius: 10px;
      color: white;
      font-weight: 600;
      font-size: 14px;
      cursor: pointer;
      transition: all 0.2s ease;
      width: 100%;
    }

    .btn-ai-primary:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(34, 197, 94, 0.35);
    }

    .btn-ai-primary:active {
      transform: translateY(0);
    }

    .btn-ai-primary:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }

    .btn-ai-secondary {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      padding: 10px 20px;
      background: transparent;
      border: 1px solid var(--border);
      border-radius: 8px;
      color: var(--text-secondary);
      font-weight: 500;
      font-size: 13px;
      cursor: pointer;
      transition: all 0.2s ease;
      flex: 1;
    }

    .btn-ai-secondary:hover {
      border-color: var(--primary);
      color: var(--text);
      background: rgba(99, 102, 241, 0.1);
    }

    /* Confidence badge */
    .confidence-badge {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 4px 10px;
      border-radius: 6px;
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
    }

    .confidence-badge.high {
      background: rgba(34, 197, 94, 0.15);
      color: #22c55e;
      border: 1px solid rgba(34, 197, 94, 0.3);
    }

    .confidence-badge.medium {
      background: rgba(249, 203, 0, 0.15);
      color: #f9cb00;
      border: 1px solid rgba(249, 203, 0, 0.3);
    }

    .confidence-badge.low {
      background: rgba(239, 68, 68, 0.15);
      color: #ef4444;
      border: 1px solid rgba(239, 68, 68, 0.3);
    }

    /* Stats grid */
    .ai-stats-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 12px;
      margin: 16px 0;
    }

    .ai-stat-card {
      background: rgba(255, 255, 255, 0.03);
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 10px;
      padding: 14px;
      text-align: center;
    }

    .ai-stat-value {
      font-size: 24px;
      font-weight: 700;
      background: linear-gradient(135deg, var(--primary), #22c55e);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .ai-stat-label {
      font-size: 11px;
      color: var(--text-muted);
      text-transform: uppercase;
      margin-top: 4px;
    }

    /* Page result list */
    .page-results-list {
      max-height: 120px;
      overflow-y: auto;
      margin-top: 12px;
      padding: 8px;
      background: rgba(0, 0, 0, 0.2);
      border-radius: 8px;
      font-family: 'SF Mono', Monaco, monospace;
      font-size: 11px;
    }

    .page-result {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 4px 0;
    }

    .page-result.success { color: #22c55e; }
    .page-result.warning { color: #f59e0b; }
    .page-result.error { color: #ef4444; }

    .page-result-icon {
      width: 16px;
      text-align: center;
    }

    /* Widen modal for better display */
    .pdf-importer-content {
      max-width: 650px;
    }

    /* =============================================
       v8.0 - Loading Skeletons & Utilities
       ============================================= */

    /* Skeleton loading animation */
    .skeleton {
      background: linear-gradient(90deg,
        rgba(255,255,255,0.05) 0%,
        rgba(255,255,255,0.1) 50%,
        rgba(255,255,255,0.05) 100%);
      background-size: 200% 100%;
      animation: skeletonShimmer 1.5s ease-in-out infinite;
      border-radius: 6px;
    }

    @keyframes skeletonShimmer {
      0% { background-position: 200% 0; }
      100% { background-position: -200% 0; }
    }

    .skeleton-text {
      height: 14px;
      margin-bottom: 8px;
    }

    .skeleton-text.short {
      width: 60%;
    }

    .skeleton-avatar {
      width: 40px;
      height: 40px;
      border-radius: 50%;
    }

    .skeleton-card {
      padding: 16px;
      border: 1px solid var(--border);
      border-radius: 10px;
    }

    /* Empty state styling */
    .empty-state {
      text-align: center;
      padding: 40px 20px;
      color: var(--text-muted);
    }

    .empty-state-icon {
      width: 64px;
      height: 64px;
      margin: 0 auto 16px;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .empty-state-icon svg {
      width: 32px;
      height: 32px;
      opacity: 0.5;
    }

    .empty-state-title {
      font-size: 16px;
      font-weight: 600;
      color: var(--text);
      margin-bottom: 8px;
    }

    .empty-state-text {
      font-size: 13px;
      line-height: 1.5;
      max-width: 280px;
      margin: 0 auto;
    }

    /* Tooltip styles */
    [data-tooltip] {
      position: relative;
    }

    [data-tooltip]::after {
      content: attr(data-tooltip);
      position: absolute;
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%) translateY(-4px);
      padding: 6px 10px;
      background: var(--dark-bg);
      border: 1px solid var(--border);
      border-radius: 6px;
      font-size: 11px;
      font-weight: 500;
      color: var(--text);
      white-space: nowrap;
      opacity: 0;
      visibility: hidden;
      transition: all 0.2s ease;
      z-index: 1000;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    }

    [data-tooltip]:hover::after {
      opacity: 1;
      visibility: visible;
      transform: translateX(-50%) translateY(-8px);
    }

    /* Status indicators */
    .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      display: inline-block;
    }

    .status-dot.online { background: #22c55e; box-shadow: 0 0 8px rgba(34, 197, 94, 0.5); }
    .status-dot.offline { background: #6b7280; }
    .status-dot.busy { background: #ef4444; box-shadow: 0 0 8px rgba(239, 68, 68, 0.5); }
    .status-dot.away { background: #f59e0b; box-shadow: 0 0 8px rgba(245, 158, 11, 0.5); }

    /* Badge component */
    .badge {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 3px 8px;
      border-radius: 6px;
      font-size: 11px;
      font-weight: 600;
    }

    .badge.primary { background: rgba(99, 102, 241, 0.2); color: var(--primary); }
    .badge.success { background: rgba(34, 197, 94, 0.2); color: #22c55e; }
    .badge.warning { background: rgba(249, 203, 0, 0.2); color: #f9cb00; }
    .badge.danger { background: rgba(239, 68, 68, 0.2); color: #ef4444; }
    .badge.neutral { background: rgba(255, 255, 255, 0.1); color: var(--text-muted); }

    /* =============================================
       v7.0 - Approval Workflow Modal
       ============================================= */
    .approval-modal {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.85);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10000;
      padding: 20px;
    }

    .approval-content {
      background: var(--dark-surface);
      border: 1px solid var(--border);
      border-radius: 16px;
      width: 100%;
      max-width: 550px;
    }

    .approval-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 20px 24px;
      border-bottom: 1px solid var(--border);
    }

    .approval-header h3 {
      margin: 0;
      font-size: 18px;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .approval-body {
      padding: 24px;
    }

    .approval-preview {
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 20px;
      margin-bottom: 20px;
      text-align: center;
    }

    .approval-preview h4 {
      margin: 0 0 12px;
      font-size: 16px;
    }

    .approval-preview-stats {
      display: flex;
      justify-content: center;
      gap: 24px;
      margin-top: 16px;
    }

    .approval-stat {
      text-align: center;
    }

    .approval-stat-value {
      font-size: 20px;
      font-weight: 700;
      color: var(--primary);
      display: block;
    }

    .approval-stat-label {
      font-size: 11px;
      color: var(--text-muted);
    }

    .recipient-input {
      margin-bottom: 20px;
    }

    .recipient-input label {
      display: block;
      font-size: 12px;
      color: var(--text-muted);
      text-transform: uppercase;
      margin-bottom: 8px;
    }

    .recipient-input input {
      width: 100%;
      padding: 14px 16px;
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      border-radius: 10px;
      color: var(--text);
      font-size: 15px;
    }

    .recipient-input input:focus {
      outline: none;
      border-color: var(--primary);
    }

    .approval-link-section {
      background: rgba(34, 197, 94, 0.1);
      border: 1px solid rgba(34, 197, 94, 0.3);
      border-radius: 12px;
      padding: 16px;
      margin-bottom: 20px;
      display: none;
    }

    .approval-link-section.show {
      display: block;
    }

    .approval-link-section h5 {
      margin: 0 0 12px;
      font-size: 13px;
      color: #22c55e;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .approval-link-box {
      display: flex;
      gap: 8px;
    }

    .approval-link-box input {
      flex: 1;
      padding: 10px 12px;
      background: var(--dark-surface);
      border: 1px solid var(--border);
      border-radius: 8px;
      color: var(--text);
      font-size: 12px;
      font-family: monospace;
    }

    .copy-link-btn {
      padding: 10px 16px;
      background: #22c55e;
      border: none;
      border-radius: 8px;
      color: white;
      font-weight: 600;
      cursor: pointer;
      font-size: 12px;
    }

    .approval-actions {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
    }

    .approval-actions button {
      padding: 14px 20px;
      border-radius: 10px;
      font-weight: 600;
      cursor: pointer;
      font-size: 14px;
      transition: all 0.2s;
    }

    .send-approval-btn {
      background: linear-gradient(135deg, var(--primary), #b8860b);
      border: none;
      color: var(--dark-deep);
    }

    .send-approval-btn:hover {
      transform: scale(1.02);
    }

    .cancel-approval-btn {
      background: transparent;
      border: 1px solid var(--border);
      color: var(--text-muted);
    }

    .cancel-approval-btn:hover {
      border-color: var(--text);
      color: var(--text);
    }

    /* Approval Status Badge */
    .approval-status-badge {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 12px;
      border-radius: 20px;
      font-size: 12px;
      font-weight: 600;
    }

    .approval-status-badge.pending {
      background: rgba(251, 191, 36, 0.2);
      color: #fbbf24;
    }

    .approval-status-badge.approved {
      background: rgba(34, 197, 94, 0.2);
      color: #22c55e;
    }

    .approval-status-badge.rejected {
      background: rgba(239, 68, 68, 0.2);
      color: #ef4444;
    }

    /* Commercial Project Approval Extras */
    .approval-summary {
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 20px;
      margin-bottom: 20px;
    }

    .approval-summary h4 {
      margin: 0 0 12px;
      font-size: 18px;
      color: var(--primary);
    }

    .approval-summary p {
      margin: 6px 0;
      font-size: 14px;
      color: var(--text-secondary);
    }

    .approval-summary p strong {
      color: var(--text);
    }

    .approval-options {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 12px;
      margin-top: 16px;
    }

    .approval-options label {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 13px;
      color: var(--text-secondary);
      cursor: pointer;
    }

    .approval-options input[type="checkbox"] {
      width: 16px;
      height: 16px;
      accent-color: var(--primary);
    }

    .approval-footer {
      display: flex;
      gap: 12px;
      justify-content: flex-end;
      padding: 20px 24px;
      border-top: 1px solid var(--border);
    }

    .approval-footer button {
      padding: 12px 24px;
      border-radius: 8px;
      font-weight: 600;
      cursor: pointer;
      font-size: 14px;
      transition: all 0.2s;
    }

    .approval-footer .btn-primary {
      background: linear-gradient(135deg, var(--primary), #b8860b);
      border: none;
      color: var(--dark-deep);
    }

    .approval-footer .btn-secondary {
      background: transparent;
      border: 1px solid var(--border);
      color: var(--text-muted);
    }

    .approval-footer .btn-primary:hover {
      transform: scale(1.02);
    }

    .approval-footer .btn-secondary:hover {
      border-color: var(--text);
      color: var(--text);
    }

    /* Demo Mode Banner */
    .demo-banner {
      background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
      padding: 10px 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 16px;
      flex-wrap: wrap;
      z-index: 1000;
    }

    .demo-banner-content {
      display: flex;
      align-items: center;
      gap: 16px;
      flex-wrap: wrap;
      justify-content: center;
    }

    .demo-banner-badge {
      background: rgba(255,255,255,0.2);
      padding: 4px 10px;
      border-radius: 12px;
      font-size: 11px;
      font-weight: 700;
      letter-spacing: 0.5px;
    }

    .demo-banner-text {
      font-size: 14px;
      font-weight: 500;
    }

    .demo-banner-cta {
      background: #fff;
      color: #6366f1;
      padding: 8px 20px;
      border-radius: 20px;
      text-decoration: none;
      font-weight: 600;
      font-size: 13px;
      transition: all 0.2s;
    }

    .demo-banner-cta:hover {
      transform: scale(1.05);
      box-shadow: 0 4px 15px rgba(0,0,0,0.2);
    }

    .demo-banner-link {
      color: rgba(255,255,255,0.9);
      text-decoration: none;
      font-size: 13px;
      font-weight: 500;
    }

    .demo-banner-link:hover {
      color: #fff;
      text-decoration: underline;
    }

    /* Demo mode upgrade modal */
    .demo-upgrade-modal {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.8);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 10000;
    }

    .demo-upgrade-modal.show {
      display: flex;
    }

    .demo-upgrade-content {
      background: var(--dark-surface);
      border-radius: 16px;
      padding: 40px;
      max-width: 480px;
      text-align: center;
      border: 1px solid var(--border);
      position: relative;
    }

    .demo-upgrade-close {
      position: absolute;
      top: 16px;
      right: 16px;
      background: none;
      border: none;
      color: var(--text-secondary);
      font-size: 24px;
      cursor: pointer;
    }

    .demo-upgrade-icon {
      font-size: 48px;
      margin-bottom: 16px;
    }

    .demo-upgrade-content h2 {
      font-size: 24px;
      margin-bottom: 12px;
    }

    .demo-upgrade-content p {
      color: var(--text-secondary);
      margin-bottom: 24px;
      line-height: 1.6;
    }

    .demo-upgrade-features {
      text-align: left;
      margin-bottom: 24px;
    }

    .demo-upgrade-feature {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 10px 0;
      border-bottom: 1px solid var(--border);
      font-size: 14px;
    }

    .demo-upgrade-feature:last-child {
      border-bottom: none;
    }

    .demo-upgrade-actions {
      display: flex;
      gap: 12px;
      justify-content: center;
    }

    @media (max-width: 768px) {
      .demo-banner {
        padding: 8px 12px;
      }
      .demo-banner-text {
        display: none;
      }
    }

    /* Demo mode layout adjustments - when banner is visible */
    .demo-banner:not([style*="display: none"]) ~ .header ~ .main {
      max-height: calc(100vh - 56px - 48px); /* Account for demo banner (~48px) */
    }

    /* Ensure right panel sections can grow/shrink properly */
    .right-panel .panel-section#itemPickerSection {
      display: flex;
      flex-direction: column;
      min-height: 0;
      flex: 1 1 auto;
    }

    .right-panel .panel-section#itemPickerSection .item-picker-list {
      flex: 1 1 auto;
      min-height: 100px;
      max-height: none;
    }

    .right-panel .panel-section#propertiesPanel {
      flex-shrink: 1;
      overflow-y: auto;
      max-height: 350px;
    }

    /* Collapsible message section shouldn't break layout */
    .right-panel .panel-section#teamChatSection {
      flex-shrink: 0;
      max-height: 300px;
      overflow: hidden;
    }

    .right-panel .panel-section#teamChatSection:not(.collapsed) {
      overflow-y: auto;
    }

    .right-panel .panel-section#teamChatSection #teamChatMessages {
      max-height: 150px;
      overflow-y: auto;
    }
  </style>
</head>
<body>
  <!-- Minimal Loading Screen -->
  <div class="cloud-preloader" id="cloudPreloader">
    <!-- Main Content -->
    <div class="preloader-content">
      <div class="preloader-company" id="preloaderCompanyMain">Surprise Granite</div>
      <div class="preloader-tagline">Room Designer</div>
      <div class="preloader-loading">
        <div class="preloader-bar">
          <div class="preloader-bar-fill" id="preloaderProgressBar"></div>
        </div>
      </div>
    </div>

    <!-- Powered By -->
    <div class="preloader-powered">
      <div class="preloader-powered-icon">
        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" fill="none">
          <defs>
            <linearGradient id="remodelyGradient" x1="0%" y1="0%" x2="100%" y2="100%">
              <stop offset="0%" style="stop-color:#6366f1"/>
              <stop offset="100%" style="stop-color:#8b5cf6"/>
            </linearGradient>
          </defs>
          <path d="M3 21V10l9-7 9 7v11" stroke="url(#remodelyGradient)" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"/>
          <path d="M21 21h-7" stroke="#8b5cf6" stroke-width="2.5" stroke-linecap="round"/>
        </svg>
      </div>
      <div class="preloader-powered-text">Powered by <span class="preloader-powered-brand">Remodely.ai</span></div>
    </div>
  </div>
  <div class="app">
    <!-- Demo Mode Banner (hidden by default, shown via ?demo=true) -->
    <div class="demo-banner" id="demoBanner" style="display: none;">
      <div class="demo-banner-content">
        <span class="demo-banner-badge">DEMO</span>
        <span class="demo-banner-text">You're viewing Room Designer Pro in demo mode</span>
        <a href="https://remodely.ai/" class="demo-banner-cta" target="_blank">Get Full Access</a>
        <a href="https://remodely.ai/" class="demo-banner-link" target="_blank">Learn More</a>
      </div>
    </div>
    <!-- Header -->
    <header class="header">
      <div class="header-left">
        <div class="logo-group" id="logoGroup">
          <a href="/" class="logo" id="mainLogo">
            <img src="https://cdn.prod.website-files.com/6456ce4476abb25581fbad0c/6456ce4476abb269c6fbb176_Surprise-Granite-favicon-32x32px.png" alt="Surprise Granite" id="logoImg">
          </a>
        </div>
        <input type="text" class="project-input" id="projectName" value="Untitled Project" placeholder="Project name">
      </div>

      <div class="header-center">
        <button class="view-btn active" id="view2D" onclick="setView('2d')">2D Plan</button>
        <button class="view-btn" id="view3D" onclick="setView('3d')">3D View</button>
        <div class="header-zoom-controls">
          <button class="header-zoom-btn" onclick="zoomOut()" title="Zoom Out (-)"></button>
          <span class="header-zoom-level" id="zoomLevel" onclick="resetZoom()" title="Click to reset to 100%">100%</span>
          <button class="header-zoom-btn" onclick="zoomIn()" title="Zoom In (+)">+</button>
        </div>
      </div>

      <div class="header-right">
        <!-- Messaging Hub -->
        <div class="messaging-hub" id="messagingHub">
          <button class="messaging-hub-btn" id="msgHubBtn" onclick="toggleMessagingPanel()" title="Messages">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"/>
            </svg>
            <span class="msg-badge hidden" id="msgBadge">0</span>
          </button>
        </div>

        <!-- Gaming-Style Notification Hub -->
        <div class="notification-hub" id="notificationHub">
          <button class="notification-hub-btn" id="notifHubBtn" onclick="toggleNotificationHub()" title="Notifications">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M18 8A6 6 0 0 0 6 8c0 7-3 9-3 9h18s-3-2-3-9"/>
              <path d="M13.73 21a2 2 0 0 1-3.46 0"/>
            </svg>
            <span class="hub-badge hidden" id="hubBadge">0</span>
          </button>
          <div class="notification-dropdown" id="notificationDropdown">
            <div class="notification-dropdown-header">
              <div class="notification-dropdown-title">
                <span></span> Activity
              </div>
              <div style="display: flex; gap: 8px;">
                <button class="mark-all-read" onclick="markAllNotificationsRead()">Mark read</button>
                <button class="mark-all-read" onclick="clearAllNotifications()" style="color: #ef4444;">Clear all</button>
              </div>
            </div>
            <div class="notification-tabs">
              <button class="notification-tab active" data-filter="all" onclick="filterNotifications('all')">
                All <span class="tab-count" id="tabCountAll">0</span>
              </button>
              <button class="notification-tab" data-filter="chat" onclick="filterNotifications('chat')">
                 Clients <span class="tab-count" id="tabCountChat">0</span>
              </button>
              <button class="notification-tab" data-filter="team" onclick="filterNotifications('team')">
                 Team <span class="tab-count" id="tabCountTeam">0</span>
              </button>
            </div>
            <div class="notification-list" id="notificationList">
              <div class="notification-empty">
                <div class="notification-empty-icon"></div>
                <div class="notification-empty-text">No notifications yet</div>
                <div class="notification-empty-subtext">Messages from clients and team will appear here</div>
              </div>
            </div>
            <div class="notification-prefs">
              <button class="notif-pref-btn active" id="toggleSoundNotif" onclick="toggleNotificationPref('sound')" title="Sound notifications">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="14" height="14">
                  <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/>
                  <path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"/>
                </svg>
                Sound
              </button>
              <button class="notif-pref-btn" id="toggleDesktopNotif" onclick="toggleNotificationPref('desktop')" title="Desktop notifications">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="14" height="14">
                  <rect x="2" y="3" width="20" height="14" rx="2" ry="2"/>
                  <line x1="8" y1="21" x2="16" y2="21"/>
                  <line x1="12" y1="17" x2="12" y2="21"/>
                </svg>
                Desktop
              </button>
            </div>
            <div class="notification-footer">
              <button class="view-all-btn" onclick="openFullInbox()">View Full Inbox</button>
            </div>
          </div>
        </div>

        <!-- User Account Menu -->
        <div class="user-account-menu" id="userAccountMenu">
          <button class="user-menu-btn" id="userMenuBtn" onclick="toggleUserMenu()">
            <div class="user-avatar-small" id="userAvatarSmall">?</div>
            <span class="user-name-display" id="userNameDisplay">Sign In</span>
            <svg width="10" height="10" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <polyline points="6 9 12 15 18 9"/>
            </svg>
          </button>
          <div class="user-dropdown" id="userDropdown">
            <!-- Logged out state -->
            <div id="loggedOutMenu">
              <button class="dropdown-item google-signin" onclick="handleGoogleSignIn()">
                <svg width="16" height="16" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                  <path fill="#4285F4" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"/>
                  <path fill="#34A853" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/>
                  <path fill="#FBBC05" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/>
                  <path fill="#EA4335" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/>
                </svg>
                Sign in with Google
              </button>
              <button class="dropdown-item" onclick="showLoginPrompt('Sign in to save and share your designs')">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M15 3h4a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2h-4"/>
                  <polyline points="10 17 15 12 10 7"/>
                  <line x1="15" y1="12" x2="3" y2="12"/>
                </svg>
                Sign In with Email
              </button>
              <button class="dropdown-item" onclick="continueAsGuest(); closeUserMenu();">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"/>
                  <circle cx="12" cy="7" r="4"/>
                </svg>
                Continue as Guest
              </button>
            </div>
            <!-- Logged in state -->
            <div id="loggedInMenu" style="display: none;">
              <a href="/account/" class="dropdown-item">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"/>
                  <circle cx="12" cy="7" r="4"/>
                </svg>
                My Account
              </a>
              <a href="/account/?page=my-designs" class="dropdown-item">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>
                  <line x1="3" y1="9" x2="21" y2="9"/>
                  <line x1="9" y1="21" x2="9" y2="9"/>
                </svg>
                My Designs
              </a>
              <a href="/account/?page=tools" class="dropdown-item">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M14.7 6.3a1 1 0 0 0 0 1.4l1.6 1.6a1 1 0 0 0 1.4 0l3.77-3.77a6 6 0 0 1-7.94 7.94l-6.91 6.91a2.12 2.12 0 0 1-3-3l6.91-6.91a6 6 0 0 1 7.94-7.94l-3.76 3.76z"/>
                </svg>
                All Tools
              </a>
              <button id="manageSubscriptionBtn" class="dropdown-item" onclick="openBillingPortal()" style="display: none;">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <rect x="1" y="4" width="22" height="16" rx="2" ry="2"/>
                  <line x1="1" y1="10" x2="23" y2="10"/>
                </svg>
                Manage Subscription
              </button>
              <div class="dropdown-divider"></div>
              <button class="dropdown-item logout-item" onclick="handleLogout()">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4"/>
                  <polyline points="16 17 21 12 16 7"/>
                  <line x1="21" y1="12" x2="9" y2="12"/>
                </svg>
                Sign Out
              </button>
            </div>
          </div>
        </div>

        <!-- Create New Button -->
        <button class="btn btn-secondary" onclick="createNewDesign()" title="Create New Design">
          <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
            <polyline points="14 2 14 8 20 8"/>
            <line x1="12" y1="18" x2="12" y2="12"/>
            <line x1="9" y1="15" x2="15" y2="15"/>
          </svg>
          New
        </button>

        <!-- Save Design Button -->
        <button class="btn btn-primary" id="saveDesignBtn" onclick="saveDesignToCloud()" style="background: #10B981; border-color: #10B981;">
          <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M19 21H5a2 2 0 01-2-2V5a2 2 0 012-2h11l5 5v11a2 2 0 01-2 2z"/>
            <polyline points="17 21 17 13 7 13 7 21"/>
            <polyline points="7 3 7 8 15 8"/>
          </svg>
          <span id="saveDesignText">Save</span>
        </button>

        <button class="btn btn-secondary" onclick="openMyDesignsModal()">
          <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M3 7v10a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-6l-2-2H5a2 2 0 00-2 2z"/>
          </svg>
          My Designs
        </button>

        <button class="btn btn-secondary" onclick="openShareModal()">
          <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M4 12v8a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-8"/>
            <polyline points="16,6 12,2 8,6"/>
            <line x1="12" y1="2" x2="12" y2="15"/>
          </svg>
          Share
        </button>

        <!-- Pro Tools Dropdown -->
        <div class="export-dropdown pro-tools-dropdown">
          <button class="btn btn-secondary" onclick="toggleProToolsMenu()" style="background: linear-gradient(135deg, #8b5cf6, #6366f1); border-color: #8b5cf6; color: white;">
            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"/>
            </svg>
            Pro Tools
            <svg width="10" height="10" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="margin-left: 4px;">
              <polyline points="6 9 12 15 18 9"/>
            </svg>
          </button>
          <div class="export-menu" id="proToolsMenu" style="min-width: 200px;">
            <button onclick="showCommercialProjectManager(); closeProToolsMenu();">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <rect x="2" y="7" width="20" height="14" rx="2"/>
                <path d="M16 21V5a2 2 0 0 0-2-2h-4a2 2 0 0 0-2 2v16"/>
              </svg>
              Commercial Projects
            </button>
            <button onclick="showAIImporter(); closeProToolsMenu();">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
                <polyline points="14 2 14 8 20 8"/>
                <line x1="12" y1="18" x2="12" y2="12"/>
                <line x1="9" y1="15" x2="15" y2="15"/>
              </svg>
              Import Image/Scan
            </button>
            <button onclick="toggleAIChatDesigner(); closeProToolsMenu();" style="background: linear-gradient(135deg, rgba(99, 102, 241, 0.15), rgba(139, 92, 246, 0.15));">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"/>
                <circle cx="12" cy="10" r="1" fill="currentColor"/>
                <circle cx="8" cy="10" r="1" fill="currentColor"/>
                <circle cx="16" cy="10" r="1" fill="currentColor"/>
              </svg>
              <span style="background: linear-gradient(135deg, #6366f1, #8b5cf6); -webkit-background-clip: text; -webkit-text-fill-color: transparent; font-weight: 600;">AI Designer Chat</span>
              <span style="font-size: 9px; background: linear-gradient(135deg, #6366f1, #8b5cf6); color: white; padding: 2px 6px; border-radius: 4px; margin-left: 6px;">NEW</span>
            </button>
            <div class="dropdown-divider"></div>
            <button onclick="showApprovalWorkflow(); closeProToolsMenu();">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/>
                <polyline points="22 4 12 14.01 9 11.01"/>
              </svg>
              Send for Approval
            </button>
          </div>
        </div>

        <div class="export-dropdown">
          <button class="btn btn-secondary" onclick="toggleExportMenu()">
            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
              <polyline points="7 10 12 15 17 10"/>
              <line x1="12" y1="15" x2="12" y2="3"/>
            </svg>
            Export
            <svg width="10" height="10" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="margin-left: 4px;">
              <polyline points="6 9 12 15 18 9"/>
            </svg>
          </button>
          <div class="export-menu" id="exportMenu">
            <button onclick="exportToPDF()">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
                <polyline points="14,2 14,8 20,8"/>
                <line x1="16" y1="13" x2="8" y2="13"/>
                <line x1="16" y1="17" x2="8" y2="17"/>
              </svg>
              PDF Proposal
            </button>
            <button onclick="exportToJSON()">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
                <polyline points="14,2 14,8 20,8"/>
                <line x1="9" y1="15" x2="15" y2="15"/>
              </svg>
              Save Design (JSON)
            </button>
            <button onclick="exportToPNG()">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>
                <circle cx="8.5" cy="8.5" r="1.5"/>
                <polyline points="21,15 16,10 5,21"/>
              </svg>
              Export Image (PNG)
            </button>
            <button onclick="exportToCSV()">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
                <polyline points="14,2 14,8 20,8"/>
                <line x1="8" y1="13" x2="16" y2="13"/>
                <line x1="8" y1="17" x2="16" y2="17"/>
                <line x1="12" y1="9" x2="12" y2="21"/>
              </svg>
              Parts List (CSV)
            </button>
            <div class="export-divider"></div>
            <button onclick="importFromJSON()">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                <polyline points="17 8 12 3 7 8"/>
                <line x1="12" y1="3" x2="12" y2="15"/>
              </svg>
              Load Design (JSON)
            </button>
          </div>
        </div>

        <button class="btn btn-primary" onclick="generateTakeoffReport()">
          <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2"/>
            <rect x="9" y="3" width="6" height="4" rx="1"/>
            <path d="M9 12h6M9 16h6"/>
          </svg>
          Get Takeoffs
        </button>
      </div>
    </header>

    <!-- Main Content -->
    <main class="main">
      <!-- Left Sidebar -->
      <aside class="sidebar" id="leftSidebar">
        <!-- Multi-Room Manager -->
        <div class="sidebar-section" data-tutorial="rooms">
          <div class="sidebar-header" onclick="toggleSection(this)">
            <span class="sidebar-title">Rooms</span>
            <span class="sidebar-toggle"></span>
          </div>
          <div class="sidebar-content">
            <div id="roomList" class="room-list">
              <!-- Room list will be rendered here -->
            </div>
            <button class="btn btn-primary btn-sm" onclick="showAddRoomModal()" style="width: 100%; margin-top: 8px;">
              + Add Room
            </button>
            <div style="margin-top: 8px; display: flex; gap: 4px;">
              <button class="btn btn-secondary btn-sm" onclick="viewAllRooms3D()" style="flex: 1; font-size: 10px;" title="View all rooms in 3D">
                 View All
              </button>
              <button class="btn btn-secondary btn-sm" onclick="exportMultiRoomLayout()" style="flex: 1; font-size: 10px;" title="Export layout">
                 Export
              </button>
            </div>
          </div>
        </div>

        <!-- Quick Favorites -->
        <div class="sidebar-section" id="favoritesSection">
          <div class="sidebar-header" onclick="toggleSection(this)" title="Your favorite elements and materials">
            <span class="sidebar-title"> Favorites</span>
            <span class="sidebar-toggle"></span>
          </div>
          <div class="sidebar-content">
            <div id="favoritesList" class="favorites-grid">
              <div class="favorites-empty" id="favoritesEmpty">
                <span style="font-size: 20px;"></span>
                <span>No favorites yet</span>
                <span style="font-size: 10px; color: var(--text-muted);">Right-click elements to add</span>
              </div>
            </div>
            <div class="favorites-actions" style="display: none;" id="favoritesActions">
              <button class="btn btn-secondary btn-sm" onclick="clearFavorites()" style="width: 100%; font-size: 10px;">
                Clear All
              </button>
            </div>
          </div>
        </div>

        <!-- Design Notes -->
        <div class="sidebar-section" id="notesSection">
          <div class="sidebar-header" onclick="toggleSection(this)" title="Add notes and annotations">
            <span class="sidebar-title"> Notes</span>
            <span class="sidebar-toggle"></span>
          </div>
          <div class="sidebar-content">
            <div id="notesList" class="notes-list">
              <div class="notes-empty" id="notesEmpty">
                <span style="font-size: 20px;"></span>
                <span>No notes yet</span>
                <span style="font-size: 10px; color: var(--text-muted);">Click canvas to add a note</span>
              </div>
            </div>
            <button class="btn btn-primary btn-sm" onclick="enableNoteMode()" id="addNoteBtn" style="width: 100%; margin-top: 8px;">
              + Add Note
            </button>
          </div>
        </div>

        <!-- Floor Plans -->
        <div class="sidebar-section">
          <div class="sidebar-header" onclick="toggleSection(this)" title="Choose a room layout">
            <span class="sidebar-title">Floor Plans</span>
            <span class="sidebar-toggle"></span>
          </div>
          <div class="sidebar-content">
            <div class="floorplan-grid" id="floorplanGrid">
              <!-- Floor plans will be rendered here -->
            </div>
          </div>
        </div>

        <!-- Tools -->
        <div class="sidebar-section" id="toolsSection">
          <div class="sidebar-header" onclick="toggleSection(this)" title="Draw & edit tools">
            <span class="sidebar-title">Tools</span>
            <span class="sidebar-toggle"></span>
          </div>
          <div class="sidebar-content">
            <div class="tool-grid" role="toolbar" aria-label="Design tools">
              <button class="tool-btn active" id="toolSelect" onclick="setTool('select')" title="Select (V)" data-shortcut="V" aria-label="Select tool, keyboard shortcut V" aria-pressed="true">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
                  <path d="M3 3l7.07 16.97 2.51-7.39 7.39-2.51L3 3z"/>
                </svg>
                <span>Select</span>
              </button>
              <button class="tool-btn" id="toolWall" onclick="setTool('wall')" title="Draw Wall (W)" data-shortcut="W" aria-label="Draw wall tool, keyboard shortcut W" aria-pressed="false">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
                  <rect x="3" y="3" width="18" height="18" rx="2"/>
                </svg>
                <span>Wall</span>
              </button>
              <button class="tool-btn" id="toolCountertop" onclick="setTool('countertop')" title="Draw Countertop (C)" data-shortcut="C" aria-label="Draw countertop tool, keyboard shortcut C" aria-pressed="false">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
                  <rect x="2" y="8" width="20" height="4" rx="1"/>
                  <rect x="4" y="12" width="16" height="8" fill="none"/>
                </svg>
                <span>Counter</span>
              </button>
              <button class="tool-btn" id="toolPan" onclick="setTool('pan')" title="Pan (H)" data-shortcut="H" aria-label="Pan and scroll tool, keyboard shortcut H" aria-pressed="false">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
                  <path d="M18 11V6a2 2 0 0 0-2-2a2 2 0 0 0-2 2"/>
                  <path d="M14 10V4a2 2 0 0 0-2-2a2 2 0 0 0-2 2v2"/>
                  <path d="M10 10.5V6a2 2 0 0 0-2-2a2 2 0 0 0-2 2v8"/>
                  <path d="M18 8a2 2 0 1 1 4 0v6a8 8 0 0 1-8 8h-2c-2.8 0-4.5-.86-5.99-2.34l-3.6-3.6a2 2 0 0 1 2.83-2.82L7 15"/>
                </svg>
                <span>Pan</span>
              </button>
              <button class="tool-btn" id="toolMeasure" onclick="setTool('measure')" title="Measure (M)" data-shortcut="M" aria-label="Measure distance tool, keyboard shortcut M" aria-pressed="false">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
                  <path d="M21.3 8.7 8.7 21.3c-1 1-2.5 1-3.4 0l-2.6-2.6c-1-1-1-2.5 0-3.4L15.3 2.7c1-1 2.5-1 3.4 0l2.6 2.6c1 1 1 2.5 0 3.4Z"/>
                </svg>
                <span>Measure</span>
              </button>
              <button class="tool-btn" id="toolAutoCounter" onclick="generateCountertopsOverCabinets()" title="Auto-generate countertops over base cabinets" data-shortcut="T" aria-label="Auto-generate countertops over cabinets, keyboard shortcut T">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
                  <rect x="2" y="6" width="20" height="3" rx="1" fill="currentColor" opacity="0.3"/>
                  <rect x="4" y="9" width="16" height="10" rx="1"/>
                  <path d="M12 2v4M8 4l4-2 4 2"/>
                </svg>
                <span>Auto Top</span>
              </button>
              <button class="tool-btn" id="toolAlign" onclick="showAlignMenu()" title="Align selected elements" data-shortcut="A" aria-label="Align selected elements, keyboard shortcut A" aria-haspopup="true">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
                  <line x1="4" y1="6" x2="20" y2="6"/>
                  <line x1="4" y1="12" x2="20" y2="12"/>
                  <line x1="4" y1="18" x2="20" y2="18"/>
                  <rect x="8" y="4" width="8" height="4" fill="currentColor" opacity="0.3"/>
                  <rect x="6" y="10" width="12" height="4" fill="currentColor" opacity="0.3"/>
                </svg>
                <span>Align</span>
              </button>
              <button class="tool-btn" id="toolLayout" onclick="setTool('layout')" title="Cabinet Layout (L) - Click and drag to create cabinet runs" data-shortcut="L" aria-label="Cabinet layout tool, keyboard shortcut L" aria-pressed="false">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <rect x="2" y="14" width="6" height="8" rx="1"/>
                  <rect x="9" y="14" width="6" height="8" rx="1"/>
                  <rect x="16" y="14" width="6" height="8" rx="1"/>
                  <rect x="2" y="12" width="20" height="2" fill="currentColor" opacity="0.4"/>
                  <path d="M4 10 L12 4 L20 10" stroke-width="1.5"/>
                </svg>
                <span>Layout</span>
              </button>
              <button class="tool-btn" id="toolSlabLayout" onclick="window.SlabLayout && window.SlabLayout.toggle()" title="Slab Layout (S) - Optimize stone slab cutting" data-shortcut="S" aria-label="Slab layout and optimization tool, keyboard shortcut S" aria-pressed="false" style="background: linear-gradient(135deg, #00d4aa 0%, #00b894 100%);">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <rect x="2" y="3" width="20" height="14" rx="1"/>
                  <line x1="8" y1="3" x2="8" y2="17"/>
                  <line x1="14" y1="3" x2="14" y2="17"/>
                  <line x1="2" y1="10" x2="14" y2="10"/>
                  <path d="M16 20h4M18 18v4" stroke-width="1.5" opacity="0.7"/>
                </svg>
                <span>Slab</span>
              </button>
            </div>
          </div>
        </div>

        <!-- Layout Tool Options (shown when layout tool is active) -->
        <div class="layout-options-panel" id="layoutOptionsPanel" style="display: none;">
          <div class="layout-options-header">
            <span> Layout Brush Options</span>
          </div>
          <div class="layout-options-content">
            <div class="layout-option-row">
              <label>Element Type:</label>
              <select id="layoutElementType" onchange="updateLayoutElementType()">
                <optgroup label="Base Cabinets (34.5&quot;H  24&quot;D)">
                  <option value="base-cabinet" selected>Base Cabinet</option>
                  <option value="drawer-base">Drawer Base (4 drawers)</option>
                  <option value="sink-base">Sink Base (false front)</option>
                  <option value="corner-cabinet">Corner Base (36&quot; sq)</option>
                  <option value="lazy-susan">Lazy Susan Corner</option>
                  <option value="blind-corner">Blind Corner Base</option>
                </optgroup>
                <optgroup label="Wall Cabinets (30&quot;H  12&quot;D)">
                  <option value="wall-cabinet">Wall Cabinet</option>
                  <option value="wall-corner">Corner Wall (diagonal)</option>
                </optgroup>
                <optgroup label="Tall Cabinets (84-96&quot;H  24&quot;D)">
                  <option value="tall-cabinet">Tall Pantry</option>
                  <option value="tall-oven">Tall Oven Cabinet</option>
                  <option value="fridge-cabinet">Refrigerator Surround</option>
                </optgroup>
                <optgroup label="Islands &amp; Peninsulas">
                  <option value="island">Kitchen Island</option>
                </optgroup>
                <optgroup label="Walls">
                  <option value="pony-wall">Pony Wall (42&quot;)</option>
                  <option value="pony-wall-bar">Bar Height Wall (42&quot;)</option>
                  <option value="knee-wall">Knee Wall (30&quot;)</option>
                  <option value="wall">Full Wall</option>
                </optgroup>
                <optgroup label="Surfaces">
                  <option value="countertop">Countertop Run</option>
                  <option value="countertop-corner">Corner Countertop</option>
                  <option value="backsplash">Backsplash</option>
                </optgroup>
              </select>
            </div>
            <div class="layout-option-row">
              <label>Depth:</label>
              <select id="layoutDepth" onchange="updateLayoutDepth()">
                <option value="1">12" (Wall Cab)</option>
                <option value="1.5">18"</option>
                <option value="2" selected>24" (Base Cab)</option>
                <option value="2.5">30"</option>
                <option value="3">36" (Island)</option>
              </select>
            </div>
            <div class="layout-option-row">
              <label>Corner Treatment:</label>
              <select id="layoutCornerType" onchange="updateLayoutCornerType()">
                <option value="corner-cabinet" selected>Corner Cabinet (36")</option>
                <option value="lazy-susan">Lazy Susan (36")</option>
                <option value="blind-corner">Blind Corner</option>
                <option value="filler">Filler Space</option>
                <option value="none">No Corner (overlap)</option>
              </select>
            </div>
            <div class="layout-option-row">
              <label>
                <input type="checkbox" id="layoutAddCountertop" onchange="updateLayoutCountertop()">
                Auto-add countertop
              </label>
            </div>
            <div class="layout-option-row">
              <label>
                <input type="checkbox" id="layoutSnapToWalls" checked onchange="updateLayoutWallSnap()">
                Snap to walls
              </label>
            </div>
            <div class="layout-option-row">
              <label>
                <input type="checkbox" id="layoutBothLevels" checked onchange="updateLayoutBothLevels()">
                Draw Upper + Lower Together
              </label>
            </div>
            <div class="layout-option-hint">
              Click & drag to draw runs  Turn creates corners
            </div>
          </div>
        </div>

        <!-- Cabinets -->
        <div class="sidebar-section">
          <div class="sidebar-header" onclick="toggleSection(this)" title="Add cabinets">
            <span class="sidebar-title">Cabinets</span>
            <span class="sidebar-toggle"></span>
          </div>
          <div class="sidebar-content">
            <div class="element-grid" id="cabinetsGrid">
              <!-- Elements rendered by JS -->
            </div>
          </div>
        </div>

        <!-- Surfaces -->
        <div class="sidebar-section">
          <div class="sidebar-header" onclick="toggleSection(this)" title="Countertops & flooring">
            <span class="sidebar-title">Surfaces</span>
            <span class="sidebar-toggle"></span>
          </div>
          <div class="sidebar-content">
            <div style="display: flex; gap: 4px; margin-bottom: 8px;">
              <button class="quick-btn" style="flex: 1; font-size: 10px; padding: 4px 6px;" onclick="fillRoomWithFlooring()" title="Fill entire room with flooring">
                Fill Floor
              </button>
              <button class="quick-btn" style="flex: 1; font-size: 10px; padding: 4px 6px;" onclick="generateCountertopsOverCabinets()" title="Auto-generate countertops over base cabinets">
                Auto Counter
              </button>
            </div>
            <div class="element-grid" id="surfacesGrid">
              <!-- Elements rendered by JS -->
            </div>
          </div>
        </div>

        <!-- Appliances -->
        <div class="sidebar-section">
          <div class="sidebar-header" onclick="toggleSection(this)" title="Sinks, stoves & more">
            <span class="sidebar-title">Appliances</span>
            <span class="sidebar-toggle"></span>
          </div>
          <div class="sidebar-content">
            <div class="element-grid" id="appliancesGrid">
              <!-- Elements rendered by JS -->
            </div>
          </div>
        </div>

        <!-- Structure -->
        <div class="sidebar-section">
          <div class="sidebar-header" onclick="toggleSection(this)" title="Doors, windows & walls">
            <span class="sidebar-title">Structure</span>
            <span class="sidebar-toggle"></span>
          </div>
          <div class="sidebar-content">
            <div class="element-grid" id="structureGrid">
              <!-- Elements rendered by JS -->
            </div>
          </div>
        </div>

        <!-- Bathroom Fixtures (collapsed by default) -->
        <div class="sidebar-section">
          <div class="sidebar-header" onclick="toggleSection(this)" title="Toilets, tubs, vanities & showers">
            <span class="sidebar-title">Bathroom</span>
            <span class="sidebar-toggle"></span>
          </div>
          <div class="sidebar-content collapsed">
            <div class="element-grid" id="bathroomGrid">
              <!-- Elements rendered by JS -->
            </div>
          </div>
        </div>

        <!-- Laundry (collapsed by default) -->
        <div class="sidebar-section">
          <div class="sidebar-header" onclick="toggleSection(this)" title="Washer, dryer & laundry items">
            <span class="sidebar-title">Laundry</span>
            <span class="sidebar-toggle"></span>
          </div>
          <div class="sidebar-content collapsed">
            <div class="element-grid" id="laundryGrid">
              <!-- Elements rendered by JS -->
            </div>
          </div>
        </div>

        <!-- Closet (collapsed by default) -->
        <div class="sidebar-section">
          <div class="sidebar-header" onclick="toggleSection(this)" title="Closet organization & storage">
            <span class="sidebar-title">Closet</span>
            <span class="sidebar-toggle"></span>
          </div>
          <div class="sidebar-content collapsed">
            <div class="element-grid" id="closetGrid">
              <!-- Elements rendered by JS -->
            </div>
          </div>
        </div>

        <!-- Electrical (collapsed by default) -->
        <div class="sidebar-section">
          <div class="sidebar-header" onclick="toggleSection(this)" title="Electrical, lighting & HVAC">
            <span class="sidebar-title">Electrical & HVAC</span>
            <span class="sidebar-toggle"></span>
          </div>
          <div class="sidebar-content collapsed">
            <div class="element-grid" id="electricalGrid">
              <!-- Elements rendered by JS -->
            </div>
          </div>
        </div>

        <!-- Materials Library -->
        <div class="sidebar-section">
          <div class="sidebar-header" onclick="toggleSection(this)" title="Apply materials">
            <span class="sidebar-title">Materials</span>
            <span class="sidebar-toggle"></span>
          </div>
          <div class="sidebar-content">
            <div class="materials-tabs">
              <!-- Countertop Stones -->
              <button class="material-tab active" onclick="showMaterialCategory('granite', this)">Granite</button>
              <button class="material-tab" onclick="showMaterialCategory('quartz', this)">Quartz</button>
              <button class="material-tab" onclick="showMaterialCategory('marble', this)">Marble</button>
              <button class="material-tab" onclick="showMaterialCategory('quartzite', this)">Quartzite</button>
              <button class="material-tab" onclick="showMaterialCategory('porcelain', this)">Porcelain</button>
              <!-- Flooring -->
              <button class="material-tab" onclick="showMaterialCategory('tile', this)">Tile</button>
              <button class="material-tab" onclick="showMaterialCategory('flooring', this)">LVT</button>
              <button class="material-tab" onclick="showMaterialCategory('hardscape', this)">Hardscape</button>
              <!-- Cabinet Finishes -->
              <button class="material-tab" onclick="showMaterialCategory('cabinets', this)">Cabinets</button>
              <button class="material-tab" onclick="showMaterialCategory('vanities', this)">Vanities</button>
              <!-- Specialty -->
              <button class="material-tab" onclick="showMaterialCategory('showerPanels', this)">Shower</button>
              <button class="material-tab" onclick="showMaterialCategory('flooringTrims', this)">Trims</button>
            </div>
            <!-- Material Filters -->
            <div class="material-filter" style="padding: 6px 8px; display: flex; flex-wrap: wrap; gap: 4px; align-items: center;">
              <select id="brandFilter" onchange="applyMaterialFilters()" style="flex: 1; min-width: 80px; padding: 4px 6px; border-radius: 4px; border: 1px solid #333; background: #1a1a2e; color: #fff; font-size: 10px;">
                <option value="">All Vendors</option>
              </select>
              <select id="priceFilter" onchange="applyMaterialFilters()" style="flex: 1; min-width: 80px; padding: 4px 6px; border-radius: 4px; border: 1px solid #333; background: #1a1a2e; color: #fff; font-size: 10px;">
                <option value="">All Prices</option>
                <option value="has">Has Price</option>
                <option value="0-5">Under $5/sf</option>
                <option value="5-15">$5$15/sf</option>
                <option value="15-30">$15$30/sf</option>
                <option value="30-50">$30$50/sf</option>
                <option value="50-100">$50$100/sf</option>
                <option value="100+">$100+/sf</option>
              </select>
              <select id="finishFilter" onchange="applyMaterialFilters()" style="flex: 1; min-width: 80px; padding: 4px 6px; border-radius: 4px; border: 1px solid #333; background: #1a1a2e; color: #fff; font-size: 10px;">
                <option value="">All Finishes</option>
              </select>
              <button onclick="clearAllMaterialFilters()" style="padding: 4px 6px; border-radius: 4px; border: none; background: #333; color: #fff; font-size: 9px; cursor: pointer;" title="Clear all filters"></button>
            </div>
            <div class="material-grid" id="materialGrid">
              <!-- Materials rendered by JS -->
            </div>
            <div class="material-hint">Click material, then click element to apply</div>
          </div>
        </div>

        <!-- Cabinet Catalog (collapsed by default) -->
        <div class="sidebar-section">
          <div class="sidebar-header" onclick="toggleSection(this)" title="Browse cabinet SKUs">
            <span class="sidebar-title">Cabinet Catalog</span>
            <span class="sidebar-toggle"></span>
          </div>
          <div class="sidebar-content collapsed">
            <div class="catalog-brand">
              <select id="catalogSelect" onchange="changeCatalog(this.value)">
                <option value="procraft">ProCraft Cabinetry</option>
                <option value="msi">MSI Cabinetry</option>
                <option value="custom">Custom / Import</option>
              </select>
            </div>
            <div class="catalog-series" id="catalogSeries">
              <select id="seriesSelect" onchange="changeSeries(this.value)">
                <option value="shaker-white">Shaker White</option>
                <option value="shaker-grey">Shaker Grey</option>
                <option value="shaker-espresso">Shaker Espresso</option>
              </select>
            </div>
            <div class="materials-tabs" id="cabinetCategoryTabs">
              <button class="material-tab active" onclick="showCabinetCategory('base', this)">Base</button>
              <button class="material-tab" onclick="showCabinetCategory('drawer', this)">Drawer</button>
              <button class="material-tab" onclick="showCabinetCategory('sink', this)">Sink</button>
              <button class="material-tab" onclick="showCabinetCategory('wall', this)">Wall</button>
              <button class="material-tab" onclick="showCabinetCategory('tall', this)">Tall</button>
              <button class="material-tab" onclick="showCabinetCategory('corner', this)">Corner</button>
              <button class="material-tab" onclick="showCabinetCategory('lazySusan', this)">L.Susan</button>
            </div>
            <div class="cabinet-catalog-list" id="cabinetCatalogList">
              <!-- Cabinets rendered by JS -->
            </div>
            <div class="catalog-actions">
              <button class="btn btn-sm btn-secondary" onclick="importCabinetList()" title="Import cabinet list from CSV or JSON">
                <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                  <polyline points="17 8 12 3 7 8"/>
                  <line x1="12" y1="3" x2="12" y2="15"/>
                </svg>
                Import List
              </button>
            </div>
          </div>
        </div>

        <!-- Product Catalog from Website (collapsed by default) -->
        <div class="sidebar-section">
          <div class="sidebar-header" onclick="toggleSection(this)" title="Shop online products">
            <span class="sidebar-title">Store Products</span>
            <span class="sidebar-toggle"></span>
          </div>
          <div class="sidebar-content collapsed">
            <div class="product-search-bar">
              <input type="text" id="productSearchInput" placeholder="Search products..." oninput="filterStoreProducts()">
              <button class="search-icon" onclick="filterStoreProducts()">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <circle cx="11" cy="11" r="8"/>
                  <line x1="21" y1="21" x2="16.65" y2="16.65"/>
                </svg>
              </button>
            </div>
            <div class="materials-tabs" id="productCategoryTabs">
              <button class="material-tab active" onclick="showProductCategory('countertops', this)">Countertops</button>
              <button class="material-tab" onclick="showProductCategory('tile', this)">Tile</button>
              <button class="material-tab" onclick="showProductCategory('flooring', this)">Flooring</button>
              <button class="material-tab" onclick="showProductCategory('sinks', this)">Sinks</button>
              <button class="material-tab" onclick="showProductCategory('faucets', this)">Faucets</button>
            </div>
            <div class="product-filters">
              <select id="productBrandFilter" onchange="filterStoreProducts()">
                <option value="">All Brands</option>
              </select>
              <select id="productTypeFilter" onchange="filterStoreProducts()">
                <option value="">All Types</option>
              </select>
            </div>
            <div class="product-catalog-grid" id="productCatalogGrid">
              <div class="loading-products">Loading products...</div>
            </div>
            <div class="product-hint">Click product to apply as material</div>
          </div>
        </div>

        <!-- Marketplace Products (Live API) -->
        <div class="sidebar-section">
          <div class="sidebar-header" onclick="toggleSection(this)" title="Browse marketplace products from vendors">
            <span class="sidebar-title">Marketplace</span>
            <span class="sidebar-toggle">&#9654;</span>
          </div>
          <div class="sidebar-content collapsed">
            <div class="product-search-bar">
              <input type="text" id="marketplaceSearchInput" placeholder="Search marketplace..." oninput="debounceMarketplaceSearch()">
              <button class="search-icon" onclick="loadMarketplaceProducts()">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <circle cx="11" cy="11" r="8"/>
                  <line x1="21" y1="21" x2="16.65" y2="16.65"/>
                </svg>
              </button>
            </div>
            <div class="materials-tabs" id="marketplaceCategoryTabs">
              <button class="material-tab active" onclick="setMarketplaceCategory('all', this)">All</button>
              <button class="material-tab" onclick="setMarketplaceCategory('countertops', this)">Countertops</button>
              <button class="material-tab" onclick="setMarketplaceCategory('cabinets', this)">Cabinets</button>
              <button class="material-tab" onclick="setMarketplaceCategory('sinks', this)">Sinks</button>
              <button class="material-tab" onclick="setMarketplaceCategory('faucets', this)">Faucets</button>
              <button class="material-tab" onclick="setMarketplaceCategory('tile', this)">Tile</button>
              <button class="material-tab" onclick="setMarketplaceCategory('flooring', this)">Flooring</button>
              <button class="material-tab" onclick="setMarketplaceCategory('vanities', this)">Vanities</button>
            </div>
            <div class="product-filters">
              <select id="marketplaceBrandFilter" onchange="applyMarketplaceFilters()">
                <option value="">All Brands</option>
              </select>
              <select id="marketplacePriceFilter" onchange="applyMarketplaceFilters()">
                <option value="">Any Price</option>
                <option value="0-50">Under $50</option>
                <option value="50-200">$50 - $200</option>
                <option value="200-500">$200 - $500</option>
                <option value="500-1000">$500 - $1,000</option>
                <option value="1000-99999">$1,000+</option>
              </select>
              <label class="marketplace-stock-filter">
                <input type="checkbox" id="marketplaceInStockOnly" onchange="applyMarketplaceFilters()"> In Stock Only
              </label>
            </div>
            <div class="marketplace-product-grid" id="marketplaceProductGrid">
              <div class="loading-products">Browse marketplace products...</div>
            </div>
            <button class="btn btn-sm btn-secondary" id="marketplaceLoadMore" onclick="loadMoreMarketplace()" style="display:none;width:100%;margin-top:8px;">
              Load More
            </button>
            <div class="product-hint">Drag product onto canvas or click to apply</div>
          </div>
        </div>
      </aside>

      <!-- Canvas Area -->
      <div class="canvas-area">
        <div class="canvas-toolbar">
          <div class="toolbar-group">
            <!-- History Controls -->
            <div class="toolbar-btn-group">
              <button class="btn btn-sm btn-secondary" id="undoBtn" onclick="undo()" title="Undo (Ctrl+Z)" data-tooltip="Undo">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M3 10h10a5 5 0 0 1 5 5v2"/>
                  <polyline points="3 10 8 5 8 15 3 10"/>
                </svg>
              </button>
              <button class="btn btn-sm btn-secondary" id="redoBtn" onclick="redo()" title="Redo (Ctrl+Y)" data-tooltip="Redo">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M21 10H11a5 5 0 0 0-5 5v2"/>
                  <polyline points="21 10 16 5 16 15 21 10"/>
                </svg>
              </button>
            </div>
            <div class="toolbar-divider"></div>
            <!-- View Controls -->
            <div class="toolbar-btn-group">
              <button class="btn btn-sm btn-secondary" onclick="fitToScreen()" title="Fit design to screen (F)">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"/>
                </svg>
                Fit
              </button>
              <button class="btn btn-sm btn-secondary" id="lockViewBtn" onclick="toggleViewLock()" title="Lock view (prevent pan/zoom)">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" id="lockIcon">
                  <rect x="3" y="11" width="18" height="11" rx="2" ry="2"/>
                  <path d="M7 11V7a5 5 0 0 1 10 0v4"/>
                </svg>
              </button>
            </div>
            <div class="toolbar-divider"></div>
            <!-- Canvas Actions -->
            <div class="toolbar-btn-group">
              <button class="btn btn-sm btn-secondary" onclick="createNewDesign()" title="Start a fresh new design" style="color: #22c55e;">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
                  <polyline points="14 2 14 8 20 8"/>
                  <line x1="12" y1="18" x2="12" y2="12"/>
                  <line x1="9" y1="15" x2="15" y2="15"/>
                </svg>
                New
              </button>
              <button class="btn btn-sm btn-secondary" onclick="clearCanvas()" title="Clear all elements (keeps room settings)">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <rect x="3" y="3" width="18" height="18" rx="2"/>
                  <line x1="9" y1="9" x2="15" y2="15"/>
                  <line x1="15" y1="9" x2="9" y2="15"/>
                </svg>
                Clear
              </button>
              <button class="btn btn-sm btn-secondary" onclick="resetCanvas()" style="color: #ef4444;" title="Reset entire project including saved progress">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/>
                  <path d="M3 3v5h5"/>
                </svg>
                Reset
              </button>
            </div>
            <div class="toolbar-divider"></div>
            <!-- Fabrication Tools -->
            <div class="toolbar-btn-group">
              <button class="btn btn-sm btn-secondary" onclick="showFabricationPlan()" title="Generate fabrication plan for countertops (seams, cut list, slab layout)" style="color: #f59e0b;">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <rect x="2" y="3" width="20" height="18" rx="2"/>
                  <path d="M8 7h8M8 11h8M8 15h4"/>
                  <line x1="16" y1="3" x2="16" y2="21" stroke-dasharray="3 2"/>
                </svg>
                Fab Plan
              </button>
              <button class="btn btn-sm btn-secondary" onclick="showSlabLayoutModal()" title="Interactive slab layout and optimization">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <rect x="2" y="2" width="20" height="20" rx="1"/>
                  <rect x="4" y="4" width="7" height="5" rx="0.5"/>
                  <rect x="13" y="4" width="7" height="8" rx="0.5"/>
                  <rect x="4" y="11" width="7" height="9" rx="0.5"/>
                  <rect x="13" y="14" width="7" height="6" rx="0.5"/>
                </svg>
                Slabs
              </button>
            </div>
          </div>
          <div class="canvas-info">
            <span id="canvasSize">12'  10'</span>
            <span id="elementCount">0 elements</span>
            <span id="saveStatus" class="save-status" title="Auto-save status">
              <svg class="save-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/>
                <polyline points="17 21 17 13 7 13 7 21"/>
                <polyline points="7 3 7 8 15 8"/>
              </svg>
              <span class="save-text">Saved</span>
              <span class="save-time" id="saveTime"></span>
            </span>
            <button class="help-btn" onclick="openModal('shortcutsModal')" title="Keyboard shortcuts (?)">
              <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="12" cy="12" r="10"/>
                <path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"/>
                <line x1="12" y1="17" x2="12.01" y2="17"/>
              </svg>
            </button>
          </div>
        </div>
        <div class="canvas-wrapper" id="canvasWrapper">
          <canvas id="canvas"></canvas>
        </div>
        <div id="three-container">
          <div class="three-controls">
            <button onclick="reset3DView()" title="Reset camera to default position">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/>
                <path d="M3 3v5h5"/>
              </svg>
              Reset View
            </button>
            <button onclick="set3DViewAngle('top')" title="Top-down view">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="12" cy="12" r="3"/>
                <path d="M12 2v4M12 18v4M2 12h4M18 12h4"/>
              </svg>
              Top
            </button>
            <button onclick="set3DViewAngle('front')" title="Front view">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <rect x="3" y="3" width="18" height="18" rx="2"/>
              </svg>
              Front
            </button>
            <button onclick="set3DViewAngle('counter')" title="Counter-level view (eye height at countertop)">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M2 17h20M2 12h20M7 17v-5M17 17v-5"/>
              </svg>
              Counter
            </button>
            <button onclick="set3DViewAngle('corner')" title="Corner view (diagonal across room)">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M3 21L21 3M3 21h6M3 21v-6"/>
              </svg>
              Corner
            </button>
            <button onclick="toggleCabinetFocus()" title="Hide walls/windows to focus on cabinets" id="focusCabinetsBtn">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <rect x="4" y="10" width="6" height="10" rx="1"/>
                <rect x="14" y="10" width="6" height="10" rx="1"/>
                <path d="M4 8h16"/>
              </svg>
              Focus
            </button>
            <button onclick="toggleWalkthroughMode()" title="First-person walkthrough mode (WASD + mouse)" id="walkthroughBtn">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="12" cy="8" r="4"/>
                <path d="M12 12v8M8 16l4 4 4-4"/>
              </svg>
              Walk
            </button>
            <button onclick="togglePostProcessing()" title="Toggle enhanced graphics (bloom, ambient occlusion)" id="postProcessingBtn" class="active">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="12" cy="12" r="4"/>
                <path d="M12 2v2M12 20v2M4.93 4.93l1.41 1.41M17.66 17.66l1.41 1.41M2 12h2M20 12h2M4.93 19.07l1.41-1.41M17.66 6.34l1.41-1.41"/>
              </svg>
              FX
            </button>
            <button onclick="toggleMeasurementMode()" title="Measure distance between two points" id="measureBtn">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M2 12h4M18 12h4"/>
                <path d="M6 8v8M18 8v8"/>
                <line x1="6" y1="12" x2="18" y2="12" stroke-dasharray="2 2"/>
                <circle cx="6" cy="12" r="2"/>
                <circle cx="18" cy="12" r="2"/>
              </svg>
              Measure
            </button>
            <button onclick="toggleRoomDimensions()" title="Show/hide room dimensions" id="roomDimsBtn">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <rect x="3" y="3" width="18" height="18" rx="1"/>
                <path d="M3 9h18M9 3v18"/>
                <text x="6" y="7" font-size="4" fill="currentColor">W</text>
                <text x="11" y="16" font-size="4" fill="currentColor">D</text>
              </svg>
              Dims
            </button>
            <button onclick="toggleLightingPanel()" title="Adjust lighting settings" id="lightingBtn">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="12" cy="12" r="5"/>
                <line x1="12" y1="1" x2="12" y2="3"/>
                <line x1="12" y1="21" x2="12" y2="23"/>
                <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/>
                <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/>
                <line x1="1" y1="12" x2="3" y2="12"/>
                <line x1="21" y1="12" x2="23" y2="12"/>
                <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/>
                <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/>
              </svg>
              Light
            </button>
            <button onclick="captureHighResScreenshot()" title="Capture high-resolution screenshot" id="screenshotBtn">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <rect x="3" y="3" width="18" height="18" rx="2"/>
                <circle cx="8.5" cy="8.5" r="1.5"/>
                <path d="M21 15l-5-5L5 21"/>
              </svg>
              Photo
            </button>
          </div>
          <!-- Lighting Control Panel -->
          <div class="lighting-panel" id="lightingPanel" style="display: none;">
            <div class="lighting-panel-header">
              <span>Lighting Controls</span>
              <button onclick="toggleLightingPanel()" class="close-btn">&times;</button>
            </div>
            <div class="lighting-panel-content">
              <div class="lighting-presets">
                <label>Presets</label>
                <div class="preset-buttons">
                  <button onclick="setLightingPreset('morning', this)" class="preset-btn" title="Morning"></button>
                  <button onclick="setLightingPreset('noon', this)" class="preset-btn active" title="Noon"></button>
                  <button onclick="setLightingPreset('evening', this)" class="preset-btn" title="Evening"></button>
                  <button onclick="setLightingPreset('night', this)" class="preset-btn" title="Night"></button>
                  <button onclick="setLightingPreset('showroom', this)" class="preset-btn" title="Showroom"></button>
                </div>
              </div>
              <div class="lighting-slider">
                <label>Brightness</label>
                <input type="range" id="brightnessSlider" min="0" max="200" value="100" oninput="adjustBrightness(this.value)">
                <span id="brightnessValue">100%</span>
              </div>
              <div class="lighting-slider">
                <label>Ambient</label>
                <input type="range" id="ambientSlider" min="0" max="150" value="50" oninput="adjustAmbient(this.value)">
                <span id="ambientValue">50%</span>
              </div>
              <div class="lighting-slider">
                <label>Shadows</label>
                <input type="range" id="shadowSlider" min="0" max="100" value="80" oninput="adjustShadows(this.value)">
                <span id="shadowValue">80%</span>
              </div>
              <div class="lighting-toggle">
                <label>
                  <input type="checkbox" id="shadowsEnabled" checked onchange="toggleShadows(this.checked)">
                  Enable Shadows
                </label>
              </div>
              <div class="lighting-toggle hd-toggle">
                <label>
                  <input type="checkbox" id="hdModeEnabled" onchange="toggleHDMode(this.checked)">
                  HD Mode <span class="hd-badge"> Enhanced</span>
                </label>
              </div>
            </div>
          </div>
          <div class="three-hint" id="threeHint">
            Left-drag: Rotate  Scroll: Zoom  Middle-drag: Pan  Double-click: Open doors
          </div>
          <div class="three-hint walkthrough-hint" id="walkthroughHint" style="display: none;">
            <strong>Walkthrough Mode:</strong> WASD to move  Mouse to look  Q/E for up/down  ESC to exit
          </div>
        </div>
      </div>

      <!-- Floating Quick-Action Toolbar -->
      <div class="floating-toolbar" id="floatingToolbar">
        <div class="selection-badge" id="selectionBadge">
          <span class="count" id="selectionCount">1</span>
          <span id="selectionType">Selected</span>
        </div>
        <div class="floating-toolbar-group">
          <button class="float-btn" onclick="duplicateSelectedElement()" title="Duplicate">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <rect x="9" y="9" width="13" height="13" rx="2"/>
              <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/>
            </svg>
            <span class="shortcut">D</span>
          </button>
          <button class="float-btn" onclick="rotateSelectedElement(90)" title="Rotate 90">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M21 12a9 9 0 1 1-9-9c2.52 0 4.93 1 6.74 2.74L21 8"/>
              <path d="M21 3v5h-5"/>
            </svg>
            <span class="shortcut">R</span>
          </button>
          <button class="float-btn" onclick="flipSelectedElement('h')" title="Flip Horizontal">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M8 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h3"/>
              <path d="M16 3h3a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2h-3"/>
              <line x1="12" y1="3" x2="12" y2="21"/>
            </svg>
            <span class="shortcut">H</span>
          </button>
        </div>
        <div class="floating-toolbar-divider"></div>
        <div class="floating-toolbar-group">
          <button class="float-btn" onclick="bringToFront()" title="Bring to Front">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <rect x="8" y="8" width="12" height="12" rx="2" fill="currentColor" opacity="0.3"/>
              <rect x="4" y="4" width="12" height="12" rx="2"/>
            </svg>
          </button>
          <button class="float-btn" onclick="sendToBack()" title="Send to Back">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <rect x="4" y="4" width="12" height="12" rx="2" fill="currentColor" opacity="0.3"/>
              <rect x="8" y="8" width="12" height="12" rx="2"/>
            </svg>
          </button>
        </div>
        <div class="floating-toolbar-divider"></div>
        <div class="floating-toolbar-group">
          <button class="float-btn" id="lockTogetherBtn" onclick="lockElementsTogether()" title="Lock with another element" style="background: rgba(99, 102, 241, 0.3);">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"/>
              <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"/>
            </svg>
          </button>
          <button class="float-btn" id="unlockBtn" onclick="unlockElement()" title="Unlock from group" style="display: none;">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M18.36 6.64a9 9 0 1 1-12.73 0"/>
              <line x1="12" y1="2" x2="12" y2="12"/>
            </svg>
          </button>
        </div>
        <div class="floating-toolbar-divider"></div>
        <button class="float-btn danger" onclick="deleteSelectedElement()" title="Delete">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M3 6h18"/>
            <path d="M8 6V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/>
            <path d="M19 6l-1 14a2 2 0 0 1-2 2H8a2 2 0 0 1-2-2L5 6"/>
          </svg>
          <span class="shortcut"></span>
        </button>
      </div>

      <!-- Right Panel -->
      <aside class="right-panel">
        <div class="panel-section">
          <div class="panel-title">Room Settings</div>
          <div class="room-grid">
            <div class="input-group">
              <label class="input-label">Room Type</label>
              <select class="input-field" id="roomType" onchange="updateRoom()">
                <option value="kitchen">Kitchen</option>
                <option value="bathroom">Bathroom</option>
                <option value="shower">Shower Room</option>
                <option value="closet">Walk-in Closet</option>
                <option value="laundry">Laundry</option>
                <option value="bedroom">Bedroom</option>
                <option value="living">Living Room</option>
                <option value="office">Office</option>
                <option value="commercial">Commercial</option>
              </select>
            </div>
            <div class="input-group">
              <label class="input-label">Width (ft)</label>
              <input type="number" class="input-field" id="roomWidth" value="20" min="8" max="100" onchange="updateRoom()">
            </div>
            <div class="input-group">
              <label class="input-label">Depth (ft)</label>
              <input type="number" class="input-field" id="roomDepth" value="16" min="8" max="100" onchange="updateRoom()">
            </div>
            <div class="input-group">
              <label class="input-label">Ceiling (ft)</label>
              <select class="input-field" id="roomHeight" onchange="updateRoomHeight()">
                <option value="8" selected>8' Standard</option>
                <option value="9">9' Raised</option>
                <option value="10">10' High</option>
                <option value="12">12' Vaulted</option>
              </select>
            </div>
            <div class="input-group">
              <label class="input-label">Scale</label>
              <select class="input-field" id="scaleMode" onchange="updateScale()">
                <option value="fit">Fit to Screen</option>
                <option value="40">40 px/ft</option>
                <option value="50">50 px/ft</option>
                <option value="60">60 px/ft</option>
              </select>
            </div>
          </div>
        </div>

        <!-- Unified Messages Panel -->
        <div class="panel-section" id="teamChatSection">
          <div class="panel-title" onclick="togglePanelSection('teamChatSection')" style="cursor: pointer; display: flex; align-items: center; justify-content: space-between;">
            <span style="display: flex; align-items: center; gap: 8px;">
              <span style="font-size: 14px;"></span>
              <span>Messages</span>
            </span>
            <div style="display: flex; align-items: center; gap: 6px;">
              <span class="online-indicator" id="teamOnlineCount" style="background: rgba(16,185,129,0.2); color: #10b981; font-size: 9px; padding: 2px 6px; border-radius: 8px; font-weight: 500;">0 online</span>
              <span class="toggle-icon" style="font-size: 10px; opacity: 0.5;"></span>
            </div>
          </div>
          <div class="panel-content" id="teamChatContent">
            <!-- Active collaborators (compact) -->
            <div id="activeCollaborators" style="display: none;"></div>
            <!-- Message type tabs -->
            <div class="message-tabs" style="display: flex; align-items: center; gap: 4px;">
              <button class="message-tab active" id="tabAllMessages" onclick="switchMessageTab('all')">
                All
                <span class="tab-badge hidden" id="badgeAll">0</span>
              </button>
              <button class="message-tab" id="tabClientMessages" onclick="switchMessageTab('client')">
                 Clients
                <span class="tab-badge hidden" id="badgeClient">0</span>
              </button>
              <button class="message-tab" id="tabTeamMessages" onclick="switchMessageTab('team')">
                 Team
                <span class="tab-badge hidden" id="badgeTeam">0</span>
              </button>
              <button onclick="refreshMessages()" title="Refresh messages" style="margin-left: auto; padding: 4px 8px; background: transparent; border: 1px solid var(--border); border-radius: 6px; cursor: pointer; font-size: 12px;"></button>
            </div>
            <!-- Messages list -->
            <div id="teamChatMessages">
              <div class="chat-empty-state" style="color: var(--text-muted); font-size: 11px; text-align: center; padding: 30px 12px;">
                <div style="font-size: 24px; margin-bottom: 8px; opacity: 0.4;"></div>
                <div style="font-weight: 500; margin-bottom: 4px;">No messages yet</div>
                <div style="font-size: 10px; opacity: 0.6;">Customer comments and team chat will appear here</div>
              </div>
            </div>
            <!-- Chat input - wrapped in form to prevent password autofill -->
            <form class="chat-input-wrapper" onsubmit="sendUnifiedMessage(); return false;" autocomplete="off">
              <input type="search" id="teamChatInput" placeholder="Type a message..." autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" data-lpignore="true" data-1p-ignore="true" data-bwignore="true" data-form-type="other" style="-webkit-appearance: none;">
              <button type="submit" class="btn btn-primary" title="Send message">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5">
                  <path stroke-linecap="round" stroke-linejoin="round" d="M6 12L3 21l18-9L3 3l3 9m0 0h12"/>
                </svg>
              </button>
            </form>
          </div>
        </div>

        <!-- Room Templates (expanded by default for discoverability) -->
        <div class="panel-section" id="roomTemplatesSection">
          <div class="panel-title" onclick="togglePanelSection('roomTemplatesSection')">
            <span>Room Templates</span>
            <span class="toggle-icon"></span>
          </div>
          <div class="panel-content">
          <div class="room-templates-grid">
            <button class="template-btn" onclick="loadRoomTemplate('kitchen-l')" title="L-shaped kitchen with island">
              <span class="template-icon"></span>
              <span class="template-name">L-Kitchen</span>
            </button>
            <button class="template-btn" onclick="loadRoomTemplate('kitchen-galley')" title="Galley kitchen layout">
              <span class="template-icon"></span>
              <span class="template-name">Galley</span>
            </button>
            <button class="template-btn" onclick="loadRoomTemplate('kitchen-u')" title="U-shaped kitchen">
              <span class="template-icon"></span>
              <span class="template-name">U-Kitchen</span>
            </button>
            <button class="template-btn" onclick="loadRoomTemplate('kitchen-single')" title="Single wall kitchen layout">
              <span class="template-icon"></span>
              <span class="template-name">Single Wall</span>
            </button>
            <button class="template-btn" onclick="loadRoomTemplate('kitchen-peninsula')" title="Peninsula kitchen with breakfast bar">
              <span class="template-icon"></span>
              <span class="template-name">Peninsula</span>
            </button>
            <button class="template-btn" onclick="loadRoomTemplate('bathroom-master')" title="Master bathroom with tub and shower">
              <span class="template-icon"></span>
              <span class="template-name">Master Bath</span>
            </button>
            <button class="template-btn" onclick="loadRoomTemplate('bathroom-half')" title="Half bathroom (powder room)">
              <span class="template-icon"></span>
              <span class="template-name">Half Bath</span>
            </button>
            <button class="template-btn" onclick="loadRoomTemplate('shower-walkin')" title="Walk-in shower with bench">
              <span class="template-icon"></span>
              <span class="template-name">Walk-in Shower</span>
            </button>
            <button class="template-btn" onclick="loadRoomTemplate('closet-walkin')" title="Walk-in closet with shelving">
              <span class="template-icon"></span>
              <span class="template-name">Walk-in Closet</span>
            </button>
            <button class="template-btn" onclick="loadRoomTemplate('laundry-room')" title="Laundry room with cabinets">
              <span class="template-icon"></span>
              <span class="template-name">Laundry</span>
            </button>
            <button class="template-btn" onclick="loadRoomTemplate('bathroom-master-full')" title="Master bath with his/hers vanity, tub, walk-in shower">
              <span class="template-icon"></span>
              <span class="template-name">Master Bath Full</span>
            </button>
            <button class="template-btn" onclick="loadRoomTemplate('bathroom-guest')" title="Guest bathroom with vanity, tub, and toilet">
              <span class="template-icon"></span>
              <span class="template-name">Guest Bath</span>
            </button>
            <button class="template-btn" onclick="loadRoomTemplate('bathroom-powder')" title="Small powder room with pedestal sink">
              <span class="template-icon"></span>
              <span class="template-name">Powder Room</span>
            </button>
            <button class="template-btn" onclick="loadRoomTemplate('bathroom-jack-jill')" title="Jack-and-Jill shared bathroom">
              <span class="template-icon"></span>
              <span class="template-name">Jack &amp; Jill</span>
            </button>
            <button class="template-btn" onclick="loadRoomTemplate('concept-modern-kitchen-bath')" title="Modern kitchen and master bath concept layout">
              <span class="template-icon"></span>
              <span class="template-name">Kitchen+Bath</span>
            </button>
            <button class="template-btn" onclick="loadRoomTemplate('kitchen-compact')" title="Compact studio kitchen - 8x8">
              <span class="template-icon"></span>
              <span class="template-name">Compact</span>
            </button>
            <button class="template-btn" onclick="loadRoomTemplate('outdoor-kitchen')" title="Outdoor kitchen with grill">
              <span class="template-icon"></span>
              <span class="template-name">Outdoor</span>
            </button>
            <button class="template-btn" onclick="loadRoomTemplate('butler-pantry')" title="Butler's pantry with wine storage">
              <span class="template-icon"></span>
              <span class="template-name">Butler's Pantry</span>
            </button>
            <button class="template-btn" onclick="loadRoomTemplate('wet-bar')" title="Compact wet bar with sink">
              <span class="template-icon"></span>
              <span class="template-name">Wet Bar</span>
            </button>
            <button class="template-btn" onclick="loadRoomTemplate('bathroom-ada')" title="ADA accessible bathroom">
              <span class="template-icon"></span>
              <span class="template-name">ADA Bath</span>
            </button>
            <button class="template-btn" onclick="loadRoomTemplate('bathroom-ensuite')" title="En-suite bathroom with shower">
              <span class="template-icon"></span>
              <span class="template-name">En-Suite</span>
            </button>
          </div>
          <p class="template-hint">Click a template to load preset room layout</p>
          <!-- Hidden for now - admin feature -->
          <button onclick="exportAsTemplate()" style="display:none;width:100%;margin-top:8px;padding:8px;background:rgba(99,102,241,0.2);border:1px solid rgba(99,102,241,0.4);border-radius:6px;color:#a5b4fc;font-size:11px;cursor:pointer;" title="Export your current design as reusable template code">
             Export Current Design as Template
          </button>
          </div><!-- /panel-content -->
        </div>

        <!-- Cabinet Settings -->
        <div class="panel-section">
          <div class="panel-title">Cabinet Settings</div>
          <div class="room-grid">
            <div class="input-group">
              <label class="input-label">Construction</label>
              <select class="input-field" id="cabinetConstruction" onchange="updateCabinetSettings()">
                <option value="frameless">Frameless (Euro)</option>
                <option value="framed">Framed (Face Frame)</option>
              </select>
            </div>
            <div class="input-group">
              <label class="input-label">Door Style</label>
              <select class="input-field" id="doorStyle" onchange="updateCabinetSettings()">
                <option value="shaker">Shaker (Standard)</option>
                <option value="thin-shaker">Thin Shaker (Slim Rail)</option>
                <option value="shaker-beaded">Shaker Beaded</option>
                <option value="raised">Raised Panel (Traditional)</option>
                <option value="recessed">Recessed Panel</option>
                <option value="mission">Mission/Craftsman</option>
                <option value="flat">Flat Panel (Modern)</option>
                <option value="slab">Slab (No Detail)</option>
              </select>
            </div>
            <div class="input-group">
              <label class="input-label">Cabinet Finish</label>
              <select class="input-field" id="cabinetFinish" onchange="updateCabinetSettings()">
                <option value="wood-grain">Wood Grain</option>
                <option value="painted">Painted (No Grain)</option>
                <option value="matte">Matte Laminate</option>
                <option value="gloss">High Gloss</option>
              </select>
            </div>
            <div class="input-group">
              <label class="input-label">Door Overlay</label>
              <select class="input-field" id="doorOverlay" onchange="updateCabinetSettings()">
                <option value="full">Full Overlay</option>
                <option value="partial">Partial Overlay</option>
                <option value="inset">Inset</option>
              </select>
            </div>
            <div class="input-group" style="grid-column: span 2;">
              <button class="action-btn" onclick="applySettingsToAllCabinets()" style="width: 100%; padding: 8px 12px; font-size: 12px;">
                Apply Style to All Cabinets
              </button>
            </div>
            <div class="input-group">
              <label class="input-label">Floor Level</label>
              <select class="input-field" id="floorLevel" onchange="updateFloorLevel()">
                <option value="1">Floor 1</option>
                <option value="2">Floor 2</option>
                <option value="3">Floor 3</option>
                <option value="add">+ Add Floor</option>
              </select>
            </div>
          </div>
        </div>

        <!-- Scene Settings (collapsed by default) -->
        <div class="panel-section collapsed" id="sceneSettingsSection">
          <div class="panel-title" onclick="togglePanelSection('sceneSettingsSection')">
            <span>Scene Settings</span>
            <span class="toggle-icon"></span>
          </div>
          <div class="panel-content">
            <div class="room-grid">
              <div class="input-group">
                <label class="input-label">Time of Day</label>
                <select class="input-field" id="timeOfDay" onchange="updateTimeOfDay()">
                  <option value="morning">Morning (Sunrise)</option>
                  <option value="noon" selected>Noon (Daylight)</option>
                  <option value="evening">Evening (Sunset)</option>
                  <option value="night">Night</option>
                </select>
              </div>
            </div>
          </div>
        </div>

        <!-- Item Picker / Quote List -->
        <div class="panel-section" id="itemPickerSection">
          <div class="panel-title" style="display: flex; align-items: center; justify-content: space-between;">
            <span>Item List</span>
            <span class="item-picker-total" id="itemPickerTotal">$0.00</span>
          </div>
          <div class="item-picker-controls">
            <select class="input-field item-filter" id="itemFilterType" onchange="filterItemList()">
              <option value="all">All Items</option>
              <option value="cabinets">Cabinets</option>
              <option value="countertops">Countertops</option>
              <option value="appliances">Appliances</option>
              <option value="sinks">Sinks</option>
              <option value="flooring">Flooring</option>
              <option value="fixtures">Fixtures</option>
              <option value="other">Other</option>
            </select>
          </div>
          <div class="item-picker-list" id="itemPickerList">
            <!-- Populated by JavaScript -->
          </div>
          <div class="item-picker-summary" id="itemPickerSummary">
            <div id="itemCategorySummary">
              <!-- Category breakdown populated by JS -->
            </div>
            <div class="summary-row" style="margin-top: 8px; padding-top: 8px; border-top: 1px solid var(--border);">
              <span>Items:</span>
              <span id="itemCount">0</span>
            </div>
            <div class="summary-row" style="font-size: 13px;">
              <span><strong>Total:</strong></span>
              <span id="itemSubtotal" style="color: #22c55e; font-weight: 700;">$0.00</span>
            </div>
          </div>
          <div class="item-picker-actions">
            <button class="btn-small btn-secondary" onclick="selectAllItems()">Select All</button>
            <button class="btn-small btn-secondary" onclick="deselectAllItems()">Deselect</button>
            <button class="btn-small btn-danger" onclick="deleteSelectedItems()">Delete</button>
          </div>
        </div>

        <!-- Hidden element list for compatibility -->
        <div id="elementLayerList" style="display: none;"></div>
        <span id="elementCountDisplay" style="display: none;">0</span>

        <div class="panel-section" id="propertiesPanel">
          <div class="panel-title">Properties</div>
          <div class="properties-empty" id="propertiesEmpty">
            Select an element to edit
          </div>
          <div id="propertiesContent" style="display: none;">
            <!-- Quick Actions Toolbar -->
            <div class="quick-actions" style="display: flex; gap: 4px; margin-bottom: 12px; padding-bottom: 12px; border-bottom: 1px solid var(--border-color);">
              <button class="quick-btn" onclick="duplicateSelectedElement()" title="Duplicate (Ctrl+D)">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="16" height="16">
                  <rect x="9" y="9" width="13" height="13" rx="2"/>
                  <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/>
                </svg>
              </button>
              <button class="quick-btn" onclick="rotateSelectedElement(90)" title="Rotate 90 (R)">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="16" height="16">
                  <path d="M21 12a9 9 0 1 1-9-9c2.52 0 4.93 1 6.74 2.74L21 8"/>
                  <path d="M21 3v5h-5"/>
                </svg>
              </button>
              <button class="quick-btn" onclick="rotateSelectedElement(180)" title="Rotate 180">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="16" height="16">
                  <path d="M21 12a9 9 0 0 1-9 9 9 9 0 0 1-9-9"/>
                  <path d="M3 12a9 9 0 0 1 9-9 9 9 0 0 1 9 9"/>
                  <path d="M16 16l2 2 2-2"/>
                  <path d="M8 8l-2-2-2 2"/>
                </svg>
              </button>
              <button class="quick-btn" onclick="flipSelectedElement('h')" title="Flip Horizontal">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="16" height="16">
                  <path d="M8 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h3"/>
                  <path d="M16 3h3a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2h-3"/>
                  <line x1="12" y1="3" x2="12" y2="21"/>
                </svg>
              </button>
              <button class="quick-btn" onclick="bringToFront()" title="Bring to Front">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="16" height="16">
                  <rect x="8" y="8" width="12" height="12" rx="2" fill="currentColor" opacity="0.3"/>
                  <rect x="4" y="4" width="12" height="12" rx="2"/>
                </svg>
              </button>
              <button class="quick-btn" onclick="sendToBack()" title="Send to Back">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="16" height="16">
                  <rect x="4" y="4" width="12" height="12" rx="2" fill="currentColor" opacity="0.3"/>
                  <rect x="8" y="8" width="12" height="12" rx="2"/>
                </svg>
              </button>
              <button class="quick-btn danger" onclick="deleteSelectedElement()" title="Delete (Del)">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="16" height="16">
                  <path d="M3 6h18"/>
                  <path d="M8 6V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/>
                  <path d="M19 6l-1 14a2 2 0 0 1-2 2H8a2 2 0 0 1-2-2L5 6"/>
                </svg>
              </button>
            </div>
            <div class="property-row">
              <span class="property-label">Type</span>
              <span class="property-value" id="propType">-</span>
            </div>
            <div class="property-row">
              <span class="property-label">Width</span>
              <input type="text" class="property-input" id="propWidth" placeholder="e.g. 3'-6&quot; or 2.5" onchange="updateSelectedElement()" title="Enter feet-inches (3'-6&quot;) or decimal feet (2.5)">
              <span class="dimension-display" id="propWidthDisplay"></span>
            </div>
            <div class="property-row">
              <span class="property-label">Depth</span>
              <input type="text" class="property-input" id="propDepth" placeholder="e.g. 2'-0&quot; or 2" onchange="updateSelectedElement()" title="Enter feet-inches (2'-0&quot;) or decimal feet (2)">
              <span class="dimension-display" id="propDepthDisplay"></span>
            </div>
            <div class="property-row" id="prop3DHeightRow">
              <span class="property-label">Height</span>
              <input type="text" class="property-input" id="prop3DHeight" placeholder="e.g. 2'-10.5&quot; or 2.875" onchange="updateSelectedElement()" title="3D vertical height - feet-inches or decimal feet">
              <span class="dimension-display" id="prop3DHeightDisplay"></span>
            </div>
            <div class="property-row" id="standardSizeRow" style="display: none;">
              <span class="property-label">Standard</span>
              <select class="property-select" id="propStandardSize" onchange="applyStandardSize()">
                <option value="">Custom</option>
              </select>
            </div>
            <!-- Window/Door height from floor -->
            <div class="property-row" id="sillHeightRow" style="display: none;">
              <span class="property-label">Sill Height</span>
              <div style="display: flex; align-items: center; gap: 8px;">
                <select class="property-select" id="propSillHeight" onchange="updateSillHeight()" style="flex: 1;">
                  <option value="0">0" - Floor Level (Doors)</option>
                  <option value="1.5">18" - Low / Picture Window</option>
                  <option value="2">24" - Bedroom Window</option>
                  <option value="3">36" - Standard (IRC)</option>
                  <option value="3.5">42" - Above Counter (Kitchen)</option>
                  <option value="4">48" - High Window</option>
                  <option value="5">60" - Clerestory</option>
                  <option value="custom">Custom...</option>
                </select>
              </div>
            </div>
            <div class="property-row" id="customSillRow" style="display: none;">
              <span class="property-label">Custom (ft)</span>
              <input type="number" class="property-input" id="propCustomSill" step="0.0833" min="0" max="8" onchange="applyCustomSillHeight()">
            </div>
            <!-- Window Opening Height controls -->
            <div class="property-row" id="windowHeightRow" style="display: none;">
              <span class="property-label">Window Height</span>
              <div style="display: flex; align-items: center; gap: 8px;">
                <select class="property-select" id="propWindowHeight" onchange="updateWindowOpeningHeight()" style="flex: 1;">
                  <option value="2">24" - Small</option>
                  <option value="2.5">30" - Standard</option>
                  <option value="3">36" - Standard+</option>
                  <option value="3.5">42" - Large</option>
                  <option value="4">48" - Bay / Large</option>
                  <option value="5">60" - Picture</option>
                  <option value="6">72" - Floor-to-Ceil</option>
                  <option value="custom">Custom...</option>
                </select>
              </div>
            </div>
            <div class="property-row" id="customWindowHeightRow" style="display: none;">
              <span class="property-label">Height (ft)</span>
              <input type="number" class="property-input" id="propCustomWindowHeight" step="0.0833" min="1" max="10" onchange="applyCustomWindowOpeningHeight()">
              <span class="dimension-display" id="propWindowHeightDisplay"></span>
            </div>
            <!-- Door/Archway height controls -->
            <div class="property-row" id="doorHeightRow" style="display: none;">
              <span class="property-label">Opening Height</span>
              <div style="display: flex; align-items: center; gap: 8px;">
                <select class="property-select" id="propDoorHeight" onchange="updateDoorHeight()" style="flex: 1;">
                  <option value="6.67">80" - Standard Door</option>
                  <option value="6.83">82" - Standard+</option>
                  <option value="7">84" - 7 Foot</option>
                  <option value="8">96" - 8 Foot</option>
                  <option value="9">108" - 9 Foot</option>
                  <option value="10">120" - 10 Foot</option>
                  <option value="custom">Custom...</option>
                </select>
              </div>
            </div>
            <div class="property-row" id="customDoorHeightRow" style="display: none;">
              <span class="property-label">Height (ft)</span>
              <input type="number" class="property-input" id="propCustomDoorHeight" step="0.0833" min="5" max="12" onchange="applyCustomDoorHeight()">
              <span class="dimension-display" id="propDoorHeightDisplay"></span>
            </div>
            <!-- Archway style controls -->
            <div class="property-row" id="archwayStyleRow" style="display: none;">
              <span class="property-label">Arch Style</span>
              <select class="property-select" id="propArchwayStyle" onchange="updateArchwayStyle()">
                <option value="round">Round Arch</option>
                <option value="pointed">Pointed/Gothic</option>
                <option value="flat">Flat Top (Cased Opening)</option>
                <option value="elliptical">Elliptical</option>
              </select>
            </div>
            <!-- Window Style controls -->
            <div class="property-row" id="windowStyleRow" style="display: none;">
              <span class="property-label">Window Style</span>
              <select class="property-select" id="propWindowStyle" onchange="updateWindowStyle()">
                <option value="double-hung">Double-Hung</option>
                <option value="single-hung">Single-Hung</option>
                <option value="casement">Casement</option>
                <option value="sliding">Sliding</option>
                <option value="fixed">Fixed/Picture</option>
              </select>
            </div>
            <div class="property-row" id="mullionPatternRow" style="display: none;">
              <span class="property-label">Mullion Pattern</span>
              <select class="property-select" id="propMullionPattern" onchange="updateMullionPattern()">
                <option value="standard">Standard Cross</option>
                <option value="colonial">Colonial Grid</option>
                <option value="prairie">Prairie Style</option>
                <option value="none">No Grilles</option>
              </select>
            </div>
            <!-- Pony Wall / Half Wall height controls -->
            <div class="property-row" id="wallHeightRow" style="display: none;">
              <span class="property-label">Wall Height</span>
              <div style="display: flex; align-items: center; gap: 8px;">
                <select class="property-select" id="propWallHeight" onchange="updateWallHeight()" style="flex: 1;">
                  <option value="2">24" - Knee Wall</option>
                  <option value="2.5">30" - Low Pony</option>
                  <option value="3">36" - Counter Height</option>
                  <option value="3.5">42" - Standard Pony</option>
                  <option value="4">48" - Bar Height</option>
                  <option value="custom">Custom...</option>
                </select>
              </div>
            </div>
            <div class="property-row" id="customWallHeightRow" style="display: none;">
              <span class="property-label">Height (ft)</span>
              <input type="number" class="property-input" id="propCustomWallHeight" step="0.0833" min="1" max="8" onchange="applyCustomWallHeight()">
              <span class="dimension-display" id="propWallHeightDisplay"></span>
            </div>
            <!-- Full-height wall controls (masonry, concrete, etc.) -->
            <div class="property-row" id="fullWallHeightRow" style="display: none;">
              <span class="property-label">Wall Height</span>
              <div style="display: flex; align-items: center; gap: 8px;">
                <select class="property-select" id="propFullWallHeight" onchange="updateFullWallHeight()" style="flex: 1;">
                  <option value="ceiling">To Ceiling</option>
                  <option value="8">8' (96")</option>
                  <option value="9">9' (108")</option>
                  <option value="10">10' (120")</option>
                  <option value="12">12' (144")</option>
                  <option value="14">14' (168")</option>
                  <option value="16">16' (192")</option>
                  <option value="custom">Custom...</option>
                </select>
              </div>
            </div>
            <div class="property-row" id="customFullWallHeightRow" style="display: none;">
              <span class="property-label">Height (ft)</span>
              <div class="dimension-input-group">
                <input type="text" class="property-input dimension-input" id="propCustomFullWallHeight" placeholder="8" onchange="applyCustomFullWallHeight()">
                <span class="dimension-display" id="propFullWallHeightDisplay"></span>
              </div>
            </div>
            <div class="property-row" id="wallThicknessRow" style="display: none;">
              <span class="property-label">Wall Thickness</span>
              <div style="display: flex; align-items: center; gap: 8px;">
                <select class="property-select" id="propWallThickness" onchange="updateWallThickness()" style="flex: 1;">
                  <option value="0.33">4" (2x4 stud)</option>
                  <option value="0.5">6" (2x6 stud)</option>
                  <option value="0.67">8" (CMU block)</option>
                  <option value="0.83">10" (Double CMU)</option>
                  <option value="1">12" (Concrete)</option>
                  <option value="1.33">16" (Heavy)</option>
                  <option value="custom">Custom...</option>
                </select>
              </div>
            </div>
            <div class="property-row" id="customWallThicknessRow" style="display: none;">
              <span class="property-label">Thickness (ft)</span>
              <div class="dimension-input-group">
                <input type="text" class="property-input dimension-input" id="propCustomWallThickness" placeholder="0.5" onchange="applyCustomWallThickness()">
                <span class="dimension-display" id="propWallThicknessDisplay"></span>
              </div>
            </div>
            <!-- Niche depth controls -->
            <div class="property-row" id="nicheDepthRow" style="display: none;">
              <span class="property-label">Recess Depth</span>
              <div style="display: flex; align-items: center; gap: 8px;">
                <select class="property-select" id="propNicheDepth" onchange="updateNicheDepth()" style="flex: 1;">
                  <option value="0.25">3" - Shallow</option>
                  <option value="0.33">4" - Standard</option>
                  <option value="0.5">6" - Deep</option>
                  <option value="0.67">8" - TV Recess</option>
                  <option value="1">12" - Fireplace</option>
                  <option value="1.5">18" - Deep Fireplace</option>
                  <option value="custom">Custom...</option>
                </select>
              </div>
            </div>
            <div class="property-row" id="customNicheDepthRow" style="display: none;">
              <span class="property-label">Depth (ft)</span>
              <input type="number" class="property-input" id="propCustomNicheDepth" step="0.0833" min="0.1" max="3" onchange="applyCustomNicheDepth()">
              <span class="dimension-display" id="propNicheDepthDisplay"></span>
            </div>
            <!-- Backsplash vertical height controls -->
            <div class="property-row" id="backsplashHeightRow" style="display: none;">
              <span class="property-label">Backsplash Height</span>
              <div style="display: flex; align-items: center; gap: 8px;">
                <select class="property-select" id="propBacksplashHeight" onchange="updateBacksplashHeight()" style="flex: 1;">
                  <option value="0.333">4" - Standard</option>
                  <option value="0.5">6" - Raised</option>
                  <option value="1">12" - Half Height</option>
                  <option value="1.5">18" - Full (to Wall Cabs)</option>
                  <option value="custom">Custom...</option>
                </select>
              </div>
            </div>
            <div class="property-row" id="customBacksplashHeightRow" style="display: none;">
              <span class="property-label">Height (inches)</span>
              <input type="number" class="property-input" id="propCustomBacksplashHeight" step="1" min="2" max="24" onchange="applyCustomBacksplashHeight()">
              <span class="dimension-display" id="propBacksplashHeightDisplay"></span>
            </div>
            <!-- Tile type for backsplash -->
            <div class="property-row" id="tileTypeRow" style="display: none;">
              <span class="property-label">Tile Pattern</span>
              <select class="property-select" id="propTileType" onchange="updateTileType()">
                <option value="standard">Standard (4"4")</option>
                <option value="subway">Subway (3"6")</option>
                <option value="mosaic">Mosaic (1"1")</option>
                <option value="herringbone">Herringbone</option>
                <option value="chevron">Chevron</option>
                <option value="hexagon">Hexagon</option>
              </select>
            </div>
            <!-- Stone surface thickness controls -->
            <div class="property-row" id="stoneThicknessRow" style="display: none;">
              <span class="property-label">Stone Thickness</span>
              <div style="display: flex; align-items: center; gap: 8px;">
                <select class="property-select" id="propStoneThickness" onchange="updateStoneThickness()" style="flex: 1;">
                  <option value="0.0625">3/4" (2cm)</option>
                  <option value="0.1">1.25" (3cm)</option>
                  <option value="0.125">1.5"</option>
                  <option value="0.17">2"</option>
                  <option value="0.25">3"</option>
                </select>
              </div>
            </div>
            <!-- Cap height control for wall caps/bar tops -->
            <div class="property-row" id="capHeightRow" style="display: none;">
              <span class="property-label">Cap Height</span>
              <div style="display: flex; align-items: center; gap: 8px;">
                <select class="property-select" id="propCapHeight" onchange="updateCapHeight()" style="flex: 1;">
                  <option value="2">2' (24") - Knee wall</option>
                  <option value="2.5">2.5' (30")</option>
                  <option value="3">3' (36") - Standard counter</option>
                  <option value="3.5">3.5' (42") - Pony wall</option>
                  <option value="4">4' (48") - Bar height</option>
                  <option value="custom">Custom...</option>
                </select>
              </div>
            </div>
            <div class="property-row" id="customCapHeightRow" style="display: none;">
              <span class="property-label">Height (ft)</span>
              <input type="number" class="property-input" id="propCustomCapHeight" step="0.0833" min="0.5" max="8" onchange="applyCustomCapHeight()">
              <span class="dimension-display" id="propCapHeightDisplay"></span>
            </div>
            <!-- Edge preview button -->
            <div class="property-row" id="edgePreviewBtnRow" style="display: none;">
              <button class="btn btn-secondary" style="width: 100%; padding: 8px;" onclick="showEdgePreviewModal(selectedElement)">
                View Edge Profile 3D
              </button>
            </div>
            <div class="property-row" id="edgeProfileRow" style="display: none;">
              <span class="property-label">Edge Profile</span>
              <select class="property-select" id="propEdgeProfile" onchange="updateSelectedEdgeProfile()">
                <optgroup label=" Most Durable">
                  <option value="full-bullnose">Full Bullnose - Fully rounded, nearly indestructible</option>
                  <option value="half-bullnose">Half Bullnose - Rounded top, flat bottom</option>
                </optgroup>
                <optgroup label=" Durable">
                  <option value="eased">Eased (Standard) - Slight round on top edge</option>
                  <option value="flat-polish">Flat Polish - Square edge, polished face</option>
                  <option value="pencil">Pencil Round - Very small radius</option>
                  <option value="quarter-round">Quarter Round - Quarter circle top</option>
                  <option value="quarter-bevel">Quarter Bevel - 45 chamfer top</option>
                </optgroup>
                <optgroup label=" Laminated (2cm buildup)">
                  <option value="mitered">Mitered Edge - 45 laminated, appears thicker</option>
                </optgroup>
                <optgroup label=" Decorative">
                  <option value="dupont">Dupont (+$30/LF) - Stepped with bullnose</option>
                  <option value="cove">Cove (+$20/LF) - Concave inward curve</option>
                  <option value="ogee">Ogee (+$25/LF) - Classic S-curve</option>
                  <option value="double-ogee">Double Ogee (+$35/LF) - Double S-curve</option>
                  <option value="chiseled">Chiseled (+$40/LF) - Rough textured</option>
                </optgroup>
                <optgroup label=" Waterfall">
                  <option value="waterfall">Waterfall - 90 turn with mitered corner</option>
                </optgroup>
              </select>
            </div>
            <!-- Edge profile info -->
            <div class="property-row" id="edgeProfileInfoRow" style="display: none;">
              <div id="edgeProfileInfo" style="font-size: 11px; color: rgba(255,255,255,0.6); padding: 6px 8px; background: rgba(0,0,0,0.2); border-radius: 4px; line-height: 1.4;"></div>
            </div>
            <div class="property-row" id="thicknessRow" style="display: none;">
              <span class="property-label">Slab Thickness</span>
              <select class="property-select" id="propThickness" onchange="updateCountertopThickness()">
                <option value="3cm">3cm (1.25") - Standard</option>
                <option value="2cm">2cm (0.75") - Requires Edge Buildup</option>
              </select>
            </div>
            <div class="property-row" id="edgeStyleRow" style="display: none;">
              <span class="property-label">Edge Buildup (2cm)</span>
              <select class="property-select" id="propEdgeStyle" onchange="updateCountertopThickness()">
                <option value="laminated">Laminated (4cm look)</option>
                <option value="mitered">Mitered (45 seam)</option>
                <option value="stacked">Stacked (vertical seam)</option>
              </select>
            </div>
            <!-- Waterfall Sides - Always visible prominent option for countertops -->
            <div class="property-row waterfall-section-header" id="waterfallSectionRow" style="display: none;">
              <div style="width: 100%; padding: 8px 0; border-top: 1px solid rgba(255,255,255,0.1); margin-top: 8px;">
                <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 10px;">
                  <span style="font-weight: 600; color: #f9cb00; font-size: 13px;">WATERFALL SIDES</span>
                  <span style="font-size: 11px; color: rgba(255,255,255,0.5);">Stone drops to floor</span>
                </div>
                <div class="checkbox-group" style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                  <label class="waterfall-checkbox-label" style="display: flex; align-items: center; gap: 6px; padding: 8px 12px; background: rgba(255,255,255,0.05); border-radius: 6px; cursor: pointer; transition: all 0.2s;">
                    <input type="checkbox" id="propWaterfallLeft" onchange="updateWaterfallSides()" style="width: 18px; height: 18px; accent-color: #f9cb00;">
                    <span style="font-size: 13px;">Left Side</span>
                  </label>
                  <label class="waterfall-checkbox-label" style="display: flex; align-items: center; gap: 6px; padding: 8px 12px; background: rgba(255,255,255,0.05); border-radius: 6px; cursor: pointer; transition: all 0.2s;">
                    <input type="checkbox" id="propWaterfallRight" onchange="updateWaterfallSides()" style="width: 18px; height: 18px; accent-color: #f9cb00;">
                    <span style="font-size: 13px;">Right Side</span>
                  </label>
                  <label class="waterfall-checkbox-label" style="display: flex; align-items: center; gap: 6px; padding: 8px 12px; background: rgba(255,255,255,0.05); border-radius: 6px; cursor: pointer; transition: all 0.2s;">
                    <input type="checkbox" id="propWaterfallFront" onchange="updateWaterfallSides()" style="width: 18px; height: 18px; accent-color: #f9cb00;">
                    <span style="font-size: 13px;">Front</span>
                  </label>
                  <label class="waterfall-checkbox-label" style="display: flex; align-items: center; gap: 6px; padding: 8px 12px; background: rgba(255,255,255,0.05); border-radius: 6px; cursor: pointer; transition: all 0.2s;">
                    <input type="checkbox" id="propWaterfallBack" onchange="updateWaterfallSides()" style="width: 18px; height: 18px; accent-color: #f9cb00;">
                    <span style="font-size: 13px;">Back</span>
                  </label>
                </div>
              </div>
            </div>
            <div class="property-row" id="waterfallHeightRow" style="display: none;">
              <span class="property-label">Waterfall Drop</span>
              <select class="property-select" id="propWaterfallHeight" onchange="updateWaterfallHeight()">
                <option value="2.5">2.5' (30") - Counter height</option>
                <option value="2.9" selected>2.9' (35") - Standard</option>
                <option value="3">3' (36") - Island height</option>
                <option value="floor">To Floor</option>
                <option value="custom">Custom...</option>
              </select>
            </div>
            <!-- Legacy waterfall row (hidden, kept for compatibility) -->
            <div class="property-row" id="waterfallRow" style="display: none;"></div>
            <!-- Overhang Controls for Islands, Bars, etc. -->
            <div class="property-row overhang-section" id="overhangSectionRow" style="display: none;">
              <div style="width: 100%; padding: 8px 0; border-top: 1px solid rgba(255,255,255,0.1); margin-top: 8px;">
                <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 10px;">
                  <span style="font-weight: 600; color: #4ade80; font-size: 13px;">OVERHANG</span>
                  <select class="property-select" id="propOverhangPreset" onchange="applyOverhangPreset()" style="width: auto; padding: 4px 8px; font-size: 11px;">
                    <option value="">Custom</option>
                    <option value="standard">Standard (2" front)</option>
                    <option value="island">Island (2" all)</option>
                    <option value="bar">Bar Seating (12")</option>
                    <option value="breakfast">Breakfast Bar (15")</option>
                    <option value="ada">ADA Accessible (19")</option>
                  </select>
                </div>
                <!-- Fabrication warning area -->
                <div id="overhangWarning" style="display: none; background: rgba(245, 158, 11, 0.15); border: 1px solid rgba(245, 158, 11, 0.3); border-radius: 6px; padding: 8px; margin-bottom: 10px; font-size: 11px;">
                  <div style="display: flex; align-items: flex-start; gap: 6px;">
                    <span style="color: #f59e0b;"></span>
                    <div id="overhangWarningText" style="color: #fbbf24; line-height: 1.4;"></div>
                  </div>
                </div>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                  <div style="display: flex; flex-direction: column; gap: 4px;">
                    <label style="font-size: 11px; color: rgba(255,255,255,0.6);">Front</label>
                    <div style="display: flex; align-items: center; gap: 4px;">
                      <input type="number" id="propOverhangFront" min="0" max="24" step="0.5" value="2"
                        onchange="updateOverhang()" style="width: 60px; padding: 6px; border-radius: 4px; border: 1px solid rgba(255,255,255,0.2); background: rgba(0,0,0,0.3); color: #fff; font-size: 12px;">
                      <span style="font-size: 11px; color: rgba(255,255,255,0.5);">in</span>
                    </div>
                  </div>
                  <div style="display: flex; flex-direction: column; gap: 4px;">
                    <label style="font-size: 11px; color: rgba(255,255,255,0.6);">Back</label>
                    <div style="display: flex; align-items: center; gap: 4px;">
                      <input type="number" id="propOverhangBack" min="0" max="24" step="0.5" value="0"
                        onchange="updateOverhang()" style="width: 60px; padding: 6px; border-radius: 4px; border: 1px solid rgba(255,255,255,0.2); background: rgba(0,0,0,0.3); color: #fff; font-size: 12px;">
                      <span style="font-size: 11px; color: rgba(255,255,255,0.5);">in</span>
                    </div>
                  </div>
                  <div style="display: flex; flex-direction: column; gap: 4px;">
                    <label style="font-size: 11px; color: rgba(255,255,255,0.6);">Left</label>
                    <div style="display: flex; align-items: center; gap: 4px;">
                      <input type="number" id="propOverhangLeft" min="0" max="24" step="0.5" value="1.5"
                        onchange="updateOverhang()" style="width: 60px; padding: 6px; border-radius: 4px; border: 1px solid rgba(255,255,255,0.2); background: rgba(0,0,0,0.3); color: #fff; font-size: 12px;">
                      <span style="font-size: 11px; color: rgba(255,255,255,0.5);">in</span>
                    </div>
                  </div>
                  <div style="display: flex; flex-direction: column; gap: 4px;">
                    <label style="font-size: 11px; color: rgba(255,255,255,0.6);">Right</label>
                    <div style="display: flex; align-items: center; gap: 4px;">
                      <input type="number" id="propOverhangRight" min="0" max="24" step="0.5" value="1.5"
                        onchange="updateOverhang()" style="width: 60px; padding: 6px; border-radius: 4px; border: 1px solid rgba(255,255,255,0.2); background: rgba(0,0,0,0.3); color: #fff; font-size: 12px;">
                      <span style="font-size: 11px; color: rgba(255,255,255,0.5);">in</span>
                    </div>
                  </div>
                </div>
              </div>
            </div>
            <div class="property-row" id="backsplashRow" style="display: none;">
              <span class="property-label">Backsplash</span>
              <select class="property-select" id="propBacksplash" onchange="updateBacksplash()">
                <option value="none">None</option>
                <option value="4">4" Standard</option>
                <option value="6">6" Raised</option>
                <option value="18">18" Mid-Height</option>
                <option value="full">Full Height</option>
              </select>
            </div>
            <div class="property-row" id="finishedEndsRow" style="display: none;">
              <span class="property-label">Finished Ends</span>
              <div class="checkbox-group">
                <label><input type="checkbox" id="propFinishedLeft" onchange="updateFinishedEnds()"> Left</label>
                <label><input type="checkbox" id="propFinishedRight" onchange="updateFinishedEnds()"> Right</label>
              </div>
            </div>
            <div class="property-row" id="seamsRow" style="display: none;">
              <span class="property-label">Seams & Slabs</span>
              <div style="display: flex; flex-direction: column; gap: 8px; width: 100%;">
                <!-- Slab Dimensions Info -->
                <div id="slabDimensionsInfo" style="font-size: 11px; padding: 8px; background: rgba(59, 130, 246, 0.1); border-radius: 4px; border-left: 3px solid #3b82f6;">
                  <div style="color: #93c5fd; margin-bottom: 4px; font-weight: 600;"> Slab Sizes</div>
                  <div style="color: #bfdbfe; line-height: 1.5;">
                    <div>Standard: <strong>120"  60"</strong> (10'  5')</div>
                    <div>Jumbo: <strong>130"  68"</strong> (10'10"  5'8")</div>
                  </div>
                </div>
                <!-- Countertop Dimensions -->
                <div id="countertopDimensionsInfo" style="font-size: 11px; padding: 8px; background: rgba(16, 185, 129, 0.1); border-radius: 4px; border-left: 3px solid #10b981;">
                  <div style="color: #6ee7b7; margin-bottom: 4px; font-weight: 600;"> This Countertop</div>
                  <div style="color: #a7f3d0; line-height: 1.5;">
                    <span id="ctopDimensions">--  --</span>
                    <span id="ctopSeamStatus" style="margin-left: 8px; padding: 2px 6px; border-radius: 3px; font-size: 10px;"></span>
                  </div>
                </div>
                <!-- Seam Controls -->
                <div class="seam-controls">
                  <button class="seam-btn" onclick="addSeamToCountertop()" title="Add seam at optimal position">+ Auto</button>
                  <button class="seam-btn" id="seamPlaceModeBtn" onclick="toggleSeamPlacementMode()"
                    style="background: rgba(139, 92, 246, 0.3);" title="Click on countertop to place seam"> Click to Place</button>
                  <span class="seam-count" id="seamCount">0 seams</span>
                  <button class="seam-btn seam-clear" onclick="clearSeams()" title="Remove all seams">Clear</button>
                </div>
                <!-- Individual Seam List -->
                <div id="seamListContainer" style="display: none; max-height: 150px; overflow-y: auto;">
                  <div id="seamList" style="display: flex; flex-direction: column; gap: 4px;"></div>
                </div>
                <!-- Piece Dimensions After Seams -->
                <div id="pieceDimensionsInfo" style="display: none; font-size: 11px; padding: 8px; background: rgba(245, 158, 11, 0.1); border-radius: 4px; border-left: 3px solid #f59e0b;">
                  <div style="color: #fcd34d; margin-bottom: 4px; font-weight: 600;"> Resulting Pieces</div>
                  <div id="piecesList" style="color: #fde68a; line-height: 1.5;"></div>
                </div>
                <!-- Seam Requirement Warning -->
                <div id="seamRequirementInfo" style="display: none; font-size: 11px; padding: 6px 8px; background: rgba(239, 68, 68, 0.15); border-radius: 4px; border-left: 3px solid #ef4444;">
                  <span id="seamRequirementText" style="color: #fca5a5; line-height: 1.4;"></span>
                </div>
              </div>
            </div>
            <!-- Sink-specific properties -->
            <div class="property-row" id="sinkColorRow" style="display: none;">
              <span class="property-label">Sink Finish</span>
              <select class="property-select" id="propSinkColor" onchange="updateSinkProperties()">
                <option value="stainless">Stainless Steel</option>
                <option value="black">Matte Black</option>
                <option value="white">White</option>
                <option value="graphite">Graphite</option>
                <option value="bisque">Bisque</option>
                <option value="bronze">Oil-Rubbed Bronze</option>
              </select>
            </div>
            <div class="property-row" id="sinkMountRow" style="display: none;">
              <span class="property-label">Mount Type</span>
              <select class="property-select" id="propSinkMount" onchange="updateSinkProperties()">
                <option value="undermount">Undermount</option>
                <option value="topmount">Top Mount</option>
                <option value="farmhouse">Farmhouse/Apron</option>
              </select>
            </div>
            <div class="property-row">
              <span class="property-label">Color</span>
              <input type="color" class="color-picker" id="propColor" onchange="updateSelectedElement()">
            </div>
            <div class="property-row">
              <span class="property-label">Texture</span>
              <div class="texture-controls">
                <div class="texture-preview" id="propTexture" onclick="openMaterialPicker()" title="Click to browse materials"></div>
                <button class="texture-upload-btn" onclick="quickUploadTexture()" title="Upload custom image">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                    <polyline points="17 8 12 3 7 8"/>
                    <line x1="12" y1="3" x2="12" y2="15"/>
                  </svg>
                </button>
                <button class="texture-clear-btn" onclick="clearTexture()" title="Clear texture"></button>
              </div>
            </div>
            <div class="property-row" id="materialNameRow" style="display: none;">
              <span class="property-label">Material</span>
              <span class="property-value" id="propMaterialName" style="font-size: 12px; color: var(--primary-color);">-</span>
            </div>
            <div class="property-row">
              <span class="property-label">Rotation</span>
              <span class="property-value" id="propRotation">0</span>
            </div>
            <div class="property-row" id="areaMeasureRow">
              <span class="property-label">Area</span>
              <span class="property-value" id="propArea" style="font-size: 11px; color: rgba(255,255,255,0.7);">-</span>
            </div>
            <div class="property-row" id="perimeterMeasureRow">
              <span class="property-label">Perimeter</span>
              <span class="property-value" id="propPerimeter" style="font-size: 11px; color: rgba(255,255,255,0.7);">-</span>
            </div>
            <div class="property-row" id="grainDirectionRow" style="display: none;">
              <span class="property-label">Grain/Tile Dir</span>
              <div class="grain-direction-controls">
                <button class="grain-btn" data-dir="0" onclick="setGrainDirection(0)" title="Horizontal ()"></button>
                <button class="grain-btn" data-dir="90" onclick="setGrainDirection(90)" title="Vertical ()"></button>
                <button class="grain-btn" data-dir="45" onclick="setGrainDirection(45)" title="Diagonal ()"></button>
                <button class="grain-btn" data-dir="135" onclick="setGrainDirection(135)" title="Diagonal ()"></button>
              </div>
            </div>

            <!-- Structural Element Controls -->
            <div class="property-row" id="beamDepthRow" style="display: none;">
              <span class="property-label">Beam Depth</span>
              <select class="property-select" id="propBeamDepth" onchange="updateBeamDepth()">
                <option value="0.33">4" (Header)</option>
                <option value="0.5">6" (W6)</option>
                <option value="0.67">8" (W8)</option>
                <option value="0.83">10" (W10)</option>
                <option value="1">12" (W12)</option>
                <option value="1.17">14" (W14)</option>
                <option value="custom">Custom...</option>
              </select>
            </div>
            <div class="property-row" id="customBeamDepthRow" style="display: none;">
              <span class="property-label">Custom Depth</span>
              <div class="dimension-input-group">
                <input type="text" class="property-input dimension-input" id="propCustomBeamDepth" placeholder="0.67" onchange="applyCustomBeamDepth()">
                <span class="dimension-display" id="propBeamDepthDisplay"></span>
              </div>
            </div>
            <div class="property-row" id="beamElevationRow" style="display: none;">
              <span class="property-label">Elevation</span>
              <select class="property-select" id="propBeamElevation" onchange="updateBeamElevation()">
                <option value="ceiling">At Ceiling</option>
                <option value="7">7' (84")</option>
                <option value="7.5">7'-6" (90")</option>
                <option value="8">8' (96")</option>
                <option value="9">9' (108")</option>
                <option value="10">10' (120")</option>
                <option value="custom">Custom...</option>
              </select>
            </div>
            <div class="property-row" id="customBeamElevationRow" style="display: none;">
              <span class="property-label">Custom Elev</span>
              <div class="dimension-input-group">
                <input type="text" class="property-input dimension-input" id="propCustomBeamElevation" placeholder="8" onchange="applyCustomBeamElevation()">
                <span class="dimension-display" id="propBeamElevationDisplay"></span>
              </div>
            </div>
            <div class="property-row" id="columnHeightRow" style="display: none;">
              <span class="property-label">Column Height</span>
              <select class="property-select" id="propColumnHeight" onchange="updateColumnHeight()">
                <option value="ceiling">Floor to Ceiling</option>
                <option value="8">8' (96")</option>
                <option value="9">9' (108")</option>
                <option value="10">10' (120")</option>
                <option value="12">12' (144")</option>
                <option value="custom">Custom...</option>
              </select>
            </div>
            <div class="property-row" id="customColumnHeightRow" style="display: none;">
              <span class="property-label">Custom Height</span>
              <div class="dimension-input-group">
                <input type="text" class="property-input dimension-input" id="propCustomColumnHeight" placeholder="8" onchange="applyCustomColumnHeight()">
                <span class="dimension-display" id="propColumnHeightDisplay"></span>
              </div>
            </div>
            <div class="property-row" id="columnSizeRow" style="display: none;">
              <span class="property-label">Column Size</span>
              <select class="property-select" id="propColumnSize" onchange="updateColumnSize()">
                <option value="0.33">4"4" (Post)</option>
                <option value="0.5">6"6" (HSS 6)</option>
                <option value="0.67">8"8" (HSS 8)</option>
                <option value="1">12"12" (Concrete)</option>
                <option value="1.33">16"16" (Large)</option>
                <option value="custom">Custom...</option>
              </select>
            </div>

            <!-- Surface Finish Picker -->
            <div class="property-row" id="finishRow" style="display:none">
              <span class="property-label">Finish</span>
              <div id="finishPicker" class="finish-picker"></div>
            </div>
            <!-- Generic 3D Height Override -->
            <div class="property-row" id="generic3DHeightRow" style="display:none">
              <span class="property-label">3D Height</span>
              <div style="display: flex; align-items: center; gap: 8px;">
                <select class="property-select" id="propGeneric3DHeight" onchange="updateGeneric3DHeight()" style="flex: 1;">
                  <option value="default">Default</option>
                  <option value="0.5">6" (0.5')</option>
                  <option value="1">12" (1')</option>
                  <option value="1.5">18" (1.5')</option>
                  <option value="2">24" (2')</option>
                  <option value="2.5">30" (2.5')</option>
                  <option value="3">36" (3')</option>
                  <option value="3.5">42" (3.5')</option>
                  <option value="4">48" (4')</option>
                  <option value="5">60" (5')</option>
                  <option value="6">72" (6')</option>
                  <option value="7">84" (7')</option>
                  <option value="8">96" (8')</option>
                  <option value="custom">Custom...</option>
                </select>
              </div>
            </div>
            <div class="property-row" id="customGeneric3DHeightRow" style="display:none">
              <span class="property-label">Height (ft)</span>
              <input type="number" class="property-input" id="propCustomGeneric3DHeight" step="0.0833" min="0.1" max="20" onchange="applyCustomGeneric3DHeight()">
            </div>
            <!-- Pricing Section -->
            <div class="pricing-section" id="pricingSection">
              <div class="property-section-title">Pricing</div>
              <div class="property-row">
                <span class="property-label">Base Price</span>
                <span class="property-value" id="propBasePrice">$0.00</span>
              </div>
              <div class="property-row">
                <span class="property-label">Override</span>
                <div class="price-override-group">
                  <input type="number" class="property-input price-input" id="propPriceOverride" placeholder="Auto" step="0.01" min="0" onchange="updateElementPrice()">
                  <select class="property-select-sm" id="propPriceUnit" onchange="updateElementPrice()">
                    <option value="sqft">/sqft</option>
                    <option value="linear_ft">/lf</option>
                    <option value="unit">each</option>
                  </select>
                </div>
              </div>
              <div class="property-row">
                <span class="property-label">Margin %</span>
                <input type="number" class="property-input margin-input" id="propMargin" placeholder="Default" step="1" min="0" max="200" onchange="updateElementPrice()">
              </div>
              <div class="property-row price-result">
                <span class="property-label">Item Total</span>
                <span class="property-value price-highlight" id="propItemTotal">$0.00</span>
              </div>
            </div>
          </div>
        </div>

        <!-- Building Code Validation -->
        <div class="validation-section" id="validationPanel">
          <div class="panel-section">
            <div class="panel-title">
              Building Standards
              <button class="validation-toggle" onclick="toggleWorkTriangle()" title="Toggle work triangle"></button>
              <button class="validation-refresh" onclick="runValidation()" title="Check design"></button>
            </div>
          </div>
          <div class="validation-content" id="validationContent">
            <div class="validation-hint">Click  to validate your design</div>
          </div>
        </div>

        <div class="quote-section" id="quotePanel">
          <div class="panel-section">
            <div class="quote-header">
              <div class="panel-title">Takeoff Summary</div>
              <div class="quote-view-toggle">
                <button class="toggle-btn active" id="retailViewBtn" onclick="setQuoteView('retail')" title="Show retail prices">Retail</button>
                <button class="toggle-btn" id="costViewBtn" onclick="setQuoteView('cost')" title="Show cost prices">Cost</button>
              </div>
            </div>
          </div>
          <!-- Quick Takeoff Stats -->
          <div id="takeoffQuickStats" style="padding: 0 12px 12px; display: none;">
            <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px;">
              <div style="background: rgba(99, 102, 241, 0.15); border: 1px solid rgba(99, 102, 241, 0.3); border-radius: 8px; padding: 10px; text-align: center;">
                <div style="font-size: 20px; font-weight: 700; color: #818cf8;" id="quickSlabCount">0</div>
                <div style="font-size: 10px; color: rgba(255,255,255,0.6); text-transform: uppercase;">Slabs</div>
              </div>
              <div style="background: rgba(16, 185, 129, 0.15); border: 1px solid rgba(16, 185, 129, 0.3); border-radius: 8px; padding: 10px; text-align: center;">
                <div style="font-size: 20px; font-weight: 700; color: #34d399;" id="quickCabinetCount">0</div>
                <div style="font-size: 10px; color: rgba(255,255,255,0.6); text-transform: uppercase;">Cabinets</div>
              </div>
            </div>
            <button class="btn btn-sm btn-secondary" onclick="generateTakeoffReport()" style="width: 100%; margin-top: 8px; font-size: 11px;">
              View Full Takeoffs 
            </button>
          </div>
          <!-- Room Selector -->
          <div class="room-selector-bar" style="padding: 8px 12px; border-bottom: 1px solid var(--border);">
            <div style="display: flex; align-items: center; gap: 8px;">
              <select id="currentRoomSelect" class="property-select" style="flex: 1; font-size: 12px;" onchange="switchRoom(this.value)">
                <option value="default">Default Room</option>
              </select>
              <button class="btn btn-sm btn-icon" onclick="openRoomManager()" title="Manage Rooms">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:14px;height:14px;">
                  <rect x="3" y="3" width="7" height="7"/><rect x="14" y="3" width="7" height="7"/>
                  <rect x="3" y="14" width="7" height="7"/><rect x="14" y="14" width="7" height="7"/>
                </svg>
              </button>
            </div>
          </div>
          <div class="quote-actions">
            <button class="btn btn-sm btn-secondary" onclick="openPriceListModal()" title="Upload or manage price lists">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:14px;height:14px;margin-right:4px;">
                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                <polyline points="17 8 12 3 7 8"/>
                <line x1="12" y1="3" x2="12" y2="15"/>
              </svg>
              Price List
            </button>
            <button class="btn btn-sm btn-secondary" onclick="openMarginModal()" title="Configure profit margins">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:14px;height:14px;margin-right:4px;">
                <line x1="19" y1="5" x2="5" y2="19"/>
                <circle cx="6.5" cy="6.5" r="2.5"/>
                <circle cx="17.5" cy="17.5" r="2.5"/>
              </svg>
              Margins
            </button>
          </div>
          <div class="quote-items" id="quoteItems">
            <div class="quote-item">
              <span class="quote-item-name">No items yet</span>
              <span class="quote-item-value">$0</span>
            </div>
          </div>
          <div class="quote-summary">
            <div class="quote-row" id="quoteCostRow" style="display: none;">
              <span>Material Cost</span>
              <span id="quoteCost">$0.00</span>
            </div>
            <div class="quote-row" id="quoteMarginRow" style="display: none;">
              <span>Markup</span>
              <span id="quoteMargin">$0.00</span>
            </div>
            <div class="quote-total">
              <div class="quote-total-row">
                <span class="quote-total-label">Estimated Total</span>
                <span class="quote-total-value" id="quoteTotal">$0</span>
              </div>
            </div>
            <!-- Quote Actions -->
            <div class="quote-send-actions" id="quoteSendActions" style="margin-top: 12px; display: flex; gap: 8px;">
              <button class="btn btn-primary" onclick="openQuotePreview()" style="flex: 1; font-size: 12px; padding: 10px;">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:14px;height:14px;margin-right:6px;">
                  <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
                  <polyline points="14 2 14 8 20 8"/>
                  <line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/>
                </svg>
                Preview Quote
              </button>
              <button class="btn btn-secondary" onclick="shareQuoteLink()" style="padding: 10px;" title="Get shareable link">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:14px;height:14px;">
                  <circle cx="18" cy="5" r="3"/><circle cx="6" cy="12" r="3"/><circle cx="18" cy="19" r="3"/>
                  <line x1="8.59" y1="13.51" x2="15.42" y2="17.49"/>
                  <line x1="15.41" y1="6.51" x2="8.59" y2="10.49"/>
                </svg>
              </button>
            </div>
            <!-- Payment Actions -->
            <div class="quote-actions" id="quoteActions" style="margin-top: 8px; display: none;">
              <button class="btn-checkout" onclick="openPaymentModal()" id="checkoutBtn">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:16px;height:16px;margin-right:6px;">
                  <rect x="1" y="4" width="22" height="16" rx="2"/><line x1="1" y1="10" x2="23" y2="10"/>
                </svg>
                Pay Deposit & Schedule
              </button>
              <p class="quote-disclaimer">10% deposit required to schedule consultation</p>
            </div>
          </div>
        </div>
      </aside>
    </main>
  </div>

  <!-- Payment Modal -->
  <div class="payment-modal-overlay" id="paymentModal" style="display: none;">
    <div class="payment-modal">
      <div class="payment-modal-header">
        <h2>Complete Your Order</h2>
        <button class="payment-modal-close" onclick="closePaymentModal()">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="20" height="20">
            <line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/>
          </svg>
        </button>
      </div>
      <div class="payment-modal-body">
        <!-- Design Summary -->
        <div class="payment-summary">
          <div class="payment-summary-row">
            <span class="label">Design Name</span>
            <span class="value" id="paymentDesignName">Kitchen Design</span>
          </div>
          <div class="payment-summary-row">
            <span class="label">Countertop Material</span>
            <span class="value" id="paymentMaterial">-</span>
          </div>
          <div class="payment-summary-row">
            <span class="label">Square Footage</span>
            <span class="value" id="paymentSqft">0 sq ft</span>
          </div>
          <div class="payment-summary-row total">
            <span class="label">Project Estimate</span>
            <span class="value" id="paymentTotal">$0</span>
          </div>
        </div>

        <!-- Payment Options -->
        <div class="payment-options">
          <div class="payment-option selected" onclick="selectPaymentOption('deposit')" id="optionDeposit">
            <div class="payment-option-header">
              <span class="payment-option-title">10% Deposit</span>
              <span class="payment-option-amount" id="depositAmount">$0</span>
            </div>
            <p class="payment-option-desc">Reserve your consultation and lock in pricing. Remainder due at installation.</p>
          </div>
          <div class="payment-option" onclick="selectPaymentOption('consultation')" id="optionConsultation">
            <div class="payment-option-header">
              <span class="payment-option-title">Design Consultation</span>
              <span class="payment-option-amount">$99</span>
            </div>
            <p class="payment-option-desc">1-hour in-home or virtual consultation with our design expert. Applied to project if you proceed.</p>
          </div>
          <div class="payment-option" onclick="selectPaymentOption('full')" id="optionFull">
            <div class="payment-option-header">
              <span class="payment-option-title">Full Payment</span>
              <span class="payment-option-amount" id="fullAmount">$0</span>
            </div>
            <p class="payment-option-desc">Pay in full and receive 5% discount. Fastest scheduling priority.</p>
          </div>
        </div>

        <!-- Contact Info -->
        <div class="payment-form-group">
          <label>Email Address</label>
          <input type="email" id="paymentEmail" placeholder="you@example.com" required>
        </div>
        <div class="payment-form-group">
          <label>Phone Number</label>
          <input type="tel" id="paymentPhone" placeholder="(555) 123-4567">
        </div>

        <!-- Submit -->
        <button class="payment-submit" onclick="processPayment()" id="paymentSubmitBtn">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="18" height="18">
            <rect x="1" y="4" width="22" height="16" rx="2"/><line x1="1" y1="10" x2="23" y2="10"/>
          </svg>
          <span id="paymentBtnText">Pay Deposit & Continue</span>
        </button>

        <div class="payment-secure">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <rect x="3" y="11" width="18" height="11" rx="2"/><path d="M7 11V7a5 5 0 0 1 10 0v4"/>
          </svg>
          Secured by Stripe  256-bit encryption
        </div>
      </div>
    </div>
  </div>

  <!-- Context Menu -->
  <div class="context-menu" id="contextMenu" style="display: none;">
    <div class="context-menu-label" id="contextMenuLabel">Element</div>
    <div class="context-menu-item" onclick="contextAction('rotate')">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <path d="M21 2v6h-6"/><path d="M3 12a9 9 0 0 1 15-6.7L21 8"/>
      </svg>
      Rotate 90
    </div>
    <div class="context-menu-item" onclick="contextAction('duplicate')">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <rect x="9" y="9" width="13" height="13" rx="2"/><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/>
      </svg>
      Duplicate
    </div>
    <div class="context-menu-item" id="replaceMenuItem" onclick="contextAction('replace')" style="display: none;">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <path d="M21 12a9 9 0 0 0-9-9 9 9 0 0 0-6.7 3L3 8"/><path d="M3 3v5h5"/><path d="M3 12a9 9 0 0 0 9 9 9 9 0 0 0 6.7-3l2.3-2"/><path d="M16 21v-5h5"/>
      </svg>
      Replace Cabinet...
    </div>
    <div class="context-menu-item" id="resizeMenuItem" onclick="contextAction('resize')" style="display: none;">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <path d="M21 21l-6-6m6 6v-4.8m0 4.8h-4.8"/><path d="M3 16.2V21m0 0h4.8M3 21l6-6"/><path d="M21 7.8V3m0 0h-4.8M21 3l-6 6"/><path d="M3 7.8V3m0 0h4.8M3 3l6 6"/>
      </svg>
      Resize Cabinet...
    </div>
    <div class="context-menu-item" onclick="contextAction('texture')">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <rect x="3" y="3" width="18" height="18" rx="2"/><circle cx="8.5" cy="8.5" r="1.5"/><path d="M21 15l-5-5L5 21"/>
      </svg>
      Change Texture
    </div>
    <div class="context-menu-item" onclick="contextAction('lock')">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <rect x="3" y="11" width="18" height="11" rx="2"/><path d="M7 11V7a5 5 0 0 1 10 0v4"/>
      </svg>
      <span id="lockText">Lock</span>
    </div>
    <div class="context-menu-item" id="groupAdjacentMenuItem" onclick="contextAction('groupAdjacent')">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <rect x="2" y="2" width="8" height="8" rx="1"/><rect x="14" y="2" width="8" height="8" rx="1"/><rect x="2" y="14" width="8" height="8" rx="1"/><path d="M14 17h8M18 14v6"/>
      </svg>
      Group Adjacent Cabinets
    </div>
    <div class="context-menu-item" id="ungroupMenuItem" onclick="contextAction('ungroupCabinets')">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <rect x="2" y="2" width="8" height="8" rx="1"/><rect x="14" y="2" width="8" height="8" rx="1"/><rect x="2" y="14" width="8" height="8" rx="1"/><path d="M14 14l8 8M22 14l-8 8"/>
      </svg>
      Ungroup Cabinets
    </div>
    <div class="context-menu-divider"></div>
    <div class="context-menu-item" onclick="contextAction('front')">Bring to Front</div>
    <div class="context-menu-item" onclick="contextAction('back')">Send to Back</div>
    <div class="context-menu-divider"></div>
    <div class="context-menu-item danger" onclick="contextAction('delete')">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/>
      </svg>
      Delete
    </div>
  </div>

  <!-- Add Room Modal -->
  <div class="modal-overlay" id="addRoomModal" style="display: none;">
    <div class="modal" style="max-width: 400px;">
      <div class="modal-header">
        <h3>Add New Room</h3>
        <button class="close-btn" onclick="closeModal('addRoomModal')">&times;</button>
      </div>
      <div class="modal-body" style="padding: 20px;">
        <div style="display: flex; flex-direction: column; gap: 12px;">
          <div class="input-group">
            <label class="input-label" style="color: rgba(255,255,255,0.7); font-size: 12px; margin-bottom: 4px;">Room Name</label>
            <input type="text" class="input-field" id="addRoomName" placeholder="e.g. Master Bathroom" style="width: 100%;">
          </div>
          <div class="input-group">
            <label class="input-label" style="color: rgba(255,255,255,0.7); font-size: 12px; margin-bottom: 4px;">Room Type</label>
            <select class="input-field" id="addRoomType" style="width: 100%;">
              <option value="kitchen">Kitchen</option>
              <option value="bathroom">Bathroom</option>
              <option value="shower">Shower Room</option>
              <option value="closet">Walk-in Closet</option>
              <option value="laundry">Laundry</option>
              <option value="bedroom">Bedroom</option>
              <option value="living">Living Room</option>
              <option value="office">Office</option>
              <option value="commercial">Commercial</option>
            </select>
          </div>
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
            <div class="input-group">
              <label class="input-label" style="color: rgba(255,255,255,0.7); font-size: 12px; margin-bottom: 4px;">Width (ft)</label>
              <input type="number" class="input-field" id="addRoomWidth" value="12" min="4" max="100" style="width: 100%;">
            </div>
            <div class="input-group">
              <label class="input-label" style="color: rgba(255,255,255,0.7); font-size: 12px; margin-bottom: 4px;">Depth (ft)</label>
              <input type="number" class="input-field" id="addRoomDepth" value="10" min="4" max="100" style="width: 100%;">
            </div>
          </div>
          <button class="btn btn-primary" onclick="submitAddRoom()" style="width: 100%; padding: 10px; margin-top: 8px;">Create Room</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Template Selection Modal (used by mobile menu) -->
  <div class="modal-overlay" id="templateModal" style="display: none;">
    <div class="modal" style="max-width: 480px;">
      <div class="modal-header">
        <h3>Room Templates</h3>
        <button class="close-btn" onclick="closeModal('templateModal')">&times;</button>
      </div>
      <div class="modal-body" style="padding: 20px;">
        <p style="color: rgba(255,255,255,0.6); font-size: 12px; margin-bottom: 16px;">Select a template to load a preset room layout</p>
        <div class="room-templates-grid" style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px;">
          <button class="template-btn" onclick="loadRoomTemplate('kitchen-l'); closeModal('templateModal');" title="L-shaped kitchen">
            <span class="template-icon"></span><span class="template-name">L-Kitchen</span>
          </button>
          <button class="template-btn" onclick="loadRoomTemplate('kitchen-galley'); closeModal('templateModal');" title="Galley kitchen">
            <span class="template-icon"></span><span class="template-name">Galley</span>
          </button>
          <button class="template-btn" onclick="loadRoomTemplate('kitchen-u'); closeModal('templateModal');" title="U-shaped kitchen">
            <span class="template-icon"></span><span class="template-name">U-Kitchen</span>
          </button>
          <button class="template-btn" onclick="loadRoomTemplate('kitchen-single'); closeModal('templateModal');" title="Single wall kitchen">
            <span class="template-icon"></span><span class="template-name">Single Wall</span>
          </button>
          <button class="template-btn" onclick="loadRoomTemplate('kitchen-peninsula'); closeModal('templateModal');" title="Peninsula kitchen">
            <span class="template-icon"></span><span class="template-name">Peninsula</span>
          </button>
          <button class="template-btn" onclick="loadRoomTemplate('bathroom-master'); closeModal('templateModal');" title="Master bathroom">
            <span class="template-icon"></span><span class="template-name">Master Bath</span>
          </button>
          <button class="template-btn" onclick="loadRoomTemplate('bathroom-half'); closeModal('templateModal');" title="Half bathroom">
            <span class="template-icon"></span><span class="template-name">Half Bath</span>
          </button>
          <button class="template-btn" onclick="loadRoomTemplate('shower-walkin'); closeModal('templateModal');" title="Walk-in shower">
            <span class="template-icon"></span><span class="template-name">Walk-in Shower</span>
          </button>
          <button class="template-btn" onclick="loadRoomTemplate('closet-walkin'); closeModal('templateModal');" title="Walk-in closet">
            <span class="template-icon"></span><span class="template-name">Walk-in Closet</span>
          </button>
          <button class="template-btn" onclick="loadRoomTemplate('laundry-room'); closeModal('templateModal');" title="Laundry room">
            <span class="template-icon"></span><span class="template-name">Laundry</span>
          </button>
          <button class="template-btn" onclick="loadRoomTemplate('bathroom-master-full'); closeModal('templateModal');" title="Master bath full luxury">
            <span class="template-icon"></span><span class="template-name">Master Bath Full</span>
          </button>
          <button class="template-btn" onclick="loadRoomTemplate('bathroom-guest'); closeModal('templateModal');" title="Guest bathroom">
            <span class="template-icon"></span><span class="template-name">Guest Bath</span>
          </button>
          <button class="template-btn" onclick="loadRoomTemplate('bathroom-powder'); closeModal('templateModal');" title="Powder room">
            <span class="template-icon"></span><span class="template-name">Powder Room</span>
          </button>
          <button class="template-btn" onclick="loadRoomTemplate('bathroom-jack-jill'); closeModal('templateModal');" title="Jack-and-Jill bathroom">
            <span class="template-icon"></span><span class="template-name">Jack &amp; Jill</span>
          </button>
          <button class="template-btn" onclick="loadRoomTemplate('concept-modern-kitchen-bath'); closeModal('templateModal');" title="Modern kitchen + bath">
            <span class="template-icon"></span><span class="template-name">Kitchen+Bath</span>
          </button>
          <button class="template-btn" onclick="loadRoomTemplate('kitchen-compact'); closeModal('templateModal');" title="Compact studio kitchen">
            <span class="template-icon"></span><span class="template-name">Compact</span>
          </button>
          <button class="template-btn" onclick="loadRoomTemplate('outdoor-kitchen'); closeModal('templateModal');" title="Outdoor kitchen with grill">
            <span class="template-icon"></span><span class="template-name">Outdoor</span>
          </button>
          <button class="template-btn" onclick="loadRoomTemplate('butler-pantry'); closeModal('templateModal');" title="Butler's pantry">
            <span class="template-icon"></span><span class="template-name">Butler's Pantry</span>
          </button>
          <button class="template-btn" onclick="loadRoomTemplate('wet-bar'); closeModal('templateModal');" title="Compact wet bar">
            <span class="template-icon"></span><span class="template-name">Wet Bar</span>
          </button>
          <button class="template-btn" onclick="loadRoomTemplate('bathroom-ada'); closeModal('templateModal');" title="ADA accessible bathroom">
            <span class="template-icon"></span><span class="template-name">ADA Bath</span>
          </button>
          <button class="template-btn" onclick="loadRoomTemplate('bathroom-ensuite'); closeModal('templateModal');" title="En-suite bathroom">
            <span class="template-icon"></span><span class="template-name">En-Suite</span>
          </button>
        </div>
      </div>
    </div>
  </div>

  <!-- Cabinet Replace Modal -->
  <div class="modal-overlay" id="replaceCabinetModal" style="display: none;">
    <div class="modal" style="max-width: 400px;">
      <div class="modal-header">
        <h3>Replace Cabinet</h3>
        <button class="close-btn" onclick="closeReplaceCabinetModal()">&times;</button>
      </div>
      <div class="modal-body" style="padding: 20px;">
        <p style="margin-bottom: 16px; color: #666;">Select a new cabinet type to replace the selected cabinet:</p>
        <div style="margin-bottom: 16px;">
          <label style="display: block; margin-bottom: 8px; font-weight: 500;">Cabinet Type:</label>
          <select id="replaceCabinetType" style="width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 8px; font-size: 14px;">
            <optgroup label="Base Cabinets">
              <option value="base-cabinet">Base Cabinet</option>
              <option value="drawer-base">Drawer Base</option>
              <option value="sink-base">Sink Base</option>
              <option value="corner-cabinet">Corner Cabinet</option>
              <option value="lazy-susan">Lazy Susan</option>
              <option value="blind-corner">Blind Corner</option>
            </optgroup>
            <optgroup label="Wall Cabinets">
              <option value="wall-cabinet">Wall Cabinet</option>
            </optgroup>
            <optgroup label="Tall Cabinets">
              <option value="tall-cabinet">Tall Cabinet</option>
              <option value="fridge-cabinet">Refrigerator Cabinet</option>
              <option value="single-oven-cabinet">Single Oven Cabinet</option>
              <option value="double-oven-cabinet">Double Oven Cabinet</option>
            </optgroup>
            <optgroup label="Appliances">
              <option value="dishwasher">Dishwasher</option>
              <option value="range">Range/Stove</option>
              <option value="microwave-cabinet">Microwave Cabinet</option>
            </optgroup>
            <optgroup label="Fillers">
              <option value="filler-3">Filler 3"</option>
              <option value="filler-6">Filler 6"</option>
            </optgroup>
          </select>
        </div>
        <div id="replaceCabinetSize" style="margin-bottom: 16px;">
          <label style="display: block; margin-bottom: 8px; font-weight: 500;">Width:</label>
          <select id="replaceCabinetWidth" style="width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 8px; font-size: 14px;">
            <option value="0.75">9"</option>
            <option value="1">12"</option>
            <option value="1.25">15"</option>
            <option value="1.5">18"</option>
            <option value="1.75">21"</option>
            <option value="2" selected>24"</option>
            <option value="2.25">27"</option>
            <option value="2.5">30"</option>
            <option value="2.75">33"</option>
            <option value="3">36"</option>
            <option value="3.5">42"</option>
            <option value="4">48"</option>
          </select>
        </div>
        <button onclick="applyReplaceCabinet()" style="width: 100%; padding: 12px; background: #f9cb00; border: none; border-radius: 8px; font-weight: 600; cursor: pointer; font-size: 14px;">
          Replace Cabinet
        </button>
      </div>
    </div>
  </div>

  <!-- Cabinet Resize Modal -->
  <div class="modal-overlay" id="resizeCabinetModal" style="display: none;">
    <div class="modal" style="max-width: 400px;">
      <div class="modal-header">
        <h3>Resize Cabinet</h3>
        <button class="close-btn" onclick="closeResizeCabinetModal()">&times;</button>
      </div>
      <div class="modal-body" style="padding: 20px;">
        <p style="margin-bottom: 16px; color: #666;">Select a new size for the selected cabinet:</p>
        <div style="margin-bottom: 16px;">
          <label style="display: block; margin-bottom: 8px; font-weight: 500;">Width:</label>
          <select id="resizeCabinetWidth" style="width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 8px; font-size: 14px;">
            <option value="0.75">9"</option>
            <option value="1">12"</option>
            <option value="1.25">15"</option>
            <option value="1.5">18"</option>
            <option value="1.75">21"</option>
            <option value="2">24"</option>
            <option value="2.25">27"</option>
            <option value="2.5">30"</option>
            <option value="2.75">33"</option>
            <option value="3">36"</option>
            <option value="3.5">42"</option>
            <option value="4">48"</option>
          </select>
        </div>
        <button onclick="applyResizeCabinet()" style="width: 100%; padding: 12px; background: #f9cb00; border: none; border-radius: 8px; font-weight: 600; cursor: pointer; font-size: 14px;">
          Apply Size
        </button>
      </div>
    </div>
  </div>

  <!-- 3D Tooltip -->
  <div id="tooltip3D" style="display: none; position: fixed; background: rgba(0,0,0,0.85); color: white; padding: 8px 12px; border-radius: 6px; font-size: 12px; pointer-events: none; z-index: 10000; max-width: 200px; box-shadow: 0 2px 10px rgba(0,0,0,0.3);">
    <div id="tooltip3DLabel" style="font-weight: bold; margin-bottom: 4px;"></div>
    <div id="tooltip3DSize" style="color: #ccc; font-size: 11px;"></div>
  </div>

  <!-- Share Modal - Enhanced -->
  <div class="modal-overlay" id="shareModal">
    <div class="modal" style="max-width: 500px;">
      <div class="modal-header">
        <h3 class="modal-title">Share Project</h3>
        <button class="modal-close" onclick="closeModal('shareModal')"></button>
      </div>

      <div class="share-status" id="shareStatus">
        <span class="status-indicator"></span>
        <span id="shareStatusText">Not shared yet</span>
      </div>

      <div class="share-link-box">
        <input type="text" class="share-link-input" id="shareLink" readonly placeholder="Generate a share link...">
        <button class="btn btn-secondary" id="copyShareBtn" onclick="copyShareLink()" disabled>Copy</button>
      </div>

      <!-- Social Sharing Buttons -->
      <div class="social-share-section" id="socialShareSection" style="display: none; margin: 16px 0; padding: 12px; background: rgba(255,255,255,0.02); border-radius: 8px;">
        <div style="font-size: 12px; color: var(--text-muted); margin-bottom: 10px;">Share to:</div>
        <div style="display: flex; gap: 10px; flex-wrap: wrap;">
          <button class="social-share-btn" onclick="shareToSocial('email')" title="Share via Email" style="background: #6b7280; color: white; border: none; padding: 8px 14px; border-radius: 6px; cursor: pointer; display: flex; align-items: center; gap: 6px; font-size: 13px;">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"/>
              <polyline points="22,6 12,13 2,6"/>
            </svg>
            Email
          </button>
          <button class="social-share-btn" onclick="shareToSocial('pinterest')" title="Share to Pinterest" style="background: #E60023; color: white; border: none; padding: 8px 14px; border-radius: 6px; cursor: pointer; display: flex; align-items: center; gap: 6px; font-size: 13px;">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
              <path d="M12 0C5.37 0 0 5.37 0 12c0 4.79 2.81 8.92 6.87 10.83-.09-.79-.17-2.01.04-2.87.19-.78 1.22-5.16 1.22-5.16s-.31-.62-.31-1.54c0-1.44.84-2.52 1.88-2.52.89 0 1.31.66 1.31 1.46 0 .89-.57 2.22-.86 3.46-.25 1.03.52 1.87 1.53 1.87 1.84 0 3.25-1.94 3.25-4.73 0-2.47-1.78-4.2-4.32-4.2-2.94 0-4.67 2.21-4.67 4.49 0 .89.34 1.84.77 2.36.08.1.09.19.07.29l-.29 1.18c-.05.19-.15.23-.35.14-1.31-.61-2.13-2.53-2.13-4.07 0-3.32 2.41-6.36 6.95-6.36 3.65 0 6.49 2.6 6.49 6.08 0 3.62-2.28 6.54-5.46 6.54-1.07 0-2.07-.55-2.41-1.21l-.66 2.5c-.24.91-.89 2.05-1.32 2.75.99.31 2.04.47 3.13.47 6.63 0 12-5.37 12-12S18.63 0 12 0z"/>
            </svg>
            Pinterest
          </button>
          <button class="social-share-btn" onclick="shareToSocial('facebook')" title="Share to Facebook" style="background: #1877F2; color: white; border: none; padding: 8px 14px; border-radius: 6px; cursor: pointer; display: flex; align-items: center; gap: 6px; font-size: 13px;">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
              <path d="M24 12.073c0-6.627-5.373-12-12-12s-12 5.373-12 12c0 5.99 4.388 10.954 10.125 11.854v-8.385H7.078v-3.47h3.047V9.43c0-3.007 1.792-4.669 4.533-4.669 1.312 0 2.686.235 2.686.235v2.953H15.83c-1.491 0-1.956.925-1.956 1.874v2.25h3.328l-.532 3.47h-2.796v8.385C19.612 23.027 24 18.062 24 12.073z"/>
            </svg>
            Facebook
          </button>
          <button class="social-share-btn" onclick="shareToSocial('download')" title="Download as Image" style="background: linear-gradient(135deg, #b8860b, #d4a436); color: white; border: none; padding: 8px 14px; border-radius: 6px; cursor: pointer; display: flex; align-items: center; gap: 6px; font-size: 13px;">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
              <polyline points="7 10 12 15 17 10"/>
              <line x1="12" y1="15" x2="12" y2="3"/>
            </svg>
            Download
          </button>
        </div>
      </div>

      <div class="permission-section">
        <h4>Permission Level</h4>
        <div class="permission-options">
          <div class="permission-btn active" data-permission="quote_approval" onclick="setSharePermission('quote_approval', this)">
            <div class="permission-icon" style="background: linear-gradient(135deg, #22c55e, #16a34a);">
              <svg viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2">
                <path d="M9 12l2 2 4-4"/>
                <rect x="3" y="4" width="18" height="16" rx="2"/>
                <path d="M3 10h18"/>
              </svg>
            </div>
            <div class="permission-info">
              <div class="permission-btn-title">Send for Approval</div>
              <div class="permission-btn-desc">Customer reviews quote & pays to approve</div>
            </div>
          </div>

          <div class="permission-btn" data-permission="full_collab" onclick="setSharePermission('full_collab', this)">
            <div class="permission-icon">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/>
                <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/>
              </svg>
            </div>
            <div class="permission-info">
              <div class="permission-btn-title">Full Collaboration</div>
              <div class="permission-btn-desc">Can edit everything including prices</div>
            </div>
          </div>

          <div class="permission-btn" data-permission="quote_view" onclick="setSharePermission('quote_view', this)">
            <div class="permission-icon">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="12" cy="12" r="3"/>
                <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/>
              </svg>
            </div>
            <div class="permission-info">
              <div class="permission-btn-title">Quote View</div>
              <div class="permission-btn-desc">See prices, cannot edit</div>
            </div>
          </div>

          <div class="permission-btn" data-permission="material_view" onclick="setSharePermission('material_view', this)">
            <div class="permission-icon">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <rect x="3" y="3" width="7" height="7"/>
                <rect x="14" y="3" width="7" height="7"/>
                <rect x="14" y="14" width="7" height="7"/>
                <rect x="3" y="14" width="7" height="7"/>
              </svg>
            </div>
            <div class="permission-info">
              <div class="permission-btn-title">Material View</div>
              <div class="permission-btn-desc">See materials only, no prices</div>
            </div>
          </div>

          <div class="permission-btn" data-permission="presentation" onclick="setSharePermission('presentation', this)">
            <div class="permission-icon">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <rect x="2" y="3" width="20" height="14" rx="2"/>
                <line x1="8" y1="21" x2="16" y2="21"/>
                <line x1="12" y1="17" x2="12" y2="21"/>
              </svg>
            </div>
            <div class="permission-info">
              <div class="permission-btn-title">Presentation</div>
              <div class="permission-btn-desc">Client-pretty, no costs shown</div>
            </div>
          </div>
        </div>
      </div>

      <!-- Invite Recipients -->
      <div class="invite-recipients-section" id="inviteSection">
        <div style="font-weight: 600; color: var(--text); margin-bottom: 10px; display: flex; align-items: center; gap: 8px;">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#6366f1" stroke-width="2">
            <path d="M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"/>
            <circle cx="8.5" cy="7" r="4"/>
            <line x1="20" y1="8" x2="20" y2="14"/>
            <line x1="23" y1="11" x2="17" y2="11"/>
          </svg>
          Invite Recipients
        </div>
        <div class="invite-chips-container" id="inviteChips"></div>
        <div class="invite-search-wrapper">
          <input type="text" id="inviteSearchInput"
                 placeholder="Search contacts or type emails (comma-separated)..."
                 autocomplete="off"
                 oninput="searchInviteRecipients(this.value)"
                 onkeydown="handleInviteKeydown(event)"
                 onpaste="handleInvitePaste(event)">
          <div class="invite-search-results" id="inviteSearchResults" style="display:none;"></div>
        </div>
        <div style="font-size: 11px; color: var(--text-muted); margin-top: 6px;">
          Search your CRM or type emails separated by commas
        </div>
        <div class="invite-send-status" id="inviteSendStatus"></div>
      </div>

      <!-- Share to Gallery Option -->
      <div class="gallery-share-option" style="margin: 20px 0; padding: 16px; background: linear-gradient(135deg, rgba(99,102,241,0.05), rgba(79,70,229,0.08)); border-radius: 12px; border: 1px solid rgba(99,102,241,0.2);">
        <label style="display: flex; align-items: flex-start; gap: 12px; cursor: pointer;">
          <input type="checkbox" id="shareToGallery" style="width: 20px; height: 20px; margin-top: 2px; accent-color: #6366f1;">
          <div>
            <div style="font-weight: 600; color: var(--text); margin-bottom: 4px;">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#6366f1" stroke-width="2" style="vertical-align: middle; margin-right: 6px;">
                <rect x="3" y="3" width="18" height="18" rx="2"/>
                <circle cx="8.5" cy="8.5" r="1.5"/>
                <path d="M21 15l-5-5L5 21"/>
              </svg>
              Share to Public Gallery
            </div>
            <div style="font-size: 12px; color: var(--text-muted);">
              Inspire others by showcasing your design in our community gallery. Your company name will be displayed.
            </div>
          </div>
        </label>
      </div>

      <div class="share-actions" style="display: flex; gap: 8px;">
        <button class="btn btn-primary" id="shareInviteBtn" onclick="generateAndInvite()" style="flex: 1;">
          <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align: middle; margin-right: 4px;">
            <path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"/>
            <polyline points="22,6 12,13 2,6"/>
          </svg>
          Send Invitations
        </button>
        <button class="btn btn-secondary" onclick="generateShareLink()" title="Generate link without sending emails">
          Link Only
        </button>
      </div>

      <div class="active-shares" id="activeShares" style="display:none;">
        <h4>Active Share Links</h4>
        <div class="shares-list" id="sharesList"></div>
      </div>

      <div class="recent-activity" id="recentActivity" style="display:none;">
        <h4>Recent Activity</h4>
        <div class="activity-list" id="activityList"></div>
      </div>
    </div>
  </div>

  <!-- My Designs Modal -->
  <div class="modal-overlay" id="myDesignsModal">
    <div class="modal" style="max-width: 800px; max-height: 85vh;">
      <div class="modal-header">
        <h3 class="modal-title">My Designs</h3>
        <button class="modal-close" onclick="closeModal('myDesignsModal')"></button>
      </div>

      <div class="designs-tabs">
        <button class="designs-tab active" onclick="switchDesignsTab('my', this)">My Designs</button>
        <button class="designs-tab" onclick="switchDesignsTab('shared', this)">Shared With Me</button>
        <button class="designs-tab" onclick="switchDesignsTab('recent', this)">Recently Viewed</button>
      </div>

      <div class="designs-search">
        <input type="text" id="designsSearch" placeholder="Search designs..." oninput="filterDesigns(this.value)">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <circle cx="11" cy="11" r="8"/><path d="m21 21-4.35-4.35"/>
        </svg>
      </div>

      <div class="designs-grid" id="designsGrid">
        <div class="designs-loading">Loading designs...</div>
      </div>

      <div class="designs-empty" id="designsEmpty" style="display:none;">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
          <path d="M3 7v10a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-6l-2-2H5a2 2 0 00-2 2z"/>
        </svg>
        <p>No designs found</p>
        <button class="btn btn-primary" onclick="createNewDesign(); closeModal('myDesignsModal');">Create New Design</button>
      </div>

      <div style="margin-top: 16px; padding-top: 16px; border-top: 1px solid var(--border-color); display: flex; gap: 12px;">
        <button class="btn btn-primary" onclick="createNewDesign(); closeModal('myDesignsModal');" style="background: #22c55e;">
          <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="margin-right: 6px;">
            <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
            <polyline points="14 2 14 8 20 8"/>
            <line x1="12" y1="18" x2="12" y2="12"/>
            <line x1="9" y1="15" x2="15" y2="15"/>
          </svg>
          New Design
        </button>
        <button class="btn btn-primary" onclick="saveDesignLocally(); loadMyDesigns();">
          <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="margin-right: 6px;">
            <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/>
            <polyline points="17 21 17 13 7 13 7 21"/>
            <polyline points="7 3 7 8 15 8"/>
          </svg>
          Save Current
        </button>
        <button class="btn btn-secondary" onclick="closeModal('myDesignsModal')">Close</button>
      </div>
    </div>
  </div>

  <!-- Keyboard Shortcuts Modal -->
  <div class="modal-overlay" id="shortcutsModal">
    <div class="modal" style="max-width: 600px;">
      <div class="modal-header">
        <h3 class="modal-title">
          <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="margin-right: 8px;">
            <rect x="2" y="4" width="20" height="16" rx="2"/>
            <path d="M6 8h.01M10 8h.01M14 8h.01M18 8h.01M8 12h.01M12 12h.01M16 12h.01M6 16h8"/>
          </svg>
          Keyboard Shortcuts
        </h3>
        <button class="modal-close" onclick="closeModal('shortcutsModal')"></button>
      </div>
      <div class="modal-body" style="padding: 20px;">
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 24px;">
          <!-- Tools Column -->
          <div>
            <h4 style="color: var(--gold); margin-bottom: 12px; font-size: 13px; text-transform: uppercase; letter-spacing: 0.5px;">Tools</h4>
            <div class="shortcut-list">
              <div class="shortcut-item"><kbd>V</kbd><span>Select Tool</span></div>
              <div class="shortcut-item"><kbd>W</kbd><span>Wall Tool</span></div>
              <div class="shortcut-item"><kbd>C</kbd><span>Countertop Tool</span></div>
              <div class="shortcut-item"><kbd>L</kbd><span>Layout Tool</span></div>
              <div class="shortcut-item"><kbd>M</kbd><span>Measure Tool</span></div>
              <div class="shortcut-item"><kbd>Space</kbd><span>Pan (hold)</span></div>
            </div>
          </div>

          <!-- Actions Column -->
          <div>
            <h4 style="color: var(--gold); margin-bottom: 12px; font-size: 13px; text-transform: uppercase; letter-spacing: 0.5px;">Actions</h4>
            <div class="shortcut-list">
              <div class="shortcut-item"><kbd>Ctrl</kbd>+<kbd>N</kbd><span>New Design</span></div>
              <div class="shortcut-item"><kbd>Ctrl</kbd>+<kbd>Z</kbd><span>Undo</span></div>
              <div class="shortcut-item"><kbd>Ctrl</kbd>+<kbd>Y</kbd><span>Redo</span></div>
              <div class="shortcut-item"><kbd>D</kbd><span>Duplicate Element</span></div>
              <div class="shortcut-item"><kbd>Delete</kbd><span>Delete Selected</span></div>
              <div class="shortcut-item"><kbd>Esc</kbd><span>Deselect / Cancel</span></div>
            </div>
          </div>

          <!-- View Column -->
          <div>
            <h4 style="color: var(--gold); margin-bottom: 12px; font-size: 13px; text-transform: uppercase; letter-spacing: 0.5px;">View</h4>
            <div class="shortcut-list">
              <div class="shortcut-item"><kbd>F</kbd><span>Fit to Screen</span></div>
              <div class="shortcut-item"><kbd>2</kbd><span>2D View</span></div>
              <div class="shortcut-item"><kbd>3</kbd><span>3D View</span></div>
              <div class="shortcut-item"><kbd>+</kbd><span>Zoom In</span></div>
              <div class="shortcut-item"><kbd>-</kbd><span>Zoom Out</span></div>
              <div class="shortcut-item"><kbd>G</kbd><span>Toggle Grid</span></div>
            </div>
          </div>

          <!-- Element Column -->
          <div>
            <h4 style="color: var(--gold); margin-bottom: 12px; font-size: 13px; text-transform: uppercase; letter-spacing: 0.5px;">Elements</h4>
            <div class="shortcut-list">
              <div class="shortcut-item"><kbd>R</kbd><span>Rotate 90</span></div>
              <div class="shortcut-item"><kbd>X</kbd><span>Flip/Swap Dimensions</span></div>
              <div class="shortcut-item"><kbd></kbd><span>Nudge (3")</span></div>
              <div class="shortcut-item"><kbd>Shift</kbd>+<kbd></kbd><span>Fine Nudge (1")</span></div>
              <div class="shortcut-item"><kbd>Ctrl</kbd>+<kbd></kbd><span>Big Nudge (1')</span></div>
              <div class="shortcut-item"><kbd>Shift</kbd>+<kbd>Drag</kbd><span>Free Place (no snap)</span></div>
              <div class="shortcut-item"><kbd>T</kbd><span>Cycle Panel Tabs</span></div>
            </div>
          </div>
        </div>

        <div style="margin-top: 20px; padding-top: 16px; border-top: 1px solid var(--border-color); text-align: center; color: var(--text-muted); font-size: 12px;">
          Press <kbd>?</kbd> or <kbd>F1</kbd> anytime to show this help
        </div>
      </div>
    </div>
  </div>

  <!-- Push Notification Toast -->
  <div class="notification-toast" id="notificationToast">
    <div class="notification-icon">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"/>
      </svg>
    </div>
    <div class="notification-content">
      <div class="notification-title" id="notificationTitle">New Message</div>
      <div class="notification-body" id="notificationBody">You have a new message</div>
    </div>
    <button class="notification-close" onclick="hideNotification()"></button>
  </div>

  <!-- Edge Preview Modal -->
  <div class="modal-overlay" id="edgePreviewModal">
    <div class="modal" style="max-width: 500px; background: var(--surface-secondary);">
      <div class="modal-header">
        <h3 class="modal-title">Edge Profile Preview</h3>
        <button class="modal-close" onclick="closeEdgePreview()"></button>
      </div>
      <div class="modal-body" style="padding: 0;">
        <!-- 3D Preview Container -->
        <div id="edgePreview3D" style="width: 100%; height: 280px; background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); border-radius: 8px 8px 0 0;"></div>

        <!-- Edge Info -->
        <div style="padding: 20px; background: rgba(26, 26, 46, 0.9); backdrop-filter: blur(16px); -webkit-backdrop-filter: blur(16px);">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
            <div>
              <div style="font-size: 11px; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.5px;">Current Edge Profile</div>
              <div id="edgeProfileName" style="font-size: 18px; font-weight: 600; color: var(--text-primary);">Eased</div>
            </div>
            <div style="text-align: right;">
              <div style="font-size: 11px; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 6px;">Thickness</div>
              <div style="display: flex; gap: 4px; background: rgba(30, 41, 59, 0.85); backdrop-filter: blur(12px); -webkit-backdrop-filter: blur(12px); border-radius: 8px; padding: 4px; border: 1px solid rgba(255, 255, 255, 0.1);">
                <button id="thickness2cmBtn" onclick="updateEdgeThickness('2cm')" style="padding: 6px 14px; border: none; border-radius: 6px; font-size: 14px; font-weight: 600; cursor: pointer; transition: all 0.2s; background: transparent; color: var(--text-muted);">2cm</button>
                <button id="thickness3cmBtn" onclick="updateEdgeThickness('3cm')" style="padding: 6px 14px; border: none; border-radius: 6px; font-size: 14px; font-weight: 600; cursor: pointer; transition: all 0.2s; background: var(--gold); color: #000;">3cm</button>
              </div>
            </div>
          </div>

          <!-- Edge Profile Selector -->
          <div style="margin-bottom: 16px;">
            <label style="font-size: 12px; color: var(--text-muted); display: block; margin-bottom: 8px;">Change Edge Profile</label>
            <select id="edgeProfileSelect" onchange="updateEdgeProfile(this.value)" style="width: 100%; padding: 12px; background: rgba(30, 41, 59, 0.85); backdrop-filter: blur(12px); -webkit-backdrop-filter: blur(12px); border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 8px; color: var(--text-primary); font-size: 14px;">
              <optgroup label=" Most Durable">
                <option value="full-bullnose">Full Bullnose - Fully rounded semicircle</option>
                <option value="half-bullnose">Half Bullnose - Rounded top, flat bottom</option>
              </optgroup>
              <optgroup label=" Durable">
                <option value="eased">Eased (Standard) - Slight round on top edge</option>
                <option value="flat-polish">Flat Polish - Square edge, polished face</option>
                <option value="pencil">Pencil Round - Small radius curve</option>
                <option value="quarter-round">Quarter Round - Medium rounded edge</option>
              </optgroup>
              <optgroup label=" Moderate Durability">
                <option value="bevel">Bevel - Angled cut (45)</option>
                <option value="ogee">Ogee - S-curve profile (Premium)</option>
                <option value="double-ogee">Double Ogee - Stacked S-curves</option>
              </optgroup>
              <optgroup label=" Decorative">
                <option value="cove">Cove - Concave curve</option>
                <option value="dupont">Dupont - Elaborate decorative</option>
                <option value="chiseled">Chiseled - Natural rough edge</option>
              </optgroup>
              <optgroup label=" Structural">
                <option value="mitered">Mitered - Laminated drop edge (2cm look on 3cm)</option>
                <option value="waterfall">Waterfall - 90 turn with mitered corner</option>
              </optgroup>
            </select>
          </div>

          <!-- Camera Controls -->
          <div style="display: flex; gap: 8px; justify-content: center; padding: 12px; background: rgba(30, 41, 59, 0.7); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); border-radius: 8px; border: 1px solid rgba(255, 255, 255, 0.08);">
            <button class="btn btn-secondary" style="padding: 8px 16px; font-size: 12px; background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.15);" onclick="rotateEdgePreview('left')"> Rotate</button>
            <button class="btn btn-secondary" style="padding: 8px 16px; font-size: 12px; background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.15);" onclick="rotateEdgePreview('reset')">Reset View</button>
            <button class="btn btn-secondary" style="padding: 8px 16px; font-size: 12px; background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.15);" onclick="rotateEdgePreview('right')">Rotate </button>
          </div>
        </div>
      </div>
      <div class="modal-footer">
        <button class="btn btn-secondary" onclick="closeEdgePreview()">Close</button>
        <button class="btn btn-primary" onclick="applyEdgeAndClose()">Apply & Close</button>
      </div>
    </div>
  </div>

  <!-- Login Modal -->
  <div class="modal-overlay" id="loginModal">
    <div class="modal login-modal">
      <div class="modal-header">
        <h3 class="modal-title" style="font-size: 22px;">Sign In</h3>
        <button class="modal-close login-modal-close" onclick="closeModal('loginModal')"></button>
      </div>

      <p id="loginPromptMessage" style="color: var(--text-secondary); margin-bottom: 24px; text-align: center; font-size: 15px; line-height: 1.5;">
        Sign in to save and share your designs.
      </p>

      <div id="loginFormContainer">
        <!-- Google OAuth Button -->
        <button class="google-signin-btn" onclick="handleGoogleLogin()">
          <svg viewBox="0 0 24 24" width="20" height="20">
            <path fill="#4285F4" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"/>
            <path fill="#34A853" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/>
            <path fill="#FBBC05" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/>
            <path fill="#EA4335" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/>
          </svg>
          Continue with Google
        </button>

        <div class="login-divider">
          <span>or</span>
        </div>

        <!-- Email/Password Form -->
        <div class="form-group" style="margin-bottom: 18px;">
          <label style="font-size: 13px; margin-bottom: 8px; display: block; font-weight: 500;">Email</label>
          <input type="email" id="loginEmail" class="input" placeholder="your@email.com" style="width: 100%; padding: 14px; font-size: 15px;" onkeydown="if(event.key==='Enter'){event.preventDefault();document.getElementById('loginPassword').focus();}">
        </div>
        <div class="form-group" style="margin-bottom: 18px;">
          <label style="font-size: 13px; margin-bottom: 8px; display: block; font-weight: 500;">Password</label>
          <input type="password" id="loginPassword" class="input" placeholder="" style="width: 100%; padding: 14px; font-size: 15px;" onkeydown="if(event.key==='Enter'){event.preventDefault();handleLogin();}">
        </div>
        <div id="loginError" style="color: var(--error); font-size: 13px; margin-bottom: 14px; display: none;"></div>

        <!-- Sign In Button -->
        <button class="btn-signin" id="signInBtn" onclick="handleLogin()">
          <span class="btn-signin-text">Sign In</span>
          <span class="btn-signin-loader"></span>
        </button>
        <div style="text-align: center; font-size: 14px; color: var(--text-muted); margin-bottom: 16px;">
          Don't have an account? <a href="/sign-up/" target="_blank" style="color: var(--gold); font-weight: 500;">Sign up free</a>
        </div>
        <div class="login-divider" style="margin-bottom: 16px;">
          <span>or</span>
        </div>
        <button class="btn" style="width: 100%; padding: 12px; font-size: 14px; background: transparent; border: 1px solid var(--border-color); color: var(--text-secondary);" onclick="continueAsGuest()">Continue as Guest</button>
        <p style="text-align: center; font-size: 11px; color: var(--text-muted); margin-top: 10px; opacity: 0.7;">Guest designs are saved locally only</p>
      </div>

      <div id="loginSuccessContainer" style="display: none; text-align: center; padding: 20px 0;">
        <div style="width: 70px; height: 70px; background: var(--success); border-radius: 50%; display: flex; align-items: center; justify-content: center; margin: 0 auto 20px;">
          <svg viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="3" style="width: 35px; height: 35px;">
            <polyline points="20 6 9 17 4 12"/>
          </svg>
        </div>
        <h4 style="margin-bottom: 10px; font-size: 20px;">Signed In!</h4>
        <p id="loginWelcome" style="color: var(--text-secondary); margin-bottom: 20px; font-size: 15px;">Welcome back</p>
        <button class="btn btn-primary" style="padding: 14px 32px; font-size: 15px;" onclick="closeModal('loginModal')">Continue</button>
      </div>
    </div>
  </div>

  <!-- Price List Modal -->
  <div class="modal-overlay" id="priceListModal">
    <div class="modal" style="max-width: 800px; max-height: 90vh; overflow: hidden; display: flex; flex-direction: column;">
      <div class="modal-header">
        <h3 class="modal-title">Price List Manager</h3>
        <button class="modal-close" onclick="closeModal('priceListModal')"></button>
      </div>

      <div class="price-list-tabs">
        <button class="tab-btn active" onclick="showPriceTab('labor')">Labor Rates</button>
        <button class="tab-btn" onclick="showPriceTab('materials')">Materials</button>
        <button class="tab-btn" onclick="showPriceTab('upload')">Upload</button>
        <button class="tab-btn" onclick="showPriceTab('saved')">Saved Lists</button>
      </div>

      <!-- Labor Rates Tab -->
      <div class="price-tab" id="priceTabLabor" style="overflow-y: auto; max-height: calc(90vh - 140px);">
        <div style="padding: 12px; background: rgba(249,203,0,0.1); border-radius: 8px; margin-bottom: 16px;">
          <p style="font-size: 13px; color: var(--text-muted); margin: 0;">
            <strong style="color: var(--gold-primary);">Labor Rates</strong> - Set your pricing for fabrication, installation, and services. These rates are used to calculate labor costs in quotes.
          </p>
        </div>

        <!-- Labor Category Accordion -->
        <div class="labor-categories" id="laborCategoriesContainer">
          <!-- Stone/Countertop Services -->
          <div class="labor-category">
            <div class="labor-category-header" onclick="toggleLaborCategory('stone')">
              <span class="category-icon"></span>
              <span class="category-title">Stone / Countertop Services</span>
              <span class="category-toggle" id="toggleStone"></span>
            </div>
            <div class="labor-category-items" id="laborItemsStone"></div>
          </div>

          <!-- Cabinet Services -->
          <div class="labor-category">
            <div class="labor-category-header" onclick="toggleLaborCategory('cabinet')">
              <span class="category-icon"></span>
              <span class="category-title">Cabinet Services</span>
              <span class="category-toggle" id="toggleCabinet"></span>
            </div>
            <div class="labor-category-items" id="laborItemsCabinet"></div>
          </div>

          <!-- Plumbing Services -->
          <div class="labor-category">
            <div class="labor-category-header" onclick="toggleLaborCategory('plumbing')">
              <span class="category-icon"></span>
              <span class="category-title">Plumbing Services</span>
              <span class="category-toggle" id="togglePlumbing"></span>
            </div>
            <div class="labor-category-items" id="laborItemsPlumbing"></div>
          </div>

          <!-- Electrical Services -->
          <div class="labor-category">
            <div class="labor-category-header" onclick="toggleLaborCategory('electrical')">
              <span class="category-icon"></span>
              <span class="category-title">Electrical Services</span>
              <span class="category-toggle" id="toggleElectrical"></span>
            </div>
            <div class="labor-category-items" id="laborItemsElectrical"></div>
          </div>

          <!-- Flooring Services -->
          <div class="labor-category">
            <div class="labor-category-header" onclick="toggleLaborCategory('flooring')">
              <span class="category-icon"></span>
              <span class="category-title">Flooring Services</span>
              <span class="category-toggle" id="toggleFlooring"></span>
            </div>
            <div class="labor-category-items" id="laborItemsFlooring"></div>
          </div>

          <!-- Demo & Prep Services -->
          <div class="labor-category">
            <div class="labor-category-header" onclick="toggleLaborCategory('demo')">
              <span class="category-icon"></span>
              <span class="category-title">Demo & Prep</span>
              <span class="category-toggle" id="toggleDemo"></span>
            </div>
            <div class="labor-category-items" id="laborItemsDemo"></div>
          </div>

          <!-- Finishing/Specialty -->
          <div class="labor-category">
            <div class="labor-category-header" onclick="toggleLaborCategory('finishing')">
              <span class="category-icon"></span>
              <span class="category-title">Finishing & Specialty</span>
              <span class="category-toggle" id="toggleFinishing"></span>
            </div>
            <div class="labor-category-items" id="laborItemsFinishing"></div>
          </div>

          <!-- Project Fees -->
          <div class="labor-category">
            <div class="labor-category-header" onclick="toggleLaborCategory('fees')">
              <span class="category-icon">$</span>
              <span class="category-title">Project Fees</span>
              <span class="category-toggle" id="toggleFees"></span>
            </div>
            <div class="labor-category-items" id="laborItemsFees"></div>
          </div>
        </div>

        <div style="padding: 16px; border-top: 1px solid var(--border-subtle); display: flex; gap: 12px; justify-content: flex-end;">
          <button class="btn btn-secondary" onclick="resetLaborRates()">Reset to Defaults</button>
          <button class="btn btn-primary" onclick="saveLaborRates()">Save Rates</button>
        </div>
      </div>

      <!-- Materials Tab (Slab Pricing) -->
      <div class="price-tab" id="priceTabMaterials" style="display:none; overflow-y: auto; max-height: calc(90vh - 140px);">
        <div style="padding: 12px; background: rgba(249,203,0,0.1); border-radius: 8px; margin-bottom: 16px;">
          <p style="font-size: 13px; color: var(--text-muted); margin: 0;">
            <strong style="color: var(--gold-primary);">Material Pricing</strong> - Materials sold by the slab are priced per slab, then fabrication/installation calculated per sqft.
          </p>
        </div>

        <div class="material-pricing-section">
          <h4 style="margin-bottom: 12px; color: #fff;">Slab Materials</h4>
          <p style="font-size: 12px; color: var(--text-muted); margin-bottom: 12px;">Enter slab cost. Fab & install are calculated from Labor Rates based on sqft.</p>
          <div id="slabMaterialsList"></div>
        </div>

        <div class="material-pricing-section" style="margin-top: 24px;">
          <h4 style="margin-bottom: 12px; color: #fff;">Per-Sqft Materials</h4>
          <div id="sqftMaterialsList"></div>
        </div>

        <div style="padding: 16px; border-top: 1px solid var(--border-subtle); display: flex; gap: 12px; justify-content: flex-end;">
          <button class="btn btn-primary" onclick="saveMaterialPricing()">Save Material Prices</button>
        </div>
      </div>

      <!-- Upload Tab -->
      <div class="price-tab" id="priceTabUpload" style="display:none;">
        <div class="upload-dropzone" id="priceListDropzone" onclick="document.getElementById('priceListFile').click()">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:48px;height:48px;margin-bottom:12px;opacity:0.5;">
            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
            <polyline points="17 8 12 3 7 8"/>
            <line x1="12" y1="3" x2="12" y2="15"/>
          </svg>
          <p style="margin-bottom:4px;">Drop Excel or CSV file here</p>
          <p class="hint" style="font-size:12px;color:var(--text-muted);">Supports .xlsx, .xls, .csv for material or labor price lists</p>
          <input type="file" id="priceListFile" accept=".xlsx,.xls,.csv" onchange="handlePriceListUpload(event)" style="display:none">
        </div>

        <div class="column-mapping" id="columnMapping" style="display:none;">
          <h4 style="margin-bottom:12px;">Map Columns</h4>
          <div class="mapping-row">
            <label>Item ID/SKU</label>
            <select id="mapMaterialId" class="property-select" onchange="updateMappingPreview()"></select>
          </div>
          <div class="mapping-row">
            <label>Item Name</label>
            <select id="mapMaterialName" class="property-select" onchange="updateMappingPreview()"></select>
          </div>
          <div class="mapping-row">
            <label>Price</label>
            <select id="mapPrice" class="property-select" onchange="updateMappingPreview()"></select>
          </div>
          <div class="mapping-row">
            <label>Unit (optional)</label>
            <select id="mapUnit" class="property-select" onchange="updateMappingPreview()"></select>
          </div>
          <div class="mapping-preview" id="mappingPreview"></div>
          <div class="mapping-actions">
            <button class="btn btn-secondary" onclick="cancelPriceUpload()">Cancel</button>
            <button class="btn btn-primary" onclick="applyPriceList()">Apply Prices</button>
          </div>
        </div>
      </div>

      <!-- Saved Lists Tab -->
      <div class="price-tab" id="priceTabSaved" style="display:none;">
        <div class="saved-lists" id="savedPriceLists">
          <p class="empty-state">No saved price lists</p>
        </div>
        <button class="btn btn-primary" onclick="savePriceList()" style="margin-top:16px;">Save Current Prices</button>
      </div>
    </div>
  </div>

  <!-- Quote Preview Modal -->
  <div class="modal-overlay" id="quotePreviewModal">
    <div class="modal" style="max-width: 900px; max-height: 90vh; overflow: hidden; display: flex; flex-direction: column;">
      <div class="modal-header">
        <div style="display: flex; align-items: center; gap: 12px;">
          <h3 class="modal-title">Quote Preview</h3>
          <div id="estimateNumberBadge" style="display: none; background: var(--gold); color: #000; padding: 4px 10px; border-radius: 4px; font-size: 12px; font-weight: 600;"></div>
        </div>
        <div style="display: flex; align-items: center; gap: 12px;">
          <select id="quoteRoomFilter" class="property-select" style="font-size: 12px; min-width: 140px;" onchange="filterQuoteByRoom(this.value)">
            <option value="all">All Rooms</option>
          </select>
          <button class="modal-close" onclick="closeModal('quotePreviewModal')"></button>
        </div>
      </div>

      <!-- Customer Info Section -->
      <div class="quote-customer-section" style="padding: 16px; background: var(--dark-elevated); border-bottom: 1px solid var(--border);">
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px;">
          <!-- Customer Search -->
          <div class="quote-customer-search-wrap">
            <svg class="search-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/></svg>
            <input type="text" id="quoteCustomerSearch"
                   placeholder="Search existing customers by name or email..."
                   oninput="searchQuoteCustomers(this.value)"
                   autocomplete="off">
            <div id="quoteCustomerResults" style="display:none;"></div>
          </div>
          <!-- Selected customer banner -->
          <div id="quoteCustomerSelectedBanner" class="quote-customer-selected-banner" style="display:none;">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#6366f1" stroke-width="2"><path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"/><circle cx="12" cy="7" r="4"/></svg>
            <div>
              <div class="name" id="quoteSelectedName"></div>
              <div class="meta" id="quoteSelectedMeta"></div>
            </div>
            <button class="clear-btn" onclick="clearQuoteCustomerSelection()" title="Clear selection">&times;</button>
          </div>
          <div>
            <label style="font-size: 11px; color: var(--text-muted); display: block; margin-bottom: 4px;">Customer Name *</label>
            <input type="text" id="quoteCustomerName" class="property-input" placeholder="Enter customer name" style="width: 100%;">
          </div>
          <div>
            <label style="font-size: 11px; color: var(--text-muted); display: block; margin-bottom: 4px;">Email *</label>
            <input type="email" id="quoteCustomerEmail" class="property-input" placeholder="customer@email.com" style="width: 100%;">
          </div>
          <div>
            <label style="font-size: 11px; color: var(--text-muted); display: block; margin-bottom: 4px;">Phone</label>
            <input type="tel" id="quoteCustomerPhone" class="property-input" placeholder="(555) 123-4567" style="width: 100%;">
          </div>
          <div>
            <label style="font-size: 11px; color: var(--text-muted); display: block; margin-bottom: 4px;">Project Name</label>
            <input type="text" id="quoteProjectName" class="property-input" placeholder="Kitchen Remodel" style="width: 100%;">
          </div>
          <div style="grid-column: span 2;">
            <label style="font-size: 11px; color: var(--text-muted); display: block; margin-bottom: 4px;">Project Address</label>
            <input type="text" id="quoteCustomerAddress" class="property-input" placeholder="123 Main St, Phoenix, AZ 85001" style="width: 100%;">
          </div>
        </div>
      </div>

      <!-- Quote Items Table -->
      <div class="quote-preview-content" style="flex: 1; overflow-y: auto; padding: 16px;">
        <table class="quote-preview-table" id="quotePreviewTable">
          <thead>
            <tr>
              <th style="width: 30px;"></th>
              <th>Item</th>
              <th style="width: 80px;">Qty</th>
              <th style="width: 100px;">Cost</th>
              <th style="width: 100px;">Retail</th>
              <th style="width: 60px;">Margin</th>
            </tr>
          </thead>
          <tbody id="quotePreviewBody">
            <!-- Populated by JavaScript -->
          </tbody>
        </table>
      </div>

      <!-- Quote Totals -->
      <div class="quote-preview-footer" style="padding: 16px; background: var(--dark-elevated); border-top: 1px solid var(--border);">
        <div style="display: flex; justify-content: space-between; align-items: flex-start;">
          <div style="flex: 1;">
            <label style="font-size: 11px; color: var(--text-muted); display: block; margin-bottom: 4px;">Notes / Terms</label>
            <textarea id="quoteNotes" class="property-input" rows="2" placeholder="Add notes, terms, or special conditions..." style="width: 100%; resize: none;"></textarea>
          </div>
          <div style="min-width: 250px; margin-left: 24px;">
            <div class="quote-totals-grid">
              <div style="display: flex; justify-content: space-between; padding: 6px 0; border-bottom: 1px solid var(--border);">
                <span style="color: var(--text-muted); font-size: 13px;">Subtotal</span>
                <span id="quotePreviewSubtotal" style="font-weight: 500;">$0.00</span>
              </div>
              <div style="display: flex; justify-content: space-between; padding: 6px 0; border-bottom: 1px solid var(--border);">
                <span style="color: var(--text-muted); font-size: 13px;">Tax (<span id="quoteTaxRate">0</span>%)</span>
                <span id="quotePreviewTax" style="font-weight: 500;">$0.00</span>
              </div>
              <div style="display: flex; justify-content: space-between; padding: 10px 0; font-size: 16px;">
                <span style="font-weight: 600;">Total</span>
                <span id="quotePreviewTotal" style="font-weight: 700; color: var(--gold);">$0.00</span>
              </div>
            </div>
            <div style="display: flex; gap: 8px; margin-top: 12px;">
              <input type="number" id="quoteTaxInput" class="property-input" value="0" min="0" max="20" step="0.5" style="width: 60px; text-align: center;" onchange="updateQuoteTax(this.value)" placeholder="%">
              <span style="font-size: 11px; color: var(--text-muted); align-self: center;">Tax %</span>
            </div>
          </div>
        </div>

        <!-- Action Buttons -->
        <div style="display: flex; gap: 12px; margin-top: 16px; padding-top: 16px; border-top: 1px solid var(--border);">
          <button class="btn btn-secondary" onclick="downloadQuotePDF()" style="flex: 1;">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:14px;height:14px;margin-right:6px;">
              <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
              <polyline points="7 10 12 15 17 10"/>
              <line x1="12" y1="15" x2="12" y2="3"/>
            </svg>
            PDF
          </button>
          <button class="btn btn-secondary" onclick="copyQuoteLink()" style="flex: 1;">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:14px;height:14px;margin-right:6px;">
              <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"/>
              <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"/>
            </svg>
            Link
          </button>
          <button class="btn btn-secondary" onclick="sendQuoteEmail()" style="flex: 1;">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:14px;height:14px;margin-right:6px;">
              <path d="M22 2L11 13"/><path d="M22 2l-7 20-4-9-9-4 20-7z"/>
            </svg>
            Email
          </button>
          <button id="saveEstimateBtn" class="btn btn-primary" onclick="saveEstimateToDatabase()" style="flex: 1.5;">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:14px;height:14px;margin-right:6px;">
              <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/>
              <polyline points="17 21 17 13 7 13 7 21"/>
              <polyline points="7 3 7 8 15 8"/>
            </svg>
            Save Estimate
          </button>
        </div>
        <!-- Estimate Status -->
        <div id="estimateStatusSection" style="display: none; margin-top: 12px; padding: 12px; background: rgba(34, 197, 94, 0.1); border: 1px solid rgba(34, 197, 94, 0.3); border-radius: 8px;">
          <div style="display: flex; align-items: center; gap: 8px;">
            <svg viewBox="0 0 24 24" fill="none" stroke="#22c55e" stroke-width="2" style="width:18px;height:18px;">
              <path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/><polyline points="22 4 12 14.01 9 11.01"/>
            </svg>
            <span id="estimateStatusText" style="color: #22c55e; font-weight: 500;">Estimate saved!</span>
          </div>
          <div id="estimateShareUrl" style="margin-top: 8px; display: none;">
            <label style="font-size: 11px; color: var(--text-muted); display: block; margin-bottom: 4px;">Customer View Link</label>
            <div style="display: flex; gap: 8px;">
              <input type="text" id="estimateViewLink" class="property-input" readonly style="flex: 1; font-size: 12px;">
              <button class="btn btn-secondary" onclick="copyEstimateLink()" style="padding: 8px 12px;">Copy</button>
            </div>
          </div>
          <div style="margin-top: 10px; display: flex; gap: 8px;">
            <button id="convertToJobBtn" class="btn btn-primary" onclick="convertEstimateToJob()" style="display:none; padding: 8px 16px; font-size: 13px;">
              <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align: middle; margin-right: 4px;"><path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"/><polyline points="3.27 6.96 12 12.01 20.73 6.96"/><line x1="12" y1="22.08" x2="12" y2="12"/></svg>
              Create Job
            </button>
            <span id="jobCreatedBadge" style="display:none; font-size: 12px; color: #6366f1; font-weight: 600; padding: 8px 0; align-self: center;"></span>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Room Manager Modal -->
  <div class="modal-overlay" id="roomManagerModal">
    <div class="modal" style="max-width: 500px;">
      <div class="modal-header">
        <h3 class="modal-title">Manage Rooms</h3>
        <button class="modal-close" onclick="closeModal('roomManagerModal')"></button>
      </div>

      <div style="padding: 16px;">
        <p style="font-size: 13px; color: var(--text-muted); margin-bottom: 16px;">
          Organize your design by rooms. Each room will have its own quote section.
        </p>

        <!-- Add Room -->
        <div style="display: flex; gap: 8px; margin-bottom: 16px;">
          <input type="text" id="newRoomName" class="property-input" placeholder="New room name (e.g., Master Bath)" style="flex: 1;">
          <button class="btn btn-primary" onclick="addRoom()">Add Room</button>
        </div>

        <!-- Room List -->
        <div class="room-list" id="roomList">
          <!-- Populated by JavaScript -->
        </div>
      </div>

      <div style="padding: 16px; border-top: 1px solid var(--border); display: flex; justify-content: flex-end; gap: 8px;">
        <button class="btn btn-secondary" onclick="closeModal('roomManagerModal')">Close</button>
      </div>
    </div>
  </div>

  <!-- Customer Quote View Share Modal -->
  <div class="modal-overlay" id="shareQuoteModal">
    <div class="modal" style="max-width: 500px;">
      <div class="modal-header">
        <h3 class="modal-title">Share Quote with Customer</h3>
        <button class="modal-close" onclick="closeModal('shareQuoteModal')"></button>
      </div>

      <div style="padding: 16px;">
        <p style="font-size: 13px; color: var(--text-muted); margin-bottom: 16px;">
          Generate a link for your customer to view the design and quote. They can see all rooms and the total estimate.
        </p>

        <div style="margin-bottom: 16px;">
          <label style="font-size: 11px; color: var(--text-muted); display: block; margin-bottom: 4px;">Customer Email (optional)</label>
          <input type="email" id="shareCustomerEmail" class="property-input" placeholder="customer@email.com" style="width: 100%;">
        </div>

        <div style="margin-bottom: 16px;">
          <label style="font-size: 11px; color: var(--text-muted); display: block; margin-bottom: 4px;">Link Expiration</label>
          <select id="shareLinkExpiry" class="property-select" style="width: 100%;">
            <option value="7">7 days</option>
            <option value="14">14 days</option>
            <option value="30" selected>30 days</option>
            <option value="90">90 days</option>
            <option value="0">Never expires</option>
          </select>
        </div>

        <div style="margin-bottom: 16px;">
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
            <input type="checkbox" id="shareShowPricing" checked style="width: 16px; height: 16px;">
            <span style="font-size: 13px;">Show pricing to customer</span>
          </label>
        </div>

        <div style="margin-bottom: 16px;">
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
            <input type="checkbox" id="shareAllowDeposit" checked style="width: 16px; height: 16px;">
            <span style="font-size: 13px;">Allow customer to pay deposit</span>
          </label>
          <p style="font-size: 11px; color: var(--text-muted); margin: 4px 0 0 24px;">Customer can approve and pay 50% deposit via Stripe</p>
        </div>

        <div style="margin-bottom: 16px;">
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
            <input type="checkbox" id="shareAllowSchedule" checked style="width: 16px; height: 16px;">
            <span style="font-size: 13px;">Allow customer to schedule consultation</span>
          </label>
          <p style="font-size: 11px; color: var(--text-muted); margin: 4px 0 0 24px;">Shows scheduling options after deposit payment</p>
        </div>

        <!-- Generated Link -->
        <div id="generatedLinkSection" style="display: none; margin-top: 16px;">
          <label style="font-size: 11px; color: var(--text-muted); display: block; margin-bottom: 4px;">Shareable Link</label>
          <div style="display: flex; gap: 8px;">
            <input type="text" id="generatedShareLink" class="property-input" readonly style="flex: 1; font-size: 11px;">
            <button class="btn btn-secondary" onclick="copyGeneratedLink()" title="Copy link">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:14px;height:14px;">
                <rect x="9" y="9" width="13" height="13" rx="2"/>
                <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/>
              </svg>
            </button>
          </div>
        </div>
      </div>

      <div style="padding: 16px; border-top: 1px solid var(--border); display: flex; justify-content: flex-end; gap: 8px;">
        <button class="btn btn-secondary" onclick="closeModal('shareQuoteModal')">Cancel</button>
        <button class="btn btn-primary" onclick="generateQuoteShareLink()" id="generateLinkBtn">Generate Link</button>
      </div>
    </div>
  </div>

  <!-- Margin Settings Modal -->
  <div class="modal-overlay" id="marginModal">
    <div class="modal" style="max-width: 450px;">
      <div class="modal-header">
        <h3 class="modal-title">Margin Settings</h3>
        <button class="modal-close" onclick="closeModal('marginModal')"></button>
      </div>

      <div class="margin-section">
        <div class="margin-global">
          <label>Default Margin</label>
          <div class="margin-input-group">
            <input type="number" class="property-input" id="globalMarginInput" value="30" min="0" max="200">
            <span class="margin-symbol">%</span>
          </div>
          <p class="hint" style="font-size:11px;color:var(--text-muted);margin-top:4px;">Applied to all items without custom margin</p>
        </div>

        <div class="margin-categories">
          <h4 style="margin:16px 0 12px;">Category Margins</h4>
          <div class="category-margin-row">
            <span>Countertops</span>
            <div class="margin-input-group">
              <input type="number" class="property-input" data-category="countertop" value="35" min="0" max="200">
              <span class="margin-symbol">%</span>
            </div>
          </div>
          <div class="category-margin-row">
            <span>Cabinets</span>
            <div class="margin-input-group">
              <input type="number" class="property-input" data-category="cabinet" value="25" min="0" max="200">
              <span class="margin-symbol">%</span>
            </div>
          </div>
          <div class="category-margin-row">
            <span>Appliances</span>
            <div class="margin-input-group">
              <input type="number" class="property-input" data-category="appliance" value="15" min="0" max="200">
              <span class="margin-symbol">%</span>
            </div>
          </div>
          <div class="category-margin-row">
            <span>Flooring/Tile</span>
            <div class="margin-input-group">
              <input type="number" class="property-input" data-category="flooring" value="30" min="0" max="200">
              <span class="margin-symbol">%</span>
            </div>
          </div>
        </div>
      </div>

      <div class="modal-footer">
        <button class="btn btn-secondary" onclick="closeModal('marginModal')">Cancel</button>
        <button class="btn btn-primary" onclick="applyMargins()">Apply</button>
      </div>
    </div>
  </div>

  <!-- Material Picker Modal -->
  <div class="modal-overlay" id="materialModal">
    <div class="modal" style="max-width: 600px;">
      <div class="modal-header">
        <h3 class="modal-title">Choose Material</h3>
        <button class="modal-close" onclick="closeModal('materialModal')"></button>
      </div>
      <div class="material-categories" id="materialCategories">
        <!-- Categories rendered by JS -->
      </div>
      <div class="materials-modal-grid" id="materialsGrid">
        <!-- Materials rendered by JS -->
      </div>
    </div>
  </div>

  <!-- Takeoff Report Modal -->
  <div class="modal-overlay" id="takeoffModal" style="display: none;">
    <div class="modal" style="max-width: 900px; max-height: 90vh; overflow: hidden; display: flex; flex-direction: column;">
      <div class="modal-header" style="flex-shrink: 0;">
        <h3 class="modal-title" style="display: flex; align-items: center; gap: 10px;">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2"/>
            <rect x="9" y="3" width="6" height="4" rx="1"/>
          </svg>
          Material Takeoffs
        </h3>
        <div style="display: flex; gap: 8px; align-items: center;">
          <button class="btn btn-secondary btn-sm" onclick="exportTakeoffPDF()" style="font-size: 12px;">
            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="margin-right: 4px;">
              <path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4"/><polyline points="7,10 12,15 17,10"/><line x1="12" y1="15" x2="12" y2="3"/>
            </svg>
            Export PDF
          </button>
          <button class="modal-close" onclick="closeModal('takeoffModal')"></button>
        </div>
      </div>
      <div class="modal-body" id="takeoffContent" style="overflow-y: auto; flex: 1; padding: 20px;">
        <!-- Takeoff content rendered by JS -->
      </div>
    </div>
  </div>

  <style>
    /* Takeoff Modal Styles */
    .takeoff-section {
      background: var(--dark-elevated);
      border-radius: 12px;
      padding: 16px;
      margin-bottom: 16px;
    }
    .takeoff-section-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 12px;
      padding-bottom: 8px;
      border-bottom: 1px solid var(--border);
    }
    .takeoff-section-title {
      font-size: 16px;
      font-weight: 600;
      color: var(--text);
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .takeoff-section-badge {
      background: var(--primary);
      color: white;
      padding: 2px 8px;
      border-radius: 12px;
      font-size: 12px;
      font-weight: 600;
    }
    .takeoff-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 12px;
    }
    .takeoff-item {
      background: rgba(0,0,0,0.2);
      border-radius: 8px;
      padding: 12px;
    }
    .takeoff-item-label {
      font-size: 12px;
      color: var(--text-muted);
      margin-bottom: 4px;
    }
    .takeoff-item-value {
      font-size: 18px;
      font-weight: 700;
      color: var(--text);
    }
    .takeoff-item-unit {
      font-size: 12px;
      color: var(--text-secondary);
      font-weight: 400;
    }
    .takeoff-item-note {
      font-size: 11px;
      color: var(--text-muted);
      margin-top: 4px;
    }
    .takeoff-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 13px;
    }
    .takeoff-table th {
      text-align: left;
      padding: 8px;
      background: rgba(0,0,0,0.3);
      color: var(--text-secondary);
      font-weight: 500;
      font-size: 11px;
      text-transform: uppercase;
    }
    .takeoff-table td {
      padding: 8px;
      border-bottom: 1px solid var(--border);
      color: var(--text);
    }
    .takeoff-table tr:last-child td {
      border-bottom: none;
    }
    .takeoff-highlight {
      background: linear-gradient(135deg, rgba(99, 102, 241, 0.2) 0%, rgba(139, 92, 246, 0.2) 100%);
      border: 1px solid rgba(99, 102, 241, 0.3);
    }
    .takeoff-warning {
      background: rgba(245, 158, 11, 0.15);
      border: 1px solid rgba(245, 158, 11, 0.3);
      color: #fbbf24;
      padding: 12px;
      border-radius: 8px;
      font-size: 13px;
      display: flex;
      align-items: flex-start;
      gap: 8px;
      margin-top: 12px;
    }
    .takeoff-summary {
      background: linear-gradient(135deg, var(--dark) 0%, var(--dark-elevated) 100%);
      border: 2px solid var(--primary);
      border-radius: 12px;
      padding: 20px;
      margin-top: 16px;
    }
    .takeoff-summary-title {
      font-size: 14px;
      color: var(--text-secondary);
      margin-bottom: 8px;
    }
    .takeoff-summary-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 16px;
    }
    .slab-visual {
      display: flex;
      gap: 8px;
      margin-top: 12px;
      flex-wrap: wrap;
    }
    .slab-icon {
      width: 60px;
      height: 40px;
      background: linear-gradient(135deg, #64748b 0%, #475569 100%);
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      font-weight: 700;
      color: white;
      border: 2px solid rgba(255,255,255,0.2);
    }
    .slab-icon.used {
      background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
      border-color: rgba(255,255,255,0.4);
    }
  </style>

  <!-- Hidden file input -->
  <input type="file" id="materialUpload" accept="image/*" style="display: none" onchange="handleMaterialUpload(event)">

  <!-- Keyboard Shortcuts (hidden in review mode) -->
  <div class="shortcuts-hint" id="shortcutsHint">
    <div class="shortcut"><kbd>V</kbd> Select</div>
    <div class="shortcut"><kbd>W</kbd> Wall</div>
    <div class="shortcut"><kbd>C</kbd> Counter</div>
    <div class="shortcut"><kbd>Del</kbd> Delete</div>
    <div class="shortcut"><kbd>R</kbd> Rotate</div>
    <div class="shortcut"><kbd>Ctrl+D</kbd> Duplicate</div>
  </div>

  <script>
    // ===== DEMO MODE DETECTION =====
    const DEMO_MODE = new URLSearchParams(window.location.search).get('demo') === 'true';

    // Initialize demo mode UI on DOM ready
    document.addEventListener('DOMContentLoaded', function() {
      if (DEMO_MODE) {
        // Show demo banner
        const demoBanner = document.getElementById('demoBanner');
        if (demoBanner) {
          demoBanner.style.display = 'flex';
        }

        // Replace logo with Remodely.ai branding (Google colors house logo)
        const logoGroup = document.getElementById('logoGroup');
        if (logoGroup) {
          logoGroup.innerHTML = `
            <a href="https://remodely.ai" class="logo" target="_blank" style="display:flex;align-items:center;gap:10px;text-decoration:none;">
              <svg width="32" height="32" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" fill="none">
                <defs>
                  <linearGradient id="googleGradientDemo" x1="0%" y1="0%" x2="100%" y2="100%">
                    <stop offset="0%" style="stop-color:#4285F4"/>
                    <stop offset="25%" style="stop-color:#EA4335"/>
                    <stop offset="50%" style="stop-color:#FBBC05"/>
                    <stop offset="100%" style="stop-color:#34A853"/>
                  </linearGradient>
                </defs>
                <path d="M3 21V10l9-7 9 7v11" stroke="url(#googleGradientDemo)" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"/>
                <path d="M21 21h-7" stroke="#34A853" stroke-width="2.5" stroke-linecap="round"/>
              </svg>
              <span style="font-size:18px;font-weight:700;color:#fff;">Remodely<span style="color:#818cf8;">.ai</span></span>
            </a>
          `;
        }

        // Update page title
        document.title = 'Room Designer Pro Demo | Remodely.ai';

        // Add demo upgrade modal to body
        const modalHTML = `
          <div class="demo-upgrade-modal" id="demoUpgradeModal">
            <div class="demo-upgrade-content">
              <button class="demo-upgrade-close" onclick="closeDemoUpgradeModal()">&times;</button>
              <div class="demo-upgrade-icon"></div>
              <h2 id="demoUpgradeTitle">Unlock Full Access</h2>
              <p id="demoUpgradeDesc">Get access to all Room Designer Pro features with a free 14-day trial.</p>
              <div class="demo-upgrade-features">
                <div class="demo-upgrade-feature"><span style="color:#10b981;"></span> Save & load unlimited designs</div>
                <div class="demo-upgrade-feature"><span style="color:#10b981;"></span> 500+ premium materials & textures</div>
                <div class="demo-upgrade-feature"><span style="color:#10b981;"></span> Export PDF quotes & cut lists</div>
                <div class="demo-upgrade-feature"><span style="color:#10b981;"></span> Real-time pricing estimates</div>
                <div class="demo-upgrade-feature"><span style="color:#10b981;"></span> Share designs with clients</div>
              </div>
              <div class="demo-upgrade-actions">
                <button class="btn btn-secondary" onclick="closeDemoUpgradeModal()">Continue Demo</button>
                <a href="https://remodely.ai/" class="btn btn-primary" target="_blank">Start Free Trial</a>
              </div>
            </div>
          </div>
        `;
        document.body.insertAdjacentHTML('beforeend', modalHTML);

        console.log(' Room Designer Pro running in DEMO MODE');
      }
    });

    // Demo mode upgrade modal functions
    function showDemoUpgradeModal(feature) {
      if (!DEMO_MODE) return false;

      const modal = document.getElementById('demoUpgradeModal');
      const title = document.getElementById('demoUpgradeTitle');
      const desc = document.getElementById('demoUpgradeDesc');

      // Customize message based on feature
      const messages = {
        save: { title: 'Save Your Design', desc: 'Create a free account to save your designs and access them anytime.' },
        export: { title: 'Export Your Design', desc: 'Upgrade to export PDF quotes, cut lists, and share with clients.' },
        share: { title: 'Share Your Design', desc: 'Create an account to share designs with clients and team members.' },
        materials: { title: 'Premium Materials', desc: 'Access 500+ premium stone, quartz, and material textures.' },
        pricing: { title: 'Real-Time Pricing', desc: 'Get instant pricing estimates with your Remodely.ai account.' },
        default: { title: 'Unlock Full Access', desc: 'Get access to all Room Designer Pro features with a free 14-day trial.' }
      };

      const msg = messages[feature] || messages.default;
      if (title) title.textContent = msg.title;
      if (desc) desc.textContent = msg.desc;

      if (modal) modal.classList.add('show');
      return true;
    }

    function closeDemoUpgradeModal() {
      const modal = document.getElementById('demoUpgradeModal');
      if (modal) modal.classList.remove('show');
    }

    // ===== CONFIGURATION =====
    const CONFIG = {
      MIN_PIXELS_PER_FOOT: 5,  // Allow zooming out to see very large rooms
      MAX_PIXELS_PER_FOOT: 200, // Allow zooming in for fine detail work
      DEFAULT_PIXELS_PER_FOOT: 40,
      GRID_SUBDIVISIONS: 12, // 12 subdivisions = 1 inch grid (12" per foot)
      MEASUREMENT_PRECISION: 16, // 1/16" precision
      WALL_THICKNESS: 6,
      PRICING: {
        'base-cabinet': 150,
        'wall-cabinet': 120,
        'tall-cabinet': 300,
        'fridge-cabinet': 450,
        'corner-cabinet': 200,
        'island': 400,
        'countertop': 65,
        'backsplash': 25,
        'flooring': 8,
        'tile': 15,
        'sink': 350,
        'stove': 800,
        'refrigerator': 1200,
        'dishwasher': 600,
        'microwave': 250,
        'range-hood': 450,
        'oven': 1500,
        'door': 200,
        'window': 300,
        'wall': 0
      }
    };

    // ===== ELEMENT TYPE CATEGORIES =====
    // Standardized type checking to avoid inconsistent OR chains
    const ELEMENT_CATEGORIES = {
      countertops: ['countertop', 'countertop-l', 'countertop-u', 'countertop-corner', 'island-countertop'],
      baseCabinets: ['base-cabinet', 'sink-base', 'drawer-base', 'corner-cabinet', 'lazy-susan', 'blind-corner', 'island'],
      wallCabinets: ['wall-cabinet', 'microwave-cabinet', 'above-microwave-cabinet', 'glass-cabinet'],
      tallCabinets: ['tall-cabinet', 'pantry', 'fridge-cabinet', 'single-oven-cabinet', 'tall-oven', 'double-oven-cabinet', 'linen-closet'],
      appliances: ['refrigerator', 'range', 'oven', 'microwave', 'range-hood', 'cooktop', 'dishwasher', 'washer', 'dryer'],
      plumbing: ['sink', 'toilet', 'bathtub', 'bathtub-freestanding', 'shower-pan', 'pedestal-sink'],
      fixtures: ['faucet', 'mirror', 'towel-bar', 'toilet-paper', 'shower-niche', 'shower-curb'],
      walls: ['wall', 'wall-block', 'wall-concrete', 'wall-framed', 'pony-wall', 'knee-wall', 'shower-wall'],
      doors: ['door', 'door-entry', 'door-sliding', 'door-french', 'door-pocket'],
      windows: ['window', 'window-large', 'window-small', 'skylight']
    };

    // Utility function to check element category
    function isElementCategory(type, category) {
      const types = ELEMENT_CATEGORIES[category];
      if (!types) return false;
      return types.includes(type) || types.some(t => type.startsWith(t + '-'));
    }

    // Check if element is any type of cabinet
    function isCabinetType(type) {
      return isElementCategory(type, 'baseCabinets') ||
             isElementCategory(type, 'wallCabinets') ||
             isElementCategory(type, 'tallCabinets');
    }

    // Check if element is stone/countertop
    function isCountertopType(type) {
      return isElementCategory(type, 'countertops') || type.startsWith('countertop');
    }

    // ===== UTILITY FUNCTIONS =====
    // Centralized click-outside handler for dropdowns/modals
    function setupClickOutsideHandler(triggerEl, dropdownEl, options = {}) {
      const handler = (e) => {
        const clickedInside = triggerEl?.contains(e.target) || dropdownEl?.contains(e.target);
        if (!clickedInside) {
          if (options.removeClass) dropdownEl.classList.remove(options.removeClass);
          if (options.setDisplay) dropdownEl.style.display = options.setDisplay;
          if (options.remove) dropdownEl.remove();
          if (options.callback) options.callback();
          document.removeEventListener('click', handler);
        }
      };
      // Delay to prevent immediate trigger
      setTimeout(() => document.addEventListener('click', handler), 0);
      return handler;
    }

    // Debug logging utility (disabled in production)
    const DEBUG_MODE = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
    function debugLog(category, message, data = null) {
      if (!DEBUG_MODE) return;
      const prefix = `[${category}]`;
      if (data !== null) {
        console.log(prefix, message, data);
      } else {
        console.log(prefix, message);
      }
    }

    // Safe JSON parse with fallback
    function safeJSONParse(str, fallback = null) {
      try {
        return JSON.parse(str);
      } catch (e) {
        debugLog('JSON', 'Parse failed:', e.message);
        return fallback;
      }
    }

    // Safe localStorage operations
    function safeLocalStorageGet(key, fallback = null) {
      try {
        const value = localStorage.getItem(key);
        return value ? safeJSONParse(value, fallback) : fallback;
      } catch (e) {
        debugLog('Storage', `Failed to get ${key}:`, e.message);
        return fallback;
      }
    }

    function safeLocalStorageSet(key, value) {
      try {
        localStorage.setItem(key, JSON.stringify(value));
        return true;
      } catch (e) {
        debugLog('Storage', `Failed to set ${key}:`, e.message);
        return false;
      }
    }

    // Debounce utility for performance
    function debounce(func, wait) {
      let timeout;
      return function executedFunction(...args) {
        const later = () => {
          clearTimeout(timeout);
          func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
      };
    }

    // Throttle utility for frequent events
    function throttle(func, limit) {
      let inThrottle;
      return function(...args) {
        if (!inThrottle) {
          func.apply(this, args);
          inThrottle = true;
          setTimeout(() => inThrottle = false, limit);
        }
      };
    }

    // ===== PRICING & SHARING STATE =====
    const PRICING_STATE = {
      globalMargin: 30,           // Default 30% markup
      categoryMargins: {
        countertop: 35,
        cabinet: 25,
        appliance: 15,
        flooring: 30,
        other: 30
      },
      showCostView: false,        // Toggle between cost/retail view
      priceLists: [],             // Saved price list configurations
      activePriceList: null,      // Currently active price list name
      customPrices: {}            // Temporary price overrides from Excel import
    };

    const SHARE_STATE = {
      designId: null,             // Supabase design ID
      designToken: null,          // Current design's share token
      permission: 'full_collab',  // Current user's permission level
      isSharedView: false,        // Whether viewing a shared design
      allowedActions: null,       // Actions permitted by current permission
      realtimeChannel: null,      // Supabase realtime subscription channel
      commentsChannel: null,      // Supabase realtime subscription for comments
      isLiveConnected: false,     // Whether realtime is connected
      lastSyncTime: null,         // Last time design was synced
      leadId: null,               // Associated lead/customer ID
      customerName: null          // Customer name for notifications
    };

    // Helper: is this user a shared viewer with edit permission (full_collab)?
    function isFullCollaborator() {
      return SHARE_STATE.isSharedView && SHARE_STATE.allowedActions?.canEdit === true;
    }

    // Echo-back prevention for realtime collaboration
    let _lastOwnSyncTime = null;
    const ECHO_SUPPRESSION_WINDOW_MS = 3000;

    // ===== REALTIME SYNC FOR SHARED DESIGNS =====
    // Enables hot-reload: customers see designer changes instantly

    function subscribeToDesignUpdates(designId) {
      const supabase = getSupabaseClient();
      if (!supabase || !designId) {
        console.log('Cannot subscribe to realtime: no supabase client or design ID');
        // Start polling fallback
        startPollingFallback(designId);
        return;
      }

      // Unsubscribe from any existing channel
      if (SHARE_STATE.realtimeChannel) {
        supabase.removeChannel(SHARE_STATE.realtimeChannel);
      }

      try {
        // Subscribe to changes on this specific design
        const channel = supabase.channel(`design-${designId}`)
          .on('postgres_changes', {
            event: 'UPDATE',
            schema: 'public',
            table: 'room_designs',
            filter: `id=eq.${designId}`
          }, (payload) => {
            console.log(' Realtime update received:', payload);
            handleRealtimeUpdate(payload.new);
          })
          .subscribe((status, err) => {
            console.log('Realtime subscription status:', status, err || '');
            if (status === 'SUBSCRIBED') {
              SHARE_STATE.isLiveConnected = true;
              // Clear polling if realtime connects
              if (SHARE_STATE.pollingInterval) {
                clearInterval(SHARE_STATE.pollingInterval);
                SHARE_STATE.pollingInterval = null;
              }
            } else if (status === 'CHANNEL_ERROR' || status === 'TIMED_OUT') {
              SHARE_STATE.isLiveConnected = false;
              console.warn('Realtime failed, starting polling fallback');
              startPollingFallback(designId);
            }
            updateLiveIndicator();
          });

        SHARE_STATE.realtimeChannel = channel;
        console.log('Subscribed to realtime updates for design:', designId);

        // Also start polling as backup (will be cleared if realtime works)
        setTimeout(() => {
          if (!SHARE_STATE.isLiveConnected) {
            console.log('Realtime not connected after 5s, starting polling');
            startPollingFallback(designId);
          }
        }, 5000);

      } catch (err) {
        console.error('Failed to subscribe to realtime:', err);
        startPollingFallback(designId);
      }
    }

    // ===== REALTIME COMMENT NOTIFICATIONS FOR DESIGNERS =====
    // When a customer comments, the designer sees a toast notification

    function subscribeToCustomerComments(leadId) {
      // Only subscribe if we're a designer (not shared view) and have a lead
      if (SHARE_STATE.isSharedView || !leadId) return;

      const supabase = getSupabaseClient();
      if (!supabase) return;

      // Unsubscribe from any existing comments channel
      if (SHARE_STATE.commentsChannel) {
        supabase.removeChannel(SHARE_STATE.commentsChannel);
      }

      try {
        const channel = supabase.channel(`comments-${leadId}`)
          .on('postgres_changes', {
            event: 'INSERT',
            schema: 'public',
            table: 'customer_messages',
            filter: `customer_id=eq.${leadId}`
          }, (payload) => {
            console.log(' New comment received:', payload);
            handleNewComment(payload.new);
          })
          .subscribe((status, err) => {
            if (status === 'SUBSCRIBED') {
              console.log('Subscribed to customer comments for lead:', leadId);
            } else if (err) {
              console.warn('Comment subscription error:', err);
            }
          });

        SHARE_STATE.commentsChannel = channel;
      } catch (err) {
        console.error('Failed to subscribe to comments:', err);
      }
    }

    function handleNewComment(comment) {
      // Only notify for inbound (customer) messages
      if (comment.direction !== 'inbound') return;

      // Don't notify if viewing shared view (customer's own messages)
      if (SHARE_STATE.isSharedView) return;

      const customerName = SHARE_STATE.customerName || 'Customer';
      const messagePreview = comment.message?.length > 50
        ? comment.message.substring(0, 50) + '...'
        : comment.message;

      // Show clickable toast notification
      window.showCommentNotification(customerName, messagePreview);

      // Update the comments list if visible (fire and forget with error handling)
      if (typeof loadCommentsFromMessages === 'function' && SHARE_STATE.leadId) {
        loadCommentsFromMessages(SHARE_STATE.leadId, SHARE_STATE.shareId)
          .catch(err => console.warn('Error updating comments list:', err));
      }

      // Update the designer messages panel if visible (fire and forget with error handling)
      if (typeof loadDesignerMessages === 'function' && SHARE_STATE.leadId) {
        loadDesignerMessages(SHARE_STATE.leadId)
          .catch(err => console.warn('Error updating messages panel:', err));
      }
    }

    window.showCommentNotification = function(customerName, message) {
      // Validate inputs
      if (!customerName || !message) return;

      // Escape to prevent XSS
      const safeCustomerName = String(customerName).replace(/[<>&"']/g, c => ({
        '<': '&lt;', '>': '&gt;', '&': '&amp;', '"': '&quot;', "'": '&#39;'
      })[c]);
      const safeMessage = String(message).replace(/[<>&"']/g, c => ({
        '<': '&lt;', '>': '&gt;', '&': '&amp;', '"': '&quot;', "'": '&#39;'
      })[c]);

      // Create notification toast
      const toast = document.createElement('div');
      toast.className = 'comment-notification-toast';
      toast.innerHTML = `
        <div class="comment-notification-icon"></div>
        <div class="comment-notification-content">
          <div class="comment-notification-title">${safeCustomerName} commented:</div>
          <div class="comment-notification-message">${safeMessage}</div>
        </div>
        <div class="comment-notification-action">View </div>
      `;

      // Make it clickable - scrolls to comments section
      toast.onclick = () => {
        toast.remove();
        openCommentsPanel();
      };

      document.body.appendChild(toast);

      // Auto-dismiss after 8 seconds
      setTimeout(() => {
        if (toast.parentNode) {
          toast.classList.add('fade-out');
          setTimeout(() => toast.remove(), 300);
        }
      }, 8000);

      // Play notification sound if available
      try {
        const audio = new Audio('data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2teleAA+ipq9q3kMJl2Kvqp1FyxYf7epbhszU3u4p2clOFF0tqRnKjxPc7ShZC0+TnKznmEwQE1xsZxfMkJNcK+aXTRETPGtmFo3Rkr0q5ZYOEhJ+qqUVjpJR/2okFM7TEb/p45RPlBF/6WNUD9RRP+li04/UkT/pYtNPlRD/6WKSz5VQv+liko+VkH/pYlJPlc//6WISD5YPv+lh0Y+Wj7/pYZFPls9/6WFRD5cPP+lhEM+XTv/pYNBPl46/6WCQD5fOf+lgD8+YDj/pX8+PmE3/6V+PT5iNv+lfDw+YzX/pXs7PmQ0/6V6Oj5lM/+leTs+ZjP/pXg6Pmcy/6V3OT5oMf+ldDg+aTH/pXM3Pmow/6VyNj5rL/+lcTU+bC7/pXA0Pm0u/6VvMz5uLf+lbjI+byz/pW0xPnAr/6VsMP5xK/+lazD+cSr/pWov/nIq/6VpLv5zKf+laC3+dCn/pWcs/nUp/6VmLP51Kf+lZSv+dij/pWQr/nYo/6VkKv52KP+lYyr+dyf/pWIp/ngo/6VhKP54J/+lYCj+eSf/pV8n/nkn/6VeJ/56Jv+lXSb+eyb/pVwm/nwm/6VbJf58Jf+lWiX+fSX/pVkk/n4l/6VYJP5+JP+lVyT+fyT/pVYj/oAk/6VVJP6AJP+lVCP+gSP/pVMj/oEj/6VSIP6CI/+lUSH+giL/pVAh/oIi/w==');
        audio.volume = 0.3;
        audio.play().catch(() => {}); // Ignore if blocked
      } catch (e) {}
    };

    function openCommentsPanel() {
      // Check if we're in designer mode (messages section visible)
      const messagesSection = document.getElementById('messagesSection');
      if (messagesSection) {
        // Ensure content is visible
        const content = document.getElementById('messagesContent');
        if (content) content.style.display = 'block';

        // Scroll to messages section in designer view
        messagesSection.scrollIntoView({ behavior: 'smooth', block: 'center' });
        messagesSection.style.boxShadow = '0 0 20px rgba(139, 92, 246, 0.5)';
        setTimeout(() => {
          messagesSection.style.boxShadow = '';
        }, 2000);

        // Focus the reply input
        const replyInput = document.getElementById('designerReplyInput');
        if (replyInput) {
          replyInput.focus();
        }
        return;
      }

      // Otherwise find and click the review/share tab (customer view)
      const reviewTab = document.querySelector('[onclick*="showTab"][onclick*="review"]') ||
                        document.querySelector('[data-tab="review"]') ||
                        document.querySelector('.tab-btn:last-child');

      if (reviewTab) {
        reviewTab.click();
      }

      // Scroll to comments section after a short delay
      setTimeout(() => {
        const commentsSection = document.getElementById('reviewComments') ||
                               document.querySelector('.review-chat-section');
        if (commentsSection) {
          commentsSection.scrollIntoView({ behavior: 'smooth', block: 'center' });
          // Highlight the section briefly
          commentsSection.style.boxShadow = '0 0 20px rgba(139, 92, 246, 0.5)';
          setTimeout(() => {
            commentsSection.style.boxShadow = '';
          }, 2000);
        }

        // Focus the comment input
        const commentInput = document.getElementById('newCommentInput');
        if (commentInput) {
          commentInput.focus();
        }
      }, 300);
    }

    // Fetch customer name from leads table for notifications
    async function fetchCustomerName(leadId) {
      if (!leadId) return;

      try {
        const supabase = getSupabaseClient();
        if (!supabase) return;

        const { data, error } = await supabase
          .from('leads')
          .select('name, first_name, last_name, email')
          .eq('id', leadId)
          .single();

        if (data && !error) {
          SHARE_STATE.customerName = data.name ||
            (data.first_name && data.last_name ? `${data.first_name} ${data.last_name}` : null) ||
            data.first_name ||
            data.email?.split('@')[0] ||
            'Customer';
          console.log('Fetched customer name:', SHARE_STATE.customerName);
        }
      } catch (err) {
        console.warn('Could not fetch customer name:', err);
      }
    }

    // Polling fallback when Realtime isn't available
    function startPollingFallback(designId) {
      if (SHARE_STATE.pollingInterval) return; // Already polling

      console.log('Starting polling fallback for design:', designId);
      SHARE_STATE.lastPollData = null;

      const pollForUpdates = async () => {
        if (!designId) return;

        try {
          const { url: SUPABASE_URL, anonKey: SUPABASE_ANON_KEY } = getSupabaseConfig();

          const response = await fetch(
            `${SUPABASE_URL}/rest/v1/room_designs?id=eq.${designId}&select=updated_at,elements,rooms,room_width,room_depth,settings`,
            {
              headers: {
                'apikey': SUPABASE_ANON_KEY,
                'Authorization': `Bearer ${SUPABASE_ANON_KEY}`
              }
            }
          );

          if (response.ok) {
            const data = await response.json();
            if (data && data.length > 0) {
              const design = data[0];
              // Check if updated since last poll
              if (SHARE_STATE.lastPollData && design.updated_at !== SHARE_STATE.lastPollData) {
                // Echo-back prevention for polling
                if (_lastOwnSyncTime && (Date.now() - _lastOwnSyncTime) < ECHO_SUPPRESSION_WINDOW_MS) {
                  console.log('Poll: skipping echo-back of own update');
                  _lastOwnSyncTime = null;
                } else {
                  console.log('Polling detected update:', design.updated_at);
                  handleRealtimeUpdate(design);
                }
              }
              SHARE_STATE.lastPollData = design.updated_at;
              SHARE_STATE.isLiveConnected = true;
              updateLiveIndicator();
            }
          }
        } catch (err) {
          console.warn('Poll failed:', err);
        }
      };

      // Poll every 5 seconds
      SHARE_STATE.pollingInterval = setInterval(pollForUpdates, 5000);
      pollForUpdates(); // Initial poll

      // Stop polling after 30 minutes to prevent resource drain
      SHARE_STATE.pollingTimeout = setTimeout(() => {
        if (SHARE_STATE.pollingInterval) {
          clearInterval(SHARE_STATE.pollingInterval);
          SHARE_STATE.pollingInterval = null;
          console.log('Polling stopped after 30 minutes - refresh page to resume');
          showToast('Live updates paused. Refresh to resume.', 'info', 5000);
        }
      }, 30 * 60 * 1000);
    }

    function handleRealtimeUpdate(newData) {
      if (!newData) return;

      // Echo-back prevention: skip our own updates bouncing back via Realtime
      if (_lastOwnSyncTime && (Date.now() - _lastOwnSyncTime) < ECHO_SUPPRESSION_WINDOW_MS) {
        console.log('Skipping echo-back of own update');
        _lastOwnSyncTime = null;
        return;
      }

      console.log('Applying realtime update...');
      SHARE_STATE.lastSyncTime = new Date();

      // Show sync notification
      showToast('Design updated by collaborator', 'info', 2000);

      // Update room dimensions first (needed for fitToScreen before deserialization)
      if (newData.room_width) roomWidth = newData.room_width;
      if (newData.room_depth) roomDepth = newData.room_depth;

      const savedScale = newData.settings?.pixelsPerFoot || pixelsPerFoot;

      // Update elements  only if new data has actual content
      if (newData.elements && Array.isArray(newData.elements) && newData.elements.length > 0) {
        elements.length = 0;
        newData.elements.forEach(el => {
          el.textureImg = null;
          deserializeElement(el, savedScale);
          elements.push(el);
        });
      } else if (newData.elements && Array.isArray(newData.elements) && newData.elements.length === 0) {
        console.warn('Realtime update has empty elements  skipping to prevent data loss');
      }

      // Update rooms array if present and non-empty
      const realtimeRooms = (newData.rooms && newData.rooms.length > 0) ? newData.rooms
        : (newData.settings?.rooms && newData.settings.rooms.length > 0) ? newData.settings.rooms
        : null;
      if (realtimeRooms) {
        rooms.length = 0;
        realtimeRooms.forEach(room => {
          room.elements = room.elements || [];
          room.elements.forEach(el => {
            el.textureImg = null;
            deserializeElement(el, savedScale);
          });
          if (room.walls) {
            room.walls.forEach(w => deserializeWall(w, savedScale));
          }
          room.pixelsPerFoot = pixelsPerFoot;
          rooms.push(room);
        });
      }

      // Update settings
      if (newData.settings) {
        if (newData.settings.walls) walls = newData.settings.walls;
        if (newData.settings.pricing_config) {
          PRICING_STATE.globalMargin = newData.settings.pricing_config.globalMargin || 30;
          PRICING_STATE.categoryMargins = newData.settings.pricing_config.categoryMargins || {};
        }
        // Also check for rooms inside settings (new format)
        if (newData.settings.rooms && Array.isArray(newData.settings.rooms) && newData.settings.rooms.length > 0 && !(newData.rooms && newData.rooms.length > 0)) {
          rooms.length = 0;
          newData.settings.rooms.forEach(room => {
            room.elements = room.elements || [];
            room.elements.forEach(el => el.textureImg = null);
            rooms.push(room);
          });
        }
      }

      // Reload textures and redraw
      elements.forEach(el => {
        if (el.texture) {
          const img = new Image();
          img.crossOrigin = 'anonymous';
          img.onload = () => {
            el.textureImg = img;
            draw();
          };
          img.src = el.texture;
        }
      });

      // Redraw 2D canvas
      draw();

      // Update 3D view
      if (currentView === '3d') {
        init3D();
        render3D();
      }

      // Update quote
      calculateQuote();
      buildQuotePreviewData();
      renderQuotePreview();

      // Update review panel if visible
      if (document.getElementById('reviewElements')) {
        populateReviewElements();
      }

      // Update properties panel to show current material info
      updateProperties();

      // Flash the live indicator
      flashLiveIndicator();
    }

    function updateLiveIndicator() {
      const indicator = document.getElementById('liveIndicator');
      if (indicator) {
        indicator.className = SHARE_STATE.isLiveConnected ? 'live-indicator connected' : 'live-indicator disconnected';
        indicator.title = SHARE_STATE.isLiveConnected ? 'Live sync active - changes appear instantly' : 'Disconnected - refresh to see changes';
      }
    }

    function flashLiveIndicator() {
      const indicator = document.getElementById('liveIndicator');
      if (indicator) {
        indicator.classList.add('flash');
        setTimeout(() => indicator.classList.remove('flash'), 1000);
      }
    }

    // Broadcast design changes to connected viewers (called on auto-save)
    async function broadcastDesignUpdate() {
      if (!SHARE_STATE.designId) return;

      const supabase = getSupabaseClient();
      if (!supabase) return;

      try {
        // The database update will trigger the realtime subscription
        // Just update the design record - subscribers will get notified automatically
        console.log('Design update will broadcast via Supabase Realtime');
      } catch (err) {
        console.error('Broadcast error:', err);
      }
    }

    // ===== REALTIME SYNC TEST FUNCTIONS =====
    // Call these from browser console to test realtime functionality

    window.testRealtimeStatus = function() {
      console.log('=== REALTIME SYNC STATUS ===');
      console.log('Design ID:', SHARE_STATE.designId);
      console.log('Is Shared View:', SHARE_STATE.isSharedView);
      console.log('Is Live Connected:', SHARE_STATE.isLiveConnected);
      console.log('Realtime Channel:', SHARE_STATE.realtimeChannel ? 'Active' : 'Not subscribed');
      console.log('Last Sync Time:', SHARE_STATE.lastSyncTime);
      console.log('Supabase Client:', getSupabaseClient() ? 'Available' : 'Not available');
      return SHARE_STATE;
    };

    window.testRealtimeUpdate = async function() {
      if (!SHARE_STATE.designId) {
        console.log('No design ID - save design to cloud first');
        return;
      }

      console.log('=== TESTING REALTIME UPDATE ===');
      console.log('Triggering cloud sync...');

      // Force a sync to trigger realtime for any connected viewers
      await syncDesignToCloud();

      console.log('Sync triggered - check connected viewer for update');
    };

    window.testRealtimeSubscribe = function(designId) {
      const id = designId || SHARE_STATE.designId;
      if (!id) {
        console.log('Please provide a design ID: testRealtimeSubscribe("your-design-id")');
        return;
      }

      console.log('=== SUBSCRIBING TO DESIGN ===');
      subscribeToDesignUpdates(id);
      console.log('Check console for subscription status messages');
    };

    window.simulateRealtimeUpdate = function() {
      console.log('=== SIMULATING REALTIME UPDATE ===');
      // Simulate what happens when a realtime update is received
      handleRealtimeUpdate({
        elements: elements.map(el => ({
          ...el,
          color: '#' + Math.floor(Math.random()*16777215).toString(16) // Random color
        })),
        room_width: roomWidth,
        room_depth: roomDepth
      });
      console.log('Simulated update applied - elements should have random colors');
    };

    // Test comment notification (for debugging)
    window.testCommentNotification = function(message = 'This is a test comment from the customer!') {
      console.log('=== TESTING COMMENT NOTIFICATION ===');
      console.log('showCommentNotification exists:', typeof window.showCommentNotification);
      const customerName = SHARE_STATE.customerName || 'Test Customer';
      window.showCommentNotification(customerName, message);
      console.log('Notification should appear. Click it to go to comments section.');
    };

    // Debug notification status
    window.debugNotifications = function() {
      console.log('=== NOTIFICATION DEBUG ===');
      console.log('Design ID:', SHARE_STATE.designId);
      console.log('Lead ID:', SHARE_STATE.leadId);
      console.log('Customer Name:', SHARE_STATE.customerName);
      console.log('Is Shared View:', SHARE_STATE.isSharedView);
      console.log('Comments Channel:', SHARE_STATE.commentsChannel ? 'Active' : 'Not subscribed');
      console.log('Realtime Channel:', SHARE_STATE.realtimeChannel ? 'Active' : 'Not subscribed');
      console.log('showCommentNotification:', typeof window.showCommentNotification);
      return {
        designId: SHARE_STATE.designId,
        leadId: SHARE_STATE.leadId,
        customerName: SHARE_STATE.customerName,
        isSharedView: SHARE_STATE.isSharedView,
        commentsSubscribed: !!SHARE_STATE.commentsChannel,
        realtimeSubscribed: !!SHARE_STATE.realtimeChannel
      };
    };

    // Pricing access control - only paid subscribers see pricing
    const PRICING_ACCESS = {
      isSubscribed: false,        // Whether user has paid subscription
      accountType: null,          // User's account type (homeowner, pro, fabricator, etc.)
      canViewPricing: false,      // Computed: can this user see pricing?
      checkedAt: null             // When we last checked subscription status
    };

    // Account types that can view pricing (paid tiers)
    const PAID_ACCOUNT_TYPES = ['pro', 'vendor', 'fabricator', 'business', 'enterprise', 'distributor', 'admin', 'super_admin'];

    // Check if current user can view pricing
    async function checkPricingAccess(forceRefresh = false) {
      try {
        // Demo mode - always show as guest with no pricing access
        if (DEMO_MODE) {
          PRICING_ACCESS.isSubscribed = false;
          PRICING_ACCESS.accountType = 'demo';
          PRICING_ACCESS.canViewPricing = false;
          PRICING_ACCESS.checkedAt = Date.now();
          updatePricingVisibility();
          return false;
        }

        const user = window.SgAuth?.getUser();
        let profile = null;

        // If force refresh, fetch directly from database
        if (forceRefresh && user) {
          const supabase = getSupabaseClient();
          if (supabase) {
            const { data } = await supabase
              .from('sg_users')
              .select('account_type, subscription_status')
              .eq('id', user.id)
              .single();
            profile = data;
            console.log('Force refreshed user profile:', profile);
          }
        } else {
          profile = await window.SgAuth?.getProfile?.();
        }

        PRICING_ACCESS.checkedAt = Date.now();

        // Super admin emails always get full access
        const SUPER_ADMIN_EMAILS = ['joshb@surprisegranite.com', 'info@surprisegranite.com'];
        const isSuperAdmin = user && SUPER_ADMIN_EMAILS.includes((user.email || '').toLowerCase());

        if (!user) {
          // Guest user - no pricing access
          PRICING_ACCESS.isSubscribed = false;
          PRICING_ACCESS.accountType = 'guest';
          PRICING_ACCESS.canViewPricing = false;
        } else if (isSuperAdmin) {
          // Super admin - full access regardless of account_type
          PRICING_ACCESS.accountType = 'super_admin';
          PRICING_ACCESS.isSubscribed = true;
          PRICING_ACCESS.canViewPricing = true;
          console.log('Super Admin detected - full pricing access granted');
        } else if (profile) {
          PRICING_ACCESS.accountType = (profile.account_type || 'homeowner').toLowerCase();
          PRICING_ACCESS.isSubscribed = PAID_ACCOUNT_TYPES.includes(PRICING_ACCESS.accountType);
          PRICING_ACCESS.canViewPricing = PRICING_ACCESS.isSubscribed;
          console.log('User account type:', PRICING_ACCESS.accountType, 'Can view pricing:', PRICING_ACCESS.canViewPricing);
        } else {
          // Logged in but no profile - treat as free tier
          PRICING_ACCESS.accountType = 'homeowner';
          PRICING_ACCESS.isSubscribed = false;
          PRICING_ACCESS.canViewPricing = false;
        }

        console.log('Pricing access:', PRICING_ACCESS);
        updatePricingVisibility();
        return PRICING_ACCESS.canViewPricing;
      } catch (err) {
        console.warn('Error checking pricing access:', err);
        PRICING_ACCESS.canViewPricing = false;
        updatePricingVisibility();
        return false;
      }
    }

    // GOD ACCESS - Super admin only features (AI tools, etc.)
    function hasGodAccess() {
      const user = window.SgAuth?.getUser();
      if (!user) return false;
      const SUPER_ADMIN_EMAILS = ['joshb@surprisegranite.com', 'info@surprisegranite.com'];
      return SUPER_ADMIN_EMAILS.includes((user.email || '').toLowerCase());
    }

    // Wrapper for AI Room Scanner - available to all authenticated users
    function showAIImporter() {
      // Check if user is authenticated (or allow demo mode)
      const user = window.SgAuth?.getUser();
      const isDemo = DEMO_MODE;

      if (user || hasGodAccess() || isDemo) {
        // Show AI Room Scanner
        if (typeof window.showPDFImporter === 'function') {
          window.showPDFImporter();
        } else {
          showToast('AI Room Scanner loading...', 'info');
        }
      } else {
        // Not logged in - prompt to sign in
        showComingSoonModal('AI Room Scanner', 'Sign in to use the AI Room Scanner. Upload photos of rooms, countertops, or hand sketches and our AI will create a quote-ready 3D project instantly.');
      }
    }

    // Generic coming soon modal for restricted features
    function showComingSoonModal(featureName, description) {
      const existing = document.getElementById('comingSoonModal');
      if (existing) existing.remove();

      const modal = document.createElement('div');
      modal.id = 'comingSoonModal';
      modal.className = 'cabinet-library-modal';
      modal.innerHTML = `
        <div class="cabinet-library-content" style="max-width: 450px;">
          <div class="cabinet-library-header">
            <h3> ${featureName}</h3>
            <button onclick="this.closest('.cabinet-library-modal').remove()">&times;</button>
          </div>
          <div class="cabinet-library-body" style="text-align: center; padding: 40px;">
            <div style="font-size: 64px; margin-bottom: 20px;"></div>
            <h4 style="margin: 0 0 12px; color: var(--primary);">Coming Soon!</h4>
            <p style="color: var(--text-muted); margin: 0; line-height: 1.6;">
              ${description}
            </p>
            <div style="margin-top: 24px; padding: 16px; background: rgba(99, 102, 241, 0.1); border-radius: 8px;">
              <p style="margin: 0; font-size: 13px; color: var(--text-muted);">
                Want early access? Contact us at<br>
                <a href="mailto:info@surprisegranite.com" style="color: var(--primary);">info@surprisegranite.com</a>
              </p>
            </div>
          </div>
        </div>
      `;
      document.body.appendChild(modal);
      modal.onclick = (e) => { if (e.target === modal) modal.remove(); };
    }

    // ============================================
    // AI ROOM SCANNER - Universal Image to Quote
    // Analyzes room photos, countertops, sketches, and CAD drawings
    // ============================================
    window.showPDFImporter = function() {
      const existing = document.getElementById('pdfImporterModal');
      if (existing) existing.remove();

      const modal = document.createElement('div');
      modal.id = 'pdfImporterModal';
      modal.className = 'cabinet-library-modal';
      modal.innerHTML = `
        <div class="cabinet-library-content" style="max-width: 750px;">
          <div class="cabinet-library-header">
            <h3> AI Room Scanner</h3>
            <button onclick="this.closest('.cabinet-library-modal').remove()">&times;</button>
          </div>
          <div class="cabinet-library-body" style="padding: 24px;">

            <!-- Scan Mode Selection -->
            <div style="margin-bottom: 20px;">
              <label style="display: block; margin-bottom: 10px; font-weight: 600; color: var(--text);">What are you scanning?</label>
              <div id="scanModeGrid" style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px;">
                <button class="scan-mode-btn active" data-mode="room-photo" style="padding: 16px 8px; border: 2px solid var(--primary); border-radius: 10px; background: rgba(99, 102, 241, 0.1); cursor: pointer; text-align: center;">
                  <div style="font-size: 28px; margin-bottom: 6px;"></div>
                  <div style="font-size: 12px; font-weight: 600; color: var(--text);">Room Photo</div>
                  <div style="font-size: 10px; color: var(--text-muted);">Kitchen, bath, etc.</div>
                </button>
                <button class="scan-mode-btn" data-mode="countertop" style="padding: 16px 8px; border: 2px solid var(--border); border-radius: 10px; background: var(--surface); cursor: pointer; text-align: center;">
                  <div style="font-size: 28px; margin-bottom: 6px;"></div>
                  <div style="font-size: 12px; font-weight: 600; color: var(--text);">Countertop</div>
                  <div style="font-size: 10px; color: var(--text-muted);">Existing counter</div>
                </button>
                <button class="scan-mode-btn" data-mode="sketch" style="padding: 16px 8px; border: 2px solid var(--border); border-radius: 10px; background: var(--surface); cursor: pointer; text-align: center;">
                  <div style="font-size: 28px; margin-bottom: 6px;"></div>
                  <div style="font-size: 12px; font-weight: 600; color: var(--text);">Hand Sketch</div>
                  <div style="font-size: 10px; color: var(--text-muted);">Napkin drawings</div>
                </button>
                <button class="scan-mode-btn" data-mode="cad" style="padding: 16px 8px; border: 2px solid var(--border); border-radius: 10px; background: var(--surface); cursor: pointer; text-align: center;">
                  <div style="font-size: 28px; margin-bottom: 6px;"></div>
                  <div style="font-size: 12px; font-weight: 600; color: var(--text);">CAD Drawing</div>
                  <div style="font-size: 10px; color: var(--text-muted);">2020, CabVision</div>
                </button>
              </div>
            </div>

            <!-- Mode-specific tips -->
            <div id="modeTips" style="padding: 12px 16px; background: rgba(99, 102, 241, 0.08); border-radius: 8px; margin-bottom: 20px; font-size: 13px; color: var(--text-muted);">
              <span id="tipIcon" style="margin-right: 8px;"></span>
              <span id="tipText">Take a photo showing the full room. AI will detect cabinets, countertops, appliances and estimate dimensions.</span>
            </div>

            <!-- File Upload Area -->
            <div id="blueprintDropZone" style="border: 2px dashed var(--border); border-radius: 12px; padding: 40px; text-align: center; margin-bottom: 20px; cursor: pointer; transition: all 0.2s;">
              <div id="uploadPlaceholder">
                <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="var(--text-muted)" stroke-width="1.5" style="margin-bottom: 12px;">
                  <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                  <polyline points="17 8 12 3 7 8"/>
                  <line x1="12" y1="3" x2="12" y2="15"/>
                </svg>
                <p style="margin: 0 0 8px; color: var(--text);">Drop image here or click to browse</p>
                <p style="margin: 0; font-size: 12px; color: var(--text-muted);">Supports: PNG, JPG, HEIC, PDF</p>
              </div>
              <div id="uploadPreview" style="display: none;">
                <img id="previewImage" style="max-width: 100%; max-height: 280px; border-radius: 8px;">
                <button id="clearUpload" style="margin-top: 12px; padding: 6px 16px; background: var(--surface); border: 1px solid var(--border); border-radius: 6px; cursor: pointer; color: var(--text);">
                   Clear & Upload Different
                </button>
              </div>
              <input type="file" id="blueprintFileInput" accept="image/*,.pdf" style="display: none;">
            </div>

            <!-- Context & Dimensions Row -->
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px; margin-bottom: 20px;">
              <!-- Context Input -->
              <div>
                <label style="display: block; margin-bottom: 8px; font-weight: 500; color: var(--text); font-size: 13px;">
                  Additional Context <span style="color: var(--text-muted); font-weight: 400;">(optional)</span>
                </label>
                <textarea id="blueprintContext" placeholder="E.g., 'L-shaped kitchen, granite counters' or 'Focus on the island only'"
                  style="width: 100%; height: 70px; padding: 10px; border: 1px solid var(--border); border-radius: 8px; background: var(--surface); color: var(--text); resize: none; font-size: 13px;"></textarea>
              </div>
              <!-- Known Dimensions -->
              <div>
                <label style="display: block; margin-bottom: 8px; font-weight: 500; color: var(--text); font-size: 13px;">
                  Known Dimensions <span style="color: var(--text-muted); font-weight: 400;">(helps accuracy)</span>
                </label>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                  <div>
                    <input type="number" id="knownWidth" placeholder="Width (ft)" min="1" max="100"
                      style="width: 100%; padding: 10px; border: 1px solid var(--border); border-radius: 8px; background: var(--surface); color: var(--text); font-size: 13px;">
                  </div>
                  <div>
                    <input type="number" id="knownDepth" placeholder="Depth (ft)" min="1" max="100"
                      style="width: 100%; padding: 10px; border: 1px solid var(--border); border-radius: 8px; background: var(--surface); color: var(--text); font-size: 13px;">
                  </div>
                </div>
                <p style="margin: 4px 0 0; font-size: 10px; color: var(--text-muted);">Enter room or counter dimensions if known</p>
              </div>
            </div>

            <!-- Project Type -->
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px; margin-bottom: 20px;">
              <div>
                <label style="display: block; margin-bottom: 8px; font-weight: 500; color: var(--text); font-size: 13px;">Project Type</label>
                <select id="blueprintProjectType" style="width: 100%; padding: 10px; border: 1px solid var(--border); border-radius: 8px; background: var(--surface); color: var(--text); font-size: 13px;">
                  <option value="kitchen-remodel">Kitchen</option>
                  <option value="bathroom-remodel">Bathroom</option>
                  <option value="laundry">Laundry Room</option>
                  <option value="commercial-cabinets">Commercial</option>
                  <option value="outdoor-kitchen">Outdoor Kitchen</option>
                  <option value="full-home">Full Home</option>
                </select>
              </div>
              <div>
                <label style="display: block; margin-bottom: 8px; font-weight: 500; color: var(--text); font-size: 13px;">What to Extract</label>
                <select id="extractMode" style="width: 100%; padding: 10px; border: 1px solid var(--border); border-radius: 8px; background: var(--surface); color: var(--text); font-size: 13px;">
                  <option value="all">Everything (cabinets, counters, appliances)</option>
                  <option value="cabinets">Cabinets Only</option>
                  <option value="countertops">Countertops Only</option>
                  <option value="layout">Room Layout Only</option>
                </select>
              </div>
            </div>

            <!-- Import Options -->
            <div style="margin-bottom: 20px; padding: 14px 16px; background: var(--surface); border: 1px solid var(--border); border-radius: 8px;">
              <div style="display: flex; flex-wrap: wrap; gap: 16px;">
                <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; font-size: 13px;">
                  <input type="checkbox" id="clearBeforeImport" style="width: 16px; height: 16px;">
                  <span style="color: var(--text);">Clear existing elements</span>
                </label>
                <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; font-size: 13px;">
                  <input type="checkbox" id="updateRoomSize" checked style="width: 16px; height: 16px;">
                  <span style="color: var(--text);">Update room dimensions</span>
                </label>
                <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; font-size: 13px;">
                  <input type="checkbox" id="autoCountertop" checked style="width: 16px; height: 16px;">
                  <span style="color: var(--text);">Auto-add countertops</span>
                </label>
              </div>
            </div>

            <!-- Status/Progress -->
            <div id="importStatus" style="display: none; padding: 16px; background: var(--surface); border-radius: 8px; margin-bottom: 20px;">
              <div style="display: flex; align-items: center; gap: 12px;">
                <div class="spinner" style="width: 24px; height: 24px; border: 3px solid var(--border); border-top-color: var(--primary); border-radius: 50%; animation: spin 1s linear infinite;"></div>
                <div>
                  <span id="importStatusText" style="color: var(--text); font-weight: 500;">Analyzing image...</span>
                  <div id="importStatusDetail" style="font-size: 12px; color: var(--text-muted); margin-top: 2px;"></div>
                </div>
              </div>
              <div id="progressBar" style="margin-top: 12px; height: 4px; background: var(--border); border-radius: 2px; overflow: hidden;">
                <div id="progressFill" style="height: 100%; width: 0%; background: var(--primary); transition: width 0.3s;"></div>
              </div>
            </div>

            <!-- Action Buttons -->
            <div style="display: flex; gap: 12px; justify-content: flex-end;">
              <button onclick="this.closest('.cabinet-library-modal').remove()"
                style="padding: 10px 24px; background: var(--surface); border: 1px solid var(--border); border-radius: 8px; cursor: pointer; color: var(--text); font-weight: 500;">
                Cancel
              </button>
              <button id="analyzeBtn" onclick="analyzeRoomImage()" disabled
                style="padding: 10px 28px; background: linear-gradient(135deg, #6366f1, #8b5cf6); border: none; border-radius: 8px; cursor: pointer; color: white; font-weight: 600; opacity: 0.5; font-size: 14px;">
                 Scan & Create Quote
              </button>
            </div>
          </div>
        </div>
        <style>
          @keyframes spin { to { transform: rotate(360deg); } }
          #blueprintDropZone:hover, #blueprintDropZone.dragover {
            border-color: var(--primary);
            background: rgba(99, 102, 241, 0.05);
          }
          .scan-mode-btn:hover {
            border-color: var(--primary) !important;
            background: rgba(99, 102, 241, 0.05) !important;
          }
          .scan-mode-btn.active {
            border-color: var(--primary) !important;
            background: rgba(99, 102, 241, 0.1) !important;
          }
        </style>
      `;
      document.body.appendChild(modal);
      modal.onclick = (e) => { if (e.target === modal) modal.remove(); };

      // Scan mode selection
      let currentScanMode = 'room-photo';
      const modeTips = {
        'room-photo': { icon: '', text: 'Take a photo showing the full room. AI will detect cabinets, countertops, appliances and estimate dimensions.' },
        'countertop': { icon: '', text: 'Photo your existing countertop from above. Include a reference object (like a phone) for scale if possible.' },
        'sketch': { icon: '', text: 'Upload a hand-drawn sketch or napkin diagram. Label dimensions if you have them. AI will interpret your layout.' },
        'cad': { icon: '', text: 'Upload elevation views, plan views, or cabinet schedules from 2020 Design, Cabinet Vision, KCD, or similar CAD software.' }
      };

      document.querySelectorAll('.scan-mode-btn').forEach(btn => {
        btn.onclick = () => {
          document.querySelectorAll('.scan-mode-btn').forEach(b => {
            b.classList.remove('active');
            b.style.borderColor = 'var(--border)';
            b.style.background = 'var(--surface)';
          });
          btn.classList.add('active');
          btn.style.borderColor = 'var(--primary)';
          btn.style.background = 'rgba(99, 102, 241, 0.1)';
          currentScanMode = btn.dataset.mode;

          const tip = modeTips[currentScanMode];
          document.getElementById('tipIcon').textContent = tip.icon;
          document.getElementById('tipText').textContent = tip.text;
        };
      });

      // Set up file upload handlers
      const dropZone = document.getElementById('blueprintDropZone');
      const fileInput = document.getElementById('blueprintFileInput');
      const analyzeBtn = document.getElementById('analyzeBtn');
      let uploadedImageData = null;

      dropZone.onclick = () => fileInput.click();

      dropZone.ondragover = (e) => {
        e.preventDefault();
        dropZone.classList.add('dragover');
      };
      dropZone.ondragleave = () => dropZone.classList.remove('dragover');
      dropZone.ondrop = (e) => {
        e.preventDefault();
        dropZone.classList.remove('dragover');
        const file = e.dataTransfer.files[0];
        if (file) handleBlueprintFile(file);
      };

      fileInput.onchange = (e) => {
        const file = e.target.files[0];
        if (file) handleBlueprintFile(file);
      };

      document.getElementById('clearUpload').onclick = (e) => {
        e.stopPropagation();
        uploadedImageData = null;
        document.getElementById('uploadPlaceholder').style.display = 'block';
        document.getElementById('uploadPreview').style.display = 'none';
        analyzeBtn.disabled = true;
        analyzeBtn.style.opacity = '0.5';
      };

      function handleBlueprintFile(file) {
        if (!file.type.startsWith('image/') && file.type !== 'application/pdf') {
          showToast('Please upload an image or PDF file', 'error');
          return;
        }

        const reader = new FileReader();
        reader.onload = (e) => {
          uploadedImageData = e.target.result;
          document.getElementById('previewImage').src = uploadedImageData;
          document.getElementById('uploadPlaceholder').style.display = 'none';
          document.getElementById('uploadPreview').style.display = 'block';
          analyzeBtn.disabled = false;
          analyzeBtn.style.opacity = '1';
        };
        reader.readAsDataURL(file);
      }

      // Main analysis function
      window.analyzeRoomImage = async function() {
        if (!uploadedImageData) {
          showToast('Please upload an image first', 'error');
          return;
        }

        const statusDiv = document.getElementById('importStatus');
        const statusText = document.getElementById('importStatusText');
        const statusDetail = document.getElementById('importStatusDetail');
        const progressFill = document.getElementById('progressFill');
        const analyzeBtn = document.getElementById('analyzeBtn');

        statusDiv.style.display = 'block';
        analyzeBtn.disabled = true;
        analyzeBtn.style.opacity = '0.5';

        // Build context based on scan mode and user inputs
        const knownWidth = document.getElementById('knownWidth').value;
        const knownDepth = document.getElementById('knownDepth').value;
        const extractMode = document.getElementById('extractMode').value;
        let userContext = document.getElementById('blueprintContext').value || '';

        // Add scan mode context
        const modeContexts = {
          'room-photo': 'This is a photograph of an actual room. Estimate dimensions from standard cabinet/appliance sizes. Identify visible cabinets, countertops, and appliances.',
          'countertop': 'This is a photograph of an existing countertop. Focus on the counter shape, edges, and estimate dimensions. Identify material if possible.',
          'sketch': 'This is a hand-drawn sketch or diagram. Interpret the layout and any labeled dimensions. Convert the sketch into cabinet and countertop elements.',
          'cad': 'This is a CAD drawing or elevation view from design software. Extract precise cabinet data with exact dimensions and positions.'
        };

        userContext = `${modeContexts[currentScanMode]} ${userContext}`;

        if (knownWidth || knownDepth) {
          userContext += ` Known dimensions: ${knownWidth ? `width=${knownWidth}ft` : ''} ${knownDepth ? `depth=${knownDepth}ft` : ''}`;
        }

        if (extractMode !== 'all') {
          userContext += ` Focus on extracting: ${extractMode}`;
        }

        try {
          // Progress simulation
          const progressSteps = [
            { pct: 10, text: 'Uploading image...', detail: 'Preparing for analysis' },
            { pct: 25, text: 'Analyzing with AI...', detail: 'Detecting room layout' },
            { pct: 50, text: 'Identifying elements...', detail: 'Finding cabinets & counters' },
            { pct: 75, text: 'Extracting dimensions...', detail: 'Calculating measurements' },
            { pct: 90, text: 'Building layout...', detail: 'Creating quote elements' }
          ];

          let stepIndex = 0;
          const progressInterval = setInterval(() => {
            if (stepIndex < progressSteps.length) {
              const step = progressSteps[stepIndex];
              progressFill.style.width = step.pct + '%';
              statusText.textContent = step.text;
              statusDetail.textContent = step.detail;
              stepIndex++;
            }
          }, 1500);

          const response = await fetch('/api/ai/room-scan', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              image: uploadedImageData,
              scanMode: currentScanMode,
              projectType: document.getElementById('blueprintProjectType').value,
              userContext: userContext,
              extractMode: extractMode,
              knownDimensions: (knownWidth || knownDepth) ? { width: parseFloat(knownWidth) || null, depth: parseFloat(knownDepth) || null } : null
            })
          });

          clearInterval(progressInterval);

          // If room-scan endpoint doesn't exist, fall back to blueprint endpoint
          let data;
          if (response.status === 404) {
            // Fallback to existing blueprint endpoint
            const fallbackResponse = await fetch('/api/ai/blueprint', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                image: uploadedImageData,
                projectType: document.getElementById('blueprintProjectType').value,
                userContext: userContext
              })
            });
            data = await fallbackResponse.json();
          } else {
            data = await response.json();
          }

          if (data.error) {
            throw new Error(data.error);
          }

          progressFill.style.width = '100%';
          statusText.textContent = 'Processing results...';
          statusDetail.textContent = 'Creating design elements';

          // Process the AI response and create elements
          const importResult = await processAIBlueprintResult(data, {
            clearExisting: document.getElementById('clearBeforeImport').checked,
            updateRoomSize: document.getElementById('updateRoomSize').checked,
            autoCountertop: document.getElementById('autoCountertop')?.checked ?? true
          });

          statusDiv.style.display = 'none';

          // Show success modal with results
          showImportResultModal(importResult);

          // Close the importer modal
          document.getElementById('pdfImporterModal')?.remove();

        } catch (error) {
          console.error('Blueprint analysis error:', error);
          statusText.textContent = 'Error: ' + error.message;
          statusDiv.style.background = 'rgba(239, 68, 68, 0.1)';
          analyzeBtn.disabled = false;
          analyzeBtn.style.opacity = '1';
        }
      };
    };

    // Process AI blueprint analysis result and create elements
    async function processAIBlueprintResult(data, options = {}) {
      const { clearExisting = false, updateRoomSize = true, autoCountertop = true } = options;
      const result = { cabinetsAdded: 0, appliancesAdded: 0, countertopsAdded: 0, roomUpdated: false, warnings: [], confidence: data.confidence || 'medium' };

      // Find room data from response
      const rooms = data.rooms || [];
      if (rooms.length === 0) {
        result.warnings.push('No rooms detected in the image');
        return result;
      }

      const room = rooms[0]; // Use first room
      const cabinets = room.cabinets || [];
      const appliances = room.appliances || [];
      const countertops = room.countertops || data.countertops || [];

      // Clear existing elements if requested
      if (clearExisting) {
        elements.length = 0;
        elementListDirty = true;
      }

      // Update room dimensions if detected
      if (updateRoomSize && room.widthFt && room.depthFt) {
        roomWidth = room.widthFt;
        roomDepth = room.depthFt;
        result.roomUpdated = true;

        // Update room dimension inputs if they exist
        const widthInput = document.getElementById('roomWidth');
        const depthInput = document.getElementById('roomDepth');
        if (widthInput) widthInput.value = roomWidth;
        if (depthInput) depthInput.value = roomDepth;
      }

      // Calculate positions along each wall
      const wallPositions = { top: 0, bottom: 0, left: 0, right: 0 };
      const wallPadding = 0.5; // Half foot padding from wall corners

      // Helper to get element type from AI cabinet type
      function getElementType(cabType) {
        const typeMap = {
          'base-cabinet': 'base-cabinet',
          'wall-cabinet': 'wall-cabinet',
          'tall-cabinet': 'tall-cabinet',
          'sink-base': 'sink-base',
          'drawer-base': 'drawer-base',
          'corner-cabinet': 'corner-cabinet',
          'lazy-susan': 'lazy-susan',
          'blind-corner': 'blind-corner',
          'island': 'island'
        };
        return typeMap[cabType] || 'base-cabinet';
      }

      // Helper to get cabinet color based on type
      function getCabinetColor(cabType) {
        if (cabType.includes('wall')) return '#B8860B';
        if (cabType.includes('tall')) return '#654321';
        return '#8B4513'; // Base cabinet brown
      }

      // Place cabinets along walls
      for (const cab of cabinets) {
        const wall = cab.wall || 'top';
        const widthFt = (cab.width || 36) / 12; // Convert inches to feet
        const depthFt = (cab.depth || 24) / 12;
        const heightFt = (cab.height || 34.5) / 12;
        const elementType = getElementType(cab.type);

        let x, y, rotation = 0;

        // Position based on wall
        switch (wall) {
          case 'top': // Back wall
            x = wallPadding + wallPositions.top;
            y = wallPadding;
            wallPositions.top += widthFt + 0.1; // Small gap
            break;
          case 'bottom': // Front wall
            x = wallPadding + wallPositions.bottom;
            y = roomDepth - depthFt - wallPadding;
            rotation = 180;
            wallPositions.bottom += widthFt + 0.1;
            break;
          case 'left': // Left wall
            x = wallPadding;
            y = wallPadding + wallPositions.left;
            rotation = 270;
            wallPositions.left += widthFt + 0.1;
            break;
          case 'right': // Right wall
            x = roomWidth - depthFt - wallPadding;
            y = wallPadding + wallPositions.right;
            rotation = 90;
            wallPositions.right += widthFt + 0.1;
            break;
          case 'island': // Center island
            x = roomWidth / 2 - widthFt / 2;
            y = roomDepth / 2 - depthFt / 2;
            break;
          default:
            x = wallPadding + wallPositions.top;
            y = wallPadding;
            wallPositions.top += widthFt + 0.1;
        }

        // Create element
        const element = {
          id: Date.now() + Math.random(),
          type: elementType,
          x: x * pixelsPerFoot,
          y: y * pixelsPerFoot,
          width: widthFt,
          height: depthFt,
          rotation: rotation,
          color: getCabinetColor(cab.type),
          label: cab.label || elementType.replace('-', ' ').replace(/\b\w/g, l => l.toUpperCase()),
          locked: false,
          roomId: currentRoom,
          floorLevel: cabinetSettings?.currentFloor || 1,
          construction: cabinetSettings?.construction || 'framed',
          doorStyle: cabinetSettings?.doorStyle || 'shaker',
          doorOverlay: cabinetSettings?.doorOverlay || 'full',
          cabinetFinish: cabinetSettings?.cabinetFinish || 'wood-grain',
          grainType: cabinetSettings?.grainType || 'oak',
          // Store original dimensions from AI
          aiImported: true,
          aiLabel: cab.label,
          aiWall: wall,
          aiWidthInches: cab.width,
          aiDepthInches: cab.depth,
          aiHeightInches: cab.height
        };

        elements.push(element);
        result.cabinetsAdded++;
      }

      // Place appliances
      for (const app of appliances) {
        const wall = app.wall || 'top';
        const widthFt = (app.width || 30) / 12;
        const depthFt = 2; // Standard appliance depth

        // Determine appliance type and dimensions
        let elementType = 'refrigerator';
        let height = 5.75; // Default fridge height in feet
        let color = '#C0C0C0'; // Stainless steel

        if (app.type === 'range' || app.type === 'stove') {
          elementType = 'range';
          height = 3; // Range footprint depth
        } else if (app.type === 'dishwasher') {
          elementType = 'dishwasher';
          height = 2;
        } else if (app.type === 'microwave') {
          elementType = 'microwave';
          height = 1;
        }

        let x, y, rotation = 0;

        switch (wall) {
          case 'top':
            x = wallPadding + wallPositions.top;
            y = wallPadding;
            wallPositions.top += widthFt + 0.1;
            break;
          case 'bottom':
            x = wallPadding + wallPositions.bottom;
            y = roomDepth - depthFt - wallPadding;
            rotation = 180;
            wallPositions.bottom += widthFt + 0.1;
            break;
          case 'left':
            x = wallPadding;
            y = wallPadding + wallPositions.left;
            rotation = 270;
            wallPositions.left += widthFt + 0.1;
            break;
          case 'right':
            x = roomWidth - depthFt - wallPadding;
            y = wallPadding + wallPositions.right;
            rotation = 90;
            wallPositions.right += widthFt + 0.1;
            break;
          default:
            x = wallPadding + wallPositions.top;
            y = wallPadding;
            wallPositions.top += widthFt + 0.1;
        }

        const element = {
          id: Date.now() + Math.random(),
          type: elementType,
          x: x * pixelsPerFoot,
          y: y * pixelsPerFoot,
          width: widthFt,
          height: depthFt,
          rotation: rotation,
          color: color,
          label: app.type ? app.type.charAt(0).toUpperCase() + app.type.slice(1) : 'Appliance',
          locked: false,
          roomId: currentRoom,
          floorLevel: cabinetSettings?.currentFloor || 1,
          aiImported: true,
          aiWall: wall
        };

        elements.push(element);
        result.appliancesAdded++;
      }

      // Handle countertops from AI detection
      for (const counter of countertops) {
        const widthFt = (counter.width || 96) / 12;
        const depthFt = (counter.depth || 25.5) / 12;

        const element = {
          id: Date.now() + Math.random(),
          type: 'countertop',
          x: (counter.x || 0.5) * pixelsPerFoot,
          y: (counter.y || 0.5) * pixelsPerFoot,
          width: widthFt,
          height: depthFt,
          rotation: counter.rotation || 0,
          color: '#4a5568',
          label: counter.material || 'Countertop',
          locked: false,
          roomId: currentRoom,
          floorLevel: cabinetSettings?.currentFloor || 1,
          edgeProfile: 'eased',
          thickness: '3cm',
          overhangFront: 0.125,
          overhangBack: 0,
          overhangLeft: 0.125,
          overhangRight: 0.125,
          aiImported: true,
          aiMaterial: counter.material
        };

        elements.push(element);
        result.countertopsAdded++;
      }

      // Auto-generate countertops over base cabinets if enabled
      const autoCountertopEnabled = document.getElementById('autoCountertop')?.checked ?? autoCountertop;
      if (autoCountertopEnabled && result.cabinetsAdded > 0 && result.countertopsAdded === 0) {
        // Group base cabinets by wall
        const baseCabinetsByWall = { top: [], bottom: [], left: [], right: [], island: [] };

        elements.forEach(el => {
          if (el.aiImported && ['base-cabinet', 'sink-base', 'drawer-base', 'corner-cabinet'].includes(el.type)) {
            const wall = el.aiWall || 'top';
            baseCabinetsByWall[wall].push(el);
          }
        });

        // Create countertop for each wall that has base cabinets
        const overhang = 0.125; // 1.5 inches in feet

        Object.entries(baseCabinetsByWall).forEach(([wall, cabs]) => {
          if (cabs.length === 0) return;

          // Sort cabinets by position
          if (wall === 'top' || wall === 'bottom') {
            cabs.sort((a, b) => a.x - b.x);
          } else {
            cabs.sort((a, b) => a.y - b.y);
          }

          // Calculate bounding box
          const first = cabs[0];
          const last = cabs[cabs.length - 1];

          let counterX, counterY, counterWidth, counterHeight, counterRotation = 0;

          if (wall === 'top') {
            counterX = (first.x / pixelsPerFoot) - overhang;
            counterY = (first.y / pixelsPerFoot) - overhang;
            counterWidth = ((last.x + last.width * pixelsPerFoot - first.x) / pixelsPerFoot) + overhang * 2;
            counterHeight = first.height + overhang * 2;
          } else if (wall === 'bottom') {
            counterX = (first.x / pixelsPerFoot) - overhang;
            counterY = (first.y / pixelsPerFoot) - overhang;
            counterWidth = ((last.x + last.width * pixelsPerFoot - first.x) / pixelsPerFoot) + overhang * 2;
            counterHeight = first.height + overhang * 2;
            counterRotation = 180;
          } else if (wall === 'left' || wall === 'right') {
            counterX = (first.x / pixelsPerFoot) - overhang;
            counterY = (first.y / pixelsPerFoot) - overhang;
            counterWidth = ((last.y + last.width * pixelsPerFoot - first.y) / pixelsPerFoot) + overhang * 2;
            counterHeight = first.height + overhang * 2;
            counterRotation = wall === 'left' ? 270 : 90;
          } else if (wall === 'island') {
            const minX = Math.min(...cabs.map(c => c.x));
            const maxX = Math.max(...cabs.map(c => c.x + c.width * pixelsPerFoot));
            const minY = Math.min(...cabs.map(c => c.y));
            const maxY = Math.max(...cabs.map(c => c.y + c.height * pixelsPerFoot));
            counterX = (minX / pixelsPerFoot) - overhang;
            counterY = (minY / pixelsPerFoot) - overhang;
            counterWidth = ((maxX - minX) / pixelsPerFoot) + overhang * 2;
            counterHeight = ((maxY - minY) / pixelsPerFoot) + overhang * 2;
          }

          if (counterWidth && counterHeight) {
            const counterElement = {
              id: Date.now() + Math.random() + Math.random(),
              type: 'countertop',
              x: counterX * pixelsPerFoot,
              y: counterY * pixelsPerFoot,
              width: counterWidth,
              height: counterHeight,
              rotation: counterRotation,
              color: '#4a5568',
              label: `${wall.charAt(0).toUpperCase() + wall.slice(1)} Counter`,
              locked: false,
              roomId: currentRoom,
              floorLevel: cabinetSettings?.currentFloor || 1,
              edgeProfile: 'eased',
              thickness: '3cm',
              overhangFront: 0.167,
              overhangBack: 0,
              overhangLeft: overhang,
              overhangRight: overhang,
              aiImported: true,
              aiWall: wall,
              autoGenerated: true
            };

            elements.push(counterElement);
            result.countertopsAdded++;
          }
        });
      }

      // Update the canvas
      elementListDirty = true;
      draw();
      calculateQuote();
      saveUndoState();

      // Switch to 3D view if we added elements
      if (result.cabinetsAdded > 0 || result.appliancesAdded > 0 || result.countertopsAdded > 0) {
        if (currentView === '2d') {
          // Optionally auto-switch to 3D
        }
        update3DScene();
      }

      return result;
    }

    // Show import result modal
    function showImportResultModal(result) {
      const existing = document.getElementById('importResultModal');
      if (existing) existing.remove();

      const hasItems = result.cabinetsAdded > 0 || result.appliancesAdded > 0 || result.countertopsAdded > 0;
      const totalItems = result.cabinetsAdded + result.appliancesAdded + result.countertopsAdded;

      const modal = document.createElement('div');
      modal.id = 'importResultModal';
      modal.className = 'cabinet-library-modal';
      modal.innerHTML = `
        <div class="cabinet-library-content" style="max-width: 500px;">
          <div class="cabinet-library-header">
            <h3>${hasItems ? ' Scan Complete' : ' Scan Results'}</h3>
            <button onclick="this.closest('.cabinet-library-modal').remove()">&times;</button>
          </div>
          <div class="cabinet-library-body" style="text-align: center; padding: 30px;">
            ${hasItems ? `
              <div style="font-size: 48px; margin-bottom: 16px;"></div>
              <h4 style="margin: 0 0 8px; color: var(--text);">Quote Project Created!</h4>
              <p style="margin: 0 0 20px; font-size: 13px; color: var(--text-muted);">
                AI detected ${totalItems} element${totalItems > 1 ? 's' : ''} from your image
                ${result.confidence ? `<span style="display: inline-block; padding: 2px 8px; background: ${result.confidence === 'high' ? 'rgba(34, 197, 94, 0.2)' : result.confidence === 'medium' ? 'rgba(251, 191, 36, 0.2)' : 'rgba(239, 68, 68, 0.2)'}; border-radius: 4px; font-size: 11px; margin-left: 6px;">${result.confidence} confidence</span>` : ''}
              </p>
              <div style="display: flex; gap: 16px; justify-content: center; margin-bottom: 20px; flex-wrap: wrap;">
                ${result.cabinetsAdded > 0 ? `
                <div style="text-align: center; padding: 12px 20px; background: var(--surface); border-radius: 8px; min-width: 80px;">
                  <div style="font-size: 24px; font-weight: 700; color: var(--primary);">${result.cabinetsAdded}</div>
                  <div style="font-size: 11px; color: var(--text-muted);">Cabinets</div>
                </div>` : ''}
                ${result.countertopsAdded > 0 ? `
                <div style="text-align: center; padding: 12px 20px; background: var(--surface); border-radius: 8px; min-width: 80px;">
                  <div style="font-size: 24px; font-weight: 700; color: #10b981;">${result.countertopsAdded}</div>
                  <div style="font-size: 11px; color: var(--text-muted);">Countertops</div>
                </div>` : ''}
                ${result.appliancesAdded > 0 ? `
                <div style="text-align: center; padding: 12px 20px; background: var(--surface); border-radius: 8px; min-width: 80px;">
                  <div style="font-size: 24px; font-weight: 700; color: #f59e0b;">${result.appliancesAdded}</div>
                  <div style="font-size: 11px; color: var(--text-muted);">Appliances</div>
                </div>` : ''}
              </div>
              ${result.roomUpdated ? '<p style="color: var(--text-muted); font-size: 13px; margin-bottom: 16px;">Room dimensions updated from image.</p>' : ''}
              <div style="padding: 12px 16px; background: rgba(99, 102, 241, 0.1); border-radius: 8px; margin-bottom: 16px;">
                <p style="margin: 0; font-size: 12px; color: var(--text-muted);">
                   <strong>Tip:</strong> Review and adjust positions in 2D view, then switch to 3D to see your layout. Select elements to edit dimensions or add materials.
                </p>
              </div>
            ` : `
              <div style="font-size: 48px; margin-bottom: 16px;"></div>
              <h4 style="margin: 0 0 16px; color: var(--text);">No Elements Detected</h4>
              <p style="color: var(--text-muted); line-height: 1.6;">
                The AI couldn't detect elements in this image. Try:
              </p>
              <ul style="text-align: left; color: var(--text-muted); padding-left: 20px; margin: 16px 0; line-height: 1.8;">
                <li>Taking a clearer photo with better lighting</li>
                <li>Including more of the room in the shot</li>
                <li>Adding context about what you're scanning</li>
                <li>Using a different angle or perspective</li>
              </ul>
            `}
            ${result.warnings && result.warnings.length > 0 ? `
              <div style="margin-top: 16px; padding: 12px; background: rgba(251, 191, 36, 0.1); border-radius: 8px; text-align: left;">
                <p style="margin: 0; font-size: 12px; color: #B45309;"><strong>Notes:</strong></p>
                ${result.warnings.map(w => `<p style="margin: 4px 0 0; font-size: 12px; color: var(--text-muted);"> ${w}</p>`).join('')}
              </div>
            ` : ''}
            <button onclick="this.closest('.cabinet-library-modal').remove()"
              style="margin-top: 20px; padding: 10px 32px; background: var(--primary); border: none; border-radius: 8px; cursor: pointer; color: white; font-weight: 500;">
              ${hasItems ? 'View in Designer' : 'Close'}
            </button>
          </div>
        </div>
      `;
      document.body.appendChild(modal);
      modal.onclick = (e) => { if (e.target === modal) modal.remove(); };
    }

    // ============================================
    // AI CHAT DESIGNER - Natural Language Room Builder
    // ============================================
    let aiChatOpen = false;
    let aiChatHistory = [];
    let aiChatProcessing = false;

    function toggleAIChatDesigner() {
      const existing = document.getElementById('aiChatPanel');
      if (existing) {
        aiChatOpen = !aiChatOpen;
        existing.style.transform = aiChatOpen ? 'translateX(0)' : 'translateX(100%)';
        return;
      }

      // Create the chat panel
      const panel = document.createElement('div');
      panel.id = 'aiChatPanel';
      panel.innerHTML = `
        <style>
          #aiChatPanel {
            position: fixed;
            top: 60px;
            right: 0;
            width: 380px;
            height: calc(100vh - 60px);
            background: var(--bg);
            border-left: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            z-index: 1000;
            transform: translateX(0);
            transition: transform 0.3s ease;
            box-shadow: -4px 0 20px rgba(0,0,0,0.3);
          }
          #aiChatPanel .chat-header {
            padding: 16px 20px;
            background: linear-gradient(135deg, rgba(99, 102, 241, 0.15), rgba(139, 92, 246, 0.15));
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
          }
          #aiChatPanel .chat-header h3 {
            margin: 0;
            font-size: 16px;
            display: flex;
            align-items: center;
            gap: 10px;
          }
          #aiChatPanel .chat-header h3 span {
            background: linear-gradient(135deg, #6366f1, #8b5cf6);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
          }
          #aiChatPanel .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
            display: flex;
            flex-direction: column;
            gap: 12px;
          }
          #aiChatPanel .chat-message {
            max-width: 90%;
            padding: 12px 16px;
            border-radius: 16px;
            font-size: 13px;
            line-height: 1.5;
          }
          #aiChatPanel .chat-message.user {
            align-self: flex-end;
            background: linear-gradient(135deg, #6366f1, #8b5cf6);
            color: white;
            border-bottom-right-radius: 4px;
          }
          #aiChatPanel .chat-message.assistant {
            align-self: flex-start;
            background: var(--surface);
            border: 1px solid var(--border);
            border-bottom-left-radius: 4px;
          }
          #aiChatPanel .chat-message.system {
            align-self: center;
            background: rgba(251, 191, 36, 0.1);
            border: 1px solid rgba(251, 191, 36, 0.3);
            color: var(--text-muted);
            font-size: 12px;
            max-width: 100%;
          }
          #aiChatPanel .chat-message .action-badge {
            display: inline-block;
            background: rgba(99, 102, 241, 0.2);
            color: var(--primary);
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 11px;
            margin-top: 8px;
          }
          #aiChatPanel .chat-input-area {
            padding: 16px;
            border-top: 1px solid var(--border);
            background: var(--surface);
          }
          #aiChatPanel .chat-input-wrapper {
            display: flex;
            gap: 8px;
            align-items: flex-end;
          }
          #aiChatPanel .chat-input {
            flex: 1;
            padding: 12px 16px;
            border: 1px solid var(--border);
            border-radius: 24px;
            background: var(--bg);
            color: var(--text);
            font-size: 14px;
            resize: none;
            max-height: 100px;
            outline: none;
          }
          #aiChatPanel .chat-input:focus {
            border-color: var(--primary);
          }
          #aiChatPanel .chat-send-btn {
            width: 44px;
            height: 44px;
            border-radius: 50%;
            background: linear-gradient(135deg, #6366f1, #8b5cf6);
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.2s, opacity 0.2s;
          }
          #aiChatPanel .chat-send-btn:hover {
            transform: scale(1.05);
          }
          #aiChatPanel .chat-send-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
          }
          #aiChatPanel .quick-actions {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin-bottom: 12px;
          }
          #aiChatPanel .quick-action {
            padding: 6px 12px;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 16px;
            font-size: 12px;
            cursor: pointer;
            color: var(--text-muted);
            transition: all 0.2s;
          }
          #aiChatPanel .quick-action:hover {
            border-color: var(--primary);
            color: var(--primary);
          }
          #aiChatPanel .typing-indicator {
            display: flex;
            gap: 4px;
            padding: 12px 16px;
            align-self: flex-start;
          }
          #aiChatPanel .typing-indicator span {
            width: 8px;
            height: 8px;
            background: var(--text-muted);
            border-radius: 50%;
            animation: typingBounce 1.4s ease-in-out infinite;
          }
          #aiChatPanel .typing-indicator span:nth-child(2) { animation-delay: 0.2s; }
          #aiChatPanel .typing-indicator span:nth-child(3) { animation-delay: 0.4s; }
          @keyframes typingBounce {
            0%, 60%, 100% { transform: translateY(0); }
            30% { transform: translateY(-8px); }
          }
        </style>

        <div class="chat-header">
          <h3>
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="url(#chatGrad)" stroke-width="2">
              <defs>
                <linearGradient id="chatGrad" x1="0%" y1="0%" x2="100%" y2="100%">
                  <stop offset="0%" stop-color="#6366f1"/>
                  <stop offset="100%" stop-color="#8b5cf6"/>
                </linearGradient>
              </defs>
              <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"/>
            </svg>
            <span>AI Designer</span>
          </h3>
          <div style="display: flex; gap: 8px;">
            <button onclick="clearAIChat()" title="Clear chat" style="background: none; border: none; cursor: pointer; padding: 6px; color: var(--text-muted);">
              <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M3 6h18M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/>
              </svg>
            </button>
            <button onclick="toggleAIChatDesigner()" style="background: none; border: none; cursor: pointer; padding: 6px; color: var(--text-muted);">
              <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <line x1="18" y1="6" x2="6" y2="18"/>
                <line x1="6" y1="6" x2="18" y2="18"/>
              </svg>
            </button>
          </div>
        </div>

        <div class="chat-messages" id="aiChatMessages">
          <div class="chat-message assistant">
            <strong> Hi! I'm your AI Design Assistant.</strong><br><br>
            Tell me what you want to build and I'll create it for you. Try:
            <ul style="margin: 8px 0 0; padding-left: 20px;">
              <li>"Create an L-shaped kitchen, 12x14 feet"</li>
              <li>"Add a 36-inch sink base on the back wall"</li>
              <li>"Put a refrigerator on the right wall"</li>
              <li>"Add wall cabinets above the base cabinets"</li>
            </ul>
          </div>
        </div>

        <div class="chat-input-area">
          <div class="quick-actions">
            <button class="quick-action" onclick="sendAIChatMessage('Create a basic L-shaped kitchen')">L-shaped kitchen</button>
            <button class="quick-action" onclick="sendAIChatMessage('Add an island in the center')">Add island</button>
            <button class="quick-action" onclick="sendAIChatMessage('Add countertops over all base cabinets')">Add countertops</button>
            <button class="quick-action" onclick="sendAIChatMessage('Clear the room and start fresh')">Clear room</button>
          </div>
          <div class="chat-input-wrapper">
            <textarea class="chat-input" id="aiChatInput" placeholder="Describe what you want to build..." rows="1"
              onkeydown="if(event.key==='Enter' && !event.shiftKey) { event.preventDefault(); sendAIChatMessage(); }"></textarea>
            <button class="chat-send-btn" onclick="sendAIChatMessage()" id="aiChatSendBtn">
              <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2">
                <line x1="22" y1="2" x2="11" y2="13"/>
                <polygon points="22 2 15 22 11 13 2 9 22 2"/>
              </svg>
            </button>
          </div>
        </div>
      `;

      document.body.appendChild(panel);
      aiChatOpen = true;

      // Auto-resize textarea
      const input = document.getElementById('aiChatInput');
      input.addEventListener('input', function() {
        this.style.height = 'auto';
        this.style.height = Math.min(this.scrollHeight, 100) + 'px';
      });
    }

    function clearAIChat() {
      aiChatHistory = [];
      const messages = document.getElementById('aiChatMessages');
      if (messages) {
        messages.innerHTML = `
          <div class="chat-message assistant">
            <strong> Chat cleared!</strong><br><br>
            Ready to start a new design. What would you like to create?
          </div>
        `;
      }
    }

    function addChatMessage(role, content, actions = []) {
      const messages = document.getElementById('aiChatMessages');
      if (!messages) return;

      const msgDiv = document.createElement('div');
      msgDiv.className = `chat-message ${role}`;

      let html = content.replace(/\n/g, '<br>');
      if (actions.length > 0) {
        html += '<div style="margin-top: 8px;">';
        actions.forEach(a => {
          html += `<span class="action-badge"> ${a}</span> `;
        });
        html += '</div>';
      }
      msgDiv.innerHTML = html;

      messages.appendChild(msgDiv);
      messages.scrollTop = messages.scrollHeight;
    }

    function showTypingIndicator() {
      const messages = document.getElementById('aiChatMessages');
      if (!messages) return;

      const indicator = document.createElement('div');
      indicator.className = 'typing-indicator';
      indicator.id = 'typingIndicator';
      indicator.innerHTML = '<span></span><span></span><span></span>';
      messages.appendChild(indicator);
      messages.scrollTop = messages.scrollHeight;
    }

    function hideTypingIndicator() {
      const indicator = document.getElementById('typingIndicator');
      if (indicator) indicator.remove();
    }

    async function sendAIChatMessage(presetMessage = null) {
      const input = document.getElementById('aiChatInput');
      const sendBtn = document.getElementById('aiChatSendBtn');
      const message = presetMessage || input?.value?.trim();

      if (!message || aiChatProcessing) return;

      // Clear input
      if (input && !presetMessage) {
        input.value = '';
        input.style.height = 'auto';
      }

      // Add user message to chat
      addChatMessage('user', message);
      aiChatHistory.push({ role: 'user', content: message });

      // Show typing indicator
      aiChatProcessing = true;
      if (sendBtn) sendBtn.disabled = true;
      showTypingIndicator();

      try {
        // Get current room state for context
        const roomState = {
          roomWidth,
          roomDepth,
          elementCount: elements.length,
          elements: elements.map(el => ({
            type: el.type,
            label: el.label,
            width: el.width,
            height: el.height,
            wall: el.aiWall || 'unknown',
            x: el.x / pixelsPerFoot,
            y: el.y / pixelsPerFoot
          }))
        };

        // Call AI endpoint
        const response = await fetch('/api/ai/design-chat', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            message,
            history: aiChatHistory.slice(-10), // Last 10 messages for context
            roomState
          })
        });

        const data = await response.json();
        hideTypingIndicator();

        if (data.error) {
          throw new Error(data.error);
        }

        // Execute any actions returned by AI
        const executedActions = [];
        if (data.actions && Array.isArray(data.actions)) {
          for (const action of data.actions) {
            try {
              const result = await executeAIDesignAction(action);
              if (result) executedActions.push(result);
            } catch (actionError) {
              console.error('Action error:', actionError);
            }
          }
        }

        // Add assistant response
        addChatMessage('assistant', data.response, executedActions);
        aiChatHistory.push({ role: 'assistant', content: data.response });

        // Update canvas if actions were taken
        if (executedActions.length > 0) {
          draw();
          calculateQuote();
          saveUndoState();
          update3DScene();
        }

      } catch (error) {
        hideTypingIndicator();
        console.error('AI Chat error:', error);
        addChatMessage('assistant', `Sorry, I encountered an error: ${error.message}. Please try again.`);
      } finally {
        aiChatProcessing = false;
        if (sendBtn) sendBtn.disabled = false;
      }
    }

    // Execute AI design actions
    async function executeAIDesignAction(action) {
      const { type, params } = action;

      switch (type) {
        case 'SET_ROOM_SIZE':
          if (params.width) roomWidth = params.width;
          if (params.depth) roomDepth = params.depth;
          const widthInput = document.getElementById('roomWidth');
          const depthInput = document.getElementById('roomDepth');
          if (widthInput) widthInput.value = roomWidth;
          if (depthInput) depthInput.value = roomDepth;
          return `Room set to ${roomWidth}' x ${roomDepth}'`;

        case 'CLEAR_ELEMENTS':
          elements.length = 0;
          elementListDirty = true;
          return 'Cleared all elements';

        case 'ADD_CABINET':
          return addAICabinet(params);

        case 'ADD_APPLIANCE':
          return addAIAppliance(params);

        case 'ADD_COUNTERTOP':
          return addAICountertop(params);

        case 'ADD_ISLAND':
          return addAIIsland(params);

        case 'CREATE_LAYOUT':
          return createAILayout(params);

        case 'DELETE_ELEMENT':
          const idx = elements.findIndex(el => el.label?.toLowerCase().includes(params.label?.toLowerCase()));
          if (idx !== -1) {
            elements.splice(idx, 1);
            elementListDirty = true;
            return `Removed ${params.label}`;
          }
          return null;

        case 'SELECT_ELEMENT':
          const el = elements.find(e => e.label?.toLowerCase().includes(params.label?.toLowerCase()));
          if (el) {
            selectedElement = el;
            updateProperties();
            return `Selected ${el.label}`;
          }
          return null;

        default:
          console.log('Unknown action:', type);
          return null;
      }
    }

    // Helper: Add cabinet from AI
    function addAICabinet(params) {
      const { type = 'base-cabinet', wall = 'top', width = 36, position = null, label = null } = params;

      const widthFt = width / 12;
      const depthFt = type.includes('wall') ? 1 : 2;
      const heightFt = type.includes('wall') ? 2.5 : depthFt;

      let x, y, rotation = 0;
      const padding = 0.5;

      // Find existing cabinets on this wall to position after them
      const wallCabs = elements.filter(el =>
        el.aiWall === wall || (wall === 'top' && el.y < roomDepth * pixelsPerFoot / 3)
      );
      const lastCab = wallCabs[wallCabs.length - 1];
      const offset = lastCab ? (lastCab.x / pixelsPerFoot + lastCab.width + 0.1) : padding;

      switch (wall) {
        case 'top':
          x = position ?? offset;
          y = padding;
          break;
        case 'bottom':
          x = position ?? offset;
          y = roomDepth - depthFt - padding;
          rotation = 180;
          break;
        case 'left':
          x = padding;
          y = position ?? offset;
          rotation = 270;
          break;
        case 'right':
          x = roomWidth - depthFt - padding;
          y = position ?? offset;
          rotation = 90;
          break;
      }

      const element = {
        id: Date.now() + Math.random(),
        type: type,
        x: x * pixelsPerFoot,
        y: y * pixelsPerFoot,
        width: widthFt,
        height: depthFt,
        rotation,
        color: type.includes('wall') ? '#B8860B' : '#8B4513',
        label: label || `${type.replace('-', ' ').replace(/\b\w/g, l => l.toUpperCase())} ${width}"`,
        locked: false,
        roomId: currentRoom,
        floorLevel: cabinetSettings?.currentFloor || 1,
        construction: cabinetSettings?.construction || 'framed',
        doorStyle: cabinetSettings?.doorStyle || 'shaker',
        aiWall: wall,
        aiGenerated: true
      };

      elements.push(element);
      elementListDirty = true;
      return `Added ${width}" ${type.replace('-', ' ')} on ${wall} wall`;
    }

    // Helper: Add appliance from AI
    function addAIAppliance(params) {
      const { type = 'refrigerator', wall = 'right', width = 36 } = params;

      const widthFt = width / 12;
      const depthFt = type === 'refrigerator' ? 2.5 : 2;
      let x, y, rotation = 0;
      const padding = 0.5;

      // Find position
      const wallItems = elements.filter(el => el.aiWall === wall);
      const offset = wallItems.length > 0
        ? Math.max(...wallItems.map(el => el.x / pixelsPerFoot + el.width)) + 0.2
        : padding;

      switch (wall) {
        case 'top':
          x = offset; y = padding;
          break;
        case 'bottom':
          x = offset; y = roomDepth - depthFt - padding; rotation = 180;
          break;
        case 'left':
          x = padding; y = offset; rotation = 270;
          break;
        case 'right':
          x = roomWidth - depthFt - padding; y = offset; rotation = 90;
          break;
      }

      const element = {
        id: Date.now() + Math.random(),
        type,
        x: x * pixelsPerFoot,
        y: y * pixelsPerFoot,
        width: widthFt,
        height: depthFt,
        rotation,
        color: '#C0C0C0',
        label: type.charAt(0).toUpperCase() + type.slice(1),
        locked: false,
        roomId: currentRoom,
        aiWall: wall,
        aiGenerated: true
      };

      elements.push(element);
      elementListDirty = true;
      return `Added ${type} on ${wall} wall`;
    }

    // Helper: Add countertop from AI
    function addAICountertop(params) {
      const { wall = 'top', material = 'granite' } = params;

      // Find base cabinets on this wall
      const baseCabs = elements.filter(el =>
        ['base-cabinet', 'sink-base', 'drawer-base'].includes(el.type) &&
        (el.aiWall === wall || wall === 'all')
      );

      if (baseCabs.length === 0 && wall !== 'all') {
        return null;
      }

      let added = 0;
      const walls = wall === 'all' ? ['top', 'bottom', 'left', 'right'] : [wall];

      walls.forEach(w => {
        const cabs = elements.filter(el =>
          ['base-cabinet', 'sink-base', 'drawer-base'].includes(el.type) &&
          el.aiWall === w
        );
        if (cabs.length === 0) return;

        cabs.sort((a, b) => a.x - b.x);
        const first = cabs[0];
        const last = cabs[cabs.length - 1];
        const overhang = 0.125;

        const counter = {
          id: Date.now() + Math.random() + added,
          type: 'countertop',
          x: first.x - overhang * pixelsPerFoot,
          y: first.y - overhang * pixelsPerFoot,
          width: ((last.x + last.width * pixelsPerFoot - first.x) / pixelsPerFoot) + overhang * 2,
          height: first.height + overhang * 2,
          rotation: first.rotation || 0,
          color: '#4a5568',
          label: `${material.charAt(0).toUpperCase() + material.slice(1)} Counter`,
          roomId: currentRoom,
          edgeProfile: 'eased',
          thickness: '3cm',
          aiWall: w,
          aiGenerated: true
        };

        elements.push(counter);
        added++;
      });

      elementListDirty = true;
      return added > 0 ? `Added ${added} countertop${added > 1 ? 's' : ''}` : null;
    }

    // Helper: Add island from AI
    function addAIIsland(params) {
      const { width = 48, depth = 36 } = params;

      const widthFt = width / 12;
      const depthFt = depth / 12;

      const element = {
        id: Date.now() + Math.random(),
        type: 'island',
        x: (roomWidth / 2 - widthFt / 2) * pixelsPerFoot,
        y: (roomDepth / 2 - depthFt / 2) * pixelsPerFoot,
        width: widthFt,
        height: depthFt,
        rotation: 0,
        color: '#8B4513',
        label: `Island ${width}" x ${depth}"`,
        roomId: currentRoom,
        aiWall: 'island',
        aiGenerated: true
      };

      elements.push(element);
      elementListDirty = true;
      return `Added ${width}" x ${depth}" island`;
    }

    // Helper: Create complete layout from AI
    function createAILayout(params) {
      const { layoutType = 'L-shape', width = 12, depth = 10 } = params;

      // Set room size
      roomWidth = width;
      roomDepth = depth;

      // Clear existing
      elements.length = 0;

      const layouts = {
        'L-shape': [
          { type: 'base-cabinet', wall: 'top', width: 36 },
          { type: 'base-cabinet', wall: 'top', width: 36 },
          { type: 'sink-base', wall: 'top', width: 36 },
          { type: 'base-cabinet', wall: 'top', width: 24 },
          { type: 'base-cabinet', wall: 'left', width: 36 },
          { type: 'base-cabinet', wall: 'left', width: 24 },
          { type: 'wall-cabinet', wall: 'top', width: 36 },
          { type: 'wall-cabinet', wall: 'top', width: 36 },
          { type: 'wall-cabinet', wall: 'top', width: 30 },
          { appliance: 'refrigerator', wall: 'right', width: 36 },
          { appliance: 'range', wall: 'top', width: 30 }
        ],
        'U-shape': [
          { type: 'base-cabinet', wall: 'top', width: 36 },
          { type: 'sink-base', wall: 'top', width: 36 },
          { type: 'base-cabinet', wall: 'top', width: 36 },
          { type: 'base-cabinet', wall: 'left', width: 36 },
          { type: 'base-cabinet', wall: 'left', width: 24 },
          { type: 'base-cabinet', wall: 'right', width: 36 },
          { type: 'base-cabinet', wall: 'right', width: 24 },
          { appliance: 'refrigerator', wall: 'right', width: 36 },
          { appliance: 'range', wall: 'top', width: 30 }
        ],
        'galley': [
          { type: 'base-cabinet', wall: 'top', width: 36 },
          { type: 'sink-base', wall: 'top', width: 36 },
          { type: 'base-cabinet', wall: 'top', width: 36 },
          { type: 'base-cabinet', wall: 'bottom', width: 36 },
          { type: 'base-cabinet', wall: 'bottom', width: 36 },
          { appliance: 'refrigerator', wall: 'bottom', width: 36 },
          { appliance: 'range', wall: 'top', width: 30 }
        ],
        'single-wall': [
          { type: 'base-cabinet', wall: 'top', width: 36 },
          { type: 'base-cabinet', wall: 'top', width: 36 },
          { type: 'sink-base', wall: 'top', width: 36 },
          { type: 'base-cabinet', wall: 'top', width: 24 },
          { type: 'wall-cabinet', wall: 'top', width: 36 },
          { type: 'wall-cabinet', wall: 'top', width: 36 },
          { appliance: 'refrigerator', wall: 'right', width: 36 }
        ],
        'island': [
          { type: 'base-cabinet', wall: 'top', width: 36 },
          { type: 'sink-base', wall: 'top', width: 36 },
          { type: 'base-cabinet', wall: 'top', width: 36 },
          { island: true, width: 60, depth: 42 },
          { appliance: 'refrigerator', wall: 'right', width: 36 },
          { appliance: 'range', wall: 'top', width: 30 }
        ]
      };

      const items = layouts[layoutType] || layouts['L-shape'];
      const results = [];

      items.forEach(item => {
        if (item.appliance) {
          results.push(addAIAppliance({ type: item.appliance, wall: item.wall, width: item.width }));
        } else if (item.island) {
          results.push(addAIIsland({ width: item.width, depth: item.depth }));
        } else {
          results.push(addAICabinet(item));
        }
      });

      // Auto-add countertops
      addAICountertop({ wall: 'all', material: 'granite' });

      elementListDirty = true;
      return `Created ${layoutType} kitchen layout`;
    }

    // Update UI to show/hide pricing based on access
    function updatePricingVisibility() {
      const canView = PRICING_ACCESS.canViewPricing;

      // Pricing section in properties panel
      const pricingSection = document.getElementById('pricingSection');
      if (pricingSection) {
        if (canView) {
          pricingSection.classList.remove('pricing-locked');
          pricingSection.style.display = '';
        } else {
          pricingSection.classList.add('pricing-locked');
        }
      }

      // Quote panel
      const quotePanel = document.getElementById('quotePanel');
      if (quotePanel) {
        if (canView) {
          quotePanel.classList.remove('pricing-locked');
        } else {
          quotePanel.classList.add('pricing-locked');
        }
      }

      // Quote total
      const quoteTotal = document.getElementById('quoteTotal');
      if (quoteTotal && !canView) {
        quoteTotal.textContent = '---';
      }

      // Show/hide manage subscription button
      const manageSubBtn = document.getElementById('manageSubscriptionBtn');
      if (manageSubBtn) {
        manageSubBtn.style.display = canView ? 'flex' : 'none';
      }

      // Add/update pricing locked overlay
      updatePricingLockedOverlay();

      // Refresh cabinet catalog to show/hide prices
      if (typeof renderCabinetCatalog === 'function') {
        renderCabinetCatalog();
      }

      // Refresh materials list to show/hide prices
      if (typeof renderMaterials === 'function' && typeof currentMaterialCategory !== 'undefined') {
        renderMaterials(currentMaterialCategory);
      }
    }

    // Open Stripe billing portal for subscription management
    async function openBillingPortal() {
      const user = window.SgAuth?.getUser();
      if (!user) {
        showNotification('Please sign in to manage your subscription', 'error');
        return;
      }

      try {
        showNotification('Opening billing portal...', 'info', 2000);

        const response = await fetch('/api/pro-billing-portal', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            user_id: user.id,
            return_url: window.location.href
          })
        });

        const data = await response.json();

        if (data.success && data.url) {
          window.location.href = data.url;
        } else {
          throw new Error(data.error || 'Failed to open billing portal');
        }
      } catch (err) {
        console.error('Billing portal error:', err);
        showNotification(err.message || 'Failed to open billing portal', 'error');
      }
    }

    // Create/update the pricing locked overlay
    function updatePricingLockedOverlay() {
      const existingOverlay = document.getElementById('pricingLockedOverlay');

      if (PRICING_ACCESS.canViewPricing) {
        // Remove overlay if it exists
        if (existingOverlay) existingOverlay.remove();
        return;
      }

      // Create overlay if doesn't exist
      if (!existingOverlay) {
        const overlay = document.createElement('div');
        overlay.id = 'pricingLockedOverlay';
        overlay.className = 'pricing-locked-overlay';

        const isLoggedIn = !!window.SgAuth?.getUser();
        const accountType = PRICING_ACCESS.accountType || 'guest';

        overlay.innerHTML = `
          <div class="pricing-locked-content">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:40px;height:40px;margin-bottom:12px;opacity:0.5;">
              <rect x="3" y="11" width="18" height="11" rx="2" ry="2"/>
              <path d="M7 11V7a5 5 0 0 1 10 0v4"/>
            </svg>
            <h4>Unlock Pricing</h4>
            <p style="margin-bottom:16px;">Upgrade to Pro to access material pricing, quotes, and takeoffs.</p>

            <div class="upgrade-plans" style="display:flex;flex-direction:column;gap:10px;margin-bottom:16px;">
              <button class="upgrade-plan-btn" data-plan="pro" onclick="startUpgrade('pro')">
                <div style="display:flex;justify-content:space-between;align-items:center;width:100%;">
                  <div style="text-align:left;">
                    <div style="font-weight:600;font-size:14px;">Pro Plan</div>
                    <div style="font-size:11px;opacity:0.8;">Pricing, quotes & takeoffs</div>
                  </div>
                  <div style="text-align:right;">
                    <div style="font-weight:700;font-size:16px;">$29<span style="font-size:11px;font-weight:400;">/mo</span></div>
                  </div>
                </div>
              </button>
              <button class="upgrade-plan-btn upgrade-plan-featured" data-plan="fabricator" onclick="startUpgrade('fabricator')">
                <div style="position:absolute;top:-8px;right:12px;background:#f9cb00;color:#1a1a2e;font-size:9px;padding:2px 8px;border-radius:4px;font-weight:600;">POPULAR</div>
                <div style="display:flex;justify-content:space-between;align-items:center;width:100%;">
                  <div style="text-align:left;">
                    <div style="font-weight:600;font-size:14px;">Fabricator Plan</div>
                    <div style="font-size:11px;opacity:0.8;">Wholesale pricing + CRM</div>
                  </div>
                  <div style="text-align:right;">
                    <div style="font-weight:700;font-size:16px;">$79<span style="font-size:11px;font-weight:400;">/mo</span></div>
                  </div>
                </div>
              </button>
            </div>

            ${!isLoggedIn ? `
              <div style="font-size:12px;color:var(--text-muted);margin-bottom:12px;">
                Already have an account? <a href="javascript:void(0)" onclick="showLoginPrompt('Log in to access your subscription.'); return false;" style="color:#6366f1;">Log in</a>
              </div>
            ` : accountType === 'homeowner' ? `
              <div style="font-size:12px;color:var(--text-muted);margin-bottom:12px;">
                Currently on free plan. Upgrade to unlock pricing.
              </div>
            ` : ''}

            <div style="font-size:11px;color:var(--text-muted);">
               Cancel anytime &nbsp;  7-day free trial
            </div>
          </div>
        `;

        // Insert after quote panel
        const quotePanel = document.getElementById('quotePanel');
        if (quotePanel) {
          quotePanel.parentNode.insertBefore(overlay, quotePanel.nextSibling);
        }
      }
    }

    // Start the upgrade process
    async function startUpgrade(plan = 'pro') {
      const user = window.SgAuth?.getUser();

      // If not logged in, prompt to sign up first
      if (!user) {
        showLoginPrompt('Create an account to start your Pro subscription.', () => {
          // After successful login, redirect to upgrade
          setTimeout(() => startUpgrade(plan), 500);
        });
        return;
      }

      // Show loading state
      const btn = document.querySelector(`[data-plan="${plan}"]`);
      if (btn) {
        btn.disabled = true;
        btn.innerHTML = '<div style="display:flex;align-items:center;justify-content:center;gap:8px;"><span class="spinner" style="width:16px;height:16px;border:2px solid rgba(255,255,255,0.3);border-top-color:#fff;border-radius:50%;animation:spin 1s linear infinite;"></span> Processing...</div>';
      }

      try {
        const response = await fetch('/api/create-pro-subscription', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            user_id: user.id,
            user_email: user.email,
            plan: plan,
            billing_cycle: 'monthly',
            success_url: window.location.origin + '/tools/room-designer/?subscription=success&plan=' + plan,
            cancel_url: window.location.origin + '/tools/room-designer/?subscription=canceled'
          })
        });

        const data = await response.json();

        if (data.success && data.url) {
          // Redirect to Stripe Checkout
          window.location.href = data.url;
        } else {
          throw new Error(data.error || 'Failed to create checkout session');
        }
      } catch (err) {
        console.error('Upgrade error:', err);
        showNotification('Failed to start upgrade. Please try again.', 'error');

        // Reset button
        if (btn) {
          btn.disabled = false;
          updatePricingLockedOverlay();
        }
      }
    }

    // Handle subscription callback from Stripe
    async function handleSubscriptionCallback(status, plan) {
      if (status === 'success') {
        // Subscription successful - force refresh pricing access from database
        // (webhook may have updated account_type)
        await checkPricingAccess(true);

        const planName = plan ? plan.charAt(0).toUpperCase() + plan.slice(1) : 'Pro';

        // Show success notification
        showNotification(`Welcome to ${planName}! You now have access to pricing, quotes, and takeoffs.`, 'success', 5000);

        // Show a celebration modal
        const modal = document.createElement('div');
        modal.className = 'modal-overlay';
        modal.id = 'subscriptionSuccessModal';
        modal.innerHTML = `
          <div class="modal" style="max-width: 420px; text-align: center;">
            <div style="font-size: 48px; margin-bottom: 16px;"></div>
            <h3 style="margin-bottom: 12px; color: #10b981;">Welcome to ${planName}!</h3>
            <p style="color: var(--text-muted); margin-bottom: 20px;">
              Your subscription is now active. You have full access to:
            </p>
            <ul style="text-align: left; margin: 0 0 24px 20px; color: var(--text);">
              <li style="margin-bottom: 8px;"> Real-time material pricing</li>
              <li style="margin-bottom: 8px;"> Professional quotes & estimates</li>
              <li style="margin-bottom: 8px;"> Detailed takeoff reports</li>
              <li style="margin-bottom: 8px;"> Unlimited design saves</li>
            </ul>
            <button class="btn btn-primary" onclick="document.getElementById('subscriptionSuccessModal').remove();" style="width: 100%;">
              Start Designing
            </button>
          </div>
        `;
        document.body.appendChild(modal);

      } else if (status === 'canceled') {
        showNotification('Subscription canceled. You can upgrade anytime to unlock pricing.', 'info', 4000);
      }
    }

    const PERMISSION_LEVELS = {
      full_collab: {
        name: 'Full Collaboration',
        description: 'Can edit everything including prices',
        canEdit: true,
        canViewPrices: true,
        canViewCosts: true,
        canViewMaterials: true,
        canExport: true,
        canApprove: false
      },
      quote_approval: {
        name: 'Design Approval',
        description: 'Customer can view design and approve with payment',
        canEdit: false,
        canViewPrices: true,
        canViewCosts: false,
        canViewMaterials: true,
        canExport: true,
        canApprove: true
      },
      quote_view: {
        name: 'Quote View',
        description: 'Can see prices but cannot edit',
        canEdit: false,
        canViewPrices: true,
        canViewCosts: false,
        canViewMaterials: true,
        canExport: true,
        canApprove: false
      },
      material_view: {
        name: 'Material View',
        description: 'See materials only, no pricing',
        canEdit: false,
        canViewPrices: false,
        canViewCosts: false,
        canViewMaterials: true,
        canExport: false
      },
      presentation: {
        name: 'Presentation',
        description: 'Client-pretty view, no costs shown',
        canEdit: false,
        canViewPrices: false,
        canViewCosts: false,
        canViewMaterials: false,
        canExport: false
      }
    };

    // ===== BUILDING STANDARDS =====
    const BUILDING_STANDARDS = {
      // ===== NKBA (National Kitchen & Bath Association) + IRC/IBC Building Codes =====
      // All measurements in feet unless otherwise noted

      // Standard element dimensions (in feet)
      DOORS: {
        interior: { width: 2.667, height: 6.667, label: "2'-8\"  6'-8\"" },    // 32"  80"
        interiorWide: { width: 3, height: 6.667, label: "3'-0\"  6'-8\"" },    // 36"  80"
        exterior: { width: 3, height: 6.667, label: "3'-0\"  6'-8\"" },        // 36"  80"
        exteriorTall: { width: 3, height: 7, label: "3'-0\"  7'-0\"" },        // 36"  84"
        double: { width: 5, height: 6.667, label: "5'-0\"  6'-8\"" },          // 60"  80"
        sliding: { width: 6, height: 6.667, label: "6'-0\"  6'-8\"" },         // 72"  80"
        garage1car: { width: 8, height: 7, label: "8'-0\"  7'-0\"" },          // 96"  84"
        garage2car: { width: 16, height: 7, label: "16'-0\"  7'-0\"" }         // 192"  84"
      },
      WINDOWS: {
        small: { width: 2, height: 3, label: "2'-0\"  3'-0\"" },               // 24"  36"
        standard: { width: 3, height: 4, label: "3'-0\"  4'-0\"" },            // 36"  48"
        large: { width: 4, height: 5, label: "4'-0\"  5'-0\"" },               // 48"  60"
        picture: { width: 6, height: 4, label: "6'-0\"  4'-0\"" }              // 72"  48"
      },

      // ===== CABINET DIMENSIONS (NKBA Standards) =====
      CABINETS: {
        // Base cabinet specifications
        BASE: {
          height: 2.875,        // 34.5" cabinet height (without countertop)
          depth: 2,             // 24" standard depth
          toeKickHeight: 0.375, // 4.5" toe kick height
          toeKickDepth: 0.25,   // 3" toe kick recess
          standardWidths: [0.75, 1, 1.25, 1.5, 1.75, 2, 2.25, 2.5, 2.75, 3, 3.5, 4] // 9"-48" in 3" increments
        },
        // Wall cabinet specifications
        WALL: {
          depth: 1,             // 12" standard depth (shallower than base)
          heights: {
            short: 2.5,         // 30" height
            standard: 3,        // 36" height
            tall: 3.5           // 42" height
          },
          bottomFromFloor: 4.5, // 54" from floor to bottom edge (NKBA standard)
          standardWidths: [0.75, 1, 1.25, 1.5, 1.75, 2, 2.5, 3] // 9"-36" standard widths
        },
        // Tall/Pantry cabinet specifications
        TALL: {
          depth: 2,             // 24" standard depth (matches base)
          heights: {
            standard: 7,        // 84" height
            tall: 8,            // 96" height
            extraTall: 8.5      // 102" height (for high ceilings)
          },
          standardWidths: [1.5, 2, 2.5, 3] // 18"-36" widths
        },
        // Legacy format for compatibility
        base12: { width: 1, depth: 2, label: "12\" wide" },
        base15: { width: 1.25, depth: 2, label: "15\" wide" },
        base18: { width: 1.5, depth: 2, label: "18\" wide" },
        base21: { width: 1.75, depth: 2, label: "21\" wide" },
        base24: { width: 2, depth: 2, label: "24\" wide" },
        base27: { width: 2.25, depth: 2, label: "27\" wide" },
        base30: { width: 2.5, depth: 2, label: "30\" wide" },
        base33: { width: 2.75, depth: 2, label: "33\" wide" },
        base36: { width: 3, depth: 2, label: "36\" wide" },
        base42: { width: 3.5, depth: 2, label: "42\" wide" },
        base48: { width: 4, depth: 2, label: "48\" wide" },
        // Wall cabinets (shallower depth)
        wall12: { width: 1, depth: 1, label: "12\" wide" },
        wall15: { width: 1.25, depth: 1, label: "15\" wide" },
        wall18: { width: 1.5, depth: 1, label: "18\" wide" },
        wall24: { width: 2, depth: 1, label: "24\" wide" },
        wall30: { width: 2.5, depth: 1, label: "30\" wide" },
        wall36: { width: 3, depth: 1, label: "36\" wide" },
        // Tall/Pantry
        tall24: { width: 2, depth: 2, label: "24\" wide pantry" },
        tall36: { width: 3, depth: 2, label: "36\" wide pantry" }
      },

      // ===== COUNTERTOP SPECIFICATIONS =====
      COUNTERTOPS: {
        standardDepth: 2.083,   // 25" including 1" overhang
        thickness: 0.125,       // 1.5" (standard 3cm stone)
        thinThickness: 0.0833,  // 1" (2cm stone)
        overhang: {
          front: 0.0833,        // 1" front overhang
          side: 0.0833,         // 1" side overhang
          barSeating: 1         // 12" overhang for bar seating
        },
        barHeight: 3.5,         // 42" bar height
        islandMinWidth: 2,      // 24" minimum island width
        islandMinDepth: 4       // 48" minimum for seating on one side
      },

      // ===== BACKSPLASH SPECIFICATIONS =====
      BACKSPLASH: {
        standard: 0.333,        // 4" standard backsplash
        full: 1.5,              // 18" full height (to wall cabinet)
        custom: {
          min: 0.333,           // 4" minimum
          max: 1.5              // 18" maximum (to wall cabinet bottom)
        }
      },

      // ===== CLEARANCE REQUIREMENTS (NKBA Guidelines) =====
      CLEARANCES: {
        // Kitchen walkways
        walkway: 3,             // 36" minimum walkway (one cook)
        twoCook: 4,             // 48" for two cooks (NKBA 8)
        applianceOpen: 3.5,     // 42" in front of open appliance
        islandWalkway: 3.5,     // 42" around island minimum

        // Work centers
        sinkCenter: 2,          // 24" on each side of sink center
        cooktopCenter: 1.25,    // 15" on one side, 12" on other (min)
        cooktopSideMin: 1,      // 12" minimum on any side
        cooktopSidePref: 1.5,   // 18" preferred on landing side
        refrigerator: 1.25,     // 15" landing space at handle side

        // ADA Requirements
        adaTurning: 5,          // 60" turning radius
        adaWheelchair: 5,       // 60" T-turn space
        adaKneeClearance: 2.25, // 27" knee clearance under counter
        adaApproach: 4,         // 48" clear floor space

        // Door clearances
        doorSwing: 1.5,         // 18" beside door latch
        doorFront: 5,           // 60" in front of door

        // Appliance-specific
        dishwasherOpen: 3,      // 36" in front of open dishwasher
        ovenDoor: 3,            // 36" in front of open oven
        refrigeratorDoor: 4     // 48" for full door swing
      },

      // ===== WORK TRIANGLE (NKBA Guidelines 1-6) =====
      WORK_TRIANGLE: {
        legMin: 4,              // 4' minimum leg length
        legMax: 9,              // 9' maximum leg length
        perimeterMin: 13,       // 13' minimum total perimeter
        perimeterMax: 26,       // 26' maximum total perimeter
        noObstruction: true,    // No obstructions crossing triangle
        islandIntersect: 1      // Island should not intersect by more than 12"
      },

      // ===== VERTICAL HEIGHTS (Floor to Element) =====
      HEIGHTS: {
        // Ceiling heights
        ceiling: 8,             // 8' standard ceiling
        ceilingTall: 9,         // 9' ceiling
        ceilingLuxury: 10,      // 10' ceiling
        ceilingMinimum: 7,      // 7' minimum ceiling (IRC R305.1)

        // Counter heights
        baseCounter: 3,         // 36" standard counter height
        baseCabinet: 2.875,     // 34.5" cabinet height (without counter)
        barCounter: 3.5,        // 42" bar height
        adaCounter: 2.833,      // 34" max ADA counter height

        // Wall cabinet positioning
        wallCabBottom: 4.5,     // 54" to bottom of wall cabinet (NKBA)
        wallCabTop: 7,          // 84" to top of 30" wall cabinet
        wallCabBottomMin: 4.25, // 51" minimum (15" above counter)
        wallCabBottomMax: 4.75, // 57" maximum practical reach

        // Appliance heights
        rangeHood: 5.5,         // 66" to bottom of range hood (24-30" above cooktop)
        rangeHoodMin: 5,        // 60" minimum (electric: 24" above)
        rangeHoodGas: 5.5,      // 66" for gas (30" above burners)
        microwave: 4.5,         // 54" to bottom (matches wall cab)
        microwaveMax: 4.5,      // 54" max bottom height (NKBA 13)

        // Window and door
        windowSill: 3,          // 36" typical window sill
        windowSillMin: 2,       // 24" minimum above counter
        doorHeader: 6.8         // 82" door header height
      },

      // ===== APPLIANCE CLEARANCES (Manufacturer + Code) =====
      APPLIANCES: {
        // Range/Cooktop
        rangeHoodClearance: {
          electric: 2,          // 24" above electric cooktop
          gas: 2.5              // 30" above gas cooktop
        },
        cooktopToWindow: 0.25,  // 3" min to operable window (fire code)
        cooktopToWall: 0,       // Can be against wall with proper protection

        // Refrigerator
        fridgeVentilation: 0.083, // 1" sides, 1" top for ventilation
        fridgeDepth: 2.5,       // 30" typical counter-depth
        fridgeDepthStandard: 3, // 36" standard depth

        // Dishwasher
        dishwasherWidth: 2,     // 24" standard width
        dishwasherToCorner: 1.5, // 18" from corner for door swing

        // Microwave (OTR)
        microwaveDepth: 1.25,   // 15" typical depth
        microwaveHeight: 1.375  // 16.5" typical height
      },

      // ===== ELECTRICAL (NEC Requirements) =====
      ELECTRICAL: {
        outletSpacing: 4,       // 48" max between outlets (NEC 210.52)
        counterOutlet: 2,       // Outlet within 24" of counter end
        gfciRequired: true,     // GFCI required within 6' of water
        islandOutlet: true,     // Island requires outlet if > 24"x12"
        peninsulaOutlet: true   // Peninsula requires outlet if > 24"x12"
      },

      // ===== VENTILATION (IMC/IRC Requirements) =====
      VENTILATION: {
        rangeHoodCFM: {
          min: 100,             // 100 CFM minimum
          perLinealFoot: 100,   // 100 CFM per lineal foot of range
          recommended: 400      // 400 CFM typical for 30" range
        },
        makeupAir: 400,         // Makeup air required above 400 CFM
        ductSize: {
          round6: 225,          // 6" round = 225 CFM max
          round8: 400,          // 8" round = 400 CFM max
          rectangular: true     // 3.25"x10" = 6" round equivalent
        }
      },

      // ===== PLUMBING CENTERLINES =====
      PLUMBING: {
        sinkCenter: 1.75,       // 21" from back wall to sink center
        faucetSetback: 0.333,   // 4" from sink edge to faucet
        dishwasherToSink: 3,    // 36" max drain run to sink
        islandVenting: true     // Island sinks need AAV or loop vent
      }
    };

    // Standard snap dimensions (in feet) for smart snapping
    const SNAP_DIMENSIONS = {
      widths: [1, 1.25, 1.5, 1.75, 2, 2.25, 2.5, 2.75, 3, 3.5, 4, 4.5, 5, 6, 8],
      depths: [1, 1.5, 2, 2.5, 3, 4],
      tolerance: 0.0833  // 1" snap tolerance
    };

    // ===== MATERIAL TYPE RESTRICTIONS =====
    // Controls which material categories can be applied to which element types
    const MATERIAL_TYPE_MAP = {
      // Stone materials (granite, quartz, marble, quartzite, dekton, etc.) -> countertops only
      granite: ['countertop', 'countertop-corner', 'countertop-l', 'countertop-u', 'island', 'backsplash'],
      quartz: ['countertop', 'countertop-corner', 'countertop-l', 'countertop-u', 'island', 'backsplash'],
      marble: ['countertop', 'countertop-corner', 'countertop-l', 'countertop-u', 'island', 'backsplash'],
      quartzite: ['countertop', 'countertop-corner', 'countertop-l', 'countertop-u', 'island', 'backsplash'],
      stone: ['countertop', 'countertop-corner', 'countertop-l', 'countertop-u', 'island', 'backsplash'],
      // Sintered stone / ultra-compact surfaces (Dekton, Neolith, etc.)
      dekton: ['countertop', 'countertop-corner', 'countertop-l', 'countertop-u', 'island', 'backsplash'],
      sintered: ['countertop', 'countertop-corner', 'countertop-l', 'countertop-u', 'island', 'backsplash'],
      neolith: ['countertop', 'countertop-corner', 'countertop-l', 'countertop-u', 'island', 'backsplash'],
      porcelain: ['countertop', 'countertop-corner', 'countertop-l', 'countertop-u', 'island', 'backsplash', 'tile', 'flooring'],
      soapstone: ['countertop', 'countertop-corner', 'countertop-l', 'countertop-u', 'island'],
      onyx: ['countertop', 'countertop-corner', 'countertop-l', 'countertop-u', 'island', 'backsplash'],
      travertine: ['countertop', 'countertop-corner', 'countertop-l', 'countertop-u', 'island', 'backsplash', 'flooring'],
      limestone: ['countertop', 'countertop-corner', 'countertop-l', 'countertop-u', 'island', 'backsplash', 'flooring'],
      // Cabinet finishes -> cabinets only
      cabinets: ['base-cabinet', 'wall-cabinet', 'tall-cabinet', 'corner-cabinet', 'sink-base',
                 'drawer-base', 'lazy-susan', 'fridge-cabinet', 'pantry', 'blind-corner',
                 'microwave-cabinet', 'island'],
      cabinet: ['base-cabinet', 'wall-cabinet', 'tall-cabinet', 'corner-cabinet', 'sink-base',
                'drawer-base', 'lazy-susan', 'fridge-cabinet', 'pantry', 'blind-corner',
                'microwave-cabinet', 'island'],
      // Tile -> backsplash, flooring
      tile: ['backsplash', 'flooring', 'tile', 'shower-wall', 'shower-floor'],
      // Flooring -> floor elements
      flooring: ['flooring', 'tile']
    };

    // Helper function to check if a material category can be applied to an element
    function canApplyMaterialToElement(category, element, showWarning = true) {
      if (!category) return true; // No category restriction

      let normalizedCategory = category.toLowerCase().trim();

      // Extract base material type from compound names like "Granite Slab", "Quartz Countertop", etc.
      const materialKeywords = ['granite', 'quartz', 'quartzite', 'marble', 'dekton', 'neolith', 'porcelain',
                                'soapstone', 'onyx', 'travertine', 'limestone', 'sintered', 'stone',
                                'tile', 'flooring', 'cabinet', 'cabinets'];
      for (const keyword of materialKeywords) {
        if (normalizedCategory.includes(keyword)) {
          normalizedCategory = keyword;
          break;
        }
      }

      let allowedTypes = MATERIAL_TYPE_MAP[normalizedCategory];

      // If no match found, try common aliases
      if (!allowedTypes) {
        const aliases = {
          'natural stone': 'stone',
          'engineered stone': 'quartz',
          'solid surface': 'stone',
          'ultra compact': 'dekton',
          'ceramic': 'tile',
          'mosaic': 'tile',
          'subway': 'tile',
          'backsplash tile': 'tile',
          'wall tile': 'tile',
          'floor tile': 'tile'
        };
        const aliasMatch = Object.keys(aliases).find(k => normalizedCategory.includes(k));
        if (aliasMatch) {
          allowedTypes = MATERIAL_TYPE_MAP[aliases[aliasMatch]];
        }
      }

      // No restriction for this category
      if (!allowedTypes) return true;

      // Check if element type matches any allowed type
      const elementType = element.type || '';
      const isAllowed = allowedTypes.some(t => elementType.includes(t) || elementType === t);

      if (!isAllowed && showWarning) {
        const categoryLabel = normalizedCategory.charAt(0).toUpperCase() + normalizedCategory.slice(1);
        showToast(`${categoryLabel} materials can only be applied to ${allowedTypes.slice(0, 3).join(', ')}${allowedTypes.length > 3 ? '...' : ''}`, 'warning');
      }

      console.log('Material type check:', { category: normalizedCategory, elementType, allowedTypes, isAllowed });
      return isAllowed;
    }

    // ===== SLAB & MATERIAL STANDARDS =====
    const SLAB_STANDARDS = {
      // Standard slab sizes by material type (in inches)
      granite: {
        width: 115,       // Typical granite slab width
        height: 68,       // Typical granite slab height
        thickness: ['2cm', '3cm'],
        sqftPerSlab: 54.3, // 115  68 / 144
        wastePercent: 25,  // 25% waste for natural stone (irregular shapes, veining match)
        label: 'Granite Slab'
      },
      quartzite: {
        width: 120,
        height: 65,
        thickness: ['2cm', '3cm'],
        sqftPerSlab: 54.2,
        wastePercent: 25,
        label: 'Quartzite Slab'
      },
      marble: {
        width: 110,
        height: 65,
        thickness: ['2cm', '3cm'],
        sqftPerSlab: 49.7,
        wastePercent: 30,  // Higher waste for veining match
        label: 'Marble Slab'
      },
      quartz: {
        width: 126,       // Engineered quartz (Cambria, Silestone, etc.)
        height: 63,
        thickness: ['2cm', '3cm'],
        sqftPerSlab: 55.1,
        wastePercent: 20,  // Lower waste - consistent pattern
        label: 'Quartz Slab'
      },
      porcelain: {
        width: 126,       // Large format porcelain
        height: 63,
        thickness: ['6mm', '12mm', '20mm'],
        sqftPerSlab: 55.1,
        wastePercent: 15,  // Lowest waste
        label: 'Porcelain Slab'
      },
      dekton: {
        width: 126,       // Dekton / sintered stone (Cosentino)
        height: 56,
        thickness: ['8mm', '12mm', '20mm', '30mm'],
        sqftPerSlab: 49,
        wastePercent: 18,
        label: 'Dekton Slab'
      },
      sintered: {
        width: 126,       // Generic sintered stone (Neolith, etc.)
        height: 60,
        thickness: ['6mm', '12mm', '20mm'],
        sqftPerSlab: 52.5,
        wastePercent: 18,
        label: 'Sintered Stone Slab'
      },
      soapstone: {
        width: 84,
        height: 36,
        thickness: ['3cm'],
        sqftPerSlab: 21,
        wastePercent: 30,
        label: 'Soapstone Slab'
      },
      // Jumbo slabs (some suppliers)
      jumboQuartz: {
        width: 132,
        height: 65,
        thickness: ['2cm', '3cm'],
        sqftPerSlab: 59.6,
        wastePercent: 18,
        label: 'Jumbo Quartz Slab'
      },
      jumboGranite: {
        width: 130,
        height: 78,
        thickness: ['3cm'],
        sqftPerSlab: 70.4,
        wastePercent: 22,
        label: 'Jumbo Granite Slab'
      }
    };

    const TAKEOFF_STANDARDS = {
      // Cabinet standards
      cabinet: {
        // Standard cabinet widths in inches (most common sizes)
        standardWidths: [9, 12, 15, 18, 21, 24, 27, 30, 33, 36],
        // Toe kick specifications
        toeKick: {
          height: 4.5,  // inches
          depth: 3,     // inches recessed
          pricePerLF: 4.50  // $/LF
        },
        // Scribe molding for walls
        scribe: {
          pricePerLF: 8.50,
          widths: [0.5, 0.75, 1.5]  // inches
        },
        // Filler strips
        filler: {
          minWidth: 1.5,   // inches - minimum practical filler
          maxWidth: 6,     // inches - max before using cabinet
          pricePerLF: 12,  // $/LF height (typically 30" or 34.5" for base)
          standardWidths: [3, 6]  // inches
        },
        // Heights
        baseHeight: 34.5,  // inches (without countertop)
        wallHeight: 30,    // inches (standard wall cabinet)
        tallHeight: 84     // inches (tall/pantry cabinet)
      },
      // Slab/stone calculations
      slab: {
        standardSizes: [
          { name: 'Half Slab', width: 60, height: 55, sqft: 22.9 },
          { name: 'Standard Slab', width: 120, height: 55, sqft: 45.8 },
          { name: 'Jumbo Slab', width: 130, height: 65, sqft: 58.7 }
        ],
        wastePercent: 20,  // typical waste for countertop fabrication
        seamAllowance: 0.125  // 1/8" seam allowance
      },
      // Flooring waste factors
      flooring: {
        tile: { wastePercent: 15, boxSqft: 10, label: 'Tile' },
        hardwood: { wastePercent: 10, boxSqft: 20, label: 'Hardwood' },
        lvp: { wastePercent: 10, boxSqft: 24, label: 'LVP/LVT' },
        carpet: { wastePercent: 5, rollWidth: 12, label: 'Carpet' },
        naturalStone: { wastePercent: 20, boxSqft: 5, label: 'Natural Stone Tile' }
      },
      // Scribe molding requirements
      scribe: {
        pricePerLF: 8.50,   // $/LF for scribe molding
        widthOptions: [0.5, 0.75, 1.5, 3], // Standard scribe widths in inches
        requiresWhen: ['wall', 'corner', 'uneven']
      },
      // Filler requirements
      filler: {
        pricePerLF: 25,     // $/LF for filler strips
        minWidth: 0.125,    // 1.5" minimum to count
        standardWidths: [3, 6, 12] // Standard filler widths available (inches)
      },
      // Edge profile linear feet pricing
      edgeProfiles: {
        eased: { pricePerLF: 0, labor: 'standard' },
        bullnose: { pricePerLF: 12, labor: 'standard' },
        ogee: { pricePerLF: 18, labor: 'specialty' },
        dupont: { pricePerLF: 22, labor: 'specialty' },
        waterfall: { pricePerLF: 45, labor: 'miter' }
      },
      // Backsplash calculations
      backsplash: {
        standard4: { height: 4, pricePerLF: 35 },
        standard6: { height: 6, pricePerLF: 45 },
        fullHeight: { height: 18, pricePerLF: 85 }
      },
      // Sink cutout pricing
      sinkCutouts: {
        undermount: { price: 175, label: 'Undermount Cutout' },
        dropin: { price: 75, label: 'Drop-in Cutout' },
        farmhouse: { price: 225, label: 'Farmhouse/Apron Cutout' },
        prep: { price: 125, label: 'Prep Sink Cutout' }
      },
      // Cooktop cutout
      cooktopCutout: { price: 125, label: 'Cooktop Cutout' }
    };

    // ===== LABOR RATES CONFIGURATION =====
    // Editable labor pricing for all services
    const LABOR_RATES = {
      // Stone/Countertop Services (per sqft unless noted)
      stone: {
        fabrication: { rate: 35, unit: 'sqft', label: 'Stone Fabrication', category: 'countertop' },
        installation: { rate: 15, unit: 'sqft', label: 'Countertop Installation', category: 'countertop' },
        polish: { rate: 8, unit: 'sqft', label: 'Polish/Seal', category: 'countertop' },
        template: { rate: 150, unit: 'visit', label: 'Template Visit', category: 'countertop' },
        delivery: { rate: 125, unit: 'trip', label: 'Delivery', category: 'countertop' }
      },
      // Cabinet Services
      cabinet: {
        installation: { rate: 85, unit: 'cabinet', label: 'Cabinet Installation', category: 'cabinet' },
        assembly: { rate: 45, unit: 'cabinet', label: 'Cabinet Assembly (RTA)', category: 'cabinet' },
        crownMolding: { rate: 12, unit: 'lf', label: 'Crown Molding Install', category: 'cabinet' },
        hardwareInstall: { rate: 8, unit: 'piece', label: 'Hardware Installation', category: 'cabinet' },
        modification: { rate: 75, unit: 'hour', label: 'Cabinet Modification', category: 'cabinet' }
      },
      // Plumbing Services
      plumbing: {
        sinkInstall: { rate: 175, unit: 'each', label: 'Sink Installation', category: 'plumbing' },
        faucetInstall: { rate: 125, unit: 'each', label: 'Faucet Installation', category: 'plumbing' },
        disposal: { rate: 150, unit: 'each', label: 'Garbage Disposal Install', category: 'plumbing' },
        dishwasherHookup: { rate: 125, unit: 'each', label: 'Dishwasher Hookup', category: 'plumbing' },
        roughIn: { rate: 350, unit: 'location', label: 'Plumbing Rough-In', category: 'plumbing' },
        waterLine: { rate: 85, unit: 'hour', label: 'Water Line Work', category: 'plumbing' }
      },
      // Electrical Services
      electrical: {
        outletInstall: { rate: 125, unit: 'each', label: 'Outlet Installation', category: 'electrical' },
        underCabinetLight: { rate: 85, unit: 'lf', label: 'Under-Cabinet Lighting', category: 'electrical' },
        applianceCircuit: { rate: 275, unit: 'each', label: 'Appliance Circuit', category: 'electrical' },
        permitFee: { rate: 150, unit: 'permit', label: 'Electrical Permit', category: 'electrical' }
      },
      // Flooring Services
      flooring: {
        tileInstall: { rate: 12, unit: 'sqft', label: 'Tile Installation', category: 'flooring' },
        hardwoodInstall: { rate: 8, unit: 'sqft', label: 'Hardwood Installation', category: 'flooring' },
        lvpInstall: { rate: 5, unit: 'sqft', label: 'LVP/LVT Installation', category: 'flooring' },
        subfloorPrep: { rate: 3, unit: 'sqft', label: 'Subfloor Prep', category: 'flooring' },
        grout: { rate: 2, unit: 'sqft', label: 'Grouting', category: 'flooring' },
        baseboardInstall: { rate: 4, unit: 'lf', label: 'Baseboard Installation', category: 'flooring' }
      },
      // Demo & Prep Services
      demo: {
        cabinetRemoval: { rate: 45, unit: 'cabinet', label: 'Cabinet Removal', category: 'demo' },
        countertopRemoval: { rate: 8, unit: 'sqft', label: 'Countertop Removal', category: 'demo' },
        flooringRemoval: { rate: 3, unit: 'sqft', label: 'Flooring Removal', category: 'demo' },
        backsplashRemoval: { rate: 6, unit: 'sqft', label: 'Backsplash Removal', category: 'demo' },
        applianceRemoval: { rate: 75, unit: 'each', label: 'Appliance Removal', category: 'demo' },
        dumpster: { rate: 450, unit: 'load', label: 'Dumpster/Haul Away', category: 'demo' },
        generalDemo: { rate: 65, unit: 'hour', label: 'General Demo Labor', category: 'demo' }
      },
      // Finishing/Specialty
      finishing: {
        drywall: { rate: 4, unit: 'sqft', label: 'Drywall Repair', category: 'finishing' },
        paint: { rate: 3, unit: 'sqft', label: 'Painting', category: 'finishing' },
        caulk: { rate: 4, unit: 'lf', label: 'Caulking', category: 'finishing' },
        trim: { rate: 6, unit: 'lf', label: 'Trim Work', category: 'finishing' },
        carpentry: { rate: 75, unit: 'hour', label: 'General Carpentry', category: 'finishing' }
      },
      // Project Fees
      fees: {
        projectManagement: { rate: 0, unit: 'percent', label: 'Project Management', category: 'fees', percentOf: 'total' },
        permit: { rate: 250, unit: 'permit', label: 'Building Permit', category: 'fees' },
        design: { rate: 150, unit: 'hour', label: 'Design Services', category: 'fees' },
        inspection: { rate: 100, unit: 'visit', label: 'Site Inspection', category: 'fees' }
      }
    };

    // Material pricing modes (slab vs sqft)
    const MATERIAL_PRICING = {
      // Slab-based materials (sold by slab, fabricated by sqft)
      slabMaterials: {
        granite: { slabPrice: 0, slabSqft: 45, label: 'Granite', priceMode: 'slab' },
        marble: { slabPrice: 0, slabSqft: 45, label: 'Marble', priceMode: 'slab' },
        quartzite: { slabPrice: 0, slabSqft: 45, label: 'Quartzite', priceMode: 'slab' },
        quartz: { slabPrice: 0, slabSqft: 50, label: 'Quartz', priceMode: 'slab' },
        porcelain: { slabPrice: 0, slabSqft: 32, label: 'Porcelain Slab', priceMode: 'slab' }
      },
      // Per-sqft materials
      sqftMaterials: {
        laminate: { pricePerSqft: 25, label: 'Laminate', priceMode: 'sqft' },
        solidSurface: { pricePerSqft: 45, label: 'Solid Surface', priceMode: 'sqft' },
        butcherBlock: { pricePerSqft: 35, label: 'Butcher Block', priceMode: 'sqft' }
      }
    };

    // ===== TAKEOFF CALCULATIONS =====
    function calculateTakeoffs() {
      const takeoffs = {
        stone: {
          slabs: [], totalSqft: 0, slabsNeeded: 0, edgeLF: 0, cutouts: [],
          materials: {}, // Group by material for pricing
          totalMaterialCost: 0, totalEdgeCost: 0, totalCutoutCost: 0
        },
        cabinets: { base: [], wall: [], tall: [], totalCount: 0, totalLF: 0, totalCost: 0 },
        scribe: { locations: [], totalLF: 0, totalCost: 0 },
        filler: { pieces: [], totalLF: 0, totalCost: 0 },
        flooring: { rooms: [], totalSqft: 0, boxesNeeded: 0, wasteIncluded: 0, totalCost: 0 },
        appliances: { items: [], totalCount: 0, totalCost: 0 },
        plumbing: { sinks: [], faucets: [], totalCount: 0, totalCost: 0 },
        backsplash: { areas: [], totalSqft: 0, totalLF: 0, totalCost: 0 },
        summary: { totalMaterialCost: 0, laborHours: 0, grandTotal: 0 }
      };

      // Helper function to calculate actual square footage for different shapes
      function calculateActualSqft(el) {
        const w = el.width;
        const h = el.height;

        if (el.type === 'countertop-l') {
          // L-shaped: Calculate as two arms meeting at corner
          // Arm width is stored in el.armWidth, or use default 2.2ft (26" countertop depth)
          const armW = el.armWidth || 2.17;
          // Area = horizontal arm + vertical arm - corner overlap
          // Horizontal arm: w * armW
          // Vertical arm: armW * (h - armW)
          // Total: w * armW + armW * h - armW * armW = armW * (w + h - armW)
          return armW * (w + h - armW);
        }

        if (el.type === 'countertop-u') {
          // U-shaped: back arm + two side arms
          const backDepth = h * 0.3; // Back arm depth (30% of total)
          const sideWidth = w * 0.25; // Side arm width (25% of total)
          // Back arm area: w * backDepth
          // Left arm area: sideWidth * (h - backDepth)
          // Right arm area: sideWidth * (h - backDepth)
          return (w * backDepth) + (2 * sideWidth * (h - backDepth));
        }

        // Standard rectangular countertop/element
        return w * h;
      }

      // Collect all elements by type
      elements.forEach(el => {
        const type = el.type;
        const sqft = calculateActualSqft(el);
        const widthInches = el.width * 12;
        const heightInches = el.height * 12;

        // ===== COUNTERTOPS / STONE =====
        // Explicit countertop types - islands are handled as cabinets separately
        if (type === 'countertop' || type === 'countertop-l' || type === 'countertop-u' ||
            type === 'countertop-corner' || type === 'island-countertop' ||
            type.startsWith('countertop')) {
          takeoffs.stone.totalSqft += sqft;

          // Calculate edge linear feet (perimeter minus back wall)
          const hasBackWall = !el.overhangBack || el.overhangBack < 0.1;
          const perimeter = (el.width + el.height) * 2;
          const edgeLF = hasBackWall ? perimeter - el.width : perimeter; // Subtract back edge if against wall
          takeoffs.stone.edgeLF += edgeLF;

          // Get material info from element (set when user applies material)
          const materialName = el.materialName || 'Unspecified Stone';
          const materialPrice = el.materialPrice || 0; // Price per SF
          const materialBrand = el.materialBrand || '';
          const materialId = el.materialId || 'unknown';

          // Group by material for summary
          if (!takeoffs.stone.materials[materialId]) {
            takeoffs.stone.materials[materialId] = {
              name: materialName,
              brand: materialBrand,
              pricePerSF: materialPrice,
              totalSqft: 0,
              totalCost: 0,
              pieces: []
            };
          }
          takeoffs.stone.materials[materialId].totalSqft += sqft;
          takeoffs.stone.materials[materialId].totalCost += sqft * materialPrice;
          takeoffs.stone.materials[materialId].pieces.push(el.label || 'Countertop');

          takeoffs.stone.totalMaterialCost += sqft * materialPrice;

          // Track waterfall edges (special pricing)
          if (el.waterfallSides && el.waterfallSides.length > 0) {
            el.waterfallSides.forEach(side => {
              const waterfallHeight = 2.5; // Standard 30" cabinet height
              const waterfallSqft = (side === 'left' || side === 'right' ? el.height : el.width) * waterfallHeight;
              takeoffs.stone.cutouts.push({
                type: 'waterfall',
                side: side,
                linearFeet: side === 'left' || side === 'right' ? el.height : el.width,
                height: waterfallHeight,
                sqft: waterfallSqft,
                cost: waterfallSqft * materialPrice
              });
              takeoffs.stone.totalMaterialCost += waterfallSqft * materialPrice;
            });
          }

          // Edge profile cost
          const edgePrice = TAKEOFF_STANDARDS.edgeProfiles[el.edgeProfile || 'eased']?.pricePerLF || 0;
          takeoffs.stone.totalEdgeCost += edgeLF * edgePrice;

          takeoffs.stone.slabs.push({
            label: el.label || 'Countertop',
            width: el.width,
            height: el.height,
            sqft: sqft,
            edgeLF: edgeLF,
            edgeProfile: el.edgeProfile || 'eased',
            material: materialName,
            materialBrand: materialBrand,
            pricePerSF: materialPrice,
            cost: sqft * materialPrice,
            hasWaterfall: (el.waterfallSides && el.waterfallSides.length > 0)
          });
        }

        // ===== CABINETS (All Types) =====
        // Base cabinets (including sink-base, drawer-base, corner, lazy-susan, island)
        else if (type === 'base-cabinet' || type === 'sink-base' ||
                 type === 'drawer-base' || type === 'corner-cabinet' ||
                 type === 'lazy-susan' || type === 'blind-corner' ||
                 type === 'dishwasher' || type === 'laundry-cabinet' ||
                 type === 'single-oven-cabinet' || type === 'double-oven-cabinet' ||
                 type === 'drawer-unit' || type === 'jewelry-cabinet' ||
                 type === 'island' || type === 'peninsula' || // Island and peninsula cabinets
                 type.includes('-base') || // Catch-all for base variants
                 (type === 'sink' && el.width > 1.5) || // MSI sink bases (width > 18")
                 (type === 'drawer' && el.width > 0.5)) { // MSI drawer bases
          const cabinetWidth = Math.round(widthInches);
          const cabinetLabel = type.includes('sink') ? 'Sink Base' :
                              type.includes('drawer') ? 'Drawer Base' :
                              type.includes('corner') ? 'Corner Base' :
                              type.includes('lazy') ? 'Lazy Susan' :
                              type.includes('blind') ? 'Blind Corner' :
                              type === 'dishwasher' ? 'Dishwasher' : 'Base';
          takeoffs.cabinets.base.push({
            label: el.label || `${cabinetLabel} ${cabinetWidth}"`,
            width: el.width,
            widthInches: cabinetWidth,
            sku: el.sku || `B${cabinetWidth}`,
            count: 1,
            subtype: cabinetLabel
          });
          takeoffs.cabinets.totalCount++;
          takeoffs.cabinets.totalLF += el.width;
        }
        // Wall cabinets (including microwave cabinet which is typically wall-mounted)
        else if (type === 'wall-cabinet' || type === 'microwave-cabinet' ||
                 type === 'above-microwave-cabinet' || type === 'medicine-cabinet' ||
                 type.includes('wall-cabinet')) {
          const cabinetWidth = Math.round(widthInches);
          const cabinetLabel = type === 'microwave-cabinet' ? 'Microwave Cabinet' : 'Wall';
          takeoffs.cabinets.wall.push({
            label: el.label || `${cabinetLabel} ${cabinetWidth}"`,
            width: el.width,
            widthInches: cabinetWidth,
            sku: el.sku || `W${cabinetWidth}`,
            count: 1
          });
          takeoffs.cabinets.totalCount++;
          takeoffs.cabinets.totalLF += el.width;
        }
        // Tall cabinets (including pantry, fridge cabinet)
        else if (type === 'tall-cabinet' || type === 'pantry' ||
                 type === 'fridge-cabinet' || type.includes('pantry') ||
                 type.includes('tall-')) {
          const cabinetWidth = Math.round(widthInches);
          const cabinetLabel = type.includes('pantry') ? 'Pantry' :
                              type.includes('fridge') ? 'Fridge Cabinet' : 'Tall';
          takeoffs.cabinets.tall.push({
            label: el.label || `${cabinetLabel} ${cabinetWidth}"`,
            width: el.width,
            widthInches: cabinetWidth,
            sku: el.sku || `T${cabinetWidth}`,
            count: 1,
            subtype: cabinetLabel
          });
          takeoffs.cabinets.totalCount++;
        }

        // ===== SINKS (Cutouts) - actual sink fixtures, not sink-base cabinets =====
        else if (type === 'sink' || type === 'sink-double' || type === 'sink-farmhouse' ||
                 type === 'sink-prep' || type === 'sink-bar') {
          const sinkType = el.mountType || 'undermount';
          takeoffs.plumbing.sinks.push({
            label: el.label || 'Sink',
            type: sinkType,
            width: el.width,
            cutoutPrice: TAKEOFF_STANDARDS.sinkCutouts[sinkType]?.price || 175
          });
          takeoffs.plumbing.totalCount++;
          takeoffs.stone.cutouts.push({
            type: 'sink',
            subtype: sinkType,
            label: el.label || 'Sink Cutout'
          });
        }

        // ===== APPLIANCES =====
        else if (['refrigerator', 'range', 'oven', 'microwave', 'range-hood', 'cooktop'].includes(type)) {
          takeoffs.appliances.items.push({
            type: type,
            label: el.label || type,
            width: el.width,
            height: el.height
          });
          takeoffs.appliances.totalCount++;

          // Cooktop requires cutout
          if (type === 'cooktop') {
            takeoffs.stone.cutouts.push({
              type: 'cooktop',
              label: 'Cooktop Cutout'
            });
          }
        }

        // ===== FLOORING =====
        else if (type === 'flooring' || type === 'tile-floor') {
          takeoffs.flooring.rooms.push({
            label: el.label || 'Flooring',
            sqft: sqft,
            material: el.material || 'tile'
          });
          takeoffs.flooring.totalSqft += sqft;
        }

        // ===== BACKSPLASH =====
        else if (type === 'backsplash') {
          takeoffs.backsplash.areas.push({
            label: el.label || 'Backsplash',
            width: el.width,
            height: el.height,
            sqft: sqft,
            linearFeet: el.width
          });
          takeoffs.backsplash.totalSqft += sqft;
          takeoffs.backsplash.totalLF += el.width;
        }
      });

      // ===== CALCULATE SLAB REQUIREMENTS =====
      if (takeoffs.stone.totalSqft > 0) {
        // Default to quartz if no material specified
        const materialType = 'quartz';
        const slabSpec = SLAB_STANDARDS[materialType];

        // Calculate net square feet needed
        const netSqft = takeoffs.stone.totalSqft;
        // Add waste factor
        const grossSqft = netSqft * (1 + slabSpec.wastePercent / 100);
        // Calculate slabs needed
        const slabsNeeded = Math.ceil(grossSqft / slabSpec.sqftPerSlab);

        takeoffs.stone.slabsNeeded = slabsNeeded;
        takeoffs.stone.netSqft = netSqft;
        takeoffs.stone.grossSqft = grossSqft;
        takeoffs.stone.wastePercent = slabSpec.wastePercent;
        takeoffs.stone.slabSize = `${slabSpec.width}"  ${slabSpec.height}"`;
        takeoffs.stone.sqftPerSlab = slabSpec.sqftPerSlab;
      }

      // ===== CALCULATE SCRIBE & FILLER REQUIREMENTS =====
      // Scribe molding: used where cabinet faces meet uneven walls
      // Filler strips: used to fill gaps between cabinet runs and walls/corners

      const rWidth = typeof roomWidth !== 'undefined' ? roomWidth : 12;
      const rDepth = typeof roomDepth !== 'undefined' ? roomDepth : 10;
      const pxPerFt = pixelsPerFoot || 50;

      // Get all cabinet elements with positions
      const cabinets = elements.filter(el => {
        const t = el.type;
        return t === 'base-cabinet' || t === 'sink-base' || t === 'drawer-base' ||
               t === 'corner-cabinet' || t === 'lazy-susan' || t === 'blind-corner' ||
               t === 'wall-cabinet' || t === 'microwave-cabinet' || t === 'above-microwave-cabinet' ||
               t === 'tall-cabinet' || t === 'pantry' || t === 'fridge-cabinet' ||
               t === 'single-oven-cabinet' || t === 'double-oven-cabinet' ||
               t === 'laundry-cabinet' || t === 'drawer-unit' ||
               t === 'dishwasher' || t === 'island' ||
               t.includes('cabinet') || t.includes('-base');
      }).map(el => ({
        ...el,
        xFt: el.x / pxPerFt,
        yFt: el.y / pxPerFt,
        widthFt: el.width,
        heightFt: el.height,
        rightEdgeFt: el.x / pxPerFt + el.width,
        bottomEdgeFt: el.y / pxPerFt + el.height
      }));

      // Group cabinets by wall they're against
      const wallCabinets = {
        back: [],    // Y  0 (back wall)
        front: [],   // Y  roomDepth (front wall)
        left: [],    // X  0 (left wall)
        right: []    // X  roomWidth (right wall)
      };

      const wallThreshold = 0.5; // Within 6" of wall

      cabinets.forEach(cab => {
        if (cab.yFt < wallThreshold) wallCabinets.back.push(cab);
        if (cab.bottomEdgeFt > rDepth - wallThreshold) wallCabinets.front.push(cab);
        if (cab.xFt < wallThreshold) wallCabinets.left.push(cab);
        if (cab.rightEdgeFt > rWidth - wallThreshold) wallCabinets.right.push(cab);
      });

      // Calculate scribe for each wall run
      Object.entries(wallCabinets).forEach(([wall, cabs]) => {
        if (cabs.length === 0) return;

        // Sort by position along wall
        const isHorizontal = wall === 'back' || wall === 'front';
        cabs.sort((a, b) => isHorizontal ? a.xFt - b.xFt : a.yFt - b.yFt);

        // Scribe needed at end cabinets where they meet wall corners
        cabs.forEach((cab, i) => {
          const isFirst = i === 0;
          const isLast = i === cabs.length - 1;

          // For horizontal runs (back/front walls), check left/right ends
          if (isHorizontal) {
            // Left end scribe
            if (isFirst && cab.xFt < wallThreshold) {
              takeoffs.scribe.locations.push({
                wall: wall,
                side: 'left end',
                cabinet: cab.label || `${Math.round(cab.widthFt * 12)}" cabinet`,
                length: cab.heightFt, // Depth of cabinet
                reason: 'Wall corner transition'
              });
              takeoffs.scribe.totalLF += cab.heightFt;
            }
            // Right end scribe
            if (isLast && cab.rightEdgeFt > rWidth - wallThreshold) {
              takeoffs.scribe.locations.push({
                wall: wall,
                side: 'right end',
                cabinet: cab.label || `${Math.round(cab.widthFt * 12)}" cabinet`,
                length: cab.heightFt,
                reason: 'Wall corner transition'
              });
              takeoffs.scribe.totalLF += cab.heightFt;
            }
          } else {
            // For vertical runs (left/right walls), check top/bottom ends
            if (isFirst && cab.yFt < wallThreshold) {
              takeoffs.scribe.locations.push({
                wall: wall,
                side: 'top end',
                cabinet: cab.label || `${Math.round(cab.widthFt * 12)}" cabinet`,
                length: cab.widthFt,
                reason: 'Wall corner transition'
              });
              takeoffs.scribe.totalLF += cab.widthFt;
            }
            if (isLast && cab.bottomEdgeFt > rDepth - wallThreshold) {
              takeoffs.scribe.locations.push({
                wall: wall,
                side: 'bottom end',
                cabinet: cab.label || `${Math.round(cab.widthFt * 12)}" cabinet`,
                length: cab.widthFt,
                reason: 'Wall corner transition'
              });
              takeoffs.scribe.totalLF += cab.widthFt;
            }
          }
        });
      });

      // Calculate filler requirements
      // Fillers are needed when cabinet runs don't fill the available wall space
      Object.entries(wallCabinets).forEach(([wall, cabs]) => {
        if (cabs.length === 0) return;

        const isHorizontal = wall === 'back' || wall === 'front';
        cabs.sort((a, b) => isHorizontal ? a.xFt - b.xFt : a.yFt - b.yFt);

        if (isHorizontal) {
          // Calculate total cabinet width along wall
          let totalCabWidth = cabs.reduce((sum, c) => sum + c.widthFt, 0);

          // Find the span these cabinets cover
          const firstCab = cabs[0];
          const lastCab = cabs[cabs.length - 1];
          const runStart = firstCab.xFt;
          const runEnd = lastCab.rightEdgeFt;
          const availableSpace = runEnd - runStart;

          // Check for gaps between cabinets
          for (let i = 0; i < cabs.length - 1; i++) {
            const currentEnd = cabs[i].rightEdgeFt;
            const nextStart = cabs[i + 1].xFt;
            const gap = nextStart - currentEnd;

            if (gap > TAKEOFF_STANDARDS.filler.minWidth) {
              const gapInches = Math.round(gap * 12);
              // Recommend standard filler width
              const recommendedWidth = TAKEOFF_STANDARDS.filler.standardWidths.find(w => w >= gapInches) ||
                                       Math.max(...TAKEOFF_STANDARDS.filler.standardWidths);

              takeoffs.filler.pieces.push({
                wall: wall,
                location: `Between ${cabs[i].label || 'cabinet'} and ${cabs[i+1].label || 'cabinet'}`,
                gapWidth: gapInches,
                recommendedFiller: recommendedWidth,
                length: 34.5, // Standard base cabinet height in inches
                lengthFt: 2.875
              });
              takeoffs.filler.totalLF += 2.875; // Cabinet height
            }
          }

          // Check for gap at start of run (between wall and first cabinet)
          if (runStart > wallThreshold) {
            const gapInches = Math.round(runStart * 12);
            if (gapInches >= TAKEOFF_STANDARDS.filler.minWidth * 12) {
              const recommendedWidth = TAKEOFF_STANDARDS.filler.standardWidths.find(w => w >= gapInches) ||
                                       Math.max(...TAKEOFF_STANDARDS.filler.standardWidths);
              takeoffs.filler.pieces.push({
                wall: wall,
                location: `${wall} wall start to first cabinet`,
                gapWidth: gapInches,
                recommendedFiller: recommendedWidth,
                length: 34.5,
                lengthFt: 2.875
              });
              takeoffs.filler.totalLF += 2.875;
            }
          }

          // Check for gap at end of run (between last cabinet and corner/wall end)
          // Only if cabinets don't extend to another wall
          const distanceToEnd = rWidth - runEnd;
          if (distanceToEnd > wallThreshold && distanceToEnd < 3) { // Gap but not room for another cabinet
            const gapInches = Math.round(distanceToEnd * 12);
            if (gapInches >= TAKEOFF_STANDARDS.filler.minWidth * 12) {
              const recommendedWidth = TAKEOFF_STANDARDS.filler.standardWidths.find(w => w >= gapInches) ||
                                       Math.max(...TAKEOFF_STANDARDS.filler.standardWidths);
              takeoffs.filler.pieces.push({
                wall: wall,
                location: `Last cabinet to ${wall} wall end`,
                gapWidth: gapInches,
                recommendedFiller: recommendedWidth,
                length: 34.5,
                lengthFt: 2.875
              });
              takeoffs.filler.totalLF += 2.875;
            }
          }
        } else {
          // Similar logic for vertical runs (left/right walls)
          for (let i = 0; i < cabs.length - 1; i++) {
            const currentEnd = cabs[i].bottomEdgeFt;
            const nextStart = cabs[i + 1].yFt;
            const gap = nextStart - currentEnd;

            if (gap > TAKEOFF_STANDARDS.filler.minWidth) {
              const gapInches = Math.round(gap * 12);
              const recommendedWidth = TAKEOFF_STANDARDS.filler.standardWidths.find(w => w >= gapInches) ||
                                       Math.max(...TAKEOFF_STANDARDS.filler.standardWidths);

              takeoffs.filler.pieces.push({
                wall: wall,
                location: `Between ${cabs[i].label || 'cabinet'} and ${cabs[i+1].label || 'cabinet'}`,
                gapWidth: gapInches,
                recommendedFiller: recommendedWidth,
                length: 34.5,
                lengthFt: 2.875
              });
              takeoffs.filler.totalLF += 2.875;
            }
          }
        }
      });

      // Calculate costs
      takeoffs.scribe.totalCost = takeoffs.scribe.totalLF * TAKEOFF_STANDARDS.scribe.pricePerLF;
      takeoffs.filler.totalCost = takeoffs.filler.totalLF * TAKEOFF_STANDARDS.filler.pricePerLF;

      // ===== CALCULATE FLOORING WITH WASTE =====
      if (takeoffs.flooring.totalSqft > 0) {
        const floorSpec = TAKEOFF_STANDARDS.flooring.tile;
        const wasteSqft = takeoffs.flooring.totalSqft * (floorSpec.wastePercent / 100);
        takeoffs.flooring.wasteIncluded = wasteSqft;
        takeoffs.flooring.grossSqft = takeoffs.flooring.totalSqft + wasteSqft;
        takeoffs.flooring.boxesNeeded = Math.ceil(takeoffs.flooring.grossSqft / floorSpec.boxSqft);
      }

      // ===== CONSOLIDATE CABINETS BY SIZE =====
      takeoffs.cabinets.baseSummary = consolidateCabinets(takeoffs.cabinets.base);
      takeoffs.cabinets.wallSummary = consolidateCabinets(takeoffs.cabinets.wall);
      takeoffs.cabinets.tallSummary = consolidateCabinets(takeoffs.cabinets.tall);

      return takeoffs;
    }

    // Helper: Consolidate cabinet list by size
    function consolidateCabinets(cabinetList) {
      const summary = {};
      cabinetList.forEach(cab => {
        const key = cab.widthInches;
        if (!summary[key]) {
          summary[key] = { width: cab.widthInches, count: 0, sku: cab.sku };
        }
        summary[key].count++;
      });
      return Object.values(summary).sort((a, b) => a.width - b.width);
    }

    // ===== GENERATE TAKEOFF REPORT =====
    function generateTakeoffReport() {
      const takeoffs = calculateTakeoffs();
      showTakeoffModal(takeoffs);
    }

    // Show takeoff modal with detailed breakdown
    function showTakeoffModal(takeoffs) {
      const modal = document.getElementById('takeoffModal');
      const content = document.getElementById('takeoffContent');

      let html = '';

      // ===== STONE / COUNTERTOPS SECTION =====
      if (takeoffs.stone.totalSqft > 0) {
        const hasPricing = takeoffs.stone.totalMaterialCost > 0;
        const materialsList = Object.values(takeoffs.stone.materials);

        html += `
          <div class="takeoff-section takeoff-highlight">
            <div class="takeoff-section-header">
              <div class="takeoff-section-title">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <rect x="3" y="3" width="18" height="18" rx="2"/>
                </svg>
                Stone / Countertops
                <span class="takeoff-section-badge">${takeoffs.stone.slabsNeeded} Slab${takeoffs.stone.slabsNeeded > 1 ? 's' : ''}</span>
              </div>
              ${hasPricing ? `<div style="font-size: 16px; font-weight: 700; color: #10b981;">$${takeoffs.stone.totalMaterialCost.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2})}</div>` : ''}
            </div>

            ${materialsList.length > 0 ? `
              <div style="margin-bottom: 16px;">
                <div style="font-weight: 600; margin-bottom: 8px; color: var(--text-secondary); font-size: 12px; text-transform: uppercase;">Materials Selected</div>
                <table class="takeoff-table">
                  <thead>
                    <tr>
                      <th>Stone</th>
                      <th>Brand</th>
                      <th>SF</th>
                      <th>$/SF</th>
                      <th style="text-align: right;">Subtotal</th>
                    </tr>
                  </thead>
                  <tbody>
                    ${materialsList.map(m => `
                      <tr>
                        <td><strong>${m.name}</strong></td>
                        <td>${m.brand || '-'}</td>
                        <td>${m.totalSqft.toFixed(1)}</td>
                        <td>${m.pricePerSF > 0 ? '$' + m.pricePerSF.toFixed(2) : '-'}</td>
                        <td style="text-align: right; font-weight: 600;">${m.totalCost > 0 ? '$' + m.totalCost.toFixed(2) : '-'}</td>
                      </tr>
                    `).join('')}
                  </tbody>
                </table>
              </div>
            ` : `
              <div class="takeoff-warning" style="margin-bottom: 16px;">
                <span></span>
                <span>Select a stone material to see pricing. Click a countertop then choose from Materials panel.</span>
              </div>
            `}

            <div class="takeoff-grid">
              <div class="takeoff-item">
                <div class="takeoff-item-label">Net Square Feet</div>
                <div class="takeoff-item-value">${takeoffs.stone.netSqft?.toFixed(1) || takeoffs.stone.totalSqft.toFixed(1)} <span class="takeoff-item-unit">SF</span></div>
                <div class="takeoff-item-note">Actual countertop area</div>
              </div>
              <div class="takeoff-item">
                <div class="takeoff-item-label">Gross (w/ ${takeoffs.stone.wastePercent || 20}% waste)</div>
                <div class="takeoff-item-value">${takeoffs.stone.grossSqft?.toFixed(1) || (takeoffs.stone.totalSqft * 1.2).toFixed(1)} <span class="takeoff-item-unit">SF</span></div>
                <div class="takeoff-item-note">Includes cutting waste</div>
              </div>
              <div class="takeoff-item">
                <div class="takeoff-item-label">Slabs Required</div>
                <div class="takeoff-item-value">${takeoffs.stone.slabsNeeded || Math.ceil(takeoffs.stone.totalSqft * 1.2 / 55)}</div>
                <div class="takeoff-item-note">@ ${takeoffs.stone.sqftPerSlab?.toFixed(1) || '55'} SF/slab</div>
              </div>
              <div class="takeoff-item">
                <div class="takeoff-item-label">Edge Profile LF</div>
                <div class="takeoff-item-value">${takeoffs.stone.edgeLF?.toFixed(1) || '0'} <span class="takeoff-item-unit">LF</span></div>
                <div class="takeoff-item-note">${takeoffs.stone.totalEdgeCost > 0 ? '+$' + takeoffs.stone.totalEdgeCost.toFixed(2) : 'Eased edge included'}</div>
              </div>
            </div>

            <div class="slab-visual">
              ${Array(takeoffs.stone.slabsNeeded || Math.ceil(takeoffs.stone.totalSqft * 1.2 / 55)).fill(0).map((_, i) =>
                `<div class="slab-icon used">${i + 1}</div>`
              ).join('')}
            </div>

            ${takeoffs.stone.cutouts.length > 0 ? `
              <div style="margin-top: 16px;">
                <div style="font-weight: 600; margin-bottom: 8px; color: var(--text-secondary); font-size: 12px; text-transform: uppercase;">Cutouts & Fabrication</div>
                <table class="takeoff-table">
                  <thead>
                    <tr>
                      <th>Item</th>
                      <th>Type</th>
                      <th>Size</th>
                      <th style="text-align: right;">Cost</th>
                    </tr>
                  </thead>
                  <tbody>
                    ${takeoffs.stone.cutouts.map(c => `
                      <tr>
                        <td>${c.label || (c.type === 'waterfall' ? 'Waterfall Edge' : c.type)}</td>
                        <td>${c.subtype || c.type}</td>
                        <td>${c.sqft ? c.sqft.toFixed(1) + ' SF' : (c.linearFeet ? c.linearFeet.toFixed(1) + ' LF' : '1')}</td>
                        <td style="text-align: right;">${c.cost ? '$' + c.cost.toFixed(2) : (TAKEOFF_STANDARDS.sinkCutouts[c.subtype]?.price ? '$' + TAKEOFF_STANDARDS.sinkCutouts[c.subtype].price : '-')}</td>
                      </tr>
                    `).join('')}
                  </tbody>
                </table>
              </div>
            ` : ''}
          </div>
        `;
      }

      // ===== CABINETS SECTION =====
      if (takeoffs.cabinets.totalCount > 0) {
        html += `
          <div class="takeoff-section">
            <div class="takeoff-section-header">
              <div class="takeoff-section-title">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <rect x="3" y="3" width="7" height="9"/><rect x="14" y="3" width="7" height="9"/>
                  <rect x="3" y="14" width="7" height="7"/><rect x="14" y="14" width="7" height="7"/>
                </svg>
                Cabinets
                <span class="takeoff-section-badge">${takeoffs.cabinets.totalCount} Units</span>
              </div>
              <div style="font-size: 13px; color: var(--text-secondary);">
                ${takeoffs.cabinets.totalLF.toFixed(1)} LF total
              </div>
            </div>
            <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 16px;">
              ${takeoffs.cabinets.baseSummary.length > 0 ? `
                <div>
                  <div style="font-weight: 600; margin-bottom: 8px; color: var(--text-secondary); font-size: 12px;">BASE CABINETS</div>
                  <table class="takeoff-table">
                    <thead><tr><th>Size</th><th>Qty</th></tr></thead>
                    <tbody>
                      ${takeoffs.cabinets.baseSummary.map(c => `
                        <tr><td>B${c.width}" ${c.width >= 36 ? '(Sink/Range)' : ''}</td><td>${c.count}</td></tr>
                      `).join('')}
                    </tbody>
                  </table>
                </div>
              ` : ''}
              ${takeoffs.cabinets.wallSummary.length > 0 ? `
                <div>
                  <div style="font-weight: 600; margin-bottom: 8px; color: var(--text-secondary); font-size: 12px;">WALL CABINETS</div>
                  <table class="takeoff-table">
                    <thead><tr><th>Size</th><th>Qty</th></tr></thead>
                    <tbody>
                      ${takeoffs.cabinets.wallSummary.map(c => `
                        <tr><td>W${c.width}"</td><td>${c.count}</td></tr>
                      `).join('')}
                    </tbody>
                  </table>
                </div>
              ` : ''}
              ${takeoffs.cabinets.tallSummary.length > 0 ? `
                <div>
                  <div style="font-weight: 600; margin-bottom: 8px; color: var(--text-secondary); font-size: 12px;">TALL/PANTRY</div>
                  <table class="takeoff-table">
                    <thead><tr><th>Size</th><th>Qty</th></tr></thead>
                    <tbody>
                      ${takeoffs.cabinets.tallSummary.map(c => `
                        <tr><td>T${c.width}"</td><td>${c.count}</td></tr>
                      `).join('')}
                    </tbody>
                  </table>
                </div>
              ` : ''}
            </div>
          </div>
        `;
      }

      // ===== SCRIBE / FILLER SECTION =====
      if (takeoffs.scribe.totalLF > 0 || takeoffs.filler.pieces.length > 0) {
        const scribeCost = takeoffs.scribe.totalCost || (takeoffs.scribe.totalLF * TAKEOFF_STANDARDS.scribe.pricePerLF);
        const fillerCost = takeoffs.filler.totalCost || (takeoffs.filler.totalLF * TAKEOFF_STANDARDS.filler.pricePerLF);
        const totalCost = scribeCost + fillerCost;

        html += `
          <div class="takeoff-section">
            <div class="takeoff-section-header">
              <div class="takeoff-section-title">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M21 10H3M21 6H3M21 14H3M21 18H3"/>
                </svg>
                Scribe & Filler
                <span class="takeoff-section-badge">${(takeoffs.scribe.locations.length + takeoffs.filler.pieces.length)} Pieces</span>
              </div>
              ${totalCost > 0 ? `<div style="font-size: 16px; font-weight: 700; color: #10b981;">$${totalCost.toFixed(2)}</div>` : ''}
            </div>

            ${takeoffs.scribe.locations.length > 0 ? `
              <div style="margin-bottom: 16px;">
                <div style="font-weight: 600; margin-bottom: 8px; color: var(--text-secondary); font-size: 12px; text-transform: uppercase;">Scribe Molding @ $${TAKEOFF_STANDARDS.scribe.pricePerLF.toFixed(2)}/LF</div>
                <table class="takeoff-table">
                  <thead>
                    <tr>
                      <th>Wall</th>
                      <th>Location</th>
                      <th>Length</th>
                      <th style="text-align: right;">Cost</th>
                    </tr>
                  </thead>
                  <tbody>
                    ${takeoffs.scribe.locations.map(s => `
                      <tr>
                        <td style="text-transform: capitalize;">${s.wall}</td>
                        <td>${s.side} - ${s.cabinet}</td>
                        <td>${s.length.toFixed(1)} LF</td>
                        <td style="text-align: right;">$${(s.length * TAKEOFF_STANDARDS.scribe.pricePerLF).toFixed(2)}</td>
                      </tr>
                    `).join('')}
                    <tr style="font-weight: 600; border-top: 2px solid var(--border-color);">
                      <td colspan="2">Scribe Total</td>
                      <td>${takeoffs.scribe.totalLF.toFixed(1)} LF</td>
                      <td style="text-align: right;">$${scribeCost.toFixed(2)}</td>
                    </tr>
                  </tbody>
                </table>
              </div>
            ` : ''}

            ${takeoffs.filler.pieces.length > 0 ? `
              <div style="margin-bottom: 16px;">
                <div style="font-weight: 600; margin-bottom: 8px; color: var(--text-secondary); font-size: 12px; text-transform: uppercase;">Filler Strips @ $${TAKEOFF_STANDARDS.filler.pricePerLF.toFixed(2)}/LF</div>
                <table class="takeoff-table">
                  <thead>
                    <tr>
                      <th>Wall</th>
                      <th>Location</th>
                      <th>Gap</th>
                      <th>Filler Size</th>
                      <th style="text-align: right;">Cost</th>
                    </tr>
                  </thead>
                  <tbody>
                    ${takeoffs.filler.pieces.map(f => `
                      <tr>
                        <td style="text-transform: capitalize;">${f.wall}</td>
                        <td>${f.location}</td>
                        <td>${f.gapWidth}"</td>
                        <td>${f.recommendedFiller}"  ${f.length}" H</td>
                        <td style="text-align: right;">$${(f.lengthFt * TAKEOFF_STANDARDS.filler.pricePerLF).toFixed(2)}</td>
                      </tr>
                    `).join('')}
                    <tr style="font-weight: 600; border-top: 2px solid var(--border-color);">
                      <td colspan="3">Filler Total</td>
                      <td>${takeoffs.filler.totalLF.toFixed(1)} LF</td>
                      <td style="text-align: right;">$${fillerCost.toFixed(2)}</td>
                    </tr>
                  </tbody>
                </table>
              </div>
            ` : ''}

            ${takeoffs.scribe.totalLF > 0 || takeoffs.filler.pieces.length > 0 ? `
              <div class="takeoff-warning">
                <span></span>
                <span>Order 10% extra scribe/filler for cuts and adjustments. Fillers can be trimmed on-site to fit exact gaps.</span>
              </div>
            ` : ''}
          </div>
        `;
      }

      // ===== FLOORING SECTION =====
      if (takeoffs.flooring.totalSqft > 0) {
        html += `
          <div class="takeoff-section">
            <div class="takeoff-section-header">
              <div class="takeoff-section-title">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <rect x="3" y="3" width="18" height="18"/><path d="M3 9h18M3 15h18M9 3v18M15 3v18"/>
                </svg>
                Flooring
                <span class="takeoff-section-badge">${takeoffs.flooring.boxesNeeded} Boxes</span>
              </div>
            </div>
            <div class="takeoff-grid">
              <div class="takeoff-item">
                <div class="takeoff-item-label">Room Area</div>
                <div class="takeoff-item-value">${takeoffs.flooring.totalSqft.toFixed(1)} <span class="takeoff-item-unit">SF</span></div>
              </div>
              <div class="takeoff-item">
                <div class="takeoff-item-label">+ Waste (${TAKEOFF_STANDARDS.flooring.tile.wastePercent}%)</div>
                <div class="takeoff-item-value">${takeoffs.flooring.wasteIncluded?.toFixed(1) || '0'} <span class="takeoff-item-unit">SF</span></div>
              </div>
              <div class="takeoff-item">
                <div class="takeoff-item-label">Total Needed</div>
                <div class="takeoff-item-value">${takeoffs.flooring.grossSqft?.toFixed(1) || '0'} <span class="takeoff-item-unit">SF</span></div>
              </div>
              <div class="takeoff-item">
                <div class="takeoff-item-label">Boxes to Order</div>
                <div class="takeoff-item-value">${takeoffs.flooring.boxesNeeded || 0}</div>
                <div class="takeoff-item-note">@ ${TAKEOFF_STANDARDS.flooring.tile.boxSqft} SF/box</div>
              </div>
            </div>
          </div>
        `;
      }

      // ===== APPLIANCES SECTION =====
      if (takeoffs.appliances.totalCount > 0) {
        html += `
          <div class="takeoff-section">
            <div class="takeoff-section-header">
              <div class="takeoff-section-title">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <rect x="4" y="2" width="16" height="20" rx="2"/><line x1="8" y1="6" x2="16" y2="6"/>
                  <circle cx="12" cy="14" r="4"/>
                </svg>
                Appliances
                <span class="takeoff-section-badge">${takeoffs.appliances.totalCount}</span>
              </div>
            </div>
            <table class="takeoff-table">
              <thead>
                <tr><th>Item</th><th>Size</th><th>Qty</th></tr>
              </thead>
              <tbody>
                ${takeoffs.appliances.items.map(a => `
                  <tr>
                    <td>${a.label}</td>
                    <td>${Math.round(a.width * 12)}"W  ${Math.round(a.height * 12)}"D</td>
                    <td>1</td>
                  </tr>
                `).join('')}
              </tbody>
            </table>
          </div>
        `;
      }

      // ===== PLUMBING / FIXTURES SECTION =====
      if (takeoffs.plumbing.totalCount > 0) {
        html += `
          <div class="takeoff-section">
            <div class="takeoff-section-header">
              <div class="takeoff-section-title">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M5.5 5.5L8 3L10.5 5.5"/><path d="M8 3v6a4 4 0 004 4h4"/>
                  <circle cx="18" cy="13" r="2"/><path d="M18 15v6"/>
                </svg>
                Plumbing & Fixtures
                <span class="takeoff-section-badge">${takeoffs.plumbing.totalCount}</span>
              </div>
            </div>
            <table class="takeoff-table">
              <thead>
                <tr><th>Item</th><th>Type</th><th>Cutout</th></tr>
              </thead>
              <tbody>
                ${takeoffs.plumbing.sinks.map(s => `
                  <tr>
                    <td>${s.label}</td>
                    <td>${s.type}</td>
                    <td>$${s.cutoutPrice}</td>
                  </tr>
                `).join('')}
              </tbody>
            </table>
          </div>
        `;
      }

      // ===== SUMMARY SECTION =====
      // Calculate all costs itemized
      const costs = {
        stoneMaterial: takeoffs.stone.totalMaterialCost || 0,
        edgeProfile: takeoffs.stone.totalEdgeCost || 0,
        sinkCutouts: takeoffs.plumbing.sinks.reduce((sum, s) => sum + (s.cutoutPrice || 0), 0),
        cooktopCutouts: takeoffs.stone.cutouts.filter(c => c.type === 'cooktop').length * TAKEOFF_STANDARDS.cooktopCutout.price,
        scribe: (takeoffs.scribe.totalCost || takeoffs.scribe.totalLF * TAKEOFF_STANDARDS.scribe.pricePerLF),
        filler: (takeoffs.filler.totalCost || takeoffs.filler.totalLF * TAKEOFF_STANDARDS.filler.pricePerLF),
        cabinets: takeoffs.cabinets.totalCost || 0,
        flooring: takeoffs.flooring.totalCost || 0
      };
      const grandTotal = Object.values(costs).reduce((sum, c) => sum + c, 0);

      // Build itemized cost list (only items with values)
      const costItems = [];
      if (costs.stoneMaterial > 0) costItems.push({ label: 'Stone Material', qty: `${takeoffs.stone.totalSqft.toFixed(1)} SF`, cost: costs.stoneMaterial });
      if (costs.edgeProfile > 0) costItems.push({ label: 'Edge Profile', qty: `${takeoffs.stone.edgeLF.toFixed(1)} LF`, cost: costs.edgeProfile });
      if (costs.sinkCutouts > 0) costItems.push({ label: 'Sink Cutouts', qty: `${takeoffs.plumbing.sinks.length} cutout(s)`, cost: costs.sinkCutouts });
      if (costs.cooktopCutouts > 0) costItems.push({ label: 'Cooktop Cutout', qty: '1 cutout', cost: costs.cooktopCutouts });
      if (costs.scribe > 0) costItems.push({ label: 'Scribe Molding', qty: `${takeoffs.scribe.totalLF.toFixed(1)} LF`, cost: costs.scribe });
      if (costs.filler > 0) costItems.push({ label: 'Filler Strips', qty: `${takeoffs.filler.totalLF.toFixed(1)} LF`, cost: costs.filler });
      if (costs.cabinets > 0) costItems.push({ label: 'Cabinets', qty: `${takeoffs.cabinets.totalCount} units`, cost: costs.cabinets });
      if (costs.flooring > 0) costItems.push({ label: 'Flooring', qty: `${takeoffs.flooring.grossSqft?.toFixed(1) || 0} SF`, cost: costs.flooring });

      html += `
        <div class="takeoff-summary">
          <div class="takeoff-summary-title">ORDER SUMMARY</div>
          <div class="takeoff-summary-grid">
            <div class="takeoff-item">
              <div class="takeoff-item-label">Stone Slabs</div>
              <div class="takeoff-item-value">${takeoffs.stone.slabsNeeded || Math.ceil((takeoffs.stone.totalSqft || 0) * 1.2 / 55)}</div>
              <div class="takeoff-item-note">${takeoffs.stone.totalSqft.toFixed(1)} net SF</div>
            </div>
            <div class="takeoff-item">
              <div class="takeoff-item-label">Cabinets</div>
              <div class="takeoff-item-value">${takeoffs.cabinets.totalCount}</div>
              <div class="takeoff-item-note">${takeoffs.cabinets.totalLF.toFixed(1)} LF</div>
            </div>
            <div class="takeoff-item">
              <div class="takeoff-item-label">Scribe/Filler</div>
              <div class="takeoff-item-value">${(takeoffs.scribe.totalLF + takeoffs.filler.totalLF).toFixed(1)} <span class="takeoff-item-unit">LF</span></div>
              <div class="takeoff-item-note">${takeoffs.scribe.locations.length + takeoffs.filler.pieces.length} locations</div>
            </div>
            <div class="takeoff-item">
              <div class="takeoff-item-label">Sink Cutouts</div>
              <div class="takeoff-item-value">${takeoffs.plumbing.sinks.length}</div>
            </div>
          </div>

          ${costItems.length > 0 ? `
            <div style="margin-top: 20px; padding-top: 16px; border-top: 2px solid var(--border-color);">
              <div style="font-weight: 600; margin-bottom: 12px; color: var(--text-secondary); font-size: 12px; text-transform: uppercase;">
                Material Cost Breakdown
              </div>
              <table class="takeoff-table" style="margin-bottom: 16px;">
                <thead>
                  <tr>
                    <th>Item</th>
                    <th>Quantity</th>
                    <th style="text-align: right;">Cost</th>
                  </tr>
                </thead>
                <tbody>
                  ${costItems.map(item => `
                    <tr>
                      <td>${item.label}</td>
                      <td>${item.qty}</td>
                      <td style="text-align: right;">$${item.cost.toFixed(2)}</td>
                    </tr>
                  `).join('')}
                </tbody>
              </table>
            </div>
          ` : ''}

          ${grandTotal > 0 ? `
            <div style="margin-top: 16px; padding: 16px; background: linear-gradient(135deg, rgba(16, 185, 129, 0.1), rgba(16, 185, 129, 0.05)); border-radius: 8px; border: 1px solid rgba(16, 185, 129, 0.2);">
              <div style="display: flex; justify-content: space-between; align-items: center;">
                <div>
                  <div style="font-size: 14px; font-weight: 600; color: var(--text-primary);">Estimated Material Total</div>
                  <div style="font-size: 11px; color: var(--text-muted); margin-top: 2px;">Excludes labor & installation</div>
                </div>
                <div style="font-size: 28px; font-weight: 700; color: #10b981;">$${grandTotal.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2})}</div>
              </div>
            </div>
          ` : `
            <div style="margin-top: 16px; padding: 16px; background: var(--bg-secondary); border-radius: 8px; text-align: center;">
              <div style="font-size: 13px; color: var(--text-muted);">
                Select materials for countertops and cabinets to see pricing breakdown
              </div>
            </div>
          `}
          <div style="margin-top: 16px; display: flex; gap: 8px;">
            <button class="btn btn-primary" onclick="exportTakeoffPDF()" style="flex: 1;">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="margin-right: 6px;">
                <path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4"/><polyline points="7,10 12,15 17,10"/><line x1="12" y1="15" x2="12" y2="3"/>
              </svg>
              Download PDF
            </button>
            <button class="btn btn-secondary" onclick="copyTakeoffToClipboard()" style="flex: 1;">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="margin-right: 6px;">
                <rect x="9" y="9" width="13" height="13" rx="2"/><path d="M5 15H4a2 2 0 01-2-2V4a2 2 0 012-2h9a2 2 0 012 2v1"/>
              </svg>
              Copy to Clipboard
            </button>
          </div>
        </div>
      `;

      // Empty state
      if (takeoffs.stone.totalSqft === 0 && takeoffs.cabinets.totalCount === 0) {
        html = `
          <div style="text-align: center; padding: 60px 20px; color: var(--text-muted);">
            <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" style="margin-bottom: 16px; opacity: 0.5;">
              <path d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2"/>
              <rect x="9" y="3" width="6" height="4" rx="1"/>
            </svg>
            <div style="font-size: 16px; margin-bottom: 8px;">No Elements to Calculate</div>
            <div style="font-size: 13px;">Add cabinets, countertops, and other elements to generate takeoffs.</div>
          </div>
        `;
      }

      content.innerHTML = html;
      modal.style.display = 'flex';
    }

    // Export takeoff as PDF
    function exportTakeoffPDF() {
      // Use existing PDF export functionality
      if (typeof jspdf !== 'undefined') {
        const { jsPDF } = window.jspdf;
        const doc = new jsPDF();
        const takeoffs = calculateTakeoffs();

        doc.setFontSize(20);
        doc.text('Material Takeoff Report', 20, 20);

        doc.setFontSize(12);
        doc.text(`Project: ${projectName || 'Untitled Project'}`, 20, 35);
        doc.text(`Date: ${new Date().toLocaleDateString()}`, 20, 42);

        let y = 55;

        // Stone section
        if (takeoffs.stone.slabsNeeded > 0) {
          doc.setFontSize(14);
          doc.text('Stone / Countertops', 20, y);
          y += 8;
          doc.setFontSize(10);
          doc.text(`Slabs Required: ${takeoffs.stone.slabsNeeded}`, 25, y); y += 6;
          doc.text(`Net Area: ${takeoffs.stone.netSqft?.toFixed(1)} SF`, 25, y); y += 6;
          doc.text(`Gross (w/ waste): ${takeoffs.stone.grossSqft?.toFixed(1)} SF`, 25, y); y += 6;
          doc.text(`Edge LF: ${takeoffs.stone.edgeLF?.toFixed(1)} LF`, 25, y); y += 10;
        }

        // Cabinets section
        if (takeoffs.cabinets.totalCount > 0) {
          doc.setFontSize(14);
          doc.text('Cabinets', 20, y);
          y += 8;
          doc.setFontSize(10);
          doc.text(`Total Cabinets: ${takeoffs.cabinets.totalCount}`, 25, y); y += 6;
          doc.text(`Total Linear Feet: ${takeoffs.cabinets.totalLF.toFixed(1)} LF`, 25, y); y += 10;
        }

        // Scribe & Filler section
        if (takeoffs.scribe.totalLF > 0 || takeoffs.filler.pieces.length > 0) {
          doc.setFontSize(14);
          doc.text('Scribe & Filler', 20, y);
          y += 8;
          doc.setFontSize(10);
          if (takeoffs.scribe.totalLF > 0) {
            doc.text(`Scribe Molding: ${takeoffs.scribe.totalLF.toFixed(1)} LF @ $${TAKEOFF_STANDARDS.scribe.pricePerLF}/LF = $${(takeoffs.scribe.totalLF * TAKEOFF_STANDARDS.scribe.pricePerLF).toFixed(2)}`, 25, y);
            y += 6;
            takeoffs.scribe.locations.forEach(s => {
              doc.text(`  - ${s.wall} wall, ${s.side}: ${s.length.toFixed(1)} LF`, 30, y);
              y += 5;
            });
          }
          if (takeoffs.filler.pieces.length > 0) {
            doc.text(`Filler Strips: ${takeoffs.filler.totalLF.toFixed(1)} LF @ $${TAKEOFF_STANDARDS.filler.pricePerLF}/LF = $${(takeoffs.filler.totalLF * TAKEOFF_STANDARDS.filler.pricePerLF).toFixed(2)}`, 25, y);
            y += 6;
            takeoffs.filler.pieces.forEach(f => {
              doc.text(`  - ${f.wall} wall: ${f.gapWidth}" gap, use ${f.recommendedFiller}" filler`, 30, y);
              y += 5;
            });
          }
          y += 5;
        }

        // Cost Summary
        const costs = {
          stoneMaterial: takeoffs.stone.totalMaterialCost || 0,
          edgeProfile: takeoffs.stone.totalEdgeCost || 0,
          sinkCutouts: takeoffs.plumbing.sinks.reduce((sum, s) => sum + (s.cutoutPrice || 0), 0),
          scribe: takeoffs.scribe.totalLF * TAKEOFF_STANDARDS.scribe.pricePerLF,
          filler: takeoffs.filler.totalLF * TAKEOFF_STANDARDS.filler.pricePerLF
        };
        const grandTotal = Object.values(costs).reduce((sum, c) => sum + c, 0);

        if (grandTotal > 0) {
          y += 10;
          doc.setFontSize(14);
          doc.text('Cost Summary', 20, y);
          y += 8;
          doc.setFontSize(10);
          if (costs.stoneMaterial > 0) { doc.text(`Stone Material: $${costs.stoneMaterial.toFixed(2)}`, 25, y); y += 6; }
          if (costs.edgeProfile > 0) { doc.text(`Edge Profile: $${costs.edgeProfile.toFixed(2)}`, 25, y); y += 6; }
          if (costs.sinkCutouts > 0) { doc.text(`Sink Cutouts: $${costs.sinkCutouts.toFixed(2)}`, 25, y); y += 6; }
          if (costs.scribe > 0) { doc.text(`Scribe Molding: $${costs.scribe.toFixed(2)}`, 25, y); y += 6; }
          if (costs.filler > 0) { doc.text(`Filler Strips: $${costs.filler.toFixed(2)}`, 25, y); y += 6; }
          y += 4;
          doc.setFontSize(12);
          doc.text(`TOTAL: $${grandTotal.toFixed(2)}`, 25, y);
        }

        doc.save('takeoff-report.pdf');
      } else {
        showToast('PDF export requires jsPDF library', 'error');
      }
    }

    // Copy takeoff to clipboard as text
    function copyTakeoffToClipboard() {
      const takeoffs = calculateTakeoffs();
      const materialsList = Object.values(takeoffs.stone.materials);

      let text = `MATERIAL TAKEOFF REPORT\n`;
      text += `Project: ${projectName || 'Untitled Project'}\n`;
      text += `Date: ${new Date().toLocaleDateString()}\n`;
      text += `${'='.repeat(50)}\n\n`;

      // Stone section
      if (takeoffs.stone.totalSqft > 0) {
        text += `STONE / COUNTERTOPS\n`;
        text += `-`.repeat(30) + `\n`;
        text += `Slabs Required: ${takeoffs.stone.slabsNeeded || Math.ceil(takeoffs.stone.totalSqft * 1.2 / 55)}\n`;
        text += `Net Area: ${takeoffs.stone.totalSqft.toFixed(1)} SF\n`;
        text += `Gross (w/ waste): ${(takeoffs.stone.totalSqft * 1.2).toFixed(1)} SF\n`;
        text += `Edge LF: ${takeoffs.stone.edgeLF?.toFixed(1) || '0'} LF\n`;

        if (materialsList.length > 0) {
          text += `\nMaterials:\n`;
          materialsList.forEach(m => {
            text += `   ${m.name} (${m.brand || 'N/A'}): ${m.totalSqft.toFixed(1)} SF`;
            if (m.pricePerSF > 0) text += ` @ $${m.pricePerSF.toFixed(2)}/SF = $${m.totalCost.toFixed(2)}`;
            text += `\n`;
          });
        }

        if (takeoffs.stone.cutouts.length > 0) {
          text += `\nCutouts:\n`;
          takeoffs.stone.cutouts.forEach(c => {
            text += `   ${c.label || c.type} (${c.subtype || c.type})\n`;
          });
        }
        text += `\n`;
      }

      // Cabinets section
      if (takeoffs.cabinets.totalCount > 0) {
        text += `CABINETS\n`;
        text += `-`.repeat(30) + `\n`;
        text += `Total Units: ${takeoffs.cabinets.totalCount}\n`;
        text += `Total Linear Feet: ${takeoffs.cabinets.totalLF.toFixed(1)} LF\n`;

        if (takeoffs.cabinets.baseSummary.length > 0) {
          text += `\nBase Cabinets:\n`;
          takeoffs.cabinets.baseSummary.forEach(c => {
            text += `   B${c.width}" x ${c.count}\n`;
          });
        }
        if (takeoffs.cabinets.wallSummary.length > 0) {
          text += `\nWall Cabinets:\n`;
          takeoffs.cabinets.wallSummary.forEach(c => {
            text += `   W${c.width}" x ${c.count}\n`;
          });
        }
        text += `\n`;
      }

      // Scribe & Filler section
      if (takeoffs.scribe.totalLF > 0 || takeoffs.filler.pieces.length > 0) {
        text += `SCRIBE & FILLER\n`;
        text += `-`.repeat(30) + `\n`;

        if (takeoffs.scribe.locations.length > 0) {
          text += `\nScribe Molding: ${takeoffs.scribe.totalLF.toFixed(1)} LF @ $${TAKEOFF_STANDARDS.scribe.pricePerLF}/LF\n`;
          takeoffs.scribe.locations.forEach(s => {
            text += `   ${s.wall} wall, ${s.side}: ${s.length.toFixed(1)} LF ($${(s.length * TAKEOFF_STANDARDS.scribe.pricePerLF).toFixed(2)})\n`;
          });
          text += `  Scribe Subtotal: $${(takeoffs.scribe.totalLF * TAKEOFF_STANDARDS.scribe.pricePerLF).toFixed(2)}\n`;
        }

        if (takeoffs.filler.pieces.length > 0) {
          text += `\nFiller Strips: ${takeoffs.filler.totalLF.toFixed(1)} LF @ $${TAKEOFF_STANDARDS.filler.pricePerLF}/LF\n`;
          takeoffs.filler.pieces.forEach(f => {
            text += `   ${f.wall} wall - ${f.location}: ${f.gapWidth}" gap  use ${f.recommendedFiller}" filler ($${(f.lengthFt * TAKEOFF_STANDARDS.filler.pricePerLF).toFixed(2)})\n`;
          });
          text += `  Filler Subtotal: $${(takeoffs.filler.totalLF * TAKEOFF_STANDARDS.filler.pricePerLF).toFixed(2)}\n`;
        }
        text += `\n`;
      }

      // Flooring section
      if (takeoffs.flooring.totalSqft > 0) {
        text += `FLOORING\n`;
        text += `-`.repeat(30) + `\n`;
        text += `Area: ${takeoffs.flooring.totalSqft.toFixed(1)} SF\n`;
        text += `With Waste: ${takeoffs.flooring.grossSqft?.toFixed(1) || (takeoffs.flooring.totalSqft * 1.15).toFixed(1)} SF\n`;
        text += `Boxes Needed: ${takeoffs.flooring.boxesNeeded || Math.ceil(takeoffs.flooring.totalSqft * 1.15 / 10)}\n\n`;
      }

      // Itemized cost summary
      const costs = {
        stoneMaterial: takeoffs.stone.totalMaterialCost || 0,
        edgeProfile: takeoffs.stone.totalEdgeCost || 0,
        sinkCutouts: takeoffs.plumbing.sinks.reduce((sum, s) => sum + (s.cutoutPrice || 0), 0),
        cooktopCutouts: takeoffs.stone.cutouts.filter(c => c.type === 'cooktop').length * TAKEOFF_STANDARDS.cooktopCutout.price,
        scribe: takeoffs.scribe.totalLF * TAKEOFF_STANDARDS.scribe.pricePerLF,
        filler: takeoffs.filler.totalLF * TAKEOFF_STANDARDS.filler.pricePerLF
      };
      const grandTotal = Object.values(costs).reduce((sum, c) => sum + c, 0);

      if (grandTotal > 0) {
        text += `${'='.repeat(50)}\n`;
        text += `COST BREAKDOWN\n`;
        text += `-`.repeat(30) + `\n`;
        if (costs.stoneMaterial > 0) text += `Stone Material:     $${costs.stoneMaterial.toFixed(2)}\n`;
        if (costs.edgeProfile > 0) text += `Edge Profile:       $${costs.edgeProfile.toFixed(2)}\n`;
        if (costs.sinkCutouts > 0) text += `Sink Cutouts:       $${costs.sinkCutouts.toFixed(2)}\n`;
        if (costs.cooktopCutouts > 0) text += `Cooktop Cutout:     $${costs.cooktopCutouts.toFixed(2)}\n`;
        if (costs.scribe > 0) text += `Scribe Molding:     $${costs.scribe.toFixed(2)}\n`;
        if (costs.filler > 0) text += `Filler Strips:      $${costs.filler.toFixed(2)}\n`;
        text += `-`.repeat(30) + `\n`;
        text += `TOTAL:              $${grandTotal.toFixed(2)}\n`;
        text += `(Excludes labor & installation)\n`;
      }

      navigator.clipboard.writeText(text).then(() => {
        showToast('Takeoff copied to clipboard!', 'success');
      }).catch(err => {
        console.error('Copy failed:', err);
        showToast('Failed to copy', 'error');
      });
    }

    // ===== MEASUREMENT FORMATTING =====
    // Format feet (decimal) to feet-inches-fractions string
    // Supports 1/16" precision
    function formatDimension(feet, showFractions = true) {
      const totalInches = feet * 12;
      const wholeInches = Math.floor(totalInches);
      const wholeFeet = Math.floor(wholeInches / 12);
      const remainingInches = wholeInches % 12;
      const fractionalInches = totalInches - wholeInches;

      // Convert to 16ths for fraction display
      const sixteenths = Math.round(fractionalInches * 16);

      // Simplify fraction
      let fractionStr = '';
      if (sixteenths > 0 && showFractions) {
        if (sixteenths === 16) {
          // Round up to next inch
          return formatDimension(feet + (1/192), showFractions);
        } else if (sixteenths === 8) {
          fractionStr = '';
        } else if (sixteenths === 4) {
          fractionStr = '';
        } else if (sixteenths === 12) {
          fractionStr = '';
        } else if (sixteenths % 2 === 0) {
          // Can simplify to eighths
          fractionStr = `${sixteenths/2}/8`;
        } else {
          fractionStr = `${sixteenths}/16`;
        }
      }

      // Build output string
      if (wholeFeet > 0 && remainingInches > 0) {
        return `${wholeFeet}'-${remainingInches}${fractionStr}"`;
      } else if (wholeFeet > 0 && fractionStr) {
        return `${wholeFeet}'-0${fractionStr}"`;
      } else if (wholeFeet > 0) {
        return `${wholeFeet}'-0"`;
      } else if (remainingInches > 0 || fractionStr) {
        return `${remainingInches}${fractionStr}"`;
      } else {
        return '0"';
      }
    }

    // Format dimensions as W  H
    function formatSize(widthFt, heightFt) {
      return `${formatDimension(widthFt)}  ${formatDimension(heightFt)}`;
    }

    // Calculate actual square footage accounting for L and U shapes
    function getElementSqft(el) {
      const w = el.width || 0;
      const h = el.height || 0;

      if (el.type === 'countertop-l') {
        // L-shaped: two arms meeting at corner
        const armW = el.armWidth || 2.17; // Default 26" countertop depth
        // Area = horizontal arm + vertical arm - corner overlap
        return armW * (w + h - armW);
      }

      if (el.type === 'countertop-u') {
        // U-shaped: back arm + two side arms
        const backDepth = h * 0.3;
        const sideWidth = w * 0.25;
        return (w * backDepth) + (2 * sideWidth * (h - backDepth));
      }

      // Standard rectangular
      return w * h;
    }

    // Parse dimension string back to feet (for input)
    // Accepts: "3'-6"", "3.5", "42"", "3' 6"", etc.
    function parseDimension(str) {
      if (typeof str === 'number') return str;
      str = str.toString().trim();

      // Already decimal feet
      if (/^[\d.]+$/.test(str)) {
        return parseFloat(str);
      }

      // Feet and inches: 3'-6" or 3' 6" or 3'6"
      const feetInchMatch = str.match(/(\d+)[''][\s-]*(\d+)?(?:\s*(\d+)\/(\d+))?[""]?/);
      if (feetInchMatch) {
        const feet = parseInt(feetInchMatch[1]) || 0;
        const inches = parseInt(feetInchMatch[2]) || 0;
        const fracNum = parseInt(feetInchMatch[3]) || 0;
        const fracDen = parseInt(feetInchMatch[4]) || 1;
        return feet + (inches + fracNum/fracDen) / 12;
      }

      // Just inches: 42" or 36"
      const inchMatch = str.match(/^(\d+)(?:\s*(\d+)\/(\d+))?[""]$/);
      if (inchMatch) {
        const inches = parseInt(inchMatch[1]) || 0;
        const fracNum = parseInt(inchMatch[2]) || 0;
        const fracDen = parseInt(inchMatch[3]) || 1;
        return (inches + fracNum/fracDen) / 12;
      }

      // Fallback
      return parseFloat(str) || 0;
    }

    // Round to nearest 1/16"
    function roundToSixteenth(feet) {
      const sixteenthsPerFoot = 12 * 16; // 192 sixteenths per foot
      return Math.round(feet * sixteenthsPerFoot) / sixteenthsPerFoot;
    }

    // ===== BUILDING CODE VALIDATION =====
    let validationIssues = [];
    let showWorkTriangle = false;

    // Find elements by type
    function findElementsByType(types) {
      if (!Array.isArray(types)) types = [types];
      return elements.filter(el => types.includes(el.type));
    }

    // Get element center point
    function getElementCenter(el) {
      return {
        x: el.x + (el.width * pixelsPerFoot) / 2,
        y: el.y + (el.height * pixelsPerFoot) / 2
      };
    }

    // Calculate distance between two elements (center to center)
    function getDistance(el1, el2) {
      const c1 = getElementCenter(el1);
      const c2 = getElementCenter(el2);
      const dx = (c2.x - c1.x) / pixelsPerFoot;
      const dy = (c2.y - c1.y) / pixelsPerFoot;
      return Math.sqrt(dx * dx + dy * dy);
    }

    // Get gap between two elements (edge to edge)
    function getGapBetween(el1, el2) {
      const r1 = {
        left: el1.x / pixelsPerFoot,
        right: (el1.x + el1.width * pixelsPerFoot) / pixelsPerFoot,
        top: el1.y / pixelsPerFoot,
        bottom: (el1.y + el1.height * pixelsPerFoot) / pixelsPerFoot
      };
      const r2 = {
        left: el2.x / pixelsPerFoot,
        right: (el2.x + el2.width * pixelsPerFoot) / pixelsPerFoot,
        top: el2.y / pixelsPerFoot,
        bottom: (el2.y + el2.height * pixelsPerFoot) / pixelsPerFoot
      };

      // Calculate gaps in each direction
      const gapX = Math.max(r1.left - r2.right, r2.left - r1.right, 0);
      const gapY = Math.max(r1.top - r2.bottom, r2.top - r1.bottom, 0);

      return Math.sqrt(gapX * gapX + gapY * gapY);
    }

    // Validate kitchen work triangle
    function validateWorkTriangle() {
      const issues = [];
      const sinks = findElementsByType('sink');
      const stoves = findElementsByType(['stove', 'range', 'cooktop']);
      const fridges = findElementsByType(['refrigerator', 'fridge']);

      if (sinks.length === 0 || stoves.length === 0 || fridges.length === 0) {
        return { valid: false, issues: [], triangle: null, message: 'Need sink, stove, and refrigerator for work triangle' };
      }

      const sink = sinks[0];
      const stove = stoves[0];
      const fridge = fridges[0];

      const leg1 = getDistance(sink, stove);
      const leg2 = getDistance(stove, fridge);
      const leg3 = getDistance(fridge, sink);
      const perimeter = leg1 + leg2 + leg3;

      const { legMin, legMax, perimeterMin, perimeterMax } = BUILDING_STANDARDS.WORK_TRIANGLE;

      // Check each leg
      if (leg1 < legMin) issues.push({ type: 'warning', message: `Sink-Stove: ${formatDimension(leg1)} (min ${formatDimension(legMin)})` });
      if (leg1 > legMax) issues.push({ type: 'warning', message: `Sink-Stove: ${formatDimension(leg1)} (max ${formatDimension(legMax)})` });
      if (leg2 < legMin) issues.push({ type: 'warning', message: `Stove-Fridge: ${formatDimension(leg2)} (min ${formatDimension(legMin)})` });
      if (leg2 > legMax) issues.push({ type: 'warning', message: `Stove-Fridge: ${formatDimension(leg2)} (max ${formatDimension(legMax)})` });
      if (leg3 < legMin) issues.push({ type: 'warning', message: `Fridge-Sink: ${formatDimension(leg3)} (min ${formatDimension(legMin)})` });
      if (leg3 > legMax) issues.push({ type: 'warning', message: `Fridge-Sink: ${formatDimension(leg3)} (max ${formatDimension(legMax)})` });

      // Check perimeter
      if (perimeter < perimeterMin) {
        issues.push({ type: 'error', message: `Triangle too small: ${formatDimension(perimeter)} (min ${formatDimension(perimeterMin)})` });
      }
      if (perimeter > perimeterMax) {
        issues.push({ type: 'error', message: `Triangle too large: ${formatDimension(perimeter)} (max ${formatDimension(perimeterMax)})` });
      }

      return {
        valid: issues.length === 0,
        issues,
        triangle: { sink, stove, fridge, leg1, leg2, leg3, perimeter },
        message: issues.length === 0 ? 'Work triangle OK' : `${issues.length} issue(s)`
      };
    }

    // Validate clearances between elements
    function validateClearances() {
      const issues = [];
      const { walkway, islandWalkway, applianceOpen } = BUILDING_STANDARDS.CLEARANCES;

      // Check island clearances
      const islands = findElementsByType('island');
      const counters = findElementsByType('countertop');
      const cabinets = findElementsByType(['base-cabinet', 'tall-cabinet']);

      islands.forEach(island => {
        // Check clearance to counters and cabinets
        [...counters, ...cabinets].forEach(other => {
          const gap = getGapBetween(island, other);
          if (gap > 0 && gap < islandWalkway) {
            issues.push({
              type: 'warning',
              message: `Island clearance: ${formatDimension(gap)} (min ${formatDimension(islandWalkway)})`,
              elements: [island, other]
            });
          }
        });
      });

      // Check walkway between parallel counters
      for (let i = 0; i < counters.length; i++) {
        for (let j = i + 1; j < counters.length; j++) {
          const gap = getGapBetween(counters[i], counters[j]);
          if (gap > 0 && gap < walkway) {
            issues.push({
              type: 'warning',
              message: `Counter gap: ${formatDimension(gap)} (min ${formatDimension(walkway)})`,
              elements: [counters[i], counters[j]]
            });
          }
        }
      }

      // Check appliance clearances
      const appliances = findElementsByType(['stove', 'refrigerator', 'dishwasher', 'oven']);
      appliances.forEach(app => {
        // Check for adequate space in front (simplified - check distance to facing elements)
        const facing = [...islands, ...counters].filter(other => {
          const gap = getGapBetween(app, other);
          return gap > 0 && gap < applianceOpen;
        });

        facing.forEach(other => {
          const gap = getGapBetween(app, other);
          issues.push({
            type: 'info',
            message: `${app.label} front clearance: ${formatDimension(gap)} (rec. ${formatDimension(applianceOpen)})`,
            elements: [app, other]
          });
        });
      });

      return issues;
    }

    // Validate door clearances
    function validateDoorClearances() {
      const issues = [];
      const doors = findElementsByType(['door', 'double-door', 'entry-archway']);
      const allElements = elements.filter(el => !['door', 'double-door', 'entry-archway', 'window'].includes(el.type));

      doors.forEach(door => {
        allElements.forEach(other => {
          const gap = getGapBetween(door, other);
          if (gap > 0 && gap < BUILDING_STANDARDS.CLEARANCES.doorSwing) {
            issues.push({
              type: 'warning',
              message: `Door swing blocked: ${formatDimension(gap)} to ${other.label}`,
              elements: [door, other]
            });
          }
        });
      });

      return issues;
    }

    // Validate ADA bathroom requirements
    function validateADABathroom() {
      const issues = [];

      // ADA Standards
      const ADA = {
        toiletClearWidth: 5,          // 60" clear floor space width for wheelchair
        toiletClearDepth: 4.75,       // 57" clear floor space depth
        toiletCenterFromWall: 1.5,    // 18" from side wall to toilet centerline
        grabBarLength: 3.5,           // 42" minimum grab bar length
        showerMinSize: 3,             // 36"x36" minimum roll-in shower
        turningRadius: 5,             // 60" diameter turning space
        vanityKneeSpace: 2.25,        // 27" minimum knee clearance height
        vanityKneeDepth: 2,           // 25" knee clearance depth
        mirrorMaxHeight: 3.33,        // 40" maximum mirror bottom height
        doorMinWidth: 2.67            // 32" minimum clear door opening
      };

      // Find bathroom elements
      const toilets = elements.filter(el =>
        ['toilet', 'toilet-round', 'toilet-wall', 'bidet'].includes(el.type)
      );
      const showers = elements.filter(el =>
        el.type?.startsWith('shower') || el.type === 'bathtub-walk-in'
      );
      const vanities = elements.filter(el =>
        el.type?.startsWith('vanity-')
      );
      const grabBars = elements.filter(el =>
        el.type?.startsWith('grab-bar')
      );
      const doors = elements.filter(el =>
        ['door', 'double-door'].includes(el.type)
      );

      // Check toilet clearances
      toilets.forEach(toilet => {
        const toiletX = toilet.x / pixelsPerFoot;
        const toiletY = toilet.y / pixelsPerFoot;
        const toiletW = toilet.width;

        // Check for grab bars near toilet
        const nearbyGrabBars = grabBars.filter(bar => {
          const barX = bar.x / pixelsPerFoot;
          const barY = bar.y / pixelsPerFoot;
          const dist = Math.sqrt(Math.pow(barX - toiletX, 2) + Math.pow(barY - toiletY, 2));
          return dist < 3; // Within 3 feet
        });

        if (nearbyGrabBars.length === 0) {
          issues.push({
            type: 'warning',
            message: `ADA: No grab bars near "${toilet.label}" - recommend 42" side bar and 36" rear bar`,
            elements: [toilet]
          });
        }

        // Check distance from side wall (should be 18" to centerline)
        if (toiletX < ADA.toiletCenterFromWall - 0.5) {
          issues.push({
            type: 'info',
            message: `ADA: "${toilet.label}" is ${formatDimension(toiletX)} from wall (ADA requires 18" min to centerline)`,
            elements: [toilet]
          });
        }
      });

      // Check shower size for roll-in accessibility
      showers.forEach(shower => {
        const showerW = shower.width;
        const showerD = shower.height;

        if (showerW < ADA.showerMinSize || showerD < ADA.showerMinSize) {
          issues.push({
            type: 'info',
            message: `ADA: "${shower.label}" is ${formatDimension(showerW)}x${formatDimension(showerD)} (ADA roll-in min: 36"x36")`,
            elements: [shower]
          });
        }

        // Check for shower bench
        const nearbyBenches = elements.filter(el =>
          el.type === 'shower-bench' &&
          Math.abs(el.x / pixelsPerFoot - shower.x / pixelsPerFoot) < shower.width + 1
        );

        if (nearbyBenches.length === 0 && (showerW >= ADA.showerMinSize || showerD >= ADA.showerMinSize)) {
          issues.push({
            type: 'info',
            message: `ADA: Consider adding shower bench to "${shower.label}" for accessibility`,
            elements: [shower]
          });
        }
      });

      // Check door width for wheelchair access
      doors.forEach(door => {
        if (door.width < ADA.doorMinWidth) {
          issues.push({
            type: 'warning',
            message: `ADA: "${door.label}" width ${formatDimension(door.width)} (min 32" clear opening required)`,
            elements: [door]
          });
        }
      });

      // Check for 60" turning radius
      // Simplified: check if room has enough open floor space
      const totalFloorArea = roomWidth * roomDepth;
      const usedArea = elements.reduce((sum, el) => sum + (el.width * el.height), 0);
      const openArea = totalFloorArea - usedArea;

      if (openArea < ADA.turningRadius * ADA.turningRadius) {
        issues.push({
          type: 'info',
          message: `ADA: Limited open floor space - ensure 60" turning radius available`,
          elements: []
        });
      }

      return issues;
    }

    // Validate wall cabinet placement per NKBA standards
    function validateWallCabinetPlacement() {
      const issues = [];
      // Find all wall cabinets including sized variants (wall-cabinet-12, wall-cabinet-18, etc.)
      const wallCabinets = elements.filter(el =>
        el.type === 'wall-cabinet' || (el.type && el.type.startsWith('wall-cabinet-'))
      );
      // Find all base cabinets including sized variants
      const baseCabinets = elements.filter(el =>
        ['base-cabinet', 'drawer-base', 'sink-base'].includes(el.type) ||
        (el.type && (el.type.startsWith('base-cabinet-') || el.type.startsWith('drawer-base-') || el.type.startsWith('sink-base-')))
      );
      const countertops = elements.filter(el =>
        ['countertop', 'countertop-l', 'countertop-corner', 'countertop-u'].includes(el.type)
      );
      const backsplashes = elements.filter(el => el.type === 'backsplash');

      // NKBA Standards for wall cabinet placement
      const minClearanceAboveCounter = 1.25;  // 15" minimum clearance
      const standardClearance = 1.5;          // 18" standard clearance
      const maxClearance = 1.75;              // 21" maximum for accessibility
      const standardWallCabBottom = BUILDING_STANDARDS.HEIGHTS?.wallCabBottom || 4.5; // 54" from floor
      const standardCounterHeight = BUILDING_STANDARDS.HEIGHTS?.baseCounter || 3; // 36" counter

      wallCabinets.forEach(wallCab => {
        const wcLeft = wallCab.x / pixelsPerFoot;
        const wcRight = wcLeft + wallCab.width;

        // Check for base cabinet alignment below
        let hasBaseCabinetBelow = false;
        let baseDepthMismatch = false;

        baseCabinets.forEach(baseCab => {
          const bcLeft = baseCab.x / pixelsPerFoot;
          const bcRight = bcLeft + baseCab.width;

          // Check for horizontal overlap
          const overlapX = Math.max(0, Math.min(wcRight, bcRight) - Math.max(wcLeft, bcLeft));
          if (overlapX > 0.5) {
            hasBaseCabinetBelow = true;

            // Check if wall cabinet width matches base cabinet width (alignment)
            const widthDiff = Math.abs(wallCab.width - baseCab.width);
            if (widthDiff > 0.1) {
              issues.push({
                type: 'info',
                message: `Wall cabinet "${wallCab.label}" width (${formatDimension(wallCab.width)}) differs from base cabinet (${formatDimension(baseCab.width)})`,
                elements: [wallCab, baseCab]
              });
            }

            // Check depth alignment - wall cabinet should be aligned at wall, not front
            const baseCabDepth = baseCab.height; // 2D height = 3D depth
            const wallCabDepth = wallCab.height;
            const baseBack = baseCab.y / pixelsPerFoot;
            const wallBack = wallCab.y / pixelsPerFoot;

            // Wall cabinet back should align with base cabinet back (both against wall)
            if (Math.abs(baseBack - wallBack) > 0.5) {
              baseDepthMismatch = true;
              issues.push({
                type: 'warning',
                message: `Wall cabinet "${wallCab.label}" not aligned at wall with base cabinet below`,
                elements: [wallCab, baseCab]
              });
            }
          }
        });

        // Check for countertop/backsplash clearance
        let hasBacksplashBelow = false;
        backsplashes.forEach(bs => {
          const bsLeft = bs.x / pixelsPerFoot;
          const bsRight = bsLeft + bs.width;
          const overlapX = Math.max(0, Math.min(wcRight, bsRight) - Math.max(wcLeft, bsLeft));
          if (overlapX > 0.5) {
            hasBacksplashBelow = true;
            const bsHeight = bs.verticalHeight || bs.wallHeight || 1.5;
            // Wall cabinet should sit just above backsplash
            // This is handled in get3DYPosition, but we can validate the design intent
            if (bsHeight > standardClearance) {
              issues.push({
                type: 'info',
                message: `Full-height backsplash (${formatDimension(bsHeight)}) under "${wallCab.label}" - cabinet will sit above it`,
                elements: [wallCab, bs]
              });
            }
          }
        });

        // Check countertop clearance
        countertops.forEach(counter => {
          const ctLeft = counter.x / pixelsPerFoot;
          const ctRight = ctLeft + counter.width;
          const overlapX = Math.max(0, Math.min(wcRight, ctRight) - Math.max(wcLeft, ctLeft));
          if (overlapX > 0.5 && !hasBacksplashBelow) {
            // Standard clearance check (only if no backsplash)
            issues.push({
              type: 'info',
              message: `Wall cabinet "${wallCab.label}" positioned 18" above countertop (standard clearance)`,
              elements: [wallCab, counter]
            });
          }
        });

        // Warn if wall cabinet has no base cabinet below (floating)
        if (!hasBaseCabinetBelow && !hasBacksplashBelow) {
          issues.push({
            type: 'info',
            message: `Wall cabinet "${wallCab.label}" has no base cabinet directly below`,
            elements: [wallCab]
          });
        }

        // Check wall cabinet height options (30", 36", 42" standard)
        const wallCabHeight = get3DHeight(wallCab);
        const standardHeights = [2.5, 3, 3.5]; // 30", 36", 42" in feet
        const isStandardHeight = standardHeights.some(h => Math.abs(wallCabHeight - h) < 0.1);
        if (!isStandardHeight && wallCabHeight > 0) {
          issues.push({
            type: 'info',
            message: `Wall cabinet "${wallCab.label}" height (${formatDimension(wallCabHeight)}) is non-standard (standard: 30", 36", 42")`,
            elements: [wallCab]
          });
        }
      });

      return issues;
    }

    // Validate appliance landing space requirements per NKBA
    function validateLandingSpaces() {
      const issues = [];

      // NKBA Landing Space Requirements:
      // - Cooktop/Range: 15" (1.25') on each side, 12" (1') min on one side
      // - Sink: 24" (2') on one side, 18" (1.5') on other side
      // - Refrigerator: 15" (1.25') on handle side
      // - Microwave: 15" (1.25') above or beside
      // - Dishwasher: counter landing within 24" (2') of dishwasher

      const countertops = elements.filter(el =>
        ['countertop', 'countertop-l', 'countertop-corner', 'countertop-u'].includes(el.type)
      );

      // Helper: Check if there's counter space adjacent to an appliance
      function getAdjacentCounterSpace(appliance, side) {
        const appLeft = appliance.x / pixelsPerFoot;
        const appRight = appLeft + appliance.width;
        const appTop = appliance.y / pixelsPerFoot;
        const appBottom = appTop + appliance.height;

        let maxSpace = 0;

        countertops.forEach(counter => {
          const cLeft = counter.x / pixelsPerFoot;
          const cRight = cLeft + counter.width;
          const cTop = counter.y / pixelsPerFoot;
          const cBottom = cTop + counter.height;

          // Check vertical alignment (countertops should be adjacent in Y)
          const verticalOverlap = Math.max(0, Math.min(appBottom, cBottom) - Math.max(appTop, cTop));
          if (verticalOverlap < 0.5) return; // Not aligned vertically

          if (side === 'left') {
            // Counter to the left of appliance
            if (cRight >= appLeft - 0.1 && cRight <= appLeft + 0.5) {
              maxSpace = Math.max(maxSpace, counter.width);
            }
          } else if (side === 'right') {
            // Counter to the right of appliance
            if (cLeft <= appRight + 0.1 && cLeft >= appRight - 0.5) {
              maxSpace = Math.max(maxSpace, counter.width);
            }
          } else if (side === 'any') {
            // Counter on either side
            if (cRight >= appLeft - 0.1 && cRight <= appLeft + 0.5) {
              maxSpace = Math.max(maxSpace, counter.width);
            }
            if (cLeft <= appRight + 0.1 && cLeft >= appRight - 0.5) {
              maxSpace = Math.max(maxSpace, counter.width);
            }
          }
        });

        return maxSpace;
      }

      // Check cooktops and ranges
      const cookingAppliances = elements.filter(el =>
        ['cooktop', 'range', 'stove', 'slide-in-range', 'grill-builtin', 'grill-42'].includes(el.type)
      );

      cookingAppliances.forEach(appliance => {
        const leftSpace = getAdjacentCounterSpace(appliance, 'left');
        const rightSpace = getAdjacentCounterSpace(appliance, 'right');

        const minOneSide = 1;     // 12" minimum one side
        const preferredSide = 1.25; // 15" preferred each side

        if (leftSpace < minOneSide && rightSpace < minOneSide) {
          issues.push({
            type: 'error',
            message: `${appliance.label || appliance.type}: No landing space (min 12" required on at least one side)`,
            elements: [appliance]
          });
        } else if (leftSpace < preferredSide || rightSpace < preferredSide) {
          const lesserSide = Math.min(leftSpace, rightSpace);
          if (lesserSide < minOneSide) {
            issues.push({
              type: 'warning',
              message: `${appliance.label || appliance.type}: Only ${formatDimension(Math.max(leftSpace, rightSpace))} landing (15" each side recommended)`,
              elements: [appliance]
            });
          }
        }
      });

      // Check sinks
      const sinks = elements.filter(el =>
        ['sink', 'sink-double', 'sink-farmhouse'].includes(el.type)
      );

      sinks.forEach(sink => {
        const leftSpace = getAdjacentCounterSpace(sink, 'left');
        const rightSpace = getAdjacentCounterSpace(sink, 'right');

        const preferredOneSide = 2;   // 24" on one side
        const preferredOtherSide = 1.5; // 18" on other side

        if (leftSpace < 1 && rightSpace < 1) {
          issues.push({
            type: 'error',
            message: `${sink.label || 'Sink'}: No counter landing space (24" + 18" required)`,
            elements: [sink]
          });
        } else {
          const maxSide = Math.max(leftSpace, rightSpace);
          const minSide = Math.min(leftSpace, rightSpace);

          if (maxSide < preferredOneSide) {
            issues.push({
              type: 'warning',
              message: `${sink.label || 'Sink'}: Landing ${formatDimension(maxSide)} (24" recommended on one side)`,
              elements: [sink]
            });
          } else if (minSide < preferredOtherSide && minSide > 0) {
            issues.push({
              type: 'info',
              message: `${sink.label || 'Sink'}: Secondary landing ${formatDimension(minSide)} (18" recommended)`,
              elements: [sink]
            });
          }
        }
      });

      // Check refrigerators
      const refrigerators = elements.filter(el =>
        ['refrigerator', 'outdoor-fridge'].includes(el.type)
      );

      refrigerators.forEach(fridge => {
        const anySpace = getAdjacentCounterSpace(fridge, 'any');

        if (anySpace < 1.25) {
          issues.push({
            type: 'warning',
            message: `${fridge.label || 'Refrigerator'}: Landing ${formatDimension(anySpace)} (15" recommended at handle side)`,
            elements: [fridge]
          });
        }
      });

      // Check dishwashers - need counter within 24" for unloading
      const dishwashers = elements.filter(el => el.type === 'dishwasher');

      dishwashers.forEach(dw => {
        const anySpace = getAdjacentCounterSpace(dw, 'any');

        if (anySpace < 1.5) {
          issues.push({
            type: 'warning',
            message: `${dw.label || 'Dishwasher'}: Limited landing space for unloading`,
            elements: [dw]
          });
        }

        // Check if near sink (dishwasher should be within 36" of sink)
        const dwCenter = {
          x: dw.x / pixelsPerFoot + dw.width / 2,
          y: dw.y / pixelsPerFoot + dw.height / 2
        };

        let nearestSinkDist = Infinity;
        sinks.forEach(sink => {
          const sinkCenter = {
            x: sink.x / pixelsPerFoot + sink.width / 2,
            y: sink.y / pixelsPerFoot + sink.height / 2
          };
          const dist = Math.sqrt(
            Math.pow(dwCenter.x - sinkCenter.x, 2) +
            Math.pow(dwCenter.y - sinkCenter.y, 2)
          );
          nearestSinkDist = Math.min(nearestSinkDist, dist);
        });

        if (nearestSinkDist > 3 && sinks.length > 0) {
          issues.push({
            type: 'info',
            message: `${dw.label || 'Dishwasher'}: ${formatDimension(nearestSinkDist)} from sink (36" max recommended)`,
            elements: [dw]
          });
        }
      });

      return issues;
    }

    // Validate electrical requirements per NEC (National Electrical Code)
    function validateElectrical() {
      const issues = [];

      // NEC Kitchen Requirements:
      // - Countertop outlets: every 4' (48") of counter space, max 24" from any point
      // - GFCI protection within 6' of water sources
      // - Dedicated circuits for major appliances
      // - No outlets above stovetop

      const NEC = {
        maxOutletSpacing: 4,       // 48" maximum spacing between outlets
        maxDistToOutlet: 2,        // 24" maximum distance to nearest outlet
        gfciWaterDistance: 6,      // 6' GFCI zone near water
        minOutletsPerCounter: 1    // At least one outlet per counter section
      };

      // Find elements
      const countertops = elements.filter(el =>
        ['countertop', 'countertop-l', 'countertop-corner', 'countertop-u'].includes(el.type)
      );
      const outlets = elements.filter(el =>
        ['outlet', 'outlet-gfci', 'electrical-outlet'].includes(el.type)
      );
      const sinks = elements.filter(el =>
        ['sink', 'sink-double', 'sink-farmhouse', 'utility-sink', 'laundry-sink', 'outdoor-sink'].includes(el.type)
      );
      const stoves = elements.filter(el =>
        ['stove', 'range', 'cooktop', 'grill-builtin'].includes(el.type)
      );

      // Check counter outlet coverage
      countertops.forEach(counter => {
        const counterW = counter.width;
        const counterX = counter.x / pixelsPerFoot;

        // Calculate required outlets based on counter length
        const requiredOutlets = Math.ceil(counterW / NEC.maxOutletSpacing);

        // Find outlets near this counter
        const counterOutlets = outlets.filter(outlet => {
          const outletX = outlet.x / pixelsPerFoot;
          const outletY = outlet.y / pixelsPerFoot;
          const counterY = counter.y / pixelsPerFoot;

          // Check if outlet is at back of counter (within backsplash area)
          return outletX >= counterX &&
                 outletX <= counterX + counterW &&
                 Math.abs(outletY - counterY) < 1.5; // Within 18" of counter back
        });

        if (counterOutlets.length < requiredOutlets) {
          issues.push({
            type: 'warning',
            message: `NEC: Counter "${counter.label}" (${formatDimension(counterW)}) needs ${requiredOutlets} outlet(s), has ${counterOutlets.length}`,
            elements: [counter]
          });
        }
      });

      // Check GFCI near water sources
      sinks.forEach(sink => {
        const sinkX = sink.x / pixelsPerFoot;
        const sinkY = sink.y / pixelsPerFoot;

        // Find outlets within GFCI zone
        const nearbyOutlets = outlets.filter(outlet => {
          const outletX = outlet.x / pixelsPerFoot;
          const outletY = outlet.y / pixelsPerFoot;
          const dist = Math.sqrt(Math.pow(outletX - sinkX, 2) + Math.pow(outletY - sinkY, 2));
          return dist < NEC.gfciWaterDistance;
        });

        // Check if any nearby outlets are non-GFCI
        const nonGfci = nearbyOutlets.filter(o => o.type !== 'outlet-gfci');
        if (nonGfci.length > 0) {
          issues.push({
            type: 'warning',
            message: `NEC: Outlet(s) within 6' of "${sink.label}" require GFCI protection`,
            elements: [sink, ...nonGfci]
          });
        }
      });

      // Check for outlets above stovetop (not allowed)
      stoves.forEach(stove => {
        const stoveX = stove.x / pixelsPerFoot;
        const stoveW = stove.width;
        const stoveY = stove.y / pixelsPerFoot;

        const outletsAbove = outlets.filter(outlet => {
          const outletX = outlet.x / pixelsPerFoot;
          const outletY = outlet.y / pixelsPerFoot;

          return outletX >= stoveX - 0.5 &&
                 outletX <= stoveX + stoveW + 0.5 &&
                 outletY < stoveY + 0.5; // Outlet above/behind stove
        });

        if (outletsAbove.length > 0) {
          issues.push({
            type: 'error',
            message: `NEC: Outlet above "${stove.label}" is not permitted (fire hazard)`,
            elements: [stove, ...outletsAbove]
          });
        }
      });

      return issues;
    }

    // Run all validations
    function runValidation() {
      validationIssues = [];

      // Work triangle
      const triangleResult = validateWorkTriangle();
      if (triangleResult.issues.length > 0) {
        validationIssues.push(...triangleResult.issues.map(i => ({
          ...i,
          category: 'Work Triangle'
        })));
      }

      // Clearances
      const clearanceIssues = validateClearances();
      validationIssues.push(...clearanceIssues.map(i => ({
        ...i,
        category: 'Clearances'
      })));

      // Door clearances
      const doorIssues = validateDoorClearances();
      validationIssues.push(...doorIssues.map(i => ({
        ...i,
        category: 'Door Swing'
      })));

      // Wall cabinet placement (NKBA standards)
      const wallCabIssues = validateWallCabinetPlacement();
      validationIssues.push(...wallCabIssues.map(i => ({
        ...i,
        category: 'Cabinet Placement'
      })));

      // Appliance landing spaces (NKBA requirements)
      const landingIssues = validateLandingSpaces();
      validationIssues.push(...landingIssues.map(i => ({
        ...i,
        category: 'Landing Spaces'
      })));

      // ADA bathroom compliance (accessibility)
      const adaIssues = validateADABathroom();
      validationIssues.push(...adaIssues.map(i => ({
        ...i,
        category: 'ADA Accessibility'
      })));

      // NEC electrical requirements
      const electricalIssues = validateElectrical();
      validationIssues.push(...electricalIssues.map(i => ({
        ...i,
        category: 'Electrical (NEC)'
      })));

      updateValidationPanel();
      return validationIssues;
    }

    // Update the validation panel UI
    function updateValidationPanel() {
      const panel = document.getElementById('validationPanel');
      if (!panel) return;

      const content = document.getElementById('validationContent');
      if (!content) return;

      if (validationIssues.length === 0) {
        content.innerHTML = '<div class="validation-ok"> No issues found</div>';
        return;
      }

      // Group by category
      const grouped = {};
      validationIssues.forEach(issue => {
        if (!grouped[issue.category]) grouped[issue.category] = [];
        grouped[issue.category].push(issue);
      });

      content.innerHTML = Object.entries(grouped).map(([category, issues]) => `
        <div class="validation-category">
          <div class="validation-category-title">${category}</div>
          ${issues.map(issue => `
            <div class="validation-issue validation-${issue.type}">
              <span class="validation-icon">${issue.type === 'error' ? '' : issue.type === 'warning' ? '' : ''}</span>
              <span class="validation-message">${issue.message}</span>
            </div>
          `).join('')}
        </div>
      `).join('');
    }

    // Draw work triangle on canvas
    function drawWorkTriangle() {
      if (!showWorkTriangle) return;

      const result = validateWorkTriangle();
      if (!result.triangle) return;

      const { sink, stove, fridge, leg1, leg2, leg3 } = result.triangle;

      ctx.save();
      ctx.setLineDash([10, 5]);
      ctx.lineWidth = 2;
      ctx.strokeStyle = result.valid ? 'rgba(34, 197, 94, 0.7)' : 'rgba(239, 68, 68, 0.7)';
      ctx.fillStyle = result.valid ? 'rgba(34, 197, 94, 0.1)' : 'rgba(239, 68, 68, 0.1)';

      const c1 = getElementCenter(sink);
      const c2 = getElementCenter(stove);
      const c3 = getElementCenter(fridge);

      // Draw triangle
      ctx.beginPath();
      ctx.moveTo(c1.x, c1.y);
      ctx.lineTo(c2.x, c2.y);
      ctx.lineTo(c3.x, c3.y);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();

      // Draw leg labels
      ctx.setLineDash([]);
      ctx.font = 'bold 11px Inter';
      ctx.fillStyle = result.valid ? '#22c55e' : '#ef4444';
      ctx.textAlign = 'center';

      // Leg 1 (sink-stove)
      const mid1 = { x: (c1.x + c2.x) / 2, y: (c1.y + c2.y) / 2 };
      ctx.fillText(formatDimension(leg1), mid1.x, mid1.y - 8);

      // Leg 2 (stove-fridge)
      const mid2 = { x: (c2.x + c3.x) / 2, y: (c2.y + c3.y) / 2 };
      ctx.fillText(formatDimension(leg2), mid2.x, mid2.y - 8);

      // Leg 3 (fridge-sink)
      const mid3 = { x: (c3.x + c1.x) / 2, y: (c3.y + c1.y) / 2 };
      ctx.fillText(formatDimension(leg3), mid3.x, mid3.y - 8);

      ctx.restore();
    }

    // Snap to standard dimension
    function snapToStandard(value, type = 'width') {
      const standards = type === 'width' ? SNAP_DIMENSIONS.widths : SNAP_DIMENSIONS.depths;
      const tolerance = SNAP_DIMENSIONS.tolerance;

      for (const std of standards) {
        if (Math.abs(value - std) <= tolerance) {
          return std;
        }
      }
      return value;
    }

    // Get suggested standard size for element type
    function getSuggestedSize(elementType) {
      switch (elementType) {
        case 'door':
          return { width: 3, height: 0.5, note: "Standard 36\" door" };
        case 'double-door':
          return { width: 5, height: 0.5, note: "Standard 60\" double door" };
        case 'sliding-door':
          return { width: 6, height: 0.5, note: "Standard 72\" slider" };
        case 'window':
          return { width: 3, height: 0.5, note: "Standard 36\" window" };
        case 'base-cabinet':
          return { width: 2, height: 2, note: "Standard 24\" base cabinet" };
        case 'wall-cabinet':
          return { width: 2.5, height: 1, note: "Standard 30\" wall cabinet" };
        case 'tall-cabinet':
          return { width: 2, height: 2, note: "Standard 24\" pantry" };
        case 'fridge-cabinet':
          return { width: 3, height: 7, note: "Enclosure for 36\" fridge" };
        case 'island':
          return { width: 4, height: 2.5, note: "Minimum island size" };
        case 'countertop':
          return { width: 3, height: 2.083, note: "Standard 25\" depth" };
        default:
          return null;
      }
    }

    // SVG icons for element thumbnails (single-line for reliability)
    const ELEMENT_ICONS = {
      'base-cabinet': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="12" width="40" height="32" rx="2" fill="#8B5A2B"/><rect x="6" y="14" width="17" height="28" rx="1" fill="#A0522D"/><rect x="25" y="14" width="17" height="28" rx="1" fill="#A0522D"/><rect x="8" y="16" width="13" height="24" rx="1" fill="#CD853F"/><rect x="27" y="16" width="13" height="24" rx="1" fill="#CD853F"/><rect x="19" y="24" width="2" height="8" rx="1" fill="#FFD700"/><rect x="35" y="24" width="2" height="8" rx="1" fill="#FFD700"/><rect x="4" y="44" width="40" height="4" fill="#2a2a2a"/></svg>',
      'wall-cabinet': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="8" width="40" height="24" rx="2" fill="#8B5A2B"/><rect x="6" y="10" width="17" height="20" rx="1" fill="#A0522D"/><rect x="25" y="10" width="17" height="20" rx="1" fill="#A0522D"/><rect x="8" y="12" width="13" height="16" rx="1" fill="#CD853F"/><rect x="27" y="12" width="13" height="16" rx="1" fill="#CD853F"/><rect x="19" y="18" width="2" height="6" rx="1" fill="#FFD700"/><rect x="35" y="18" width="2" height="6" rx="1" fill="#FFD700"/></svg>',
      'microwave-cabinet': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="4" width="40" height="40" rx="2" fill="#5C5040"/><rect x="6" y="6" width="36" height="10" rx="1" fill="#6B5D4D"/><rect x="8" y="8" width="32" height="6" rx="1" fill="#7A6B5A"/><rect x="6" y="18" width="36" height="16" rx="1" fill="#2a2a2a"/><rect x="8" y="20" width="24" height="12" fill="#1a1a1a"/><rect x="34" y="20" width="6" height="12" fill="#3a3a3a"/><circle cx="37" cy="24" r="1.5" fill="#444"/><circle cx="37" cy="28" r="1.5" fill="#444"/><rect x="6" y="36" width="36" height="6" rx="1" fill="#6B5D4D"/><rect x="20" y="38" width="8" height="2" rx="1" fill="#A0A0A0"/></svg>',
      'above-microwave-cabinet': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="4" width="40" height="16" rx="2" fill="#8B5A2B"/><rect x="6" y="6" width="36" height="12" rx="1" fill="#A0522D"/><rect x="8" y="8" width="32" height="8" rx="1" fill="#CD853F"/><rect x="20" y="10" width="8" height="2" rx="1" fill="#FFD700"/><rect x="4" y="24" width="40" height="20" rx="2" fill="#3a3a3a"/><rect x="6" y="26" width="26" height="16" rx="1" fill="#1a1a1a"/><rect x="8" y="28" width="22" height="12" fill="#222"/><rect x="34" y="28" width="8" height="12" rx="1" fill="#4a4a4a"/><circle cx="38" cy="32" r="1.5" fill="#666"/><circle cx="38" cy="38" r="1.5" fill="#666"/></svg>',
      'tall-cabinet': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="10" y="2" width="28" height="44" rx="2" fill="#8B5A2B"/><rect x="12" y="4" width="24" height="18" rx="1" fill="#A0522D"/><rect x="12" y="24" width="24" height="20" rx="1" fill="#A0522D"/><rect x="14" y="6" width="20" height="14" rx="1" fill="#CD853F"/><rect x="14" y="26" width="20" height="16" rx="1" fill="#CD853F"/><rect x="32" y="11" width="2" height="6" rx="1" fill="#FFD700"/><rect x="32" y="32" width="2" height="6" rx="1" fill="#FFD700"/></svg>',
      'corner-cabinet': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><path d="M4 4 L4 44 L24 44 L24 24 L44 24 L44 4 Z" fill="#8B5A2B"/><path d="M6 6 L6 42 L22 42 L22 22 L42 22 L42 6 Z" fill="#A0522D"/><line x1="22" y1="22" x2="42" y2="42" stroke="#CD853F" stroke-width="2"/><circle cx="28" cy="28" r="8" fill="none" stroke="#CD853F" stroke-width="1.5"/><rect x="32" y="32" width="3" height="10" rx="1" fill="#FFD700" transform="rotate(45 33.5 37)"/><rect x="4" y="44" width="20" height="4" fill="#2a2a2a"/></svg>',
      'island': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="16" width="44" height="24" rx="2" fill="#8B5A2B"/><rect x="2" y="12" width="44" height="6" rx="1" fill="#708090"/><rect x="4" y="18" width="12" height="20" rx="1" fill="#CD853F"/><rect x="18" y="18" width="12" height="20" rx="1" fill="#CD853F"/><rect x="32" y="18" width="12" height="20" rx="1" fill="#CD853F"/><rect x="14" y="26" width="2" height="6" rx="1" fill="#FFD700"/><rect x="28" y="26" width="2" height="6" rx="1" fill="#FFD700"/><rect x="2" y="40" width="44" height="4" fill="#2a2a2a"/></svg>',
      'drawer-base': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="12" width="40" height="32" rx="2" fill="#8B5A2B"/><rect x="6" y="14" width="36" height="7" rx="1" fill="#CD853F"/><rect x="6" y="23" width="36" height="7" rx="1" fill="#CD853F"/><rect x="6" y="32" width="36" height="10" rx="1" fill="#CD853F"/><rect x="20" y="16" width="8" height="2" rx="1" fill="#FFD700"/><rect x="20" y="25" width="8" height="2" rx="1" fill="#FFD700"/><rect x="20" y="35" width="8" height="2" rx="1" fill="#FFD700"/><rect x="4" y="44" width="40" height="4" fill="#2a2a2a"/></svg>',
      'sink-base': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="12" width="40" height="32" rx="2" fill="#8B5A2B"/><rect x="6" y="14" width="36" height="5" rx="1" fill="#A0522D"/><rect x="6" y="21" width="17" height="21" rx="1" fill="#CD853F"/><rect x="25" y="21" width="17" height="21" rx="1" fill="#CD853F"/><rect x="19" y="29" width="2" height="6" rx="1" fill="#FFD700"/><rect x="35" y="29" width="2" height="6" rx="1" fill="#FFD700"/><ellipse cx="24" cy="8" rx="12" ry="4" fill="#E0E0E0"/><ellipse cx="24" cy="8" rx="8" ry="2.5" fill="#808080"/><rect x="4" y="44" width="40" height="4" fill="#2a2a2a"/></svg>',
      'lazy-susan': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><path d="M4 4 L4 44 L24 44 L24 24 L44 24 L44 4 Z" fill="#8B5A2B"/><path d="M6 6 L6 42 L22 42 L22 22 L42 22 L42 6 Z" fill="#A0522D"/><circle cx="24" cy="24" r="10" fill="none" stroke="#CD853F" stroke-width="2"/><circle cx="24" cy="24" r="6" fill="none" stroke="#CD853F" stroke-width="1.5"/><circle cx="24" cy="24" r="2" fill="#CD853F"/><path d="M24 14 L26 18 L22 18 Z" fill="#FFD700"/><rect x="4" y="44" width="20" height="4" fill="#2a2a2a"/></svg>',
      'countertop': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="18" width="44" height="8" rx="1" fill="#708090"/><rect x="2" y="20" width="44" height="4" fill="#5a6a7a"/><circle cx="10" cy="22" r="2" fill="#8090a0"/><circle cx="24" cy="22" r="2" fill="#8090a0"/><circle cx="38" cy="22" r="2" fill="#8090a0"/><rect x="2" y="26" width="44" height="2" fill="#4a5a6a"/></svg>',
      'backsplash': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="8" width="40" height="32" fill="#D4AF37"/><rect x="4" y="8" width="10" height="10" fill="#E5C158" stroke="#B8860B"/><rect x="14" y="8" width="10" height="10" fill="#D4AF37" stroke="#B8860B"/><rect x="24" y="8" width="10" height="10" fill="#E5C158" stroke="#B8860B"/><rect x="34" y="8" width="10" height="10" fill="#D4AF37" stroke="#B8860B"/><rect x="4" y="18" width="10" height="10" fill="#D4AF37" stroke="#B8860B"/><rect x="14" y="18" width="10" height="10" fill="#E5C158" stroke="#B8860B"/><rect x="24" y="18" width="10" height="10" fill="#D4AF37" stroke="#B8860B"/><rect x="34" y="18" width="10" height="10" fill="#E5C158" stroke="#B8860B"/><rect x="4" y="28" width="10" height="10" fill="#E5C158" stroke="#B8860B"/><rect x="14" y="28" width="10" height="10" fill="#D4AF37" stroke="#B8860B"/><rect x="24" y="28" width="10" height="10" fill="#E5C158" stroke="#B8860B"/><rect x="34" y="28" width="10" height="10" fill="#D4AF37" stroke="#B8860B"/></svg>',
      'flooring': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="2" width="22" height="44" fill="#CD853F"/><rect x="24" y="2" width="22" height="44" fill="#DEB887"/><line x1="2" y1="13" x2="24" y2="13" stroke="#8B4513"/><line x1="2" y1="24" x2="24" y2="24" stroke="#8B4513"/><line x1="2" y1="35" x2="24" y2="35" stroke="#8B4513"/><line x1="24" y1="8" x2="46" y2="8" stroke="#8B4513"/><line x1="24" y1="19" x2="46" y2="19" stroke="#8B4513"/><line x1="24" y1="30" x2="46" y2="30" stroke="#8B4513"/><line x1="24" y1="41" x2="46" y2="41" stroke="#8B4513"/></svg>',
      'tile': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="2" width="14" height="14" fill="#E8E8E8" stroke="#CCC"/><rect x="17" y="2" width="14" height="14" fill="#F5F5F5" stroke="#CCC"/><rect x="32" y="2" width="14" height="14" fill="#E8E8E8" stroke="#CCC"/><rect x="2" y="17" width="14" height="14" fill="#F5F5F5" stroke="#CCC"/><rect x="17" y="17" width="14" height="14" fill="#E8E8E8" stroke="#CCC"/><rect x="32" y="17" width="14" height="14" fill="#F5F5F5" stroke="#CCC"/><rect x="2" y="32" width="14" height="14" fill="#E8E8E8" stroke="#CCC"/><rect x="17" y="32" width="14" height="14" fill="#F5F5F5" stroke="#CCC"/><rect x="32" y="32" width="14" height="14" fill="#E8E8E8" stroke="#CCC"/></svg>',
      'sink': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="16" width="40" height="24" rx="4" fill="#E0E0E0"/><rect x="8" y="20" width="32" height="16" rx="2" fill="#404040"/><ellipse cx="24" cy="28" rx="12" ry="6" fill="#505050"/><rect x="22" y="6" width="4" height="10" rx="2" fill="#C0C0C0"/><ellipse cx="24" cy="6" rx="3" ry="2" fill="#A0A0A0"/><circle cx="24" cy="28" r="2" fill="#303030"/></svg>',
      'sink-double': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="16" width="44" height="24" rx="4" fill="#E0E0E0"/><rect x="5" y="20" width="17" height="16" rx="2" fill="#404040"/><rect x="26" y="20" width="17" height="16" rx="2" fill="#404040"/><ellipse cx="13.5" cy="28" rx="6" ry="5" fill="#505050"/><ellipse cx="34.5" cy="28" rx="6" ry="5" fill="#505050"/><rect x="22" y="6" width="4" height="10" rx="2" fill="#C0C0C0"/><ellipse cx="24" cy="6" rx="3" ry="2" fill="#A0A0A0"/><circle cx="13.5" cy="28" r="1.5" fill="#303030"/><circle cx="34.5" cy="28" r="1.5" fill="#303030"/></svg>',
      'sink-farmhouse': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="14" width="40" height="28" rx="2" fill="#F5F5DC" stroke="#D4C8A8" stroke-width="2"/><rect x="6" y="16" width="36" height="24" fill="#FFFEF7"/><rect x="8" y="18" width="32" height="20" rx="1" fill="#404040"/><ellipse cx="24" cy="28" rx="12" ry="7" fill="#505050"/><rect x="22" y="4" width="4" height="12" rx="2" fill="#C0C0C0"/><ellipse cx="24" cy="4" rx="3" ry="2" fill="#A0A0A0"/><circle cx="24" cy="30" r="2" fill="#303030"/><path d="M4 20 L4 14 Q4 12 6 12 L42 12 Q44 12 44 14 L44 20" fill="none" stroke="#C9B896" stroke-width="2"/></svg>',
      'stove': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="8" width="40" height="36" rx="2" fill="#2a2a2a"/><rect x="6" y="10" width="36" height="16" rx="1" fill="#1a1a1a"/><circle cx="14" cy="18" r="5" fill="#333" stroke="#444" stroke-width="2"/><circle cx="34" cy="18" r="5" fill="#333" stroke="#444" stroke-width="2"/><rect x="8" y="28" width="32" height="14" rx="1" fill="#1a1a1a"/><rect x="12" y="30" width="24" height="10" rx="1" fill="#111"/></svg>',
      'refrigerator': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="8" y="2" width="32" height="44" rx="2" fill="#D0D0D0"/><rect x="10" y="4" width="28" height="14" rx="1" fill="#E0E0E0"/><rect x="10" y="20" width="28" height="24" rx="1" fill="#E0E0E0"/><rect x="34" y="8" width="2" height="6" rx="1" fill="#888"/><rect x="34" y="28" width="2" height="10" rx="1" fill="#888"/><line x1="10" y1="18" x2="38" y2="18" stroke="#999" stroke-width="2"/></svg>',
      'dishwasher': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="6" y="8" width="36" height="36" rx="2" fill="#A0A0A0"/><rect x="8" y="10" width="32" height="6" rx="1" fill="#606060"/><rect x="8" y="18" width="32" height="24" rx="1" fill="#B8B8B8"/><rect x="12" y="12" width="4" height="2" rx="1" fill="#888"/><rect x="18" y="12" width="4" height="2" rx="1" fill="#888"/><rect x="14" y="32" width="20" height="2" rx="1" fill="#909090"/></svg>',
      'microwave': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="12" width="40" height="24" rx="2" fill="#3a3a3a"/><rect x="6" y="14" width="26" height="20" rx="1" fill="#1a1a1a"/><rect x="8" y="16" width="22" height="16" rx="1" fill="#222"/><rect x="34" y="16" width="8" height="16" rx="1" fill="#4a4a4a"/><circle cx="38" cy="20" r="2" fill="#666"/><circle cx="38" cy="28" r="2" fill="#666"/></svg>',
      'range-hood': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><path d="M8 32 L16 12 L32 12 L40 32 Z" fill="#808080"/><rect x="6" y="32" width="36" height="8" rx="1" fill="#909090"/><rect x="20" y="4" width="8" height="8" fill="#707070"/><rect x="10" y="36" width="6" height="2" rx="1" fill="#606060"/><rect x="21" y="36" width="6" height="2" rx="1" fill="#606060"/><rect x="32" y="36" width="6" height="2" rx="1" fill="#606060"/></svg>',
      'oven': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="6" y="4" width="36" height="40" rx="2" fill="#2a2a2a"/><rect x="8" y="6" width="32" height="8" rx="1" fill="#3a3a3a"/><rect x="8" y="16" width="32" height="26" rx="1" fill="#1a1a1a"/><rect x="12" y="20" width="24" height="18" rx="1" fill="#222"/><rect x="14" y="8" width="20" height="4" rx="1" fill="#444"/></svg>',
      'door': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="8" y="4" width="32" height="40" rx="1" fill="#DEB887"/><rect x="10" y="6" width="12" height="16" rx="1" fill="#D2B48C"/><rect x="26" y="6" width="12" height="16" rx="1" fill="#D2B48C"/><rect x="10" y="26" width="12" height="16" rx="1" fill="#D2B48C"/><rect x="26" y="26" width="12" height="16" rx="1" fill="#D2B48C"/><circle cx="36" cy="26" r="2" fill="#FFD700"/></svg>',
      'double-door': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="4" width="18" height="40" rx="1" fill="#DEB887"/><rect x="26" y="4" width="18" height="40" rx="1" fill="#DEB887"/><rect x="6" y="8" width="14" height="32" rx="1" fill="#D2B48C"/><rect x="28" y="8" width="14" height="32" rx="1" fill="#D2B48C"/><circle cx="18" cy="26" r="2" fill="#FFD700"/><circle cx="30" cy="26" r="2" fill="#FFD700"/></svg>',
      'sliding-door': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="4" width="44" height="40" rx="1" fill="#BC8F8F"/><rect x="4" y="6" width="20" height="36" fill="#ADD8E6" opacity="0.6"/><rect x="24" y="6" width="20" height="36" fill="#ADD8E6" opacity="0.4"/><line x1="24" y1="6" x2="24" y2="42" stroke="#888" stroke-width="2"/><rect x="4" y="42" width="40" height="2" fill="#666"/></svg>',
      'entry-archway': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><path d="M4 44 L4 16 Q4 4 24 4 Q44 4 44 16 L44 44" fill="none" stroke="#DAA520" stroke-width="4"/><path d="M8 44 L8 18 Q8 8 24 8 Q40 8 40 18 L40 44" fill="#F5DEB3" opacity="0.3"/></svg>',
      'garage-door': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="4" width="44" height="40" rx="1" fill="#A9A9A9"/><rect x="4" y="6" width="40" height="8" fill="#888"/><rect x="4" y="16" width="40" height="8" fill="#999"/><rect x="4" y="26" width="40" height="8" fill="#888"/><rect x="4" y="36" width="40" height="6" fill="#999"/><rect x="20" y="38" width="8" height="2" fill="#666"/></svg>',
      'window': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="8" width="40" height="32" rx="2" fill="#FFF"/><rect x="6" y="10" width="17" height="13" fill="#87CEEB"/><rect x="25" y="10" width="17" height="13" fill="#87CEEB"/><rect x="6" y="25" width="17" height="13" fill="#87CEEB"/><rect x="25" y="25" width="17" height="13" fill="#87CEEB"/><line x1="24" y1="10" x2="24" y2="38" stroke="#FFF" stroke-width="2"/><line x1="6" y1="24" x2="42" y2="24" stroke="#FFF" stroke-width="2"/></svg>',
      'wall': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="4" width="40" height="8" fill="#666"/><rect x="4" y="14" width="18" height="8" fill="#555"/><rect x="24" y="14" width="20" height="8" fill="#555"/><rect x="4" y="24" width="40" height="8" fill="#666"/><rect x="4" y="34" width="18" height="8" fill="#555"/><rect x="24" y="34" width="20" height="8" fill="#555"/></svg>',
      'wall-wood-2x4': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="8" y="2" width="6" height="44" fill="#DEB887"/><rect x="20" y="2" width="6" height="44" fill="#DEB887"/><rect x="32" y="2" width="6" height="44" fill="#DEB887"/><rect x="6" y="10" width="36" height="4" fill="#D2B48C"/><rect x="6" y="32" width="36" height="4" fill="#D2B48C"/></svg>',
      'wall-wood-2x6': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="6" y="2" width="8" height="44" fill="#CD853F"/><rect x="20" y="2" width="8" height="44" fill="#CD853F"/><rect x="34" y="2" width="8" height="44" fill="#CD853F"/><rect x="4" y="10" width="40" height="5" fill="#DEB887"/><rect x="4" y="32" width="40" height="5" fill="#DEB887"/></svg>',
      'wall-steel': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="10" y="2" width="4" height="44" fill="#708090"/><rect x="22" y="2" width="4" height="44" fill="#708090"/><rect x="34" y="2" width="4" height="44" fill="#708090"/><rect x="8" y="8" width="32" height="3" fill="#A9A9A9"/><rect x="8" y="36" width="32" height="3" fill="#A9A9A9"/><circle cx="12" cy="10" r="2" fill="#666"/><circle cx="24" cy="10" r="2" fill="#666"/><circle cx="36" cy="10" r="2" fill="#666"/></svg>',
      'wall-aluminum': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="10" y="2" width="3" height="44" fill="#C0C0C0"/><rect x="22" y="2" width="3" height="44" fill="#C0C0C0"/><rect x="34" y="2" width="3" height="44" fill="#C0C0C0"/><rect x="8" y="6" width="32" height="2" fill="#D3D3D3"/><rect x="8" y="22" width="32" height="2" fill="#D3D3D3"/><rect x="8" y="38" width="32" height="2" fill="#D3D3D3"/></svg>',
      'wall-concrete': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="4" width="40" height="40" fill="#808080"/><circle cx="12" cy="12" r="2" fill="#696969"/><circle cx="28" cy="18" r="3" fill="#696969"/><circle cx="18" cy="32" r="2" fill="#696969"/><circle cx="36" cy="28" r="2" fill="#696969"/><circle cx="24" cy="38" r="2" fill="#696969"/></svg>',
      'wall-brick': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="4" width="10" height="6" fill="#B22222"/><rect x="14" y="4" width="10" height="6" fill="#B22222"/><rect x="26" y="4" width="10" height="6" fill="#B22222"/><rect x="38" y="4" width="8" height="6" fill="#B22222"/><rect x="2" y="12" width="5" height="6" fill="#CD5C5C"/><rect x="9" y="12" width="10" height="6" fill="#CD5C5C"/><rect x="21" y="12" width="10" height="6" fill="#CD5C5C"/><rect x="33" y="12" width="10" height="6" fill="#CD5C5C"/><rect x="2" y="20" width="10" height="6" fill="#B22222"/><rect x="14" y="20" width="10" height="6" fill="#B22222"/><rect x="26" y="20" width="10" height="6" fill="#B22222"/><rect x="38" y="20" width="8" height="6" fill="#B22222"/><rect x="2" y="28" width="5" height="6" fill="#CD5C5C"/><rect x="9" y="28" width="10" height="6" fill="#CD5C5C"/><rect x="21" y="28" width="10" height="6" fill="#CD5C5C"/><rect x="33" y="28" width="10" height="6" fill="#CD5C5C"/><rect x="2" y="36" width="10" height="6" fill="#B22222"/><rect x="14" y="36" width="10" height="6" fill="#B22222"/><rect x="26" y="36" width="10" height="6" fill="#B22222"/><rect x="38" y="36" width="8" height="6" fill="#B22222"/></svg>',
      'wall-block': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="4" width="14" height="10" fill="#696969" stroke="#555"/><rect x="18" y="4" width="14" height="10" fill="#696969" stroke="#555"/><rect x="34" y="4" width="12" height="10" fill="#696969" stroke="#555"/><rect x="2" y="16" width="14" height="10" fill="#787878" stroke="#555"/><rect x="18" y="16" width="14" height="10" fill="#787878" stroke="#555"/><rect x="34" y="16" width="12" height="10" fill="#787878" stroke="#555"/><rect x="2" y="28" width="14" height="10" fill="#696969" stroke="#555"/><rect x="18" y="28" width="14" height="10" fill="#696969" stroke="#555"/><rect x="34" y="28" width="12" height="10" fill="#696969" stroke="#555"/></svg>',
      'steel-beam': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="18" width="40" height="12" fill="#4A4A4A"/><rect x="4" y="18" width="40" height="3" fill="#5A5A5A"/><rect x="4" y="27" width="40" height="3" fill="#3A3A3A"/><rect x="4" y="22" width="40" height="4" fill="#606060"/></svg>',
      'steel-column': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="16" y="4" width="16" height="40" fill="#4A4A4A"/><rect x="16" y="4" width="4" height="40" fill="#5A5A5A"/><rect x="28" y="4" width="4" height="40" fill="#3A3A3A"/><rect x="20" y="4" width="8" height="40" fill="#555"/></svg>',
      'wood-beam': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="18" width="40" height="12" fill="#8B6914" rx="1"/><line x1="8" y1="20" x2="8" y2="28" stroke="#6B4914" stroke-width="1"/><line x1="18" y1="20" x2="18" y2="28" stroke="#6B4914" stroke-width="1"/><line x1="28" y1="20" x2="28" y2="28" stroke="#6B4914" stroke-width="1"/><line x1="38" y1="20" x2="38" y2="28" stroke="#6B4914" stroke-width="1"/></svg>',
      'wood-post': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="16" y="4" width="16" height="40" fill="#8B6914" rx="1"/><line x1="20" y1="8" x2="20" y2="40" stroke="#6B4914" stroke-width="1"/><line x1="24" y1="8" x2="24" y2="40" stroke="#6B4914" stroke-width="1"/><line x1="28" y1="8" x2="28" y2="40" stroke="#6B4914" stroke-width="1"/></svg>',
      'concrete-beam': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="16" width="40" height="16" fill="#707070"/><circle cx="12" cy="22" r="2" fill="#606060"/><circle cx="28" cy="26" r="2" fill="#606060"/><circle cx="38" cy="22" r="2" fill="#808080"/></svg>',
      'concrete-column': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="12" y="4" width="24" height="40" fill="#707070"/><circle cx="20" cy="14" r="2" fill="#606060"/><circle cx="28" cy="28" r="2" fill="#606060"/><circle cx="22" cy="38" r="2" fill="#808080"/></svg>',
      'header': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="18" width="40" height="12" fill="#CD853F" rx="1"/><line x1="4" y1="24" x2="44" y2="24" stroke="#8B6914" stroke-width="1"/><rect x="4" y="18" width="40" height="2" fill="#DEB887"/></svg>',
      'lvl-beam': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="14" width="40" height="20" fill="#DEB887"/><line x1="4" y1="18" x2="44" y2="18" stroke="#C4A76C" stroke-width="1"/><line x1="4" y1="22" x2="44" y2="22" stroke="#C4A76C" stroke-width="1"/><line x1="4" y1="26" x2="44" y2="26" stroke="#C4A76C" stroke-width="1"/><line x1="4" y1="30" x2="44" y2="30" stroke="#C4A76C" stroke-width="1"/></svg>',
      'surface-stainless': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="16" width="44" height="16" rx="1" fill="#C0C0C0"/><line x1="4" y1="20" x2="44" y2="20" stroke="#D8D8D8" stroke-width="1"/><line x1="4" y1="24" x2="44" y2="24" stroke="#D8D8D8" stroke-width="1"/><line x1="4" y1="28" x2="44" y2="28" stroke="#D8D8D8" stroke-width="1"/><rect x="2" y="16" width="44" height="3" fill="#E0E0E0"/><rect x="2" y="29" width="44" height="3" fill="#A0A0A0"/></svg>',
      'surface-solid': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="16" width="44" height="16" rx="2" fill="#E8E4E0"/><rect x="2" y="16" width="44" height="2" fill="#F0ECE8"/><rect x="2" y="30" width="44" height="2" fill="#D8D4D0"/></svg>',
      'surface-laminate': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="18" width="44" height="12" fill="#D4C4A8"/><rect x="2" y="16" width="44" height="3" fill="#E8D8BC"/><rect x="2" y="29" width="44" height="3" fill="#4A4A4A"/><line x1="12" y1="18" x2="12" y2="30" stroke="#C4B498" stroke-width="1"/><line x1="24" y1="18" x2="24" y2="30" stroke="#C4B498" stroke-width="1"/><line x1="36" y1="18" x2="36" y2="30" stroke="#C4B498" stroke-width="1"/></svg>',
      'surface-butcherblock': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="16" width="44" height="16" fill="#C4A76C"/><line x1="8" y1="16" x2="8" y2="32" stroke="#8B6914" stroke-width="1"/><line x1="14" y1="16" x2="14" y2="32" stroke="#8B6914" stroke-width="1"/><line x1="20" y1="16" x2="20" y2="32" stroke="#8B6914" stroke-width="1"/><line x1="26" y1="16" x2="26" y2="32" stroke="#8B6914" stroke-width="1"/><line x1="32" y1="16" x2="32" y2="32" stroke="#8B6914" stroke-width="1"/><line x1="38" y1="16" x2="38" y2="32" stroke="#8B6914" stroke-width="1"/><rect x="2" y="16" width="44" height="2" fill="#D4B77C"/></svg>',
      'surface-concrete': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="16" width="44" height="16" fill="#808080"/><circle cx="10" cy="22" r="2" fill="#707070"/><circle cx="28" cy="26" r="3" fill="#707070"/><circle cx="38" cy="20" r="2" fill="#909090"/><circle cx="18" cy="28" r="2" fill="#909090"/></svg>',
      'glass-door': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="8" y="4" width="32" height="40" rx="1" fill="#FFF"/><rect x="10" y="6" width="28" height="36" fill="#ADD8E6" opacity="0.5"/><rect x="12" y="8" width="24" height="32" fill="#87CEEB" opacity="0.3"/><rect x="34" y="20" width="2" height="10" rx="1" fill="#C0C0C0"/></svg>',
      'french-door': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="4" width="40" height="40" rx="1" fill="#F5F5DC"/><rect x="6" y="6" width="17" height="36" fill="#ADD8E6" opacity="0.4"/><rect x="25" y="6" width="17" height="36" fill="#ADD8E6" opacity="0.4"/><line x1="24" y1="6" x2="24" y2="42" stroke="#F5F5DC" stroke-width="3"/><line x1="6" y1="16" x2="23" y2="16" stroke="#F5F5DC" stroke-width="2"/><line x1="6" y1="28" x2="23" y2="28" stroke="#F5F5DC" stroke-width="2"/><line x1="25" y1="16" x2="42" y2="16" stroke="#F5F5DC" stroke-width="2"/><line x1="25" y1="28" x2="42" y2="28" stroke="#F5F5DC" stroke-width="2"/></svg>',
      'window-large': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="8" width="44" height="32" rx="2" fill="#FFF"/><rect x="4" y="10" width="40" height="28" fill="#87CEEB"/><rect x="4" y="26" width="40" height="12" fill="#90EE90" opacity="0.5"/></svg>',
      'window-bay': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><path d="M8 8 L18 4 L30 4 L40 8 L40 40 L8 40 Z" fill="#FFF"/><path d="M10 10 L17 6 L31 6 L38 10 L38 38 L10 38 Z" fill="#87CEEB"/><line x1="17" y1="6" x2="14" y2="38" stroke="#FFF" stroke-width="2"/><line x1="31" y1="6" x2="34" y2="38" stroke="#FFF" stroke-width="2"/></svg>',
      'crown-molding': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="18" width="44" height="12" fill="#F5F5F5"/><path d="M2 18 Q24 14 46 18" fill="none" stroke="#E0E0E0" stroke-width="2"/><line x1="2" y1="22" x2="46" y2="22" stroke="#DDD" stroke-width="1"/><line x1="2" y1="26" x2="46" y2="26" stroke="#DDD" stroke-width="1"/></svg>',
      'baseboard': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="28" width="44" height="16" fill="#F5F5F5"/><line x1="2" y1="32" x2="46" y2="32" stroke="#E0E0E0" stroke-width="1"/><line x1="2" y1="36" x2="46" y2="36" stroke="#E0E0E0" stroke-width="1"/><rect x="2" y="42" width="44" height="2" fill="#DDD"/></svg>',
      'chair-rail': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="20" width="44" height="8" fill="#F5F5F5"/><path d="M2 20 Q24 18 46 20" fill="none" stroke="#E8E8E8" stroke-width="1"/><line x1="2" y1="24" x2="46" y2="24" stroke="#DDD" stroke-width="1"/></svg>',
      'countertop-l': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><path d="M4 4 L4 44 L28 44 L28 24 L44 24 L44 4 Z" fill="#708090"/><path d="M6 6 L6 42 L26 42 L26 22 L42 22 L42 6 Z" fill="#5a6a7a"/></svg>',
      'countertop-u': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><path d="M4 4 L4 44 L44 44 L44 4 L34 4 L34 34 L14 34 L14 4 Z" fill="#708090"/><path d="M6 6 L6 42 L42 42 L42 6 L32 6 L32 32 L16 32 L16 6 Z" fill="#5a6a7a"/></svg>',
      // Pony Walls & Half Walls
      'pony-wall': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="20" width="40" height="24" fill="#888"/><rect x="2" y="18" width="44" height="4" fill="#708090" rx="1"/><rect x="4" y="44" width="40" height="2" fill="#666"/></svg>',
      'pony-wall-bar': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="16" width="40" height="28" fill="#888"/><rect x="2" y="14" width="44" height="4" fill="#708090" rx="1"/><rect x="0" y="12" width="48" height="4" fill="#5a6a7a" rx="1"/><rect x="4" y="44" width="40" height="2" fill="#666"/></svg>',
      'knee-wall': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="28" width="40" height="16" fill="#888"/><rect x="2" y="26" width="44" height="4" fill="#708090" rx="1"/><rect x="4" y="44" width="40" height="2" fill="#666"/></svg>',
      // Niches & Recesses
      'wall-niche': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="4" width="40" height="40" fill="#888"/><rect x="10" y="10" width="28" height="28" fill="#333"/><rect x="12" y="12" width="24" height="24" fill="#222"/></svg>',
      'fireplace-niche': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="8" width="40" height="36" fill="#888"/><rect x="8" y="12" width="32" height="28" fill="#333"/><rect x="10" y="14" width="28" height="24" fill="#1a1a1a"/><ellipse cx="24" cy="32" rx="8" ry="4" fill="#FF4500" opacity="0.8"/><ellipse cx="24" cy="30" rx="5" ry="3" fill="#FFD700" opacity="0.6"/></svg>',
      'tv-niche': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="8" width="40" height="32" fill="#888"/><rect x="8" y="12" width="32" height="24" fill="#222"/><rect x="10" y="14" width="28" height="20" fill="#1a1a1a"/><rect x="12" y="16" width="24" height="16" fill="#333" stroke="#444"/></svg>',
      'shower-niche': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="10" y="8" width="28" height="32" fill="#87CEEB"/><rect x="14" y="12" width="20" height="24" fill="#555"/><rect x="16" y="14" width="16" height="20" fill="#444"/><ellipse cx="24" cy="24" rx="4" ry="2" fill="#666"/></svg>',
      'grab-bar': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="20" width="40" height="8" rx="4" fill="#C0C0C0"/><circle cx="8" cy="24" r="5" fill="#888"/><circle cx="40" cy="24" r="5" fill="#888"/><rect x="8" y="21" width="32" height="2" fill="#E0E0E0"/></svg>',
      'grab-bar-24': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="8" y="20" width="32" height="8" rx="4" fill="#C0C0C0"/><circle cx="12" cy="24" r="5" fill="#888"/><circle cx="36" cy="24" r="5" fill="#888"/><rect x="12" y="21" width="24" height="2" fill="#E0E0E0"/><text x="24" y="40" font-size="8" fill="#666" text-anchor="middle">24"</text></svg>',
      'grab-bar-36': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="20" width="40" height="8" rx="4" fill="#C0C0C0"/><circle cx="8" cy="24" r="5" fill="#888"/><circle cx="40" cy="24" r="5" fill="#888"/><rect x="8" y="21" width="32" height="2" fill="#E0E0E0"/><text x="24" y="40" font-size="8" fill="#666" text-anchor="middle">36"</text></svg>',
      'grab-bar-42': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="20" width="44" height="8" rx="4" fill="#C0C0C0"/><circle cx="6" cy="24" r="5" fill="#888"/><circle cx="42" cy="24" r="5" fill="#888"/><rect x="6" y="21" width="36" height="2" fill="#E0E0E0"/><text x="24" y="40" font-size="8" fill="#666" text-anchor="middle">42"</text></svg>',
      // Stone Caps & Ledges
      'wall-cap': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="20" width="44" height="8" fill="#708090" rx="1"/><path d="M2 28 Q24 30 46 28" fill="#5a6a7a"/><rect x="4" y="26" width="40" height="16" fill="#aaa" opacity="0.3"/></svg>',
      'bar-top': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="18" width="44" height="6" fill="#708090" rx="1"/><path d="M2 24 Q24 26 46 24" fill="#5a6a7a"/><rect x="0" y="16" width="48" height="4" fill="#5a6a7a" rx="1"/><rect x="6" y="22" width="36" height="20" fill="#888" opacity="0.3"/></svg>',
      'niche-surround': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="4" width="8" height="40" fill="#708090"/><rect x="36" y="4" width="8" height="40" fill="#708090"/><rect x="4" y="4" width="40" height="8" fill="#708090"/><rect x="4" y="36" width="40" height="8" fill="#708090"/><rect x="12" y="12" width="24" height="24" fill="#333"/></svg>',
      'fireplace-surround': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="4" width="10" height="40" fill="#708090"/><rect x="36" y="4" width="10" height="40" fill="#708090"/><rect x="2" y="4" width="44" height="8" fill="#708090"/><rect x="2" y="36" width="44" height="8" fill="#5a6a7a"/><rect x="12" y="12" width="24" height="24" fill="#1a1a1a"/><ellipse cx="24" cy="30" rx="6" ry="3" fill="#FF4500" opacity="0.7"/></svg>',
      'fireplace-hearth': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="28" width="44" height="16" fill="#708090" rx="1"/><rect x="4" y="20" width="40" height="10" fill="#5a6a7a"/><path d="M2 44 Q24 46 46 44" fill="#4a5a6a"/></svg>',
      'mantel': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="18" width="44" height="6" fill="#8B4513" rx="1"/><rect x="6" y="24" width="6" height="16" fill="#A0522D"/><rect x="36" y="24" width="6" height="16" fill="#A0522D"/><rect x="0" y="16" width="48" height="4" fill="#A0522D" rx="1"/></svg>',
      'window-sill': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="8" y="8" width="32" height="24" fill="#87CEEB" stroke="#FFF" stroke-width="2"/><rect x="4" y="32" width="40" height="6" fill="#708090" rx="1"/><path d="M4 38 Q24 40 44 38" fill="#5a6a7a"/></svg>',
      'threshold': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="20" width="40" height="8" fill="#708090" rx="1"/><rect x="2" y="10" width="4" height="28" fill="#DEB887"/><rect x="42" y="10" width="4" height="28" fill="#DEB887"/><path d="M4 28 Q24 30 44 28" fill="#5a6a7a"/></svg>',
      // ===== BATHROOM ELEMENTS =====
      'toilet': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><ellipse cx="24" cy="30" rx="10" ry="12" fill="#F5F5F5" stroke="#DDD" stroke-width="1"/><rect x="14" y="8" width="20" height="14" rx="2" fill="#F0F0F0" stroke="#DDD"/><rect x="18" y="4" width="12" height="6" rx="1" fill="#E8E8E8"/><ellipse cx="24" cy="32" rx="6" ry="8" fill="#E0E0E0"/></svg>',
      'toilet-round': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><ellipse cx="24" cy="28" rx="10" ry="10" fill="#F5F5F5" stroke="#DDD" stroke-width="1"/><rect x="14" y="8" width="20" height="12" rx="2" fill="#F0F0F0" stroke="#DDD"/><rect x="18" y="4" width="12" height="6" rx="1" fill="#E8E8E8"/><ellipse cx="24" cy="28" rx="6" ry="6" fill="#E0E0E0"/></svg>',
      'toilet-wall': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><ellipse cx="24" cy="30" rx="10" ry="12" fill="#F5F5F5" stroke="#DDD" stroke-width="1"/><rect x="10" y="6" width="28" height="8" fill="#888" stroke="#666"/><ellipse cx="24" cy="32" rx="6" ry="8" fill="#E0E0E0"/></svg>',
      'bidet': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><ellipse cx="24" cy="28" rx="10" ry="12" fill="#F5F5F5" stroke="#DDD" stroke-width="1"/><ellipse cx="24" cy="28" rx="6" ry="8" fill="#E0E0E0"/><circle cx="24" cy="16" r="3" fill="#C0C0C0"/><circle cx="24" cy="28" r="2" fill="#888"/></svg>',
      'bathtub': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="12" width="40" height="28" rx="3" fill="#F5F5F5" stroke="#DDD" stroke-width="1"/><rect x="6" y="14" width="36" height="24" rx="2" fill="#E8E8E8"/><circle cx="10" cy="20" r="3" fill="#C0C0C0"/><rect x="8" y="10" width="4" height="4" rx="1" fill="#A0A0A0"/></svg>',
      'bathtub-freestanding': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><ellipse cx="24" cy="24" rx="20" ry="12" fill="#F5F5F5" stroke="#DDD" stroke-width="1"/><ellipse cx="24" cy="24" rx="16" ry="8" fill="#E8E8E8"/><ellipse cx="8" cy="38" rx="3" ry="4" fill="#A0A0A0"/><ellipse cx="40" cy="38" rx="3" ry="4" fill="#A0A0A0"/></svg>',
      'bathtub-corner': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><path d="M4 4 L44 4 L44 44 L4 44 Z" fill="#F5F5F5" stroke="#DDD" stroke-width="1"/><path d="M8 8 L40 8 L40 40 Q24 40 8 24 Z" fill="#E8E8E8"/><circle cx="36" cy="12" r="3" fill="#C0C0C0"/></svg>',
      'bathtub-walk-in': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="12" width="40" height="32" rx="2" fill="#F0F0F0" stroke="#DDD" stroke-width="1"/><rect x="6" y="14" width="36" height="28" rx="1" fill="#E8E8E8"/><rect x="4" y="12" width="8" height="32" fill="#D0D0D0"/><rect x="10" y="20" width="2" height="16" rx="1" fill="#C0C0C0"/></svg>',
      'vanity-24': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="8" y="16" width="32" height="28" rx="2" fill="#8B7355"/><rect x="10" y="18" width="28" height="24" rx="1" fill="#A08060"/><rect x="22" y="28" width="4" height="6" rx="1" fill="#FFD700"/><ellipse cx="24" cy="10" rx="10" ry="5" fill="#E0E0E0"/><ellipse cx="24" cy="10" rx="6" ry="3" fill="#808080"/></svg>',
      'vanity-30': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="6" y="16" width="36" height="28" rx="2" fill="#8B7355"/><rect x="8" y="18" width="32" height="24" rx="1" fill="#A08060"/><rect x="22" y="28" width="4" height="6" rx="1" fill="#FFD700"/><ellipse cx="24" cy="10" rx="12" ry="5" fill="#E0E0E0"/><ellipse cx="24" cy="10" rx="8" ry="3" fill="#808080"/></svg>',
      'vanity-36': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="16" width="40" height="28" rx="2" fill="#8B7355"/><rect x="6" y="18" width="36" height="24" rx="1" fill="#A08060"/><rect x="22" y="28" width="4" height="6" rx="1" fill="#FFD700"/><ellipse cx="24" cy="10" rx="14" ry="5" fill="#E0E0E0"/><ellipse cx="24" cy="10" rx="10" ry="3" fill="#808080"/></svg>',
      'vanity-48': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="16" width="44" height="28" rx="2" fill="#8B7355"/><rect x="4" y="18" width="40" height="24" rx="1" fill="#A08060"/><rect x="22" y="28" width="4" height="6" rx="1" fill="#FFD700"/><ellipse cx="24" cy="10" rx="16" ry="5" fill="#E0E0E0"/><ellipse cx="24" cy="10" rx="12" ry="3" fill="#808080"/></svg>',
      'vanity-60': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="16" width="44" height="28" rx="2" fill="#8B7355"/><rect x="4" y="18" width="40" height="24" rx="1" fill="#A08060"/><rect x="12" y="28" width="4" height="6" rx="1" fill="#FFD700"/><rect x="32" y="28" width="4" height="6" rx="1" fill="#FFD700"/><ellipse cx="14" cy="10" rx="8" ry="4" fill="#E0E0E0"/><ellipse cx="34" cy="10" rx="8" ry="4" fill="#E0E0E0"/></svg>',
      'vanity-72': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="16" width="44" height="28" rx="2" fill="#8B7355"/><rect x="4" y="18" width="40" height="24" rx="1" fill="#A08060"/><rect x="10" y="28" width="4" height="6" rx="1" fill="#FFD700"/><rect x="34" y="28" width="4" height="6" rx="1" fill="#FFD700"/><ellipse cx="12" cy="10" rx="7" ry="4" fill="#E0E0E0"/><ellipse cx="36" cy="10" rx="7" ry="4" fill="#E0E0E0"/></svg>',
      'shower-base-36': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="6" y="6" width="36" height="36" rx="2" fill="#D0D0D0" stroke="#B0B0B0"/><rect x="8" y="8" width="32" height="32" rx="1" fill="#E0E0E0"/><circle cx="24" cy="24" r="3" fill="#888"/><circle cx="24" cy="24" r="8" fill="none" stroke="#CCC" stroke-width="1"/></svg>',
      'shower-base-48': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="8" width="40" height="32" rx="2" fill="#D0D0D0" stroke="#B0B0B0"/><rect x="6" y="10" width="36" height="28" rx="1" fill="#E0E0E0"/><circle cx="24" cy="24" r="3" fill="#888"/><circle cx="24" cy="24" r="8" fill="none" stroke="#CCC" stroke-width="1"/></svg>',
      'shower-base-60': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="10" width="44" height="28" rx="2" fill="#D0D0D0" stroke="#B0B0B0"/><rect x="4" y="12" width="40" height="24" rx="1" fill="#E0E0E0"/><circle cx="24" cy="24" r="3" fill="#888"/><circle cx="24" cy="24" r="8" fill="none" stroke="#CCC" stroke-width="1"/></svg>',
      'shower-bench': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="6" y="24" width="36" height="20" rx="2" fill="#A0A0A0" stroke="#888"/><rect x="4" y="20" width="40" height="6" rx="1" fill="#B8B8B8"/><rect x="10" y="32" width="4" height="12" fill="#888"/><rect x="34" y="32" width="4" height="12" fill="#888"/></svg>',
      'shower-glass': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="8" y="4" width="32" height="40" rx="1" fill="#B8E0FF" opacity="0.4" stroke="#87CEEB" stroke-width="2"/><line x1="12" y1="8" x2="12" y2="40" stroke="#ADD8E6" stroke-width="1" opacity="0.5"/><line x1="24" y1="8" x2="24" y2="40" stroke="#ADD8E6" stroke-width="1" opacity="0.5"/><line x1="36" y1="8" x2="36" y2="40" stroke="#ADD8E6" stroke-width="1" opacity="0.5"/></svg>',
      'shower-door': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="6" y="4" width="36" height="40" rx="1" fill="#C4E8FF" opacity="0.5" stroke="#87CEEB" stroke-width="2"/><rect x="36" y="18" width="4" height="12" rx="2" fill="#C0C0C0"/><line x1="20" y1="4" x2="20" y2="44" stroke="#87CEEB" stroke-width="2"/></svg>',
      'mirror': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="6" y="8" width="36" height="32" rx="2" fill="#E8E8FF" stroke="#CCC" stroke-width="2"/><rect x="8" y="10" width="32" height="28" fill="#F0F0FF"/><path d="M12 14 L18 20 L12 20 Z" fill="#FFF" opacity="0.6"/></svg>',
      'medicine-cabinet': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="8" y="6" width="32" height="36" rx="2" fill="#C0C0C0" stroke="#A0A0A0"/><rect x="10" y="8" width="28" height="32" rx="1" fill="#E8E8FF"/><line x1="24" y1="8" x2="24" y2="40" stroke="#C0C0C0" stroke-width="2"/><rect x="28" y="20" width="3" height="8" rx="1" fill="#888"/></svg>',
      'towel-bar': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="20" width="40" height="4" rx="2" fill="#C0C0C0"/><circle cx="8" cy="22" r="4" fill="#888"/><circle cx="40" cy="22" r="4" fill="#888"/><path d="M10 24 Q24 32 38 24" fill="none" stroke="#DEB887" stroke-width="3"/></svg>',
      'toilet-paper': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="16" y="12" width="16" height="24" rx="2" fill="#A0A0A0"/><ellipse cx="24" cy="24" rx="10" ry="12" fill="#F5F5F5"/><ellipse cx="24" cy="24" rx="4" ry="5" fill="#888"/><path d="M30 16 Q36 24 30 32" fill="none" stroke="#E8E8E8" stroke-width="2"/></svg>',
      'fridge-cabinet': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="6" y="2" width="36" height="44" rx="2" fill="#8B5A2B"/><rect x="8" y="4" width="4" height="38" fill="#A0522D"/><rect x="36" y="4" width="4" height="38" fill="#A0522D"/><rect x="12" y="4" width="24" height="10" rx="1" fill="#A0522D"/><rect x="14" y="6" width="20" height="6" rx="1" fill="#CD853F"/><rect x="22" y="8" width="6" height="2" rx="1" fill="#FFD700"/><rect x="12" y="16" width="24" height="26" fill="#2a2a2a"/><rect x="14" y="18" width="20" height="22" rx="1" fill="#D5D5D5"/><rect x="14" y="18" width="9" height="14" fill="#E0E0E0"/><rect x="25" y="18" width="9" height="14" fill="#E0E0E0"/><rect x="14" y="34" width="20" height="6" fill="#E0E0E0"/><rect x="22" y="22" width="4" height="6" fill="#444"/><rect x="6" y="42" width="36" height="4" fill="#1a1a1a"/></svg>',
      // Shower panels (structure elements that need icons)
      'shower-pan': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="8" width="40" height="32" rx="3" fill="#D0D0D0" stroke="#B0B0B0"/><rect x="6" y="10" width="36" height="28" rx="2" fill="#E8E8E8"/><circle cx="24" cy="24" r="4" fill="#808080"/></svg>',
      'shower-curb': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="18" width="40" height="12" rx="2" fill="#808080"/><rect x="4" y="16" width="40" height="4" fill="#909090" rx="1"/></svg>',
      'shower-wall': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="4" width="40" height="40" fill="#B0B0B0"/><rect x="6" y="6" width="36" height="36" fill="#C8C8C8"/><line x1="6" y1="16" x2="42" y2="16" stroke="#B0B0B0"/><line x1="6" y1="26" x2="42" y2="26" stroke="#B0B0B0"/><line x1="6" y1="36" x2="42" y2="36" stroke="#B0B0B0"/></svg>',
      'wall-tile': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="2" width="10" height="10" fill="#E8E8E8" stroke="#CCC"/><rect x="14" y="2" width="10" height="10" fill="#F0F0F0" stroke="#CCC"/><rect x="26" y="2" width="10" height="10" fill="#E8E8E8" stroke="#CCC"/><rect x="38" y="2" width="8" height="10" fill="#F0F0F0" stroke="#CCC"/><rect x="2" y="14" width="10" height="10" fill="#F0F0F0" stroke="#CCC"/><rect x="14" y="14" width="10" height="10" fill="#E8E8E8" stroke="#CCC"/><rect x="26" y="14" width="10" height="10" fill="#F0F0F0" stroke="#CCC"/><rect x="38" y="14" width="8" height="10" fill="#E8E8E8" stroke="#CCC"/><rect x="2" y="26" width="10" height="10" fill="#E8E8E8" stroke="#CCC"/><rect x="14" y="26" width="10" height="10" fill="#F0F0F0" stroke="#CCC"/><rect x="26" y="26" width="10" height="10" fill="#E8E8E8" stroke="#CCC"/><rect x="38" y="26" width="8" height="10" fill="#F0F0F0" stroke="#CCC"/><rect x="2" y="38" width="10" height="8" fill="#F0F0F0" stroke="#CCC"/><rect x="14" y="38" width="10" height="8" fill="#E8E8E8" stroke="#CCC"/><rect x="26" y="38" width="10" height="8" fill="#F0F0F0" stroke="#CCC"/><rect x="38" y="38" width="8" height="8" fill="#E8E8E8" stroke="#CCC"/></svg>',
      'accent-wall': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="4" width="40" height="40" fill="#888"/><rect x="6" y="6" width="36" height="36" fill="#666"/><rect x="8" y="8" width="14" height="14" fill="#555"/><rect x="26" y="8" width="14" height="14" fill="#777"/><rect x="8" y="26" width="14" height="14" fill="#777"/><rect x="26" y="26" width="14" height="14" fill="#555"/></svg>',
      // ===== LAUNDRY ELEMENTS =====
      'washer': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="6" y="4" width="36" height="40" rx="3" fill="#E8E8E8" stroke="#CCC"/><rect x="8" y="6" width="32" height="8" rx="1" fill="#D0D0D0"/><circle cx="24" cy="28" r="12" fill="#F5F5F5" stroke="#CCC" stroke-width="2"/><circle cx="24" cy="28" r="8" fill="#87CEEB" opacity="0.5"/><circle cx="14" cy="10" r="2" fill="#4CAF50"/><circle cx="20" cy="10" r="2" fill="#888"/></svg>',
      'dryer': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="6" y="4" width="36" height="40" rx="3" fill="#E0E0E0" stroke="#CCC"/><rect x="8" y="6" width="32" height="8" rx="1" fill="#D0D0D0"/><circle cx="24" cy="28" r="12" fill="#F0F0F0" stroke="#CCC" stroke-width="2"/><circle cx="24" cy="28" r="8" fill="#DDD"/><circle cx="14" cy="10" r="2" fill="#FF9800"/><circle cx="20" cy="10" r="2" fill="#888"/></svg>',
      'washer-dryer-stack': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="8" y="2" width="32" height="22" rx="2" fill="#E0E0E0" stroke="#CCC"/><rect x="8" y="24" width="32" height="22" rx="2" fill="#E8E8E8" stroke="#CCC"/><circle cx="24" cy="13" r="7" fill="#F0F0F0" stroke="#CCC"/><circle cx="24" cy="35" r="7" fill="#87CEEB" opacity="0.5" stroke="#CCC"/><circle cx="12" cy="6" r="1.5" fill="#FF9800"/><circle cx="12" cy="28" r="1.5" fill="#4CAF50"/></svg>',
      'utility-sink': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="6" y="16" width="36" height="28" rx="2" fill="#D0D0D0" stroke="#B0B0B0"/><rect x="8" y="18" width="32" height="24" rx="1" fill="#E8E8E8"/><rect x="10" y="20" width="28" height="20" fill="#505050"/><rect x="22" y="6" width="4" height="12" rx="2" fill="#C0C0C0"/><circle cx="24" cy="6" r="3" fill="#A0A0A0"/></svg>',
      'laundry-sink': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="6" y="18" width="36" height="26" rx="2" fill="#E0E0E0" stroke="#C0C0C0"/><rect x="8" y="20" width="32" height="22" rx="1" fill="#F0F0F0"/><rect x="10" y="22" width="28" height="18" fill="#606060"/><rect x="22" y="8" width="4" height="12" rx="2" fill="#B0B0B0"/><circle cx="24" cy="8" r="3" fill="#909090"/></svg>',
      'laundry-cabinet': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="6" y="8" width="36" height="36" rx="2" fill="#8B7355"/><rect x="8" y="10" width="15" height="32" rx="1" fill="#A08060"/><rect x="25" y="10" width="15" height="32" rx="1" fill="#A08060"/><rect x="18" y="24" width="2" height="8" rx="1" fill="#FFD700"/><rect x="35" y="24" width="2" height="8" rx="1" fill="#FFD700"/></svg>',
      'ironing-board': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><path d="M8 20 L40 20 L44 24 L40 28 L8 28 Z" fill="#C0C0C0"/><rect x="12" y="22" width="28" height="4" fill="#E8E8E8"/><line x1="16" y1="28" x2="12" y2="40" stroke="#888" stroke-width="2"/><line x1="36" y1="28" x2="40" y2="40" stroke="#888" stroke-width="2"/><line x1="24" y1="28" x2="24" y2="36" stroke="#888" stroke-width="2"/></svg>',
      'drying-rack': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="8" y="8" width="4" height="32" fill="#A0A0A0"/><rect x="36" y="8" width="4" height="32" fill="#A0A0A0"/><line x1="12" y1="12" x2="36" y2="12" stroke="#C0C0C0" stroke-width="2"/><line x1="12" y1="20" x2="36" y2="20" stroke="#C0C0C0" stroke-width="2"/><line x1="12" y1="28" x2="36" y2="28" stroke="#C0C0C0" stroke-width="2"/><line x1="12" y1="36" x2="36" y2="36" stroke="#C0C0C0" stroke-width="2"/></svg>',
      // ===== CLOSET ELEMENTS =====
      'closet-rod': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="20" width="40" height="4" rx="2" fill="#C0C0C0"/><ellipse cx="8" cy="22" rx="4" ry="6" fill="#A0A0A0"/><ellipse cx="40" cy="22" rx="4" ry="6" fill="#A0A0A0"/><path d="M12 24 L12 36 M20 24 L20 38 M28 24 L28 36 M36 24 L36 38" stroke="#8B7355" stroke-width="2"/></svg>',
      'closet-shelf': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="20" width="40" height="6" rx="1" fill="#D4C4A8"/><rect x="4" y="26" width="4" height="16" fill="#C4B498"/><rect x="40" y="26" width="4" height="16" fill="#C4B498"/><rect x="8" y="22" width="8" height="3" fill="#DEB887"/><rect x="20" y="22" width="8" height="3" fill="#DEB887"/><rect x="32" y="22" width="8" height="3" fill="#DEB887"/></svg>',
      'closet-drawers': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="8" y="8" width="32" height="36" rx="2" fill="#8B7355"/><rect x="10" y="10" width="28" height="10" rx="1" fill="#A08060"/><rect x="10" y="22" width="28" height="10" rx="1" fill="#A08060"/><rect x="10" y="34" width="28" height="8" rx="1" fill="#A08060"/><rect x="22" y="13" width="4" height="4" rx="1" fill="#FFD700"/><rect x="22" y="25" width="4" height="4" rx="1" fill="#FFD700"/><rect x="22" y="36" width="4" height="4" rx="1" fill="#FFD700"/></svg>',
      'drawer-unit': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="8" y="8" width="32" height="36" rx="2" fill="#8B7355"/><rect x="10" y="10" width="28" height="10" rx="1" fill="#A08060"/><rect x="10" y="22" width="28" height="10" rx="1" fill="#A08060"/><rect x="10" y="34" width="28" height="8" rx="1" fill="#A08060"/><rect x="22" y="13" width="4" height="4" rx="1" fill="#C0C0C0"/><rect x="22" y="25" width="4" height="4" rx="1" fill="#C0C0C0"/><rect x="22" y="36" width="4" height="4" rx="1" fill="#C0C0C0"/></svg>',
      'shoe-rack': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="6" y="8" width="36" height="4" fill="#A0A0A0"/><rect x="6" y="18" width="36" height="4" fill="#A0A0A0"/><rect x="6" y="28" width="36" height="4" fill="#A0A0A0"/><rect x="6" y="38" width="36" height="4" fill="#A0A0A0"/><rect x="6" y="8" width="4" height="34" fill="#888"/><rect x="38" y="8" width="4" height="34" fill="#888"/><ellipse cx="16" cy="10" rx="4" ry="2" fill="#4A3728"/><ellipse cx="28" cy="10" rx="4" ry="2" fill="#2F1F14"/></svg>',
      'closet-island': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="6" y="16" width="36" height="28" rx="2" fill="#8B7355"/><rect x="4" y="12" width="40" height="6" rx="1" fill="#A08060"/><rect x="8" y="18" width="14" height="24" rx="1" fill="#A08060"/><rect x="26" y="18" width="14" height="24" rx="1" fill="#A08060"/><rect x="18" y="28" width="2" height="6" rx="1" fill="#FFD700"/><rect x="36" y="28" width="2" height="6" rx="1" fill="#FFD700"/></svg>',
      'jewelry-cabinet': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="10" y="4" width="28" height="40" rx="2" fill="#8B7355"/><rect x="12" y="6" width="24" height="36" rx="1" fill="#A08060"/><rect x="14" y="8" width="20" height="8" fill="#2a2a2a" rx="1"/><rect x="14" y="18" width="20" height="8" fill="#2a2a2a" rx="1"/><rect x="14" y="28" width="20" height="8" fill="#2a2a2a" rx="1"/><circle cx="24" cy="12" r="2" fill="#FFD700"/><circle cx="20" cy="22" r="1.5" fill="#C0C0C0"/><circle cx="28" cy="22" r="1.5" fill="#B8860B"/><circle cx="24" cy="32" r="2" fill="#E0E0FF"/></svg>',
      'jewelry-drawer': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="6" y="16" width="36" height="16" rx="2" fill="#8B7355"/><rect x="8" y="18" width="32" height="12" rx="1" fill="#A08060"/><rect x="10" y="20" width="8" height="8" fill="#2a2a2a"/><rect x="20" y="20" width="8" height="8" fill="#2a2a2a"/><rect x="30" y="20" width="8" height="8" fill="#2a2a2a"/><circle cx="14" cy="24" r="2" fill="#FFD700"/><circle cx="24" cy="24" r="2" fill="#C0C0C0"/><circle cx="34" cy="24" r="2" fill="#B8860B"/></svg>',
      'tie-rack': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="8" y="8" width="32" height="6" rx="1" fill="#A0A0A0"/><rect x="12" y="14" width="2" height="28" fill="#C0C0C0"/><rect x="22" y="14" width="2" height="28" fill="#C0C0C0"/><rect x="32" y="14" width="2" height="28" fill="#C0C0C0"/><path d="M11 18 L15 18 L14 32 L12 32 Z" fill="#4169E1"/><path d="M21 18 L25 18 L24 30 L22 30 Z" fill="#DC143C"/><path d="M31 18 L35 18 L34 34 L32 34 Z" fill="#228B22"/></svg>',
      'full-mirror': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="12" y="2" width="24" height="44" rx="2" fill="#E8E8FF" stroke="#CCC" stroke-width="2"/><rect x="14" y="4" width="20" height="40" fill="#F0F0FF"/><path d="M18 8 L24 16 L18 16 Z" fill="#FFF" opacity="0.6"/></svg>',
      // ===== MISSING ELEMENTS (ADDED) =====
      'single-oven-cabinet': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="8" y="2" width="32" height="44" rx="2" fill="#8B5A2B"/><rect x="10" y="4" width="28" height="10" rx="1" fill="#A0522D"/><rect x="12" y="6" width="24" height="6" rx="1" fill="#CD853F"/><rect x="22" y="8" width="4" height="2" rx="1" fill="#FFD700"/><rect x="10" y="16" width="28" height="28" rx="1" fill="#2a2a2a"/><rect x="12" y="18" width="24" height="6" rx="1" fill="#3a3a3a"/><rect x="14" y="19" width="20" height="4" rx="1" fill="#444"/><rect x="12" y="26" width="24" height="16" rx="1" fill="#1a1a1a"/><rect x="14" y="28" width="20" height="12" rx="1" fill="#222"/><rect x="34" y="32" width="2" height="4" rx="1" fill="#666"/></svg>',
      'tall-oven': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="8" y="2" width="32" height="44" rx="2" fill="#8B5A2B"/><rect x="10" y="4" width="28" height="10" rx="1" fill="#A0522D"/><rect x="12" y="6" width="24" height="6" rx="1" fill="#CD853F"/><rect x="22" y="8" width="4" height="2" rx="1" fill="#FFD700"/><rect x="10" y="16" width="28" height="28" rx="1" fill="#2a2a2a"/><rect x="12" y="18" width="24" height="6" rx="1" fill="#3a3a3a"/><rect x="14" y="19" width="20" height="4" rx="1" fill="#444"/><rect x="12" y="26" width="24" height="16" rx="1" fill="#1a1a1a"/><rect x="14" y="28" width="20" height="12" rx="1" fill="#222"/><rect x="34" y="32" width="2" height="4" rx="1" fill="#666"/></svg>',
      'double-oven-cabinet': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="8" y="2" width="32" height="44" rx="2" fill="#8B5A2B"/><rect x="10" y="4" width="28" height="6" rx="1" fill="#A0522D"/><rect x="12" y="5" width="24" height="4" rx="1" fill="#CD853F"/><rect x="22" y="6" width="4" height="2" rx="1" fill="#FFD700"/><rect x="10" y="12" width="28" height="15" rx="1" fill="#2a2a2a"/><rect x="12" y="14" width="24" height="11" rx="1" fill="#1a1a1a"/><rect x="14" y="16" width="20" height="7" rx="1" fill="#222"/><rect x="32" y="18" width="2" height="3" rx="1" fill="#666"/><rect x="10" y="29" width="28" height="15" rx="1" fill="#2a2a2a"/><rect x="12" y="31" width="24" height="11" rx="1" fill="#1a1a1a"/><rect x="14" y="33" width="20" height="7" rx="1" fill="#222"/><rect x="32" y="35" width="2" height="3" rx="1" fill="#666"/></svg>',
      'blind-corner': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><path d="M4 4 L4 44 L44 44 L44 24 L24 24 L24 4 Z" fill="#8B5A2B"/><path d="M6 6 L6 42 L42 42 L42 26 L22 26 L22 6 Z" fill="#A0522D"/><rect x="8" y="8" width="12" height="16" rx="1" fill="#CD853F"/><rect x="8" y="28" width="12" height="12" rx="1" fill="#CD853F"/><rect x="24" y="28" width="16" height="12" rx="1" fill="#CD853F"/><rect x="18" y="14" width="2" height="6" rx="1" fill="#FFD700"/><rect x="18" y="32" width="2" height="6" rx="1" fill="#FFD700"/><rect x="38" y="32" width="2" height="6" rx="1" fill="#FFD700"/><rect x="4" y="44" width="40" height="4" fill="#2a2a2a"/></svg>',
      'countertop-corner': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><path d="M4 4 L4 44 L24 44 L24 24 L44 24 L44 4 Z" fill="#708090"/><path d="M6 6 L6 42 L22 42 L22 22 L42 22 L42 6 Z" fill="#5a6a7a"/><circle cx="12" cy="14" r="2" fill="#8090a0"/><circle cx="12" cy="32" r="2" fill="#8090a0"/><circle cx="32" cy="14" r="2" fill="#8090a0"/><path d="M4 44 L4 46 L26 46 L26 24 L44 24 L44 22 L24 22 L24 44 Z" fill="#4a5a6a"/></svg>',
      'slide-in-range': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="4" width="40" height="40" rx="2" fill="#2a2a2a"/><rect x="4" y="4" width="40" height="12" rx="2" fill="#1a1a1a"/><circle cx="14" cy="10" r="4" fill="#333" stroke="#444" stroke-width="1.5"/><circle cx="24" cy="10" r="4" fill="#333" stroke="#444" stroke-width="1.5"/><circle cx="34" cy="10" r="4" fill="#333" stroke="#444" stroke-width="1.5"/><rect x="6" y="18" width="36" height="4" rx="1" fill="#3a3a3a"/><circle cx="12" cy="20" r="1.5" fill="#666"/><circle cx="20" cy="20" r="1.5" fill="#666"/><circle cx="28" cy="20" r="1.5" fill="#666"/><circle cx="36" cy="20" r="1.5" fill="#666"/><rect x="8" y="24" width="32" height="18" rx="1" fill="#1a1a1a"/><rect x="10" y="26" width="28" height="14" rx="1" fill="#111"/></svg>',
      'cooktop': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="14" width="44" height="20" rx="2" fill="#1a1a1a"/><rect x="4" y="16" width="40" height="16" rx="1" fill="#2a2a2a"/><circle cx="14" cy="24" r="6" fill="#333" stroke="#555" stroke-width="2"/><circle cx="34" cy="24" r="6" fill="#333" stroke="#555" stroke-width="2"/><circle cx="14" cy="24" r="3" fill="#444"/><circle cx="34" cy="24" r="3" fill="#444"/><circle cx="14" cy="24" r="1" fill="#ff4500" opacity="0.6"/><circle cx="34" cy="24" r="1" fill="#ff4500" opacity="0.6"/><rect x="22" y="18" width="4" height="12" fill="#3a3a3a"/><circle cx="24" cy="20" r="1" fill="#666"/><circle cx="24" cy="28" r="1" fill="#666"/></svg>',
      'wall-oven-double': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="6" y="2" width="36" height="44" rx="2" fill="#2a2a2a"/><rect x="8" y="4" width="32" height="20" rx="1" fill="#3a3a3a"/><rect x="10" y="6" width="28" height="16" rx="1" fill="#1a1a1a"/><rect x="12" y="8" width="24" height="12" rx="1" fill="#222"/><rect x="34" y="12" width="2" height="4" rx="1" fill="#666"/><rect x="8" y="26" width="32" height="20" rx="1" fill="#3a3a3a"/><rect x="10" y="28" width="28" height="16" rx="1" fill="#1a1a1a"/><rect x="12" y="30" width="24" height="12" rx="1" fill="#222"/><rect x="34" y="34" width="2" height="4" rx="1" fill="#666"/></svg>',
      'vanity-double-60': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="14" width="44" height="28" rx="2" fill="#8B5A2B"/><rect x="4" y="16" width="20" height="24" rx="1" fill="#A0522D"/><rect x="26" y="16" width="20" height="24" rx="1" fill="#A0522D"/><rect x="23" y="16" width="2" height="24" fill="#6B3A1B"/><ellipse cx="14" cy="28" rx="7" ry="5" fill="#FFF" stroke="#CCC" stroke-width="1"/><ellipse cx="36" cy="28" rx="7" ry="5" fill="#FFF" stroke="#CCC" stroke-width="1"/><circle cx="14" cy="20" r="2" fill="#C0C0C0"/><circle cx="36" cy="20" r="2" fill="#C0C0C0"/><rect x="12" y="38" width="4" height="2" rx="0.5" fill="#FFD700"/><rect x="34" y="38" width="4" height="2" rx="0.5" fill="#FFD700"/></svg>',
      'vanity-double-72': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="14" width="44" height="28" rx="2" fill="#8B5A2B"/><rect x="4" y="16" width="20" height="24" rx="1" fill="#A0522D"/><rect x="26" y="16" width="20" height="24" rx="1" fill="#A0522D"/><rect x="23" y="16" width="2" height="24" fill="#6B3A1B"/><ellipse cx="14" cy="28" rx="7" ry="5" fill="#FFF" stroke="#CCC" stroke-width="1"/><ellipse cx="36" cy="28" rx="7" ry="5" fill="#FFF" stroke="#CCC" stroke-width="1"/><circle cx="14" cy="20" r="2" fill="#C0C0C0"/><circle cx="36" cy="20" r="2" fill="#C0C0C0"/><rect x="12" y="38" width="4" height="2" rx="0.5" fill="#FFD700"/><rect x="34" y="38" width="4" height="2" rx="0.5" fill="#FFD700"/></svg>',
      'vanity-double-84': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="14" width="44" height="28" rx="2" fill="#8B5A2B"/><rect x="4" y="16" width="20" height="24" rx="1" fill="#A0522D"/><rect x="26" y="16" width="20" height="24" rx="1" fill="#A0522D"/><rect x="23" y="16" width="2" height="24" fill="#6B3A1B"/><ellipse cx="14" cy="28" rx="7" ry="5" fill="#FFF" stroke="#CCC" stroke-width="1"/><ellipse cx="36" cy="28" rx="7" ry="5" fill="#FFF" stroke="#CCC" stroke-width="1"/><circle cx="14" cy="20" r="2" fill="#C0C0C0"/><circle cx="36" cy="20" r="2" fill="#C0C0C0"/><rect x="12" y="38" width="4" height="2" rx="0.5" fill="#FFD700"/><rect x="34" y="38" width="4" height="2" rx="0.5" fill="#FFD700"/></svg>',
      'vanity-hishers-96': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="14" width="44" height="28" rx="2" fill="#8B5A2B"/><rect x="3" y="16" width="14" height="24" rx="1" fill="#A0522D"/><rect x="19" y="16" width="10" height="24" rx="1" fill="#C4A87C"/><rect x="31" y="16" width="14" height="24" rx="1" fill="#A0522D"/><ellipse cx="10" cy="28" rx="5" ry="4" fill="#FFF" stroke="#CCC" stroke-width="1"/><ellipse cx="38" cy="28" rx="5" ry="4" fill="#FFF" stroke="#CCC" stroke-width="1"/><circle cx="10" cy="20" r="2" fill="#C0C0C0"/><circle cx="38" cy="20" r="2" fill="#C0C0C0"/><circle cx="24" cy="22" r="3" fill="#E8E8FF" stroke="#CCC" stroke-width="0.5"/><rect x="22" y="34" width="4" height="2" rx="0.5" fill="#FFD700"/></svg>',
      'vanity-hishers-108': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="14" width="44" height="28" rx="2" fill="#8B5A2B"/><rect x="3" y="16" width="14" height="24" rx="1" fill="#A0522D"/><rect x="19" y="16" width="10" height="24" rx="1" fill="#C4A87C"/><rect x="31" y="16" width="14" height="24" rx="1" fill="#A0522D"/><ellipse cx="10" cy="28" rx="5" ry="4" fill="#FFF" stroke="#CCC" stroke-width="1"/><ellipse cx="38" cy="28" rx="5" ry="4" fill="#FFF" stroke="#CCC" stroke-width="1"/><circle cx="10" cy="20" r="2" fill="#C0C0C0"/><circle cx="38" cy="20" r="2" fill="#C0C0C0"/><circle cx="24" cy="22" r="3" fill="#E8E8FF" stroke="#CCC" stroke-width="0.5"/><rect x="22" y="34" width="4" height="2" rx="0.5" fill="#FFD700"/></svg>',
      'powder-table': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="6" y="20" width="36" height="24" rx="2" fill="#A08060"/><rect x="8" y="22" width="32" height="8" rx="1" fill="#BFA070"/><circle cx="24" cy="12" r="8" fill="#E8E8FF" stroke="#CCC" stroke-width="1"/><rect x="20" y="40" width="8" height="2" rx="0.5" fill="#FFD700"/></svg>',
      'makeup-vanity': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="6" y="24" width="36" height="20" rx="2" fill="#8B5A2B"/><rect x="8" y="26" width="32" height="16" rx="1" fill="#A0522D"/><rect x="10" y="4" width="28" height="18" rx="2" fill="#E8E8FF" stroke="#CCC" stroke-width="1"/><rect x="20" y="40" width="8" height="2" rx="0.5" fill="#FFD700"/><rect x="18" y="30" width="12" height="6" rx="1" fill="#BFA070"/></svg>',
      'pedestal-sink': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><ellipse cx="24" cy="16" rx="16" ry="10" fill="#FFFFFF" stroke="#CCC" stroke-width="1.5"/><rect x="20" y="22" width="8" height="22" rx="1" fill="#F0F0F0" stroke="#CCC" stroke-width="1"/><ellipse cx="24" cy="16" rx="10" ry="6" fill="#F5F5F5" stroke="#DDD" stroke-width="1"/><circle cx="24" cy="16" r="2" fill="#888"/><circle cx="24" cy="10" r="2.5" fill="#C0C0C0"/></svg>',
      'linen-closet': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="6" y="2" width="36" height="44" rx="2" fill="#8B5A2B"/><rect x="8" y="4" width="32" height="40" rx="1" fill="#A0522D"/><line x1="8" y1="14" x2="40" y2="14" stroke="#6B3A1B" stroke-width="1"/><line x1="8" y1="24" x2="40" y2="24" stroke="#6B3A1B" stroke-width="1"/><line x1="8" y1="34" x2="40" y2="34" stroke="#6B3A1B" stroke-width="1"/><rect x="22" y="20" width="4" height="8" rx="1" fill="#FFD700"/></svg>',
      'linen-tower': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="10" y="2" width="28" height="44" rx="2" fill="#8B5A2B"/><rect x="12" y="4" width="24" height="40" rx="1" fill="#A0522D"/><line x1="12" y1="12" x2="36" y2="12" stroke="#6B3A1B" stroke-width="1"/><line x1="12" y1="20" x2="36" y2="20" stroke="#6B3A1B" stroke-width="1"/><line x1="12" y1="28" x2="36" y2="28" stroke="#6B3A1B" stroke-width="1"/><line x1="12" y1="36" x2="36" y2="36" stroke="#6B3A1B" stroke-width="1"/><rect x="22" y="18" width="4" height="6" rx="1" fill="#FFD700"/></svg>',
      // ===== ELECTRICAL & HVAC ELEMENTS =====
      'outlet': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="10" y="8" width="28" height="32" rx="4" fill="#F5F5DC" stroke="#CCC" stroke-width="2"/><rect x="18" y="16" width="4" height="8" rx="1" fill="#333"/><rect x="26" y="16" width="4" height="8" rx="1" fill="#333"/><rect x="18" y="28" width="4" height="8" rx="1" fill="#333"/><rect x="26" y="28" width="4" height="8" rx="1" fill="#333"/><circle cx="24" cy="24" r="2" fill="#333"/></svg>',
      'outlet-gfci': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="10" y="8" width="28" height="32" rx="4" fill="#F5F5DC" stroke="#CCC" stroke-width="2"/><rect x="18" y="12" width="4" height="6" rx="1" fill="#333"/><rect x="26" y="12" width="4" height="6" rx="1" fill="#333"/><rect x="16" y="22" width="6" height="4" rx="1" fill="#FF0000"/><rect x="26" y="22" width="6" height="4" rx="1" fill="#333"/><rect x="18" y="32" width="4" height="6" rx="1" fill="#333"/><rect x="26" y="32" width="4" height="6" rx="1" fill="#333"/><text x="19" y="25" font-size="3" fill="#FFF" font-weight="bold">T</text><text x="29" y="25" font-size="3" fill="#FFF" font-weight="bold">R</text></svg>',
      'outlet-20a': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="10" y="8" width="28" height="32" rx="4" fill="#F5F5DC" stroke="#CCC" stroke-width="2"/><rect x="16" y="16" width="4" height="8" rx="1" fill="#333"/><rect x="22" y="16" width="4" height="8" rx="1" fill="#333" transform="rotate(90 24 20)"/><rect x="28" y="16" width="4" height="8" rx="1" fill="#333"/><circle cx="24" cy="32" r="3" fill="#333"/></svg>',
      'outlet-240v': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="8" y="8" width="32" height="32" rx="4" fill="#F5F5DC" stroke="#CCC" stroke-width="2"/><circle cx="16" cy="20" r="4" fill="#333"/><circle cx="32" cy="20" r="4" fill="#333"/><rect x="20" y="28" width="8" height="6" rx="1" fill="#333"/><text x="24" y="42" font-size="6" fill="#666" text-anchor="middle">240V</text></svg>',
      'outlet-usb': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="10" y="8" width="28" height="32" rx="4" fill="#F5F5DC" stroke="#CCC" stroke-width="2"/><rect x="18" y="12" width="4" height="6" rx="1" fill="#333"/><rect x="26" y="12" width="4" height="6" rx="1" fill="#333"/><rect x="16" y="22" width="6" height="4" rx="1" fill="#4169E1"/><rect x="26" y="22" width="6" height="4" rx="1" fill="#4169E1"/><rect x="18" y="32" width="4" height="6" rx="1" fill="#333"/><rect x="26" y="32" width="4" height="6" rx="1" fill="#333"/></svg>',
      'switch-single': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="10" y="8" width="28" height="32" rx="4" fill="#F5F5DC" stroke="#CCC" stroke-width="2"/><rect x="18" y="14" width="12" height="20" rx="2" fill="#DDD"/><rect x="20" y="16" width="8" height="8" rx="1" fill="#888"/></svg>',
      'switch-dimmer': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="10" y="8" width="28" height="32" rx="4" fill="#F5F5DC" stroke="#CCC" stroke-width="2"/><rect x="18" y="12" width="12" height="24" rx="2" fill="#DDD"/><circle cx="24" cy="24" r="6" fill="#888" stroke="#666"/><rect x="22" y="18" width="4" height="2" rx="1" fill="#FFF"/></svg>',
      'switch-3way': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="10" y="8" width="28" height="32" rx="4" fill="#F5F5DC" stroke="#CCC" stroke-width="2"/><rect x="16" y="14" width="16" height="20" rx="2" fill="#DDD"/><rect x="18" y="16" width="5" height="8" rx="1" fill="#888"/><rect x="25" y="16" width="5" height="8" rx="1" fill="#888"/><rect x="21" y="26" width="6" height="6" rx="1" fill="#666"/></svg>',
      'switch-smart': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="10" y="8" width="28" height="32" rx="4" fill="#87CEEB" stroke="#4682B4" stroke-width="2"/><rect x="16" y="14" width="16" height="20" rx="2" fill="#E0F0FF"/><circle cx="24" cy="24" r="6" fill="#4169E1"/><path d="M21 24 L24 21 L27 24 L24 27 Z" fill="#FFF"/></svg>',
      'panel-main': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="6" y="4" width="36" height="40" rx="2" fill="#696969" stroke="#555" stroke-width="2"/><rect x="10" y="8" width="12" height="6" fill="#333"/><rect x="26" y="8" width="12" height="6" fill="#333"/><rect x="10" y="16" width="12" height="4" fill="#444"/><rect x="26" y="16" width="12" height="4" fill="#444"/><rect x="10" y="22" width="12" height="4" fill="#444"/><rect x="26" y="22" width="12" height="4" fill="#444"/><rect x="10" y="28" width="12" height="4" fill="#444"/><rect x="26" y="28" width="12" height="4" fill="#444"/><rect x="10" y="34" width="12" height="4" fill="#444"/><rect x="26" y="34" width="12" height="4" fill="#444"/></svg>',
      'panel-sub': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="10" y="8" width="28" height="32" rx="2" fill="#696969" stroke="#555" stroke-width="2"/><rect x="14" y="12" width="8" height="6" fill="#333"/><rect x="26" y="12" width="8" height="6" fill="#333"/><rect x="14" y="20" width="8" height="4" fill="#444"/><rect x="26" y="20" width="8" height="4" fill="#444"/><rect x="14" y="26" width="8" height="4" fill="#444"/><rect x="26" y="26" width="8" height="4" fill="#444"/><rect x="14" y="32" width="8" height="4" fill="#444"/><rect x="26" y="32" width="8" height="4" fill="#444"/></svg>',
      'junction-box': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="14" y="14" width="20" height="20" rx="2" fill="#808080" stroke="#666" stroke-width="2"/><circle cx="24" cy="24" r="6" fill="#666"/><circle cx="18" cy="18" r="2" fill="#555"/><circle cx="30" cy="18" r="2" fill="#555"/><circle cx="18" cy="30" r="2" fill="#555"/><circle cx="30" cy="30" r="2" fill="#555"/></svg>',
      'recessed-light': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><circle cx="24" cy="24" r="14" fill="#FFF" stroke="#CCC" stroke-width="2"/><circle cx="24" cy="24" r="8" fill="#FFD700"/><circle cx="24" cy="24" r="4" fill="#FFF8DC"/></svg>',
      'pendant-light': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="22" y="4" width="4" height="12" fill="#333"/><path d="M14 16 L34 16 L30 36 L18 36 Z" fill="#FFD700" stroke="#DAA520"/><ellipse cx="24" cy="36" rx="6" ry="2" fill="#FFF8DC"/></svg>',
      'under-cabinet-light': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="20" width="40" height="8" rx="2" fill="#FFFACD" stroke="#DAA520"/><rect x="8" y="22" width="32" height="4" fill="#FFD700"/></svg>',
      'light-fixture': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><circle cx="24" cy="24" r="16" fill="#FFF" stroke="#CCC" stroke-width="2"/><circle cx="24" cy="24" r="10" fill="#FFD700"/><circle cx="24" cy="24" r="4" fill="#FFF"/><rect x="22" y="4" width="4" height="4" fill="#888"/></svg>',
      'chandelier': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="22" y="2" width="4" height="8" fill="#333"/><ellipse cx="24" cy="14" rx="16" ry="4" fill="#C0C0C0"/><path d="M12 14 L10 28" stroke="#A0A0A0" stroke-width="2"/><path d="M24 14 L24 32" stroke="#A0A0A0" stroke-width="2"/><path d="M36 14 L38 28" stroke="#A0A0A0" stroke-width="2"/><circle cx="10" cy="30" r="4" fill="#FFD700"/><circle cx="24" cy="34" r="4" fill="#FFD700"/><circle cx="38" cy="30" r="4" fill="#FFD700"/></svg>',
      'sconce': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="20" y="8" width="8" height="4" fill="#888"/><path d="M16 12 L32 12 L30 36 L18 36 Z" fill="#FFD700" stroke="#DAA520"/><ellipse cx="24" cy="36" rx="4" ry="1.5" fill="#FFF8DC"/></svg>',
      'vent': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="8" y="16" width="32" height="16" rx="2" fill="#C0C0C0" stroke="#A0A0A0"/><line x1="12" y1="20" x2="36" y2="20" stroke="#888" stroke-width="2"/><line x1="12" y1="24" x2="36" y2="24" stroke="#888" stroke-width="2"/><line x1="12" y1="28" x2="36" y2="28" stroke="#888" stroke-width="2"/></svg>',
      'return-vent': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="12" width="40" height="24" rx="2" fill="#A0A0A0" stroke="#888"/><rect x="8" y="16" width="32" height="16" fill="#666"/><line x1="12" y1="18" x2="36" y2="18" stroke="#555" stroke-width="2"/><line x1="12" y1="24" x2="36" y2="24" stroke="#555" stroke-width="2"/><line x1="12" y1="30" x2="36" y2="30" stroke="#555" stroke-width="2"/></svg>',
      'exhaust-fan': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="8" y="8" width="32" height="32" rx="2" fill="#B0B0B0" stroke="#888"/><circle cx="24" cy="24" r="12" fill="#666"/><circle cx="24" cy="24" r="4" fill="#444"/><path d="M24 12 L28 20 L24 18 L20 20 Z" fill="#888"/><path d="M36 24 L28 28 L30 24 L28 20 Z" fill="#888"/><path d="M24 36 L20 28 L24 30 L28 28 Z" fill="#888"/><path d="M12 24 L20 20 L18 24 L20 28 Z" fill="#888"/></svg>',
      'thermostat': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="12" y="8" width="24" height="32" rx="4" fill="#E8E8E8" stroke="#CCC" stroke-width="2"/><circle cx="24" cy="24" r="10" fill="#FFF" stroke="#DDD"/><text x="24" y="28" font-size="10" fill="#333" text-anchor="middle">72</text><rect x="18" y="36" width="12" height="2" rx="1" fill="#4CAF50"/></svg>',
      // ===== SPECIALTY KITCHEN APPLIANCES =====
      'wine-cooler': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="6" y="2" width="36" height="44" rx="2" fill="#2a2a2a"/><rect x="8" y="4" width="32" height="40" rx="1" fill="#1a1a1a"/><rect x="10" y="6" width="28" height="36" rx="1" fill="#3a3a3a" opacity="0.5"/><line x1="10" y1="14" x2="38" y2="14" stroke="#555" stroke-width="1"/><line x1="10" y1="22" x2="38" y2="22" stroke="#555" stroke-width="1"/><line x1="10" y1="30" x2="38" y2="30" stroke="#555" stroke-width="1"/><ellipse cx="18" cy="10" rx="3" ry="4" fill="#722F37" opacity="0.6"/><ellipse cx="30" cy="10" rx="3" ry="4" fill="#722F37" opacity="0.6"/><ellipse cx="18" cy="18" rx="3" ry="4" fill="#722F37" opacity="0.6"/><ellipse cx="30" cy="18" rx="3" ry="4" fill="#722F37" opacity="0.6"/><ellipse cx="18" cy="26" rx="3" ry="4" fill="#E8E8D0" opacity="0.6"/><ellipse cx="30" cy="26" rx="3" ry="4" fill="#E8E8D0" opacity="0.6"/><circle cx="40" cy="24" r="2" fill="#4169E1"/></svg>',
      'beverage-center': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="6" y="2" width="36" height="44" rx="2" fill="#2a2a2a"/><rect x="8" y="4" width="32" height="40" rx="1" fill="#4a90a4" opacity="0.3"/><rect x="10" y="6" width="28" height="36" fill="#1a1a1a" opacity="0.5"/><rect x="14" y="10" width="6" height="12" rx="1" fill="#FFA500" opacity="0.7"/><rect x="22" y="10" width="6" height="12" rx="1" fill="#8B4513" opacity="0.7"/><rect x="30" y="10" width="6" height="12" rx="1" fill="#228B22" opacity="0.7"/><rect x="14" y="26" width="6" height="12" rx="1" fill="#DC143C" opacity="0.7"/><rect x="22" y="26" width="6" height="12" rx="1" fill="#4169E1" opacity="0.7"/><rect x="30" y="26" width="6" height="12" rx="1" fill="#FFD700" opacity="0.7"/><rect x="38" y="20" width="4" height="8" rx="1" fill="#333"/></svg>',
      'ice-maker': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="8" y="4" width="32" height="40" rx="2" fill="#A0A0A0"/><rect x="10" y="6" width="28" height="14" rx="1" fill="#E0F4FF"/><rect x="10" y="22" width="28" height="20" rx="1" fill="#888"/><rect x="12" y="24" width="24" height="16" fill="#666"/><polygon points="16,28 20,28 18,32" fill="#87CEEB"/><polygon points="22,28 26,28 24,32" fill="#87CEEB"/><polygon points="28,28 32,28 30,32" fill="#87CEEB"/><polygon points="19,34 23,34 21,38" fill="#87CEEB"/><polygon points="25,34 29,34 27,38" fill="#87CEEB"/><circle cx="36" cy="12" r="2" fill="#4CAF50"/></svg>',
      'warming-drawer': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="14" width="40" height="20" rx="2" fill="#2a2a2a"/><rect x="6" y="16" width="36" height="16" rx="1" fill="#3a3a3a"/><rect x="8" y="18" width="32" height="12" fill="#1a1a1a"/><path d="M14 22 Q16 20 18 22 Q20 24 22 22" stroke="#FF6B35" stroke-width="2" fill="none"/><path d="M26 22 Q28 20 30 22 Q32 24 34 22" stroke="#FF6B35" stroke-width="2" fill="none"/><rect x="20" y="28" width="8" height="2" rx="1" fill="#666"/></svg>',
      'trash-compactor': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="10" y="4" width="28" height="40" rx="2" fill="#696969"/><rect x="12" y="6" width="24" height="8" rx="1" fill="#555"/><rect x="14" y="8" width="20" height="4" fill="#444"/><circle cx="18" cy="10" r="1.5" fill="#333"/><circle cx="24" cy="10" r="1.5" fill="#333"/><circle cx="30" cy="10" r="1.5" fill="#333"/><rect x="12" y="16" width="24" height="26" rx="1" fill="#5a5a5a"/><rect x="14" y="18" width="20" height="22" fill="#4a4a4a"/><path d="M18 24 L30 24 L28 36 L20 36 Z" fill="#333"/><rect x="22" y="40" width="4" height="2" rx="1" fill="#888"/></svg>',
      'coffee-system': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="6" y="8" width="36" height="32" rx="2" fill="#2a2a2a"/><rect x="8" y="10" width="32" height="28" rx="1" fill="#3a3a3a"/><rect x="12" y="14" width="10" height="8" rx="1" fill="#1a1a1a"/><rect x="26" y="14" width="10" height="8" rx="1" fill="#1a1a1a"/><ellipse cx="17" cy="18" rx="3" ry="2" fill="#4a3728"/><ellipse cx="31" cy="18" rx="3" ry="2" fill="#4a3728"/><rect x="14" y="26" width="6" height="8" rx="1" fill="#F5F5DC"/><rect x="28" y="26" width="6" height="8" rx="1" fill="#F5F5DC"/><circle cx="40" cy="18" r="2" fill="#4CAF50"/><circle cx="40" cy="24" r="2" fill="#FFA500"/></svg>',
      'steam-oven': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="6" y="8" width="36" height="32" rx="2" fill="#3a3a3a"/><rect x="8" y="10" width="32" height="6" rx="1" fill="#4a4a4a"/><circle cx="14" cy="13" r="2" fill="#666"/><circle cx="22" cy="13" r="2" fill="#666"/><circle cx="30" cy="13" r="2" fill="#666"/><rect x="8" y="18" width="32" height="20" rx="1" fill="#2a2a2a"/><rect x="10" y="20" width="28" height="16" fill="#1a1a1a"/><path d="M16 28 Q18 24 20 28" stroke="#87CEEB" stroke-width="1.5" fill="none" opacity="0.7"/><path d="M24 28 Q26 24 28 28" stroke="#87CEEB" stroke-width="1.5" fill="none" opacity="0.7"/><path d="M32 28 Q34 24 36 28" stroke="#87CEEB" stroke-width="1.5" fill="none" opacity="0.7"/><rect x="36" y="24" width="2" height="4" rx="1" fill="#666"/></svg>',
      'speed-oven': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="6" y="8" width="36" height="32" rx="2" fill="#3a3a3a"/><rect x="8" y="10" width="32" height="6" rx="1" fill="#4a4a4a"/><circle cx="12" cy="13" r="2" fill="#666"/><rect x="18" y="11" width="18" height="4" rx="1" fill="#222"/><text x="27" y="14.5" font-size="4" fill="#0f0" text-anchor="middle">350</text><rect x="8" y="18" width="32" height="20" rx="1" fill="#2a2a2a"/><rect x="10" y="20" width="28" height="16" fill="#1a1a1a"/><circle cx="24" cy="28" r="6" fill="#222"/><circle cx="24" cy="28" r="4" fill="#333"/><rect x="36" y="24" width="2" height="4" rx="1" fill="#666"/></svg>',
      // ===== OUTDOOR KITCHEN APPLIANCES =====
      'grill-builtin': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="8" width="40" height="32" rx="2" fill="#2F2F2F"/><rect x="6" y="10" width="36" height="12" rx="1" fill="#1a1a1a"/><line x1="10" y1="14" x2="38" y2="14" stroke="#444" stroke-width="2"/><line x1="10" y1="18" x2="38" y2="18" stroke="#444" stroke-width="2"/><rect x="6" y="24" width="36" height="14" rx="1" fill="#3a3a3a"/><circle cx="14" cy="31" r="3" fill="#444" stroke="#555"/><circle cx="24" cy="31" r="3" fill="#444" stroke="#555"/><circle cx="34" cy="31" r="3" fill="#444" stroke="#555"/><path d="M12 12 Q14 8 16 12" stroke="#FF6B35" stroke-width="1.5" fill="none" opacity="0.8"/><path d="M22 12 Q24 8 26 12" stroke="#FF6B35" stroke-width="1.5" fill="none" opacity="0.8"/><path d="M32 12 Q34 8 36 12" stroke="#FF6B35" stroke-width="1.5" fill="none" opacity="0.8"/></svg>',
      'grill-42': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="8" width="44" height="32" rx="2" fill="#2F2F2F"/><rect x="4" y="10" width="40" height="12" rx="1" fill="#1a1a1a"/><line x1="8" y1="14" x2="40" y2="14" stroke="#444" stroke-width="2"/><line x1="8" y1="18" x2="40" y2="18" stroke="#444" stroke-width="2"/><rect x="4" y="24" width="40" height="14" rx="1" fill="#3a3a3a"/><circle cx="12" cy="31" r="3" fill="#444" stroke="#555"/><circle cx="24" cy="31" r="3" fill="#444" stroke="#555"/><circle cx="36" cy="31" r="3" fill="#444" stroke="#555"/><path d="M10 12 Q12 8 14 12" stroke="#FF6B35" stroke-width="1.5" fill="none" opacity="0.8"/><path d="M22 12 Q24 8 26 12" stroke="#FF6B35" stroke-width="1.5" fill="none" opacity="0.8"/><path d="M34 12 Q36 8 38 12" stroke="#FF6B35" stroke-width="1.5" fill="none" opacity="0.8"/></svg>',
      'side-burner': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="12" y="8" width="24" height="32" rx="2" fill="#2F2F2F"/><rect x="14" y="10" width="20" height="12" rx="1" fill="#1a1a1a"/><circle cx="24" cy="16" r="6" fill="#333" stroke="#444" stroke-width="2"/><circle cx="24" cy="16" r="3" fill="#444"/><path d="M22 14 Q24 10 26 14" stroke="#FF6B35" stroke-width="1.5" fill="none" opacity="0.8"/><rect x="14" y="24" width="20" height="14" rx="1" fill="#3a3a3a"/><circle cx="24" cy="31" r="3" fill="#444" stroke="#555"/></svg>',
      'power-burner': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="8" y="8" width="32" height="32" rx="2" fill="#2F2F2F"/><rect x="10" y="10" width="28" height="14" rx="1" fill="#1a1a1a"/><circle cx="24" cy="17" r="8" fill="#333" stroke="#555" stroke-width="2"/><circle cx="24" cy="17" r="5" fill="#444"/><circle cx="24" cy="17" r="2" fill="#555"/><path d="M20 15 Q22 10 24 15" stroke="#FF6B35" stroke-width="2" fill="none"/><path d="M24 15 Q26 10 28 15" stroke="#FF6B35" stroke-width="2" fill="none"/><rect x="10" y="26" width="28" height="12" rx="1" fill="#3a3a3a"/><circle cx="24" cy="32" r="4" fill="#444" stroke="#555"/></svg>',
      'outdoor-fridge': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="6" y="2" width="36" height="44" rx="2" fill="#A9A9A9"/><rect x="8" y="4" width="32" height="16" rx="1" fill="#C0C0C0"/><rect x="8" y="22" width="32" height="22" rx="1" fill="#B8B8B8"/><line x1="8" y1="20" x2="40" y2="20" stroke="#888" stroke-width="2"/><rect x="34" y="10" width="3" height="6" rx="1" fill="#888"/><rect x="34" y="30" width="3" height="8" rx="1" fill="#888"/><text x="24" y="14" font-size="6" fill="#666" text-anchor="middle"></text></svg>',
      'kegerator': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="6" y="6" width="36" height="38" rx="2" fill="#3a3a3a"/><rect x="8" y="8" width="32" height="34" rx="1" fill="#2a2a2a"/><circle cx="24" cy="25" r="10" fill="#444" stroke="#555" stroke-width="2"/><circle cx="24" cy="25" r="6" fill="#DAA520"/><text x="24" y="28" font-size="6" fill="#8B4513" text-anchor="middle" font-weight="bold">B</text><rect x="20" y="4" width="8" height="4" rx="1" fill="#C0C0C0"/><circle cx="24" cy="5" r="2" fill="#888"/><rect x="22" y="0" width="4" height="4" fill="#A0A0A0"/></svg>',
      'pizza-oven': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><path d="M6 16 Q6 6 24 6 Q42 6 42 16 L42 40 Q42 44 38 44 L10 44 Q6 44 6 40 Z" fill="#8B4513"/><path d="M10 18 Q10 10 24 10 Q38 10 38 18 L38 36 Q38 38 36 38 L12 38 Q10 38 10 36 Z" fill="#2a2a2a"/><ellipse cx="24" cy="28" rx="10" ry="8" fill="#1a1a1a"/><path d="M16 26 Q18 22 20 26" stroke="#FF6B35" stroke-width="2" fill="none"/><path d="M24 26 Q26 22 28 26" stroke="#FF6B35" stroke-width="2" fill="none"/><path d="M32 26 Q34 22 36 26" stroke="#FF4500" stroke-width="2" fill="none"/><ellipse cx="24" cy="30" rx="6" ry="4" fill="#FFD700" opacity="0.3"/></svg>',
      'smoker': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="10" y="8" width="28" height="36" rx="2" fill="#2F2F2F"/><rect x="12" y="10" width="24" height="32" rx="1" fill="#1a1a1a"/><rect x="14" y="12" width="20" height="10" fill="#333"/><rect x="14" y="24" width="20" height="10" fill="#333"/><line x1="14" y1="17" x2="34" y2="17" stroke="#444" stroke-width="1"/><line x1="14" y1="22" x2="34" y2="22" stroke="#444" stroke-width="1"/><line x1="14" y1="29" x2="34" y2="29" stroke="#444" stroke-width="1"/><line x1="14" y1="34" x2="34" y2="34" stroke="#444" stroke-width="1"/><path d="M20 6 Q22 2 24 6" stroke="#888" stroke-width="1.5" fill="none"/><path d="M26 4 Q28 0 30 4" stroke="#888" stroke-width="1.5" fill="none"/><rect x="16" y="38" width="16" height="4" rx="1" fill="#3a3a3a"/><circle cx="24" cy="40" r="2" fill="#666"/></svg>',
      'outdoor-sink': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="6" y="14" width="36" height="28" rx="2" fill="#A0A0A0"/><rect x="8" y="16" width="32" height="24" rx="1" fill="#C0C0C0"/><rect x="10" y="18" width="28" height="20" fill="#666"/><rect x="22" y="6" width="4" height="12" rx="2" fill="#888"/><ellipse cx="24" cy="6" rx="4" ry="2" fill="#777"/><circle cx="24" cy="30" r="2" fill="#444"/><rect x="22" y="32" width="4" height="4" fill="#333"/></svg>',
      'outdoor-ice-maker': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="10" y="6" width="28" height="36" rx="2" fill="#808080"/><rect x="12" y="8" width="24" height="12" rx="1" fill="#B0E0E6"/><rect x="12" y="22" width="24" height="18" rx="1" fill="#696969"/><rect x="14" y="24" width="20" height="14" fill="#555"/><polygon points="18,28 22,28 20,32" fill="#87CEEB"/><polygon points="26,28 30,28 28,32" fill="#87CEEB"/><polygon points="22,34 26,34 24,38" fill="#87CEEB"/><circle cx="34" cy="14" r="2" fill="#4CAF50"/><text x="24" y="14" font-size="5" fill="#4682B4" text-anchor="middle"></text></svg>',
      'access-door': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="8" y="8" width="32" height="32" rx="2" fill="#696969"/><rect x="10" y="10" width="28" height="28" rx="1" fill="#808080"/><rect x="12" y="12" width="24" height="24" fill="#5a5a5a"/><rect x="32" y="22" width="3" height="6" rx="1" fill="#444"/></svg>',
      'trash-drawer': '<svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><rect x="8" y="12" width="32" height="28" rx="2" fill="#696969"/><rect x="10" y="14" width="28" height="24" rx="1" fill="#808080"/><rect x="12" y="16" width="24" height="20" fill="#5a5a5a"/><rect x="20" y="36" width="8" height="2" rx="1" fill="#444"/><path d="M18 22 L24 22 L26 32 L16 32 Z" fill="#333"/><path d="M24 22 L30 22 L32 32 L26 32 Z" fill="#444"/></svg>'
    };

    // Map sized and variant cabinet types to base icons (reuse icons for different sizes)
    const CABINET_ICON_MAPPINGS = {
      // Base cabinet sizes - all use base-cabinet icon
      'base-cabinet-12': 'base-cabinet', 'base-cabinet-15': 'base-cabinet', 'base-cabinet-18': 'base-cabinet',
      'base-cabinet-21': 'base-cabinet', 'base-cabinet-24': 'base-cabinet', 'base-cabinet-27': 'base-cabinet',
      'base-cabinet-30': 'base-cabinet', 'base-cabinet-33': 'base-cabinet', 'base-cabinet-36': 'base-cabinet',
      'base-cabinet-42': 'base-cabinet', 'base-cabinet-48': 'base-cabinet',
      // Wall cabinet sizes - all use wall-cabinet icon
      'wall-cabinet-12': 'wall-cabinet', 'wall-cabinet-15': 'wall-cabinet', 'wall-cabinet-18': 'wall-cabinet',
      'wall-cabinet-21': 'wall-cabinet', 'wall-cabinet-24': 'wall-cabinet', 'wall-cabinet-27': 'wall-cabinet',
      'wall-cabinet-30': 'wall-cabinet', 'wall-cabinet-33': 'wall-cabinet', 'wall-cabinet-36': 'wall-cabinet',
      'wall-cabinet-42': 'wall-cabinet',
      // Tall wall cabinets (36"H) - use wall-cabinet icon
      'wall-cabinet-12-tall': 'wall-cabinet', 'wall-cabinet-15-tall': 'wall-cabinet', 'wall-cabinet-18-tall': 'wall-cabinet',
      'wall-cabinet-21-tall': 'wall-cabinet', 'wall-cabinet-24-tall': 'wall-cabinet', 'wall-cabinet-27-tall': 'wall-cabinet',
      'wall-cabinet-30-tall': 'wall-cabinet', 'wall-cabinet-33-tall': 'wall-cabinet', 'wall-cabinet-36-tall': 'wall-cabinet',
      // Extra-tall wall cabinets (42"H) - use wall-cabinet icon
      'wall-cabinet-12-xtall': 'wall-cabinet', 'wall-cabinet-15-xtall': 'wall-cabinet', 'wall-cabinet-18-xtall': 'wall-cabinet',
      'wall-cabinet-21-xtall': 'wall-cabinet', 'wall-cabinet-24-xtall': 'wall-cabinet', 'wall-cabinet-27-xtall': 'wall-cabinet',
      'wall-cabinet-30-xtall': 'wall-cabinet', 'wall-cabinet-33-xtall': 'wall-cabinet', 'wall-cabinet-36-xtall': 'wall-cabinet',
      // Tall cabinet sizes
      'tall-cabinet-18': 'tall-cabinet', 'tall-cabinet-24': 'tall-cabinet', 'tall-cabinet-30': 'tall-cabinet',
      'tall-cabinet-36': 'tall-cabinet',
      // Oven cabinets - use tall-cabinet icon
      'single-oven-cabinet': 'tall-cabinet',
      'tall-oven': 'tall-cabinet',
      'double-oven-cabinet': 'tall-cabinet',
      // Corner cabinets variants
      'blind-corner': 'corner-cabinet',
      'blind-corner-base': 'corner-cabinet',
      'blind-corner-wall': 'corner-cabinet',
      // Drawer base sizes
      'drawer-base-12': 'drawer-base', 'drawer-base-15': 'drawer-base', 'drawer-base-18': 'drawer-base',
      'drawer-base-24': 'drawer-base', 'drawer-base-30': 'drawer-base', 'drawer-base-36': 'drawer-base',
      // Sink base sizes
      'sink-base-30': 'sink-base', 'sink-base-33': 'sink-base', 'sink-base-36': 'sink-base',
      'sink-base-42': 'sink-base'
    };

    // Add cabinet icons to ELEMENT_ICONS (reference base icons)
    Object.entries(CABINET_ICON_MAPPINGS).forEach(([variantType, baseType]) => {
      if (ELEMENT_ICONS[baseType] && !ELEMENT_ICONS[variantType]) {
        ELEMENT_ICONS[variantType] = ELEMENT_ICONS[baseType];
      }
    });

    // Industry standard cabinet dimensions:
    // Base cabinets: 24" deep (2 ft), 34.5" tall (2.875 ft) - top-down view shows depth as 'height'
    // Wall cabinets: 12" deep (1 ft), 30-42" tall, mounted 54" from floor
    // Countertop overhang: 1.5" front (0.125 ft)
    // Total counter depth: 25.5" (2.125 ft) with overhang
    const ELEMENT_TYPES = {
      cabinets: [
        // Base cabinets: 24" (2 ft) deep - this is the 'height' in top-down view
        { type: 'base-cabinet', width: 3, height: 2, color: '#8B7355', label: 'Base Cabinet 36"' },
        { type: 'drawer-base', width: 1.5, height: 2, color: '#8B7355', label: 'Drawer Base 18"' },
        { type: 'sink-base', width: 3, height: 2, color: '#8B7355', label: 'Sink Base 36"' },
        // Wall cabinets: 12" (1 ft) deep - this is the 'height' in top-down view
        { type: 'wall-cabinet', width: 3, height: 1, color: '#9B8465', label: 'Wall Cabinet 36"' },
        { type: 'microwave-cabinet', width: 2.5, height: 1.25, color: '#8B7355', label: 'Microwave Shelf' },
        { type: 'above-microwave-cabinet', width: 2.5, height: 1, color: '#8B7355', label: 'Above Microwave' },
        // Tall/Pantry cabinets: 24" (2 ft) deep, 84-96" tall
        { type: 'tall-cabinet', width: 2, height: 2, color: '#8B7355', label: 'Tall Cabinet 24"' },
        { type: 'fridge-cabinet', width: 3, height: 2, color: '#8B7355', label: 'Fridge Cabinet 36"' },
        // Oven cabinets: 30" wide, 24" deep
        { type: 'single-oven-cabinet', width: 2.5, height: 2, color: '#8B7355', label: 'Single Oven Cabinet 30"' },
        { type: 'tall-oven', width: 2.5, height: 2, color: '#8B7355', label: 'Tall Oven Cabinet 30"' },
        { type: 'double-oven-cabinet', width: 2.5, height: 2, color: '#8B7355', label: 'Double Oven Cabinet 30"' },
        // Corner cabinets: 36"x36" footprint (diagonal or lazy susan)
        { type: 'corner-cabinet', width: 3, height: 3, color: '#7B6545', label: 'Corner Cabinet' },
        { type: 'lazy-susan', width: 3, height: 3, color: '#7B6545', label: 'Lazy Susan' },
        { type: 'blind-corner', width: 3.5, height: 2, color: '#7B6545', label: 'Blind Corner 42"' },
        // Island: configurable, default 6ft x 3ft (24" deep cabinets on each side)
        { type: 'island', width: 6, height: 3, color: '#6B5545', label: 'Island 72"x36"' },
        // Sized base cabinets (width in inches, depth always 24"/2ft)
        { type: 'base-cabinet-12', width: 1, height: 2, color: '#8B7355', label: 'Base Cabinet 12"' },
        { type: 'base-cabinet-15', width: 1.25, height: 2, color: '#8B7355', label: 'Base Cabinet 15"' },
        { type: 'base-cabinet-18', width: 1.5, height: 2, color: '#8B7355', label: 'Base Cabinet 18"' },
        { type: 'base-cabinet-21', width: 1.75, height: 2, color: '#8B7355', label: 'Base Cabinet 21"' },
        { type: 'base-cabinet-24', width: 2, height: 2, color: '#8B7355', label: 'Base Cabinet 24"' },
        { type: 'base-cabinet-27', width: 2.25, height: 2, color: '#8B7355', label: 'Base Cabinet 27"' },
        { type: 'base-cabinet-30', width: 2.5, height: 2, color: '#8B7355', label: 'Base Cabinet 30"' },
        { type: 'base-cabinet-33', width: 2.75, height: 2, color: '#8B7355', label: 'Base Cabinet 33"' },
        // Sized drawer base cabinets (width in inches, depth always 24"/2ft)
        { type: 'drawer-base-12', width: 1, height: 2, color: '#8B7355', label: 'Drawer Base 12"' },
        { type: 'drawer-base-15', width: 1.25, height: 2, color: '#8B7355', label: 'Drawer Base 15"' },
        { type: 'drawer-base-18', width: 1.5, height: 2, color: '#8B7355', label: 'Drawer Base 18"' },
        { type: 'drawer-base-21', width: 1.75, height: 2, color: '#8B7355', label: 'Drawer Base 21"' },
        { type: 'drawer-base-24', width: 2, height: 2, color: '#8B7355', label: 'Drawer Base 24"' },
        { type: 'drawer-base-30', width: 2.5, height: 2, color: '#8B7355', label: 'Drawer Base 30"' },
        { type: 'drawer-base-36', width: 3, height: 2, color: '#8B7355', label: 'Drawer Base 36"' },
        // Sized sink base cabinets (width in inches, depth always 24"/2ft)
        { type: 'sink-base-30', width: 2.5, height: 2, color: '#8B7355', label: 'Sink Base 30"' },
        { type: 'sink-base-33', width: 2.75, height: 2, color: '#8B7355', label: 'Sink Base 33"' },
        { type: 'sink-base-36', width: 3, height: 2, color: '#8B7355', label: 'Sink Base 36"' },
        { type: 'sink-base-42', width: 3.5, height: 2, color: '#8B7355', label: 'Sink Base 42"' },
        { type: 'sink-base-48', width: 4, height: 2, color: '#8B7355', label: 'Sink Base 48"' },
        // Sized wall cabinets (width in inches, depth always 12"/1ft)
        { type: 'wall-cabinet-12', width: 1, height: 1, color: '#9B8465', label: 'Wall Cabinet 12"' },
        { type: 'wall-cabinet-15', width: 1.25, height: 1, color: '#9B8465', label: 'Wall Cabinet 15"' },
        { type: 'wall-cabinet-18', width: 1.5, height: 1, color: '#9B8465', label: 'Wall Cabinet 18"' },
        { type: 'wall-cabinet-24', width: 2, height: 1, color: '#9B8465', label: 'Wall Cabinet 24"' },
        { type: 'wall-cabinet-30', width: 2.5, height: 1, color: '#9B8465', label: 'Wall Cabinet 30"' },
        { type: 'wall-cabinet-36', width: 3, height: 1, color: '#9B8465', label: 'Wall Cabinet 36"' },
        { type: 'wall-cabinet-42', width: 3.5, height: 1, color: '#9B8465', label: 'Wall Cabinet 42"' },
        // Tall wall cabinets (36" height, for 42" clearance layouts)
        { type: 'wall-cabinet-12-tall', width: 1, height: 1, color: '#9B8465', label: 'Wall 12"36"H', cabinetHeight: 3 },
        { type: 'wall-cabinet-18-tall', width: 1.5, height: 1, color: '#9B8465', label: 'Wall 18"36"H', cabinetHeight: 3 },
        { type: 'wall-cabinet-24-tall', width: 2, height: 1, color: '#9B8465', label: 'Wall 24"36"H', cabinetHeight: 3 },
        { type: 'wall-cabinet-30-tall', width: 2.5, height: 1, color: '#9B8465', label: 'Wall 30"36"H', cabinetHeight: 3 },
        { type: 'wall-cabinet-36-tall', width: 3, height: 1, color: '#9B8465', label: 'Wall 36"36"H', cabinetHeight: 3 },
        // Extra-tall wall cabinets (42" height, for stacked to ceiling)
        { type: 'wall-cabinet-12-xtall', width: 1, height: 1, color: '#9B8465', label: 'Wall 12"42"H', cabinetHeight: 3.5 },
        { type: 'wall-cabinet-18-xtall', width: 1.5, height: 1, color: '#9B8465', label: 'Wall 18"42"H', cabinetHeight: 3.5 },
        { type: 'wall-cabinet-24-xtall', width: 2, height: 1, color: '#9B8465', label: 'Wall 24"42"H', cabinetHeight: 3.5 },
        { type: 'wall-cabinet-30-xtall', width: 2.5, height: 1, color: '#9B8465', label: 'Wall 30"42"H', cabinetHeight: 3.5 },
        { type: 'wall-cabinet-36-xtall', width: 3, height: 1, color: '#9B8465', label: 'Wall 36"42"H', cabinetHeight: 3.5 },
        // Sized tall/pantry cabinets
        { type: 'tall-cabinet-18', width: 1.5, height: 2, color: '#8B7355', label: 'Tall Cabinet 18"' },
        { type: 'tall-cabinet-24', width: 2, height: 2, color: '#8B7355', label: 'Tall Cabinet 24"' },
        { type: 'tall-cabinet-30', width: 2.5, height: 2, color: '#8B7355', label: 'Tall Cabinet 30"' },
        { type: 'tall-cabinet-36', width: 3, height: 2, color: '#8B7355', label: 'Tall Cabinet 36"' }
      ],
      surfaces: [
        // Standard countertop: 25.5" depth (2.125') with 1.5" overhang = 2.17' total
        // Quartz slabs are typically 126" x 63" (10.5' x 5.25') - seams needed after ~10'
        { type: 'countertop', width: 8, height: 2.17, color: '#708090', label: 'Countertop Run' },
        // Corner countertop: sits in corner, 2.17' x 2.17' (symmetrical)
        { type: 'countertop-corner', width: 2.17, height: 2.17, color: '#708090', label: 'Corner Counter' },
        // L-Counter and U-Counter for full kitchen layouts
        { type: 'countertop-l', width: 8, height: 6, color: '#708090', label: 'L-Counter', armWidth: 2.17 },
        { type: 'countertop-u', width: 8, height: 6, color: '#708090', label: 'U-Counter' },
        // Material-specific surfaces
        { type: 'surface-stainless', width: 4, height: 2, color: '#C0C0C0', label: 'Stainless Steel' },
        { type: 'surface-solid', width: 4, height: 2, color: '#E8E4E0', label: 'Solid Surface' },
        { type: 'surface-laminate', width: 4, height: 2, color: '#D4C4A8', label: 'Laminate/Formica' },
        { type: 'surface-butcherblock', width: 3, height: 2, color: '#C4A76C', label: 'Butcher Block' },
        { type: 'surface-concrete', width: 4, height: 2, color: '#808080', label: 'Concrete' },
        // Backsplash options with different heights
        { type: 'backsplash', width: 6, height: 0.08, verticalHeight: 1.5, color: '#B8860B', label: 'Full Backsplash (18")' },
        { type: 'backsplash', width: 6, height: 0.08, verticalHeight: 0.5, color: '#B8860B', label: 'Raised Backsplash (6")' },
        { type: 'backsplash', width: 6, height: 0.08, verticalHeight: 0.333, color: '#B8860B', label: 'Standard Backsplash (4")' },
        { type: 'backsplash', width: 6, height: 0.08, verticalHeight: 1.5, tileType: 'subway', color: '#FFFFFF', label: 'Subway Tile Backsplash' },
        { type: 'backsplash', width: 6, height: 0.08, verticalHeight: 1.5, tileType: 'mosaic', color: '#4A90A4', label: 'Mosaic Tile Backsplash' },
        { type: 'flooring', width: 5, height: 5, color: '#D2691E', label: 'Flooring' },
        { type: 'tile', width: 4, height: 4, color: '#CCC', label: 'Tile Area' },
        // Stone Caps & Ledges (for pony walls, entryways, etc.)
        { type: 'wall-cap', width: 4, height: 0.5, color: '#708090', label: 'Wall Cap/Ledge', capHeight: 3.5, thickness: 0.125 },
        { type: 'bar-top', width: 6, height: 1.5, color: '#708090', label: 'Bar Top', capHeight: 3.5, thickness: 0.125 },
        // Stone Bezels & Surrounds (for niches, fireplaces)
        { type: 'niche-surround', width: 3, height: 4, color: '#708090', label: 'Niche Surround' },
        { type: 'fireplace-surround', width: 5, height: 4, color: '#708090', label: 'Fireplace Surround' },
        { type: 'fireplace-hearth', width: 5, height: 1.5, color: '#708090', label: 'Hearth' },
        { type: 'mantel', width: 5, height: 0.5, color: '#8B4513', label: 'Mantel/Shelf' },
        // Window & Door Sills
        { type: 'window-sill', width: 3, height: 0.5, color: '#708090', label: 'Window Sill' },
        { type: 'threshold', width: 3, height: 0.33, color: '#708090', label: 'Door Threshold' }
      ],
      appliances: [
        { type: 'sink', width: 2.75, height: 1.83, color: '#C0C0C0', label: 'Single Sink', mountType: 'undermount' },
        { type: 'sink-double', width: 3, height: 1.83, color: '#C0C0C0', label: 'Double Sink', mountType: 'undermount' },
        { type: 'sink-farmhouse', width: 2.5, height: 1.75, color: '#F5F5DC', label: 'Farmhouse Sink', mountType: 'farmhouse' },
        { type: 'stove', width: 2.5, height: 2.17, color: '#2F2F2F', label: 'Freestanding Range' },
        { type: 'slide-in-range', width: 2.5, height: 2.17, color: '#2F2F2F', label: 'Slide-In Range' },
        { type: 'cooktop', width: 2.5, height: 1.75, color: '#1a1a1a', label: 'Cooktop' },
        { type: 'refrigerator', width: 3, height: 2.5, color: '#A9A9A9', label: 'Refrigerator' },
        { type: 'dishwasher', width: 2, height: 2, color: '#808080', label: 'Dishwasher' },
        { type: 'microwave', width: 2.5, height: 1.33, color: '#4a4a4a', label: 'Microwave' },
        { type: 'range-hood', width: 2.5, height: 1.67, color: '#696969', label: 'Range Hood' },
        { type: 'oven', width: 2.5, height: 2.08, color: '#3a3a3a', label: 'Wall Oven' },
        { type: 'wall-oven-double', width: 2.5, height: 2.08, color: '#3a3a3a', label: 'Double Wall Oven' },
        // Specialty Kitchen Appliances
        { type: 'wine-cooler', width: 2, height: 2, color: '#4a4a4a', label: 'Wine Cooler 24"' },
        { type: 'beverage-center', width: 2, height: 2, color: '#4a4a4a', label: 'Beverage Center' },
        { type: 'ice-maker', width: 1.25, height: 2, color: '#808080', label: 'Ice Maker 15"' },
        { type: 'warming-drawer', width: 2.5, height: 0.83, color: '#3a3a3a', label: 'Warming Drawer 30"' },
        { type: 'trash-compactor', width: 1.25, height: 2, color: '#696969', label: 'Trash Compactor' },
        { type: 'coffee-system', width: 2, height: 1.5, color: '#3a3a3a', label: 'Built-in Coffee' },
        { type: 'steam-oven', width: 2, height: 1.5, color: '#4a4a4a', label: 'Steam Oven 24"' },
        { type: 'speed-oven', width: 2, height: 1.5, color: '#4a4a4a', label: 'Speed Oven 24"' },
        // Outdoor Kitchen Appliances
        { type: 'grill-builtin', width: 3, height: 2.5, color: '#2F2F2F', label: 'Built-in Grill 36"' },
        { type: 'grill-42', width: 3.5, height: 2.5, color: '#2F2F2F', label: 'Built-in Grill 42"' },
        { type: 'side-burner', width: 1, height: 2, color: '#3a3a3a', label: 'Side Burner' },
        { type: 'power-burner', width: 1.5, height: 2, color: '#3a3a3a', label: 'Power Burner' },
        { type: 'outdoor-fridge', width: 2, height: 2.5, color: '#A9A9A9', label: 'Outdoor Fridge' },
        { type: 'kegerator', width: 2, height: 2.5, color: '#4a4a4a', label: 'Kegerator' },
        { type: 'pizza-oven', width: 2.5, height: 2.5, color: '#8B4513', label: 'Pizza Oven' },
        { type: 'smoker', width: 2, height: 2.5, color: '#2F2F2F', label: 'Built-in Smoker' },
        { type: 'outdoor-sink', width: 2, height: 2, color: '#C0C0C0', label: 'Outdoor Sink' },
        { type: 'outdoor-ice-maker', width: 1.25, height: 2, color: '#808080', label: 'Outdoor Ice Maker' },
        { type: 'access-door', width: 1.75, height: 2, color: '#696969', label: 'Access Door' },
        { type: 'trash-drawer', width: 1.5, height: 2, color: '#696969', label: 'Trash Drawer' }
      ],
      structure: [
        // Doors & Entryways
        { type: 'door', width: 3, height: 0.5, color: '#DEB887', label: 'Standard Door' },
        { type: 'double-door', width: 5, height: 0.5, color: '#D2B48C', label: 'Double Door' },
        { type: 'sliding-door', width: 6, height: 0.5, color: '#BC8F8F', label: 'Sliding Door' },
        { type: 'glass-door', width: 3, height: 0.5, color: '#ADD8E6', label: 'Glass Door' },
        { type: 'french-door', width: 5, height: 0.5, color: '#F5F5DC', label: 'French Door' },
        { type: 'entry-archway', width: 4, height: 0.5, color: '#DAA520', label: 'Archway' },
        { type: 'garage-door', width: 8, height: 0.5, color: '#A9A9A9', label: 'Garage Door' },
        // Windows
        { type: 'window', width: 4, height: 0.5, color: '#87CEEB', label: 'Window' },
        { type: 'window-large', width: 6, height: 0.5, color: '#87CEEB', label: 'Picture Window' },
        { type: 'window-bay', width: 5, height: 1, color: '#87CEEB', label: 'Bay Window' },
        // Trim & Molding
        { type: 'crown-molding', width: 10, height: 0.25, color: '#F5F5F5', label: 'Crown Molding' },
        { type: 'baseboard', width: 10, height: 0.15, color: '#F5F5F5', label: 'Baseboard' },
        { type: 'chair-rail', width: 10, height: 0.1, color: '#F5F5F5', label: 'Chair Rail' },
        // Walls - Residential
        { type: 'wall', width: 0.5, height: 8, color: '#555', label: 'Wall (Drywall)' },
        { type: 'wall-wood-2x4', width: 0.33, height: 8, color: '#8B7355', label: 'Wall (2x4 Wood)' },
        { type: 'wall-wood-2x6', width: 0.5, height: 8, color: '#8B6914', label: 'Wall (2x6 Wood)' },
        // Walls - Commercial
        { type: 'wall-steel', width: 0.33, height: 10, color: '#708090', label: 'Wall (Steel Frame)' },
        { type: 'wall-aluminum', width: 0.33, height: 10, color: '#C0C0C0', label: 'Wall (Aluminum)' },
        // Walls - Masonry
        { type: 'wall-concrete', width: 0.67, height: 8, color: '#808080', label: 'Wall (Concrete)' },
        { type: 'wall-brick', width: 0.67, height: 8, color: '#B22222', label: 'Wall (Brick)' },
        { type: 'wall-block', width: 0.67, height: 8, color: '#696969', label: 'Wall (CMU Block)' },
        // Structural - Beams & Columns
        { type: 'steel-beam', width: 8, height: 0.67, color: '#4A4A4A', label: 'Steel I-Beam' },
        { type: 'steel-column', width: 0.5, height: 0.5, color: '#4A4A4A', label: 'Steel Column' },
        { type: 'wood-beam', width: 6, height: 0.5, color: '#8B6914', label: 'Wood Beam' },
        { type: 'wood-post', width: 0.33, height: 0.33, color: '#8B6914', label: 'Wood Post 4x4' },
        { type: 'concrete-beam', width: 8, height: 0.83, color: '#707070', label: 'Concrete Beam' },
        { type: 'concrete-column', width: 1, height: 1, color: '#707070', label: 'Concrete Column' },
        { type: 'header', width: 4, height: 0.33, color: '#CD853F', label: 'Header/Lintel' },
        { type: 'lvl-beam', width: 8, height: 0.92, color: '#DEB887', label: 'LVL Beam' },
        // Pony Walls & Half Walls (for stone caps)
        { type: 'pony-wall', width: 4, height: 0.5, color: '#888', label: 'Pony Wall', wallHeight: 3.5 },
        { type: 'pony-wall-bar', width: 6, height: 0.5, color: '#888', label: 'Bar Height Wall', wallHeight: 3.5 },
        { type: 'knee-wall', width: 4, height: 0.5, color: '#888', label: 'Knee Wall', wallHeight: 2.5 },
        // Niches & Recesses (for stone bezels/surrounds)
        { type: 'wall-niche', width: 3, height: 4, color: '#444', label: 'Wall Niche' },
        { type: 'fireplace-niche', width: 4, height: 3, color: '#333', label: 'Fireplace Recess' },
        { type: 'tv-niche', width: 5, height: 3, color: '#222', label: 'TV Recess' },
        { type: 'shower-niche', width: 1, height: 1.5, color: '#555', label: 'Shower Niche' },
        // Shower Components
        { type: 'shower-pan', width: 4, height: 3, color: '#D0D0D0', label: 'Shower Pan' },
        { type: 'shower-curb', width: 4, height: 0.5, color: '#808080', label: 'Shower Curb' },
        { type: 'shower-wall', width: 4, height: 0.35, color: '#B0B0B0', label: 'Shower Wall Panel' },
        // Tile Surfaces
        { type: 'wall-tile', width: 4, height: 4, color: '#CCC', label: 'Wall Tile Panel' },
        { type: 'accent-wall', width: 6, height: 0.5, color: '#888', label: 'Accent Wall' },
        // ADA Accessibility
        { type: 'grab-bar-24', width: 2, height: 0.25, color: '#C0C0C0', label: 'Grab Bar 24"' },
        { type: 'grab-bar-36', width: 3, height: 0.25, color: '#C0C0C0', label: 'Grab Bar 36"' },
        { type: 'grab-bar-42', width: 3.5, height: 0.25, color: '#C0C0C0', label: 'Grab Bar 42"' }
      ],
      bathroom: [
        // Toilets
        { type: 'toilet', width: 1.5, height: 2.3, color: '#FFFFFF', label: 'Toilet (Elongated)' },
        { type: 'toilet-round', width: 1.5, height: 2, color: '#FFFFFF', label: 'Toilet (Round)' },
        { type: 'toilet-wall', width: 1.5, height: 1.8, color: '#FFFFFF', label: 'Wall-Hung Toilet' },
        { type: 'bidet', width: 1.5, height: 2, color: '#FFFFFF', label: 'Bidet' },
        // Bathtubs
        { type: 'bathtub', width: 5, height: 2.7, color: '#F5F5F5', label: 'Alcove Tub (60")' },
        { type: 'bathtub-freestanding', width: 5.5, height: 2.5, color: '#FFFFFF', label: 'Freestanding Tub' },
        { type: 'bathtub-corner', width: 5, height: 5, color: '#F5F5F5', label: 'Corner Tub' },
        { type: 'bathtub-walk-in', width: 4.5, height: 2.5, color: '#F0F0F0', label: 'Walk-in Tub' },
        // Vanities
        { type: 'vanity-24', width: 2, height: 1.75, color: '#8B7355', label: 'Vanity 24"' },
        { type: 'vanity-30', width: 2.5, height: 1.75, color: '#8B7355', label: 'Vanity 30"' },
        { type: 'vanity-36', width: 3, height: 1.75, color: '#8B7355', label: 'Vanity 36"' },
        { type: 'vanity-48', width: 4, height: 1.75, color: '#8B7355', label: 'Vanity 48"' },
        { type: 'vanity-60', width: 5, height: 1.75, color: '#8B7355', label: 'Double Vanity 60"' },
        { type: 'vanity-72', width: 6, height: 1.75, color: '#8B7355', label: 'Double Vanity 72"' },
        { type: 'vanity-double-60', width: 5, height: 1.75, color: '#8B7355', label: 'Double Vanity 60" (His/Hers)' },
        { type: 'vanity-double-72', width: 6, height: 1.75, color: '#8B7355', label: 'Double Vanity 72" (His/Hers)' },
        { type: 'vanity-double-84', width: 7, height: 1.75, color: '#8B7355', label: 'Double Vanity 84" (His/Hers)' },
        { type: 'vanity-hishers-96', width: 8, height: 1.75, color: '#8B7355', label: 'His/Hers Vanity 96" w/ Table' },
        { type: 'vanity-hishers-108', width: 9, height: 1.75, color: '#8B7355', label: 'His/Hers Vanity 108" w/ Table' },
        { type: 'powder-table', width: 2, height: 1.75, color: '#A08060', label: 'Powder Table' },
        { type: 'makeup-vanity', width: 3, height: 1.75, color: '#8B7355', label: 'Makeup Vanity 36"' },
        { type: 'pedestal-sink', width: 1.5, height: 1.5, color: '#FFFFFF', label: 'Pedestal Sink' },
        { type: 'linen-closet', width: 2, height: 1.5, color: '#8B7355', label: 'Linen Closet' },
        { type: 'linen-tower', width: 1.5, height: 1.5, color: '#8B7355', label: 'Linen Tower' },
        // Shower Components
        { type: 'shower-base-36', width: 3, height: 3, color: '#D0D0D0', label: 'Shower Base 36x36' },
        { type: 'shower-base-48', width: 4, height: 3, color: '#D0D0D0', label: 'Shower Base 48x36' },
        { type: 'shower-base-60', width: 5, height: 3, color: '#D0D0D0', label: 'Shower Base 60x36' },
        { type: 'shower-bench', width: 2, height: 1.5, color: '#A0A0A0', label: 'Shower Bench' },
        { type: 'shower-glass', width: 3, height: 0.15, color: '#B8E0FF', label: 'Glass Panel' },
        { type: 'shower-door', width: 2.5, height: 0.15, color: '#C4E8FF', label: 'Shower Door' },
        // Accessories
        { type: 'mirror', width: 3, height: 0.15, color: '#E8E8FF', label: 'Mirror' },
        { type: 'medicine-cabinet', width: 2, height: 0.5, color: '#C0C0C0', label: 'Medicine Cabinet' },
        { type: 'towel-bar', width: 2, height: 0.15, color: '#C0C0C0', label: 'Towel Bar' },
        { type: 'toilet-paper', width: 0.5, height: 0.5, color: '#A0A0A0', label: 'TP Holder' }
      ],
      laundry: [
        { type: 'washer', width: 2.3, height: 2.3, color: '#E8E8E8', label: 'Washer' },
        { type: 'dryer', width: 2.3, height: 2.3, color: '#E0E0E0', label: 'Dryer' },
        { type: 'washer-dryer-stack', width: 2.3, height: 2.3, color: '#E8E8E8', label: 'Stacked W/D' },
        { type: 'utility-sink', width: 2, height: 2, color: '#D0D0D0', label: 'Utility Sink' },
        { type: 'laundry-sink', width: 2, height: 1.75, color: '#E0E0E0', label: 'Laundry Sink' },
        { type: 'laundry-cabinet', width: 3, height: 2, color: '#8B7355', label: 'Laundry Cabinet' },
        { type: 'ironing-board', width: 1, height: 4, color: '#C0C0C0', label: 'Ironing Board' },
        { type: 'drying-rack', width: 2, height: 3, color: '#A0A0A0', label: 'Drying Rack' }
      ],
      closet: [
        { type: 'closet-rod', width: 4, height: 0.15, color: '#C0C0C0', label: 'Closet Rod' },
        { type: 'closet-shelf', width: 4, height: 1, color: '#D4C4A8', label: 'Shelf' },
        { type: 'closet-drawers', width: 2, height: 2, color: '#8B7355', label: 'Drawer Unit' },
        { type: 'drawer-unit', width: 2, height: 2, color: '#8B7355', label: 'Drawer Unit (Alt)' },
        { type: 'shoe-rack', width: 3, height: 1.5, color: '#A0A0A0', label: 'Shoe Rack' },
        { type: 'closet-island', width: 3, height: 2, color: '#8B7355', label: 'Closet Island' },
        { type: 'jewelry-cabinet', width: 1.5, height: 1, color: '#8B7355', label: 'Jewelry Cabinet' },
        { type: 'jewelry-drawer', width: 2, height: 0.5, color: '#8B7355', label: 'Jewelry Drawer' },
        { type: 'tie-rack', width: 1.5, height: 2, color: '#A0A0A0', label: 'Tie/Belt Rack' },
        { type: 'full-mirror', width: 2, height: 0.15, color: '#E8E8FF', label: 'Full-Length Mirror' }
      ],
      // === FURNITURE ===
      furniture: [
        // Dining Tables
        { type: 'dining-table-rect', width: 6, height: 3, color: '#8B6914', label: 'Dining Table 72x36' },
        { type: 'dining-table-square', width: 4, height: 4, color: '#8B6914', label: 'Dining Table 48x48' },
        { type: 'dining-table-round', width: 4, height: 4, color: '#8B6914', label: 'Round Dining Table 48"' },
        { type: 'dining-table-oval', width: 6, height: 3.5, color: '#8B6914', label: 'Oval Dining Table 72x42' },
        { type: 'breakfast-table', width: 3, height: 3, color: '#A08060', label: 'Breakfast Table 36"' },
        { type: 'pub-table', width: 2.5, height: 2.5, color: '#6B4423', label: 'Pub/Bar Table 30"' },
        // Dining Chairs
        { type: 'dining-chair', width: 1.5, height: 1.5, color: '#8B7355', label: 'Dining Chair' },
        { type: 'armchair', width: 2, height: 2, color: '#6B5545', label: 'Armchair' },
        { type: 'bar-stool', width: 1.25, height: 1.25, color: '#8B7355', label: 'Bar Stool' },
        { type: 'bench', width: 4, height: 1.5, color: '#8B6914', label: 'Bench 48"' },
        // Kitchen/Breakfast Tables
        { type: 'kitchen-table', width: 4, height: 2.5, color: '#A08060', label: 'Kitchen Table 48x30' },
        { type: 'cafe-table', width: 2.5, height: 2.5, color: '#6B4423', label: 'Cafe Table 30"' },
        // Living Room Seating
        { type: 'sofa-3seat', width: 7, height: 3, color: '#5C4033', label: '3-Seat Sofa 84"' },
        { type: 'sofa-2seat', width: 5, height: 3, color: '#5C4033', label: 'Loveseat 60"' },
        { type: 'sectional-l', width: 8, height: 8, color: '#5C4033', label: 'L-Sectional' },
        { type: 'sectional-u', width: 10, height: 6, color: '#5C4033', label: 'U-Sectional' },
        { type: 'accent-chair', width: 2.5, height: 2.5, color: '#8B6914', label: 'Accent Chair' },
        { type: 'recliner', width: 3, height: 3, color: '#5C4033', label: 'Recliner' },
        { type: 'ottoman', width: 2, height: 2, color: '#6B5545', label: 'Ottoman' },
        // Coffee & Side Tables
        { type: 'coffee-table-rect', width: 4, height: 2, color: '#8B6914', label: 'Coffee Table 48x24' },
        { type: 'coffee-table-round', width: 3, height: 3, color: '#8B6914', label: 'Round Coffee Table 36"' },
        { type: 'side-table', width: 2, height: 2, color: '#8B7355', label: 'Side Table 24"' },
        { type: 'console-table', width: 4, height: 1.25, color: '#8B6914', label: 'Console Table 48x15' },
        { type: 'end-table', width: 2, height: 2, color: '#8B7355', label: 'End Table' },
        // Entertainment
        { type: 'tv-stand', width: 5, height: 1.5, color: '#4A4A4A', label: 'TV Stand 60"' },
        { type: 'entertainment-center', width: 6, height: 2, color: '#5C4033', label: 'Entertainment Center' },
        { type: 'bookshelf', width: 3, height: 1, color: '#8B7355', label: 'Bookshelf 36"' },
        { type: 'bookshelf-tall', width: 3, height: 1.5, color: '#8B7355', label: 'Tall Bookshelf 36"' },
        // Bedroom
        { type: 'bed-king', width: 6.5, height: 6.75, color: '#D4C4A8', label: 'King Bed 76x80' },
        { type: 'bed-queen', width: 5, height: 6.75, color: '#D4C4A8', label: 'Queen Bed 60x80' },
        { type: 'bed-full', width: 4.5, height: 6.25, color: '#D4C4A8', label: 'Full Bed 54x75' },
        { type: 'bed-twin', width: 3.25, height: 6.25, color: '#D4C4A8', label: 'Twin Bed 38x75' },
        { type: 'nightstand', width: 2, height: 1.5, color: '#8B7355', label: 'Nightstand 24"' },
        { type: 'dresser', width: 5, height: 1.5, color: '#8B7355', label: 'Dresser 60"' },
        { type: 'chest-drawers', width: 3, height: 1.5, color: '#8B7355', label: 'Chest of Drawers' },
        { type: 'wardrobe', width: 4, height: 2, color: '#6B5545', label: 'Wardrobe 48"' },
        // Office
        { type: 'desk', width: 5, height: 2.5, color: '#8B6914', label: 'Desk 60x30' },
        { type: 'desk-l', width: 5, height: 5, color: '#8B6914', label: 'L-Shaped Desk' },
        { type: 'office-chair', width: 2, height: 2, color: '#404040', label: 'Office Chair' },
        { type: 'filing-cabinet', width: 1.25, height: 2, color: '#606060', label: 'Filing Cabinet' }
      ],
      // === DECOR & SHELVING ===
      decor: [
        // Wall Shelving
        { type: 'floating-shelf', width: 3, height: 0.75, color: '#A08060', label: 'Floating Shelf 36"' },
        { type: 'floating-shelf-24', width: 2, height: 0.75, color: '#A08060', label: 'Floating Shelf 24"' },
        { type: 'floating-shelf-48', width: 4, height: 0.75, color: '#A08060', label: 'Floating Shelf 48"' },
        { type: 'corner-shelf', width: 1.5, height: 1.5, color: '#A08060', label: 'Corner Shelf' },
        { type: 'bracket-shelf', width: 3, height: 1, color: '#8B7355', label: 'Bracket Shelf 36"' },
        { type: 'ladder-shelf', width: 2.5, height: 1.5, color: '#8B6914', label: 'Ladder Shelf' },
        // Shadow Boxes & Display
        { type: 'shadow-box-sm', width: 1, height: 0.33, color: '#3A3A3A', label: 'Shadow Box 12"' },
        { type: 'shadow-box-md', width: 1.5, height: 0.33, color: '#3A3A3A', label: 'Shadow Box 18"' },
        { type: 'shadow-box-lg', width: 2, height: 0.33, color: '#3A3A3A', label: 'Shadow Box 24"' },
        { type: 'display-shelf', width: 3, height: 0.5, color: '#8B7355', label: 'Display Shelf' },
        { type: 'cube-shelf', width: 1, height: 1, color: '#A08060', label: 'Cube Shelf 12"' },
        { type: 'cube-shelf-set', width: 3, height: 3, color: '#A08060', label: 'Cube Shelf Set' },
        // Picture Frames & Art
        { type: 'picture-frame-sm', width: 0.67, height: 0.17, color: '#4A4A4A', label: 'Picture Frame 8x10' },
        { type: 'picture-frame-md', width: 1, height: 0.17, color: '#4A4A4A', label: 'Picture Frame 12x16' },
        { type: 'picture-frame-lg', width: 1.5, height: 0.17, color: '#4A4A4A', label: 'Picture Frame 18x24' },
        { type: 'picture-frame-xl', width: 2, height: 0.17, color: '#4A4A4A', label: 'Picture Frame 24x36' },
        { type: 'gallery-frame', width: 2.5, height: 0.17, color: '#3A3A3A', label: 'Gallery Frame 30"' },
        { type: 'canvas-art', width: 3, height: 0.17, color: '#F5F5DC', label: 'Canvas Art 36"' },
        { type: 'wall-art', width: 4, height: 0.17, color: '#E8E4E0', label: 'Wall Art 48"' },
        // Mirrors (Decorative)
        { type: 'decorative-mirror', width: 2, height: 0.17, color: '#C4D4E4', label: 'Decorative Mirror 24"' },
        { type: 'round-mirror', width: 2.5, height: 0.17, color: '#C4D4E4', label: 'Round Mirror 30"' },
        { type: 'floor-mirror', width: 2, height: 0.17, color: '#E8E8FF', label: 'Floor Mirror' },
        // Wall Decor
        { type: 'wall-clock', width: 1, height: 0.17, color: '#3A3A3A', label: 'Wall Clock 12"' },
        { type: 'wall-sconce', width: 0.5, height: 0.25, color: '#C0A080', label: 'Wall Sconce' },
        { type: 'wall-planter', width: 1, height: 0.5, color: '#228B22', label: 'Wall Planter' },
        // Plants & Greenery
        { type: 'potted-plant-sm', width: 1, height: 1, color: '#228B22', label: 'Small Plant' },
        { type: 'potted-plant-md', width: 1.5, height: 1.5, color: '#228B22', label: 'Medium Plant' },
        { type: 'potted-plant-lg', width: 2, height: 2, color: '#228B22', label: 'Large Plant' },
        { type: 'tree-indoor', width: 2.5, height: 2.5, color: '#2E8B57', label: 'Indoor Tree' },
        // Rugs & Floor Decor
        { type: 'area-rug-sm', width: 4, height: 6, color: '#8B6914', label: 'Area Rug 4x6' },
        { type: 'area-rug-md', width: 5, height: 8, color: '#8B6914', label: 'Area Rug 5x8' },
        { type: 'area-rug-lg', width: 8, height: 10, color: '#8B6914', label: 'Area Rug 8x10' },
        { type: 'runner-rug', width: 2.5, height: 8, color: '#8B6914', label: 'Runner Rug 2.5x8' },
        { type: 'round-rug', width: 6, height: 6, color: '#8B6914', label: 'Round Rug 6\'' }
      ],
      electrical: [
        // Outlets - NEC requires GFCI within 6' of water sources
        { type: 'outlet', width: 0.33, height: 0.25, color: '#F5F5DC', label: 'Duplex Outlet' },
        { type: 'outlet-gfci', width: 0.33, height: 0.25, color: '#F5F5DC', label: 'GFCI Outlet' },
        { type: 'outlet-20a', width: 0.33, height: 0.25, color: '#F5F5DC', label: '20A Outlet' },
        { type: 'outlet-240v', width: 0.5, height: 0.33, color: '#F5F5DC', label: '240V Outlet' },
        { type: 'outlet-usb', width: 0.33, height: 0.25, color: '#F5F5DC', label: 'USB Outlet' },
        // Switches
        { type: 'switch-single', width: 0.33, height: 0.25, color: '#F5F5DC', label: 'Light Switch' },
        { type: 'switch-dimmer', width: 0.33, height: 0.25, color: '#F5F5DC', label: 'Dimmer Switch' },
        { type: 'switch-3way', width: 0.33, height: 0.25, color: '#F5F5DC', label: '3-Way Switch' },
        { type: 'switch-smart', width: 0.33, height: 0.25, color: '#87CEEB', label: 'Smart Switch' },
        // Panels & Connections
        { type: 'panel-main', width: 2, height: 3, color: '#696969', label: 'Main Panel' },
        { type: 'panel-sub', width: 1.5, height: 2, color: '#696969', label: 'Sub Panel' },
        { type: 'junction-box', width: 0.33, height: 0.33, color: '#808080', label: 'Junction Box' },
        // Lighting (for placement reference)
        { type: 'recessed-light', width: 0.5, height: 0.5, color: '#FFD700', label: 'Recessed Light' },
        { type: 'pendant-light', width: 0.5, height: 0.5, color: '#FFD700', label: 'Pendant Light' },
        { type: 'under-cabinet-light', width: 2, height: 0.25, color: '#FFFACD', label: 'Under-Cabinet Light' },
        { type: 'light-fixture', width: 1, height: 1, color: '#FFD700', label: 'Ceiling Light' },
        { type: 'chandelier', width: 2, height: 2, color: '#FFD700', label: 'Chandelier' },
        { type: 'sconce', width: 0.5, height: 0.33, color: '#FFD700', label: 'Wall Sconce' },
        // HVAC/Mechanical
        { type: 'vent', width: 0.83, height: 0.5, color: '#C0C0C0', label: 'HVAC Vent' },
        { type: 'return-vent', width: 1.5, height: 0.5, color: '#A0A0A0', label: 'Return Vent' },
        { type: 'exhaust-fan', width: 1, height: 1, color: '#B0B0B0', label: 'Exhaust Fan' },
        { type: 'thermostat', width: 0.33, height: 0.5, color: '#E8E8E8', label: 'Thermostat' }
      ]
    };

    const FLOOR_PLANS = [
      { id: 'empty', name: 'Empty', walls: [] },
      { id: 'square', name: 'Square', walls: [
        { x: 0, y: 0, w: 1, h: 1, type: 'full' }
      ]},
      { id: 'l-shape', name: 'L-Shape', walls: [
        { x: 0, y: 0, w: 0.6, h: 1, type: 'rect' },
        { x: 0, y: 0, w: 1, h: 0.5, type: 'rect' }
      ]},
      { id: 'u-shape', name: 'U-Shape', walls: [
        { x: 0, y: 0, w: 0.3, h: 1, type: 'rect' },
        { x: 0.7, y: 0, w: 0.3, h: 1, type: 'rect' },
        { x: 0, y: 0.7, w: 1, h: 0.3, type: 'rect' }
      ]},
      { id: 'galley', name: 'Galley', walls: [
        { x: 0, y: 0, w: 0.2, h: 1, type: 'rect' },
        { x: 0.8, y: 0, w: 0.2, h: 1, type: 'rect' }
      ]},
      { id: 'open', name: 'Open Plan', walls: [
        { x: 0, y: 0.7, w: 0.4, h: 0.3, type: 'rect' }
      ]}
    ];

    // Helper function to resolve asset URLs for both file:// and http:// protocols
    function resolveAssetUrl(url) {
      if (!url) return null;
      if (url.startsWith('http') || url.startsWith('data:') || url.startsWith('blob:')) {
        return url;
      }
      // For local file:// protocol, construct absolute path
      if (window.location.protocol === 'file:') {
        const basePath = window.location.href.replace(/\/tools\/room-designer\/.*$/, '');
        return basePath + url;
      }
      // For http/https, relative paths work
      return url;
    }

    // Materials library using actual Surprise Granite product images + Daltile CTF Price List
    const MATERIALS = {
      granite: [
        // Daltile Natural Stone - Granite (CTF Price List Jan 2026)
        { id: 'daltile-absolute-black', name: 'Absolute Black', color: '#0a0a0a', sku: 'L75712121L', price: 10.45, brand: 'Daltile' },
        { id: 'daltile-alaska-white', name: 'Alaska White', color: '#E8E4E0', sku: 'L77612121L', price: 23.40, brand: 'Daltile' },
        { id: 'daltile-bianco-antico', name: 'Bianco Antico', color: '#E0D8D0', sku: 'L79912121L', price: 25.90, brand: 'Daltile' },
        { id: 'daltile-black-galaxy', name: 'Black Galaxy', color: '#1a1a2e', sku: 'L76712121L', price: 10.45, brand: 'Daltile' },
        { id: 'daltile-blue-pearl', name: 'Blue Pearl', color: '#3d4f6b', sku: 'L75812121L', price: 16.05, brand: 'Daltile' },
        { id: 'daltile-colonial-white', name: 'Colonial White', color: '#F0EBE5', sku: 'L79512121L', price: 23.40, brand: 'Daltile' },
        { id: 'daltile-delicatus-white', name: 'Delicatus White', color: '#FAF8F5', sku: 'L80812121L', price: 31.45, brand: 'Daltile' },
        { id: 'daltile-fantasy-brown', name: 'Fantasy Brown', color: '#C4B7A6', sku: 'L81212121L', price: 25.90, brand: 'Daltile' },
        { id: 'daltile-giallo-ornamental', name: 'Giallo Ornamental', color: '#C9B896', sku: 'L76012121L', price: 10.45, brand: 'Daltile' },
        { id: 'daltile-new-venetian-gold', name: 'New Venetian Gold', color: '#D4B878', sku: 'L76112121L', price: 10.45, brand: 'Daltile' },
        { id: 'daltile-river-white', name: 'River White', color: '#F0EBE5', sku: 'L80712121L', price: 23.40, brand: 'Daltile' },
        { id: 'daltile-santa-cecilia', name: 'Santa Cecilia', color: '#C8A878', sku: 'L76212121L', price: 10.45, brand: 'Daltile' },
        { id: 'daltile-steel-grey', name: 'Steel Grey', color: '#6B6B6B', sku: 'L78512121L', price: 10.45, brand: 'Daltile' },
        { id: 'daltile-typhoon-bordeaux', name: 'Typhoon Bordeaux', color: '#8B4A4A', sku: 'L79812121L', price: 25.90, brand: 'Daltile' },
        { id: 'daltile-uba-tuba', name: 'Uba Tuba', color: '#2A3A2A', sku: 'L76312121L', price: 5.80, brand: 'Daltile' },
        { id: 'daltile-white-ice', name: 'White Ice', color: '#F8F8F8', sku: 'L81112121L', price: 23.40, brand: 'Daltile' }
      ],
      quartz: [
        // Surprise Granite Collection
        { id: 'quartz-stellar-white', name: 'Stellar White', color: '#f5f5f5', price: 15.57, url: 'https://cdn.prod.website-files.com/6456ce4476abb25581fbad0c/6456ce4576abb21af6fbc914_msi-surfaces-quartz-surprise-granite-stellar-white-moment.webp', brand: 'MSI' },
        { id: 'quartz-shell-white', name: 'Shell White', color: '#faf8f5', price: 12.30, url: 'https://cdn.prod.website-files.com/6456ce4476abb25581fbad0c/6456ce4576abb28a6bfbc8cb_msi-surfaces-quartz-surprise-granite-shell-white-close-up.webp', brand: 'MSI' },
        { id: 'quartz-perla-white', name: 'Perla White', color: '#f0ece5', price: 22.95, url: 'https://cdn.prod.website-files.com/6456ce4476abb25581fbad0c/6456ce4576abb20436fbc89c_msi-surfaces-quartz-surprise-granite-perla-white-moment.webp', brand: 'MSI' },
        { id: 'quartz-stellar-gray', name: 'Stellar Gray', color: '#8a8a8a', price: 15.57, url: 'https://cdn.prod.website-files.com/6456ce4476abb25581fbad0c/6456ce4576abb2590afbc90f_msi-surfaces-quartz-surprise-granite-sstellar-gray-moment.webp', brand: 'MSI' },
        { id: 'quartz-calacatta', name: 'Calacatta Laurent', color: '#f8f6f0', price: 22.95, url: 'https://cdn.prod.website-files.com/6456ce4476abb25581fbad0c/6456ce4576abb294bffbc2da_dekton-surprise-granite-laurent-quartz-close-up.webp', brand: 'Dekton' },
        // MSI Premium Natural Quartz (Jan 2025 Price List) - with CDN images
        { id: 'msi-aruca-white', name: 'Aruca White', color: '#F5F5F5', sku: 'QSL-ARUCAWHT', price: 8.40, brand: 'MSI Quartz', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/aruca-white-quartz.jpg' },
        { id: 'msi-frost-white', name: 'Frost White', color: '#FFFFFF', sku: 'QSL-FRSTWHT', price: 8.40, brand: 'MSI Quartz', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/frost-white-quartz.jpg' },
        { id: 'msi-sparkling-white', name: 'Sparkling White', color: '#FAFAFA', sku: 'QSL-SPRWHT', price: 8.40, brand: 'MSI Quartz', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/sparkling-white-quartz.jpg' },
        { id: 'msi-arctic-white', name: 'Arctic White', color: '#F0F0F0', sku: 'QSL-ARCWHT', price: 9.00, brand: 'MSI Quartz', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/arctic-white-quartz.jpg' },
        { id: 'msi-carrara-mist', name: 'Carrara Mist', color: '#E8E8E8', sku: 'QSL-CARRMIST', price: 10.75, brand: 'MSI Quartz', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/carrara-mist-quartz.jpg' },
        { id: 'msi-calacatta-alto', name: 'Calacatta Alto', color: '#FAF8F5', sku: 'QSL-CALAALTO', price: 10.75, brand: 'MSI Quartz', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/calacatta-alto-quartz.jpg' },
        { id: 'msi-midnight-majesty', name: 'Midnight Majesty', color: '#1A1A1A', sku: 'QSL-MIDMAJ', price: 10.75, brand: 'MSI Quartz', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/midnight-majesty-quartz.jpg' },
        { id: 'msi-alabaster-white', name: 'Alabaster White', color: '#FAF8F5', sku: 'QSL-ALABWHT', price: 13.15, brand: 'MSI Quartz', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/alabaster-white-quartz.jpg' },
        { id: 'msi-calacatta-vicenza', name: 'Calacatta Vicenza', color: '#F8F5F0', sku: 'QSL-CALVIC', price: 13.15, brand: 'MSI Quartz', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/calacatta-vicenza-quartz.jpg' },
        { id: 'msi-calacatta-laza', name: 'Calacatta Laza', color: '#FAFAFA', sku: 'QSL-CALALAZA', price: 15.00, brand: 'MSI Quartz', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/calacatta-laza-quartz.jpg' },
        { id: 'msi-babylon-gray', name: 'Babylon Gray', color: '#4A4A4A', sku: 'QSL-BABYLONGRY', price: 15.00, brand: 'MSI Quartz', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/babylon-gray-quartz.jpg' },
        { id: 'msi-soapstone-mist', name: 'Soapstone Mist', color: '#686868', sku: 'QSL-SPSTNMIST', price: 15.00, brand: 'MSI Quartz', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/soapstone-mist-quartz.jpg' },
        { id: 'msi-calacatta-miraggio', name: 'Calacatta Miraggio', color: '#FAF8F5', sku: 'QSL-CALAMIRAGGIO', price: 18.00, brand: 'MSI Quartz', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/calacatta-miraggio-quartz.jpg' },
        { id: 'msi-calacatta-versailles', name: 'Calacatta Versailles', color: '#FAFAFA', sku: 'QSL-CALAVERSA', price: 20.75, brand: 'MSI Quartz', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/calacatta-versailles-quartz.jpg' },
        { id: 'msi-lumataj', name: 'Lumataj', color: '#F5F0E8', sku: 'QSL-LUMATAJ', price: 21.80, brand: 'MSI Quartz', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/lumataj-quartz.jpg' },
        // MSI Premium Quartz - Additional Colors (Jan 2025) - with CDN images
        { id: 'msi-iced-white', name: 'Iced White', color: '#F8F8F8', sku: 'QSL-ICEDWHT', price: 8.40, brand: 'MSI Quartz', tier: 'Group 0', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/iced-white-quartz.jpg' },
        { id: 'msi-bayshore-sand', name: 'Bayshore Sand', color: '#D4C4A8', sku: 'QSL-BAYSHRSND', price: 8.40, brand: 'MSI Quartz', tier: 'Group 0', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/bayshore-sand-quartz.jpg' },
        { id: 'msi-snow-white', name: 'Snow White', color: '#FEFEFE', sku: 'QSL-SNOWHTE', price: 9.00, brand: 'MSI Quartz', tier: 'Group 1', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/snow-white-quartz.jpg' },
        { id: 'msi-carrara-marmi', name: 'Carrara Marmi', color: '#F5F5F5', sku: 'QSL-CARMARMI', price: 10.75, brand: 'MSI Quartz', tier: 'Group 2', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/carrara-marmi-quartz.jpg' },
        { id: 'msi-stellar-white-g2', name: 'Stellar White', color: '#F5F5F5', sku: 'QSL-STELLARWHT', price: 10.75, brand: 'MSI Quartz', tier: 'Group 2', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/stellar-white-quartz.jpg' },
        { id: 'msi-calacatta-classique', name: 'Calacatta Classique', color: '#FAFAFA', sku: 'QSL-CALACLSQUE', price: 13.15, brand: 'MSI Quartz', tier: 'Group 3', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/calacatta-classique-quartz.jpg' },
        { id: 'msi-fairy-white', name: 'Fairy White', color: '#F8F8F8', sku: 'QSL-FAIWHT', price: 13.15, brand: 'MSI Quartz', tier: 'Group 3', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/fairy-white-quartz.jpg' },
        { id: 'msi-calacatta-botanica', name: 'Calacatta Botanica', color: '#F5F2EE', sku: 'QSL-CALABOTNICA', price: 15.00, brand: 'MSI Quartz', tier: 'Group 4', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/calacatta-botanica-quartz.jpg' },
        { id: 'msi-perla-white-g4', name: 'Perla White', color: '#F0ECE5', sku: 'QSL-PERWHT', price: 15.00, brand: 'MSI Quartz', tier: 'Group 4', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/perla-white-quartz.jpg' },
        { id: 'msi-calacatta-monaco', name: 'Calacatta Monaco', color: '#F8F5F0', sku: 'QSL-CALAMONACO', price: 17.00, brand: 'MSI Quartz', tier: 'Group 5', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/calacatta-monaco-quartz.jpg' },
        { id: 'msi-glacier-white', name: 'Glacier White', color: '#F8F8F8', sku: 'QSL-GLACIERWHT', price: 17.00, brand: 'MSI Quartz', tier: 'Group 5', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/glacier-white-quartz.jpg' },
        { id: 'msi-statuary-classique', name: 'Statuary Classique', color: '#FAFAFA', sku: 'QSL-STACLSQUE', price: 17.00, brand: 'MSI Quartz', tier: 'Group 5', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/statuary-classique-quartz.jpg' },
        { id: 'msi-calacatta-clara', name: 'Calacatta Clara', color: '#FAFAFA', sku: 'QSL-CALACLARA', price: 18.00, brand: 'MSI Quartz', tier: 'Group 6', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/calacatta-clara-quartz.jpg' },
        { id: 'msi-calacatta-luccia', name: 'Calacatta Luccia', color: '#FAFAFA', sku: 'QSL-CALALUCCIA', price: 18.00, brand: 'MSI Quartz', tier: 'Group 6', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/calacatta-luccia-quartz.jpg' },
        { id: 'msi-calacatta-trevi', name: 'Calacatta Trevi', color: '#FAFAFA', sku: 'QSL-CALATREVI', price: 18.00, brand: 'MSI Quartz', tier: 'Group 6', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/calacatta-trevi-quartz.jpg' },
        { id: 'msi-calacatta-goa', name: 'Calacatta Goa', color: '#FAF8F5', sku: 'QSL-CALAGOA', price: 20.75, brand: 'MSI Quartz', tier: 'Group 7', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/calacatta-goa-quartz.jpg' },
        { id: 'msi-calacatta-miraggio-gold', name: 'Calacatta Miraggio Gold', color: '#FAF5E8', sku: 'QSL-CALAMIRGOLD', price: 20.75, brand: 'MSI Quartz', tier: 'Group 7', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/calacatta-miraggio-gold-quartz.jpg' },
        { id: 'msi-azurmatt', name: 'Azurmatt', color: '#4A6B8C', sku: 'QSL-AZURMATT', price: 21.80, brand: 'MSI Quartz', tier: 'Group 8', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/azurmatt-quartz.jpg' },
        { id: 'msi-calacatta-viraldi', name: 'Calacatta Viraldi', color: '#FAF8F5', sku: 'QSL-CALAVIRALDI', price: 21.80, brand: 'MSI Quartz', tier: 'Group 8', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/calacatta-viraldi-quartz.jpg' },
        // Daltile ONE Quartz Surfaces (CTF Price List Jan 2026)
        { id: 'daltile-quartz-alabaster', name: 'Alabaster White', color: '#FAF8F5', sku: 'NQ90', price: 7.90, brand: 'Daltile ONE Quartz' },
        { id: 'daltile-quartz-simply-white', name: 'Simply White', color: '#FEFEFE', sku: 'NQ51', price: 7.90, brand: 'Daltile ONE Quartz' },
        { id: 'daltile-quartz-frost-white', name: 'Frost White', color: '#FFFFFF', sku: 'NQ01', price: 12.60, brand: 'Daltile ONE Quartz' },
        { id: 'daltile-quartz-carrara-mist', name: 'Carrara Mist', color: '#F5F5F5', sku: 'NQ64', price: 21.15, brand: 'Daltile ONE Quartz' },
        { id: 'daltile-quartz-calacatta-laza', name: 'Calacatta Laza', color: '#FAFAFA', sku: 'NQ73', price: 34.60, brand: 'Daltile ONE Quartz' },
        // Hanstone Quartz Collection (Q1 2025 Pricing) - Canadian Made, 15-Year Warranty
        { id: 'hanstone-cremosa', name: 'Cremosa', color: '#FAF8F0', price: 10.00, brand: 'Hanstone', pattern: 'veined', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/calacatta-laza-quartz.jpg' },
        { id: 'hanstone-le-blanc', name: 'Le Blanc', color: '#FEFEFE', price: 12.00, brand: 'Hanstone', pattern: 'veined', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/calacatta-laza-quartz.jpg' },
        { id: 'hanstone-matterhorn', name: 'Matterhorn', color: '#F5F5F5', price: 10.00, brand: 'Hanstone', pattern: 'veined', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/calacatta-classique-quartz.jpg' },
        { id: 'hanstone-elba-white', name: 'Elba White', color: '#F8F8F8', price: 10.00, brand: 'Hanstone', pattern: 'veined', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/calacatta-classique-quartz.jpg' },
        { id: 'hanstone-calacatta-mont', name: 'Calacatta Mont', color: '#FAFAFA', price: 12.00, brand: 'Hanstone', pattern: 'veined', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/calacatta-laza-quartz.jpg' },
        { id: 'hanstone-calacatta-extra', name: 'Calacatta Extra', color: '#FAF8F0', price: 12.00, brand: 'Hanstone', pattern: 'veined', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/calacatta-gold-quartz.jpg' },
        { id: 'hanstone-calacatta-gold', name: 'Calacatta Gold', color: '#FAF5E8', price: 14.00, brand: 'Hanstone', pattern: 'veined', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/calacatta-gold-quartz.jpg' },
        { id: 'hanstone-calacatta-venato', name: 'Calacatta Venato', color: '#FAFAFA', price: 12.00, brand: 'Hanstone', pattern: 'veined', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/calacatta-classique-quartz.jpg' },
        { id: 'hanstone-swan-cotton', name: 'Swan Cotton', color: '#FFFFFF', price: 8.00, brand: 'Hanstone', pattern: 'subtle', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/frost-white-quartz.jpg' },
        { id: 'hanstone-bianco-canvas', name: 'Bianco Canvas', color: '#FEFEFE', price: 8.00, brand: 'Hanstone', pattern: 'solid', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/frost-white-quartz.jpg' },
        { id: 'hanstone-artisan-grey', name: 'Artisan Grey', color: '#7A7A7A', price: 8.00, brand: 'Hanstone', pattern: 'subtle', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/grey-lagoon-quartz.jpg' },
        { id: 'hanstone-uptown-grey', name: 'Uptown Grey', color: '#6A6A6A', price: 8.00, brand: 'Hanstone', pattern: 'subtle', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/grey-lagoon-quartz.jpg' },
        { id: 'hanstone-storm', name: 'Storm', color: '#4A4A4A', price: 10.00, brand: 'Hanstone', pattern: 'movement', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/babylon-gray-quartz.jpg' },
        { id: 'hanstone-blackburn', name: 'Blackburn', color: '#1A1A1A', price: 8.00, brand: 'Hanstone', pattern: 'solid', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/midnight-majesty-quartz.jpg' },
        { id: 'hanstone-silhouette', name: 'Silhouette', color: '#0A0A0A', price: 8.00, brand: 'Hanstone', pattern: 'solid', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/midnight-majesty-quartz.jpg' },
        { id: 'hanstone-tranquility', name: 'Tranquility', color: '#6B8BA4', price: 10.00, brand: 'Hanstone', pattern: 'movement', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/azurmatt-quartz.jpg' },
        { id: 'hanstone-serenity', name: 'Serenity', color: '#7A9BB8', price: 10.00, brand: 'Hanstone', pattern: 'movement', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/azurmatt-quartz.jpg' },
        { id: 'hanstone-oceana', name: 'Oceana', color: '#4A6B8C', price: 10.00, brand: 'Hanstone', pattern: 'movement', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/azurmatt-quartz.jpg' },
        { id: 'hanstone-empress', name: 'Empress', color: '#F8F5F0', price: 12.00, brand: 'Hanstone', pattern: 'veined', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/calacatta-versailles-quartz.jpg' },
        { id: 'hanstone-patagonia', name: 'Patagonia', color: '#E8E4DC', price: 12.00, brand: 'Hanstone', pattern: 'movement', url: 'https://cdn.msisurfaces.com/images/quartz-countertops/products/closeup/large/calacatta-botanica-quartz.jpg' }
      ],
      marble: [
        // Daltile Natural Stone - Marble (CTF Price List Jan 2026)
        { id: 'daltile-carrara-honed', name: 'Carrara White (Honed)', color: '#F5F5F5', sku: 'M70112181U', price: 10.45, brand: 'Daltile' },
        { id: 'daltile-carrara-polished', name: 'Carrara White (Polished)', color: '#FAFAFA', sku: 'M70112181L', price: 12.25, brand: 'Daltile' },
        { id: 'daltile-first-snow', name: 'First Snow Elegance', color: '#FFFFFF', sku: 'M19012181L', price: 38.80, brand: 'Daltile' }
      ],
      quartzite: [
        // Daltile Natural Stone - Quartzite (CTF Price List Jan 2026)
        { id: 'daltile-super-white', name: 'Super White', color: '#FEFEFE', sku: 'L02212121L', price: 39.85, brand: 'Daltile' },
        { id: 'daltile-taj-mahal', name: 'Taj Mahal', color: '#F5F0E8', sku: 'L02112121L', price: 39.85, brand: 'Daltile' },
        { id: 'daltile-calacatta-macaubas', name: 'Calacatta Macaubas', color: '#FAF8F5', sku: 'L02612121L', price: 39.85, brand: 'Daltile' },
        { id: 'daltile-azul-macaubas', name: 'Azul Macaubas', color: '#4A6B8C', sku: 'L02512121L', price: 39.85, brand: 'Daltile' },
        { id: 'daltile-sea-pearl', name: 'Sea Pearl', color: '#D8E0E8', sku: 'L02312121L', price: 39.85, brand: 'Daltile' },
        { id: 'daltile-madre-perla', name: 'Madre Perla', color: '#F0E8E0', sku: 'L02812121L', price: 31.20, brand: 'Daltile' }
      ],
      porcelain: [],
      cabinets: [
        { id: 'cabinet-white', name: 'Shaker White', color: '#f5f5f5', url: 'https://cdn.prod.website-files.com/6456ce4476abb25581fbad0c/6456ce4476abb22994fbb0d6_Liberty%20Shaker%20White%20Cabinet.webp' },
        { id: 'cabinet-grey', name: 'Shaker Grey', color: '#7a7a7a', url: 'https://cdn.prod.website-files.com/6456ce4476abb25581fbad0c/6456ce4476abb22121fbb0d7_Liberty%20Shaker%20Grey%20Cabinet.webp' },
        { id: 'cabinet-espresso', name: 'Shaker Espresso', color: '#3d2b1f', url: 'https://cdn.prod.website-files.com/6456ce4476abb25581fbad0c/6456ce4476abb20cc6fbb0d5_Liberty%20Shaker%20Espresso.webp' },
        { id: 'cabinet-black', name: 'Onyx Black', color: '#1a1a1a', url: 'https://cdn.prod.website-files.com/6456ce4476abb25581fbad0c/6456ce4476abb24601fbb0e8_Onyx%20Black%20Shaker.webp' },
        { id: 'cabinet-uptown', name: 'Uptown White', color: '#fefefe', url: 'https://cdn.prod.website-files.com/6456ce4476abb25581fbad0c/6456ce4476abb232ddfbb0eb_Uptown%20White%20Shaker.webp' },
        // MSI Cabinet Collection - Base Cabinets (Jan 2025 Pricing)
        // Colors represent default shaker white finish - actual color changes based on selected series
        { id: 'msi-cab-b09', name: 'MSI Base 9"', color: '#e8ddd0', sku: 'B09', price: 119.13, brand: 'MSI', type: 'base', width: 9, finish: 'shaker-white' },
        { id: 'msi-cab-b12', name: 'MSI Base 12"', color: '#e8ddd0', sku: 'B12', price: 127.63, brand: 'MSI', type: 'base', width: 12, finish: 'shaker-white' },
        { id: 'msi-cab-b15', name: 'MSI Base 15"', color: '#e8ddd0', sku: 'B15', price: 137.25, brand: 'MSI', type: 'base', width: 15, finish: 'shaker-white' },
        { id: 'msi-cab-b18', name: 'MSI Base 18"', color: '#e8ddd0', sku: 'B18', price: 146.30, brand: 'MSI', type: 'base', width: 18, finish: 'shaker-white' },
        { id: 'msi-cab-b21', name: 'MSI Base 21"', color: '#d4a76a', sku: 'B21', price: 155.00, brand: 'MSI', type: 'base', width: 21, finish: 'natural-oak' },
        { id: 'msi-cab-b24', name: 'MSI Base 24"', color: '#d4a76a', sku: 'B24', price: 175.71, brand: 'MSI', type: 'base', width: 24, finish: 'natural-oak' },
        { id: 'msi-cab-b30', name: 'MSI Base 30"', color: '#5d4037', sku: 'B30', price: 196.45, brand: 'MSI', type: 'base', width: 30, finish: 'rustic-walnut' },
        { id: 'msi-cab-b36', name: 'MSI Base 36"', color: '#5d4037', sku: 'B36', price: 245.41, brand: 'MSI', type: 'base', width: 36, finish: 'rustic-walnut' },
        { id: 'msi-cab-sb30', name: 'MSI Sink Base 30"', color: '#6a6a6a', sku: 'SB30', price: 151.82, brand: 'MSI', type: 'sink', width: 30, finish: 'euro-grey' },
        { id: 'msi-cab-sb36', name: 'MSI Sink Base 36"', color: '#6a6a6a', sku: 'SB36', price: 171.82, brand: 'MSI', type: 'sink', width: 36, finish: 'euro-grey' },
        { id: 'msi-cab-3db15', name: 'MSI Drawer Base 15"', color: '#c78b4a', sku: '3DB15', price: 206.32, brand: 'MSI', type: 'drawer', width: 15, finish: 'autumn-oak' },
        { id: 'msi-cab-3db18', name: 'MSI Drawer Base 18"', color: '#c78b4a', sku: '3DB18', price: 219.00, brand: 'MSI', type: 'drawer', width: 18, finish: 'autumn-oak' },
        // MSI Cabinet Collection - Wall Cabinets
        { id: 'msi-cab-w1236', name: 'MSI Wall 12x36"', color: '#e0c8a0', sku: 'W1236', price: 82.15, brand: 'MSI', type: 'wall', width: 12, height: 36, finish: 'light-oak' },
        { id: 'msi-cab-w1536', name: 'MSI Wall 15x36"', color: '#e0c8a0', sku: 'W1536', price: 92.77, brand: 'MSI', type: 'wall', width: 15, height: 36, finish: 'light-oak' },
        { id: 'msi-cab-w1836', name: 'MSI Wall 18x36"', color: '#9e8b7d', sku: 'W1836', price: 103.55, brand: 'MSI', type: 'wall', width: 18, height: 36, finish: 'driftwood' },
        { id: 'msi-cab-w2436', name: 'MSI Wall 24x36"', color: '#9e8b7d', sku: 'W2436', price: 136.01, brand: 'MSI', type: 'wall', width: 24, height: 36, finish: 'driftwood' },
        { id: 'msi-cab-w3036', name: 'MSI Wall 30x36"', color: '#3d2b1f', sku: 'W3036', price: 154.95, brand: 'MSI', type: 'wall', width: 30, height: 36, finish: 'java' },
        { id: 'msi-cab-w3630', name: 'MSI Wall 36x30"', color: '#3d2b1f', sku: 'W3630', price: 154.95, brand: 'MSI', type: 'wall', width: 36, height: 30, finish: 'java' },
        { id: 'msi-cab-w1242', name: 'MSI Wall 12x42"', color: '#8b7355', sku: 'W1242', price: 95.99, brand: 'MSI', type: 'wall', width: 12, height: 42, finish: 'toffee' },
        { id: 'msi-cab-w2442', name: 'MSI Wall 24x42"', color: '#8b7355', sku: 'W2442', price: 159.90, brand: 'MSI', type: 'wall', width: 24, height: 42, finish: 'toffee' },
        { id: 'msi-cab-w3042', name: 'MSI Wall 30x42"', color: '#6b5344', sku: 'W3042', price: 184.23, brand: 'MSI', type: 'wall', width: 30, height: 42, finish: 'barnwood' },
        // MSI Cabinet Collection - Vanity Cabinets
        { id: 'msi-cab-v3021', name: 'MSI Vanity 30x21"', color: '#d3d3d3', sku: 'V3021', price: 152.48, brand: 'MSI', type: 'vanity', width: 30, finish: 'shaker-dove' },
        { id: 'msi-cab-v3621', name: 'MSI Vanity 36x21"', color: '#d3d3d3', sku: 'V3621', price: 172.00, brand: 'MSI', type: 'vanity', width: 36, finish: 'shaker-dove' },
        { id: 'msi-cab-vdb4221', name: 'MSI Vanity Combo 42x21"', color: '#7b3f00', sku: 'VDB4221R', price: 328.93, brand: 'MSI', type: 'vanity', width: 42, finish: 'chestnut' },
        { id: 'msi-cab-vdb4821', name: 'MSI Vanity Combo 48x21"', color: '#7b3f00', sku: 'VDB4821', price: 361.88, brand: 'MSI', type: 'vanity', width: 48, finish: 'chestnut' }
      ],
      tile: [
        // Existing tiles
        { id: 'tile-perla', name: 'Taja Perla', color: '#d4cfc5', url: 'https://cdn.prod.website-files.com/6456ce4476abb25581fbad0c/6456ce4576abb2d4d0fbcc56_taja-perla-porcelain-close-up-thumbnail.jpg' },
        { id: 'tile-white', name: 'White Subway', color: '#ffffff', url: '' },
        { id: 'tile-marble', name: 'Carrara Look', color: '#e8e8e8', url: '' },
        { id: 'tile-slate', name: 'Slate Grey', color: '#708090', url: '' },
        // Daltile PANORAMIC Porcelain Surfaces (CTF Price List Jan 2026)
        { id: 'daltile-panoramic-calacatta', name: 'PANORAMIC Calacatta', color: '#FAFAFA', sku: 'PAN-CAL', price: 31.20, brand: 'Daltile', series: 'PANORAMIC' },
        { id: 'daltile-panoramic-statuario', name: 'PANORAMIC Statuario', color: '#F8F8F8', sku: 'PAN-STA', price: 31.20, brand: 'Daltile', series: 'PANORAMIC' },
        { id: 'daltile-panoramic-nero', name: 'PANORAMIC Nero Marquina', color: '#1A1A1A', sku: 'PAN-NER', price: 28.80, brand: 'Daltile', series: 'PANORAMIC' },
        { id: 'daltile-panoramic-cement', name: 'PANORAMIC Cement', color: '#9E9E9E', sku: 'PAN-CEM', price: 8.90, brand: 'Daltile', series: 'PANORAMIC' }
      ],
      flooring: [
        { id: 'floor-premium', name: 'Premium LVP', color: '#b8956c', url: 'https://cdn.prod.website-files.com/6456ce4476abb25581fbad0c/6456ce4476abb2d85bfbb1d2_All%20Flooring%20Hero%20Background%20Image.webp' },
        { id: 'floor-oak', name: 'Natural Oak', color: '#c4a76c', url: '' },
        { id: 'floor-walnut', name: 'Dark Walnut', color: '#5d4037', url: '' },
        { id: 'floor-maple', name: 'Light Maple', color: '#deb887', url: '' },
        // MSI Everlife LVT Flooring - Ashton Series (Tier 4 Pricing Q1 2025) - with CDN images
        { id: 'msi-lvt-bergen-hills', name: 'Ashton Bergen Hills', color: '#C4A76C', sku: 'ASHTON-BERGENHILLS', price: 1.25, brand: 'MSI Everlife', series: 'Ashton', warranty: '25yr Res' },
        { id: 'msi-lvt-maracay-brown', name: 'Ashton Maracay Brown', color: '#8B7355', sku: 'ASHTON-MARACAYBROWN', price: 1.25, brand: 'MSI Everlife', series: 'Ashton', warranty: '25yr Res' },
        { id: 'msi-lvt-york-gray', name: 'Ashton York Gray', color: '#7A7A7A', sku: 'ASHTON-YORKGRAY', price: 1.25, brand: 'MSI Everlife', series: 'Ashton', warranty: '25yr Res' },
        // MSI Everlife LVT - Cyrus Series - with CDN images
        { id: 'msi-lvt-akadia', name: 'Cyrus Akadia', color: '#A08060', sku: 'CYRUS-AKADIA', price: 1.55, brand: 'MSI Everlife', series: 'Cyrus', warranty: 'Lifetime/10yr Comm' },
        { id: 'msi-lvt-barnstorm', name: 'Cyrus Barnstorm', color: '#5D4037', sku: 'CYRUS-BARNSTORM', price: 1.55, brand: 'MSI Everlife', series: 'Cyrus', warranty: 'Lifetime/10yr Comm' },
        { id: 'msi-lvt-braly', name: 'Cyrus Braly', color: '#6B5344', sku: 'CYRUS-BRALY', price: 1.55, brand: 'MSI Everlife', series: 'Cyrus', warranty: 'Lifetime/10yr Comm' },
        { id: 'msi-lvt-fauna', name: 'Cyrus Fauna', color: '#9E8B7D', sku: 'CYRUS-FAUNA', price: 1.55, brand: 'MSI Everlife', series: 'Cyrus', warranty: 'Lifetime/10yr Comm' },
        { id: 'msi-lvt-katella-ash', name: 'Cyrus Katella Ash', color: '#8A8A8A', sku: 'CYRUS-KATELLAASH', price: 1.55, brand: 'MSI Everlife', series: 'Cyrus', warranty: 'Lifetime/10yr Comm' },
        { id: 'msi-lvt-ludlow', name: 'Cyrus Ludlow', color: '#7D6B5D', sku: 'CYRUS-LUDLOW', price: 1.55, brand: 'MSI Everlife', series: 'Cyrus', warranty: 'Lifetime/10yr Comm' },
        { id: 'msi-lvt-sandino', name: 'Cyrus Sandino', color: '#C4A878', sku: 'CYRUS-SANDINO', price: 1.55, brand: 'MSI Everlife', series: 'Cyrus', warranty: 'Lifetime/10yr Comm' },
        // MSI Everlife LVT - Prescott Series (Premium Commercial) - with CDN images
        { id: 'msi-lvt-prescott-akadia', name: 'Prescott Akadia', color: '#A08060', sku: 'PRESCOTT-AKADIA', price: 1.79, brand: 'MSI Everlife', series: 'Prescott', warranty: 'Lifetime/20yr Comm' },
        { id: 'msi-lvt-prescott-braly', name: 'Prescott Braly', color: '#6B5344', sku: 'PRESCOTT-BRALY', price: 1.79, brand: 'MSI Everlife', series: 'Prescott', warranty: 'Lifetime/20yr Comm' },
        { id: 'msi-lvt-prescott-fauna', name: 'Prescott Fauna', color: '#9E8B7D', sku: 'PRESCOTT-FAUNA', price: 1.79, brand: 'MSI Everlife', series: 'Prescott', warranty: 'Lifetime/20yr Comm' },
        { id: 'msi-lvt-prescott-ludlow', name: 'Prescott Ludlow', color: '#7D6B5D', sku: 'PRESCOTT-LUDLOW', price: 1.79, brand: 'MSI Everlife', series: 'Prescott', warranty: 'Lifetime/20yr Comm' },
        // MSI Everlife LVT - Andover Series - with CDN images
        { id: 'msi-lvt-bayhill-blonde', name: 'Andover Bayhill Blonde', color: '#DEB887', sku: 'ANDOVER-BAYHILLBLONDE', price: 1.79, brand: 'MSI Everlife', series: 'Andover', warranty: 'Lifetime/15yr Comm' },
        { id: 'msi-lvt-hatfield', name: 'Andover Hatfield', color: '#8B7355', sku: 'ANDOVER-HATFIELD', price: 1.79, brand: 'MSI Everlife', series: 'Andover', warranty: 'Lifetime/15yr Comm' },
        { id: 'msi-lvt-kingsdown-gray', name: 'Andover Kingsdown Gray', color: '#6E6E6E', sku: 'ANDOVER-KINGSDOWNGRAY', price: 1.79, brand: 'MSI Everlife', series: 'Andover', warranty: 'Lifetime/15yr Comm' },
        { id: 'msi-lvt-whitby-white', name: 'Andover Whitby White', color: '#E8E4DC', sku: 'ANDOVER-WHITBYWHITE', price: 1.79, brand: 'MSI Everlife', series: 'Andover', warranty: 'Lifetime/15yr Comm' },
        // MSI Everlife LVT - Trecento Series (Stone Look 12x24) - with CDN images
        { id: 'msi-lvt-calacatta-legend', name: 'Trecento Calacatta Legend', color: '#F5F5F5', sku: 'TRECENTO-CALACATTALEGEND', price: 1.75, brand: 'MSI Everlife', series: 'Trecento', warranty: 'Lifetime/10yr Comm' },
        { id: 'msi-lvt-carrara-avell', name: 'Trecento Carrara Avell', color: '#E8E8E8', sku: 'TRECENTO-CARRARAAVELL', price: 1.75, brand: 'MSI Everlife', series: 'Trecento', warranty: 'Lifetime/10yr Comm' },
        { id: 'msi-lvt-mountains-gray', name: 'Trecento Mountains Gray', color: '#9E9E9E', sku: 'TRECENTO-MOUNTAINSGRAY', price: 1.75, brand: 'MSI Everlife', series: 'Trecento', warranty: 'Lifetime/10yr Comm' },
        // MSI Everlife LVT - Laurel Series - with CDN images
        { id: 'msi-lvt-coastal-cottage', name: 'Laurel Coastal Cottage', color: '#D4C8B8', sku: 'LAUREL-COASTALCOTTAGE', price: 1.69, brand: 'MSI Everlife', series: 'Laurel', warranty: 'Lifetime/15yr Comm' },
        { id: 'msi-lvt-honey-hollow', name: 'Laurel Honey Hollow', color: '#C4A76C', sku: 'LAUREL-HONEYHOLLOW', price: 1.69, brand: 'MSI Everlife', series: 'Laurel', warranty: 'Lifetime/15yr Comm' },
        { id: 'msi-lvt-scandi', name: 'Laurel Scandi', color: '#E8E0D8', sku: 'LAUREL-SCANDI', price: 1.69, brand: 'MSI Everlife', series: 'Laurel', warranty: 'Lifetime/15yr Comm' },
        // MSI Everlife LVT - Studio Collection (Ultra Premium) - with CDN images
        { id: 'msi-lvt-studio-bozeman', name: 'Studio Bozeman', color: '#6B5344', sku: 'STUDIO-BOZEMAN', price: 3.39, brand: 'MSI Everlife', series: 'Studio', warranty: 'Lifetime/30yr Comm' },
        { id: 'msi-lvt-studio-taos', name: 'Studio Taos', color: '#8B7355', sku: 'STUDIO-TAOS', price: 3.39, brand: 'MSI Everlife', series: 'Studio', warranty: 'Lifetime/30yr Comm' },
        { id: 'msi-lvt-studio-roswell', name: 'Studio Roswell', color: '#A08060', sku: 'STUDIO-ROSWELL', price: 3.39, brand: 'MSI Everlife', series: 'Studio', warranty: 'Lifetime/30yr Comm' },
        // MSI DryBack LVT - Katavia Series (Budget)
        { id: 'msi-dryback-katavia-bleached-elm', name: 'Katavia Bleached Elm', color: '#D4C8B8', sku: 'VTGBLEELM6X48-2MM-6MIL', price: 0.80, brand: 'MSI DryBack', series: 'Katavia', warranty: '15yr Res' },
        { id: 'msi-dryback-katavia-burnished-acacia', name: 'Katavia Burnished Acacia', color: '#8B7355', sku: 'VTGBURACA6X48-2MM-6MIL', price: 0.80, brand: 'MSI DryBack', series: 'Katavia', warranty: '15yr Res' },
        { id: 'msi-dryback-katavia-charcoal-oak', name: 'Katavia Charcoal Oak', color: '#4A4A4A', sku: 'VTGCHAOAK6X48-2MM-6MIL', price: 0.80, brand: 'MSI DryBack', series: 'Katavia', warranty: '15yr Res' },
        { id: 'msi-dryback-katavia-elmwood-ash', name: 'Katavia Elmwood Ash', color: '#9E8B7D', sku: 'VTGELMASH6X48-2MM-6MIL', price: 0.80, brand: 'MSI DryBack', series: 'Katavia', warranty: '15yr Res' },
        { id: 'msi-dryback-katavia-twilight-oak', name: 'Katavia Twilight Oak', color: '#5D4037', sku: 'VTGTWIOAK6X48-2MM-6MIL', price: 0.80, brand: 'MSI DryBack', series: 'Katavia', warranty: '15yr Res' },
        { id: 'msi-dryback-katavia-woodrift-gray', name: 'Katavia Woodrift Gray', color: '#6E6E6E', sku: 'VTGWOOGRA6X48-2MM-6MIL', price: 0.80, brand: 'MSI DryBack', series: 'Katavia', warranty: '15yr Res' },
        // MSI DryBack LVT - Glenridge Series
        { id: 'msi-dryback-glenridge-aged-hickory', name: 'Glenridge Aged Hickory', color: '#7D6B5D', sku: 'VTGAGEHIC6X48-2MM-12MIL', price: 0.89, brand: 'MSI DryBack', series: 'Glenridge', warranty: '25yr Res/6yr Comm' },
        { id: 'msi-dryback-glenridge-coastal-mix', name: 'Glenridge Coastal Mix', color: '#A8A090', sku: 'VTGCOAMIX6X48-2MM-12MIL', price: 0.89, brand: 'MSI DryBack', series: 'Glenridge', warranty: '25yr Res/6yr Comm' },
        { id: 'msi-dryback-glenridge-jatoba', name: 'Glenridge Jatoba', color: '#6B4A3A', sku: 'VTGJATOBA6X48-2MM-12MIL', price: 0.89, brand: 'MSI DryBack', series: 'Glenridge', warranty: '25yr Res/6yr Comm' },
        { id: 'msi-dryback-glenridge-midnight-maple', name: 'Glenridge Midnight Maple', color: '#3D2B1F', sku: 'VTGMIDMAP6X48-2MM-12MIL', price: 0.89, brand: 'MSI DryBack', series: 'Glenridge', warranty: '25yr Res/6yr Comm' },
        { id: 'msi-dryback-glenridge-saddle-oak', name: 'Glenridge Saddle Oak', color: '#8B7355', sku: 'VTGSADOAK6X48-2MM-12MIL', price: 0.89, brand: 'MSI DryBack', series: 'Glenridge', warranty: '25yr Res/6yr Comm' },
        { id: 'msi-dryback-glenridge-tawny-birch', name: 'Glenridge Tawny Birch', color: '#C4A878', sku: 'VTGTAWBIR6X48-2MM-12MIL', price: 0.89, brand: 'MSI DryBack', series: 'Glenridge', warranty: '25yr Res/6yr Comm' },
        // MSI DryBack LVT - Acclima Series
        { id: 'msi-dryback-acclima-ayla', name: 'Acclima Ayla', color: '#C4A76C', sku: 'VTGAYLA7X48-2MM-12MIL', price: 0.98, brand: 'MSI DryBack', series: 'Acclima', warranty: '25yr Res/6yr Comm' },
        { id: 'msi-dryback-acclima-louis-hill', name: 'Acclima Louis Hill', color: '#8B7355', sku: 'VTGLOUHIL7X48-2MM-12MIL', price: 0.98, brand: 'MSI DryBack', series: 'Acclima', warranty: '25yr Res/6yr Comm' },
        { id: 'msi-dryback-acclima-ludlow', name: 'Acclima Ludlow', color: '#7D6B5D', sku: 'VTGLUDLOW7X48-2MM-12MIL', price: 0.98, brand: 'MSI DryBack', series: 'Acclima', warranty: '25yr Res/6yr Comm' },
        { id: 'msi-dryback-acclima-waldorf', name: 'Acclima Waldorf', color: '#A08060', sku: 'VTGWALDOR7X48-2MM-12MIL', price: 0.98, brand: 'MSI DryBack', series: 'Acclima', warranty: '25yr Res/6yr Comm' },
        { id: 'msi-dryback-acclima-whitfield-gray', name: 'Acclima Whitfield Gray', color: '#8A8A8A', sku: 'VTGWHTGRA7X48-2MM-12MIL', price: 0.98, brand: 'MSI DryBack', series: 'Acclima', warranty: '25yr Res/6yr Comm' },
        // MSI DryBack LVT - Wilmont Series (20mil wear layer)
        { id: 'msi-dryback-wilmont-burnished-acacia', name: 'Wilmont Burnished Acacia', color: '#8B7355', sku: 'VTGBURACA7X48-2.5MM-20MIL', price: 1.19, brand: 'MSI DryBack', series: 'Wilmont', warranty: 'Lifetime/15yr Comm' },
        { id: 'msi-dryback-wilmont-charcoal-oak', name: 'Wilmont Charcoal Oak', color: '#4A4A4A', sku: 'VTGCHAOAK7X48-2.5MM-20MIL', price: 1.19, brand: 'MSI DryBack', series: 'Wilmont', warranty: 'Lifetime/15yr Comm' },
        { id: 'msi-dryback-wilmont-elmwood-ash', name: 'Wilmont Elmwood Ash', color: '#9E8B7D', sku: 'VTGELMASH7X48-2.5MM-20MIL', price: 1.19, brand: 'MSI DryBack', series: 'Wilmont', warranty: 'Lifetime/15yr Comm' },
        { id: 'msi-dryback-wilmont-lime-washed', name: 'Wilmont Lime Washed Oak', color: '#E8E0D8', sku: 'VTGLIMWAS7X48-2.5MM-20MIL', price: 1.19, brand: 'MSI DryBack', series: 'Wilmont', warranty: 'Lifetime/15yr Comm' },
        { id: 'msi-dryback-wilmont-twilight-oak', name: 'Wilmont Twilight Oak', color: '#5D4037', sku: 'VTGTWIOAK7X48-2.5MM-20MIL', price: 1.19, brand: 'MSI DryBack', series: 'Wilmont', warranty: 'Lifetime/15yr Comm' },
        // MSI DryBack LVT - Kallum Series (Looselay Premium)
        { id: 'msi-dryback-kallum-akadia', name: 'Kallum Akadia', color: '#A08060', sku: 'VTGAKADIA9X48-5MM-20MIL', price: 1.69, brand: 'MSI DryBack', series: 'Kallum', warranty: 'Lifetime/25yr Comm' },
        { id: 'msi-dryback-kallum-cranton', name: 'Kallum Cranton', color: '#8B7355', sku: 'VTGCRANTO9X48-5MM-20MIL', price: 1.69, brand: 'MSI DryBack', series: 'Kallum', warranty: 'Lifetime/25yr Comm' },
        { id: 'msi-dryback-kallum-fauna', name: 'Kallum Fauna', color: '#9E8B7D', sku: 'VTGFAUNA9X48-5MM-20MIL', price: 1.69, brand: 'MSI DryBack', series: 'Kallum', warranty: 'Lifetime/25yr Comm' },
        { id: 'msi-dryback-kallum-finely', name: 'Kallum Finely', color: '#6B5344', sku: 'VTGFINELY9X48-5MM-20MIL', price: 1.69, brand: 'MSI DryBack', series: 'Kallum', warranty: 'Lifetime/25yr Comm' },
        { id: 'msi-dryback-kallum-larkin', name: 'Kallum Larkin', color: '#C4A76C', sku: 'VTGLARKIN9X48-5MM-20MIL', price: 1.69, brand: 'MSI DryBack', series: 'Kallum', warranty: 'Lifetime/25yr Comm' },
        { id: 'msi-dryback-kallum-walnut-waves', name: 'Kallum Walnut Waves', color: '#5D4037', sku: 'VTGWALWAV9X48-5MM-20MIL', price: 1.69, brand: 'MSI DryBack', series: 'Kallum', warranty: 'Lifetime/25yr Comm' }
      ],
      showerPanels: [
        // Daltile LUXORA Shower Panels (CTF Price List Jan 2026)
        { id: 'luxora-calacatta-gold', name: 'LUXORA Calacatta Gold', color: '#FAF8F0', sku: 'LUX-CAL-G', price: 5.80, brand: 'Daltile' },
        { id: 'luxora-carrara', name: 'LUXORA Carrara', color: '#F5F5F5', sku: 'LUX-CAR', price: 5.20, brand: 'Daltile' },
        { id: 'luxora-bianco-statuario', name: 'LUXORA Bianco Statuario', color: '#FEFEFE', sku: 'LUX-BIA', price: 5.80, brand: 'Daltile' }
      ],
      // MSI Hardscape Products (Tier 3 Q1 2025 Pricing)
      hardscape: [
        // Travertine Pavers - with CDN images
        { id: 'msi-trav-tuscany-beige', name: 'Tuscany Beige Travertine Paver 16x24', color: '#D4C4A8', sku: 'LPATBEI1624TUMBLED', price: 4.07, brand: 'MSI', category: 'Travertine Pavers', size: '16x24' },
        { id: 'msi-trav-tuscany-beige-6x12', name: 'Tuscany Beige Travertine Paver 6x12', color: '#D4C4A8', sku: 'LPATBEI0612TUMBLED', price: 3.58, brand: 'MSI', category: 'Travertine Pavers', size: '6x12' },
        { id: 'msi-trav-tuscany-choc', name: 'Tuscany Chocolat Travertine Paver 16x24', color: '#6B5344', sku: 'LPATCHOC1624TUMBLED', price: 5.44, brand: 'MSI', category: 'Travertine Pavers', size: '16x24' },
        { id: 'msi-trav-tuscany-ivory', name: 'Tuscany Ivory Travertine Paver 16x24', color: '#F0E8E0', sku: 'LPATIVORY1624TUMBLED', price: 5.13, brand: 'MSI', category: 'Travertine Pavers', size: '16x24' },
        { id: 'msi-trav-tuscany-walnut', name: 'Tuscany Walnut Travertine Paver 16x24', color: '#8B7355', sku: 'LPATWALNUT1624TUMBLED', price: 4.91, brand: 'MSI', category: 'Travertine Pavers', size: '16x24' },
        // Pool Coping - with CDN images
        { id: 'msi-coping-tuscany-beige', name: 'Tuscany Beige Pool Coping 4x12', color: '#D4C4A8', sku: 'LCOPATBEI412TUMBLED', price: 9.45, brand: 'MSI', category: 'Pool Coping', size: '4x12' },
        { id: 'msi-coping-tuscany-ivory', name: 'Tuscany Ivory Pool Coping 4x12', color: '#F0E8E0', sku: 'LCOPATIVORY412TUMBLED', price: 9.81, brand: 'MSI', category: 'Pool Coping', size: '4x12' },
        { id: 'msi-coping-tuscany-walnut', name: 'Tuscany Walnut Pool Coping 4x12', color: '#8B7355', sku: 'LCOPATWALNUT412TUMBLED', price: 11.03, brand: 'MSI', category: 'Pool Coping', size: '4x12' },
        // Porcelain Pavers - Arterra Collection - with CDN images
        { id: 'msi-arterra-beton-gray', name: 'Arterra Beton Gray 24x24', color: '#9E9E9E', sku: 'LPARTBETGRY2424', price: 5.98, brand: 'MSI', category: 'Porcelain Pavers', size: '24x24' },
        { id: 'msi-arterra-legions-aspen', name: 'Arterra Legions Aspen Ash 24x24', color: '#A08060', sku: 'LPARTLEGASP2424', price: 6.98, brand: 'MSI', category: 'Porcelain Pavers', size: '24x24' },
        { id: 'msi-arterra-praia-grey', name: 'Arterra Praia Grey 24x24', color: '#7A7A7A', sku: 'LPARTPRAIAGRY2424', price: 5.98, brand: 'MSI', category: 'Porcelain Pavers', size: '24x24' },
        { id: 'msi-arterra-tierra-sol', name: 'Arterra Tierra Sol Beige 24x24', color: '#C4A878', sku: 'LPARTTIERBEI2424', price: 5.98, brand: 'MSI', category: 'Porcelain Pavers', size: '24x24' },
        // Stacked Stone - with CDN images
        { id: 'msi-stack-arctic-white', name: 'Arctic White Stacked Stone', color: '#F5F5F5', sku: 'LSLEDARCWHT', price: 10.98, brand: 'MSI', category: 'Stacked Stone', size: '6x24' },
        { id: 'msi-stack-charcoal', name: 'Charcoal Stacked Stone', color: '#4A4A4A', sku: 'LSLEDCHAR', price: 9.98, brand: 'MSI', category: 'Stacked Stone', size: '6x24' },
        { id: 'msi-stack-golden-honey', name: 'Golden Honey Stacked Stone', color: '#C4A76C', sku: 'LSLEDGLDHNY', price: 9.98, brand: 'MSI', category: 'Stacked Stone', size: '6x24' },
        { id: 'msi-stack-white-oak', name: 'White Oak Stacked Stone', color: '#E8E4DC', sku: 'LSLEDWHTOAK', price: 11.98, brand: 'MSI', category: 'Stacked Stone', size: '6x24' },
        // Decomposed Granite & Aggregates
        { id: 'msi-dg-pathway', name: 'Decomposed Granite Pathway', color: '#C4A878', sku: 'DG-PATHWAY', price: 89.00, brand: 'MSI', category: 'Aggregates', unit: 'per yard' },
        // Pebbles (40lb bags)
        { id: 'msi-pebble-amazon-multi', name: 'Amazon Multi Pebbles', color: '#8B7355', sku: 'LPEBQAMZMUL3NAT40', price: 14.50, brand: 'MSI', category: 'Pebbles', unit: 'per 40lb bag' },
        { id: 'msi-pebble-black', name: 'Black Polished Pebbles', color: '#1A1A1A', sku: 'LPEBQBLK3POL40', price: 14.50, brand: 'MSI', category: 'Pebbles', unit: 'per 40lb bag' },
        { id: 'msi-pebble-white', name: 'White Polished Pebbles', color: '#F5F5F5', sku: 'LPEBMWHI3POL40', price: 14.50, brand: 'MSI', category: 'Pebbles', unit: 'per 40lb bag' },
        { id: 'msi-pebble-mixed', name: 'Mixed Polished Pebbles', color: '#9E8B7D', sku: 'LPEBMMIX3POL40', price: 14.50, brand: 'MSI', category: 'Pebbles', unit: 'per 40lb bag' },
        { id: 'msi-pebble-nile-gray', name: 'Nile Gray Pebbles', color: '#7A7A7A', sku: 'LPEBQNILGRY3NAT40', price: 14.50, brand: 'MSI', category: 'Pebbles', unit: 'per 40lb bag' },
        { id: 'msi-pebble-himalaya-white', name: 'Himalaya White Pebbles', color: '#FAFAFA', sku: 'LPEBMHIMWHI3NAT40', price: 14.50, brand: 'MSI', category: 'Pebbles', unit: 'per 40lb bag' },
        // Fire Glass (20lb bags)
        { id: 'msi-fireglass-galaxy-black', name: 'Fire Glass Galaxy Black', color: '#0A0A0A', sku: 'LFIRGGALBLK0.5CRU20', price: 21.00, brand: 'MSI', category: 'Fire Glass', unit: 'per 20lb bag' },
        { id: 'msi-fireglass-aqua-blue', name: 'Fire Glass Aqua Blue', color: '#00CED1', sku: 'LFIRGAQUBLU0.25CRU20', price: 21.00, brand: 'MSI', category: 'Fire Glass', unit: 'per 20lb bag' },
        { id: 'msi-fireglass-sapphire-blue', name: 'Fire Glass Sapphire Blue', color: '#0F52BA', sku: 'LFIRGSAPBLU0.5CRU20', price: 21.00, brand: 'MSI', category: 'Fire Glass', unit: 'per 20lb bag' },
        { id: 'msi-fireglass-marine-blue', name: 'Fire Glass Marine Blue', color: '#4169E1', sku: 'LFIRGMARBLU0.5CRU20', price: 21.00, brand: 'MSI', category: 'Fire Glass', unit: 'per 20lb bag' },
        { id: 'msi-fireglass-copper-brown', name: 'Fire Glass Copper Brown', color: '#B87333', sku: 'LFIRGCOPBRO0.5CRU20', price: 21.00, brand: 'MSI', category: 'Fire Glass', unit: 'per 20lb bag' },
        { id: 'msi-fireglass-glacial-silver', name: 'Fire Glass Glacial Silver', color: '#C0C0C0', sku: 'LFIRGGLASIL0.5CRU20', price: 21.00, brand: 'MSI', category: 'Fire Glass', unit: 'per 20lb bag' }
      ],
      // MSI Vanity Collections (2024 Flyer)
      vanities: [
        // RTA Vanities - Ready-To-Assemble Collection
        { id: 'msi-rta-v2721-white', name: 'RTA Vanity 27x21 White', color: '#FFFFFF', sku: 'VANHDR-V2721-WHT', brand: 'MSI', collection: 'RTA', width: 27, features: 'Plywood, Soft-close doors' },
        { id: 'msi-rta-v3021-white', name: 'RTA Vanity 30x21 White', color: '#FFFFFF', sku: 'VANHDR-V3021-WHT', brand: 'MSI', collection: 'RTA', width: 30, features: 'Plywood, Soft-close doors' },
        { id: 'msi-rta-v3621-white', name: 'RTA Vanity 36x21 White', color: '#FFFFFF', sku: 'VANHDR-V3621-WHT', brand: 'MSI', collection: 'RTA', width: 36, features: 'Plywood, Soft-close doors' },
        { id: 'msi-rta-v4821-white', name: 'RTA Vanity 48x21 Single Bowl White', color: '#FFFFFF', sku: 'VANHDR-V4821SB-FLSW-2H', brand: 'MSI', collection: 'RTA', width: 48, features: '4 doors, 2 drawers, Plywood' },
        { id: 'msi-rta-v6021-white', name: 'RTA Vanity 60x21 Double Bowl White', color: '#FFFFFF', sku: 'VANHDR-V6021DB-FLSW-2H', brand: 'MSI', collection: 'RTA', width: 60, features: '4 doors, 2 tilted drawers, Plywood' },
        { id: 'msi-rta-vdb15-white', name: 'RTA Drawer Vanity 15" White', color: '#FFFFFF', sku: 'VDB15-3', brand: 'MSI', collection: 'RTA', width: 15, features: '3-Drawer, Plywood' },
        { id: 'msi-rta-vdb21-white', name: 'RTA Drawer Vanity 21" White', color: '#FFFFFF', sku: 'VDB21-3', brand: 'MSI', collection: 'RTA', width: 21, features: '3-Drawer, Plywood' },
        // RTA Vanities - Grey Color
        { id: 'msi-rta-v3021-grey', name: 'RTA Vanity 30x21 Grey', color: '#7A7A7A', sku: 'VANHDR-V3021-GRY', brand: 'MSI', collection: 'RTA', width: 30, features: 'Plywood, Soft-close doors' },
        { id: 'msi-rta-v3621-grey', name: 'RTA Vanity 36x21 Grey', color: '#7A7A7A', sku: 'VANHDR-V3621-GRY', brand: 'MSI', collection: 'RTA', width: 36, features: 'Plywood, Soft-close doors' },
        { id: 'msi-rta-v4821-grey', name: 'RTA Vanity 48x21 Grey', color: '#7A7A7A', sku: 'VANHDR-V4821SB-GRY', brand: 'MSI', collection: 'RTA', width: 48, features: '4 doors, 2 drawers, Plywood' },
        // RTA Vanities - Blue Color
        { id: 'msi-rta-v3021-blue', name: 'RTA Vanity 30x21 Blue', color: '#4A6B8C', sku: 'VANHDR-V3021-BLU', brand: 'MSI', collection: 'RTA', width: 30, features: 'Plywood, Soft-close doors' },
        { id: 'msi-rta-v3621-blue', name: 'RTA Vanity 36x21 Blue', color: '#4A6B8C', sku: 'VANHDR-V3621-BLU', brand: 'MSI', collection: 'RTA', width: 36, features: 'Plywood, Soft-close doors' },
        // RTA Vanities - Black Color
        { id: 'msi-rta-v3021-black', name: 'RTA Vanity 30x21 Black', color: '#1A1A1A', sku: 'VANHDR-V3021-BLK', brand: 'MSI', collection: 'RTA', width: 30, features: 'Plywood, Soft-close doors' },
        { id: 'msi-rta-v3621-black', name: 'RTA Vanity 36x21 Black', color: '#1A1A1A', sku: 'VANHDR-V3621-BLK', brand: 'MSI', collection: 'RTA', width: 36, features: 'Plywood, Soft-close doors' },
        // RTA Vanities - Natural Oak
        { id: 'msi-rta-v3021-oak', name: 'RTA Vanity 30x21 Natural Oak', color: '#C4A76C', sku: 'VANHDR-V3021-OAK', brand: 'MSI', collection: 'RTA', width: 30, features: 'Wood veneer, Soft-close doors' },
        { id: 'msi-rta-v3621-oak', name: 'RTA Vanity 36x21 Natural Oak', color: '#C4A76C', sku: 'VANHDR-V3621-OAK', brand: 'MSI', collection: 'RTA', width: 36, features: 'Wood veneer, Soft-close doors' },
        // Fluted Vanities - Pre-Assembled Collection
        { id: 'msi-fluted-v3021', name: 'Fluted Vanity 30x21', color: '#DEB887', sku: 'VANFLT-V3021', brand: 'MSI', collection: 'Fluted', width: 30, features: 'Solid wood, Wood veneer, Pre-assembled' },
        { id: 'msi-fluted-v3621', name: 'Fluted Vanity 36x21', color: '#DEB887', sku: 'VANFLT-V3621', brand: 'MSI', collection: 'Fluted', width: 36, features: 'Solid wood, 3 drawers, Pre-assembled' },
        { id: 'msi-fluted-v3021-tilt', name: 'Fluted Vanity 30x21 w/Tilt Drawer', color: '#DEB887', sku: 'VANFLT-V3021-TILT', brand: 'MSI', collection: 'Fluted', width: 30, features: 'Solid wood, Tilted drawer, Pre-assembled' },
        { id: 'msi-fluted-v3621-tilt', name: 'Fluted Vanity 36x21 w/Tilt Drawer', color: '#DEB887', sku: 'VANFLT-V3621-TILT', brand: 'MSI', collection: 'Fluted', width: 36, features: 'Solid wood, 2 tilted drawers, Pre-assembled' },
        // Folding Vanities - Easy Assembly Collection
        { id: 'msi-fold-v2421', name: 'Folding Vanity 24x21', color: '#FFFFFF', sku: 'VANFOLD-V2421', brand: 'MSI', collection: 'Folding', width: 24, features: 'Solid wood frame, Plywood box, Easy assembly' },
        { id: 'msi-fold-v3021', name: 'Folding Vanity 30x21', color: '#FFFFFF', sku: 'VANFOLD-V3021', brand: 'MSI', collection: 'Folding', width: 30, features: 'Solid wood frame, Plywood box, Easy assembly' },
        { id: 'msi-fold-v3621', name: 'Folding Vanity 36x21', color: '#FFFFFF', sku: 'VANFOLD-V3621', brand: 'MSI', collection: 'Folding', width: 36, features: 'Solid wood frame, Plywood box, Easy assembly' },
        { id: 'msi-fold-v4221', name: 'Folding Vanity 42x21', color: '#FFFFFF', sku: 'VANFOLD-V4221', brand: 'MSI', collection: 'Folding', width: 42, features: 'Solid wood frame, Plywood box, Easy assembly' },
        { id: 'msi-fold-v4821', name: 'Folding Vanity 48x21', color: '#FFFFFF', sku: 'VANFOLD-V4821', brand: 'MSI', collection: 'Folding', width: 48, features: 'Solid wood frame, Plywood box, Easy assembly' },
        { id: 'msi-fold-v6021', name: 'Folding Vanity 60x21', color: '#FFFFFF', sku: 'VANFOLD-V6021', brand: 'MSI', collection: 'Folding', width: 60, features: 'Solid wood frame, Plywood box, Easy assembly' }
      ],
      // MSI Flooring Trim & Accessories
      flooringTrims: [
        { id: 'msi-trim-stairtread', name: 'Stair Tread (Eased Edge)', color: '#8B7355', sku: 'STAIR-TREAD', price: 37.00, brand: 'MSI', size: '47.25" x 12"', unit: 'each' },
        { id: 'msi-trim-stairnose-flush', name: 'Stair Nose (Flush)', color: '#8B7355', sku: 'STAIRNOSE-FLUSH', price: 32.00, brand: 'MSI', size: '94"', unit: 'each' },
        { id: 'msi-trim-stairnose-overlap', name: 'Stair Nose (Overlapping)', color: '#8B7355', sku: 'STAIRNOSE-OVERLAP', price: 27.00, brand: 'MSI', size: '94"', unit: 'each' },
        { id: 'msi-trim-endcap', name: 'End Cap', color: '#8B7355', sku: 'ENDCAP', price: 27.00, brand: 'MSI', size: '94"', unit: 'each' },
        { id: 'msi-trim-reducer', name: 'Surface Reducer', color: '#8B7355', sku: 'REDUCER', price: 22.00, brand: 'MSI', size: '94"', unit: 'each' },
        { id: 'msi-trim-tmolding', name: 'T-Molding', color: '#8B7355', sku: 'TMOLDING', price: 27.00, brand: 'MSI', size: '94"', unit: 'each' },
        { id: 'msi-trim-quarterround', name: 'Quarter Round', color: '#8B7355', sku: 'QUARTERROUND', price: 20.00, brand: 'MSI', size: '94"', unit: 'each' }
      ],
      // Cabinet Accessories
      cabinetAccessories: [
        { id: 'msi-acc-basepanel', name: 'Base Panel 36x96', color: '#F5F5F5', sku: 'BP3696', price: 59.39, brand: 'MSI' },
        { id: 'msi-acc-dishwasher-return', name: 'Dishwasher Return Panel', color: '#F5F5F5', sku: 'DWR3', price: 26.35, brand: 'MSI' },
        { id: 'msi-acc-basefiller', name: 'Base Filler 3x30', color: '#F5F5F5', sku: 'F330', price: 12.73, brand: 'MSI' },
        { id: 'msi-acc-scribemolding', name: 'Scribe Molding 96"', color: '#F5F5F5', sku: 'SM8', price: 6.43, brand: 'MSI' },
        { id: 'msi-acc-tallendpanel', name: 'Tall End Panel 30x96', color: '#F5F5F5', sku: 'TEP3096', price: 170.32, brand: 'MSI' },
        { id: 'msi-acc-toekick', name: 'Toe Kick 96"', color: '#F5F5F5', sku: 'TK8', price: 8.88, brand: 'MSI' },
        { id: 'msi-acc-wallfiller36', name: 'Wall Filler 3x36', color: '#F5F5F5', sku: 'WF336', price: 27.19, brand: 'MSI' },
        { id: 'msi-acc-wallfiller42', name: 'Wall Filler 3x42', color: '#F5F5F5', sku: 'WF342', price: 31.58, brand: 'MSI' },
        { id: 'msi-acc-wallfiller96', name: 'Wall Filler 3x96', color: '#F5F5F5', sku: 'WF396', price: 41.64, brand: 'MSI' }
      ],
      // Sinks - loaded from sinks.json
      sinks: [],
      // Faucets - loaded from faucets.json
      faucets: []
    };

    // Stone pricing loaded from external JSON file (contains 1137 materials from Excel import)
    let stonePricingLoaded = false;

    // Load stone pricing data from external JSON file and merge into MATERIALS
    async function loadStonePricing() {
      if (stonePricingLoaded) return; // Already loaded

      try {
        const response = await fetch('stone-pricing.json');
        if (!response.ok) {
          console.warn('Stone pricing file not found, using built-in materials only');
          return;
        }

        const stonePricing = await response.json();
        let addedCount = 0;

        // Merge each category  deduplicate by BOTH id AND name
        for (const category of ['granite', 'quartz', 'quartzite', 'marble', 'porcelain']) {
          if (stonePricing[category]) {
            if (!MATERIALS[category]) MATERIALS[category] = [];

            const existingIds = new Set(MATERIALS[category].map(m => m.id));
            const existingNames = new Set(MATERIALS[category].map(m => (m.name || '').toLowerCase().trim()));

            for (const material of stonePricing[category]) {
              if (existingIds.has(material.id)) continue;

              const nameKey = (material.name || '').toLowerCase().trim();
              if (existingNames.has(nameKey)) {
                // Same name already exists (possibly different distributor)
                // Merge price into existing if it lacks one
                const existing = MATERIALS[category].find(m => (m.name || '').toLowerCase().trim() === nameKey);
                if (existing && !existing.price && material.price) {
                  existing.price = material.price;
                  existing.tier = material.tier;
                }
                continue;
              }

              MATERIALS[category].push(material);
              existingIds.add(material.id);
              existingNames.add(nameKey);
              addedCount++;
            }
          }
        }

        stonePricingLoaded = true;
        console.log(`Loaded ${addedCount} stone materials from pricing file`);

        // Refresh the materials panel if it's currently showing a stone category
        if (['granite', 'quartz', 'quartzite', 'marble', 'porcelain'].includes(currentMaterialCategory)) {
          renderMaterials(currentMaterialCategory);
        }

        return addedCount;
      } catch (error) {
        console.warn('Could not load stone pricing:', error);
        return 0;
      }
    }

    // ===== LOAD COUNTERTOPS.JSON (874 products with images) =====
    let countertopsJsonLoaded = false;

    // Brand slug  display name mapping
    const BRAND_SLUG_MAP = {
      'msi-surfaces': 'MSI Surfaces',
      'cambria': 'Cambria',
      'pentalquartz': 'Pentalquartz',
      'radianz-quartz': 'Radianz',
      'silestone': 'Silestone',
      'bolder-image-stone': 'Bolder Image Stone',
      'cosentino': 'Cosentino',
      'sensa': 'Sensa',
      'arizona-tile': 'Arizona Tile',
      'lx-hausys': 'LX Hausys',
      'daltile': 'Daltile'
    };

    // Color name  hex mapping for primaryColor field
    const COLOR_NAME_MAP = {
      'White': '#F5F5F5',
      'Gray': '#888888',
      'Cream': '#F5F0E0',
      'Black': '#1a1a1a',
      'Beige': '#D4C4A8',
      'Brown': '#6B4226',
      'Gold': '#C8A84E',
      'Green': '#4A6B4A',
      'Blue': '#4A6B8C',
      'Red': '#8B4A4A',
      'Tan': '#C8B08A',
      'Silver': '#A8A8A8',
      'Multi': '#B0A090',
      'Yellow': '#D4C878',
      'Pink': '#C8A0A0',
      'Orange': '#C88A4A',
      'Purple': '#6B4A8B',
      'Taupe': '#9B8878'
    };

    // Type  category mapping
    const TYPE_CATEGORY_MAP = {
      'Quartz': 'quartz',
      'Granite': 'granite',
      'Marble': 'marble',
      'Quartzite': 'quartzite',
      'Porcelain': 'porcelain',
      'Dekton': 'porcelain'
    };

    async function loadCountertopsJson() {
      if (countertopsJsonLoaded) return 0;

      try {
        // Determine the path relative to the room designer
        const basePath = window.location.pathname.includes('/tools/room-designer')
          ? '../../data/countertops.json'
          : '/data/countertops.json';

        const response = await fetch(basePath);
        if (!response.ok) {
          console.warn('countertops.json not found at', basePath);
          return 0;
        }

        const data = await response.json();
        const countertops = data.countertops || [];
        console.log(`Loaded countertops.json: ${countertops.length} products`);

        // Build existing name sets per category to avoid duplicates
        const existingNames = {};
        for (const cat of Object.keys(MATERIALS)) {
          if (Array.isArray(MATERIALS[cat])) {
            existingNames[cat] = new Set(
              MATERIALS[cat].map(m => (m.name || '').toLowerCase().trim())
            );
          }
        }

        let added = 0;
        const brandCounts = {};

        for (const product of countertops) {
          if (!product.name || !product.primaryImage) continue;
          if (!product.primaryImage.startsWith('http')) continue;

          // Map type to category
          const category = TYPE_CATEGORY_MAP[product.type];
          if (!category) continue;

          // Ensure category exists
          if (!MATERIALS[category]) MATERIALS[category] = [];
          if (!existingNames[category]) existingNames[category] = new Set();

          // Deduplicate by name (case-insensitive)
          const nameKey = product.name.toLowerCase().trim();
          if (existingNames[category].has(nameKey)) {
            // If existing material has no image, update it with the image from countertops.json
            const existing = MATERIALS[category].find(m => (m.name || '').toLowerCase().trim() === nameKey);
            if (existing && (!existing.url || !existing.url.startsWith('http')) && product.primaryImage) {
              existing.url = product.primaryImage;
              existing.source = existing.source ? existing.source + '+countertops.json' : 'countertops.json';
            }
            continue;
          }

          // Map brand slug to display name
          const brandDisplay = BRAND_SLUG_MAP[product.brand] ||
            (product.brand || '').replace(/-/g, ' ').replace(/\b\w/g, c => c.toUpperCase());

          // Map color name to hex
          const colorHex = COLOR_NAME_MAP[product.primaryColor] || '#888888';

          const material = {
            id: `ctjson-${product.slug || product.name.toLowerCase().replace(/[^a-z0-9]+/g, '-')}`,
            name: product.name,
            brand: brandDisplay,
            url: product.primaryImage,
            color: colorHex,
            price: null, // Price comes from stone-pricing.json
            primaryColor: product.primaryColor || '',
            style: product.style || '',
            source: 'countertops.json'
          };

          MATERIALS[category].push(material);
          existingNames[category].add(nameKey);
          added++;

          // Track brand counts
          brandCounts[brandDisplay] = (brandCounts[brandDisplay] || 0) + 1;
        }

        countertopsJsonLoaded = true;
        console.log(`Added ${added} countertops from countertops.json`);
        console.log('By brand:', brandCounts);

        // Merge pricing from stone-pricing into newly added materials
        mergePricingIntoMaterials();

        // Refresh materials panel
        renderMaterials(currentMaterialCategory);

        return added;
      } catch (error) {
        console.warn('Could not load countertops.json:', error);
        return 0;
      }
    }

    /**
     * Merge pricing data from stone-pricing materials into countertops.json materials
     * that were added without prices
     */
    function mergePricingIntoMaterials() {
      for (const category of Object.keys(MATERIALS)) {
        if (!Array.isArray(MATERIALS[category])) continue;

        // Build a price lookup from materials that have prices
        const priceLookup = {};
        MATERIALS[category].forEach(m => {
          if (m.price && m.name) {
            priceLookup[m.name.toLowerCase().trim()] = m.price;
          }
        });

        // Apply prices to materials that are missing them
        MATERIALS[category].forEach(m => {
          if (!m.price && m.name) {
            const key = m.name.toLowerCase().trim();
            if (priceLookup[key]) {
              m.price = priceLookup[key];
            }
          }
        });
      }
    }

    // ===== HELPER: Detect valid image URL (HTTP or relative path) =====
    function hasValidImageUrl(url) {
      if (!url) return false;
      return url.startsWith('http') || url.startsWith('/');
    }

    // ===== LOAD TILE.JSON (466 tiles with images) =====
    let tileJsonLoaded = false;

    async function loadTileJson() {
      if (tileJsonLoaded) return 0;

      try {
        const basePath = window.location.pathname.includes('/tools/room-designer')
          ? '../../data/tile.json'
          : '/data/tile.json';

        const response = await fetch(basePath);
        if (!response.ok) {
          console.warn('tile.json not found at', basePath);
          return 0;
        }

        const data = await response.json();
        const tiles = data.tiles || [];
        console.log(`Loaded tile.json: ${tiles.length} products`);

        // Build existing name set for tile category to avoid duplicates
        if (!MATERIALS.tile) MATERIALS.tile = [];
        const existingNames = new Set(
          MATERIALS.tile.map(m => (m.name || '').toLowerCase().trim())
        );

        let added = 0;
        const brandCounts = {};

        const TILE_BRAND_MAP = {
          'msi': 'MSI',
          'bravo-tile': 'Bravo Tile'
        };

        for (const product of tiles) {
          if (!product.name) continue;
          if (!product.primaryImage && !product.image) continue;

          const imageUrl = product.primaryImage || product.image;
          if (!hasValidImageUrl(imageUrl)) continue;

          const nameKey = product.name.toLowerCase().trim();
          if (existingNames.has(nameKey)) {
            // Backfill image if existing entry lacks one
            const existing = MATERIALS.tile.find(m => (m.name || '').toLowerCase().trim() === nameKey);
            if (existing && !hasValidImageUrl(existing.url) && imageUrl) {
              existing.url = imageUrl;
            }
            continue;
          }

          const brandDisplay = TILE_BRAND_MAP[product.brand] ||
            (product.brand || '').replace(/-/g, ' ').replace(/\b\w/g, c => c.toUpperCase());

          const COLOR_HEX = {
            'White': '#F5F5F5', 'Gray': '#888888', 'Beige': '#D4C5A9',
            'Brown': '#8B6914', 'Black': '#2C2C2C', 'Cream': '#FFFDD0',
            'Gold': '#D4AF37', 'Blue': '#4169E1', 'Green': '#2E8B57',
            'Silver': '#C0C0C0', 'Ivory': '#FFFFF0', 'Multi': '#C0C0C0'
          };

          const material = {
            id: `tile-${product.slug || product.name.toLowerCase().replace(/[^a-z0-9]+/g, '-')}`,
            name: product.name,
            brand: brandDisplay,
            url: imageUrl,
            color: COLOR_HEX[product.primaryColor] || '#888888',
            price: null,
            material: product.material || '',
            tileType: product.type || '',
            subcategory: product.subcategory || '',
            source: 'tile.json'
          };

          MATERIALS.tile.push(material);
          existingNames.add(nameKey);
          added++;
          brandCounts[brandDisplay] = (brandCounts[brandDisplay] || 0) + 1;
        }

        tileJsonLoaded = true;
        console.log(`Added ${added} tiles from tile.json`);
        console.log('Tile brands:', brandCounts);

        return added;
      } catch (error) {
        console.warn('Could not load tile.json:', error);
        return 0;
      }
    }

    // ===== LOAD BRAVO-TILE.JSON (82 products with wholesale pricing) =====
    let bravoTileJsonLoaded = false;

    async function loadBravoTileJson() {
      if (bravoTileJsonLoaded) return 0;

      try {
        const basePath = window.location.pathname.includes('/tools/room-designer')
          ? '../../data/bravo-tile.json'
          : '/data/bravo-tile.json';

        const response = await fetch(basePath);
        if (!response.ok) {
          console.warn('bravo-tile.json not found at', basePath);
          return 0;
        }

        const data = await response.json();
        const products = data.products || [];
        console.log(`Loaded bravo-tile.json: ${products.length} products`);

        if (!MATERIALS.tile) MATERIALS.tile = [];

        // Build lookup of existing tile materials by name for price merging
        const existingByName = {};
        MATERIALS.tile.forEach(m => {
          if (m.name) existingByName[m.name.toLowerCase().trim()] = m;
        });

        let pricesMerged = 0;
        let added = 0;

        for (const product of products) {
          if (!product.name) continue;

          const nameKey = product.name.toLowerCase().trim();
          const existing = existingByName[nameKey];

          if (existing) {
            // Merge wholesale pricing into existing material
            if (product.wholesalePrice && !existing.price) {
              existing.price = product.wholesalePrice;
              existing.unit = product.unit || 'SF';
              pricesMerged++;
            }
            // Merge additional data
            if (product.size && !existing.size) existing.size = product.size;
            if (product.finish && !existing.finish) existing.finish = product.finish;
            if (product.origin && !existing.origin) existing.origin = product.origin;
            // Backfill image if missing
            if (!hasValidImageUrl(existing.url) && hasValidImageUrl(product.primaryImage)) {
              existing.url = product.primaryImage;
            }
          } else {
            // New product not in tile.json  add it
            const imageUrl = product.primaryImage || '';
            const COLOR_HEX = {
              'White': '#F5F5F5', 'Gray': '#888888', 'Beige': '#D4C5A9',
              'Brown': '#8B6914', 'Black': '#2C2C2C', 'Cream': '#FFFDD0',
              'Gold': '#D4AF37', 'Blue': '#4169E1', 'Green': '#2E8B57',
              'Silver': '#C0C0C0', 'Ivory': '#FFFFF0', 'Multi': '#C0C0C0'
            };

            const material = {
              id: `bravo-${product.slug || product.name.toLowerCase().replace(/[^a-z0-9]+/g, '-')}`,
              name: product.name,
              brand: 'Bravo Tile',
              url: imageUrl,
              color: COLOR_HEX[product.primaryColor] || '#888888',
              price: product.wholesalePrice || null,
              unit: product.unit || 'SF',
              size: product.size || '',
              finish: product.finish || '',
              origin: product.origin || '',
              material: product.category || '',
              subcategory: product.subcategory || '',
              source: 'bravo-tile.json'
            };

            MATERIALS.tile.push(material);
            existingByName[nameKey] = material;
            added++;
          }
        }

        bravoTileJsonLoaded = true;
        console.log(`Bravo Tile: merged ${pricesMerged} prices, added ${added} new products`);

        // Refresh panel if showing tile
        if (currentMaterialCategory === 'tile') {
          renderMaterials('tile');
        }

        return pricesMerged + added;
      } catch (error) {
        console.warn('Could not load bravo-tile.json:', error);
        return 0;
      }
    }

    // ===== LOAD SINKS.JSON (marketplace sinks) =====
    let sinksJsonLoaded = false;

    async function loadSinksJson() {
      if (sinksJsonLoaded) return 0;

      try {
        const basePath = window.location.pathname.includes('/tools/room-designer')
          ? '../../data/sinks.json'
          : '/data/sinks.json';

        const response = await fetch(basePath);
        if (!response.ok) {
          console.warn('sinks.json not found at', basePath);
          return 0;
        }

        const products = await response.json();
        console.log(`Loaded sinks.json: ${products.length} products`);

        if (!MATERIALS.sinks) MATERIALS.sinks = [];
        const existingNames = new Set(MATERIALS.sinks.map(m => (m.name || '').toLowerCase().trim()));
        const existingSlugs = new Set(storeProducts.map(p => p.slug));

        let added = 0;
        const brandCounts = {};

        for (const product of products) {
          if (!product.title) continue;
          const img = product.images?.[0] || '';
          if (!img) continue;

          const nameKey = product.title.toLowerCase().trim();
          if (existingNames.has(nameKey)) continue;

          const brand = product.brandDisplay || product.vendor || 'MSI';
          const price = product.price ? parseFloat(product.price) : null;
          const slug = product.handle || product.title.toLowerCase().replace(/[^a-z0-9]+/g, '-');

          const material = {
            id: `sink-${slug}`,
            name: product.title,
            brand: brand,
            url: img,
            color: '#C0C0C0',
            price: price,
            productType: product.productType || 'Sink',
            specs: product.specs || {},
            handle: product.handle,
            source: 'sinks.json'
          };

          MATERIALS.sinks.push(material);
          existingNames.add(nameKey);
          added++;
          brandCounts[brand] = (brandCounts[brand] || 0) + 1;

          // Also add to storeProducts for Products tab
          if (!existingSlugs.has(slug)) {
            storeProducts.push({
              slug: slug,
              name: product.title,
              brand: brand.toLowerCase().replace(/\s+/g, '-'),
              type: product.productType || 'Kitchen Sinks',
              category: 'sinks',
              primaryImage: img,
              price: price,
              source: 'sinks.json'
            });
            existingSlugs.add(slug);
          }
        }

        sinksJsonLoaded = true;
        console.log(`Added ${added} sinks from sinks.json`);
        console.log('Sink brands:', brandCounts);

        return added;
      } catch (error) {
        console.warn('Could not load sinks.json:', error);
        return 0;
      }
    }

    // ===== LOAD FAUCETS.JSON (marketplace faucets) =====
    let faucetsJsonLoaded = false;

    async function loadFaucetsJson() {
      if (faucetsJsonLoaded) return 0;

      try {
        const basePath = window.location.pathname.includes('/tools/room-designer')
          ? '../../data/faucets.json'
          : '/data/faucets.json';

        const response = await fetch(basePath);
        if (!response.ok) {
          console.warn('faucets.json not found at', basePath);
          return 0;
        }

        const products = await response.json();
        console.log(`Loaded faucets.json: ${products.length} products`);

        if (!MATERIALS.faucets) MATERIALS.faucets = [];
        const existingNames = new Set(MATERIALS.faucets.map(m => (m.name || '').toLowerCase().trim()));
        const existingSlugs = new Set(storeProducts.map(p => p.slug));

        let added = 0;
        const brandCounts = {};

        for (const product of products) {
          if (!product.title) continue;
          const img = product.images?.[0] || '';
          if (!img) continue;

          const nameKey = product.title.toLowerCase().trim();
          if (existingNames.has(nameKey)) continue;

          const brand = product.brandDisplay || product.vendor || 'KIBI';
          const price = product.price ? parseFloat(product.price) : null;
          const slug = product.handle || product.title.toLowerCase().replace(/[^a-z0-9]+/g, '-');

          const material = {
            id: `faucet-${slug}`,
            name: product.title,
            brand: brand,
            url: img,
            color: '#C0C0C0',
            price: price,
            productType: product.productType || 'Faucet',
            specs: product.specs || {},
            handle: product.handle,
            source: 'faucets.json'
          };

          MATERIALS.faucets.push(material);
          existingNames.add(nameKey);
          added++;
          brandCounts[brand] = (brandCounts[brand] || 0) + 1;

          // Also add to storeProducts for Products tab
          if (!existingSlugs.has(slug)) {
            storeProducts.push({
              slug: slug,
              name: product.title,
              brand: brand.toLowerCase().replace(/\s+/g, '-'),
              type: product.productType || 'Kitchen Faucets',
              category: 'faucets',
              primaryImage: img,
              price: price,
              source: 'faucets.json'
            });
            existingSlugs.add(slug);
          }
        }

        faucetsJsonLoaded = true;
        console.log(`Added ${added} faucets from faucets.json`);
        console.log('Faucet brands:', brandCounts);

        return added;
      } catch (error) {
        console.warn('Could not load faucets.json:', error);
        return 0;
      }
    }

    // ===== LOAD FLOORING.JSON (marketplace flooring) =====
    let flooringJsonLoaded = false;

    async function loadFlooringJson() {
      if (flooringJsonLoaded) return 0;

      try {
        const basePath = window.location.pathname.includes('/tools/room-designer')
          ? '../../data/flooring.json'
          : '/data/flooring.json';

        const response = await fetch(basePath);
        if (!response.ok) {
          console.warn('flooring.json not found at', basePath);
          return 0;
        }

        const data = await response.json();
        const products = data.flooring || data.products || data || [];
        console.log(`Loaded flooring.json: ${products.length} products`);

        if (!MATERIALS.flooring) MATERIALS.flooring = [];
        const existingNames = new Set(MATERIALS.flooring.map(m => (m.name || '').toLowerCase().trim()));
        const existingSlugs = new Set(storeProducts.map(p => p.slug));

        let added = 0;
        const brandCounts = {};

        const COLOR_HEX = {
          'White': '#F5F5F5', 'Gray': '#888888', 'Beige': '#D4C5A9',
          'Brown': '#8B6914', 'Black': '#2C2C2C', 'Cream': '#FFFDD0',
          'Gold': '#D4AF37', 'Blue': '#4169E1', 'Green': '#2E8B57',
          'Silver': '#C0C0C0', 'Ivory': '#FFFFF0', 'Multi': '#C4A76C'
        };

        for (const product of products) {
          if (!product.name) continue;
          const img = product.primaryImage || product.image || '';
          if (!img) continue;

          const nameKey = product.name.toLowerCase().trim();
          if (existingNames.has(nameKey)) continue;

          const brand = (product.brand || 'MSI').toUpperCase().replace(/-/g, ' ');
          const type = product.type || 'Luxury Vinyl';
          const slug = product.slug || product.name.toLowerCase().replace(/[^a-z0-9]+/g, '-');

          const material = {
            id: `flooring-${slug}`,
            name: product.name,
            brand: brand,
            url: img,
            color: COLOR_HEX[product.primaryColor] || '#C4A76C',
            flooringType: type,
            slug: slug,
            source: 'flooring.json'
          };

          MATERIALS.flooring.push(material);
          existingNames.add(nameKey);
          added++;
          brandCounts[brand] = (brandCounts[brand] || 0) + 1;

          // Also add to storeProducts for Products tab
          if (!existingSlugs.has(slug)) {
            storeProducts.push({
              slug: slug,
              name: product.name,
              brand: brand.toLowerCase().replace(/\s+/g, '-'),
              type: type,
              category: 'flooring',
              primaryImage: img,
              source: 'flooring.json'
            });
            existingSlugs.add(slug);
          }
        }

        flooringJsonLoaded = true;
        console.log(`Added ${added} flooring products from flooring.json`);
        console.log('Flooring brands:', brandCounts);

        // Refresh panel if showing flooring
        if (currentMaterialCategory === 'flooring') {
          renderMaterials('flooring');
        }

        return added;
      } catch (error) {
        console.warn('Could not load flooring.json:', error);
        return 0;
      }
    }

    // Load products from Supabase and add to materials
    let supabaseProductsLoaded = false;
    async function loadSupabaseProducts() {
      if (supabaseProductsLoaded) return;

      // Inline config since getSupabaseConfig may not be defined yet
      const SUPABASE_URL = 'https://ypeypgwsycxcagncgdur.supabase.co';
      const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InlwZXlwZ3dzeWN4Y2FnbmNnZHVyIiwicm9sZSI6ImFub24iLCJpYXQiOjE3Njc3NTQ4MjMsImV4cCI6MjA4MzMzMDgyM30.R13pNv2FDtGhfeu7gUcttYNrQAbNYitqR4FIq3O2-ME';

      try {
        // Fetch ALL products (paginate)
        let allProducts = [];
        let offset = 0;
        const limit = 1000;

        while (true) {
          const response = await fetch(
            `${SUPABASE_URL}/rest/v1/shopify_products?select=id,name,handle,vendor,product_type,image_url,price,tags&limit=${limit}&offset=${offset}`,
            {
              headers: {
                'apikey': SUPABASE_ANON_KEY,
                'Authorization': `Bearer ${SUPABASE_ANON_KEY}`
              }
            }
          );

          if (!response.ok) {
            console.warn('Failed to fetch products:', response.status);
            break;
          }

          const products = await response.json();
          allProducts = allProducts.concat(products);

          if (products.length < limit) break;
          offset += limit;
        }

        const withImages = allProducts.filter(p => p.image_url).length;
        console.log(`Fetched ${allProducts.length} products from Supabase (${withImages} with images)`);

        // Categorize and add products
        let countertops = 0, tiles = 0, floors = 0, skippedDupes = 0;

        // Track existing IDs AND NAMES to avoid duplicates across all sources
        const existingIds = {};
        const existingNames = {};
        for (const cat of Object.keys(MATERIALS)) {
          if (Array.isArray(MATERIALS[cat])) {
            existingIds[cat] = new Set(MATERIALS[cat].map(m => m.id));
            existingNames[cat] = new Set(MATERIALS[cat].map(m => (m.name || '').toLowerCase().trim()));
          }
        }

        // Helper: detect tile-like product names
        const isTileName = (n) => /\btile\b|\btiles\b|\bpaver\b|\bpavers\b|\bmosaic\b|\bbacksplash\b|\bsubway\b|\bledger\b|\bmolding\b|\btrim\b|\b\d+x\d+\b/.test(n);

        // Only import Supabase products that are surface materials for the Room Designer
        const allowedTypes = new Set([
          'tile', 'ceramic', 'glass', 'quartz', 'granite', 'marble',
          'travertine', 'quartzite', 'porcelain', 'dekton', 'natural stone',
          'luxury vinyl', 'slate', 'paver', 'limestone', 'trim'
        ]);

        for (const product of allProducts) {
          // Skip products without name or valid image
          if (!product.name || !product.image_url) continue;
          if (product.image_url.includes('placeholder') || !product.image_url.startsWith('http')) continue;

          const type = (product.product_type || '').toLowerCase();
          const name = (product.name || '').toLowerCase();
          const vendor = (product.vendor || '').toLowerCase();

          // Skip non-surface products entirely (sinks, faucets, furniture, etc.)
          if (type && !allowedTypes.has(type) && !type.includes('tile') && !type.includes('floor') && !type.includes('slab') && !type.includes('countertop') && !type.includes('quartz') && !type.includes('granite') && !type.includes('marble')) {
            continue;
          }

          // Determine category based on product_type and vendor
          let category = null;

          // Check vendor first - Bravo Tile products are always tile
          if (vendor.includes('bravo') && vendor.includes('tile')) {
            category = 'tile';
            tiles++;
          }
          // Direct tile types
          else if (type === 'tile' || type === 'ceramic' || type === 'glass' || type === 'slate' || type === 'paver' || type === 'limestone' || type === 'trim') {
            category = 'tile';
            tiles++;
          }
          // Travertine: check if it's a tile or a slab
          else if (type === 'travertine') {
            if (isTileName(name)) { category = 'tile'; tiles++; }
            else { category = 'marble'; countertops++; }
          }
          // Natural stone: check for tile-like names FIRST, then stone categories
          else if (type === 'natural stone') {
            if (isTileName(name)) { category = 'tile'; tiles++; }
            else if (name.includes('marble')) { category = 'marble'; countertops++; }
            else if (name.includes('quartzite')) { category = 'quartzite'; countertops++; }
            else { category = 'granite'; countertops++; }
          }
          // Direct stone types
          else if (type === 'quartz') { category = 'quartz'; countertops++; }
          else if (type === 'granite') { category = 'granite'; countertops++; }
          else if (type === 'marble') { category = 'marble'; countertops++; }
          else if (type === 'quartzite') { category = 'quartzite'; countertops++; }
          else if (type === 'porcelain' || type === 'dekton') { category = 'porcelain'; countertops++; }
          // Flooring: LVP/LVT/Luxury Vinyl
          else if (type === 'luxury vinyl' || type.includes('floor') || name.includes('lvp') || name.includes('lvt') || name.includes('flooring')) {
            category = 'flooring';
            floors++;
          }
          // Fallback tile detection
          else if (type.includes('tile') || isTileName(name)) {
            category = 'tile';
            tiles++;
          }
          // Fallback stone detection
          else if (type.includes('quartz') || type.includes('granite') || type.includes('marble') || type.includes('slab') || type.includes('countertop')) {
            if (name.includes('quartzite')) { category = 'quartzite'; }
            else if (name.includes('marble')) { category = 'marble'; }
            else if (name.includes('granite')) { category = 'granite'; }
            else { category = 'quartz'; }
            countertops++;
          }
          // Skip everything else (sinks, faucets, furniture, etc.)

          if (!category) continue;

          // Create material object
          const matId = `supabase-${product.id}`;
          if (existingIds[category]?.has(matId)) continue;

          // Skip if a material with the same name already exists in this category
          const nameKey = (product.name || '').toLowerCase().trim();
          if (existingNames[category]?.has(nameKey)) {
            // Backfill image if existing entry lacks one
            const existing = MATERIALS[category].find(m => (m.name || '').toLowerCase().trim() === nameKey);
            if (existing && !hasValidImageUrl(existing.url) && product.image_url) {
              existing.url = product.image_url;
            }
            skippedDupes++;
            continue;
          }

          // Don't import Supabase prices for stone categories (they're full-slab prices, not per-sqft)
          const stoneCategories = ['granite', 'quartz', 'quartzite', 'marble', 'porcelain'];
          const skipPrice = stoneCategories.includes(category);

          const material = {
            id: matId,
            name: product.name,
            brand: product.vendor || '',
            url: product.image_url || '',
            price: skipPrice ? null : (product.price || null),
            handle: product.handle || '',
            color: '#888888',
            source: 'supabase'
          };

          if (!MATERIALS[category]) MATERIALS[category] = [];
          if (!existingNames[category]) existingNames[category] = new Set();
          MATERIALS[category].push(material);
          existingIds[category]?.add(matId);
          existingNames[category].add(nameKey);
        }

        supabaseProductsLoaded = true;
        console.log(`Added from Supabase: ${countertops} countertops, ${tiles} tiles, ${floors} flooring (${skippedDupes} name-dupes skipped)`);

        // Refresh materials panel
        renderMaterials(currentMaterialCategory);

        return { countertops, tiles, floors };
      } catch (error) {
        console.warn('Could not load Supabase product images:', error);
        return 0;
      }
    }

    // ===== DISTRIBUTOR MARKETPLACE INTEGRATION =====
    // Use local API in development, Render in production
    const MARKETPLACE_API_BASE = (window.SG_CONFIG && window.SG_CONFIG.API_BASE)
      ? window.SG_CONFIG.API_BASE
      : (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1')
        ? 'http://localhost:3001'
        : 'https://surprise-granite-email-api.onrender.com';

    const MARKETPLACE_ENDPOINTS = {
      products: `${MARKETPLACE_API_BASE}/api/marketplace/products`,
      slabs: `${MARKETPLACE_API_BASE}/api/marketplace/slabs`,
      slabDetail: (id) => `${MARKETPLACE_API_BASE}/api/marketplace/slabs/${id}`,
      slabInquiry: (id) => `${MARKETPLACE_API_BASE}/api/marketplace/slabs/${id}/inquiry`
    };

    // Surface finish options by material group
    const FINISH_OPTIONS = {
      stone: ['Polished', 'Honed', 'Leathered', 'Matte', 'Brushed', 'Flamed', 'Natural'],
      tile:  ['Polished', 'Matte', 'Natural'],
      cabinet: []
    };
    const CATEGORY_FINISH_GROUP = {
      granite: 'stone', quartz: 'stone', marble: 'stone', quartzite: 'stone',
      porcelain: 'tile', tile: 'tile', flooring: 'tile', hardscape: 'stone',
      showerPanels: 'tile', cabinets: 'cabinet', vanities: 'cabinet',
      flooringTrims: 'cabinet', cabinetAccessories: 'cabinet'
    };

    // Map Room Designer categories  API material_type filter values
    const CATEGORY_TO_API_MATERIAL = {
      'granite': 'granite',
      'quartz': 'quartz',
      'marble': 'marble',
      'quartzite': 'quartzite',
      'porcelain': 'porcelain',
      'tile': 'tile',
      'flooring': 'flooring',
      'hardscape': 'hardscape',
      'cabinets': 'cabinets',
      'vanities': 'vanities',
      'showerPanels': 'shower_panels',
      'flooringTrims': 'flooring_trims',
      'cabinetAccessories': 'cabinet_accessories'
    };

    // Cache for distributor products per category
    const distributorCache = {};
    let distributorApiAvailable = null; // null = untested

    function isStale(cacheEntry) {
      if (!cacheEntry?.lastFetched) return true;
      return (Date.now() - cacheEntry.lastFetched) > 5 * 60 * 1000; // 5 minutes
    }

    function getDisplayPrice(material) {
      if (!PRICING_ACCESS.canViewPricing) return null;
      const accountType = PRICING_ACCESS.accountType;
      const isTradeAccount = ['fabricator', 'vendor', 'distributor'].includes(accountType);

      if (material.source?.includes('distributor')) {
        if (isTradeAccount && material.tradePrice) {
          return { amount: material.tradePrice, label: 'Trade' };
        }
        if (material.retailPrice) {
          return { amount: material.retailPrice, label: '' };
        }
      }
      if (material.price) {
        return { amount: material.price, label: '' };
      }
      return null;
    }

    function transformDistributorProduct(product, category, isSlab) {
      const name = isSlab ? (product.product_name || product.name) : product.name;

      // Resolve image URL from images array or primary_image_url
      let resolvedImage = '';
      if (Array.isArray(product.images) && product.images.length > 0) {
        const first = product.images[0];
        resolvedImage = typeof first === 'string' ? first : (first.url || first.src || '');
      }
      if (!resolvedImage) {
        resolvedImage = product.primary_image_url || '';
      }

      const colorHex = (typeof COLOR_NAME_MAP !== 'undefined' && (COLOR_NAME_MAP[product.color_family] || COLOR_NAME_MAP[product.primary_color]))
        || product.color || '#888888';

      const wholesalePrice = isSlab ? product.price_per_sqft : product.wholesale_price;
      const retailPrice = product.retail_price || product.msrp_per_sqft || wholesalePrice;
      const tradePrice = product.trade_price_per_sqft || wholesalePrice;

      return {
        id: `dist-${product.id}`,
        name: name || 'Unknown Product',
        brand: product.brand || (product.distributor?.company_name) || '',
        url: resolvedImage,
        color: colorHex,
        price: wholesalePrice || null,
        retailPrice: retailPrice || null,
        tradePrice: tradePrice || null,
        unit: isSlab ? 'sf' : (product.unit_type || 'sf'),
        sku: product.sku || product.product_sku || '',
        finish: product.finish || '',
        material: product.material_type || '',
        source: 'distributor',
        distributorId: product.distributor_id,
        distributorName: product.distributor?.company_name || '',
        distributorLogo: product.distributor?.logo_url || '',
        productUUID: product.id,
        status: product.status || 'available',
        isFeatured: product.is_featured || false
      };
    }

    async function fetchDistributorProducts(category) {
      const apiMaterialType = CATEGORY_TO_API_MATERIAL[category];
      if (!apiMaterialType) {
        console.log(`No API mapping for category "${category}", skipping fetch`);
        return [];
      }

      // Return cached if fresh
      if (distributorCache[category]?.loaded && !isStale(distributorCache[category])) {
        return distributorCache[category].products;
      }

      // Prevent duplicate concurrent fetches
      if (distributorCache[category]?.loading) {
        return new Promise((resolve) => {
          const check = setInterval(() => {
            if (!distributorCache[category]?.loading) {
              clearInterval(check);
              resolve(distributorCache[category]?.products || []);
            }
          }, 100);
          setTimeout(() => { clearInterval(check); resolve([]); }, 10000);
        });
      }

      distributorCache[category] = { products: [], loaded: false, loading: true, error: null, lastFetched: null };

      try {
        const isSlabCategory = ['granite', 'quartz', 'marble', 'quartzite', 'porcelain'].includes(category);
        const endpoint = isSlabCategory ? MARKETPLACE_ENDPOINTS.slabs : MARKETPLACE_ENDPOINTS.products;

        const params = new URLSearchParams({
          material_type: apiMaterialType,
          limit: '100',
          offset: '0'
        });

        const response = await fetch(`${endpoint}?${params.toString()}`);

        if (!response.ok) throw new Error(`API returned ${response.status}`);

        const data = await response.json();
        const rawProducts = isSlabCategory ? (data.slabs || []) : (data.products || []);
        const materials = rawProducts.map(p => transformDistributorProduct(p, category, isSlabCategory));

        distributorCache[category] = { products: materials, loaded: true, loading: false, error: null, lastFetched: Date.now() };
        distributorApiAvailable = true;
        console.log(`Loaded ${materials.length} distributor products for ${category}`);
        return materials;
      } catch (error) {
        console.warn(`Could not load distributor products for ${category}:`, error.message);
        distributorCache[category] = { products: [], loaded: false, loading: false, error: error.message, lastFetched: null };
        if (distributorApiAvailable === null) distributorApiAvailable = false;
        return [];
      }
    }

    function mergeDistributorMaterials(category, newMaterials) {
      if (!MATERIALS[category]) MATERIALS[category] = [];

      const existingNames = new Set(MATERIALS[category].map(m => (m.name || '').toLowerCase().trim()));
      const existingIds = new Set(MATERIALS[category].map(m => m.id));
      let added = 0;

      for (const mat of newMaterials) {
        if (existingIds.has(mat.id)) continue;

        const nameKey = (mat.name || '').toLowerCase().trim();
        if (existingNames.has(nameKey)) {
          // Backfill onto existing entry
          const existing = MATERIALS[category].find(m => (m.name || '').toLowerCase().trim() === nameKey);
          if (existing) {
            if (!hasValidImageUrl(existing.url) && hasValidImageUrl(mat.url)) existing.url = mat.url;
            if (!existing.price && mat.price) existing.price = mat.price;
            if (mat.tradePrice) existing.tradePrice = mat.tradePrice;
            if (mat.retailPrice) existing.retailPrice = mat.retailPrice;
            existing.productUUID = mat.productUUID;
            existing.distributorId = mat.distributorId;
            existing.distributorName = mat.distributorName;
            existing.distributorLogo = mat.distributorLogo;
            existing.source = (existing.source || 'static') + '+distributor';
          }
          continue;
        }

        MATERIALS[category].push(mat);
        existingIds.add(mat.id);
        existingNames.add(nameKey);
        added++;
      }
      if (added > 0) console.log(`Added ${added} new distributor materials to ${category}`);
    }

    async function loadDistributorDataForCategory(category) {
      const apiMaterialType = CATEGORY_TO_API_MATERIAL[category];
      if (!apiMaterialType) {
        console.log(`No API mapping for category "${category}", skipping load`);
        return;
      }

      if (distributorCache[category]?.loaded && !isStale(distributorCache[category])) return;

      // Show loading indicator
      const grid = document.getElementById('materialGrid');
      if (grid && !distributorCache[category]?.loaded) {
        const el = document.createElement('div');
        el.id = 'distributor-loading-indicator';
        el.textContent = 'Loading distributor inventory...';
        grid.appendChild(el);
      }

      try {
        const distributorMaterials = await fetchDistributorProducts(category);
        if (distributorMaterials.length > 0) {
          mergeDistributorMaterials(category, distributorMaterials);
          if (currentMaterialCategory === category) {
            renderMaterials(category);
          }
        }
      } catch (err) {
        console.warn('Distributor load failed for', category, err);
      }

      const loadingEl = document.getElementById('distributor-loading-indicator');
      if (loadingEl) loadingEl.remove();
    }

    // Inquiry modal for distributor products
    function showProductInquiryModal(materialId) {
      let material = null;
      for (const cat of Object.keys(MATERIALS)) {
        if (Array.isArray(MATERIALS[cat])) {
          material = MATERIALS[cat].find(m => m.id === materialId);
          if (material) break;
        }
      }
      if (!material || !material.productUUID) {
        showToast('Product inquiry not available for this material', 'info');
        return;
      }

      const user = window.SgAuth?.getUser?.();
      const profile = window.SgAuth?.getProfile?.();
      const displayPrice = getDisplayPrice(material);

      const modalHtml = `
        <div id="inquiryModal" style="position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.6);z-index:10000;display:flex;align-items:center;justify-content:center;" onclick="if(event.target===this)this.remove()">
          <div style="background:#1a1a2e;border:1px solid var(--gold);border-radius:12px;padding:24px;max-width:480px;width:90%;max-height:80vh;overflow-y:auto;">
            <h3 style="color:var(--gold);margin:0 0 12px;">Inquire About ${material.name}</h3>
            ${material.distributorName ? `<p style="font-size:13px;opacity:0.7;margin:0 0 4px;">Available from: ${material.distributorName}</p>` : ''}
            ${displayPrice ? `<p style="font-size:14px;margin:0 0 16px;">Price: $${displayPrice.amount.toFixed(2)}/${material.unit || 'sf'}${displayPrice.label ? ' <span class="material-trade-label">(' + displayPrice.label + ')</span>' : ''}</p>` : '<div style="margin-bottom:16px;"></div>'}
            <form id="inquiryForm" style="display:flex;flex-direction:column;gap:10px;">
              <input type="text" name="name" placeholder="Your Name *" required value="${user?.user_metadata?.full_name || profile?.full_name || ''}" style="padding:8px;border-radius:6px;border:1px solid #444;background:#0f0f23;color:#fff;font-size:14px;">
              <input type="email" name="email" placeholder="Email *" required value="${user?.email || ''}" style="padding:8px;border-radius:6px;border:1px solid #444;background:#0f0f23;color:#fff;font-size:14px;">
              <input type="tel" name="phone" placeholder="Phone" value="${profile?.phone || ''}" style="padding:8px;border-radius:6px;border:1px solid #444;background:#0f0f23;color:#fff;font-size:14px;">
              <input type="text" name="company_name" placeholder="Company Name" value="${profile?.company_name || ''}" style="padding:8px;border-radius:6px;border:1px solid #444;background:#0f0f23;color:#fff;font-size:14px;">
              <textarea name="message" placeholder="Tell us about your project..." rows="3" style="padding:8px;border-radius:6px;border:1px solid #444;background:#0f0f23;color:#fff;font-size:14px;resize:vertical;"></textarea>
              <select name="timeline" style="padding:8px;border-radius:6px;border:1px solid #444;background:#0f0f23;color:#fff;font-size:14px;">
                <option value="">When do you need this?</option>
                <option value="asap">ASAP</option>
                <option value="1_month">Within 1 month</option>
                <option value="1_3_months">1-3 months</option>
                <option value="3_plus_months">3+ months</option>
                <option value="just_browsing">Just browsing</option>
              </select>
              <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:8px;">
                <button type="button" onclick="document.getElementById('inquiryModal').remove();" style="padding:8px 16px;border-radius:6px;border:1px solid #555;background:transparent;color:#fff;cursor:pointer;font-size:14px;">Cancel</button>
                <button type="submit" style="padding:8px 16px;border-radius:6px;border:none;background:var(--gold);color:#000;cursor:pointer;font-weight:bold;font-size:14px;">Send Inquiry</button>
              </div>
            </form>
          </div>
        </div>`;

      document.body.insertAdjacentHTML('beforeend', modalHtml);
      document.getElementById('inquiryForm').addEventListener('submit', async (e) => {
        e.preventDefault();
        await submitProductInquiry(material, e.target);
      });
    }

    async function submitProductInquiry(material, form) {
      const formData = new FormData(form);
      const submitBtn = form.querySelector('button[type="submit"]');
      submitBtn.disabled = true;
      submitBtn.textContent = 'Sending...';

      try {
        const response = await fetch(MARKETPLACE_ENDPOINTS.slabInquiry(material.productUUID), {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            name: formData.get('name'),
            email: formData.get('email'),
            phone: formData.get('phone') || undefined,
            company_name: formData.get('company_name') || undefined,
            inquirer_type: PRICING_ACCESS.accountType || 'homeowner',
            message: formData.get('message') || undefined,
            timeline: formData.get('timeline') || undefined,
            project_type: 'room_designer'
          })
        });

        if (response.ok) {
          showToast('Inquiry sent! The distributor will contact you soon.', 'success');
          document.getElementById('inquiryModal')?.remove();
        } else {
          const err = await response.json().catch(() => ({}));
          throw new Error(err.error || 'Failed to submit inquiry');
        }
      } catch (error) {
        showToast(`Error: ${error.message}`, 'error');
        submitBtn.disabled = false;
        submitBtn.textContent = 'Send Inquiry';
      }
    }

    // Price tier helper for materials
    const PRICE_TIERS = {
      budget: { min: 0, max: 12.60, label: 'Budget-Friendly', color: '#10b981' },
      popular: { min: 12.60, max: 25.90, label: 'Popular Choice', color: '#f59e0b' },
      premium: { min: 25.90, max: 100, label: 'Premium', color: '#8b5cf6' }
    };

    function getMaterialPriceTier(price) {
      if (!price) return null;
      if (price <= PRICE_TIERS.budget.max) return 'budget';
      if (price <= PRICE_TIERS.popular.max) return 'popular';
      return 'premium';
    }

    // ===== CENTRALIZED CORS HANDLING =====
    // Configuration for CORS-friendly domains
    const CORS_CONFIG = {
      // Domains that support CORS natively
      corsFriendly: [
        'cdn.shopify.com',
        'supabase.co',
        'images.weserv.nl',
        'localhost',
        window.location.hostname
      ],
      // Domains that need proxying
      needsProxy: [
        'cdn.msisurfaces.com',
        'cdn.prod.website-files.com',
        'cdn.prod.website-files.com'
      ],
      // Proxy URL template
      proxyUrl: 'https://images.weserv.nl/?url='
    };

    /**
     * Check if URL needs CORS handling
     */
    function needsCorsHandling(url) {
      if (!url) return false;
      return CORS_CONFIG.corsFriendly.some(domain => url.includes(domain));
    }

    /**
     * Check if URL needs to be proxied for CORS
     */
    function needsProxying(url) {
      if (!url) return false;
      return CORS_CONFIG.needsProxy.some(domain => url.includes(domain));
    }

    /**
     * Get proxied URL for CORS (using images.weserv.nl)
     */
    function getProxiedUrl(url) {
      if (!url) return url;
      if (needsProxying(url)) {
        return `${CORS_CONFIG.proxyUrl}${url.replace('https://', '').replace('http://', '')}`;
      }
      return url;
    }

    /**
     * Centralized image loading with proper CORS handling
     * @param {string} url - Image URL to load
     * @param {function} onLoad - Callback when image loads
     * @param {function} onError - Callback on error
     * @returns {Image} - The image element
     */
    function loadImageWithCors(url, onLoad, onError) {
      const img = new Image();

      // Apply proxy if needed
      const finalUrl = getProxiedUrl(url);

      // Only set crossOrigin for CORS-friendly domains (including proxied ones)
      if (needsCorsHandling(finalUrl) || needsProxying(url)) {
        img.crossOrigin = 'anonymous';
      }

      img.onload = () => {
        if (onLoad) onLoad(img);
      };

      img.onerror = (err) => {
        console.warn('Image load failed:', url, err);
        if (onError) onError(err);
      };

      img.src = finalUrl;
      return img;
    }

    /**
     * Load Three.js texture with proper CORS handling
     * @param {string} url - Texture URL
     * @param {function} onLoad - Callback with texture
     * @param {function} onError - Callback on error
     */
    function loadTextureWithCors(url, onLoad, onError) {
      // Apply proxy if needed
      const finalUrl = getProxiedUrl(url);

      // Check LRU cache first
      const cached = getTextureFromCache(finalUrl);
      if (cached) {
        if (onLoad) onLoad(cached.clone());
        return;
      }

      textureLoader.load(
        finalUrl,
        (texture) => {
          // Cache the loaded texture
          addTextureToCache(finalUrl, texture);
          if (url !== finalUrl) {
            addTextureToCache(url, texture);
          }
          if (onLoad) onLoad(texture);
        },
        undefined,
        (err) => {
          console.warn('Texture load failed:', url, err);
          if (onError) onError(err);
        }
      );
    }

    // Cabinet Catalogs from Manufacturers
    const CABINET_CATALOGS = {
      procraft: {
        name: 'ProCraft Cabinetry',
        logo: 'https://cdn.prod.website-files.com/6456ce4476abb25581fbad0c/6456ce4476abb265e5fbb1f1_62708265be16bc2ec3e69111_procraft-cabinetry-p-500.png',
        series: {
          // Painted Finishes (flat/no grain)
          'shaker-white': { name: 'Shaker White', color: '#f5f5f5', finish: 'painted', grainType: 'flat' },
          'shaker-grey': { name: 'Shaker Grey', color: '#7a7a7a', finish: 'painted', grainType: 'flat' },
          'dove-grey': { name: 'Dove Grey', color: '#b0b0b0', finish: 'painted', grainType: 'flat' },
          'navy-blue': { name: 'Navy Blue', color: '#1e3a5f', finish: 'painted', grainType: 'flat' },
          'sage-green': { name: 'Sage Green', color: '#8fbc8f', finish: 'painted', grainType: 'flat' },
          'onyx-black': { name: 'Onyx Black', color: '#1a1a1a', finish: 'painted', grainType: 'flat' },
          // Wood Grain Finishes - Oak
          'natural-oak': { name: 'Natural Oak', color: '#d4a76a', finish: 'wood-grain', grainType: 'oak' },
          'honey-oak': { name: 'Honey Oak', color: '#c4973d', finish: 'wood-grain', grainType: 'oak' },
          'golden-oak': { name: 'Golden Oak', color: '#bb8b41', finish: 'wood-grain', grainType: 'oak' },
          // Wood Grain Finishes - Maple
          'natural-maple': { name: 'Natural Maple', color: '#f5deb3', finish: 'wood-grain', grainType: 'maple' },
          'honey-maple': { name: 'Honey Maple', color: '#e8c07d', finish: 'wood-grain', grainType: 'maple' },
          // Wood Grain Finishes - Cherry
          'cherry': { name: 'Cherry', color: '#a0522d', finish: 'wood-grain', grainType: 'cherry' },
          'dark-cherry': { name: 'Dark Cherry', color: '#8b2500', finish: 'wood-grain', grainType: 'cherry' },
          // Wood Grain Finishes - Walnut
          'walnut': { name: 'Walnut', color: '#5d4037', finish: 'wood-grain', grainType: 'walnut' },
          'dark-walnut': { name: 'Dark Walnut', color: '#3e2723', finish: 'wood-grain', grainType: 'walnut' },
          'shaker-espresso': { name: 'Espresso', color: '#3d2b1f', finish: 'wood-grain', grainType: 'walnut' },
          // Wood Grain Finishes - Hickory
          'hickory': { name: 'Hickory', color: '#b8860b', finish: 'wood-grain', grainType: 'hickory' },
          'pecan': { name: 'Pecan', color: '#9e7b57', finish: 'wood-grain', grainType: 'hickory' }
        },
        cabinets: {
          base: [
            { sku: 'B09', name: 'Base 9"', width: 0.75, height: 2, depth: 2, type: 'base-cabinet', price: 185 },
            { sku: 'B12', name: 'Base 12"', width: 1, height: 2, depth: 2, type: 'base-cabinet', price: 215 },
            { sku: 'B15', name: 'Base 15"', width: 1.25, height: 2, depth: 2, type: 'base-cabinet', price: 245 },
            { sku: 'B18', name: 'Base 18"', width: 1.5, height: 2, depth: 2, type: 'base-cabinet', price: 275 },
            { sku: 'B21', name: 'Base 21"', width: 1.75, height: 2, depth: 2, type: 'base-cabinet', price: 305 },
            { sku: 'B24', name: 'Base 24"', width: 2, height: 2, depth: 2, type: 'base-cabinet', price: 335 },
            { sku: 'B27', name: 'Base 27"', width: 2.25, height: 2, depth: 2, type: 'base-cabinet', price: 365 },
            { sku: 'B30', name: 'Base 30"', width: 2.5, height: 2, depth: 2, type: 'base-cabinet', price: 395 },
            { sku: 'B33', name: 'Base 33"', width: 2.75, height: 2, depth: 2, type: 'base-cabinet', price: 425 },
            { sku: 'B36', name: 'Base 36"', width: 3, height: 2, depth: 2, type: 'base-cabinet', price: 455 },
            { sku: 'B42', name: 'Base 42"', width: 3.5, height: 2, depth: 2, type: 'base-cabinet', price: 515 },
            { sku: 'B48', name: 'Base 48"', width: 4, height: 2, depth: 2, type: 'base-cabinet', price: 575 }
          ],
          wall: [
            { sku: 'W0930', name: 'Wall 9"x30"', width: 0.75, height: 1.25, depth: 2.5, type: 'wall-cabinet', price: 145 },
            { sku: 'W1230', name: 'Wall 12"x30"', width: 1, height: 1.25, depth: 2.5, type: 'wall-cabinet', price: 165 },
            { sku: 'W1530', name: 'Wall 15"x30"', width: 1.25, height: 1.25, depth: 2.5, type: 'wall-cabinet', price: 185 },
            { sku: 'W1830', name: 'Wall 18"x30"', width: 1.5, height: 1.25, depth: 2.5, type: 'wall-cabinet', price: 205 },
            { sku: 'W2130', name: 'Wall 21"x30"', width: 1.75, height: 1.25, depth: 2.5, type: 'wall-cabinet', price: 225 },
            { sku: 'W2430', name: 'Wall 24"x30"', width: 2, height: 1.25, depth: 2.5, type: 'wall-cabinet', price: 245 },
            { sku: 'W3030', name: 'Wall 30"x30"', width: 2.5, height: 1.25, depth: 2.5, type: 'wall-cabinet', price: 285 },
            { sku: 'W3630', name: 'Wall 36"x30"', width: 3, height: 1.25, depth: 2.5, type: 'wall-cabinet', price: 325 },
            { sku: 'W0936', name: 'Wall 9"x36"', width: 0.75, height: 1.25, depth: 3, type: 'wall-cabinet', price: 165 },
            { sku: 'W1236', name: 'Wall 12"x36"', width: 1, height: 1.25, depth: 3, type: 'wall-cabinet', price: 185 },
            { sku: 'W1536', name: 'Wall 15"x36"', width: 1.25, height: 1.25, depth: 3, type: 'wall-cabinet', price: 215 },
            { sku: 'W1836', name: 'Wall 18"x36"', width: 1.5, height: 1.25, depth: 3, type: 'wall-cabinet', price: 245 },
            { sku: 'W2436', name: 'Wall 24"x36"', width: 2, height: 1.25, depth: 3, type: 'wall-cabinet', price: 285 },
            { sku: 'W3036', name: 'Wall 30"x36"', width: 2.5, height: 1.25, depth: 3, type: 'wall-cabinet', price: 335 },
            { sku: 'W3636', name: 'Wall 36"x36"', width: 3, height: 1.25, depth: 3, type: 'wall-cabinet', price: 385 },
            { sku: 'W0942', name: 'Wall 9"x42"', width: 0.75, height: 1.25, depth: 3.5, type: 'wall-cabinet', price: 185 },
            { sku: 'W1242', name: 'Wall 12"x42"', width: 1, height: 1.25, depth: 3.5, type: 'wall-cabinet', price: 215 },
            { sku: 'W1842', name: 'Wall 18"x42"', width: 1.5, height: 1.25, depth: 3.5, type: 'wall-cabinet', price: 275 },
            { sku: 'W2442', name: 'Wall 24"x42"', width: 2, height: 1.25, depth: 3.5, type: 'wall-cabinet', price: 325 },
            { sku: 'W3042', name: 'Wall 30"x42"', width: 2.5, height: 1.25, depth: 3.5, type: 'wall-cabinet', price: 385 },
            { sku: 'W3642', name: 'Wall 36"x42"', width: 3, height: 1.25, depth: 3.5, type: 'wall-cabinet', price: 445 }
          ],
          tall: [
            { sku: 'T189024', name: 'Pantry 18"x90"', width: 1.5, height: 2, depth: 7.5, type: 'tall-cabinet', price: 685 },
            { sku: 'T249024', name: 'Pantry 24"x90"', width: 2, height: 2, depth: 7.5, type: 'tall-cabinet', price: 795 },
            { sku: 'T309024', name: 'Pantry 30"x90"', width: 2.5, height: 2, depth: 7.5, type: 'tall-cabinet', price: 895 },
            { sku: 'T369024', name: 'Pantry 36"x90"', width: 3, height: 2, depth: 7.5, type: 'tall-cabinet', price: 995 },
            { sku: 'OC3390', name: 'Oven Cabinet 33"x90"', width: 2.75, height: 2, depth: 7.5, type: 'tall-cabinet', price: 945 },
            { sku: 'OC3396', name: 'Oven Cabinet 33"x96"', width: 2.75, height: 2, depth: 8, type: 'tall-cabinet', price: 1045 }
          ],
          corner: [
            { sku: 'DERA36', name: 'Diagonal Corner 36"', width: 3, height: 3, depth: 2, type: 'corner-cabinet', price: 545 },
            { sku: 'WDC2430', name: 'Diagonal Wall 24"x30"', width: 2, height: 2, depth: 2.5, type: 'corner-cabinet', price: 385 },
            { sku: 'WDC2436', name: 'Diagonal Wall 24"x36"', width: 2, height: 2, depth: 3, type: 'corner-cabinet', price: 425 },
            { sku: 'WDC2442', name: 'Diagonal Wall 24"x42"', width: 2, height: 2, depth: 3.5, type: 'corner-cabinet', price: 465 }
          ],
          lazySusan: [
            { sku: 'BLS33', name: 'Lazy Susan 33"', width: 2.75, height: 2.75, depth: 2, type: 'lazy-susan', price: 595 },
            { sku: 'BLS36', name: 'Lazy Susan 36"', width: 3, height: 3, depth: 2, type: 'lazy-susan', price: 645 },
            { sku: 'BLS39', name: 'Lazy Susan 39"', width: 3.25, height: 3.25, depth: 2, type: 'lazy-susan', price: 695 }
          ],
          sink: [
            { sku: 'SB30', name: 'Sink Base 30"', width: 2.5, height: 2, depth: 2, type: 'sink-base', price: 365 },
            { sku: 'SB33', name: 'Sink Base 33"', width: 2.75, height: 2, depth: 2, type: 'sink-base', price: 395 },
            { sku: 'SB36', name: 'Sink Base 36"', width: 3, height: 2, depth: 2, type: 'sink-base', price: 425 },
            { sku: 'SB42', name: 'Sink Base 42"', width: 3.5, height: 2, depth: 2, type: 'sink-base', price: 485 }
          ],
          drawer: [
            { sku: 'DB12', name: 'Drawer Base 12"', width: 1, height: 2, depth: 2, type: 'drawer-base', price: 295 },
            { sku: 'DB15', name: 'Drawer Base 15"', width: 1.25, height: 2, depth: 2, type: 'drawer-base', price: 335 },
            { sku: 'DB18', name: 'Drawer Base 18"', width: 1.5, height: 2, depth: 2, type: 'drawer-base', price: 375 },
            { sku: 'DB24', name: 'Drawer Base 24"', width: 2, height: 2, depth: 2, type: 'drawer-base', price: 425 },
            { sku: 'DB30', name: 'Drawer Base 30"', width: 2.5, height: 2, depth: 2, type: 'drawer-base', price: 485 },
            { sku: 'DB36', name: 'Drawer Base 36"', width: 3, height: 2, depth: 2, type: 'drawer-base', price: 545 }
          ]
        }
      },
      msi: {
        name: 'MSI Cabinetry',
        logo: null,
        series: {
          // Painted/Laminate Finishes (flat/no grain)
          'euro-white': { name: 'Euro White', color: '#ffffff', finish: 'matte', grainType: 'flat' },
          'euro-grey': { name: 'Euro Grey', color: '#6a6a6a', finish: 'matte', grainType: 'flat' },
          'shaker-dove': { name: 'Shaker Dove', color: '#d3d3d3', finish: 'painted', grainType: 'flat' },
          'shaker-graphite': { name: 'Shaker Graphite', color: '#4a4a4a', finish: 'painted', grainType: 'flat' },
          'charcoal': { name: 'Charcoal', color: '#36454f', finish: 'painted', grainType: 'flat' },
          'midnight-black': { name: 'Midnight Black', color: '#121212', finish: 'gloss', grainType: 'flat' },
          // Wood Grain Finishes - Oak
          'natural-oak': { name: 'Natural Oak', color: '#d4a76a', finish: 'wood-grain', grainType: 'oak' },
          'light-oak': { name: 'Light Oak', color: '#e0c8a0', finish: 'wood-grain', grainType: 'oak' },
          'autumn-oak': { name: 'Autumn Oak', color: '#c78b4a', finish: 'wood-grain', grainType: 'oak' },
          // Wood Grain Finishes - Hickory/Rustic
          'driftwood': { name: 'Driftwood', color: '#9e8b7d', finish: 'wood-grain', grainType: 'hickory' },
          'barnwood': { name: 'Barnwood', color: '#6b5344', finish: 'wood-grain', grainType: 'hickory' },
          // Wood Grain Finishes - Walnut
          'rustic-walnut': { name: 'Rustic Walnut', color: '#5d4037', finish: 'wood-grain', grainType: 'walnut' },
          'java': { name: 'Java', color: '#3d2b1f', finish: 'wood-grain', grainType: 'walnut' },
          'toffee': { name: 'Toffee', color: '#8b7355', finish: 'wood-grain', grainType: 'walnut' },
          // Wood Grain Finishes - Cherry
          'chestnut': { name: 'Chestnut', color: '#7b3f00', finish: 'wood-grain', grainType: 'cherry' }
        },
        cabinets: {
          base: [
            { sku: 'MSI-B12', name: 'Base 12"', width: 1, height: 2, depth: 2, type: 'base-cabinet', price: 189 },
            { sku: 'MSI-B15', name: 'Base 15"', width: 1.25, height: 2, depth: 2, type: 'base-cabinet', price: 219 },
            { sku: 'MSI-B18', name: 'Base 18"', width: 1.5, height: 2, depth: 2, type: 'base-cabinet', price: 249 },
            { sku: 'MSI-B21', name: 'Base 21"', width: 1.75, height: 2, depth: 2, type: 'base-cabinet', price: 279 },
            { sku: 'MSI-B24', name: 'Base 24"', width: 2, height: 2, depth: 2, type: 'base-cabinet', price: 309 },
            { sku: 'MSI-B27', name: 'Base 27"', width: 2.25, height: 2, depth: 2, type: 'base-cabinet', price: 339 },
            { sku: 'MSI-B30', name: 'Base 30"', width: 2.5, height: 2, depth: 2, type: 'base-cabinet', price: 369 },
            { sku: 'MSI-B33', name: 'Base 33"', width: 2.75, height: 2, depth: 2, type: 'base-cabinet', price: 399 },
            { sku: 'MSI-B36', name: 'Base 36"', width: 3, height: 2, depth: 2, type: 'base-cabinet', price: 429 }
          ],
          wall: [
            { sku: 'MSI-W1230', name: 'Wall 12"x30"', width: 1, height: 1.25, depth: 2.5, type: 'wall-cabinet', price: 149 },
            { sku: 'MSI-W1530', name: 'Wall 15"x30"', width: 1.25, height: 1.25, depth: 2.5, type: 'wall-cabinet', price: 169 },
            { sku: 'MSI-W1830', name: 'Wall 18"x30"', width: 1.5, height: 1.25, depth: 2.5, type: 'wall-cabinet', price: 189 },
            { sku: 'MSI-W2430', name: 'Wall 24"x30"', width: 2, height: 1.25, depth: 2.5, type: 'wall-cabinet', price: 229 },
            { sku: 'MSI-W3030', name: 'Wall 30"x30"', width: 2.5, height: 1.25, depth: 2.5, type: 'wall-cabinet', price: 269 },
            { sku: 'MSI-W3630', name: 'Wall 36"x30"', width: 3, height: 1.25, depth: 2.5, type: 'wall-cabinet', price: 309 },
            { sku: 'MSI-W1236', name: 'Wall 12"x36"', width: 1, height: 1.25, depth: 3, type: 'wall-cabinet', price: 169 },
            { sku: 'MSI-W1536', name: 'Wall 15"x36"', width: 1.25, height: 1.25, depth: 3, type: 'wall-cabinet', price: 199 },
            { sku: 'MSI-W1836', name: 'Wall 18"x36"', width: 1.5, height: 1.25, depth: 3, type: 'wall-cabinet', price: 229 },
            { sku: 'MSI-W2436', name: 'Wall 24"x36"', width: 2, height: 1.25, depth: 3, type: 'wall-cabinet', price: 269 },
            { sku: 'MSI-W3036', name: 'Wall 30"x36"', width: 2.5, height: 1.25, depth: 3, type: 'wall-cabinet', price: 319 },
            { sku: 'MSI-W3636', name: 'Wall 36"x36"', width: 3, height: 1.25, depth: 3, type: 'wall-cabinet', price: 369 }
          ],
          tall: [
            { sku: 'MSI-T1890', name: 'Pantry 18"x90"', width: 1.5, height: 2, depth: 7.5, type: 'tall-cabinet', price: 649 },
            { sku: 'MSI-T2490', name: 'Pantry 24"x90"', width: 2, height: 2, depth: 7.5, type: 'tall-cabinet', price: 749 },
            { sku: 'MSI-T3090', name: 'Pantry 30"x90"', width: 2.5, height: 2, depth: 7.5, type: 'tall-cabinet', price: 849 }
          ],
          corner: [
            { sku: 'MSI-BC36', name: 'Base Corner 36"', width: 3, height: 3, depth: 2, type: 'corner-cabinet', price: 495 },
            { sku: 'MSI-WC24', name: 'Wall Corner 24"', width: 2, height: 2, depth: 2.5, type: 'corner-cabinet', price: 359 }
          ],
          sink: [
            { sku: 'MSI-SB30', name: 'Sink Base 30"', width: 2.5, height: 2, depth: 2, type: 'sink-base', price: 339 },
            { sku: 'MSI-SB33', name: 'Sink Base 33"', width: 2.75, height: 2, depth: 2, type: 'sink-base', price: 369 },
            { sku: 'MSI-SB36', name: 'Sink Base 36"', width: 3, height: 2, depth: 2, type: 'sink-base', price: 399 }
          ],
          drawer: [
            { sku: 'MSI-DB12', name: 'Drawer Base 12"', width: 1, height: 2, depth: 2, type: 'drawer-base', price: 269 },
            { sku: 'MSI-DB15', name: 'Drawer Base 15"', width: 1.25, height: 2, depth: 2, type: 'drawer-base', price: 309 },
            { sku: 'MSI-DB18', name: 'Drawer Base 18"', width: 1.5, height: 2, depth: 2, type: 'drawer-base', price: 349 },
            { sku: 'MSI-DB24', name: 'Drawer Base 24"', width: 2, height: 2, depth: 2, type: 'drawer-base', price: 399 }
          ]
        }
      },
      custom: {
        name: 'Custom Cabinets',
        logo: null,
        series: {},
        cabinets: {
          imported: [] // User-uploaded cabinet list
        }
      }
    };

    let currentCatalog = 'procraft';
    let currentCabinetCategory = 'base';
    let currentCabinetSeries = 'shaker-white';

    // ===== STATE =====
    let canvas, ctx;
    let currentTool = 'select';
    let currentView = '2d';
    let zoom = 1;
    let pixelsPerFoot = 40;
    let elements = [];
    let walls = [];
    let selectedElement = null;
    let elementListDirty = true; // Flag to track when element list needs updating
    let lastSelectedElementId = null; // Track selection changes
    let currentDesignId = null; // Current design ID for messaging/collaboration

    // Expose key variables globally for pro features module
    window.elements = elements;
    window.walls = walls;
    // Note: draw() function is exposed later after it's defined
    let isDragging = false;
    let dragOffset = { x: 0, y: 0 };
    let autoRotationApplied = false; // Track if auto-rotation was applied during this drag
    let lastSnappedWall = null; // Track which wall we last snapped to
    let drawPending = false; // Throttle flag for requestAnimationFrame-based draw batching

    // DOM element cache for frequently accessed elements
    const domCache = {
      elementCount: null,
      elementLayerList: null,
      elementCountDisplay: null,
      quoteItems: null
    };

    // Initialize DOM cache (call after DOM ready)
    function initDomCache() {
      domCache.elementCount = document.getElementById('elementCount');
      domCache.elementLayerList = document.getElementById('elementLayerList');
      domCache.elementCountDisplay = document.getElementById('elementCountDisplay');
      domCache.quoteItems = document.getElementById('quoteItems');
    }

    // Element locking (simple grouping)
    let nextGroupId = 1;

    // Generate unique IDs for elements
    function generateId() {
      return 'el_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    }
    window.generateId = generateId;

    // Element cycling state - for cycling through overlapping elements
    let lastClickPos = { x: 0, y: 0 };
    let lastClickTime = 0;
    let cycleIndex = 0;
    const CLICK_CYCLE_THRESHOLD = 20; // pixels - how close clicks need to be to cycle
    const CLICK_CYCLE_TIME = 1000; // ms - max time between clicks to cycle

    // Resize state
    let isResizing = false;
    let resizeHandle = null; // 'nw', 'n', 'ne', 'e', 'se', 's', 'sw', 'w'
    let resizeStart = { x: 0, y: 0, width: 0, height: 0, elX: 0, elY: 0 };
    const HANDLE_SIZE = 10;

    let roomWidth = 20;
    let roomDepth = 16;
    let roomHeight = 8; // Ceiling height in feet (8', 9', 10', 12')
    let currentFloorPlan = 'empty';
    let contextMenuElement = null;
    let elementTextures = {}; // Store custom textures for element types
    let customMaterials = []; // User uploaded materials

    // Multi-room support
    let rooms = [];
    let currentRoomId = null;

    // Initialize default room
    function initializeRooms() {
      if (rooms.length === 0) {
        rooms.push({
          id: 'room-' + Date.now(),
          name: 'Kitchen',
          type: 'kitchen',
          width: roomWidth,
          depth: roomDepth,
          offsetX: 0,  // Position in multi-room layout
          offsetY: 0,
          elements: [],
          walls: [],
          floorPlan: 'empty'
        });
        currentRoomId = rooms[0].id;
      }
    }

    // ===== POSITION SERIALIZATION (feet-based) =====
    // Store positions in feet so they're stable across viewport sizes and rooms
    function serializeElement(el) {
      return {
        ...el,
        textureImg: null,
        xFt: (el.x || 0) / (pixelsPerFoot || 40),
        yFt: (el.y || 0) / (pixelsPerFoot || 40)
      };
    }

    function serializeWall(wall) {
      const ppf = pixelsPerFoot || 40;
      return {
        ...wall,
        x1Ft: wall.x1 !== undefined ? wall.x1 / ppf : undefined,
        y1Ft: wall.y1 !== undefined ? wall.y1 / ppf : undefined,
        x2Ft: wall.x2 !== undefined ? wall.x2 / ppf : undefined,
        y2Ft: wall.y2 !== undefined ? wall.y2 / ppf : undefined
      };
    }

    function deserializeElement(el, savedPixelsPerFoot) {
      if (el.xFt !== undefined && el.yFt !== undefined) {
        // New format: feet-based  multiply by current scale
        el.x = el.xFt * pixelsPerFoot;
        el.y = el.yFt * pixelsPerFoot;
      } else if (savedPixelsPerFoot && savedPixelsPerFoot !== pixelsPerFoot && savedPixelsPerFoot > 0) {
        // Legacy format: pixel-based  scale ratio conversion
        const ratio = pixelsPerFoot / savedPixelsPerFoot;
        el.x = (el.x || 0) * ratio;
        el.y = (el.y || 0) * ratio;
      }
      return el;
    }

    function deserializeWall(wall, savedPixelsPerFoot) {
      if (wall.x1Ft !== undefined) {
        wall.x1 = wall.x1Ft * pixelsPerFoot;
        wall.y1 = wall.y1Ft * pixelsPerFoot;
        wall.x2 = wall.x2Ft * pixelsPerFoot;
        wall.y2 = wall.y2Ft * pixelsPerFoot;
      } else if (savedPixelsPerFoot && savedPixelsPerFoot !== pixelsPerFoot && savedPixelsPerFoot > 0) {
        const ratio = pixelsPerFoot / savedPixelsPerFoot;
        if (wall.x1 !== undefined) wall.x1 *= ratio;
        if (wall.y1 !== undefined) wall.y1 *= ratio;
        if (wall.x2 !== undefined) wall.x2 *= ratio;
        if (wall.y2 !== undefined) wall.y2 *= ratio;
      }
      return wall;
    }

    // Get current room object
    function getCurrentRoom() {
      return rooms.find(r => r.id === currentRoomId) || rooms[0];
    }

    // Save current room state before switching
    function saveCurrentRoomState() {
      // Check if external code requested to skip this save (e.g., when loading new project data)
      if (window._skipNextRoomSave) {
        window._skipNextRoomSave = false;
        return;
      }

      const room = getCurrentRoom();
      if (room) {
        room.width = roomWidth;
        room.depth = roomDepth;
        // Deep copy with feet-based positions for stable storage
        room.elements = elements.map(el => serializeElement(el));
        room.walls = walls.map(w => serializeWall(w));
        room.floorPlan = currentFloorPlan;
        room.pixelsPerFoot = pixelsPerFoot;
      }
    }

    // Switch to a different room
    function switchToRoom(roomId) {
      saveCurrentRoomState();

      const room = rooms.find(r => r.id === roomId);
      if (!room) return;

      currentRoomId = roomId;
      roomWidth = room.width;
      roomDepth = room.depth;
      currentFloorPlan = room.floorPlan || 'empty';

      // Update UI
      document.getElementById('roomWidth').value = roomWidth;
      document.getElementById('roomDepth').value = roomDepth;
      document.getElementById('roomType').value = room.type || 'kitchen';

      // Recalculate scale for new room dimensions BEFORE deserializing
      const savedScale = room.pixelsPerFoot || pixelsPerFoot;
      fitToScreen();

      // Deep copy + deserialize from feet-based positions
      elements = (room.elements || []).map(el => {
        const copy = { ...el, textureImg: el.textureImg || null };
        return deserializeElement(copy, savedScale);
      });
      walls = (room.walls || []).map(w => {
        const copy = { ...w };
        return deserializeWall(copy, savedScale);
      });

      // Redraw
      draw();
      updateRoomList();
      calculateQuote();

      // Rebuild 3D if in 3D view
      if (currentView === '3d') {
        init3D();
        render3D();
      }

      showToast(`Switched to ${room.name}`, 'info');
    }

    // Add a new room
    function addNewRoom(name, type, width, depth) {
      saveCurrentRoomState();

      // Calculate position for new room (to the right of existing rooms)
      let maxX = 0;
      rooms.forEach(r => {
        const rightEdge = r.offsetX + r.width;
        if (rightEdge > maxX) maxX = rightEdge;
      });

      const newRoom = {
        id: 'room-' + Date.now(),
        name: name || `Room ${rooms.length + 1}`,
        type: type || 'kitchen',
        width: width || 12,
        depth: depth || 10,
        offsetX: maxX + 2,  // 2ft gap between rooms
        offsetY: 0,
        elements: [],
        walls: [],
        floorPlan: 'empty'
      };

      rooms.push(newRoom);
      switchToRoom(newRoom.id);

      return newRoom;
    }

    // Delete a room (legacy multi-room system)
    function deleteRoomLegacy(roomId) {
      if (rooms.length <= 1) {
        showToast('Cannot delete the only room', 'error');
        return;
      }

      const index = rooms.findIndex(r => r.id === roomId);
      if (index === -1) return;

      const roomName = rooms[index].name;
      rooms.splice(index, 1);

      // If deleted current room, switch to first room
      if (currentRoomId === roomId) {
        switchToRoom(rooms[0].id);
      }

      updateRoomList();
      showToast(`Deleted ${roomName}`, 'info');
    }

    // Update room list UI
    function updateRoomList() {
      const container = document.getElementById('roomList');
      if (!container) return;

      container.innerHTML = rooms.map(room => `
        <div class="room-item ${room.id === currentRoomId ? 'active' : ''}" onclick="switchToRoom('${room.id}')">
          <span class="room-icon">${room.type === 'kitchen' ? '' : room.type === 'bathroom' ? '' : ''}</span>
          <span class="room-name" ondblclick="event.stopPropagation(); renameRoom('${room.id}')" title="Double-click to rename">${room.name}</span>
          <span class="room-size">${room.width}'${room.depth}'</span>
          <button class="room-edit-btn" onclick="event.stopPropagation(); renameRoom('${room.id}')" title="Rename room"></button>
          ${rooms.length > 1 ? `<button class="room-delete-btn" onclick="event.stopPropagation(); deleteRoomLegacy('${room.id}')" title="Delete room"></button>` : ''}
        </div>
      `).join('');
    }

    // Rename a room
    function renameRoom(roomId) {
      const room = rooms.find(r => r.id === roomId);
      if (!room) return;

      const newName = prompt('Enter new room name:', room.name);
      if (newName && newName.trim()) {
        room.name = newName.trim();
        updateRoomList();
        showToast(`Room renamed to "${room.name}"`, 'success');
      }
    }

    window.renameRoom = renameRoom;

    // Show add room modal
    function showAddRoomModal() {
      const modal = document.getElementById('addRoomModal');
      if (modal) {
        // Prefill defaults
        const nameInput = document.getElementById('addRoomName');
        if (nameInput) nameInput.value = `Room ${rooms.length + 1}`;
        openModal('addRoomModal');
      } else {
        // Simple prompt fallback
        const name = prompt('Room name:', `Room ${rooms.length + 1}`);
        if (name) {
          const type = prompt('Room type (kitchen, bathroom, laundry, other):', 'kitchen');
          const width = parseInt(prompt('Room width (feet):', '12')) || 12;
          const depth = parseInt(prompt('Room depth (feet):', '10')) || 10;
          addNewRoom(name, type, width, depth);
        }
      }
    }

    function submitAddRoom() {
      const name = document.getElementById('addRoomName').value.trim() || `Room ${rooms.length + 1}`;
      const type = document.getElementById('addRoomType').value || 'kitchen';
      const width = parseInt(document.getElementById('addRoomWidth').value) || 12;
      const depth = parseInt(document.getElementById('addRoomDepth').value) || 10;
      closeModal('addRoomModal');
      addNewRoom(name, type, width, depth);
    }

    // Make functions and variables globally accessible
    window.switchToRoom = switchToRoom;
    window.addNewRoom = addNewRoom;
    window.deleteRoomLegacy = deleteRoomLegacy;
    window.showAddRoomModal = showAddRoomModal;
    window.updateRoomList = updateRoomList;
    window.rooms = rooms;
    window.currentRoomId = currentRoomId;

    // View all rooms in 3D (multi-room layout)
    let viewingAllRooms = false;

    function viewAllRooms3D() {
      saveCurrentRoomState();
      viewingAllRooms = true;

      // Switch to 3D view
      setView('3d');

      // Rebuild 3D scene with all rooms
      setTimeout(() => {
        init3DMultiRoom();
        showToast('Viewing all rooms - click a room to edit', 'info');
      }, 100);
    }

    // Initialize 3D scene with all rooms
    function init3DMultiRoom() {
      if (!window.THREE) {
        console.error('Three.js not loaded');
        return;
      }

      const container = document.getElementById('view3D');
      if (!container) return;

      // Clear existing scene
      container.innerHTML = '';

      // Calculate total layout dimensions
      let totalWidth = 0;
      let totalDepth = 0;
      rooms.forEach(room => {
        const rightEdge = room.offsetX + room.width;
        const bottomEdge = room.offsetY + room.depth;
        if (rightEdge > totalWidth) totalWidth = rightEdge;
        if (bottomEdge > totalDepth) totalDepth = bottomEdge;
      });

      // Create scene
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x1a1a2e);

      // Create camera with view of entire layout
      const camera = new THREE.PerspectiveCamera(
        60,
        container.clientWidth / container.clientHeight,
        0.1,
        1000
      );
      camera.position.set(totalWidth / 2, Math.max(totalWidth, totalDepth) * 1.5, totalDepth * 1.5);
      camera.lookAt(totalWidth / 2, 0, totalDepth / 2);

      // Create renderer with enhanced quality
      const renderer = new THREE.WebGLRenderer({
        antialias: true,
        powerPreference: 'high-performance',
        alpha: false
      });
      renderer.setSize(container.clientWidth, container.clientHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 1.2;
      container.appendChild(renderer.domElement);

      // Add controls
      const controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.target.set(totalWidth / 2, 0, totalDepth / 2);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.update();

      // Enhanced Lighting for clarity
      // Hemisphere light for natural sky/ground ambient
      const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.4);
      hemiLight.position.set(0, 20, 0);
      scene.add(hemiLight);

      // Main ambient for overall illumination
      const ambient = new THREE.AmbientLight(0xffffff, 0.5);
      scene.add(ambient);

      // Key light (sun) - warm directional
      const sun = new THREE.DirectionalLight(0xFFFBF0, 1.2);
      sun.position.set(totalWidth, 25, totalDepth / 2);
      sun.castShadow = true;
      sun.shadow.mapSize.width = 2048;
      sun.shadow.mapSize.height = 2048;
      sun.shadow.camera.near = 0.5;
      sun.shadow.camera.far = 100;
      sun.shadow.camera.left = -30;
      sun.shadow.camera.right = 30;
      sun.shadow.camera.top = 30;
      sun.shadow.camera.bottom = -30;
      sun.shadow.bias = -0.0001;
      scene.add(sun);

      // Fill light - softer, cooler from opposite side
      const fillLight = new THREE.DirectionalLight(0xE8F0FF, 0.4);
      fillLight.position.set(-totalWidth, 15, totalDepth);
      scene.add(fillLight);

      // Rim light for edge definition
      const rimLight = new THREE.DirectionalLight(0xFFFFFF, 0.3);
      rimLight.position.set(0, 5, -totalDepth);
      scene.add(rimLight);

      // Render each room
      rooms.forEach((room, roomIndex) => {
        const roomGroup = new THREE.Group();
        roomGroup.position.set(room.offsetX, 0, room.offsetY);
        roomGroup.userData = { roomId: room.id, roomName: room.name };

        // Floor
        const floorGeo = new THREE.PlaneGeometry(room.width, room.depth);
        const floorMat = new THREE.MeshStandardMaterial({
          color: roomIndex === rooms.findIndex(r => r.id === currentRoomId) ? 0x3a5a8a : 0x2a3a4a,
          side: THREE.DoubleSide
        });
        const floor = new THREE.Mesh(floorGeo, floorMat);
        floor.rotation.x = -Math.PI / 2;
        floor.position.set(room.width / 2, 0, room.depth / 2);
        floor.receiveShadow = true;
        roomGroup.add(floor);

        // Room label
        const canvas = document.createElement('canvas');
        canvas.width = 256;
        canvas.height = 64;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = '#f9cb00';
        ctx.font = 'bold 24px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(room.name, 128, 40);

        const labelTexture = new THREE.CanvasTexture(canvas);
        const labelGeo = new THREE.PlaneGeometry(4, 1);
        const labelMat = new THREE.MeshBasicMaterial({ map: labelTexture, transparent: true });
        const label = new THREE.Mesh(labelGeo, labelMat);
        label.position.set(room.width / 2, 0.1, room.depth / 2);
        label.rotation.x = -Math.PI / 2;
        roomGroup.add(label);

        // Walls (outline)
        const wallHeight = room.height || roomHeight || 8;
        const wallMat = new THREE.MeshStandardMaterial({ color: 0x555555, transparent: true, opacity: 0.3 });

        // Back wall
        const backWall = new THREE.Mesh(new THREE.BoxGeometry(room.width, wallHeight, 0.3), wallMat);
        backWall.position.set(room.width / 2, wallHeight / 2, 0.15);
        roomGroup.add(backWall);

        // Left wall
        const leftWall = new THREE.Mesh(new THREE.BoxGeometry(0.3, wallHeight, room.depth), wallMat);
        leftWall.position.set(0.15, wallHeight / 2, room.depth / 2);
        roomGroup.add(leftWall);

        // Render elements for this room
        if (room.elements && room.elements.length > 0) {
          room.elements.forEach(el => {
            const elMesh = createSimple3DElement(el);
            if (elMesh) {
              // Convert 2D position to 3D
              const x3d = (el.x / pixelsPerFoot);
              const z3d = (el.y / pixelsPerFoot);
              elMesh.position.set(x3d + el.width / 2, 0, z3d + el.height / 2);
              roomGroup.add(elMesh);
            }
          });
        }

        scene.add(roomGroup);
      });

      // Animation loop
      function animate() {
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
      }
      animate();

      // Handle resize
      window.addEventListener('resize', () => {
        camera.aspect = container.clientWidth / container.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(container.clientWidth, container.clientHeight);
      });
    }

    // Create simplified 3D element for multi-room view
    function createSimple3DElement(el) {
      if (!window.THREE) return null;

      const w = el.width;
      const d = el.height;
      let h = 2.5; // default height

      // Adjust height based on type
      if (el.type === 'linen-closet' || el.type === 'linen-tower') h = 6.5;
      else if (el.type.includes('tall')) h = 7;
      else if (el.type.includes('wall-cabinet')) h = 2.5;
      else if (el.type.includes('vanity-') || el.type === 'pedestal-sink') h = 2.9;
      else if (el.type === 'powder-table' || el.type === 'makeup-vanity') h = 2.5;
      else if (el.type.includes('cabinet')) h = 2.9;
      else if (el.type === 'countertop') h = 0.1;
      else if (el.type === 'sink' || el.type === 'stove') h = 0.5;
      else if (el.type === 'refrigerator') h = 5.5;

      const color = new THREE.Color(el.color || '#808080');
      const geometry = new THREE.BoxGeometry(w, h, d);
      const material = new THREE.MeshStandardMaterial({ color: color });
      const mesh = new THREE.Mesh(geometry, material);
      mesh.castShadow = true;
      mesh.position.y = h / 2;

      return mesh;
    }

    // Export multi-room layout
    function exportMultiRoomLayout() {
      saveCurrentRoomState();

      const layoutData = {
        version: '1.0',
        projectName: document.getElementById('projectName').value || 'Multi-Room Design',
        createdAt: new Date().toISOString(),
        rooms: rooms.map(room => ({
          ...room,
          elements: room.elements.map(el => ({ ...el, textureImg: null }))
        })),
        currentRoomId: currentRoomId
      };

      const blob = new Blob([JSON.stringify(layoutData, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `multi-room-layout-${Date.now()}.json`;
      a.click();
      URL.revokeObjectURL(url);

      showToast('Layout exported successfully', 'success');
    }

    window.viewAllRooms3D = viewAllRooms3D;
    window.exportMultiRoomLayout = exportMultiRoomLayout;

    // Pan offset (for infinite canvas navigation)
    let panX = 0;
    let panY = 0;
    let isPanning = false;
    let panStart = { x: 0, y: 0 };
    let viewLocked = false; // Lock view to prevent accidental pan/zoom

    // Wall drawing
    let isDrawingWall = false;
    let wallStart = null;

    // Countertop drawing
    let isDrawingCountertop = false;
    let countertopStart = null;

    // Cabinet Settings State
    let cabinetSettings = {
      construction: 'frameless', // 'frameless' or 'framed'
      doorStyle: 'shaker',       // 'shaker', 'shaker-beaded', 'flat', 'raised', 'slab'
      doorOverlay: 'full',       // 'full', 'partial', 'inset'
      cabinetFinish: 'wood-grain', // 'wood-grain', 'painted', 'matte', 'gloss'
      grainType: 'oak',          // 'oak', 'walnut', 'cherry', 'maple', 'hickory', 'flat'
      currentFloor: 1,
      floors: [{ id: 1, name: 'Floor 1', height: 0 }]
    };

    // Environment/Scene settings
    let sceneSettings = {
      timeOfDay: 'noon', // 'morning', 'noon', 'evening', 'night'
      showOutdoorView: true,
      showFrontWall: false, // Show 4th wall (front wall) - useful for enclosed rooms
      wallTransparency: 0.3 // Transparency for front wall when shown
    };

    // Outdoor view colors based on time of day
    const OUTDOOR_COLORS = {
      morning: { sky: 0xFDB813, horizon: 0xFFE4B5, ambient: 0xFFF8DC },
      noon: { sky: 0x87CEEB, horizon: 0xE0F7FA, ambient: 0xFFFFFF },
      evening: { sky: 0xFFA07A, horizon: 0xFFDAB9, ambient: 0xFFE4C4 },
      night: { sky: 0x191970, horizon: 0x2F4F4F, ambient: 0x404040 }
    };

    // Three.js
    let scene, camera, renderer, controls;
    let composer; // Post-processing effect composer
    let animationId = null; // Track animation frame to prevent duplicates
    let postProcessingEnabled = true; // Toggle for post-processing effects

    // ===== INCREMENTAL 3D SCENE UPDATE SYSTEM =====
    // Mesh cache: element ID -> { group: THREE.Group, version: number }
    const meshCache3D = new Map();
    // Element versions: element ID -> version number (incremented on change)
    const elementVersions = new Map();
    // Dirty elements that need 3D update
    const dirtyElements3D = new Set();
    // Flag to force full scene rebuild
    let forceFullRebuild3D = true;
    // Cached room structure
    let cachedRoomStructure = null;
    let cachedRoomDimensions = { width: 0, depth: 0, height: 0 };

    /**
     * Mark an element as needing 3D update
     */
    function markElement3DDirty(elementId) {
      if (elementId) {
        dirtyElements3D.add(elementId);
        // Increment version
        const currentVersion = elementVersions.get(elementId) || 0;
        elementVersions.set(elementId, currentVersion + 1);
      }
    }

    /**
     * Mark all elements as dirty (for full rebuild scenarios)
     */
    function markAllElements3DDirty() {
      elements.forEach(el => markElement3DDirty(el.id));
      forceFullRebuild3D = true;
    }

    /**
     * Remove element from 3D cache and scene
     */
    function removeElement3D(elementId) {
      const cached = meshCache3D.get(elementId);
      if (cached && cached.group) {
        // Dispose geometry and materials
        cached.group.traverse(obj => {
          if (obj.geometry) obj.geometry.dispose();
          if (obj.material) {
            if (Array.isArray(obj.material)) {
              obj.material.forEach(m => {
                if (m.map) m.map.dispose();
                m.dispose();
              });
            } else {
              if (obj.material.map) obj.material.map.dispose();
              obj.material.dispose();
            }
          }
        });
        // Remove from scene
        if (scene) scene.remove(cached.group);
      }
      meshCache3D.delete(elementId);
      elementVersions.delete(elementId);
      dirtyElements3D.delete(elementId);
    }

    /**
     * Clear all 3D caches (for full cleanup)
     */
    function clearAll3DCaches() {
      meshCache3D.forEach((cached, id) => {
        if (cached && cached.group) {
          cached.group.traverse(obj => {
            if (obj.geometry) obj.geometry.dispose();
            if (obj.material) {
              if (Array.isArray(obj.material)) {
                obj.material.forEach(m => m.dispose());
              } else {
                obj.material.dispose();
              }
            }
          });
        }
      });
      meshCache3D.clear();
      elementVersions.clear();
      dirtyElements3D.clear();
      cachedRoomStructure = null;
      forceFullRebuild3D = true;
    }

    // ===== INITIALIZATION =====
    document.addEventListener('DOMContentLoaded', init);

    // Undo/Redo state
    let undoStack = [];
    let redoStack = [];
    const MAX_UNDO_STATES = 50;

    // Track if we're waiting for login to continue
    let pendingAuthInit = false;
    let workspaceInitialized = false;

    // Wait for SgAuth to initialize (shared auth system)
    async function waitForAuth() {
      // Wait for SgAuth to be available
      let attempts = 0;
      while (!window.SgAuth && attempts < 30) {
        await new Promise(r => setTimeout(r, 100));
        attempts++;
      }

      // Wait for SgAuth to initialize with error handling
      if (window.SgAuth && window.SgAuth.init) {
        try {
          await window.SgAuth.init();
        } catch (err) {
          // Handle AbortError and other init errors gracefully
          if (err.name === 'AbortError') {
            console.warn('SgAuth init aborted (may have timed out):', err.message);
          } else {
            console.warn('SgAuth init error:', err);
          }
          // Continue without auth - user can still use the tool
        }
      }
    }

    async function init() {
      // Start preloader animation immediately
      showPreloader('Loading workspace', 'Surprise Granite');

      // Check if viewing a shared design (allow without login)
      const urlParams = new URLSearchParams(window.location.search);
      const shareToken = urlParams.get('share') || urlParams.get('p');

      // Check for subscription callback (returning from Stripe)
      const subscriptionStatus = urlParams.get('subscription');
      const subscriptionPlan = urlParams.get('plan');

      if (subscriptionStatus) {
        // Clean URL
        const cleanUrl = new URL(window.location);
        cleanUrl.searchParams.delete('subscription');
        cleanUrl.searchParams.delete('plan');
        history.replaceState(null, '', cleanUrl.toString());

        // Show appropriate message after workspace loads
        setTimeout(() => handleSubscriptionCallback(subscriptionStatus, subscriptionPlan), 1000);
      }

      // Check if this is an OAuth callback (has hash with access_token)
      const hashParams = new URLSearchParams(window.location.hash.substring(1));
      const isOAuthCallback = hashParams.has('access_token') || hashParams.has('error');

      // Wait for global auth system to be ready
      await waitForAuth();

      const supabase = getSupabaseClient();

      if (isOAuthCallback && supabase) {
        // Wait for Supabase to process the OAuth callback
        // Clear the hash from URL for cleaner look
        history.replaceState(null, '', window.location.pathname + window.location.search);

        // Give Supabase a moment to process the tokens
        await new Promise(resolve => setTimeout(resolve, 500));

        // Check session after OAuth processing
        try {
          const { data: { session } } = await supabase.auth.getSession();
          if (session) {
            initializeWorkspace();
            return;
          }
        } catch (authErr) {
          if (authErr.name !== 'AbortError') {
            console.warn('OAuth callback session check failed:', authErr.message);
          }
          // Continue without auth
        }
      }

      // If NOT a shared design, check authentication
      // Allow local file:// access without login for development
      const isLocalFile = window.location.protocol === 'file:';

      if (!shareToken && !isLocalFile) {
        // First check if SgAuth already has a logged-in user
        if (window.SgAuth && window.SgAuth.isLoggedIn()) {
          initializeWorkspace();
          return;
        }

        // Check if Supabase is available
        if (!supabase) {
          console.warn('Supabase not available, continuing without auth');
          initializeWorkspace();
          return;
        }

        // Try to get session with error handling
        let session = null;
        try {
          const result = await supabase.auth.getSession();
          session = result.data?.session;
        } catch (authErr) {
          // AbortError is benign - happens during page refresh/navigation
          if (authErr.name !== 'AbortError') {
            console.warn('Auth session check failed:', authErr.message);
          }
          // Continue without session - will initialize workspace
        }

        if (!session) {
          // Not logged in - show login prompt with guest option
          pendingAuthInit = true;
          hidePreloader();
          showLoginPromptRequired();

          // Listen for auth state changes (for when user logs in)
          try {
            supabase.auth.onAuthStateChange((event, session) => {
              if (event === 'SIGNED_IN' && session && !workspaceInitialized) {
                pendingAuthInit = false;
                // Force close login modal (remove required attribute first)
                const loginModal = document.getElementById('loginModal');
                loginModal.removeAttribute('data-required');
                loginModal.classList.remove('active');
                initializeWorkspace();
              }
            });
          } catch (authErr) {
            if (authErr.name !== 'AbortError') {
              console.warn('Auth state listener failed:', authErr.message);
            }
          }
          return;
        }
      }

      // Continue with normal initialization
      initializeWorkspace();
    }

    // Initialize the workspace (called after auth check passes)
    function initializeWorkspace() {
      if (workspaceInitialized) return; // Prevent double initialization
      workspaceInitialized = true;

      // Initialize DOM cache for frequently accessed elements
      initDomCache();

      canvas = document.getElementById('canvas');
      ctx = canvas.getContext('2d');

      renderSidebar();
      renderFloorPlans();
      renderMaterials('granite');

      // Initialize cabinet catalog with series dropdown
      changeCatalog(currentCatalog);
      renderCabinetCatalog();

      // Load extended stone pricing from Excel import (async, non-blocking)
      loadStonePricing().then(count => {
        if (count > 0) {
          showToast(`Loaded ${count} stone materials with pricing`, 'success');
        }
        // Load countertops.json (874 products with images) after stone pricing
        return loadCountertopsJson();
      }).then(ctCount => {
        if (ctCount > 0) {
          showToast(`Loaded ${ctCount} countertop colors with images`, 'success');
        }
        // Load tile.json (466 tiles) then bravo-tile.json (pricing)
        return loadTileJson();
      }).then(tileCount => {
        if (tileCount > 0) {
          showToast(`Loaded ${tileCount} tile products`, 'success');
        }
        return loadBravoTileJson();
      }).then(bravoCount => {
        if (bravoCount > 0) {
          showToast(`Loaded Bravo Tile pricing for ${bravoCount} products`, 'success');
        }
        // Load sinks from sinks.json
        return loadSinksJson();
      }).then(sinksCount => {
        if (sinksCount > 0) {
          showToast(`Loaded ${sinksCount} sinks from marketplace`, 'success');
        }
        // Load faucets from faucets.json
        return loadFaucetsJson();
      }).then(faucetsCount => {
        if (faucetsCount > 0) {
          showToast(`Loaded ${faucetsCount} faucets from marketplace`, 'success');
        }
        // Load flooring from flooring.json
        return loadFlooringJson();
      }).then(flooringCount => {
        if (flooringCount > 0) {
          showToast(`Loaded ${flooringCount} flooring products from marketplace`, 'success');
        }
        // Load products from Supabase last
        loadSupabaseProducts();
        // Pre-fetch distributor data for the default tab after static data loads
        setTimeout(() => {
          if (typeof loadDistributorDataForCategory === 'function') {
            loadDistributorDataForCategory(currentMaterialCategory || 'granite');
          }
        }, 1000);
      });

      setupEventListeners();
      setupDragDrop();
      fitToScreen();

      // Check for special URL parameters (share links, approval links)
      const urlParams = new URLSearchParams(window.location.search);
      const shareToken = urlParams.get('share') || urlParams.get('p');
      const approvalToken = urlParams.get('approval');
      let autoSaveLoaded = false;

      // Only auto-load if explicitly coming from a share/approval link
      // Otherwise always start fresh - users can load designs from "My Designs"
      if (shareToken || approvalToken) {
        // Let the share/approval handlers load the appropriate design
        autoSaveLoaded = false;
      }
      // Designer always opens with fresh canvas - no auto-restore

      // Initialize multi-room system (only creates new room if no rooms exist from autosave)
      initializeRooms();

      // Only sync elements with first room if we DIDN'T load from autosave
      // (autosave already has proper room-element associations)
      if (!autoSaveLoaded) {
        const firstRoom = getCurrentRoom();
        if (firstRoom) {
          firstRoom.elements = elements;
          firstRoom.walls = walls;
        }
      }
      updateRoomList();

      // Initialize auth UI
      initAuth();

      // Check pricing access based on subscription status
      checkPricingAccess();

      // Check for shared design URL
      checkSharedDesignUrl();

      // Check for lead info from account page
      checkLeadInfo();

      // Restore lead context from localStorage (if not coming fresh from account)
      if (!currentLeadInfo) {
        restoreLeadInfo();
      }

      // Keyboard shortcuts for undo/redo and new design
      document.addEventListener('keydown', (e) => {
        if ((e.ctrlKey || e.metaKey) && e.key === 'z') {
          e.preventDefault();
          if (e.shiftKey) {
            redo();
          } else {
            undo();
          }
        }
        if ((e.ctrlKey || e.metaKey) && e.key === 'y') {
          e.preventDefault();
          redo();
        }
        // Ctrl+N for new design
        if ((e.ctrlKey || e.metaKey) && e.key === 'n') {
          e.preventDefault();
          createNewDesign();
        }
        // ? or F1 for keyboard shortcuts help
        if (e.key === '?' || e.key === 'F1') {
          e.preventDefault();
          openModal('shortcutsModal');
        }
      });

      // Auto-hide keyboard shortcuts bar after 5 seconds
      const shortcutsHint = document.getElementById('shortcutsHint');
      if (shortcutsHint) {
        setTimeout(() => {
          shortcutsHint.classList.add('hidden');
        }, 5000);

        // Show on hover
        shortcutsHint.addEventListener('mouseenter', () => {
          shortcutsHint.classList.remove('hidden');
        });

        // Hide again after mouse leaves (with delay)
        shortcutsHint.addEventListener('mouseleave', () => {
          setTimeout(() => {
            shortcutsHint.classList.add('hidden');
          }, 2000);
        });
      }

      // Show restore notification if autosave was loaded earlier
      if (autoSaveLoaded) {
        showToast(`Restored your design (${elements.length} elements)`, 'success');
        draw();
        render3D();
      }

      // Save initial undo state AFTER loading any saved design
      saveUndoState();

      // Initialize element selector dropdown and item picker
      updateElementSelector();
      updateItemPicker();

      // Hide preloader - workspace is ready
      hidePreloader();

      // Ensure messages section is visible (for signed-in designers)
      const messagesSection = document.getElementById('messagesSection');
      if (messagesSection) {
        messagesSection.style.display = 'block';
        const content = document.getElementById('messagesContent');
        if (content) content.style.display = 'block';
        console.log('Messages section visibility ensured');
      }

      // Show auto-save indicator
      console.log('Room Designer initialized. Auto-save enabled.');
    }

    // ===== AUTO-SAVE TO LOCALSTORAGE =====
    const AUTOSAVE_KEY = 'room_designer_autosave';
    let autosaveTimeout = null;
    let lastAutoSaveTimestamp = 0;
    let hasUnsavedChanges = false;

    function autoSaveDesign(immediate = false) {
      hasUnsavedChanges = true;
      updateSaveStatus('unsaved');

      // CRITICAL: Never auto-save for view-only shared viewers
      // But allow full_collab shared viewers to save (they have edit permission)
      if (SHARE_STATE.isSharedView && !isFullCollaborator()) {
        console.log('Auto-save skipped: viewing shared design (read-only for save purposes)');
        return;
      }

      // Debounce auto-save to avoid excessive writes
      if (autosaveTimeout) clearTimeout(autosaveTimeout);

      const doSave = async () => {
        updateSaveStatus('saving');
        try {
          // SAFETY: Don't overwrite existing non-empty save with empty state
          if (elements.length === 0) {
            try {
              const existingSave = localStorage.getItem(AUTOSAVE_KEY);
              if (existingSave) {
                const existing = JSON.parse(existingSave);
                if (existing.elements && existing.elements.length > 0) {
                  console.log('Auto-save skipped: would overwrite', existing.elements.length, 'elements with empty state');
                  return;
                }
              }
            } catch (e) { /* parse error  safe to overwrite */ }
          }

          // Save current room state before saving
          if (typeof saveCurrentRoomState === 'function') {
            saveCurrentRoomState();
          }

          const saveData = {
            elements: elements.map(el => serializeElement(el)),
            walls: walls.map(w => serializeWall(w)),
            roomWidth: roomWidth,
            roomDepth: roomDepth,
            roomHeight: roomHeight,
            roomType: document.getElementById('roomType')?.value || 'kitchen',
            projectName: document.getElementById('projectName')?.value || 'Untitled',
            timestamp: Date.now(),
            version: 4, // v4: feet-based positions (xFt/yFt)
            pixelsPerFoot: pixelsPerFoot,
            // Save multi-room data (already serialized by saveCurrentRoomState)
            rooms: rooms.map(room => ({
              ...room,
              elements: (room.elements || []).map(el =>
                el.xFt !== undefined ? { ...el, textureImg: null } : serializeElement(el)
              ),
              walls: (room.walls || []).map(w =>
                w.x1Ft !== undefined ? { ...w } : serializeWall(w)
              )
            })),
            currentRoomId: currentRoomId,
            currentRoom: currentRoom,
            projectRooms: projectRooms
          };
          const saveJson = JSON.stringify(saveData);

          // Create backup of previous save before overwriting (rotate 2 generations)
          try {
            const prevSave = localStorage.getItem(AUTOSAVE_KEY);
            if (prevSave) {
              // Only backup if previous save has meaningful content
              try {
                const prevData = JSON.parse(prevSave);
                if (prevData.elements && prevData.elements.length > 0) {
                  // Rotate: backup  backup2, current  backup
                  const existingBackup = localStorage.getItem(AUTOSAVE_KEY + '_backup');
                  if (existingBackup) {
                    try { localStorage.setItem(AUTOSAVE_KEY + '_backup2', existingBackup); } catch(e) {}
                  }
                  localStorage.setItem(AUTOSAVE_KEY + '_backup', prevSave);
                }
              } catch (e) { /* corrupted  don't back up corrupted data */ }
            }
          } catch (backupErr) {
            console.warn('Backup save failed, freeing space:', backupErr.message);
            try {
              const designs = JSON.parse(localStorage.getItem('room_designs') || '[]');
              if (designs.length > 5) {
                localStorage.setItem('room_designs', JSON.stringify(designs.slice(0, 5)));
                console.log('Trimmed local designs from', designs.length, 'to 5 to free quota');
                const prevSave = localStorage.getItem(AUTOSAVE_KEY);
                if (prevSave) localStorage.setItem(AUTOSAVE_KEY + '_backup', prevSave);
              }
            } catch (trimErr) { /* give up on backup */ }
          }

          try {
            localStorage.setItem(AUTOSAVE_KEY, saveJson);
          } catch (quotaErr) {
            // Main save quota exceeded  trim designs and retry
            console.warn('Auto-save quota exceeded, freeing space...');
            try {
              const designs = JSON.parse(localStorage.getItem('room_designs') || '[]');
              if (designs.length > 3) {
                localStorage.setItem('room_designs', JSON.stringify(designs.slice(0, 3)));
              }
              localStorage.removeItem(AUTOSAVE_KEY + '_backup');
              localStorage.setItem(AUTOSAVE_KEY, saveJson);
            } catch (retryErr) {
              console.error('Auto-save failed even after freeing space:', retryErr);
            }
          }
          lastAutoSaveTimestamp = Date.now();
          hasUnsavedChanges = false;
          console.log('Auto-saved design:', elements.length, 'elements');

          // Show subtle auto-save feedback
          showAutoSaveIndicator();

          // ===== REALTIME SYNC TO CLOUD =====
          // If design is saved to cloud, sync changes for live viewers
          // Allow full_collab shared viewers to sync their edits too
          if (SHARE_STATE.designId && (!SHARE_STATE.isSharedView || isFullCollaborator())) {
            syncDesignToCloud();
          }
        } catch (e) {
          console.warn('Auto-save failed:', e);
          updateSaveStatus('error', 'Save failed');
        }
      };

      if (immediate) {
        doSave();
      } else {
        autosaveTimeout = setTimeout(doSave, 1000); // 1 second debounce
      }
    }

    // Sync design changes to cloud for realtime updates
    let cloudSyncTimeout = null;
    async function syncDesignToCloud() {
      // Debounce cloud sync to avoid excessive API calls
      if (cloudSyncTimeout) clearTimeout(cloudSyncTimeout);

      cloudSyncTimeout = setTimeout(async () => {
        if (!SHARE_STATE.designId) return;

        const supabase = getSupabaseClient();
        if (!supabase) return;

        try {
          const updateData = {
            elements: elements.map(el => serializeElement(el)),
            room_width: roomWidth,
            room_depth: roomDepth,
            settings: {
              walls: walls.map(w => serializeWall(w)),
              pricing_config: {
                globalMargin: PRICING_STATE.globalMargin,
                categoryMargins: PRICING_STATE.categoryMargins,
                customPrices: PRICING_STATE.customPrices
              },
              pixelsPerFoot: pixelsPerFoot,
              rooms: rooms.map(room => ({
                ...room,
                elements: (room.elements || []).map(el =>
                  el.xFt !== undefined ? { ...el, textureImg: null } : serializeElement(el)
                ),
                walls: (room.walls || []).map(w =>
                  w.x1Ft !== undefined ? { ...w } : serializeWall(w)
                )
              }))
            },
            updated_at: new Date().toISOString()
          };

          const { error } = await supabase
            .from('room_designs')
            .update(updateData)
            .eq('id', SHARE_STATE.designId);

          if (error) {
            console.warn('Cloud sync failed:', error);
          } else {
            console.log('Design synced to cloud - live viewers will see update');
            _lastOwnSyncTime = Date.now(); // Echo-back prevention
          }
        } catch (err) {
          console.warn('Cloud sync error:', err);
        }
      }, 2000); // 2 second debounce for cloud sync
    }

    // Helper to check if there's any design data to save
    function hasDesignData() {
      if (elements.length > 0) return true;
      if (rooms.some(r => r.elements && r.elements.length > 0)) return true;
      return false;
    }

    // Save before page unload
    window.addEventListener('beforeunload', (e) => {
      if (hasDesignData()) {
        // Save current room state first
        if (typeof saveCurrentRoomState === 'function') {
          saveCurrentRoomState();
        }
        // Force immediate save
        autoSaveDesign(true);

        // Only show warning if there are unsaved changes
        if (hasUnsavedChanges) {
          e.preventDefault();
          e.returnValue = 'You have unsaved changes. Are you sure you want to leave?';
          return e.returnValue;
        }
      }
    });

    // Also save on visibility change (tab switch, minimize)
    document.addEventListener('visibilitychange', () => {
      if (document.visibilityState === 'hidden' && hasDesignData()) {
        if (typeof saveCurrentRoomState === 'function') {
          saveCurrentRoomState();
        }
        autoSaveDesign(true);
      }
    });

    // Periodic auto-save every 30 seconds if there are changes
    setInterval(() => {
      if (hasUnsavedChanges && hasDesignData()) {
        autoSaveDesign(true);
      }
    }, 30000);

    // ===== INACTIVITY TIMEOUT =====
    const INACTIVITY_TIMEOUT = 5 * 60 * 1000; // 5 minutes
    const INACTIVITY_WARNING = 60 * 1000; // 1 minute warning before timeout
    let lastActivityTime = Date.now();
    let inactivityTimer = null;
    let warningTimer = null;
    let isSessionLocked = false;

    function resetActivityTimer() {
      lastActivityTime = Date.now();

      // Clear existing timers
      if (inactivityTimer) clearTimeout(inactivityTimer);
      if (warningTimer) clearTimeout(warningTimer);

      // Hide warning if shown
      hideInactivityWarning();

      // Don't set new timers if session is locked
      if (isSessionLocked) return;

      // Set warning timer (1 minute before timeout)
      warningTimer = setTimeout(() => {
        showInactivityWarning();
      }, INACTIVITY_TIMEOUT - INACTIVITY_WARNING);

      // Set timeout timer
      inactivityTimer = setTimeout(() => {
        handleInactivityTimeout();
      }, INACTIVITY_TIMEOUT);
    }

    function showInactivityWarning() {
      // Don't show if no work to save
      if (elements.length === 0) return;

      // Create warning modal if it doesn't exist
      let modal = document.getElementById('inactivityModal');
      if (!modal) {
        modal = document.createElement('div');
        modal.id = 'inactivityModal';
        modal.className = 'modal-overlay';
        modal.innerHTML = `
          <div class="modal" style="max-width: 400px; text-align: center;">
            <div class="modal-header">
              <h3 style="color: #f59e0b;"> Session Timeout Warning</h3>
            </div>
            <div class="modal-body" style="padding: 20px;">
              <p style="font-size: 16px; margin-bottom: 15px;">You've been inactive for a while.</p>
              <p style="margin-bottom: 20px;">Your session will be saved and locked in <strong id="inactivityCountdown">60</strong> seconds.</p>
              <button class="btn btn-primary" onclick="stayActive()" style="padding: 12px 30px; font-size: 16px;">
                I'm Still Here
              </button>
            </div>
          </div>
        `;
        document.body.appendChild(modal);
      }

      modal.classList.add('active');

      // Start countdown
      let countdown = 60;
      const countdownEl = document.getElementById('inactivityCountdown');
      const countdownInterval = setInterval(() => {
        countdown--;
        if (countdownEl) countdownEl.textContent = countdown;
        if (countdown <= 0 || isSessionLocked) {
          clearInterval(countdownInterval);
        }
      }, 1000);

      modal.dataset.countdownInterval = countdownInterval;
    }

    function hideInactivityWarning() {
      const modal = document.getElementById('inactivityModal');
      if (modal) {
        modal.classList.remove('active');
        if (modal.dataset.countdownInterval) {
          clearInterval(parseInt(modal.dataset.countdownInterval));
        }
      }
    }

    function stayActive() {
      hideInactivityWarning();
      resetActivityTimer();
      showToast('Session extended', 'success');
    }

    function handleInactivityTimeout() {
      // Save work first
      if (elements.length > 0) {
        autoSaveDesign(true);
      }

      isSessionLocked = true;
      hideInactivityWarning();

      // Show locked screen
      let lockScreen = document.getElementById('sessionLockScreen');
      if (!lockScreen) {
        lockScreen = document.createElement('div');
        lockScreen.id = 'sessionLockScreen';
        lockScreen.style.cssText = `
          position: fixed;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          background: rgba(0, 0, 0, 0.9);
          z-index: 100000;
          display: flex;
          align-items: center;
          justify-content: center;
          flex-direction: column;
        `;
        lockScreen.innerHTML = `
          <div style="text-align: center; color: white; padding: 40px;">
            <div style="font-size: 60px; margin-bottom: 20px;"></div>
            <h2 style="font-size: 28px; margin-bottom: 15px;">Session Timed Out</h2>
            <p style="font-size: 16px; color: #aaa; margin-bottom: 10px;">You were inactive for 5 minutes.</p>
            <p style="font-size: 14px; color: #888; margin-bottom: 30px;">Your work has been saved automatically.</p>
            <button onclick="unlockSession()" style="
              background: linear-gradient(135deg, #3b82f6, #2563eb);
              color: white;
              border: none;
              padding: 15px 40px;
              font-size: 18px;
              border-radius: 8px;
              cursor: pointer;
              font-weight: 600;
            ">
              Resume Working
            </button>
          </div>
        `;
        document.body.appendChild(lockScreen);
      }
      lockScreen.style.display = 'flex';
    }

    function unlockSession() {
      isSessionLocked = false;
      const lockScreen = document.getElementById('sessionLockScreen');
      if (lockScreen) {
        lockScreen.style.display = 'none';
      }
      resetActivityTimer();
      showToast('Welcome back! Your work was saved.', 'success');
    }

    // Track user activity
    const activityEvents = ['mousedown', 'mousemove', 'keydown', 'touchstart', 'scroll', 'click'];
    activityEvents.forEach(event => {
      document.addEventListener(event, () => {
        if (!isSessionLocked) {
          resetActivityTimer();
        }
      }, { passive: true });
    });

    // Start activity tracking
    resetActivityTimer();

    function loadAutoSavedDesign() {
      try {
        const saved = localStorage.getItem(AUTOSAVE_KEY);
        if (!saved) {
          console.log('No auto-save found');
          return false;
        }

        const data = JSON.parse(saved);
        if (!data.elements || !Array.isArray(data.elements)) {
          console.log('Invalid auto-save data');
          return false;
        }

        // Check if save is recent (within 30 days)
        const age = Date.now() - (data.timestamp || 0);
        const maxAge = 30 * 24 * 60 * 60 * 1000; // 30 days
        if (age > maxAge) {
          console.log('Auto-save too old, clearing');
          clearAutoSave();
          return false;
        }

        // Skip if no elements to restore
        if (data.elements.length === 0) {
          console.log('Auto-save is empty');
          return false;
        }

        // Restore elements
        elements.length = 0;
        data.elements.forEach(el => {
          // Ensure element has required properties
          if (!el.id) el.id = Date.now() + Math.random();
          if (!el.type) return; // Skip invalid elements

          // Restore texture images if URLs exist
          if (el.texture && !el.textureImg) {
            const img = new Image();
            img.crossOrigin = 'anonymous';
            img.onload = () => {
              el.textureImg = img;
              draw();
            };
            img.onerror = () => {
              console.warn('Failed to load texture:', el.texture);
            };
            img.src = el.texture;
          }
          elements.push(el);
        });

        // Restore walls
        if (data.walls && Array.isArray(data.walls)) {
          walls.length = 0;
          data.walls.forEach(w => walls.push(w));
        }

        // Restore room settings with validation
        if (data.roomWidth && data.roomWidth > 0 && data.roomWidth <= 100) {
          roomWidth = data.roomWidth;
          const roomWidthEl = document.getElementById('roomWidth');
          if (roomWidthEl) roomWidthEl.value = roomWidth;
        }
        if (data.roomDepth && data.roomDepth > 0 && data.roomDepth <= 100) {
          roomDepth = data.roomDepth;
          const roomDepthEl = document.getElementById('roomDepth');
          if (roomDepthEl) roomDepthEl.value = roomDepth;
        }
        if (data.roomHeight && data.roomHeight > 0 && data.roomHeight <= 30) {
          roomHeight = data.roomHeight;
          const roomHeightEl = document.getElementById('roomHeight');
          if (roomHeightEl) roomHeightEl.value = roomHeight;
        }
        if (data.roomType) {
          const roomTypeEl = document.getElementById('roomType');
          if (roomTypeEl) roomTypeEl.value = data.roomType;
        }
        if (data.projectName) {
          const projectNameEl = document.getElementById('projectName');
          if (projectNameEl) projectNameEl.value = data.projectName;
        }

        // Restore multi-room data if present
        if (data.rooms && Array.isArray(data.rooms) && data.rooms.length > 0) {
          rooms.length = 0;
          data.rooms.forEach(room => {
            // Restore texture images in room elements
            if (room.elements) {
              room.elements.forEach(el => {
                if (el.texture && !el.textureImg) {
                  const img = new Image();
                  img.crossOrigin = 'anonymous';
                  img.onload = () => {
                    el.textureImg = img;
                    draw();
                  };
                  img.src = el.texture;
                }
              });
            }
            rooms.push(room);
          });
          console.log('Restored', rooms.length, 'rooms');
        }
        if (data.currentRoomId) {
          currentRoomId = data.currentRoomId;
        }
        if (data.currentRoom) {
          currentRoom = data.currentRoom;
        }
        if (data.projectRooms && Array.isArray(data.projectRooms)) {
          projectRooms.length = 0;
          data.projectRooms.forEach(r => projectRooms.push(r));
        }

        // Deserialize positions from feet-based format (or legacy pixel-based with scale conversion)
        updateCanvasSize(); // Calculate current pixelsPerFoot first
        const savedScale = data.pixelsPerFoot || 40;
        console.log('Auto-save scale:', savedScale, 'Current scale:', pixelsPerFoot);

        // Deserialize element and wall positions
        elements.forEach(el => deserializeElement(el, savedScale));
        walls.forEach(w => deserializeWall(w, savedScale));

        // Deserialize room element and wall positions
        rooms.forEach(room => {
          if (room.elements) {
            room.elements.forEach(el => deserializeElement(el, savedScale));
          }
          if (room.walls) {
            room.walls.forEach(w => deserializeWall(w, savedScale));
          }
          room.pixelsPerFoot = pixelsPerFoot; // Update to current scale
        });

        // If rooms were restored, sync global elements with current room
        if (rooms.length > 0) {
          // Find the current room (by saved currentRoomId or first room)
          let activeRoom = rooms.find(r => r.id === currentRoomId);
          if (!activeRoom) {
            activeRoom = rooms[0];
            currentRoomId = activeRoom.id;
          }

          // If the room has elements, use those instead of the global elements
          // (they should be the same, but room.elements is the authoritative source)
          if (activeRoom.elements && activeRoom.elements.length > 0) {
            elements.length = 0;
            activeRoom.elements.forEach(el => elements.push(el));
          } else {
            // Otherwise, save current elements to the room
            activeRoom.elements = [...elements];
          }

          if (activeRoom.walls && activeRoom.walls.length > 0) {
            walls.length = 0;
            activeRoom.walls.forEach(w => walls.push(w));
          } else {
            activeRoom.walls = [...walls];
          }

          // Update room dimensions from active room
          if (activeRoom.width) roomWidth = activeRoom.width;
          if (activeRoom.depth) roomDepth = activeRoom.depth;
        }

        // Update room list UI if available
        if (typeof updateRoomList === 'function') {
          updateRoomList();
        }

        // Update UI components
        updateElementSelector();
        updateItemPicker();
        calculateQuote();

        console.log('Loaded auto-saved design:', elements.length, 'elements from', rooms.length, 'rooms');
        hasUnsavedChanges = false;
        return true;
      } catch (e) {
        console.warn('Failed to load auto-save:', e);
        // Try backup before clearing
        try {
          const backup = localStorage.getItem(AUTOSAVE_KEY + '_backup');
          if (backup) {
            console.log('Attempting to restore from backup auto-save...');
            localStorage.setItem(AUTOSAVE_KEY, backup);
            return loadAutoSavedDesign(); // Retry with backup
          }
        } catch (backupErr) {
          console.warn('Backup restore also failed:', backupErr);
        }
        clearAutoSave();
        return false;
      }
    }

    // Recovery function  accessible from browser console as recoverDesignFromBackup()
    // Checks ALL backup sources: _backup, _protected, room_designs
    window.recoverDesignFromBackup = function() {
      console.log('=== DESIGN RECOVERY ===');
      const sources = [];

      // Check all possible backup sources
      const keys = [AUTOSAVE_KEY + '_protected', AUTOSAVE_KEY + '_backup', AUTOSAVE_KEY + '_backup2', AUTOSAVE_KEY];
      keys.forEach(key => {
        try {
          const raw = localStorage.getItem(key);
          if (raw) {
            const data = JSON.parse(raw);
            if (data.elements && data.elements.length > 0) {
              sources.push({
                key: key,
                elements: data.elements.length,
                rooms: data.rooms?.length || 0,
                timestamp: data.timestamp,
                date: new Date(data.timestamp).toLocaleString(),
                data: raw
              });
            }
          }
        } catch (e) { /* skip corrupted */ }
      });

      // Check local designs
      try {
        const designs = JSON.parse(localStorage.getItem('room_designs') || '[]');
        designs.forEach((d, i) => {
          if (d.elements && d.elements.length > 0) {
            sources.push({
              key: 'room_designs[' + i + ']',
              elements: d.elements.length,
              rooms: d.rooms?.length || 0,
              timestamp: d.timestamp || d.updated_at,
              date: d.timestamp ? new Date(d.timestamp).toLocaleString() : (d.updated_at || 'unknown'),
              name: d.name || d.projectName,
              data: JSON.stringify(d)
            });
          }
        });
      } catch (e) { /* skip */ }

      if (sources.length === 0) {
        console.log('No recoverable designs found in localStorage.');
        console.log('Try checking cloud saves: open the Load Design dialog in the app.');
        return false;
      }

      // Sort by most elements (best candidate)
      sources.sort((a, b) => b.elements - a.elements);

      console.log('Found', sources.length, 'recoverable sources:');
      sources.forEach((s, i) => {
        console.log('  [' + i + ']', s.key, '', s.elements, 'elements,', s.rooms, 'rooms,', s.name || '', 'saved:', s.date);
      });

      // Restore the best candidate
      const best = sources[0];
      console.log('\nRestoring best candidate:', best.key, '(' + best.elements + ' elements)');
      localStorage.setItem(AUTOSAVE_KEY, best.data);
      console.log('Restored! Reload the page (Ctrl+Shift+R) to see your design.');
      return true;
    };

    function clearAutoSave() {
      try {
        // Before clearing, save current auto-save as protected backup (if it has content)
        const current = localStorage.getItem(AUTOSAVE_KEY);
        if (current) {
          try {
            const data = JSON.parse(current);
            if (data.elements && data.elements.length > 0) {
              localStorage.setItem(AUTOSAVE_KEY + '_protected', current);
              console.log('Protected', data.elements.length, 'elements before clearing auto-save');
            }
          } catch (e) { /* corrupted, skip */ }
        }
        localStorage.removeItem(AUTOSAVE_KEY);
        hasUnsavedChanges = false;
        console.log('Auto-save cleared (backups preserved)');
      } catch (e) {
        console.warn('Failed to clear auto-save:', e);
      }
    }

    // Check if there's saved work
    function hasSavedWork() {
      try {
        const saved = localStorage.getItem(AUTOSAVE_KEY);
        if (!saved) return false;
        const data = JSON.parse(saved);
        return data.elements && data.elements.length > 0;
      } catch (e) {
        return false;
      }
    }

    // ===== UNDO/REDO =====
    function saveUndoState() {
      // Clone current state
      const state = {
        elements: JSON.parse(JSON.stringify(elements.map(el => ({
          ...el,
          textureImg: el.textureImg ? el.textureImg.src : null
        })))),
        walls: JSON.parse(JSON.stringify(walls)),
        roomWidth: roomWidth,
        roomDepth: roomDepth
      };

      undoStack.push(state);

      // Limit stack size
      if (undoStack.length > MAX_UNDO_STATES) {
        undoStack.shift();
      }

      // Clear redo stack on new action
      redoStack = [];

      updateUndoButtons();

      // Auto-save to localStorage
      autoSaveDesign();
    }

    function undo() {
      if (undoStack.length <= 1) return; // Keep at least one state

      // Save current to redo
      const currentState = undoStack.pop();
      redoStack.push(currentState);

      // Restore previous state
      const prevState = undoStack[undoStack.length - 1];
      restoreState(prevState);

      updateUndoButtons();
    }

    function redo() {
      if (redoStack.length === 0) return;

      const state = redoStack.pop();
      undoStack.push(state);
      restoreState(state);

      updateUndoButtons();
    }

    function restoreState(state) {
      elements = state.elements.map(el => {
        const restored = { ...el };
        // Reload texture if it had one
        if (el.textureImg) {
          const img = new Image();
          img.crossOrigin = 'anonymous';
          img.onload = () => {
            restored.textureImg = img;
            draw();
          };
          img.src = el.textureImg;
          restored.textureImg = null; // Will be set when loaded
        }
        return restored;
      });
      walls = state.walls;
      roomWidth = state.roomWidth;
      roomDepth = state.roomDepth;

      selectedElement = null;
      updateProperties();
      calculateQuote();
      draw();
    }

    function updateUndoButtons() {
      const undoBtn = document.getElementById('undoBtn');
      const redoBtn = document.getElementById('redoBtn');

      if (undoBtn) {
        undoBtn.disabled = undoStack.length <= 1;
        undoBtn.title = `Undo (${undoStack.length - 1} steps)`;
      }
      if (redoBtn) {
        redoBtn.disabled = redoStack.length === 0;
        redoBtn.title = `Redo (${redoStack.length} steps)`;
      }
    }

    async function resetCanvas() {
      const confirmed = await showConfirmDialog({
        title: 'Reset Entire Project?',
        message: 'This will delete all elements, clear room settings, and erase saved progress.\n\nThis cannot be undone!',
        confirmText: 'Reset Project',
        cancelText: 'Cancel',
        dangerous: true
      });
      if (!confirmed) return;

      // Clear everything
      elements = [];
      elementListDirty = true;
      walls = [];
      selectedElement = null;
      undoStack = [];
      redoStack = [];

      // Reset room settings to defaults
      roomWidth = 12;
      roomDepth = 10;
      roomHeight = 8;
      document.getElementById('roomWidth').value = 12;
      document.getElementById('roomDepth').value = 10;
      document.getElementById('roomHeight').value = 8;

      const projectNameEl = document.getElementById('projectName');
      if (projectNameEl) projectNameEl.value = 'Untitled Project';

      const roomTypeEl = document.getElementById('roomType');
      if (roomTypeEl) roomTypeEl.value = 'kitchen';

      // Clear auto-save so refresh starts fresh
      clearAutoSave();

      updateProperties();
      updateElementSelector();
      updateItemPicker();
      calculateQuote();
      updateCanvasSize();
      draw();
      render3D();

      showToast('Project reset to defaults', 'info');
    }

    function renderSidebar() {
      // Render element grids with SVG icons
      ['cabinets', 'surfaces', 'appliances', 'structure', 'bathroom', 'laundry', 'closet', 'electrical'].forEach(category => {
        const grid = document.getElementById(category + 'Grid');
        if (!grid) return;

        grid.innerHTML = ELEMENT_TYPES[category].map(el => {
          // Get the SVG icon for this element type
          // Try direct lookup first, then try base type for sized variants
          let svgIcon = ELEMENT_ICONS[el.type];
          if (!svgIcon) {
            // For sized variants like base-cabinet-12, try the base type
            const baseType = el.type.replace(/-\d+$/, '');
            if (baseType !== el.type) {
              svgIcon = ELEMENT_ICONS[baseType];
            }
          }

          // Build icon content - prefer SVG, fallback to color
          let iconContent;
          if (elementTextures[el.type]) {
            // Custom uploaded texture
            iconContent = `<div class="element-icon" style="background-image: url(${elementTextures[el.type]}); background-size: cover; background-position: center;"></div>`;
          } else if (svgIcon) {
            // SVG icon from ELEMENT_ICONS
            iconContent = `<div class="element-icon element-svg">${svgIcon}</div>`;
          } else {
            // Color fallback - also log for debugging
            console.warn(`Missing SVG icon for element type: ${el.type}`);
            iconContent = `<div class="element-icon" style="background: ${el.color};"></div>`;
          }

          return `
            <div class="element-item ${elementTextures[el.type] ? 'has-texture' : ''}"
                 draggable="true"
                 data-type="${el.type}"
                 data-category="${category}"
                 title="${el.label}">
              ${iconContent}
              <div class="element-name" title="${el.label}">${el.label}</div>
              <div class="element-upload-btn" onclick="event.stopPropagation(); uploadElementTexture('${el.type}')" title="Upload custom texture">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                  <polyline points="17 8 12 3 7 8"/>
                  <line x1="12" y1="3" x2="12" y2="15"/>
                </svg>
              </div>
            </div>
          `;
        }).join('');
      });
    }

    function renderFloorPlans() {
      const grid = document.getElementById('floorplanGrid');
      grid.innerHTML = FLOOR_PLANS.map(fp => `
        <div class="floorplan-item ${currentFloorPlan === fp.id ? 'active' : ''}"
             onclick="selectFloorPlan('${fp.id}')">
          <div class="floorplan-preview">
            ${getFloorPlanSVG(fp)}
          </div>
          <div class="floorplan-name">${fp.name}</div>
        </div>
      `).join('');
    }

    function getFloorPlanSVG(fp) {
      if (fp.id === 'empty') {
        return `<svg viewBox="0 0 40 30"><rect x="2" y="2" width="36" height="26" fill="none" stroke="#666" stroke-width="1" stroke-dasharray="2"/></svg>`;
      }
      if (fp.id === 'square') {
        return `<svg viewBox="0 0 40 30"><rect x="2" y="2" width="36" height="26" fill="#333" stroke="#666" stroke-width="1"/></svg>`;
      }
      if (fp.id === 'l-shape') {
        return `<svg viewBox="0 0 40 30"><path d="M2 2 H26 V15 H15 V28 H2 Z" fill="#333" stroke="#666" stroke-width="1"/></svg>`;
      }
      if (fp.id === 'u-shape') {
        return `<svg viewBox="0 0 40 30"><path d="M2 2 H12 V20 H28 V2 H38 V28 H2 Z" fill="#333" stroke="#666" stroke-width="1"/></svg>`;
      }
      if (fp.id === 'galley') {
        return `<svg viewBox="0 0 40 30"><rect x="2" y="2" width="8" height="26" fill="#333" stroke="#666"/><rect x="30" y="2" width="8" height="26" fill="#333" stroke="#666"/></svg>`;
      }
      if (fp.id === 'open') {
        return `<svg viewBox="0 0 40 30"><rect x="2" y="2" width="36" height="26" fill="none" stroke="#666" stroke-dasharray="2"/><rect x="2" y="18" width="16" height="10" fill="#333" stroke="#666"/></svg>`;
      }
      return `<svg viewBox="0 0 40 30"><rect x="2" y="2" width="36" height="26" fill="none" stroke="#666"/></svg>`;
    }

    // ===== MATERIALS LIBRARY =====
    let selectedMaterial = null;
    let currentMaterialCategory = 'granite';

    // Current brand filter
    let currentBrandFilter = '';

    let currentPriceFilter = '';
    let currentFinishFilter = '';

    function applyMaterialFilters() {
      currentBrandFilter = document.getElementById('brandFilter')?.value || '';
      currentPriceFilter = document.getElementById('priceFilter')?.value || '';
      currentFinishFilter = document.getElementById('finishFilter')?.value || '';
      renderMaterials(currentMaterialCategory);
    }

    function clearAllMaterialFilters() {
      currentBrandFilter = '';
      currentPriceFilter = '';
      currentFinishFilter = '';
      const bf = document.getElementById('brandFilter');
      const pf = document.getElementById('priceFilter');
      const ff = document.getElementById('finishFilter');
      if (bf) bf.value = '';
      if (pf) pf.value = '';
      if (ff) ff.value = '';
      renderMaterials(currentMaterialCategory);
    }

    // Legacy compat
    function filterMaterialsByBrand(brand) {
      currentBrandFilter = brand;
      renderMaterials(currentMaterialCategory);
    }
    function clearBrandFilter() { clearAllMaterialFilters(); }

    function renderMaterials(category = 'granite') {
      currentMaterialCategory = category;
      const grid = document.getElementById('materialGrid');
      let materials = MATERIALS[category] || [];

      // DEDUPLICATE: Remove duplicates by NAME only (case-insensitive)
      // Same stone/product from different distributors = same product
      // Score picks the best version: image + price + sku
      const seenKeys = new Map();
      for (const m of materials) {
        const key = (m.name || '').toLowerCase().trim();
        if (!key) continue;

        if (seenKeys.has(key)) {
          const existing = seenKeys.get(key);
          // Score: higher is better (image=10, price=5, sku=3, brand=1)
          const existingScore = (hasValidImageUrl(existing.url) ? 10 : 0) +
                               (existing.price ? 5 : 0) +
                               (existing.sku ? 3 : 0) +
                               (existing.brand ? 1 : 0);
          const newScore = (hasValidImageUrl(m.url) ? 10 : 0) +
                          (m.price ? 5 : 0) +
                          (m.sku ? 3 : 0) +
                          (m.brand ? 1 : 0);
          if (newScore > existingScore) {
            // Carry forward data from existing if new is missing it
            if (!m.price && existing.price) m.price = existing.price;
            if (!m.unit && existing.unit) m.unit = existing.unit;
            if (!hasValidImageUrl(m.url) && hasValidImageUrl(existing.url)) m.url = existing.url;
            if (!m.brand && existing.brand) m.brand = existing.brand;
            seenKeys.set(key, m);
          } else {
            // Carry forward data from new entry if existing is missing it
            if (!existing.price && m.price) existing.price = m.price;
            if (!existing.unit && m.unit) existing.unit = m.unit;
            if (!hasValidImageUrl(existing.url) && hasValidImageUrl(m.url)) existing.url = m.url;
            if (!existing.brand && m.brand) existing.brand = m.brand;
          }
        } else {
          seenKeys.set(key, m);
        }
      }
      // Get the deduplicated list
      materials = Array.from(seenKeys.values());

      // Sanitize prices: anything over $200/unit is likely a full-slab or product price, not per-sqft
      for (const m of materials) {
        if (m.price && m.price > 200) {
          m.price = null;
        }
      }

      // Filter: only show materials with images (http URLs or relative paths) or valid colors
      materials = materials.filter(m => {
        const hasImage = hasValidImageUrl(m.url);
        const hasColor = m.color && m.color !== '#888888';
        return hasImage || hasColor;
      });

      // --- Populate filter dropdowns from ALL materials (before filtering) ---
      const allBrands = [...new Set(materials.map(m => m.brand).filter(Boolean))].sort();
      const allFinishes = [...new Set(materials.map(m => m.finish).filter(Boolean))].sort();

      const brandFilterEl = document.getElementById('brandFilter');
      if (brandFilterEl) {
        brandFilterEl.innerHTML = '<option value="">All Vendors (' + materials.length + ')</option>' +
          allBrands.map(b => {
            const count = materials.filter(m => m.brand === b).length;
            return `<option value="${b}" ${currentBrandFilter === b ? 'selected' : ''}>${b} (${count})</option>`;
          }).join('');
      }

      const finishFilterEl = document.getElementById('finishFilter');
      if (finishFilterEl) {
        finishFilterEl.innerHTML = '<option value="">All Finishes</option>' +
          allFinishes.map(f => {
            const count = materials.filter(m => m.finish === f).length;
            return `<option value="${f}" ${currentFinishFilter === f ? 'selected' : ''}>${f} (${count})</option>`;
          }).join('');
      }

      const priceFilterEl = document.getElementById('priceFilter');
      if (priceFilterEl && currentPriceFilter) {
        priceFilterEl.value = currentPriceFilter;
      }

      // --- Apply all active filters ---
      if (currentBrandFilter) {
        materials = materials.filter(m => m.brand === currentBrandFilter);
      }
      if (currentFinishFilter) {
        materials = materials.filter(m => m.finish === currentFinishFilter);
      }
      if (currentPriceFilter) {
        materials = materials.filter(m => {
          const p = m.price || (m.tradePrice) || (m.retailPrice) || null;
          if (currentPriceFilter === 'has') return p != null;
          if (!p) return false;
          const ranges = { '0-5': [0,5], '5-15': [5,15], '15-30': [15,30], '30-50': [30,50], '50-100': [50,100] };
          if (ranges[currentPriceFilter]) {
            const [lo, hi] = ranges[currentPriceFilter];
            return p >= lo && p < hi;
          }
          if (currentPriceFilter === '100+') return p >= 100;
          return true;
        });
      }

      // Sort: priced before priceless, image+real color first, then by name
      materials.sort((a, b) => {
        const aPrice = a.price ? 0 : 1;
        const bPrice = b.price ? 0 : 1;
        if (aPrice !== bPrice) return aPrice - bPrice;
        const aImg = hasValidImageUrl(a.url);
        const bImg = hasValidImageUrl(b.url);
        const aRealColor = a.color && a.color !== '#888888' && a.color !== '#C0C0C0';
        const bRealColor = b.color && b.color !== '#888888' && b.color !== '#C0C0C0';
        // Tier: 0 = has image + real color, 1 = has image only, 2 = color only, 3 = neither
        const aTier = aImg && aRealColor ? 0 : aImg ? 1 : aRealColor ? 2 : 3;
        const bTier = bImg && bRealColor ? 0 : bImg ? 1 : bRealColor ? 2 : 3;
        if (aTier !== bTier) return aTier - bTier;
        return (a.name || '').localeCompare(b.name || '');
      });

      const canShowPrice = PRICING_ACCESS.canViewPricing;

      // Render all materials as a flat alphabetical grid (no brand separators)
      grid.innerHTML = materials.map(mat => {
        // Get account-aware display price (trade vs retail)
        const displayPrice = (typeof getDisplayPrice === 'function') ? getDisplayPrice(mat) : (canShowPrice && mat.price ? { amount: mat.price, label: '' } : null);

        // Build tooltip with details
        let tooltip = mat.name;
        if (mat.brand) tooltip += ` | ${mat.brand}`;
        if (displayPrice) tooltip += ` | $${Number(displayPrice.amount).toFixed(2)}/${mat.unit || 'sf'}${displayPrice.label ? ' (' + displayPrice.label + ')' : ''}`;
        if (mat.sku) tooltip += ` | SKU: ${mat.sku}`;
        if (mat.material) tooltip += ` | ${mat.material}`;
        if (mat.size) tooltip += ` | ${mat.size}`;
        if (mat.finish) tooltip += ` | ${mat.finish}`;
        if (mat.origin) tooltip += ` | ${mat.origin}`;
        if (mat.series) tooltip += ` | ${mat.series}`;
        if (mat.warranty) tooltip += ` | ${mat.warranty}`;
        if (mat.features) tooltip += ` | ${mat.features}`;

        // Brand badge
        const brandBadge = mat.brand
          ? `<div class="material-brand-badge">${mat.brand.replace('MSI ', '').replace('Daltile ', '').substring(0, 10)}</div>`
          : '';

        // Distributor "In Stock" badge for live inventory items
        const distributorBadge = (mat.source === 'distributor' && mat.distributorName)
          ? `<div class="material-distributor-badge">${mat.distributorLogo ? `<img src="${mat.distributorLogo}" alt="">` : ''}${mat.distributorName}</div>`
          : '';

        // Use image URL directly
        const imageUrl = mat.url || '';

        // Determine background style
        let bgStyle = mat.color || '#666';
        let bgImage = imageUrl ? `background-image: url(${imageUrl});` : '';

        // Special handling for cabinets - wood grain pattern
        if (!imageUrl && category === 'cabinets' && mat.color) {
          const baseColor = mat.color;
          const darkColor = adjustColor(baseColor, -15);
          const lightColor = adjustColor(baseColor, 10);
          bgStyle = `repeating-linear-gradient(90deg, transparent 0px, transparent 2px, rgba(0,0,0,0.1) 2px, rgba(0,0,0,0.1) 3px, transparent 3px, transparent 8px), repeating-linear-gradient(90deg, transparent 0px, transparent 12px, rgba(255,255,255,0.06) 12px, rgba(255,255,255,0.06) 14px, transparent 14px, transparent 25px), linear-gradient(180deg, ${lightColor} 0%, ${baseColor} 35%, ${darkColor} 65%, ${baseColor} 100%)`;
        }

        // Add indicator if no texture (color only) - but not for cabinets with wood grain
        const noTextureBadge = !imageUrl && category !== 'cabinets'
          ? '<div class="material-no-texture-badge" title="Color only - no texture image"></div>'
          : '';

        // Use img tag for materials with images
        // On error: hide the broken image. If the fallback color is just default grey, hide the whole swatch.
        const imgTag = imageUrl
          ? `<img src="${imageUrl}" onerror="this.style.display='none'; if(this.parentElement.style.backgroundColor==='rgb(136, 136, 136)')this.parentElement.style.display='none';">`
          : '';

        return `
        <div class="material-swatch ${selectedMaterial?.id === mat.id ? 'selected' : ''}"
             style="background-color: ${mat.color || '#666'};"
             onclick="selectMaterial('${mat.id}')"
             draggable="true"
             ondragstart="dragMaterialSwatch(event, '${mat.id}')"
             data-material-id="${mat.id}"
             data-url="${imageUrl || ''}"
             data-color="${mat.color || '#666'}"
             title="${tooltip}">
          ${imgTag}
          ${noTextureBadge}
          ${distributorBadge}
          <div class="material-swatch-label">${mat.name}${displayPrice ? `<br><span style="font-size:10px;opacity:0.85${displayPrice.label ? ';color:#10b981' : ''}">$${Number(displayPrice.amount).toFixed(2)}/${mat.unit || 'sf'}${displayPrice.label ? ' ' + displayPrice.label : ''}</span>` : (canShowPrice ? '<br><span style="font-size:9px;opacity:0.6;font-style:italic">Call for Price</span>' : '')}</div>
        </div>
      `;
      }).join('');
    }

    function showMaterialCategory(category, btn) {
      // Update tab buttons
      document.querySelectorAll('.material-tab').forEach(t => t.classList.remove('active'));
      btn.classList.add('active');

      // Reset all filters when switching tabs
      currentBrandFilter = '';
      currentPriceFilter = '';
      currentFinishFilter = '';
      const bf = document.getElementById('brandFilter');
      const pf = document.getElementById('priceFilter');
      const ff = document.getElementById('finishFilter');
      if (bf) bf.value = '';
      if (pf) pf.value = '';
      if (ff) ff.value = '';

      // Render materials for category
      renderMaterials(category);

      // Lazy-load distributor data for this category (async, non-blocking)
      if (typeof loadDistributorDataForCategory === 'function') {
        loadDistributorDataForCategory(category);
      }
    }

    // ==========================================
    // Product Catalog from Website/Store
    // ==========================================
    let storeProducts = [];
    let currentProductCategory = 'countertops';
    let selectedStoreProduct = null;

    // Load products from the search index
    async function loadStoreProducts() {
      try {
        // Try to load from the website's search index
        const basePath = window.location.protocol === 'file:'
          ? window.location.href.replace(/\/tools\/room-designer\/.*$/, '')
          : '';
        const response = await fetch(basePath + '/data/search-index.json');
        const data = await response.json();
        storeProducts = data.products || [];

        // Populate brand filter
        const brands = [...new Set(storeProducts.map(p => p.brand).filter(Boolean))];
        const brandSelect = document.getElementById('productBrandFilter');
        if (brandSelect) {
          brandSelect.innerHTML = '<option value="">All Brands</option>' +
            brands.map(b => `<option value="${b}">${formatBrandName(b)}</option>`).join('');
        }

        // Populate type filter
        const types = [...new Set(storeProducts.map(p => p.type).filter(Boolean))];
        const typeSelect = document.getElementById('productTypeFilter');
        if (typeSelect) {
          typeSelect.innerHTML = '<option value="">All Types</option>' +
            types.map(t => `<option value="${t}">${t}</option>`).join('');
        }

        renderStoreProducts();
      } catch (e) {
        console.warn('Could not load store products:', e);
        const grid = document.getElementById('productCatalogGrid');
        if (grid) {
          grid.innerHTML = '<div class="loading-products">Products unavailable offline</div>';
        }
      }
    }

    // Format brand name for display
    function formatBrandName(brand) {
      const brandNames = {
        'msi-surfaces': 'MSI Surfaces',
        'cosentino': 'Cosentino',
        'radianz-quartz': 'Radianz',
        'lx-hausys': 'LX Hausys',
        'cambria': 'Cambria',
        'daltile': 'Daltile',
        'bedrosians': 'Bedrosians'
      };
      return brandNames[brand] || brand.replace(/-/g, ' ').replace(/\b\w/g, c => c.toUpperCase());
    }

    // Show products by category
    function showProductCategory(category, btn) {
      // Update tabs
      document.querySelectorAll('#productCategoryTabs .material-tab').forEach(t => t.classList.remove('active'));
      btn.classList.add('active');
      currentProductCategory = category;
      renderStoreProducts();
    }

    // Filter store products based on search and dropdowns
    function filterStoreProducts() {
      renderStoreProducts();
    }

    // ===== MARKETPLACE (Live API Bridge) =====
    let marketplaceProducts = [];
    let marketplaceCategory = 'all';
    let marketplaceOffset = 0;
    const MARKETPLACE_LIMIT = 20;
    let marketplaceSearchTimer = null;
    let marketplacePriceRefreshTimer = null;

    function debounceMarketplaceSearch() {
      clearTimeout(marketplaceSearchTimer);
      marketplaceSearchTimer = setTimeout(() => loadMarketplaceProducts(false), 400);
    }

    function setMarketplaceCategory(category, btn) {
      document.querySelectorAll('#marketplaceCategoryTabs .material-tab').forEach(t => t.classList.remove('active'));
      btn.classList.add('active');
      marketplaceCategory = category;
      marketplaceOffset = 0;
      loadMarketplaceProducts(false);
    }

    function applyMarketplaceFilters() {
      marketplaceOffset = 0;
      loadMarketplaceProducts(false);
    }

    function loadMoreMarketplace() {
      marketplaceOffset += MARKETPLACE_LIMIT;
      loadMarketplaceProducts(true);
    }

    async function loadMarketplaceProducts(append) {
      const grid = document.getElementById('marketplaceProductGrid');
      const loadMoreBtn = document.getElementById('marketplaceLoadMore');
      if (!grid) return;

      if (!append) {
        grid.innerHTML = '<div class="loading-products">Loading marketplace...</div>';
        marketplaceOffset = 0;
      }

      const search = document.getElementById('marketplaceSearchInput')?.value || '';
      const brand = document.getElementById('marketplaceBrandFilter')?.value || '';
      const priceRange = document.getElementById('marketplacePriceFilter')?.value || '';
      const inStockOnly = document.getElementById('marketplaceInStockOnly')?.checked || false;

      const params = new URLSearchParams();
      params.set('limit', MARKETPLACE_LIMIT);
      params.set('offset', marketplaceOffset);
      if (search) params.set('search', search);
      if (brand) params.set('brand', brand);
      if (marketplaceCategory !== 'all') {
        const categoryMap = {
          'countertops': 'countertop',
          'cabinets': 'cabinet',
          'sinks': 'sink',
          'faucets': 'faucet',
          'tile': 'tile',
          'flooring': 'flooring',
          'vanities': 'vanity'
        };
        params.set('product_type', categoryMap[marketplaceCategory] || marketplaceCategory);
      }
      if (priceRange) {
        const [min, max] = priceRange.split('-');
        if (min) params.set('min_price', min);
        if (max) params.set('max_price', max);
      }

      try {
        const response = await fetch(`${MARKETPLACE_API_BASE}/api/marketplace/products?${params.toString()}`);
        if (!response.ok) throw new Error('API error');
        const data = await response.json();

        if (append) {
          marketplaceProducts = [...marketplaceProducts, ...(data.products || [])];
        } else {
          marketplaceProducts = data.products || [];
        }

        renderMarketplaceGrid(inStockOnly);
        updateMarketplaceBrandFilter();

        // Show/hide Load More
        if (loadMoreBtn) {
          loadMoreBtn.style.display = (data.products?.length >= MARKETPLACE_LIMIT) ? 'block' : 'none';
        }
      } catch (err) {
        console.warn('Marketplace load error:', err);
        if (!append) {
          grid.innerHTML = '<div class="loading-products">Marketplace unavailable</div>';
        }
      }
    }

    function renderMarketplaceGrid(inStockOnly) {
      const grid = document.getElementById('marketplaceProductGrid');
      if (!grid) return;

      let products = marketplaceProducts;
      if (inStockOnly) {
        products = products.filter(p => (p.quantity_available || 0) > 0);
      }

      if (products.length === 0) {
        grid.innerHTML = '<div class="loading-products">No products found</div>';
        return;
      }

      grid.innerHTML = products.map(p => {
        const imgUrl = p.images?.[0] || '';
        const price = p.wholesale_price || p.unit_price || 0;
        const qty = p.quantity_available || 0;
        const isOutOfStock = qty <= 0;
        const isLowStock = qty > 0 && qty <= 5;

        let badgeHtml = '';
        if (isOutOfStock) {
          badgeHtml = '<span class="marketplace-card-badge marketplace-badge-out">Out</span>';
        } else if (isLowStock) {
          badgeHtml = '<span class="marketplace-card-badge marketplace-badge-low">Low</span>';
        } else if (qty > 0) {
          badgeHtml = '<span class="marketplace-card-badge marketplace-badge-instock">In Stock</span>';
        }

        const distributor = p.distributor_profiles?.company_name || '';

        return `<div class="marketplace-card ${isOutOfStock ? 'out-of-stock' : ''}"
                     draggable="true"
                     ondragstart="onMarketplaceDragStart(event, '${p.id}')"
                     onclick="selectMarketplaceProduct('${p.id}')"
                     title="${(p.name || '').replace(/"/g, '&quot;')}">
          ${badgeHtml}
          ${imgUrl ? `<img class="marketplace-card-img" src="${imgUrl}" alt="${(p.name || '').replace(/"/g, '&quot;')}" loading="lazy" onerror="this.style.display='none'">` : '<div class="marketplace-card-img" style="background:var(--dark-elevated);display:flex;align-items:center;justify-content:center;font-size:9px;color:var(--text-muted);">No Image</div>'}
          <div class="marketplace-card-name">${p.name || 'Product'}</div>
          <div class="marketplace-card-brand">${p.brand || ''}</div>
          <div class="marketplace-card-price">${price > 0 ? '$' + parseFloat(price).toFixed(2) : ''}</div>
          ${distributor ? `<div class="marketplace-card-distributor">${distributor}</div>` : ''}
        </div>`;
      }).join('');
    }

    function onMarketplaceDragStart(event, productId) {
      const product = marketplaceProducts.find(p => String(p.id) === String(productId));
      if (!product) return;
      const dragData = {
        type: 'marketplace-product',
        product: {
          id: product.id,
          name: product.name,
          brand: product.brand,
          sku: product.sku,
          price: product.wholesale_price || product.unit_price,
          type: product.product_type,
          images: product.images,
          image: product.images?.[0]
        }
      };
      event.dataTransfer.setData('text/plain', JSON.stringify(dragData));
      event.dataTransfer.effectAllowed = 'copy';
    }

    function selectMarketplaceProduct(productId) {
      const product = marketplaceProducts.find(p => String(p.id) === String(productId));
      if (!product) return;

      if (selectedElement) {
        // Apply as material to selected element
        applyStoreProductToElement(selectedElement, {
          name: product.name,
          brand: product.brand,
          sku: product.sku,
          price: product.wholesale_price || product.unit_price,
          primaryImage: product.images?.[0],
          slug: product.id
        });
        showToast(`Applied ${product.name} to ${selectedElement.type}`, 'success');
      } else {
        showToast('Select an element first, then click a product to apply it', 'info');
      }
    }

    function updateMarketplaceBrandFilter() {
      const select = document.getElementById('marketplaceBrandFilter');
      if (!select) return;
      const currentVal = select.value;
      const brands = [...new Set(marketplaceProducts.map(p => p.brand).filter(Boolean))].sort();
      select.innerHTML = '<option value="">All Brands</option>' +
        brands.map(b => `<option value="${b}" ${b === currentVal ? 'selected' : ''}>${b}</option>`).join('');
    }

    async function refreshMarketplacePrices() {
      const marketplaceElements = elements.filter(el => el.storeProduct?.slug || el.vendorProduct);
      if (marketplaceElements.length === 0) return;

      try {
        const ids = marketplaceElements.map(el => el.storeProduct?.slug || el.vendorProduct?.id).filter(Boolean);
        const response = await fetch(`${MARKETPLACE_API_BASE}/api/marketplace/products?limit=50&search=`);
        if (!response.ok) return;
        const data = await response.json();
        const priceMap = {};
        (data.products || []).forEach(p => { priceMap[p.id] = p.wholesale_price || p.unit_price; });

        let updated = false;
        marketplaceElements.forEach(el => {
          const key = el.storeProduct?.slug || el.vendorProduct?.id;
          if (key && priceMap[key] !== undefined) {
            el.priceOverride = parseFloat(priceMap[key]);
            el.costPrice = parseFloat(priceMap[key]);
            updated = true;
          }
        });

        if (updated) {
          calculateQuote();
          showToast('Marketplace prices refreshed', 'info');
        }
      } catch (err) {
        console.warn('Price refresh failed:', err);
      }
    }

    // Initialize marketplace on load
    document.addEventListener('DOMContentLoaded', () => {
      setTimeout(() => loadMarketplaceProducts(false), 1000);
      // Refresh prices every 5 minutes
      marketplacePriceRefreshTimer = setInterval(refreshMarketplacePrices, 5 * 60 * 1000);
    });

    // ===== VENDOR DESIGNER ELEMENTS =====
    async function loadVendorDesignerElements() {
      try {
        const response = await fetch(`${MARKETPLACE_API_BASE}/api/marketplace/designer-products?limit=200`);
        if (!response.ok) return;
        const data = await response.json();

        if (!data.grouped || Object.keys(data.grouped).length === 0) return;

        // Merge vendor products into ELEMENT_TYPES
        Object.entries(data.grouped).forEach(([category, products]) => {
          const targetCategory = ELEMENT_TYPES[category];
          if (!targetCategory) return;

          products.forEach(p => {
            // Skip if element type already exists from vendor
            if (targetCategory.find(e => e.type === `vendor-${p.id}`)) return;

            targetCategory.push({
              type: p.elementType || 'base-cabinet',
              width: parseFloat(p.defaultWidth) || 3,
              height: parseFloat(p.defaultHeight) || 2,
              color: p.color || '#8B4513',
              label: p.name || 'Vendor Product',
              vendorProduct: {
                id: p.id,
                name: p.name,
                brand: p.brand,
                sku: p.sku,
                unit_price: p.price,
                image: p.images?.[0],
                distributor: p.distributor
              }
            });
          });
        });

        // Re-render sidebar to show new elements
        if (typeof renderSidebar === 'function') {
          renderSidebar();
        }
        console.log('Vendor designer elements loaded:', Object.keys(data.grouped).length, 'categories');
      } catch (err) {
        console.warn('Vendor designer elements unavailable:', err.message);
      }
    }

    // Load vendor elements 2s after init
    document.addEventListener('DOMContentLoaded', () => {
      setTimeout(loadVendorDesignerElements, 2000);
    });
    // ===== END VENDOR DESIGNER ELEMENTS =====

    // ===== END MARKETPLACE =====

    // Render products in the grid
    function renderStoreProducts() {
      const grid = document.getElementById('productCatalogGrid');
      if (!grid) return;

      const searchTerm = (document.getElementById('productSearchInput')?.value || '').toLowerCase();
      const brandFilter = document.getElementById('productBrandFilter')?.value || '';
      const typeFilter = document.getElementById('productTypeFilter')?.value || '';

      // Filter products
      let filtered = storeProducts.filter(p => {
        // Category filter
        if (currentProductCategory === 'countertops' && p.category !== 'countertops') return false;
        if (currentProductCategory === 'tile' && p.category !== 'tile' && !p.type?.toLowerCase().includes('tile')) return false;
        if (currentProductCategory === 'flooring' && p.category !== 'flooring') return false;
        if (currentProductCategory === 'sinks' && p.category !== 'sinks' && !p.type?.toLowerCase().includes('sink')) return false;
        if (currentProductCategory === 'faucets' && p.category !== 'faucets' && !p.type?.toLowerCase().includes('faucet')) return false;

        // Search filter
        if (searchTerm && !p.name.toLowerCase().includes(searchTerm) &&
            !p.brand?.toLowerCase().includes(searchTerm) &&
            !p.type?.toLowerCase().includes(searchTerm)) return false;

        // Brand filter
        if (brandFilter && p.brand !== brandFilter) return false;

        // Type filter
        if (typeFilter && p.type !== typeFilter) return false;

        return true;
      });

      // Limit to 50 for performance
      filtered = filtered.slice(0, 50);

      if (filtered.length === 0) {
        grid.innerHTML = '<div class="loading-products">No products found</div>';
        return;
      }

      grid.innerHTML = filtered.map(product => `
        <div class="product-card ${selectedStoreProduct?.slug === product.slug ? 'selected' : ''}"
             onclick="selectStoreProduct('${product.slug}')"
             draggable="true"
             ondragstart="dragStoreProduct(event, '${product.slug}')">
          <img class="product-card-image" src="${product.primaryImage}" alt="${product.name}" loading="lazy"
               onerror="this.src='data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><rect fill=%22%23333%22 width=%22100%22 height=%22100%22/><text x=%2250%22 y=%2255%22 text-anchor=%22middle%22 fill=%22%23666%22 font-size=%2210%22>${encodeURIComponent(product.name.substring(0, 8))}</text></svg>'">
          <div class="product-card-name">${product.name}</div>
          <div class="product-card-meta">${product.type || ''} ${product.brand ? ' ' + formatBrandName(product.brand) : ''}</div>
        </div>
      `).join('');
    }

    // Select a store product
    function selectStoreProduct(slug) {
      const product = storeProducts.find(p => p.slug === slug);
      if (!product) return;

      selectedStoreProduct = product;
      renderStoreProducts();

      // Update hint
      const hint = document.querySelector('.product-hint');
      if (hint) {
        hint.innerHTML = `<strong>${product.name}</strong> selected. Click an element to apply.`;
        hint.style.color = 'var(--gold)';
      }
    }

    // Drag store product
    function dragStoreProduct(event, slug) {
      const product = storeProducts.find(p => p.slug === slug);
      if (product) {
        event.dataTransfer.effectAllowed = 'copy';
        event.dataTransfer.setData('text/plain', JSON.stringify({
          type: 'store-product',
          product: product
        }));
        console.log('Dragging store product:', product.name);
      }
    }

    // Apply store product as material to element
    function applyStoreProductToElement(element) {
      if (!selectedStoreProduct) return false;

      const product = selectedStoreProduct;
      console.log('Applying store product to element:', product.name, 'Element type:', element.type);

      // Check material type compatibility using product type
      const productType = product.type?.toLowerCase() || '';
      if (!canApplyMaterialToElement(productType, element)) {
        return false;
      }

      // Store complete product info on element for 3D rendering
      element.storeProduct = {
        name: product.name,
        slug: product.slug,
        brand: product.brand,
        image: product.primaryImage,
        type: product.type
      };

      // Apply product as material
      element.materialId = product.slug;
      element.materialName = product.name;
      element.materialBrand = product.brand;
      element.materialCategory = product.type?.toLowerCase() || product.category || null;
      element.texture = product.primaryImage;
      element.label = product.name; // Update label to product name

      // Extract color from product primaryColor if available (for fallback)
      const colorMap = {
        'White': '#f5f5f5',
        'Black': '#2a2a2a',
        'Gray': '#808080',
        'Beige': '#d4c4a8',
        'Brown': '#8b7355',
        'Gold': '#d4a574',
        'Blue': '#4a6b8c',
        'Green': '#4a6b4a'
      };
      element.color = colorMap[product.primaryColor] || '#a0a0a0';

      // Update quote/pricing
      if (product.price) {
        element.priceOverride = parseFloat(product.price) || 0;
      }

      // Load texture for 2D canvas
      if (product.primaryImage) {
        const img = new Image();
        img.crossOrigin = 'anonymous';
        img.onload = () => {
          element.textureImg = img;
          console.log('Texture image loaded for 2D:', product.primaryImage);
          draw();
          // Force 3D scene rebuild to show new texture
          if (currentView === '3d') {
            console.log('Rebuilding 3D scene with new texture');
            init3D();
            render3D();
          }
        };
        img.onerror = () => {
          console.warn('Failed to load product image:', product.primaryImage);
          draw();
        };
        img.src = product.primaryImage;
      } else {
        // No image, still update views
        draw();
        if (currentView === '3d') {
          init3D();
          render3D();
        }
      }

      // Clear selection
      const prevProduct = selectedStoreProduct.name;
      selectedStoreProduct = null;
      renderStoreProducts();

      const hint = document.querySelector('.product-hint');
      if (hint) {
        hint.innerHTML = `Applied <strong>${prevProduct}</strong>!`;
        hint.style.color = 'var(--success)';
        setTimeout(() => {
          hint.innerHTML = 'Click product to apply as material';
          hint.style.color = '';
        }, 2000);
      }

      showSnapFeedback(`Applied ${prevProduct} to ${element.type}`);
      calculateQuote(); // Update pricing
      return true;
    }

    // Initialize product catalog on load
    document.addEventListener('DOMContentLoaded', () => {
      setTimeout(loadStoreProducts, 500);
    });

    function applyFinishToElement(finishId) {
      if (!selectedElement) return;
      selectedElement.finish = finishId;
      markElement3DDirty(selectedElement.id);
      saveUndoState();
      draw();
      update3DScene();
      updateProperties();
    }

    // Drag-and-drop material swatch onto canvas
    function dragMaterialSwatch(event, materialId) {
      event.dataTransfer.setData('material-id', materialId);
      event.dataTransfer.effectAllowed = 'copy';
      // Also select it so the hint updates
      selectMaterial(materialId);
    }

    function selectMaterial(materialId) {
      // Find material in all categories
      for (const [cat, materials] of Object.entries(MATERIALS)) {
        const mat = materials.find(m => m.id === materialId);
        if (mat) {
          selectedMaterial = { ...mat, category: cat };
          break;
        }
      }

      // Update UI
      renderMaterials(currentMaterialCategory);

      // Update hint
      const hint = document.querySelector('.material-hint');
      if (hint && selectedMaterial) {
        const inquireLink = selectedMaterial.productUUID
          ? ` <a href="#" onclick="event.preventDefault(); showProductInquiryModal('${selectedMaterial.id}')" style="color: var(--gold); text-decoration: underline; margin-left: 8px; font-size: 12px;">Inquire</a>`
          : '';
        hint.innerHTML = `<strong>${selectedMaterial.name}</strong> selected. Click an element to apply.${inquireLink}`;
        hint.style.borderColor = 'var(--gold)';
      }
    }

    function applyMaterialToElement(element) {
      if (!selectedMaterial) return false;

      // Use global helper to check material type compatibility
      if (!canApplyMaterialToElement(selectedMaterial.category, element)) {
        return false;
      }

      // Apply the material
      element.color = selectedMaterial.color;
      element.materialId = selectedMaterial.id;
      element.materialName = selectedMaterial.name;
      const matDisplayPrice = (typeof getDisplayPrice === 'function') ? getDisplayPrice(selectedMaterial) : null;
      element.materialPrice = matDisplayPrice ? matDisplayPrice.amount : (selectedMaterial.price || null);
      element.materialBrand = selectedMaterial.brand || null;
      element.materialCategory = selectedMaterial.category || null;

      // Mark element as needing 3D update
      markElement3DDirty(element.id);

      // Recalculate quote with new material pricing
      calculateQuote();

      // Resolve texture URL using helper
      const textureUrl = resolveAssetUrl(selectedMaterial.url);

      // Store resolved texture URL
      element.texture = textureUrl || null;

      // Load texture image if URL exists (using centralized CORS handling)
      if (textureUrl) {
        let loadTimeout;
        const img = loadImageWithCors(
          textureUrl,
          () => {
            clearTimeout(loadTimeout);
            console.log('Texture loaded successfully:', textureUrl);
            element.textureImg = img;
            draw();
            update3DScene();
          },
          (err) => {
            clearTimeout(loadTimeout);
            // Clear texture reference on error
            element.texture = null;
            element.textureImg = null;
            // Fallback: use solid color
            draw();
            showToast(`Could not load texture image, using solid color`, 'error');
          }
        );
        // Set a timeout to handle hung requests
        loadTimeout = setTimeout(() => {
          if (!img.complete) {
            console.warn('Texture load timeout:', textureUrl);
            element.texture = null;
            element.textureImg = null;
            draw();
          }
        }, 10000);
      } else {
        // No texture URL - material only has color (this is normal for some materials)
        element.textureImg = null;
        element.texture = null;
        console.log('Material has no texture URL, using color:', element.color);
      }

      // Clear selection after applying
      const prevMaterial = selectedMaterial.name;
      selectedMaterial = null;
      materialHoverElement = null;
      materialDropHighlight = null;
      renderMaterials(currentMaterialCategory);

      // Reset hint
      const hint = document.querySelector('.material-hint');
      if (hint) {
        hint.innerHTML = `Applied <strong>${prevMaterial}</strong>! Click material, then element to apply.`;
        hint.style.borderColor = 'var(--success)';
        setTimeout(() => {
          hint.innerHTML = 'Click material, then click element to apply';
          hint.style.borderColor = 'var(--border)';
        }, 2000);
      }

      return true;
    }

    // ===== CABINET CATALOG =====
    function renderCabinetCatalog() {
      const catalog = CABINET_CATALOGS[currentCatalog];
      if (!catalog) return;

      const list = document.getElementById('cabinetCatalogList');
      const cabinets = catalog.cabinets[currentCabinetCategory] || [];
      const series = catalog.series[currentCabinetSeries] || { color: '#8B4513' };

      if (cabinets.length === 0) {
        list.innerHTML = '<div style="padding: 20px; text-align: center; color: var(--text-muted); font-size: 11px;">No cabinets in this category</div>';
        return;
      }

      const canShowPrice = PRICING_ACCESS.canViewPricing;
      list.innerHTML = cabinets.map(cab => `
        <div class="cabinet-catalog-item"
             draggable="true"
             ondragstart="dragCatalogCabinet(event, '${cab.sku}')"
             onclick="addCatalogCabinet('${cab.sku}')">
          <div class="cabinet-item-info">
            <span class="cabinet-item-sku">${cab.sku}</span>
            <span class="cabinet-item-name">${cab.name}</span>
            <span class="cabinet-item-size">${cab.width}'  ${cab.height}'</span>
            ${canShowPrice && cab.price ? `<span class="cabinet-item-price">$${cab.price}</span>` : ''}
          </div>
          <button class="cabinet-item-add" onclick="event.stopPropagation(); addCatalogCabinet('${cab.sku}')" title="Add to canvas">+</button>
        </div>
      `).join('');
    }

    function changeCatalog(catalogId) {
      currentCatalog = catalogId;
      const catalog = CABINET_CATALOGS[catalogId];

      // Update series dropdown
      const seriesSelect = document.getElementById('seriesSelect');
      const seriesDiv = document.getElementById('catalogSeries');

      if (catalog && Object.keys(catalog.series).length > 0) {
        seriesDiv.style.display = 'block';

        // Group series by finish type for better organization
        const paintedFinishes = [];
        const woodGrainFinishes = [];
        const otherFinishes = [];

        Object.entries(catalog.series).forEach(([id, s]) => {
          const finish = s.finish || 'wood-grain';
          if (finish === 'painted' || finish === 'matte' || finish === 'gloss') {
            paintedFinishes.push([id, s]);
          } else if (finish === 'wood-grain') {
            woodGrainFinishes.push([id, s]);
          } else {
            otherFinishes.push([id, s]);
          }
        });

        let optionsHtml = '';

        // Add painted finishes group
        if (paintedFinishes.length > 0) {
          optionsHtml += '<optgroup label="Painted / Solid Colors">';
          paintedFinishes.forEach(([id, s]) => {
            optionsHtml += `<option value="${id}" style="background: linear-gradient(90deg, ${s.color} 20px, transparent 20px);">${s.name}</option>`;
          });
          optionsHtml += '</optgroup>';
        }

        // Add wood grain finishes group
        if (woodGrainFinishes.length > 0) {
          optionsHtml += '<optgroup label="Wood Grain Finishes">';
          woodGrainFinishes.forEach(([id, s]) => {
            optionsHtml += `<option value="${id}" style="background: linear-gradient(90deg, ${s.color} 20px, transparent 20px);">${s.name}</option>`;
          });
          optionsHtml += '</optgroup>';
        }

        // Add other finishes
        if (otherFinishes.length > 0) {
          otherFinishes.forEach(([id, s]) => {
            optionsHtml += `<option value="${id}">${s.name}</option>`;
          });
        }

        seriesSelect.innerHTML = optionsHtml;
        currentCabinetSeries = Object.keys(catalog.series)[0];

        // Update finish dropdown to match
        const series = catalog.series[currentCabinetSeries];
        if (series?.finish) {
          const finishSelect = document.getElementById('cabinetFinish');
          if (finishSelect) {
            finishSelect.value = series.finish;
            cabinetSettings.cabinetFinish = series.finish;
          }
        }
      } else {
        seriesDiv.style.display = catalogId === 'custom' ? 'none' : 'block';
      }

      renderCabinetCatalog();
    }

    function changeSeries(seriesId) {
      currentCabinetSeries = seriesId;

      // Update the finish dropdown to match the series finish type
      const catalog = CABINET_CATALOGS[currentCatalog];
      const series = catalog?.series[seriesId];
      if (series?.finish) {
        const finishSelect = document.getElementById('cabinetFinish');
        if (finishSelect) {
          finishSelect.value = series.finish;
          cabinetSettings.cabinetFinish = series.finish;
        }
      }
      // Also update grain type from series
      if (series?.grainType) {
        cabinetSettings.grainType = series.grainType;
      } else if (series?.finish === 'painted' || series?.finish === 'matte' || series?.finish === 'gloss') {
        // Default to flat for painted finishes
        cabinetSettings.grainType = 'flat';
      } else {
        // Default to oak for wood grain finishes
        cabinetSettings.grainType = 'oak';
      }

      renderCabinetCatalog();
    }

    function showCabinetCategory(category, btn) {
      currentCabinetCategory = category;
      document.querySelectorAll('#cabinetCategoryTabs .material-tab').forEach(t => t.classList.remove('active'));
      btn.classList.add('active');
      renderCabinetCatalog();
    }

    function getCatalogCabinet(sku) {
      const catalog = CABINET_CATALOGS[currentCatalog];
      if (!catalog) return null;

      for (const category of Object.values(catalog.cabinets)) {
        const cab = category.find(c => c.sku === sku);
        if (cab) return cab;
      }
      return null;
    }

    function addCatalogCabinet(sku) {
      const cab = getCatalogCabinet(sku);
      if (!cab) return;

      const catalog = CABINET_CATALOGS[currentCatalog];
      const series = catalog.series[currentCabinetSeries] || { color: '#8B4513', name: 'Default', finish: 'wood-grain', grainType: 'oak' };

      // Calculate position (center of visible area)
      const centerX = (canvas.width / 2 - panX) / pixelsPerFoot;
      const centerY = (canvas.height / 2 - panY) / pixelsPerFoot;

      // Use series finish type if defined, otherwise use cabinetSettings
      const finishType = series.finish || cabinetSettings.cabinetFinish || 'wood-grain';
      // Use series grain type if defined, otherwise use cabinetSettings (flat for painted finishes)
      const grainType = series.grainType || (finishType === 'painted' || finishType === 'matte' || finishType === 'gloss' ? 'flat' : cabinetSettings.grainType || 'oak');

      const element = {
        id: Date.now() + Math.random(),
        type: cab.type,
        x: centerX * pixelsPerFoot,
        y: centerY * pixelsPerFoot,
        width: cab.width,
        height: cab.height,
        rotation: 0,
        color: series.color,
        label: `${cab.name} (${series.name})`,
        sku: cab.sku,
        catalog: currentCatalog,
        series: currentCabinetSeries,
        roomId: currentRoom,
        // Store original SKU dimensions for linear fill calculation
        skuWidth: cab.width,  // Original box width (e.g., 3 for 36" cabinet)
        skuHeight: cab.height, // Original box depth
        skuName: cab.name,
        // Cabinet settings - use series finish type for wood grain colors
        construction: cabinetSettings.construction,
        doorStyle: cabinetSettings.doorStyle,
        doorOverlay: cabinetSettings.doorOverlay,
        cabinetFinish: finishType,
        grainType: grainType,
        floorLevel: cabinetSettings.currentFloor
      };

      elements.push(element);
      elementListDirty = true;
      selectedElement = element;
      updateProperties();
      calculateQuote();
      saveUndoState();
      draw();
    }

    function dragCatalogCabinet(e, sku) {
      e.dataTransfer.setData('catalog-cabinet', sku);
      e.dataTransfer.effectAllowed = 'copy';
    }

    function importCabinetList() {
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = '.csv,.json,.txt';
      input.onchange = async (e) => {
        const file = e.target.files[0];
        if (!file) return;

        const text = await file.text();
        let cabinets = [];

        try {
          if (file.name.endsWith('.json')) {
            // JSON format: array of cabinet objects
            cabinets = JSON.parse(text);
          } else {
            // CSV format: sku,name,width,height,type
            const lines = text.split('\n').filter(l => l.trim());
            const hasHeader = lines[0].toLowerCase().includes('sku') || lines[0].toLowerCase().includes('name');

            (hasHeader ? lines.slice(1) : lines).forEach(line => {
              const parts = line.split(',').map(p => p.trim().replace(/"/g, ''));
              if (parts.length >= 4) {
                cabinets.push({
                  sku: parts[0] || `CUSTOM-${Date.now()}`,
                  name: parts[1] || 'Custom Cabinet',
                  width: parseFloat(parts[2]) || 2,
                  height: parseFloat(parts[3]) || 2,
                  depth: parseFloat(parts[4]) || 2,
                  type: parts[5] || 'base-cabinet'
                });
              }
            });
          }

          if (cabinets.length > 0) {
            CABINET_CATALOGS.custom.cabinets.imported = cabinets;
            currentCatalog = 'custom';
            currentCabinetCategory = 'imported';
            document.getElementById('catalogSelect').value = 'custom';

            // Add imported tab if not exists
            const tabs = document.getElementById('cabinetCategoryTabs');
            if (!tabs.innerHTML.includes('imported')) {
              tabs.innerHTML += '<button class="material-tab" onclick="showCabinetCategory(\'imported\', this)">Imported</button>';
            }

            renderCabinetCatalog();
            showToast(`Imported ${cabinets.length} cabinets successfully!`, 'success');
          } else {
            showToast('No valid cabinet data found in file', 'error');
          }
        } catch (err) {
          console.error('Import error:', err);
          showToast('Error importing file. Check CSV format.', 'error');
        }
      };
      input.click();
    }

    function selectFloorPlan(id) {
      currentFloorPlan = id;
      const plan = FLOOR_PLANS.find(p => p.id === id);

      // Clear existing walls
      walls = [];

      const rW = roomWidth * pixelsPerFoot;
      const rD = roomDepth * pixelsPerFoot;
      const wallT = CONFIG.WALL_THICKNESS;

      // Create walls based on floor plan type
      if (id === 'empty') {
        // No walls for empty room
      } else if (id === 'square') {
        // Standard rectangular room - 4 perimeter walls
        addWall(0, 0, rW, wallT);                    // Top wall
        addWall(0, 0, wallT, rD);                    // Left wall
        addWall(0, rD - wallT, rW, wallT);           // Bottom wall
        addWall(rW - wallT, 0, wallT, rD);           // Right wall
      } else if (id === 'l-shape') {
        // L-shaped room - perimeter + inner corner walls
        // L opens at bottom-right corner (60% width, 50% height cutout)
        const cutW = rW * 0.4;  // Right side cutout width
        const cutH = rD * 0.5;  // Bottom cutout height

        // Outer perimeter
        addWall(0, 0, rW, wallT);                    // Top wall (full width)
        addWall(0, 0, wallT, rD);                    // Left wall (full height)
        addWall(0, rD - wallT, rW - cutW, wallT);   // Bottom wall (partial - up to cutout)
        addWall(rW - wallT, 0, wallT, rD - cutH);    // Right wall (partial - up to cutout)

        // Inner L corner walls
        addWall(rW - cutW - wallT, rD - cutH, wallT, cutH);  // Vertical inner wall
        addWall(rW - cutW, rD - cutH - wallT, cutW, wallT);  // Horizontal inner wall
      } else if (id === 'u-shape') {
        // U-shaped room - open at bottom center
        const sideW = rW * 0.3;   // Side sections width (30% each)
        const openH = rD * 0.3;   // Bottom open section height

        // Outer perimeter
        addWall(0, 0, rW, wallT);                    // Top wall (full)
        addWall(0, 0, wallT, rD);                    // Left wall (full)
        addWall(rW - wallT, 0, wallT, rD);           // Right wall (full)

        // Bottom walls (left and right sections)
        addWall(0, rD - wallT, sideW, wallT);        // Bottom left wall
        addWall(rW - sideW, rD - wallT, sideW, wallT); // Bottom right wall

        // Inner U walls (vertical portions going up from bottom sections)
        addWall(sideW - wallT, rD - openH, wallT, openH);      // Left inner vertical
        addWall(rW - sideW, rD - openH, wallT, openH);         // Right inner vertical
        addWall(sideW, rD - openH - wallT, rW - sideW * 2, wallT); // Inner horizontal (connecting)
      } else if (id === 'galley') {
        // Galley kitchen - parallel walls on left and right sides
        const sideW = rW * 0.2;   // Side wall sections width

        // All 4 outer perimeter walls
        addWall(0, 0, rW, wallT);                    // Top wall
        addWall(0, 0, wallT, rD);                    // Left outer wall
        addWall(0, rD - wallT, rW, wallT);           // Bottom wall
        addWall(rW - wallT, 0, wallT, rD);           // Right outer wall

        // Inner galley walls (create the corridor)
        addWall(sideW - wallT, 0, wallT, rD);        // Left inner wall
        addWall(rW - sideW, 0, wallT, rD);           // Right inner wall
      } else if (id === 'open') {
        // Open plan - only partial walls at bottom-left corner
        const areaW = rW * 0.4;
        const areaH = rD * 0.3;

        // Just the outer perimeter
        addWall(0, 0, rW, wallT);                    // Top wall
        addWall(0, 0, wallT, rD);                    // Left wall
        addWall(0, rD - wallT, rW, wallT);           // Bottom wall
        addWall(rW - wallT, 0, wallT, rD);           // Right wall

        // Peninsula or partial wall in bottom-left area
        addWall(0, rD - areaH, areaW, wallT);        // Partial horizontal wall
      }

      renderFloorPlans();
      draw();
    }

    function addWall(x, y, width, height) {
      walls.push({
        id: Date.now() + Math.random(),
        x, y, width, height,
        type: 'wall',
        color: '#444'
      });
    }

    function fitToScreen() {
      const wrapper = document.getElementById('canvasWrapper');
      const padding = 80;
      const availableWidth = wrapper.clientWidth - padding;
      const availableHeight = wrapper.clientHeight - padding;

      const scaleX = availableWidth / roomWidth;
      const scaleY = availableHeight / roomDepth;

      // Use configured limits for zoom range
      pixelsPerFoot = Math.min(scaleX, scaleY, CONFIG.MAX_PIXELS_PER_FOOT || 200);
      pixelsPerFoot = Math.max(pixelsPerFoot, CONFIG.MIN_PIXELS_PER_FOOT);

      // Center the room in the canvas
      panX = (wrapper.clientWidth - roomWidth * pixelsPerFoot) / 2;
      panY = (wrapper.clientHeight - roomDepth * pixelsPerFoot) / 2;

      document.getElementById('scaleMode').value = 'fit';
      updateCanvasSize();
    }

    function updateScale() {
      const mode = document.getElementById('scaleMode').value;
      if (mode === 'fit') {
        fitToScreen();
      } else {
        pixelsPerFoot = parseInt(mode);
        // Re-center when changing scale
        const wrapper = document.getElementById('canvasWrapper');
        panX = (wrapper.clientWidth - roomWidth * pixelsPerFoot) / 2;
        panY = (wrapper.clientHeight - roomDepth * pixelsPerFoot) / 2;
        updateCanvasSize();
      }
    }

    function updateCanvasSize() {
      const wrapper = document.getElementById('canvasWrapper');

      // Guard against missing elements (e.g., after share link error overlay)
      if (!wrapper || !canvas) return;

      // Canvas fills entire workspace
      canvas.width = wrapper.clientWidth;
      canvas.height = wrapper.clientHeight;

      const sizeEl = document.getElementById('canvasSize');
      if (sizeEl) {
        sizeEl.textContent = `${roomWidth}'  ${roomDepth}'`;
      }

      draw();
    }

    function setupEventListeners() {
      // Mouse events
      canvas.addEventListener('mousedown', onMouseDown);
      canvas.addEventListener('mousemove', onMouseMove);
      canvas.addEventListener('mouseup', onMouseUp);
      canvas.addEventListener('mouseleave', onMouseUp);
      canvas.addEventListener('contextmenu', onContextMenu);
      canvas.addEventListener('dblclick', onDoubleClick);
      canvas.addEventListener('wheel', onWheel, { passive: false });

      // Touch events for mobile/tablet support
      canvas.addEventListener('touchstart', onTouchStart, { passive: false });
      canvas.addEventListener('touchmove', onTouchMove, { passive: false });
      canvas.addEventListener('touchend', onTouchEnd, { passive: false });
      canvas.addEventListener('touchcancel', onTouchEnd, { passive: false });

      document.addEventListener('keydown', onKeyDown);
      document.addEventListener('keyup', onKeyUp);

      document.addEventListener('click', (e) => {
        if (!e.target.closest('.context-menu')) {
          hideContextMenu();
        }
      });

      window.addEventListener('resize', () => {
        updateCanvasSize();
        const scaleMode = document.getElementById('scaleMode');
        if (scaleMode && scaleMode.value === 'fit') {
          fitToScreen();
        }
      });
    }

    // ===== TOUCH EVENT HANDLERS =====
    let lastTouchTime = 0;
    let touchStartPos = null;
    let pinchStartDistance = null;
    let pinchStartZoom = null;
    let longPressTimeout = null;
    let isLongPress = false;
    let twoFingerPanStart = null;

    function getTouchPos(touch) {
      const rect = canvas.getBoundingClientRect();
      return {
        clientX: touch.clientX,
        clientY: touch.clientY,
        offsetX: touch.clientX - rect.left,
        offsetY: touch.clientY - rect.top
      };
    }

    function getTwoFingerCenter(touches) {
      return {
        x: (touches[0].clientX + touches[1].clientX) / 2,
        y: (touches[0].clientY + touches[1].clientY) / 2
      };
    }

    function onTouchStart(e) {
      e.preventDefault();
      cancelLongPress();

      if (e.touches.length === 2) {
        // Two finger gesture - could be pinch zoom or pan
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        pinchStartDistance = Math.sqrt(dx * dx + dy * dy);
        pinchStartZoom = pixelsPerFoot;
        twoFingerPanStart = {
          center: getTwoFingerCenter(e.touches),
          panX: panX,
          panY: panY
        };
        return;
      }

      if (e.touches.length === 1) {
        const touch = e.touches[0];
        const touchPos = getTouchPos(touch);
        touchStartPos = { x: touchPos.offsetX, y: touchPos.offsetY, time: Date.now() };

        // Detect double-tap
        const now = Date.now();
        if (now - lastTouchTime < 300) {
          // Double tap - zoom in at touch point
          const worldX = (touchPos.offsetX - panX) / pixelsPerFoot;
          const worldY = (touchPos.offsetY - panY) / pixelsPerFoot;
          const newZoom = Math.min(CONFIG.MAX_PIXELS_PER_FOOT, pixelsPerFoot * 1.5);
          pixelsPerFoot = newZoom;
          panX = touchPos.offsetX - worldX * pixelsPerFoot;
          panY = touchPos.offsetY - worldY * pixelsPerFoot;
          updateZoomDisplay();
          draw();
          lastTouchTime = 0;
          return;
        }
        lastTouchTime = now;

        // Start long-press timer for context menu
        longPressTimeout = setTimeout(() => {
          isLongPress = true;
          // Find element at touch position
          const { x, y } = screenToWorld(touchPos.offsetX, touchPos.offsetY);
          const touchedElement = [...elements].reverse().find(el => isPointInElement(x, y, el));
          if (touchedElement) {
            selectedElement = touchedElement;
            updateProperties();
            draw();
            // Show context menu at touch position
            showContextMenu(touchPos.clientX, touchPos.clientY, touchedElement);
            // Vibrate for haptic feedback if supported
            if (navigator.vibrate) navigator.vibrate(50);
          }
        }, 500);

        // Simulate mousedown
        onMouseDown({
          ...touchPos,
          button: 0,
          preventDefault: () => {},
          stopPropagation: () => {}
        });
      }
    }

    function onTouchMove(e) {
      e.preventDefault();

      // Cancel long press if finger moved
      if (touchStartPos) {
        const touch = e.touches[0];
        if (touch) {
          const touchPos = getTouchPos(touch);
          const moveDistance = Math.sqrt(
            Math.pow(touchPos.offsetX - touchStartPos.x, 2) +
            Math.pow(touchPos.offsetY - touchStartPos.y, 2)
          );
          if (moveDistance > 10) {
            cancelLongPress();
          }
        }
      }

      if (e.touches.length === 2) {
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        const distance = Math.sqrt(dx * dx + dy * dy);

        // Pinch zoom
        if (pinchStartDistance) {
          const scale = distance / pinchStartDistance;
          const rect = canvas.getBoundingClientRect();
          const center = getTwoFingerCenter(e.touches);
          const canvasCenterX = center.x - rect.left;
          const canvasCenterY = center.y - rect.top;

          // Apply zoom
          const newZoom = Math.max(CONFIG.MIN_PIXELS_PER_FOOT, Math.min(CONFIG.MAX_PIXELS_PER_FOOT, pinchStartZoom * scale));
          if (newZoom !== pixelsPerFoot) {
            const worldX = (canvasCenterX - panX) / pixelsPerFoot;
            const worldY = (canvasCenterY - panY) / pixelsPerFoot;
            pixelsPerFoot = newZoom;
            panX = canvasCenterX - worldX * pixelsPerFoot;
            panY = canvasCenterY - worldY * pixelsPerFoot;
            updateZoomDisplay();
          }
        }

        // Two-finger pan
        if (twoFingerPanStart) {
          const currentCenter = getTwoFingerCenter(e.touches);
          const panDeltaX = currentCenter.x - twoFingerPanStart.center.x;
          const panDeltaY = currentCenter.y - twoFingerPanStart.center.y;
          panX = twoFingerPanStart.panX + panDeltaX;
          panY = twoFingerPanStart.panY + panDeltaY;
        }

        drawThrottled();
        return;
      }

      if (e.touches.length === 1 && !isLongPress) {
        const touch = e.touches[0];
        const touchPos = getTouchPos(touch);

        // Simulate mousemove
        onMouseMove({
          ...touchPos,
          buttons: 1,
          shiftKey: false,
          preventDefault: () => {},
          stopPropagation: () => {}
        });
      }
    }

    function onTouchEnd(e) {
      e.preventDefault();
      cancelLongPress();
      pinchStartDistance = null;
      pinchStartZoom = null;
      twoFingerPanStart = null;

      // Check for tap (quick touch without much movement)
      if (touchStartPos && !isLongPress) {
        const duration = Date.now() - touchStartPos.time;
        if (duration < 200 && !isDragging) {
          // Quick tap - could be selection
          const { x, y } = screenToWorld(touchStartPos.x, touchStartPos.y);
          const tappedElement = [...elements].reverse().find(el => isPointInElement(x, y, el));
          if (tappedElement) {
            selectedElement = tappedElement;
            updateProperties();
            draw();
          } else if (!isPointInRoom(x, y)) {
            // Tapped outside room - deselect
            selectedElement = null;
            updateProperties();
            draw();
          }
        }
      }

      touchStartPos = null;
      isLongPress = false;

      // Simulate mouseup
      onMouseUp({
        button: 0,
        preventDefault: () => {},
        stopPropagation: () => {}
      });
    }

    function cancelLongPress() {
      if (longPressTimeout) {
        clearTimeout(longPressTimeout);
        longPressTimeout = null;
      }
    }

    // Check if point is inside the room bounds
    function isPointInRoom(x, y) {
      return x >= 0 && x <= roomWidth * pixelsPerFoot && y >= 0 && y <= roomDepth * pixelsPerFoot;
    }

    function setupDragDrop() {
      document.addEventListener('dragstart', (e) => {
        if (e.target.classList.contains('element-item')) {
          e.dataTransfer.setData('element-type', e.target.dataset.type);
          e.dataTransfer.effectAllowed = 'copy';
          e.target.style.opacity = '0.5';
          isHtmlDragging = true;
        }
      });

      document.addEventListener('dragend', (e) => {
        if (e.target.classList.contains('element-item')) {
          e.target.style.opacity = '1';
        }
        isHtmlDragging = false;
      });

      canvas.addEventListener('dragover', (e) => {
        e.preventDefault();
        e.dataTransfer.dropEffect = 'copy';
        isHtmlDragging = true;

        // Highlight element under cursor during material drag
        if (selectedMaterial) {
          const rect = canvas.getBoundingClientRect();
          const screenX = e.clientX - rect.left;
          const screenY = e.clientY - rect.top;
          const { x, y } = screenToWorld(screenX, screenY);
          const hit = [...elements].reverse().find(el => isPointInElement(x, y, el));
          const newHighlight = hit ? hit.id : null;
          if (newHighlight !== materialDropHighlight) {
            materialDropHighlight = newHighlight;
            draw();
          }
        }
      });
      canvas.addEventListener('dragleave', () => {
        isHtmlDragging = false;
        if (materialDropHighlight) {
          materialDropHighlight = null;
          draw();
        }
      });
      canvas.addEventListener('drop', (e) => {
        isHtmlDragging = false;
        onDrop(e);
      });
    }

    // ===== DRAWING =====
    function draw() {
      if (!ctx) return;

      // Clear entire canvas with dark background
      ctx.fillStyle = '#0d0d15';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Apply pan transformation
      ctx.save();
      ctx.translate(panX, panY);

      // Draw infinite grid
      drawGrid();

      // Draw room boundary (the actual room shape)
      drawRoomBoundary();

      // Draw floor plan areas
      drawFloorPlanAreas();

      // Draw walls
      drawWalls();

      // Draw elements
      drawElements();

      // Draw snap guides when dragging cabinets
      drawSnapGuides();

      // Draw work triangle overlay if enabled
      drawWorkTriangle();

      // Draw layout tool preview
      drawLayoutToolPreview();

      ctx.restore();

      // Use cached DOM element for performance
      const elCount = domCache.elementCount || document.getElementById('elementCount');
      if (elCount) elCount.textContent = `${elements.length} element${elements.length !== 1 ? 's' : ''}`;
      calculateQuoteThrottled();

      // Update element layer list panel
      updateElementList();
    }

    // Throttled draw using requestAnimationFrame - prevents excessive redraws during drag
    function drawThrottled() {
      if (drawPending) return;
      drawPending = true;
      requestAnimationFrame(() => {
        drawPending = false;
        draw();
      });
    }

    // Expose draw function globally for pro features module
    window.draw = draw;
    window.pixelsPerInch = pixelsPerFoot / 12;
    window.fitToScreen = fitToScreen;
    window.pixelsPerFoot = pixelsPerFoot;

    // Draw snap guides when dragging cabinets near walls
    function drawSnapGuides() {
      if (!isDragging || !selectedElement) return;

      const isCabinetType = ['base-cabinet', 'wall-cabinet', 'tall-cabinet', 'corner-cabinet',
                             'drawer-base', 'sink-base', 'lazy-susan',
                             'island', 'countertop', 'sink', 'stove', 'dishwasher',
                             'refrigerator', 'oven'].includes(selectedElement.type);

      if (!isCabinetType) return;

      // Draw hint text at top of canvas
      ctx.save();
      ctx.setTransform(1, 0, 0, 1, 0, 0); // Reset to screen coordinates
      ctx.font = '12px Inter';
      ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
      ctx.textAlign = 'center';
      ctx.fillText('Hold SHIFT for free placement (no snap/rotate)', canvas.width / 2, 25);
      ctx.restore();

      const snapZone = pixelsPerFoot * 0.5; // Match the reduced snap distance
      const roomW = roomWidth * pixelsPerFoot;
      const roomH = roomDepth * pixelsPerFoot;

      const elX = selectedElement.x;
      const elY = selectedElement.y;
      const elW = selectedElement.width * pixelsPerFoot;
      const elH = selectedElement.height * pixelsPerFoot;

      ctx.save();
      ctx.setLineDash([8, 4]);
      ctx.lineWidth = 2;

      // Back wall snap guide (top)
      if (Math.abs(elY) < snapZone) {
        ctx.strokeStyle = '#4CAF50';
        ctx.beginPath();
        ctx.moveTo(-50, 0);
        ctx.lineTo(roomW + 50, 0);
        ctx.stroke();
        // Highlight indicator
        ctx.fillStyle = 'rgba(76, 175, 80, 0.2)';
        ctx.fillRect(-50, 0, roomW + 100, snapZone);
      }

      // Left wall snap guide
      if (Math.abs(elX) < snapZone) {
        ctx.strokeStyle = '#2196F3';
        ctx.beginPath();
        ctx.moveTo(0, -50);
        ctx.lineTo(0, roomH + 50);
        ctx.stroke();
        ctx.fillStyle = 'rgba(33, 150, 243, 0.2)';
        ctx.fillRect(0, -50, snapZone, roomH + 100);
      }

      // Right wall snap guide
      if (Math.abs((elX + elW) - roomW) < snapZone) {
        ctx.strokeStyle = '#FF9800';
        ctx.beginPath();
        ctx.moveTo(roomW, -50);
        ctx.lineTo(roomW, roomH + 50);
        ctx.stroke();
        ctx.fillStyle = 'rgba(255, 152, 0, 0.2)';
        ctx.fillRect(roomW - snapZone, -50, snapZone, roomH + 100);
      }

      // Front wall snap guide (bottom)
      if (Math.abs((elY + elH) - roomH) < snapZone) {
        ctx.strokeStyle = '#9C27B0';
        ctx.beginPath();
        ctx.moveTo(-50, roomH);
        ctx.lineTo(roomW + 50, roomH);
        ctx.stroke();
        ctx.fillStyle = 'rgba(156, 39, 176, 0.2)';
        ctx.fillRect(-50, roomH - snapZone, roomW + 100, snapZone);
      }

      // Corner indicators for corner cabinets
      const isCornerCabinet = ['corner-cabinet', 'lazy-susan'].includes(selectedElement.type);
      if (isCornerCabinet) {
        const cornerZone = pixelsPerFoot * 1.0;

        // Top-left corner
        if (Math.abs(elX) < cornerZone && Math.abs(elY) < cornerZone) {
          ctx.fillStyle = 'rgba(76, 175, 80, 0.4)';
          ctx.beginPath();
          ctx.arc(0, 0, cornerZone, 0, Math.PI / 2);
          ctx.lineTo(0, 0);
          ctx.fill();
        }

        // Top-right corner
        if (Math.abs((elX + elW) - roomW) < cornerZone && Math.abs(elY) < cornerZone) {
          ctx.fillStyle = 'rgba(255, 152, 0, 0.4)';
          ctx.beginPath();
          ctx.arc(roomW, 0, cornerZone, Math.PI / 2, Math.PI);
          ctx.lineTo(roomW, 0);
          ctx.fill();
        }

        // Bottom-left corner
        if (Math.abs(elX) < cornerZone && Math.abs((elY + elH) - roomH) < cornerZone) {
          ctx.fillStyle = 'rgba(33, 150, 243, 0.4)';
          ctx.beginPath();
          ctx.arc(0, roomH, cornerZone, -Math.PI / 2, 0);
          ctx.lineTo(0, roomH);
          ctx.fill();
        }

        // Bottom-right corner
        if (Math.abs((elX + elW) - roomW) < cornerZone && Math.abs((elY + elH) - roomH) < cornerZone) {
          ctx.fillStyle = 'rgba(156, 39, 176, 0.4)';
          ctx.beginPath();
          ctx.arc(roomW, roomH, cornerZone, Math.PI, Math.PI * 1.5);
          ctx.lineTo(roomW, roomH);
          ctx.fill();
        }
      }

      // === ELEMENT-TO-ELEMENT ALIGNMENT GUIDES ===
      // Show alignment when current element aligns with other elements
      const alignThreshold = pixelsPerFoot * 0.25; // 3" tolerance
      const elCenterX = elX + elW / 2;
      const elCenterY = elY + elH / 2;
      const elRight = elX + elW;
      const elBottom = elY + elH;

      ctx.setLineDash([4, 4]);
      ctx.lineWidth = 1;

      elements.forEach(other => {
        if (other.id === selectedElement.id) return;
        if (other.type === 'flooring' || other.type === 'tile') return; // Skip floor elements

        const otherX = other.x;
        const otherY = other.y;
        const otherW = other.width * pixelsPerFoot;
        const otherH = other.height * pixelsPerFoot;
        const otherCenterX = otherX + otherW / 2;
        const otherCenterY = otherY + otherH / 2;
        const otherRight = otherX + otherW;
        const otherBottom = otherY + otherH;

        // Vertical alignment guides (X axis matches)
        // Left edge to left edge
        if (Math.abs(elX - otherX) < alignThreshold) {
          ctx.strokeStyle = '#00BCD4';
          ctx.beginPath();
          ctx.moveTo(otherX, Math.min(elY, otherY) - 20);
          ctx.lineTo(otherX, Math.max(elBottom, otherBottom) + 20);
          ctx.stroke();
        }
        // Right edge to right edge
        if (Math.abs(elRight - otherRight) < alignThreshold) {
          ctx.strokeStyle = '#00BCD4';
          ctx.beginPath();
          ctx.moveTo(otherRight, Math.min(elY, otherY) - 20);
          ctx.lineTo(otherRight, Math.max(elBottom, otherBottom) + 20);
          ctx.stroke();
        }
        // Center to center (vertical)
        if (Math.abs(elCenterX - otherCenterX) < alignThreshold) {
          ctx.strokeStyle = '#E91E63';
          ctx.beginPath();
          ctx.moveTo(otherCenterX, Math.min(elY, otherY) - 20);
          ctx.lineTo(otherCenterX, Math.max(elBottom, otherBottom) + 20);
          ctx.stroke();
        }
        // Left edge to right edge (butting together)
        if (Math.abs(elX - otherRight) < alignThreshold) {
          ctx.strokeStyle = '#8BC34A';
          ctx.beginPath();
          ctx.moveTo(otherRight, Math.min(elY, otherY) - 10);
          ctx.lineTo(otherRight, Math.max(elBottom, otherBottom) + 10);
          ctx.stroke();
        }
        // Right edge to left edge (butting together)
        if (Math.abs(elRight - otherX) < alignThreshold) {
          ctx.strokeStyle = '#8BC34A';
          ctx.beginPath();
          ctx.moveTo(otherX, Math.min(elY, otherY) - 10);
          ctx.lineTo(otherX, Math.max(elBottom, otherBottom) + 10);
          ctx.stroke();
        }

        // Horizontal alignment guides (Y axis matches)
        // Top edge to top edge
        if (Math.abs(elY - otherY) < alignThreshold) {
          ctx.strokeStyle = '#00BCD4';
          ctx.beginPath();
          ctx.moveTo(Math.min(elX, otherX) - 20, otherY);
          ctx.lineTo(Math.max(elRight, otherRight) + 20, otherY);
          ctx.stroke();
        }
        // Bottom edge to bottom edge
        if (Math.abs(elBottom - otherBottom) < alignThreshold) {
          ctx.strokeStyle = '#00BCD4';
          ctx.beginPath();
          ctx.moveTo(Math.min(elX, otherX) - 20, otherBottom);
          ctx.lineTo(Math.max(elRight, otherRight) + 20, otherBottom);
          ctx.stroke();
        }
        // Center to center (horizontal)
        if (Math.abs(elCenterY - otherCenterY) < alignThreshold) {
          ctx.strokeStyle = '#E91E63';
          ctx.beginPath();
          ctx.moveTo(Math.min(elX, otherX) - 20, otherCenterY);
          ctx.lineTo(Math.max(elRight, otherRight) + 20, otherCenterY);
          ctx.stroke();
        }
        // Top edge to bottom edge (stacking)
        if (Math.abs(elY - otherBottom) < alignThreshold) {
          ctx.strokeStyle = '#8BC34A';
          ctx.beginPath();
          ctx.moveTo(Math.min(elX, otherX) - 10, otherBottom);
          ctx.lineTo(Math.max(elRight, otherRight) + 10, otherBottom);
          ctx.stroke();
        }
        // Bottom edge to top edge (stacking)
        if (Math.abs(elBottom - otherY) < alignThreshold) {
          ctx.strokeStyle = '#8BC34A';
          ctx.beginPath();
          ctx.moveTo(Math.min(elX, otherX) - 10, otherY);
          ctx.lineTo(Math.max(elRight, otherRight) + 10, otherY);
          ctx.stroke();
        }

        // === DISTANCE MEASUREMENTS ===
        // Show gap distance when elements are close but not touching
        const gapThreshold = pixelsPerFoot * 4; // Show distances up to 4 feet

        // Horizontal gap (elements side by side)
        if (elY < otherBottom && elBottom > otherY) { // Vertically overlapping
          let hGap = 0;
          let gapX = 0;
          let gapY = Math.max(elY, otherY) + Math.min(elH, otherH) / 2;

          if (elX > otherRight) {
            hGap = elX - otherRight;
            gapX = otherRight + hGap / 2;
          } else if (otherX > elRight) {
            hGap = otherX - elRight;
            gapX = elRight + hGap / 2;
          }

          if (hGap > 0 && hGap < gapThreshold) {
            // Draw gap indicator
            ctx.strokeStyle = '#FFC107';
            ctx.setLineDash([2, 2]);
            ctx.beginPath();
            if (elX > otherRight) {
              ctx.moveTo(otherRight, gapY);
              ctx.lineTo(elX, gapY);
            } else {
              ctx.moveTo(elRight, gapY);
              ctx.lineTo(otherX, gapY);
            }
            ctx.stroke();

            // Draw measurement text
            const gapFeet = hGap / pixelsPerFoot;
            const gapInches = Math.round(gapFeet * 12);
            const gapText = gapInches < 12 ? `${gapInches}"` : `${Math.floor(gapInches / 12)}'-${gapInches % 12}"`;

            ctx.font = '10px Inter';
            ctx.fillStyle = '#FFC107';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'bottom';
            ctx.fillText(gapText, gapX, gapY - 3);
          }
        }

        // Vertical gap (elements stacked)
        if (elX < otherRight && elRight > otherX) { // Horizontally overlapping
          let vGap = 0;
          let gapY = 0;
          let gapX = Math.max(elX, otherX) + Math.min(elW, otherW) / 2;

          if (elY > otherBottom) {
            vGap = elY - otherBottom;
            gapY = otherBottom + vGap / 2;
          } else if (otherY > elBottom) {
            vGap = otherY - elBottom;
            gapY = elBottom + vGap / 2;
          }

          if (vGap > 0 && vGap < gapThreshold) {
            // Draw gap indicator
            ctx.strokeStyle = '#FFC107';
            ctx.setLineDash([2, 2]);
            ctx.beginPath();
            if (elY > otherBottom) {
              ctx.moveTo(gapX, otherBottom);
              ctx.lineTo(gapX, elY);
            } else {
              ctx.moveTo(gapX, elBottom);
              ctx.lineTo(gapX, otherY);
            }
            ctx.stroke();

            // Draw measurement text
            const gapFeet = vGap / pixelsPerFoot;
            const gapInches = Math.round(gapFeet * 12);
            const gapText = gapInches < 12 ? `${gapInches}"` : `${Math.floor(gapInches / 12)}'-${gapInches % 12}"`;

            ctx.font = '10px Inter';
            ctx.fillStyle = '#FFC107';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'middle';
            ctx.fillText(gapText, gapX + 5, gapY);
          }
        }
      });

      ctx.restore();
    }

    // Toggle work triangle visualization
    function toggleWorkTriangle() {
      showWorkTriangle = !showWorkTriangle;
      const btn = document.querySelector('.validation-toggle');
      if (btn) {
        btn.classList.toggle('active', showWorkTriangle);
      }
      if (showWorkTriangle) {
        runValidation();
      }
      draw();
    }

    function drawGrid() {
      const gridSize = pixelsPerFoot / CONFIG.GRID_SUBDIVISIONS;
      const roomW = roomWidth * pixelsPerFoot;
      const roomH = roomDepth * pixelsPerFoot;

      // Calculate visible area for grid
      const startX = -panX - pixelsPerFoot;
      const startY = -panY - pixelsPerFoot;
      const endX = canvas.width - panX + pixelsPerFoot;
      const endY = canvas.height - panY + pixelsPerFoot;

      // Sub-grid (faint lines)
      ctx.strokeStyle = 'rgba(255,255,255,0.02)';
      ctx.lineWidth = 1;

      const gridStartX = Math.floor(startX / gridSize) * gridSize;
      const gridStartY = Math.floor(startY / gridSize) * gridSize;

      for (let x = gridStartX; x < endX; x += gridSize) {
        ctx.beginPath();
        ctx.moveTo(x, startY);
        ctx.lineTo(x, endY);
        ctx.stroke();
      }
      for (let y = gridStartY; y < endY; y += gridSize) {
        ctx.beginPath();
        ctx.moveTo(startX, y);
        ctx.lineTo(endX, y);
        ctx.stroke();
      }

      // Main grid (1ft lines)
      ctx.strokeStyle = 'rgba(255,255,255,0.06)';
      const mainStartX = Math.floor(startX / pixelsPerFoot) * pixelsPerFoot;
      const mainStartY = Math.floor(startY / pixelsPerFoot) * pixelsPerFoot;

      for (let x = mainStartX; x < endX; x += pixelsPerFoot) {
        ctx.beginPath();
        ctx.moveTo(x, startY);
        ctx.lineTo(x, endY);
        ctx.stroke();
      }
      for (let y = mainStartY; y < endY; y += pixelsPerFoot) {
        ctx.beginPath();
        ctx.moveTo(startX, y);
        ctx.lineTo(endX, y);
        ctx.stroke();
      }
    }

    // Room resize state
    let isResizingRoom = false;
    let roomResizeHandle = null; // 'e', 's', 'se' (east, south, southeast corner)
    let roomResizeStart = { x: 0, y: 0, width: 0, depth: 0 };
    const ROOM_HANDLE_SIZE = 16;

    // Get room resize handles (only right, bottom, and bottom-right corner)
    function getRoomResizeHandles() {
      const roomW = roomWidth * pixelsPerFoot;
      const roomH = roomDepth * pixelsPerFoot;
      const hs = ROOM_HANDLE_SIZE;

      return {
        e: { x: roomW, y: roomH / 2, cursor: 'ew-resize' },    // Right edge center
        s: { x: roomW / 2, y: roomH, cursor: 'ns-resize' },    // Bottom edge center
        se: { x: roomW, y: roomH, cursor: 'nwse-resize' }      // Bottom-right corner
      };
    }

    // Check if point is on a room resize handle
    function getRoomHandleAtPosition(worldX, worldY) {
      const handles = getRoomResizeHandles();
      const hs = ROOM_HANDLE_SIZE + 6; // Slightly larger hit area

      for (const [name, handle] of Object.entries(handles)) {
        if (worldX >= handle.x - hs/2 && worldX <= handle.x + hs/2 &&
            worldY >= handle.y - hs/2 && worldY <= handle.y + hs/2) {
          return { name, ...handle };
        }
      }
      return null;
    }

    function drawRoomBoundary() {
      const roomW = roomWidth * pixelsPerFoot;
      const roomH = roomDepth * pixelsPerFoot;

      // Room floor (lighter area)
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, roomW, roomH);

      // Room border with measurements
      ctx.strokeStyle = '#4a4a6a';
      ctx.lineWidth = 3;
      ctx.strokeRect(0, 0, roomW, roomH);

      // Corner markers (static - top-left, top-right, bottom-left)
      const markerSize = 12;
      ctx.fillStyle = '#6366f1';
      ctx.fillRect(-markerSize/2, -markerSize/2, markerSize, markerSize);
      ctx.fillRect(roomW - markerSize/2, -markerSize/2, markerSize, markerSize);
      ctx.fillRect(-markerSize/2, roomH - markerSize/2, markerSize, markerSize);

      // Room resize handles (interactive - right edge, bottom edge, bottom-right corner)
      const handles = getRoomResizeHandles();
      const hs = ROOM_HANDLE_SIZE;

      // Right edge handle (east)
      ctx.fillStyle = isResizingRoom && roomResizeHandle === 'e' ? '#22c55e' : '#f97316';
      ctx.fillRect(handles.e.x - hs/2, handles.e.y - hs, hs, hs * 2);
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 2;
      ctx.strokeRect(handles.e.x - hs/2, handles.e.y - hs, hs, hs * 2);
      // Arrow indicator
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 12px Inter';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('', handles.e.x, handles.e.y);

      // Bottom edge handle (south)
      ctx.fillStyle = isResizingRoom && roomResizeHandle === 's' ? '#22c55e' : '#f97316';
      ctx.fillRect(handles.s.x - hs, handles.s.y - hs/2, hs * 2, hs);
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 2;
      ctx.strokeRect(handles.s.x - hs, handles.s.y - hs/2, hs * 2, hs);
      // Arrow indicator
      ctx.fillText('', handles.s.x, handles.s.y);
      ctx.save();
      ctx.translate(handles.s.x, handles.s.y);
      ctx.rotate(Math.PI / 2);
      ctx.fillText('', 0, 0);
      ctx.restore();

      // Bottom-right corner handle (southeast) - main resize handle
      ctx.fillStyle = isResizingRoom && roomResizeHandle === 'se' ? '#22c55e' : '#ef4444';
      ctx.beginPath();
      ctx.moveTo(roomW - hs * 1.5, roomH);
      ctx.lineTo(roomW, roomH);
      ctx.lineTo(roomW, roomH - hs * 1.5);
      ctx.closePath();
      ctx.fill();
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 2;
      ctx.stroke();
      // Diagonal resize indicator
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 14px Inter';
      ctx.fillText('', roomW - hs * 0.6, roomH - hs * 0.4);

      // Dimension labels along edges
      ctx.fillStyle = 'rgba(255,255,255,0.6)';
      ctx.font = `bold ${Math.max(12, pixelsPerFoot / 3)}px Inter`;
      ctx.textAlign = 'center';

      // Top dimension
      ctx.fillText(`${roomWidth}'`, roomW / 2, -10);
      // Left dimension
      ctx.save();
      ctx.translate(-10, roomH / 2);
      ctx.rotate(-Math.PI / 2);
      ctx.fillText(`${roomDepth}'`, 0, 0);
      ctx.restore();

      // Foot markers along room edges
      ctx.fillStyle = 'rgba(255,255,255,0.4)';
      ctx.font = `${Math.max(9, pixelsPerFoot / 5)}px Inter`;
      for (let x = pixelsPerFoot; x < roomW; x += pixelsPerFoot) {
        ctx.fillText(`${Math.round(x / pixelsPerFoot)}'`, x, -25);
        // Tick mark
        ctx.strokeStyle = 'rgba(255,255,255,0.3)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, -6);
        ctx.stroke();
      }
      for (let y = pixelsPerFoot; y < roomH; y += pixelsPerFoot) {
        ctx.save();
        ctx.translate(-25, y);
        ctx.rotate(-Math.PI / 2);
        ctx.fillText(`${Math.round(y / pixelsPerFoot)}'`, 0, 0);
        ctx.restore();
        // Tick mark
        ctx.strokeStyle = 'rgba(255,255,255,0.3)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(-6, y);
        ctx.stroke();
      }

      // Wall labels for clear orientation reference
      ctx.font = 'bold 11px Inter';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';

      // Back Wall label (top edge - far wall in 3D)
      ctx.fillStyle = 'rgba(99, 102, 241, 0.9)';
      ctx.fillRect(roomW / 2 - 40, 8, 80, 18);
      ctx.fillStyle = '#fff';
      ctx.fillText('BACK WALL', roomW / 2, 17);

      // Front Wall label (bottom edge - near wall in 3D)
      ctx.fillStyle = 'rgba(99, 102, 241, 0.9)';
      ctx.fillRect(roomW / 2 - 40, roomH - 26, 80, 18);
      ctx.fillStyle = '#fff';
      ctx.fillText('FRONT WALL', roomW / 2, roomH - 17);

      // Left Wall label (left edge)
      ctx.save();
      ctx.translate(26, roomH / 2);
      ctx.rotate(-Math.PI / 2);
      ctx.fillStyle = 'rgba(99, 102, 241, 0.9)';
      ctx.fillRect(-40, -9, 80, 18);
      ctx.fillStyle = '#fff';
      ctx.fillText('LEFT WALL', 0, 0);
      ctx.restore();

      // Right Wall label (right edge)
      ctx.save();
      ctx.translate(roomW - 26, roomH / 2);
      ctx.rotate(Math.PI / 2);
      ctx.fillStyle = 'rgba(99, 102, 241, 0.9)';
      ctx.fillRect(-40, -9, 80, 18);
      ctx.fillStyle = '#fff';
      ctx.fillText('RIGHT WALL', 0, 0);
      ctx.restore();
    }

    function drawFloorPlanAreas() {
      walls.filter(w => w.type === 'area').forEach(area => {
        ctx.fillStyle = 'rgba(60, 60, 80, 0.6)';
        ctx.fillRect(area.x, area.y, area.width, area.height);
        ctx.strokeStyle = '#666';
        ctx.lineWidth = 2;
        ctx.strokeRect(area.x, area.y, area.width, area.height);
      });
    }

    function drawWalls() {
      walls.filter(w => w.type === 'wall').forEach(wall => {
        ctx.fillStyle = wall.color;
        ctx.fillRect(wall.x, wall.y, wall.width, wall.height);
      });
    }

    // ===== RENDERING HELPER FUNCTIONS =====

    // Adjust a hex color by amount (-255 to 255)
    function adjustColor(color, amount) {
      if (!color || color.charAt(0) !== '#') return color;
      let r = parseInt(color.slice(1, 3), 16);
      let g = parseInt(color.slice(3, 5), 16);
      let b = parseInt(color.slice(5, 7), 16);
      r = Math.max(0, Math.min(255, r + amount));
      g = Math.max(0, Math.min(255, g + amount));
      b = Math.max(0, Math.min(255, b + amount));
      return `#${r.toString(16).padStart(2,'0')}${g.toString(16).padStart(2,'0')}${b.toString(16).padStart(2,'0')}`;
    }

    // Draw wood grain pattern
    function drawWoodGrain(ctx, x, y, w, h, baseColor, opacity = 1) {
      // Guard against invalid dimensions
      w = Math.abs(w);
      h = Math.abs(h);
      if (w < 1 || h < 1) return;

      const seed = Math.floor(x * 7 + y * 13) % 1000;
      const rand = (n) => ((seed + n * 31) % 100) / 100;

      ctx.save();
      ctx.globalAlpha = opacity;

      // HD wood grain with multiple layers for realism
      // Layer 1: Primary grain lines (darker, thicker)
      ctx.strokeStyle = 'rgba(60,40,20,0.18)';
      ctx.lineWidth = 1.2;

      const grainCount = Math.floor(h / 4); // More grain lines for HD
      for (let i = 0; i < grainCount; i++) {
        const gy = y + 3 + i * (h - 6) / grainCount;
        const waveAmp = 0.8 + rand(i) * 1.5;
        const waveFreq = 0.015 + rand(i + 50) * 0.025;
        const phaseShift = rand(i + 100) * Math.PI * 2;

        ctx.beginPath();
        ctx.moveTo(x + 1, gy);

        for (let gx = x + 1; gx < x + w - 1; gx += 2) {
          const progress = (gx - x) / w;
          const yOffset = Math.sin((gx - x) * waveFreq + phaseShift) * waveAmp * (0.8 + progress * 0.4);
          ctx.lineTo(gx, gy + yOffset);
        }
        ctx.stroke();
      }

      // Layer 2: Secondary fine grain (lighter, thinner)
      ctx.strokeStyle = 'rgba(80,60,40,0.10)';
      ctx.lineWidth = 0.5;
      const fineGrainCount = Math.floor(h / 2.5);
      for (let i = 0; i < fineGrainCount; i++) {
        const gy = y + 2 + i * (h - 4) / fineGrainCount;
        const waveAmp = 0.3 + rand(i + 200) * 0.8;
        const waveFreq = 0.03 + rand(i + 250) * 0.04;

        ctx.beginPath();
        ctx.moveTo(x + 1, gy);
        for (let gx = x + 1; gx < x + w - 1; gx += 1.5) {
          const yOffset = Math.sin((gx - x) * waveFreq + rand(i + 300) * Math.PI) * waveAmp;
          ctx.lineTo(gx, gy + yOffset);
        }
        ctx.stroke();
      }

      // Layer 3: Highlight grain streaks
      ctx.strokeStyle = 'rgba(255,240,220,0.06)';
      ctx.lineWidth = 1.5;
      const highlightCount = Math.floor(h / 10);
      for (let i = 0; i < highlightCount; i++) {
        const gy = y + 5 + rand(i * 17) * (h - 10);
        ctx.beginPath();
        ctx.moveTo(x + rand(i) * w * 0.2, gy);
        ctx.lineTo(x + w * 0.3 + rand(i + 1) * w * 0.7, gy + rand(i + 2) * 3 - 1.5);
        ctx.stroke();
      }

      // Darker grain knots with rings
      const knotCount = Math.floor(w * h / 2000);
      for (let k = 0; k < knotCount; k++) {
        const kx = x + rand(k * 3) * w * 0.8 + w * 0.1;
        const ky = y + rand(k * 5) * h * 0.8 + h * 0.1;
        const kr = 2 + rand(k * 7) * 5;

        // Knot center (darkest)
        ctx.fillStyle = 'rgba(40,25,10,0.15)';
        ctx.beginPath();
        ctx.ellipse(kx, ky, Math.abs(kr * 0.4), Math.abs(kr * 0.25), rand(k * 11) * Math.PI, 0, Math.PI * 2);
        ctx.fill();

        // Knot ring
        ctx.strokeStyle = 'rgba(50,30,15,0.12)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.ellipse(kx, ky, Math.abs(kr), Math.abs(kr * 0.6), rand(k * 11) * Math.PI, 0, Math.PI * 2);
        ctx.stroke();
      }

      // Subtle color variation patches
      ctx.fillStyle = 'rgba(80,50,20,0.03)';
      const patchCount = Math.floor(w * h / 1500);
      for (let p = 0; p < patchCount; p++) {
        const px = x + rand(p * 7) * w;
        const py = y + rand(p * 11) * h;
        const pw = 10 + rand(p * 13) * 20;
        const ph = 5 + rand(p * 17) * 15;
        ctx.fillRect(px, py, pw, ph);
      }

      ctx.restore();
    }

    // Draw a single cabinet door with shaker style - HD rendering
    function drawCabinetDoor(ctx, x, y, w, h, color) {
      // Guard against invalid dimensions
      w = Math.abs(w);
      h = Math.abs(h);
      if (w < 1 || h < 1) return;

      // Door background with subtle gradient
      const doorGrad = ctx.createLinearGradient(x, y, x, y + h);
      doorGrad.addColorStop(0, adjustColor(color, 8));
      doorGrad.addColorStop(0.5, color);
      doorGrad.addColorStop(1, adjustColor(color, -5));
      ctx.fillStyle = doorGrad;
      ctx.fillRect(x, y, w, h);

      // HD wood grain texture
      drawWoodGrain(ctx, x, y, w, h, color, 0.6);

      // Shaker panel inset - HD with beveled edges
      const inset = Math.min(12, w * 0.12, h * 0.1);
      const px = x + inset;
      const py = y + inset;
      const pw = w - inset * 2;
      const ph = h - inset * 2;

      // Outer bevel shadow (top-left inset)
      ctx.fillStyle = 'rgba(0,0,0,0.20)';
      ctx.fillRect(px - 1, py - 1, pw + 2, 3);
      ctx.fillRect(px - 1, py - 1, 3, ph + 2);

      // Outer bevel highlight (bottom-right)
      ctx.fillStyle = 'rgba(255,255,255,0.15)';
      ctx.fillRect(px, py + ph - 2, pw, 3);
      ctx.fillRect(px + pw - 2, py, 3, ph);

      // Inner panel with subtle gradient
      const panelGrad = ctx.createLinearGradient(px, py, px, py + ph);
      panelGrad.addColorStop(0, adjustColor(color, -8));
      panelGrad.addColorStop(0.3, adjustColor(color, -3));
      panelGrad.addColorStop(1, adjustColor(color, -12));
      ctx.fillStyle = panelGrad;
      ctx.fillRect(px + 2, py + 2, pw - 4, ph - 4);

      // Inner panel grain
      drawWoodGrain(ctx, px + 2, py + 2, pw - 4, ph - 4, color, 0.4);

      // Crisp edge definition
      ctx.strokeStyle = 'rgba(0,0,0,0.08)';
      ctx.lineWidth = 1;
      ctx.strokeRect(px + 1, py + 1, pw - 2, ph - 2);

      // Door frame outer highlights (simulates light source top-left)
      ctx.fillStyle = 'rgba(255,255,255,0.12)';
      ctx.fillRect(x, y, w, 2);
      ctx.fillRect(x, y, 2, h);

      ctx.fillStyle = 'rgba(0,0,0,0.15)';
      ctx.fillRect(x, y + h - 2, w, 2);
      ctx.fillRect(x + w - 2, y, 2, h);

      // HD Handle with metallic finish
      const handleLen = Math.min(22, h * 0.35);
      const handleW = 4;
      const handleX = x + w - 10;
      const handleY = y + h / 2 - handleLen / 2;

      // Handle shadow
      ctx.fillStyle = 'rgba(0,0,0,0.25)';
      ctx.fillRect(handleX + 2, handleY + 2, handleW, handleLen);

      // Handle body with metallic gradient
      const handleGrad = ctx.createLinearGradient(handleX, handleY, handleX + handleW, handleY);
      handleGrad.addColorStop(0, '#C8C8C8');
      handleGrad.addColorStop(0.3, '#E8E8E8');
      handleGrad.addColorStop(0.5, '#F5F5F5');
      handleGrad.addColorStop(0.7, '#D8D8D8');
      handleGrad.addColorStop(1, '#A0A0A0');
      ctx.fillStyle = handleGrad;
      ctx.fillRect(handleX, handleY, handleW, handleLen);

      // Handle edge highlight
      ctx.fillStyle = 'rgba(255,255,255,0.5)';
      ctx.fillRect(handleX, handleY, 1, handleLen);

      // Handle ends (rounded caps)
      ctx.fillStyle = '#B0B0B0';
      ctx.beginPath();
      ctx.arc(handleX + handleW/2, handleY + 2, handleW/2, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(handleX + handleW/2, handleY + handleLen - 2, handleW/2, 0, Math.PI * 2);
      ctx.fill();
    }

    // Draw countertop surface with material-specific patterns
    function drawCountertopSurface(ctx, x, y, w, h, color, materialName) {
      const name = (materialName || '').toLowerCase();
      const seed = Math.floor(x * 11 + y * 17) % 1000;
      const rand = (n) => ((seed + n * 23) % 100) / 100;

      // Determine material type from name
      let materialType = 'granite'; // default
      if (name.includes('marble') || name.includes('calacatta') || name.includes('carrara') || name.includes('statuario')) {
        materialType = 'marble';
      } else if (name.includes('quartz') || name.includes('silestone') || name.includes('caesarstone')) {
        materialType = 'quartz';
      } else if (name.includes('quartzite') || name.includes('taj') || name.includes('fantasy')) {
        materialType = 'quartzite';
      } else if (name.includes('concrete') || name.includes('cement')) {
        materialType = 'concrete';
      } else if (name.includes('butcher') || name.includes('wood') || name.includes('walnut') || name.includes('maple')) {
        materialType = 'wood';
      }

      ctx.save();

      switch (materialType) {
        case 'marble':
          // Marble: Dramatic veining on light background
          // Base with subtle variation
          const marbleGrad = ctx.createLinearGradient(x, y, x + w, y + h);
          marbleGrad.addColorStop(0, color);
          marbleGrad.addColorStop(0.5, adjustColor(color, 8));
          marbleGrad.addColorStop(1, adjustColor(color, -5));
          ctx.fillStyle = marbleGrad;
          ctx.fillRect(x, y, w, h);

          // Primary dramatic veins
          ctx.strokeStyle = 'rgba(80,80,90,0.35)';
          ctx.lineWidth = 2.5;
          for (let i = 0; i < 3; i++) {
            ctx.beginPath();
            const startX = x + rand(i) * w * 0.3;
            const startY = y + rand(i + 10) * h;
            ctx.moveTo(startX, startY);

            // Create flowing vein path
            const cp1x = x + w * (0.2 + rand(i + 20) * 0.3);
            const cp1y = y + h * rand(i + 30);
            const cp2x = x + w * (0.5 + rand(i + 40) * 0.3);
            const cp2y = y + h * rand(i + 50);
            const endX = x + w - rand(i + 60) * w * 0.2;
            const endY = y + rand(i + 70) * h;

            ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, endX, endY);
            ctx.stroke();

            // Feathered edges on main veins
            ctx.strokeStyle = 'rgba(80,80,90,0.15)';
            ctx.lineWidth = 5;
            ctx.stroke();
          }

          // Secondary thinner veins
          ctx.strokeStyle = 'rgba(100,100,110,0.2)';
          ctx.lineWidth = 1;
          for (let i = 0; i < 6; i++) {
            ctx.beginPath();
            ctx.moveTo(x + rand(i + 80) * w, y + rand(i + 90) * h);
            ctx.quadraticCurveTo(
              x + w * rand(i + 100),
              y + h * rand(i + 110),
              x + rand(i + 120) * w,
              y + rand(i + 130) * h
            );
            ctx.stroke();
          }
          break;

        case 'quartz':
          // Quartz: Uniform with subtle sparkle/flecks (optimized)
          ctx.fillStyle = color;
          ctx.fillRect(x, y, w, h);

          // Pre-defined speckle colors for performance (avoid string concat)
          const quartzSpeckles = [
            'rgba(255,255,255,0.06)', 'rgba(255,255,255,0.10)', 'rgba(255,255,255,0.14)',
            'rgba(0,0,0,0.05)', 'rgba(0,0,0,0.08)', 'rgba(0,0,0,0.12)'
          ];

          // Reduced speckle count for performance (was /40, now /80)
          const speckleCount = Math.floor(w * h / 80);
          for (let i = 0; i < speckleCount; i++) {
            const sx = x + rand(i) * w;
            const sy = y + rand(i + 500) * h;
            ctx.fillStyle = quartzSpeckles[Math.floor(rand(i + 1000) * quartzSpeckles.length)];
            ctx.fillRect(sx, sy, 1.5, 1.5);
          }

          // Occasional larger sparkle spots (batched)
          ctx.fillStyle = 'rgba(255,255,255,0.25)';
          ctx.beginPath();
          for (let i = 0; i < speckleCount / 25; i++) {
            const sx = x + rand(i + 2000) * w;
            const sy = y + rand(i + 2500) * h;
            ctx.moveTo(sx + 1, sy);
            ctx.arc(sx, sy, 1, 0, Math.PI * 2);
          }
          ctx.fill();
          break;

        case 'quartzite':
          // Quartzite: Natural flowing patterns with crystalline look
          ctx.fillStyle = color;
          ctx.fillRect(x, y, w, h);

          // Flowing wave patterns
          ctx.strokeStyle = 'rgba(255,255,255,0.15)';
          ctx.lineWidth = 3;
          for (let i = 0; i < 5; i++) {
            ctx.beginPath();
            const startY = y + (i / 5) * h + rand(i) * h * 0.1;
            ctx.moveTo(x, startY);

            for (let px = 0; px <= w; px += 20) {
              const py = startY + Math.sin((px / w) * Math.PI * (2 + rand(i + 10))) * h * 0.1 * rand(i + 20);
              ctx.lineTo(x + px, py);
            }
            ctx.stroke();
          }

          // Crystalline shimmer - batched drawing
          ctx.fillStyle = 'rgba(255,255,255,0.08)';
          ctx.beginPath();
          for (let i = 0; i < 20; i++) {
            const cx = x + rand(i + 300) * w;
            const cy = y + rand(i + 400) * h;
            ctx.moveTo(cx, cy - 3);
            ctx.lineTo(cx + 2, cy);
            ctx.lineTo(cx, cy + 3);
            ctx.lineTo(cx - 2, cy);
            ctx.closePath();
          }
          ctx.fill();
          break;

        case 'concrete':
          // Concrete: Matte with subtle texture
          ctx.fillStyle = color;
          ctx.fillRect(x, y, w, h);

          // Subtle aggregate texture - reduced count for performance (was /100, now /200)
          const concreteAggCount = Math.floor(w * h / 200);
          ctx.fillStyle = 'rgba(0,0,0,0.03)';
          ctx.beginPath();
          for (let i = 0; i < concreteAggCount; i++) {
            const cx = x + rand(i) * w;
            const cy = y + rand(i + 500) * h;
            const radius = 1 + rand(i + 1000) * 2;
            ctx.moveTo(cx + radius, cy);
            ctx.arc(cx, cy, radius, 0, Math.PI * 2);
          }
          ctx.fill();

          // Subtle variation patches - batched by dark/light
          ctx.fillStyle = 'rgba(0,0,0,0.02)';
          ctx.beginPath();
          for (let i = 0; i < 4; i++) {
            if (rand(i) > 0.5) {
              ctx.ellipse(
                x + rand(i + 100) * Math.abs(w),
                y + rand(i + 200) * Math.abs(h),
                Math.abs(rand(i + 300) * w * 0.3) || 1,
                Math.abs(rand(i + 400) * h * 0.3) || 1,
                rand(i + 500) * Math.PI,
                0, Math.PI * 2
              );
            }
          }
          ctx.fill();
          ctx.fillStyle = 'rgba(255,255,255,0.02)';
          ctx.beginPath();
          for (let i = 0; i < 4; i++) {
            if (rand(i) <= 0.5) {
              ctx.ellipse(
                x + rand(i + 100) * Math.abs(w),
                y + rand(i + 200) * Math.abs(h),
                Math.abs(rand(i + 300) * w * 0.3) || 1,
                Math.abs(rand(i + 400) * h * 0.3) || 1,
                rand(i + 500) * Math.PI,
                0, Math.PI * 2
              );
            }
          }
          ctx.fill();
          break;

        case 'wood':
          // Wood countertop: butcher block style
          drawWoodGrain(ctx, x, y, w, h, color);

          // Butcher block strips - batched for performance
          const stripWidth = pixelsPerFoot * 0.25;
          ctx.strokeStyle = 'rgba(0,0,0,0.1)';
          ctx.lineWidth = 1;
          ctx.beginPath();
          for (let sx = x + stripWidth; sx < x + w; sx += stripWidth) {
            ctx.moveTo(sx, y);
            ctx.lineTo(sx, y + h);
          }
          ctx.stroke();
          break;

        default: // granite
          // Granite: Speckled with various mineral colors
          ctx.fillStyle = color;
          ctx.fillRect(x, y, w, h);

          // Pre-defined mineral colors for performance
          const mineralColors = [
            'rgba(0,0,0,0.3)',
            'rgba(255,255,255,0.25)',
            'rgba(150,150,150,0.2)',
            'rgba(100,80,60,0.15)',
            'rgba(60,60,70,0.2)'
          ];

          // Reduced speckle count for performance (was /25, now /60)
          const graniteSpeckles = Math.floor(w * h / 60);

          // Batch speckles by color for fewer fillStyle changes
          for (let colorIdx = 0; colorIdx < mineralColors.length; colorIdx++) {
            ctx.fillStyle = mineralColors[colorIdx];
            const specklesPerColor = Math.floor(graniteSpeckles / mineralColors.length);
            for (let i = 0; i < specklesPerColor; i++) {
              const seed = colorIdx * specklesPerColor + i;
              const gx = x + rand(seed) * w;
              const gy = y + rand(seed + 500) * h;
              const size = 1 + rand(seed + 1500) * 2;
              ctx.fillRect(gx, gy, size, size);
            }
          }

          // Larger mineral clusters - batched by color
          const clusterCount = Math.floor(graniteSpeckles / 20);
          for (let colorIdx = 0; colorIdx < mineralColors.length; colorIdx++) {
            ctx.fillStyle = mineralColors[colorIdx];
            ctx.beginPath();
            const clustersPerColor = Math.floor(clusterCount / mineralColors.length);
            for (let i = 0; i < clustersPerColor; i++) {
              const seed = colorIdx * clustersPerColor + i + 2000;
              const cx = x + rand(seed) * w;
              const cy = y + rand(seed + 500) * h;
              const radius = 2 + rand(seed + 1000) * 3;
              ctx.moveTo(cx + radius, cy);
              ctx.arc(cx, cy, radius, 0, Math.PI * 2);
            }
            ctx.fill();
          }
      }

      // Edge profile (bullnose/eased edge look)
      // Top edge highlight
      ctx.fillStyle = 'rgba(255,255,255,0.2)';
      ctx.fillRect(x, y, w, 3);
      ctx.fillRect(x, y, 3, h);

      // Bottom edge shadow
      ctx.fillStyle = 'rgba(0,0,0,0.25)';
      ctx.fillRect(x, y + h - 3, w, 3);
      ctx.fillRect(x + w - 3, y, 3, h);

      // Outer border
      ctx.strokeStyle = 'rgba(255,255,255,0.15)';
      ctx.lineWidth = 1;
      ctx.strokeRect(x + 1, y + 1, w - 2, h - 2);

      ctx.restore();
    }

    // Draw architectural details for each element type
    function drawElementDetails(el, x, y, w, h) {
      ctx.strokeStyle = 'rgba(255,255,255,0.4)';
      ctx.fillStyle = 'rgba(255,255,255,0.1)';
      ctx.lineWidth = 1;

      const type = el.type;
      const padding = Math.min(w, h) * 0.08;

      // Check if element has a loaded texture image
      const hasTexture = el.textureImg && el.textureImg.complete && el.textureImg.naturalWidth > 0;

      switch(type) {
        case 'base-cabinet':
        case 'wall-cabinet':
          // CLEAN, CRISP CABINET RENDERING
          // Determine cabinet style from material or default to shaker
          const cabinetStyle = el.materialName?.toLowerCase().includes('flat') ? 'flat' : 'shaker';
          const isWallCab = type === 'wall-cabinet';

          // Toe kick dimensions for base cabinets (4" tall, 3" recessed)
          const toeKickH = isWallCab ? 0 : Math.max(6, h * 0.12);
          const toeKickRecess = isWallCab ? 0 : Math.max(4, w * 0.05);

          // Cabinet body height (excluding toe kick)
          const cabinetBodyH = h - toeKickH;

          // Draw cabinet body fill (clean solid color)
          ctx.fillStyle = el.color;
          ctx.fillRect(x, y, w, cabinetBodyH);

          // Draw toe kick recess for base cabinets
          if (!isWallCab && toeKickH > 0) {
            // Dark recessed void under cabinet
            ctx.fillStyle = '#0a0a0e';
            ctx.fillRect(x + toeKickRecess, y + cabinetBodyH, w - toeKickRecess * 2, toeKickH);

            // Clean shadow line at top of toe kick
            ctx.fillStyle = 'rgba(0,0,0,0.5)';
            ctx.fillRect(x + toeKickRecess, y + cabinetBodyH, w - toeKickRecess * 2, 2);
          }

          // Calculate door layout
          const doorCount = Math.max(1, Math.floor(w / (pixelsPerFoot * 1.5)));
          const doorWidth = (w - 6) / doorCount; // Minimal gap between doors
          const doorGap = 2;

          for (let i = 0; i < doorCount; i++) {
            const dx = x + 3 + i * doorWidth;
            const dy = y + 3;
            const dw = doorWidth - doorGap;
            const dh = cabinetBodyH - 6;

            // Door face - clean solid
            ctx.fillStyle = el.color;
            ctx.fillRect(dx, dy, dw, dh);

            // Clean door outline
            ctx.strokeStyle = 'rgba(0,0,0,0.25)';
            ctx.lineWidth = 1;
            ctx.strokeRect(dx + 0.5, dy + 0.5, dw - 1, dh - 1);

            if (cabinetStyle === 'shaker') {
              // Shaker style - clean recessed panel
              const panelInset = Math.min(10, Math.max(6, dw * 0.1));
              const px = dx + panelInset;
              const py = dy + panelInset;
              const pw = dw - panelInset * 2;
              const ph = dh - panelInset * 2;

              // Panel recess - clean lines
              ctx.strokeStyle = 'rgba(0,0,0,0.18)';
              ctx.lineWidth = 1;
              ctx.strokeRect(px + 0.5, py + 0.5, pw - 1, ph - 1);

              // Inner panel slightly recessed
              ctx.fillStyle = 'rgba(0,0,0,0.05)';
              ctx.fillRect(px + 1, py + 1, pw - 2, ph - 2);

              // Subtle highlight on panel frame
              ctx.strokeStyle = 'rgba(255,255,255,0.08)';
              ctx.strokeRect(px - 0.5, py - 0.5, pw + 1, ph + 1);
            }

            // Door edge highlights - subtle and clean
            ctx.fillStyle = 'rgba(255,255,255,0.1)';
            ctx.fillRect(dx, dy, dw, 1); // top highlight
            ctx.fillRect(dx, dy, 1, dh); // left highlight

            ctx.fillStyle = 'rgba(0,0,0,0.1)';
            ctx.fillRect(dx, dy + dh - 1, dw, 1); // bottom shadow
            ctx.fillRect(dx + dw - 1, dy, 1, dh); // right shadow

            // Door handle - clean bar pull
            const handleLen = Math.min(20, dh * 0.3);
            const handleX = dx + dw - 8;
            const handleY = dy + dh / 2 - handleLen / 2;

            // Handle shadow
            ctx.fillStyle = 'rgba(0,0,0,0.2)';
            ctx.fillRect(handleX + 1, handleY + 1, 3, handleLen);

            // Handle body - clean metallic
            ctx.fillStyle = '#C0C0C0';
            ctx.fillRect(handleX, handleY, 3, handleLen);

            // Handle highlight
            ctx.fillStyle = 'rgba(255,255,255,0.4)';
            ctx.fillRect(handleX, handleY, 1, handleLen);
          }

          // Cabinet side edges - clean dark line
          ctx.fillStyle = 'rgba(0,0,0,0.15)';
          ctx.fillRect(x, y, 1, cabinetBodyH);
          ctx.fillRect(x + w - 1, y, 1, cabinetBodyH);
          break;

        case 'microwave-cabinet': {
          // Microwave cabinet - open box/shelf with microwave inside
          // Standard microwave opening: 30" wide x 18" tall x 15" deep
          const mwcPad = padding;
          const boxThickness = Math.max(4, w * 0.05);

          // Cabinet box frame (open front)
          ctx.fillStyle = el.color || '#5C5040';

          // Top of box
          ctx.fillRect(x, y, w, boxThickness);
          // Bottom of box
          ctx.fillRect(x, y + h - boxThickness, w, boxThickness);
          // Left side
          ctx.fillRect(x, y, boxThickness, h);
          // Right side
          ctx.fillRect(x + w - boxThickness, y, boxThickness, h);

          // Wood grain on frame
          if (!hasTexture) {
            drawWoodGrain(ctx, x, y, w, boxThickness, el.color, 0.4);
            drawWoodGrain(ctx, x, y + h - boxThickness, w, boxThickness, el.color, 0.4);
          }

          // Dark interior (open box showing depth)
          ctx.fillStyle = '#1a1a1a';
          ctx.fillRect(x + boxThickness, y + boxThickness, w - boxThickness * 2, h - boxThickness * 2);

          // Microwave face inside the opening
          const mwPad = boxThickness + 4;
          const mwW = w - mwPad * 2;
          const mwH = h - mwPad * 2;

          // Microwave body
          ctx.fillStyle = '#2a2a2a';
          ctx.fillRect(x + mwPad, y + mwPad, mwW, mwH);

          // Microwave glass door (left 65%)
          ctx.fillStyle = '#1a1a1a';
          ctx.fillRect(x + mwPad + 4, y + mwPad + 4, mwW * 0.6, mwH - 8);

          // Glass reflection
          ctx.fillStyle = 'rgba(255,255,255,0.05)';
          ctx.fillRect(x + mwPad + 8, y + mwPad + 8, mwW * 0.3, mwH * 0.4);

          // Control panel (right 35%)
          ctx.fillStyle = '#3a3a3a';
          ctx.fillRect(x + mwPad + mwW * 0.65, y + mwPad + 4, mwW * 0.3, mwH - 8);

          // Buttons/display
          ctx.fillStyle = '#222';
          ctx.fillRect(x + mwPad + mwW * 0.68, y + mwPad + 10, mwW * 0.22, mwH * 0.2);

          // Button grid
          for (let row = 0; row < 3; row++) {
            for (let col = 0; col < 3; col++) {
              ctx.fillStyle = '#444';
              ctx.fillRect(
                x + mwPad + mwW * 0.7 + col * (mwW * 0.07),
                y + mwPad + mwH * 0.4 + row * (mwH * 0.15),
                mwW * 0.05,
                mwH * 0.1
              );
            }
          }

          // Door handle
          ctx.fillStyle = '#666';
          ctx.fillRect(x + mwPad + mwW * 0.58, y + mwPad + mwH * 0.3, 4, mwH * 0.4);

          break;
        }

        case 'drawer-base': {
          // Drawer base cabinet - 3-4 stacked drawer fronts
          const dbToeKickH = Math.max(8, h * 0.15);
          const dbToeKickRecess = Math.max(5, w * 0.06);
          const dbBodyH = h - dbToeKickH;

          // Draw toe kick recess
          ctx.fillStyle = '#0d0d12';
          ctx.fillRect(x + dbToeKickRecess, y + dbBodyH, w - dbToeKickRecess * 2, dbToeKickH);
          ctx.fillStyle = 'rgba(0,0,0,0.7)';
          ctx.fillRect(x + dbToeKickRecess, y + dbBodyH, w - dbToeKickRecess * 2, 3);
          ctx.fillStyle = adjustColor(el.color, -40);
          ctx.fillRect(x, y + dbBodyH - 2, w, 2);

          // Draw wood grain background
          if (!hasTexture) {
            drawWoodGrain(ctx, x, y, w, dbBodyH, el.color);
          }

          // Calculate drawer layout (3-4 drawers)
          const numDrawers = w > pixelsPerFoot * 2 ? 4 : 3;
          const drawerHeight = (dbBodyH - padding * 2 - (numDrawers - 1) * 3) / numDrawers;

          for (let i = 0; i < numDrawers; i++) {
            const dx = x + padding;
            const dy = y + padding + i * (drawerHeight + 3);
            const dw = w - padding * 2;
            const dh = drawerHeight;

            // Drawer shadow
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.fillRect(dx + 3, dy + 3, dw, dh);

            // Drawer face
            ctx.fillStyle = el.color;
            ctx.fillRect(dx, dy, dw, dh);

            // Drawer panel detail (shaker style)
            const panelInset = Math.min(8, dw * 0.08);
            ctx.fillStyle = 'rgba(0,0,0,0.15)';
            ctx.fillRect(dx + panelInset, dy + panelInset, 2, dh - panelInset * 2);
            ctx.fillRect(dx + panelInset, dy + panelInset, dw - panelInset * 2, 2);
            ctx.fillStyle = 'rgba(255,255,255,0.1)';
            ctx.fillRect(dx + dw - panelInset - 2, dy + panelInset, 2, dh - panelInset * 2);
            ctx.fillRect(dx + panelInset, dy + dh - panelInset - 2, dw - panelInset * 2, 2);

            // Drawer edge highlights
            ctx.fillStyle = 'rgba(255,255,255,0.12)';
            ctx.fillRect(dx, dy, dw, 2);
            ctx.fillRect(dx, dy, 2, dh);
            ctx.fillStyle = 'rgba(0,0,0,0.15)';
            ctx.fillRect(dx, dy + dh - 2, dw, 2);
            ctx.fillRect(dx + dw - 2, dy, 2, dh);

            // Centered bar pull handle
            const handleLen = Math.min(dw * 0.4, 40);
            const handleX = dx + dw / 2 - handleLen / 2;
            const handleY = dy + dh / 2 - 2;

            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.fillRect(handleX + 2, handleY + 2, handleLen, 4);

            const handleGrad = ctx.createLinearGradient(0, handleY, 0, handleY + 4);
            handleGrad.addColorStop(0, 'rgba(220,220,220,0.95)');
            handleGrad.addColorStop(0.5, 'rgba(250,250,250,0.95)');
            handleGrad.addColorStop(1, 'rgba(190,190,190,0.9)');
            ctx.fillStyle = handleGrad;
            ctx.fillRect(handleX, handleY, handleLen, 4);
          }

          // Side panel edges
          ctx.fillStyle = adjustColor(el.color, -25);
          ctx.fillRect(x, y, 2, dbBodyH);
          ctx.fillRect(x + w - 2, y, 2, dbBodyH);
          break;
        }

        case 'sink-base': {
          // Sink base cabinet - false drawer front at top, open interior
          const sbToeKickH = Math.max(8, h * 0.15);
          const sbToeKickRecess = Math.max(5, w * 0.06);
          const sbBodyH = h - sbToeKickH;

          // Draw toe kick recess
          ctx.fillStyle = '#0d0d12';
          ctx.fillRect(x + sbToeKickRecess, y + sbBodyH, w - sbToeKickRecess * 2, sbToeKickH);
          ctx.fillStyle = 'rgba(0,0,0,0.7)';
          ctx.fillRect(x + sbToeKickRecess, y + sbBodyH, w - sbToeKickRecess * 2, 3);
          ctx.fillStyle = adjustColor(el.color, -40);
          ctx.fillRect(x, y + sbBodyH - 2, w, 2);

          // Draw wood grain background
          if (!hasTexture) {
            drawWoodGrain(ctx, x, y, w, sbBodyH, el.color);
          }

          // False drawer front at top (non-functional)
          const falseDrawerH = Math.min(sbBodyH * 0.18, 20);
          const fdx = x + padding;
          const fdy = y + padding;
          const fdw = w - padding * 2;

          ctx.fillStyle = 'rgba(0,0,0,0.3)';
          ctx.fillRect(fdx + 3, fdy + 3, fdw, falseDrawerH);
          ctx.fillStyle = el.color;
          ctx.fillRect(fdx, fdy, fdw, falseDrawerH);
          ctx.fillStyle = 'rgba(255,255,255,0.12)';
          ctx.fillRect(fdx, fdy, fdw, 2);
          ctx.fillStyle = 'rgba(0,0,0,0.1)';
          ctx.fillRect(fdx, fdy + falseDrawerH - 2, fdw, 2);

          // False drawer handle
          const fhandleLen = Math.min(fdw * 0.4, 35);
          const fhandleX = fdx + fdw / 2 - fhandleLen / 2;
          const fhandleY = fdy + falseDrawerH / 2 - 2;
          ctx.fillStyle = 'rgba(200,200,200,0.9)';
          ctx.fillRect(fhandleX, fhandleY, fhandleLen, 3);

          // Double door section below
          const doorsY = fdy + falseDrawerH + 4;
          const doorsH = sbBodyH - padding * 2 - falseDrawerH - 4;
          const doorW = (fdw - 4) / 2;

          for (let i = 0; i < 2; i++) {
            const ddx = fdx + i * (doorW + 4);
            const ddy = doorsY;
            const ddw = doorW;
            const ddh = doorsH;

            // Door shadow
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.fillRect(ddx + 3, ddy + 3, ddw, ddh);

            // Door face
            ctx.fillStyle = el.color;
            ctx.fillRect(ddx, ddy, ddw, ddh);

            // Shaker panel
            const panelInset = Math.min(10, ddw * 0.1);
            ctx.fillStyle = 'rgba(0,0,0,0.15)';
            ctx.fillRect(ddx + panelInset, ddy + panelInset, 2, ddh - panelInset * 2);
            ctx.fillRect(ddx + panelInset, ddy + panelInset, ddw - panelInset * 2, 2);
            ctx.fillStyle = 'rgba(255,255,255,0.1)';
            ctx.fillRect(ddx + ddw - panelInset - 2, ddy + panelInset, 2, ddh - panelInset * 2);
            ctx.fillRect(ddx + panelInset, ddy + ddh - panelInset - 2, ddw - panelInset * 2, 2);

            // Door edge highlights
            ctx.fillStyle = 'rgba(255,255,255,0.12)';
            ctx.fillRect(ddx, ddy, ddw, 2);
            ctx.fillRect(ddx, ddy, 2, ddh);
            ctx.fillStyle = 'rgba(0,0,0,0.15)';
            ctx.fillRect(ddx, ddy + ddh - 2, ddw, 2);
            ctx.fillRect(ddx + ddw - 2, ddy, 2, ddh);

            // Door handle
            const dhandleLen = Math.min(20, ddh * 0.3);
            const dhandleX = i === 0 ? ddx + ddw - 10 : ddx + 6;
            const dhandleY = ddy + ddh / 2 - dhandleLen / 2;
            ctx.fillStyle = 'rgba(200,200,200,0.9)';
            ctx.fillRect(dhandleX, dhandleY, 4, dhandleLen);
          }

          // Side panel edges
          ctx.fillStyle = adjustColor(el.color, -25);
          ctx.fillRect(x, y, 2, sbBodyH);
          ctx.fillRect(x + w - 2, y, 2, sbBodyH);
          break;
        }

        case 'lazy-susan': {
          // LAZY SUSAN - L-shaped corner cabinet with rotating turntable shelves
          // Plan view (top-down): L-shape with 24" depth arms, lazy susan circle in corner
          const lsArmD = pixelsPerFoot * 2; // 24" standard cabinet depth for each arm
          const lsInnerW = w - lsArmD; // exposed portion of bottom arm
          const lsInnerH = h - lsArmD; // exposed portion of right arm

          // L-shape cabinet body
          ctx.fillStyle = el.color;
          ctx.beginPath();
          ctx.moveTo(x, y);
          ctx.lineTo(x + w, y);
          ctx.lineTo(x + w, y + lsArmD);
          ctx.lineTo(x + lsArmD, y + lsArmD);
          ctx.lineTo(x + lsArmD, y + h);
          ctx.lineTo(x, y + h);
          ctx.closePath();
          ctx.fill();

          // Dark interior in corner overlap area
          ctx.fillStyle = 'rgba(20,20,25,0.5)';
          ctx.fillRect(x + 2, y + 2, lsArmD - 4, lsArmD - 4);

          // Lazy susan turntable (circle in corner area)
          const lsRadius = Math.min(lsArmD, lsArmD) * 0.42;
          const lsCx = x + lsArmD * 0.5;
          const lsCy = y + lsArmD * 0.5;

          // Turntable base circle
          ctx.fillStyle = 'rgba(180,160,120,0.35)';
          ctx.beginPath();
          ctx.arc(lsCx, lsCy, lsRadius, 0, Math.PI * 2);
          ctx.fill();
          ctx.strokeStyle = 'rgba(0,0,0,0.2)';
          ctx.lineWidth = 1.5;
          ctx.stroke();

          // Pie-shaped shelf dividers (4 quadrants)
          ctx.strokeStyle = 'rgba(0,0,0,0.15)';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(lsCx - lsRadius, lsCy);
          ctx.lineTo(lsCx + lsRadius, lsCy);
          ctx.moveTo(lsCx, lsCy - lsRadius);
          ctx.lineTo(lsCx, lsCy + lsRadius);
          ctx.stroke();

          // Center pivot
          ctx.fillStyle = '#A0A0A0';
          ctx.beginPath();
          ctx.arc(lsCx, lsCy, 3, 0, Math.PI * 2);
          ctx.fill();

          // Rotation arrow hint
          ctx.strokeStyle = 'rgba(0,0,0,0.12)';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.arc(lsCx, lsCy, lsRadius * 0.7, -0.3, Math.PI * 1.2);
          ctx.stroke();
          // Arrowhead
          const arrowAngle = Math.PI * 1.2;
          const arrowR = lsRadius * 0.7;
          const ax = lsCx + Math.cos(arrowAngle) * arrowR;
          const ay = lsCy + Math.sin(arrowAngle) * arrowR;
          ctx.beginPath();
          ctx.moveTo(ax + 4, ay - 3);
          ctx.lineTo(ax, ay);
          ctx.lineTo(ax + 5, ay + 2);
          ctx.stroke();

          // Diagonal door line (where bi-fold doors meet at 45)
          ctx.strokeStyle = 'rgba(0,0,0,0.35)';
          ctx.lineWidth = 1.5;
          ctx.beginPath();
          ctx.moveTo(x + lsArmD, y + lsArmD);
          ctx.lineTo(x + lsArmD + lsInnerW, y + lsArmD - lsInnerH);
          ctx.stroke();

          // Door on bottom arm (front-facing, at x + lsArmD edge going down)
          const lsBottomDoorY = y + lsArmD + 3;
          const lsBottomDoorH = h - lsArmD - 6;
          const lsBottomDoorW = lsArmD - 6;
          if (lsBottomDoorH > 8) {
            ctx.fillStyle = el.color;
            ctx.fillRect(x + 3, lsBottomDoorY, lsBottomDoorW, lsBottomDoorH);
            ctx.strokeStyle = 'rgba(0,0,0,0.2)';
            ctx.lineWidth = 1;
            ctx.strokeRect(x + 3.5, lsBottomDoorY + 0.5, lsBottomDoorW - 1, lsBottomDoorH - 1);
            const lsInset = Math.min(8, lsBottomDoorW * 0.12);
            ctx.strokeStyle = 'rgba(0,0,0,0.12)';
            ctx.strokeRect(x + 3 + lsInset, lsBottomDoorY + lsInset, lsBottomDoorW - lsInset * 2, lsBottomDoorH - lsInset * 2);
            // Handle
            ctx.fillStyle = '#C0C0C0';
            ctx.fillRect(x + 3 + lsBottomDoorW - 7, lsBottomDoorY + lsBottomDoorH / 2 - 8, 3, 16);
          }

          // Door on right arm (front-facing, at y + lsArmD edge going right)
          const lsRightDoorX = x + lsArmD + 3;
          const lsRightDoorW = w - lsArmD - 6;
          const lsRightDoorH = lsArmD - 6;
          if (lsRightDoorW > 8) {
            ctx.fillStyle = el.color;
            ctx.fillRect(lsRightDoorX, y + 3, lsRightDoorW, lsRightDoorH);
            ctx.strokeStyle = 'rgba(0,0,0,0.2)';
            ctx.lineWidth = 1;
            ctx.strokeRect(lsRightDoorX + 0.5, y + 3.5, lsRightDoorW - 1, lsRightDoorH - 1);
            const lsInset2 = Math.min(8, lsRightDoorH * 0.12);
            ctx.strokeStyle = 'rgba(0,0,0,0.12)';
            ctx.strokeRect(lsRightDoorX + lsInset2, y + 3 + lsInset2, lsRightDoorW - lsInset2 * 2, lsRightDoorH - lsInset2 * 2);
            // Handle
            ctx.fillStyle = '#C0C0C0';
            ctx.fillRect(lsRightDoorX + lsRightDoorW / 2 - 8, y + 3 + lsRightDoorH - 7, 16, 3);
          }

          // Cabinet outline
          ctx.strokeStyle = 'rgba(0,0,0,0.25)';
          ctx.lineWidth = 1.5;
          ctx.beginPath();
          ctx.moveTo(x, y);
          ctx.lineTo(x + w, y);
          ctx.lineTo(x + w, y + lsArmD);
          ctx.lineTo(x + lsArmD, y + lsArmD);
          ctx.lineTo(x + lsArmD, y + h);
          ctx.lineTo(x, y + h);
          ctx.closePath();
          ctx.stroke();
          break;
        }

        case 'blind-corner': {
          // BLIND CORNER CABINET - L-shaped with one accessible door, one blind side
          // Plan view: L-shape with 24" depth arms, door only on main face
          const bcArmD = pixelsPerFoot * 2; // 24" standard depth
          const bcInnerW = w - bcArmD; // exposed bottom arm width
          const bcInnerH = h - bcArmD; // exposed right arm height

          // L-shape cabinet body
          ctx.fillStyle = el.color;
          ctx.beginPath();
          ctx.moveTo(x, y);
          ctx.lineTo(x + w, y);
          ctx.lineTo(x + w, y + bcArmD);
          ctx.lineTo(x + bcArmD, y + bcArmD);
          ctx.lineTo(x + bcArmD, y + h);
          ctx.lineTo(x, y + h);
          ctx.closePath();
          ctx.fill();

          // Dark dead space in corner (blind/inaccessible area)
          ctx.fillStyle = 'rgba(15,15,20,0.6)';
          ctx.fillRect(x + 2, y + 2, bcArmD - 4, bcArmD - 4);

          // "BLIND" label in dead space
          ctx.fillStyle = 'rgba(255,255,255,0.15)';
          ctx.font = `${Math.max(8, bcArmD * 0.12)}px Arial`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText('BLIND', x + bcArmD / 2, y + bcArmD / 2);

          // Internal partition wall between blind area and accessible area
          ctx.strokeStyle = 'rgba(0,0,0,0.3)';
          ctx.lineWidth = 2;
          // Vertical partition at armD
          ctx.beginPath();
          ctx.moveTo(x + bcArmD, y + bcArmD);
          ctx.lineTo(x + bcArmD, y + 2);
          ctx.stroke();
          // Horizontal partition at armD
          ctx.beginPath();
          ctx.moveTo(x + bcArmD, y + bcArmD);
          ctx.lineTo(x + 2, y + bcArmD);
          ctx.stroke();

          // Main door on bottom arm (accessible side, faces room)
          const bcDoorY = y + bcArmD + 3;
          const bcDoorH = h - bcArmD - 6;
          const bcDoorW = bcArmD - 6;
          if (bcDoorH > 8) {
            ctx.fillStyle = el.color;
            ctx.fillRect(x + 3, bcDoorY, bcDoorW, bcDoorH);
            ctx.strokeStyle = 'rgba(0,0,0,0.2)';
            ctx.lineWidth = 1;
            ctx.strokeRect(x + 3.5, bcDoorY + 0.5, bcDoorW - 1, bcDoorH - 1);
            const bcPanelInset = Math.min(8, bcDoorW * 0.12);
            ctx.strokeStyle = 'rgba(0,0,0,0.12)';
            ctx.strokeRect(x + 3 + bcPanelInset, bcDoorY + bcPanelInset, bcDoorW - bcPanelInset * 2, bcDoorH - bcPanelInset * 2);
            ctx.fillStyle = 'rgba(0,0,0,0.04)';
            ctx.fillRect(x + 3 + bcPanelInset + 1, bcDoorY + bcPanelInset + 1, bcDoorW - bcPanelInset * 2 - 2, bcDoorH - bcPanelInset * 2 - 2);
            // Handle
            ctx.fillStyle = '#C0C0C0';
            ctx.fillRect(x + 3 + bcDoorW - 7, bcDoorY + bcDoorH / 2 - 8, 3, 16);
          }

          // Right arm door (accessible side)
          const bcRightDoorX = x + bcArmD + 3;
          const bcRightDoorW = w - bcArmD - 6;
          const bcRightDoorH = bcArmD - 6;
          if (bcRightDoorW > 8) {
            ctx.fillStyle = el.color;
            ctx.fillRect(bcRightDoorX, y + 3, bcRightDoorW, bcRightDoorH);
            ctx.strokeStyle = 'rgba(0,0,0,0.2)';
            ctx.lineWidth = 1;
            ctx.strokeRect(bcRightDoorX + 0.5, y + 3.5, bcRightDoorW - 1, bcRightDoorH - 1);
            const bcInset2 = Math.min(8, bcRightDoorH * 0.12);
            ctx.strokeStyle = 'rgba(0,0,0,0.12)';
            ctx.strokeRect(bcRightDoorX + bcInset2, y + 3 + bcInset2, bcRightDoorW - bcInset2 * 2, bcRightDoorH - bcInset2 * 2);
            ctx.fillStyle = 'rgba(0,0,0,0.04)';
            ctx.fillRect(bcRightDoorX + bcInset2 + 1, y + 3 + bcInset2 + 1, bcRightDoorW - bcInset2 * 2 - 2, bcRightDoorH - bcInset2 * 2 - 2);
            // Handle
            ctx.fillStyle = '#C0C0C0';
            ctx.fillRect(bcRightDoorX + bcRightDoorW / 2 - 8, y + 3 + bcRightDoorH - 7, 16, 3);
          }

          // Cabinet outline
          ctx.strokeStyle = 'rgba(0,0,0,0.25)';
          ctx.lineWidth = 1.5;
          ctx.beginPath();
          ctx.moveTo(x, y);
          ctx.lineTo(x + w, y);
          ctx.lineTo(x + w, y + bcArmD);
          ctx.lineTo(x + bcArmD, y + bcArmD);
          ctx.lineTo(x + bcArmD, y + h);
          ctx.lineTo(x, y + h);
          ctx.closePath();
          ctx.stroke();
          break;
        }

        case 'tall-cabinet':
          // CLEAN TALL CABINET RENDERING
          const tallToeH = Math.max(6, h * 0.06);
          const tallToeRecess = Math.max(4, w * 0.05);
          const tallBodyH = h - tallToeH;

          // Cabinet body fill
          ctx.fillStyle = el.color;
          ctx.fillRect(x, y, w, tallBodyH);

          // Draw toe kick recess
          ctx.fillStyle = '#0a0a0e';
          ctx.fillRect(x + tallToeRecess, y + tallBodyH, w - tallToeRecess * 2, tallToeH);
          ctx.fillStyle = 'rgba(0,0,0,0.5)';
          ctx.fillRect(x + tallToeRecess, y + tallBodyH, w - tallToeRecess * 2, 2);

          // Two-section tall cabinet (upper 35%, lower 65%)
          const tallMidY = y + tallBodyH * 0.35;
          const sectionGap = 3;

          // Upper door
          const upperDx = x + 3;
          const upperDy = y + 3;
          const upperDw = w - 6;
          const upperDh = tallMidY - y - 3 - sectionGap/2;

          ctx.fillStyle = el.color;
          ctx.fillRect(upperDx, upperDy, upperDw, upperDh);
          ctx.strokeStyle = 'rgba(0,0,0,0.25)';
          ctx.lineWidth = 1;
          ctx.strokeRect(upperDx + 0.5, upperDy + 0.5, upperDw - 1, upperDh - 1);

          // Upper shaker panel
          const upperInset = Math.min(8, upperDw * 0.08);
          ctx.strokeStyle = 'rgba(0,0,0,0.15)';
          ctx.strokeRect(upperDx + upperInset, upperDy + upperInset, upperDw - upperInset * 2, upperDh - upperInset * 2);
          ctx.fillStyle = 'rgba(0,0,0,0.04)';
          ctx.fillRect(upperDx + upperInset + 1, upperDy + upperInset + 1, upperDw - upperInset * 2 - 2, upperDh - upperInset * 2 - 2);

          // Upper handle
          const upperHandleLen = Math.min(18, upperDh * 0.25);
          ctx.fillStyle = '#C0C0C0';
          ctx.fillRect(upperDx + upperDw - 7, upperDy + upperDh - upperHandleLen - 8, 3, upperHandleLen);

          // Lower door
          const lowerDy = tallMidY + sectionGap/2;
          const lowerDh = tallBodyH - (tallMidY - y) - 3 - sectionGap/2;

          ctx.fillStyle = el.color;
          ctx.fillRect(upperDx, lowerDy, upperDw, lowerDh);
          ctx.strokeStyle = 'rgba(0,0,0,0.25)';
          ctx.strokeRect(upperDx + 0.5, lowerDy + 0.5, upperDw - 1, lowerDh - 1);

          // Lower shaker panel
          ctx.strokeStyle = 'rgba(0,0,0,0.15)';
          ctx.strokeRect(upperDx + upperInset, lowerDy + upperInset, upperDw - upperInset * 2, lowerDh - upperInset * 2);
          ctx.fillStyle = 'rgba(0,0,0,0.04)';
          ctx.fillRect(upperDx + upperInset + 1, lowerDy + upperInset + 1, upperDw - upperInset * 2 - 2, lowerDh - upperInset * 2 - 2);

          // Lower handle
          const lowerHandleLen = Math.min(18, lowerDh * 0.2);
          ctx.fillStyle = '#C0C0C0';
          ctx.fillRect(upperDx + upperDw - 7, lowerDy + 8, 3, lowerHandleLen);

          // Side edges
          ctx.fillStyle = 'rgba(0,0,0,0.15)';
          ctx.fillRect(x, y, 1, tallBodyH);
          ctx.fillRect(x + w - 1, y, 1, tallBodyH);
          break;

        case 'fridge-cabinet': {
          // Fridge enclosure cabinet - frame with opening for fridge and cabinet above
          const fridgeCabPadding = 4;
          const panelWidth = w * 0.08; // Side panels
          const topCabinetH = h * 0.25; // Cabinet above fridge
          const fridgeOpeningH = h * 0.70; // Opening for fridge
          const toeKickH = h * 0.05;

          // Draw outer frame/panels
          ctx.fillStyle = el.color || '#8B4513';

          // Left panel
          ctx.fillRect(x, y, panelWidth, h - toeKickH);
          // Right panel
          ctx.fillRect(x + w - panelWidth, y, panelWidth, h - toeKickH);
          // Top cabinet section
          ctx.fillRect(x, y, w, topCabinetH);

          // Draw cabinet door on top section
          drawCabinetDoor(ctx, x + fridgeCabPadding, y + fridgeCabPadding, w - fridgeCabPadding * 2, topCabinetH - fridgeCabPadding * 2, el.color);

          // Fridge opening (dark recess)
          ctx.fillStyle = '#1a1a1a';
          ctx.fillRect(x + panelWidth, y + topCabinetH, w - panelWidth * 2, fridgeOpeningH);

          // Fridge icon in opening
          ctx.fillStyle = '#888';
          const fridgeIconX = x + panelWidth + (w - panelWidth * 2) * 0.15;
          const fridgeIconY = y + topCabinetH + fridgeOpeningH * 0.1;
          const fridgeIconW = (w - panelWidth * 2) * 0.7;
          const fridgeIconH = fridgeOpeningH * 0.8;
          ctx.fillRect(fridgeIconX, fridgeIconY, fridgeIconW, fridgeIconH);
          // Fridge handle
          ctx.fillStyle = '#555';
          ctx.fillRect(fridgeIconX + fridgeIconW - 8, fridgeIconY + fridgeIconH * 0.2, 4, fridgeIconH * 0.3);
          ctx.fillRect(fridgeIconX + fridgeIconW - 8, fridgeIconY + fridgeIconH * 0.6, 4, fridgeIconH * 0.3);

          // Toe kick
          ctx.fillStyle = '#0d0d12';
          ctx.fillRect(x + panelWidth * 0.5, y + h - toeKickH, w - panelWidth, toeKickH);

          // Panel edges/shadows
          ctx.fillStyle = adjustColor(el.color, -25);
          ctx.fillRect(x + panelWidth - 2, y + topCabinetH, 2, fridgeOpeningH);
          ctx.fillRect(x + w - panelWidth, y + topCabinetH, 2, fridgeOpeningH);
          break;
        }

        case 'island':
          // Island with countertop overhang and cabinet base with toe kick
          const counterOverhang = 10; // Countertop overhangs the base
          const islandToeH = 6; // Toe kick height
          const islandToeRecess = 5; // Toe kick recessed from cabinet face

          // Cabinet base dimensions (inside the countertop overhang)
          const islandBaseX = x + counterOverhang;
          const islandBaseY = y + counterOverhang;
          const islandBaseW = w - counterOverhang * 2;
          const islandBaseH = h - counterOverhang * 2;

          // Cabinet body (above toe kick)
          const islandCabH = islandBaseH - islandToeH;

          // Draw toe kick recess FIRST (all 4 sides since island is accessible from all sides)
          ctx.fillStyle = '#0d0d12';
          // Front (bottom in Y)
          ctx.fillRect(islandBaseX + islandToeRecess, islandBaseY + islandCabH, islandBaseW - islandToeRecess * 2, islandToeH);
          // Back (top in Y)
          ctx.fillRect(islandBaseX + islandToeRecess, islandBaseY, islandBaseW - islandToeRecess * 2, islandToeH);
          // Left
          ctx.fillRect(islandBaseX, islandBaseY + islandToeRecess, islandToeH, islandBaseH - islandToeRecess * 2);
          // Right
          ctx.fillRect(islandBaseX + islandBaseW - islandToeH, islandBaseY + islandToeRecess, islandToeH, islandBaseH - islandToeRecess * 2);

          // Shadow lines at toe kick edges
          ctx.fillStyle = 'rgba(0,0,0,0.6)';
          ctx.fillRect(islandBaseX + islandToeRecess, islandBaseY + islandCabH, islandBaseW - islandToeRecess * 2, 2);
          ctx.fillRect(islandBaseX + islandToeRecess, islandBaseY + islandToeH - 2, islandBaseW - islandToeRecess * 2, 2);

          // Cabinet body (between toe kicks)
          const cabBodyX = islandBaseX + islandToeH;
          const cabBodyY = islandBaseY + islandToeH;
          const cabBodyW = islandBaseW - islandToeH * 2;
          const cabBodyH = islandCabH - islandToeH;

          // Cabinet base color
          ctx.fillStyle = adjustColor(el.color, -30);
          ctx.fillRect(cabBodyX, cabBodyY, cabBodyW, cabBodyH);

          // Draw cabinet doors on the cabinet body
          const islandDoorCount = Math.max(2, Math.floor(cabBodyW / (pixelsPerFoot * 1.2)));
          const islandDoorW = (cabBodyW - 8) / islandDoorCount;

          for (let i = 0; i < islandDoorCount; i++) {
            const idx = cabBodyX + 4 + i * islandDoorW;
            const idy = cabBodyY + 4;
            const idw = islandDoorW - 4;
            const idh = cabBodyH - 8;

            // Door panel
            ctx.fillStyle = adjustColor(el.color, -20);
            ctx.fillRect(idx, idy, idw, idh);

            // Shaker panel inset
            const inset = Math.min(8, idw * 0.1);
            ctx.strokeStyle = 'rgba(0,0,0,0.2)';
            ctx.lineWidth = 1;
            ctx.strokeRect(idx + inset, idy + inset, idw - inset * 2, idh - inset * 2);

            // Handle
            ctx.fillStyle = 'rgba(180,180,180,0.8)';
            ctx.fillRect(idx + idw - 8, idy + idh/2 - 8, 3, 16);
          }

          // Draw countertop surface LAST (on top, with overhang)
          if (!hasTexture) {
            drawCountertopSurface(ctx, x, y, w, h, el.color, el.materialName);
          } else {
            // Just edge highlights for textured countertop
            ctx.fillStyle = 'rgba(255,255,255,0.2)';
            ctx.fillRect(x, y, w, 3);
            ctx.fillRect(x, y, 3, h);
            ctx.fillStyle = 'rgba(0,0,0,0.25)';
            ctx.fillRect(x, y + h - 3, w, 3);
            ctx.fillRect(x + w - 3, y, 3, h);
          }

          break;

        case 'countertop':
          // Draw countertop with material-specific patterns (only if no texture)
          if (!hasTexture) {
            drawCountertopSurface(ctx, x, y, w, h, el.color, el.materialName);
          } else {
            // Just add edge profile for textured countertops
            ctx.fillStyle = 'rgba(255,255,255,0.15)';
            ctx.fillRect(x, y, w, 3);
            ctx.fillRect(x, y, 3, h);
            ctx.fillStyle = 'rgba(0,0,0,0.2)';
            ctx.fillRect(x, y + h - 3, w, 3);
            ctx.fillRect(x + w - 3, y, 3, h);
          }

          // Draw slab boundary indicators (show where standard slabs would end)
          // Only show when countertop is selected
          if (selectedElement && el.id === selectedElement.id) {
            const widthInches = el.width * 12;
            const maxSlabWidth = FABRICATION_STANDARDS?.seams?.maxSlabWidth || 120;

            // If countertop exceeds one slab width, show boundary markers
            if (widthInches > maxSlabWidth) {
              ctx.save();
              ctx.setLineDash([3, 6]);
              ctx.strokeStyle = 'rgba(59, 130, 246, 0.5)'; // Blue dashed lines
              ctx.lineWidth = 1;

              // Draw boundary lines at slab width intervals
              let boundaryPos = maxSlabWidth;
              while (boundaryPos < widthInches) {
                const boundaryX = x + (boundaryPos / widthInches) * w;
                ctx.beginPath();
                ctx.moveTo(boundaryX, y);
                ctx.lineTo(boundaryX, y + h);
                ctx.stroke();

                // Small label at top
                ctx.font = '9px sans-serif';
                ctx.fillStyle = 'rgba(59, 130, 246, 0.8)';
                ctx.fillText(`${boundaryPos}"`, boundaryX + 2, y + 10);

                boundaryPos += maxSlabWidth;
              }
              ctx.restore();
            }
          }

          // Draw seams if present
          if (el.seams && el.seams.length > 0) {
            el.seams.forEach(seam => {
              const seamX = x + w * seam.position;
              // Seam line (dashed)
              ctx.save();
              ctx.setLineDash([6, 4]);
              ctx.strokeStyle = '#dc3545';
              ctx.lineWidth = 2;
              ctx.beginPath();
              ctx.moveTo(seamX, y + 2);
              ctx.lineTo(seamX, y + h - 2);
              ctx.stroke();
              ctx.restore();

              // Seam marker (small diamond)
              ctx.fillStyle = '#dc3545';
              ctx.beginPath();
              ctx.moveTo(seamX, y - 6);
              ctx.lineTo(seamX + 5, y);
              ctx.lineTo(seamX, y + 6);
              ctx.lineTo(seamX - 5, y);
              ctx.closePath();
              ctx.fill();
            });
          }
          break;

        case 'countertop-l': {
          // L-shaped countertop - draw as actual L shape in 2D
          // Both arms are 2.2ft (26.4") wide - standard countertop depth
          const armWidthFt = el.armWidth || 2.17;
          const armDepth = armWidthFt * pixelsPerFoot;  // Horizontal arm depth
          const armWidth = armWidthFt * pixelsPerFoot;  // Vertical arm width

          // Cutout area is transparent (not drawn) - only the L-shape is filled

          // Draw L shape using path
          ctx.beginPath();
          ctx.moveTo(x, y);
          ctx.lineTo(x + w, y);
          ctx.lineTo(x + w, y + armDepth);
          ctx.lineTo(x + armWidth, y + armDepth);
          ctx.lineTo(x + armWidth, y + h);
          ctx.lineTo(x, y + h);
          ctx.closePath();

          // Fill with color or texture
          if (!hasTexture) {
            ctx.fillStyle = el.color || '#708090';
            ctx.fill();

            // Add stone-like speckle pattern
            ctx.fillStyle = 'rgba(255,255,255,0.15)';
            for (let i = 0; i < 30; i++) {
              const dotX = x + Math.random() * w;
              const dotY = y + Math.random() * h;
              // Only draw dot if it's in the L area
              if (dotY < y + armDepth || dotX < x + armWidth) {
                ctx.beginPath();
                ctx.arc(dotX, dotY, 1 + Math.random(), 0, Math.PI * 2);
                ctx.fill();
              }
            }
            ctx.fillStyle = 'rgba(0,0,0,0.1)';
            for (let i = 0; i < 20; i++) {
              const dotX = x + Math.random() * w;
              const dotY = y + Math.random() * h;
              if (dotY < y + armDepth || dotX < x + armWidth) {
                ctx.beginPath();
                ctx.arc(dotX, dotY, 1 + Math.random(), 0, Math.PI * 2);
                ctx.fill();
              }
            }
          } else {
            ctx.fill();
          }

          // Edge highlights
          ctx.strokeStyle = 'rgba(255,255,255,0.2)';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(x, y);
          ctx.lineTo(x + w, y);
          ctx.lineTo(x + w, y + armDepth);
          ctx.stroke();

          ctx.beginPath();
          ctx.moveTo(x, y);
          ctx.lineTo(x, y + h);
          ctx.lineTo(x + armWidth, y + h);
          ctx.stroke();

          // Shadow edges
          ctx.strokeStyle = 'rgba(0,0,0,0.25)';
          ctx.beginPath();
          ctx.moveTo(x + w, y + armDepth);
          ctx.lineTo(x + armWidth, y + armDepth);
          ctx.lineTo(x + armWidth, y + h);
          ctx.stroke();

          break;
        }

        case 'countertop-corner': {
          // Corner countertop - small square piece that sits in corner
          // Used to join two countertop runs at 90 degrees
          if (!hasTexture) {
            ctx.fillStyle = el.color || '#708090';
            ctx.fillRect(x, y, w, h);

            // Stone speckle pattern
            ctx.fillStyle = 'rgba(255,255,255,0.15)';
            for (let i = 0; i < 15; i++) {
              ctx.beginPath();
              ctx.arc(x + Math.random() * w, y + Math.random() * h, 1 + Math.random(), 0, Math.PI * 2);
              ctx.fill();
            }
            ctx.fillStyle = 'rgba(0,0,0,0.1)';
            for (let i = 0; i < 10; i++) {
              ctx.beginPath();
              ctx.arc(x + Math.random() * w, y + Math.random() * h, 1 + Math.random(), 0, Math.PI * 2);
              ctx.fill();
            }
          }

          // Edge profile
          ctx.fillStyle = 'rgba(255,255,255,0.2)';
          ctx.fillRect(x, y, w, 3);
          ctx.fillRect(x, y, 3, h);
          ctx.fillStyle = 'rgba(0,0,0,0.2)';
          ctx.fillRect(x, y + h - 3, w, 3);
          ctx.fillRect(x + w - 3, y, 3, h);

          // Seam indicator lines (shows where countertop runs join)
          ctx.strokeStyle = 'rgba(220, 53, 69, 0.5)';
          ctx.lineWidth = 1;
          ctx.setLineDash([4, 4]);
          // Seam on right edge
          ctx.beginPath();
          ctx.moveTo(x + w, y);
          ctx.lineTo(x + w, y + h);
          ctx.stroke();
          // Seam on bottom edge
          ctx.beginPath();
          ctx.moveTo(x, y + h);
          ctx.lineTo(x + w, y + h);
          ctx.stroke();
          ctx.setLineDash([]);

          break;
        }

        case 'surface-stainless':
          // Stainless steel with brushed effect
          ctx.fillStyle = '#C0C0C0';
          ctx.fillRect(x, y, w, h);
          // Brushed lines
          ctx.strokeStyle = 'rgba(255,255,255,0.3)';
          ctx.lineWidth = 1;
          for (let ly = y + 3; ly < y + h; ly += 4) {
            ctx.beginPath();
            ctx.moveTo(x + 2, ly);
            ctx.lineTo(x + w - 2, ly);
            ctx.stroke();
          }
          // Metallic highlight
          ctx.fillStyle = 'rgba(255,255,255,0.15)';
          ctx.fillRect(x, y, w, 4);
          ctx.fillRect(x, y, 4, h);
          // Shadow edge
          ctx.fillStyle = 'rgba(0,0,0,0.15)';
          ctx.fillRect(x, y + h - 3, w, 3);
          ctx.fillRect(x + w - 3, y, 3, h);
          break;

        case 'surface-solid':
          // Solid surface (Corian-style) - smooth matte
          ctx.fillStyle = el.color || '#E8E4E0';
          ctx.fillRect(x, y, w, h);
          // Subtle seamless look
          ctx.fillStyle = 'rgba(255,255,255,0.1)';
          ctx.fillRect(x + 1, y + 1, w - 2, 2);
          ctx.fillStyle = 'rgba(0,0,0,0.1)';
          ctx.fillRect(x + 1, y + h - 3, w - 2, 2);
          break;

        case 'surface-laminate':
          // Laminate/Formica with edge banding
          ctx.fillStyle = el.color || '#D4C4A8';
          ctx.fillRect(x, y, w, h);
          // Dark edge banding
          ctx.strokeStyle = '#4A4A4A';
          ctx.lineWidth = 2;
          ctx.strokeRect(x, y, w, h);
          // Subtle pattern if no texture
          if (!hasTexture) {
            ctx.fillStyle = 'rgba(0,0,0,0.03)';
            for (let px = x; px < x + w; px += 8) {
              ctx.fillRect(px, y, 4, h);
            }
          }
          break;

        case 'surface-butcherblock':
          // Butcher block with wood grain
          ctx.fillStyle = el.color || '#C4A76C';
          ctx.fillRect(x, y, w, h);
          // Wood strips
          ctx.strokeStyle = 'rgba(139,69,19,0.4)';
          ctx.lineWidth = 1;
          for (let sx = x + 6; sx < x + w; sx += 6) {
            ctx.beginPath();
            ctx.moveTo(sx, y + 2);
            ctx.lineTo(sx, y + h - 2);
            ctx.stroke();
          }
          // Highlights
          ctx.fillStyle = 'rgba(255,255,255,0.1)';
          ctx.fillRect(x, y, w, 3);
          break;

        case 'surface-concrete':
          // Concrete with industrial look
          ctx.fillStyle = el.color || '#808080';
          ctx.fillRect(x, y, w, h);
          // Aggregate texture spots
          ctx.fillStyle = 'rgba(0,0,0,0.1)';
          for (let i = 0; i < 20; i++) {
            const spotX = x + 5 + Math.random() * (w - 10);
            const spotY = y + 5 + Math.random() * (h - 10);
            ctx.beginPath();
            ctx.arc(spotX, spotY, 2 + Math.random() * 2, 0, Math.PI * 2);
            ctx.fill();
          }
          // Light aggregate
          ctx.fillStyle = 'rgba(255,255,255,0.1)';
          for (let i = 0; i < 15; i++) {
            const spotX = x + 5 + Math.random() * (w - 10);
            const spotY = y + 5 + Math.random() * (h - 10);
            ctx.beginPath();
            ctx.arc(spotX, spotY, 1 + Math.random() * 2, 0, Math.PI * 2);
            ctx.fill();
          }
          break;

        case 'backsplash':
          // If texture is loaded, just add subtle edge detail
          if (hasTexture) {
            ctx.strokeStyle = 'rgba(255,255,255,0.2)';
            ctx.lineWidth = 1;
            ctx.strokeRect(x + 1, y + 1, w - 2, h - 2);
            break;
          }

          // Draw backsplash with material-specific pattern
          const bsName = (el.materialName || '').toLowerCase();
          const bsSeed = Math.floor(x * 13 + y * 19) % 1000;
          const bsRand = (n) => ((bsSeed + n * 29) % 100) / 100;

          // Determine tile style from material name
          let tileStyle = 'subway'; // default
          if (bsName.includes('mosaic') || bsName.includes('penny')) {
            tileStyle = 'mosaic';
          } else if (bsName.includes('herringbone')) {
            tileStyle = 'herringbone';
          } else if (bsName.includes('hexagon') || bsName.includes('hex')) {
            tileStyle = 'hexagon';
          } else if (bsName.includes('arabesque') || bsName.includes('lantern')) {
            tileStyle = 'arabesque';
          } else if (bsName.includes('chevron')) {
            tileStyle = 'chevron';
          } else if (bsName.includes('marble') || bsName.includes('granite') || bsName.includes('quartz') || bsName.includes('slab')) {
            tileStyle = 'slab';
          }

          switch (tileStyle) {
            case 'subway':
              // Classic subway tile (3x6 ratio)
              const subwayH = Math.max(12, h / 4);
              const subwayW = subwayH * 2;
              let subwayRow = 0;

              for (let ty = y; ty < y + h; ty += subwayH) {
                const offset = (subwayRow % 2) * (subwayW / 2);
                for (let tx = x - offset; tx < x + w + subwayW; tx += subwayW) {
                  if (tx + subwayW > x && tx < x + w) {
                    const tileX = Math.max(tx, x);
                    const tileW = Math.min(tx + subwayW, x + w) - tileX;
                    const tileY = Math.max(ty, y);
                    const tileH = Math.min(ty + subwayH, y + h) - tileY;

                    // Tile face with subtle variation
                    const variation = (bsRand(tx + ty) - 0.5) * 10;
                    ctx.fillStyle = adjustColor(el.color, variation);
                    ctx.fillRect(tileX + 1, tileY + 1, tileW - 2, tileH - 2);

                    // Tile bevel highlight (top/left)
                    ctx.fillStyle = 'rgba(255,255,255,0.15)';
                    ctx.fillRect(tileX + 1, tileY + 1, tileW - 2, 2);
                    ctx.fillRect(tileX + 1, tileY + 1, 2, tileH - 2);

                    // Tile bevel shadow (bottom/right)
                    ctx.fillStyle = 'rgba(0,0,0,0.1)';
                    ctx.fillRect(tileX + 1, tileY + tileH - 3, tileW - 2, 2);
                    ctx.fillRect(tileX + tileW - 3, tileY + 1, 2, tileH - 2);
                  }
                }
                subwayRow++;
              }
              // Grout lines
              ctx.strokeStyle = 'rgba(100,100,100,0.4)';
              ctx.lineWidth = 1;
              ctx.strokeRect(x, y, w, h);
              break;

            case 'mosaic':
              // Small mosaic tiles
              const mosaicSize = Math.max(8, Math.min(w, h) / 8);
              for (let ty = y; ty < y + h; ty += mosaicSize) {
                for (let tx = x; tx < x + w; tx += mosaicSize) {
                  const variation = (bsRand(tx * 3 + ty * 7) - 0.5) * 20;
                  ctx.fillStyle = adjustColor(el.color, variation);
                  ctx.fillRect(tx + 0.5, ty + 0.5, mosaicSize - 1, mosaicSize - 1);

                  // Slight 3D effect
                  ctx.fillStyle = 'rgba(255,255,255,0.1)';
                  ctx.fillRect(tx + 0.5, ty + 0.5, mosaicSize - 1, 1);
                }
              }
              break;

            case 'herringbone':
              // Herringbone pattern
              const hbW = Math.max(8, w / 12);
              const hbH = hbW * 3;
              ctx.save();
              ctx.beginPath();
              ctx.rect(x, y, w, h);
              ctx.clip();

              for (let row = -2; row < h / (hbH/2) + 2; row++) {
                for (let col = -2; col < w / hbW + 2; col++) {
                  const isEven = (row + col) % 2 === 0;
                  const tx = x + col * hbW;
                  const ty = y + row * (hbH / 2);

                  ctx.save();
                  ctx.translate(tx + hbW/2, ty + hbH/4);
                  ctx.rotate(isEven ? Math.PI/4 : -Math.PI/4);

                  const variation = (bsRand(row * 5 + col * 11) - 0.5) * 15;
                  ctx.fillStyle = adjustColor(el.color, variation);
                  ctx.fillRect(-hbW/2 + 1, -hbH/4 + 1, hbW - 2, hbH/2 - 2);

                  ctx.restore();
                }
              }
              ctx.restore();
              break;

            case 'hexagon':
              // Hexagon tiles
              const hexR = Math.max(10, Math.min(w, h) / 6);
              const hexH = hexR * Math.sqrt(3);
              let hexRow = 0;

              for (let ty = y - hexH; ty < y + h + hexH; ty += hexH * 0.75) {
                const offset = (hexRow % 2) * (hexR * 1.5);
                for (let tx = x - hexR + offset; tx < x + w + hexR * 2; tx += hexR * 3) {
                  const variation = (bsRand(hexRow * 7 + tx) - 0.5) * 15;
                  ctx.fillStyle = adjustColor(el.color, variation);
                  ctx.beginPath();
                  for (let i = 0; i < 6; i++) {
                    const angle = (Math.PI / 3) * i - Math.PI / 6;
                    const hx = tx + hexR * Math.cos(angle);
                    const hy = ty + hexR * Math.sin(angle);
                    if (i === 0) ctx.moveTo(hx, hy);
                    else ctx.lineTo(hx, hy);
                  }
                  ctx.closePath();
                  ctx.fill();
                  ctx.strokeStyle = 'rgba(100,100,100,0.3)';
                  ctx.lineWidth = 1;
                  ctx.stroke();
                }
                hexRow++;
              }
              break;

            case 'slab':
              // Full slab (like matching countertop)
              drawCountertopSurface(ctx, x, y, w, h, el.color, el.materialName);
              break;

            default:
              // Default grid tiles
              const defTileSize = Math.max(15, Math.min(w, h) / 4);
              for (let ty = y; ty < y + h; ty += defTileSize) {
                for (let tx = x; tx < x + w; tx += defTileSize) {
                  const variation = (bsRand(tx + ty * 3) - 0.5) * 12;
                  ctx.fillStyle = adjustColor(el.color, variation);
                  ctx.fillRect(tx + 1, ty + 1, defTileSize - 2, defTileSize - 2);

                  ctx.fillStyle = 'rgba(255,255,255,0.1)';
                  ctx.fillRect(tx + 1, ty + 1, defTileSize - 2, 2);
                  ctx.fillRect(tx + 1, ty + 1, 2, defTileSize - 2);
                }
              }
          }
          break;

        case 'sink':
        case 'sink-double':
        case 'sink-farmhouse': {
          const isDouble = el.type === 'sink-double';
          const isFarmhouse = el.type === 'sink-farmhouse';
          const basinPadding = Math.min(w, h) * 0.12;

          // Outer rim
          ctx.strokeStyle = isFarmhouse ? 'rgba(200,180,140,0.8)' : 'rgba(180,180,180,0.8)';
          ctx.lineWidth = isFarmhouse ? 4 : 2;
          ctx.strokeRect(x + basinPadding/2, y + basinPadding/2, w - basinPadding, h - basinPadding);

          if (isDouble) {
            // Double basin
            const basinW = (w - basinPadding * 2 - 6) / 2;
            // Left basin
            ctx.fillStyle = 'rgba(60,60,60,0.4)';
            ctx.fillRect(x + basinPadding, y + basinPadding, basinW, h - basinPadding * 2);
            // Right basin
            ctx.fillRect(x + basinPadding + basinW + 6, y + basinPadding, basinW, h - basinPadding * 2);
            // Divider
            ctx.fillStyle = 'rgba(180,180,180,0.6)';
            ctx.fillRect(x + w/2 - 3, y + basinPadding, 6, h - basinPadding * 2);
            // Drains
            ctx.fillStyle = 'rgba(50,50,50,0.7)';
            ctx.beginPath();
            ctx.arc(x + basinPadding + basinW/2, y + h/2, Math.min(w, h) * 0.05, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x + w - basinPadding - basinW/2, y + h/2, Math.min(w, h) * 0.05, 0, Math.PI * 2);
            ctx.fill();
          } else {
            // Single basin
            ctx.fillStyle = isFarmhouse ? 'rgba(245,245,220,0.5)' : 'rgba(60,60,60,0.4)';
            ctx.fillRect(x + basinPadding, y + basinPadding, w - basinPadding * 2, h - basinPadding * 2);
            // Inner basin shadow
            ctx.fillStyle = isFarmhouse ? 'rgba(200,180,140,0.3)' : 'rgba(40,40,40,0.3)';
            ctx.fillRect(x + basinPadding + 4, y + basinPadding + 4, w - basinPadding * 2 - 8, h - basinPadding * 2 - 8);
            // Drain
            ctx.fillStyle = 'rgba(50,50,50,0.7)';
            ctx.beginPath();
            ctx.arc(x + w/2, y + h/2 + 5, Math.min(w, h) * 0.06, 0, Math.PI * 2);
            ctx.fill();
          }

          // Faucet (centered at back)
          ctx.fillStyle = 'rgba(200,200,200,0.9)';
          ctx.fillRect(x + w/2 - 8, y + basinPadding/2 - 6, 16, 8);
          // Faucet spout
          ctx.beginPath();
          ctx.arc(x + w/2, y + basinPadding/2 - 6, 8, Math.PI, 0);
          ctx.fill();
          // Handles
          ctx.fillStyle = 'rgba(180,180,180,0.8)';
          ctx.beginPath();
          ctx.arc(x + w/2 - 20, y + basinPadding/2, 5, 0, Math.PI * 2);
          ctx.fill();
          ctx.beginPath();
          ctx.arc(x + w/2 + 20, y + basinPadding/2, 5, 0, Math.PI * 2);
          ctx.fill();
          break;
        }

        case 'stove':
          // Draw stove burners
          ctx.strokeStyle = 'rgba(50,50,50,0.8)';
          ctx.lineWidth = 2;
          const burnerRadius = Math.min(w, h) * 0.15;
          const positions = [
            [x + w * 0.3, y + h * 0.35],
            [x + w * 0.7, y + h * 0.35],
            [x + w * 0.3, y + h * 0.7],
            [x + w * 0.7, y + h * 0.7]
          ];
          positions.forEach(([bx, by]) => {
            // Outer ring
            ctx.beginPath();
            ctx.arc(bx, by, burnerRadius, 0, Math.PI * 2);
            ctx.stroke();
            // Inner ring
            ctx.beginPath();
            ctx.arc(bx, by, burnerRadius * 0.6, 0, Math.PI * 2);
            ctx.stroke();
            // Grate lines
            ctx.beginPath();
            ctx.moveTo(bx - burnerRadius, by);
            ctx.lineTo(bx + burnerRadius, by);
            ctx.moveTo(bx, by - burnerRadius);
            ctx.lineTo(bx, by + burnerRadius);
            ctx.stroke();
          });
          // Control panel area
          ctx.fillStyle = 'rgba(40,40,40,0.5)';
          ctx.fillRect(x + padding, y + padding, w - padding * 2, h * 0.12);
          break;

        case 'refrigerator':
          // Draw refrigerator doors
          ctx.strokeStyle = 'rgba(150,150,150,0.5)';
          ctx.lineWidth = 2;
          const fridgeMid = y + h * 0.65;
          // Upper section (freezer)
          ctx.strokeRect(x + padding, y + padding, w - padding * 2, fridgeMid - y - padding * 1.5);
          // Lower section (fridge)
          ctx.strokeRect(x + padding, fridgeMid, w - padding * 2, y + h - fridgeMid - padding);
          // Handles
          ctx.fillStyle = 'rgba(200,200,200,0.6)';
          ctx.fillRect(x + w - padding - 6, y + (fridgeMid - y) / 2 - 12, 3, 24);
          ctx.fillRect(x + w - padding - 6, fridgeMid + (y + h - fridgeMid) / 2 - 15, 3, 30);
          // Ice dispenser
          ctx.fillStyle = 'rgba(60,60,60,0.4)';
          ctx.fillRect(x + w * 0.3, y + padding + 10, w * 0.4, 15);
          break;

        case 'dishwasher':
          // Draw dishwasher front
          ctx.strokeStyle = 'rgba(120,120,120,0.5)';
          ctx.lineWidth = 1.5;
          // Main door
          ctx.strokeRect(x + padding, y + padding, w - padding * 2, h - padding * 2);
          // Control panel
          ctx.fillStyle = 'rgba(60,60,60,0.4)';
          ctx.fillRect(x + padding + 4, y + padding + 4, w - padding * 2 - 8, h * 0.12);
          // Handle
          ctx.fillStyle = 'rgba(180,180,180,0.6)';
          ctx.fillRect(x + padding + 8, y + h * 0.18, w - padding * 2 - 16, 4);
          break;

        case 'flooring': {
          // Draw realistic wood plank flooring with grain direction support
          const grainDir = el.grainDirection || 0;
          const floorSeed = (el.x * 11 + el.y * 13) % 50;

          // Save context for rotation if needed
          ctx.save();

          // For diagonal directions, we'll use rotation
          if (grainDir === 45 || grainDir === 135) {
            // Clip to element bounds
            ctx.beginPath();
            ctx.rect(x, y, w, h);
            ctx.clip();

            // Rotate around center
            const cx = x + w / 2;
            const cy = y + h / 2;
            ctx.translate(cx, cy);
            ctx.rotate(grainDir * Math.PI / 180);
            ctx.translate(-cx, -cy);

            // Expand drawing area to cover after rotation
            const diagonal = Math.sqrt(w * w + h * h);
            const expandedX = cx - diagonal / 2;
            const expandedY = cy - diagonal / 2;
            const expandedW = diagonal;
            const expandedH = diagonal;

            drawPlanks(expandedX, expandedY, expandedW, expandedH, 0);
          } else if (grainDir === 90) {
            // Vertical planks - swap dimensions conceptually
            drawPlanks(x, y, w, h, 90);
          } else {
            // Horizontal planks (default)
            drawPlanks(x, y, w, h, 0);
          }

          ctx.restore();

          // Helper function to draw planks
          function drawPlanks(px, py, pw, ph, dir) {
            const plankLong = pixelsPerFoot * 2;
            const plankShort = pixelsPerFoot * 0.35;

            let rowNum = 0;
            if (dir === 90) {
              // Vertical planks
              for (let colX = px; colX < px + pw; colX += plankShort) {
                const colOffset = (rowNum % 3) * (plankLong / 3);
                let plankNum = 0;

                for (let rowY = py - colOffset; rowY < py + ph; rowY += plankLong) {
                  if (rowY + plankLong < py) continue;
                  if (rowY > py + ph) break;

                  const drawX = Math.max(colX, px);
                  const drawW = Math.min(colX + plankShort, px + pw) - drawX;
                  const drawY = Math.max(rowY, py);
                  const drawH = Math.min(rowY + plankLong, py + ph) - drawY;

                  if (drawW > 0 && drawH > 0) {
                    drawSinglePlank(drawX, drawY, drawW, drawH, rowNum, plankNum, true);
                  }
                  plankNum++;
                }
                rowNum++;
              }
            } else {
              // Horizontal planks
              for (let rowY = py; rowY < py + ph; rowY += plankShort) {
                const rowOffset = (rowNum % 3) * (plankLong / 3);
                let plankNum = 0;

                for (let colX = px - rowOffset; colX < px + pw; colX += plankLong) {
                  if (colX + plankLong < px) continue;
                  if (colX > px + pw) break;

                  const drawX = Math.max(colX, px);
                  const drawW = Math.min(colX + plankLong, px + pw) - drawX;
                  const drawY = Math.max(rowY, py);
                  const drawH = Math.min(rowY + plankShort, py + ph) - drawY;

                  if (drawW > 0 && drawH > 0) {
                    drawSinglePlank(drawX, drawY, drawW, drawH, rowNum, plankNum, false);
                  }
                  plankNum++;
                }
                rowNum++;
              }
            }
          }

          function drawSinglePlank(drawX, drawY, drawW, drawH, rowNum, plankNum, vertical) {
            // Plank base with slight color variation
            const variation = ((floorSeed + rowNum * 7 + plankNum * 3) % 20 - 10) / 100;
            ctx.fillStyle = `rgba(${variation > 0 ? 255 : 0},${variation > 0 ? 255 : 0},${variation > 0 ? 255 : 0},${Math.abs(variation)})`;
            ctx.fillRect(drawX, drawY, drawW, drawH);

            // Plank border (groove between planks)
            ctx.strokeStyle = 'rgba(0,0,0,0.2)';
            ctx.lineWidth = 1;
            ctx.strokeRect(drawX + 0.5, drawY + 0.5, drawW - 1, drawH - 1);

            // Wood grain lines
            ctx.strokeStyle = 'rgba(0,0,0,0.06)';
            ctx.lineWidth = 0.5;

            if (vertical) {
              // Vertical grain
              const grainCount = Math.floor(drawW / 4);
              for (let g = 0; g < grainCount; g++) {
                const gx = drawX + 2 + g * (drawW - 4) / Math.max(1, grainCount);
                const wave = Math.sin((floorSeed + plankNum + g) * 0.5) * 2;
                ctx.beginPath();
                ctx.moveTo(gx, drawY + 2);
                ctx.bezierCurveTo(
                  gx + wave, drawY + drawH * 0.3,
                  gx - wave, drawY + drawH * 0.7,
                  gx + wave * 0.5, drawY + drawH - 2
                );
                ctx.stroke();
              }
            } else {
              // Horizontal grain
              const grainCount = Math.floor(drawH / 4);
              for (let g = 0; g < grainCount; g++) {
                const gy = drawY + 2 + g * (drawH - 4) / Math.max(1, grainCount);
                const wave = Math.sin((floorSeed + plankNum + g) * 0.5) * 2;
                ctx.beginPath();
                ctx.moveTo(drawX + 2, gy);
                ctx.bezierCurveTo(
                  drawX + drawW * 0.3, gy + wave,
                  drawX + drawW * 0.7, gy - wave,
                  drawX + drawW - 2, gy + wave * 0.5
                );
                ctx.stroke();
              }
            }

            // Subtle knot marks occasionally
            if ((floorSeed + rowNum + plankNum) % 7 === 0) {
              ctx.fillStyle = 'rgba(0,0,0,0.08)';
              ctx.beginPath();
              ctx.ellipse(
                drawX + Math.abs(drawW) * 0.6,
                drawY + Math.abs(drawH) * 0.5,
                vertical ? 5 : 3, vertical ? 3 : 5, vertical ? 0.8 : 0.3, 0, Math.PI * 2
              );
              ctx.fill();
            }
          }
          break;
        }

        case 'tile': {
          // Draw realistic tile pattern with grout lines and variation
          // Supports diagonal orientation (45 or 135)
          const tileGrainDir = el.grainDirection || 0;
          const tileSz = Math.min(pixelsPerFoot * 0.5, Math.min(w, h) / 3);
          const groutWidth = 2;
          const tileSeed = (el.x * 17 + el.y * 23) % 100;

          ctx.save();

          // Clip to element bounds
          ctx.beginPath();
          ctx.rect(x, y, w, h);
          ctx.clip();

          // For diagonal tiles, rotate the pattern
          if (tileGrainDir === 45 || tileGrainDir === 135) {
            const cx = x + w / 2;
            const cy = y + h / 2;
            ctx.translate(cx, cy);
            ctx.rotate(tileGrainDir * Math.PI / 180);
            ctx.translate(-cx, -cy);

            // Expand drawing area to cover after rotation
            const diagonal = Math.sqrt(w * w + h * h);
            const expandX = cx - diagonal / 2;
            const expandY = cy - diagonal / 2;
            drawTileGrid(expandX, expandY, diagonal, diagonal);
          } else {
            drawTileGrid(x, y, w, h);
          }

          ctx.restore();

          function drawTileGrid(startX, startY, gridW, gridH) {
            // Draw tiles
            let tileRow = 0;
            for (let ty = startY; ty < startY + gridH; ty += tileSz) {
              let tileCol = 0;
              for (let tx = startX; tx < startX + gridW; tx += tileSz) {
                const tileW = tileSz - groutWidth;
                const tileH = tileSz - groutWidth;

                if (tileW > 0 && tileH > 0) {
                  // Subtle color variation per tile
                  const variation = ((tileSeed + tileRow * 5 + tileCol * 3) % 15) / 100;
                  ctx.fillStyle = `rgba(255,255,255,${0.02 + variation * 0.03})`;
                  ctx.fillRect(tx + 1, ty + 1, tileW, tileH);

                  // Tile surface texture (subtle speckling)
                  ctx.fillStyle = 'rgba(255,255,255,0.03)';
                  for (let s = 0; s < 3; s++) {
                    const sx = tx + 5 + ((tileSeed + tileCol + s * 7) % Math.max(1, tileW - 10));
                    const sy = ty + 5 + ((tileSeed + tileRow + s * 11) % Math.max(1, tileH - 10));
                    ctx.beginPath();
                    ctx.arc(sx, sy, 1, 0, Math.PI * 2);
                    ctx.fill();
                  }

                  // Light reflection on tile edge (top-left highlight)
                  ctx.fillStyle = 'rgba(255,255,255,0.08)';
                  ctx.fillRect(tx + 1, ty + 1, tileW, 1);
                  ctx.fillRect(tx + 1, ty + 1, 1, tileH);
                }
                tileCol++;
              }
              tileRow++;
            }

            // Grout lines (darker)
            ctx.strokeStyle = 'rgba(100,100,100,0.4)';
            ctx.lineWidth = groutWidth;
            for (let tx = startX; tx <= startX + gridW; tx += tileSz) {
              ctx.beginPath();
              ctx.moveTo(tx, startY);
              ctx.lineTo(tx, startY + gridH);
              ctx.stroke();
            }
            for (let ty = startY; ty <= startY + gridH; ty += tileSz) {
              ctx.beginPath();
              ctx.moveTo(startX, ty);
              ctx.lineTo(startX + gridW, ty);
              ctx.stroke();
            }
          }
          break;
        }

        case 'door':
          // Draw door with swing arc
          ctx.strokeStyle = 'rgba(255,255,255,0.4)';
          ctx.lineWidth = 1.5;
          // Door panel
          ctx.fillStyle = 'rgba(180,140,100,0.3)';
          ctx.fillRect(x, y, w * 0.1, h);
          // Swing arc
          ctx.beginPath();
          ctx.arc(x, y + h, w * 0.9, -Math.PI/2, 0);
          ctx.stroke();
          // Door line
          ctx.beginPath();
          ctx.moveTo(x, y + h);
          ctx.lineTo(x + w * 0.9, y + h);
          ctx.stroke();
          break;

        case 'window':
          // Draw window with transparent glass effect showing "outside"
          // Outer frame (white)
          ctx.strokeStyle = 'rgba(255,255,255,0.9)';
          ctx.lineWidth = 4;
          ctx.strokeRect(x + 2, y + 2, w - 4, h - 4);

          // Sky gradient background (simulated outdoor view)
          const skyGradient = ctx.createLinearGradient(x, y, x, y + h);
          skyGradient.addColorStop(0, 'rgba(135,206,250,0.7)'); // Light sky blue
          skyGradient.addColorStop(0.6, 'rgba(176,224,230,0.6)'); // Powder blue
          skyGradient.addColorStop(1, 'rgba(144,238,144,0.5)'); // Light green (trees/ground)
          ctx.fillStyle = skyGradient;
          ctx.fillRect(x + 6, y + 6, w - 12, h - 12);

          // Glass reflection effect (diagonal shine)
          ctx.strokeStyle = 'rgba(255,255,255,0.3)';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(x + w * 0.2, y + 4);
          ctx.lineTo(x + 4, y + h * 0.3);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(x + w * 0.35, y + 4);
          ctx.lineTo(x + 4, y + h * 0.5);
          ctx.stroke();

          // Center divider (mullion)
          ctx.strokeStyle = 'rgba(255,255,255,0.8)';
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.moveTo(x + w/2, y + 4);
          ctx.lineTo(x + w/2, y + h - 4);
          ctx.stroke();

          // Horizontal divider for classic look
          ctx.beginPath();
          ctx.moveTo(x + 4, y + h/2);
          ctx.lineTo(x + w - 4, y + h/2);
          ctx.stroke();
          break;

        case 'wall':
        case 'wall-wood-2x4':
        case 'wall-wood-2x6':
          // Wall section with hatch pattern
          ctx.strokeStyle = 'rgba(255,255,255,0.2)';
          ctx.lineWidth = 1;
          const step = 8;
          for (let i = 0; i < Math.max(w, h) * 2; i += step) {
            ctx.beginPath();
            ctx.moveTo(x + i, y);
            ctx.lineTo(x, y + i);
            ctx.stroke();
          }
          // Wood grain for wood walls
          if (type.includes('wood')) {
            ctx.strokeStyle = 'rgba(139,69,19,0.3)';
            ctx.lineWidth = 0.5;
            for (let g = 0; g < 3; g++) {
              ctx.beginPath();
              ctx.moveTo(x + g * w/3, y);
              ctx.lineTo(x + g * w/3, y + h);
              ctx.stroke();
            }
          }
          break;

        case 'wall-steel':
        case 'wall-aluminum':
          // Metal stud pattern
          ctx.strokeStyle = type.includes('steel') ? 'rgba(112,128,144,0.6)' : 'rgba(192,192,192,0.6)';
          ctx.lineWidth = 2;
          const studSpacing = pixelsPerFoot * 1.33; // 16" on center
          for (let sx = x; sx <= x + w; sx += studSpacing) {
            ctx.beginPath();
            ctx.moveTo(sx, y);
            ctx.lineTo(sx, y + h);
            ctx.stroke();
          }
          // Track at top and bottom
          ctx.fillStyle = type.includes('steel') ? 'rgba(112,128,144,0.4)' : 'rgba(192,192,192,0.4)';
          ctx.fillRect(x, y, w, 4);
          ctx.fillRect(x, y + h - 4, w, 4);
          break;

        case 'wall-concrete':
          // Concrete texture
          ctx.fillStyle = 'rgba(128,128,128,0.3)';
          ctx.fillRect(x, y, w, h);
          // Aggregate speckles
          ctx.fillStyle = 'rgba(100,100,100,0.4)';
          for (let i = 0; i < 10; i++) {
            const cx = x + (Math.random() * w);
            const cy = y + (Math.random() * h);
            ctx.beginPath();
            ctx.arc(cx, cy, Math.random() * 3 + 1, 0, Math.PI * 2);
            ctx.fill();
          }
          break;

        case 'wall-brick':
          // Brick pattern
          const brickH = pixelsPerFoot * 0.25;
          const brickW = pixelsPerFoot * 0.67;
          ctx.strokeStyle = 'rgba(139,69,19,0.5)';
          ctx.lineWidth = 1;
          let brickRow = 0;
          for (let by = y; by < y + h; by += brickH) {
            const offset = (brickRow % 2) * (brickW / 2);
            for (let bx = x - offset; bx < x + w; bx += brickW) {
              if (bx + brickW > x && bx < x + w) {
                ctx.strokeRect(Math.max(bx, x), by, Math.min(brickW, x + w - bx), brickH);
              }
            }
            brickRow++;
          }
          break;

        case 'wall-block':
          // CMU block pattern
          const blockH = pixelsPerFoot * 0.67;
          const blockW = pixelsPerFoot * 1.33;
          ctx.strokeStyle = 'rgba(80,80,80,0.5)';
          ctx.lineWidth = 2;
          let blockRow = 0;
          for (let by = y; by < y + h; by += blockH) {
            const offset = (blockRow % 2) * (blockW / 2);
            for (let bx = x - offset; bx < x + w; bx += blockW) {
              if (bx + blockW > x && bx < x + w) {
                ctx.strokeRect(Math.max(bx, x), by, Math.min(blockW, x + w - bx), blockH);
              }
            }
            blockRow++;
          }
          break;

        case 'steel-beam':
          // Steel I-Beam cross-section (horizontal beam)
          ctx.fillStyle = el.color || '#4A4A4A';
          ctx.fillRect(x, y, w, h);
          // Flange highlights
          ctx.fillStyle = 'rgba(255,255,255,0.15)';
          ctx.fillRect(x, y, w, h * 0.2);
          ctx.fillRect(x, y + h * 0.8, w, h * 0.2);
          // Web line
          ctx.strokeStyle = 'rgba(0,0,0,0.3)';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(x, y + h/2);
          ctx.lineTo(x + w, y + h/2);
          ctx.stroke();
          break;

        case 'steel-column':
          // Steel column (square HSS)
          ctx.fillStyle = el.color || '#4A4A4A';
          ctx.fillRect(x, y, w, h);
          // Highlight edges
          ctx.fillStyle = 'rgba(255,255,255,0.2)';
          ctx.fillRect(x, y, w * 0.2, h);
          ctx.fillStyle = 'rgba(0,0,0,0.2)';
          ctx.fillRect(x + w * 0.8, y, w * 0.2, h);
          // Center (hollow indicator)
          ctx.fillStyle = 'rgba(0,0,0,0.3)';
          ctx.fillRect(x + w * 0.25, y + h * 0.25, w * 0.5, h * 0.5);
          break;

        case 'wood-beam':
          // Wood beam (solid timber)
          ctx.fillStyle = el.color || '#8B6914';
          ctx.fillRect(x, y, w, h);
          // Wood grain lines
          ctx.strokeStyle = 'rgba(0,0,0,0.2)';
          ctx.lineWidth = 1;
          for (let gx = x + w * 0.2; gx < x + w; gx += w * 0.25) {
            ctx.beginPath();
            ctx.moveTo(gx, y);
            ctx.lineTo(gx, y + h);
            ctx.stroke();
          }
          // Highlight
          ctx.fillStyle = 'rgba(255,255,255,0.1)';
          ctx.fillRect(x, y, w, h * 0.15);
          break;

        case 'wood-post':
          // Wood post (4x4 or 6x6)
          ctx.fillStyle = el.color || '#8B6914';
          ctx.fillRect(x, y, w, h);
          // Wood grain
          ctx.strokeStyle = 'rgba(0,0,0,0.15)';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(x + w * 0.3, y);
          ctx.lineTo(x + w * 0.3, y + h);
          ctx.moveTo(x + w * 0.5, y);
          ctx.lineTo(x + w * 0.5, y + h);
          ctx.moveTo(x + w * 0.7, y);
          ctx.lineTo(x + w * 0.7, y + h);
          ctx.stroke();
          break;

        case 'concrete-beam':
          // Concrete beam
          ctx.fillStyle = el.color || '#707070';
          ctx.fillRect(x, y, w, h);
          // Aggregate texture
          ctx.fillStyle = 'rgba(0,0,0,0.15)';
          for (let i = 0; i < 8; i++) {
            const cx = x + Math.random() * w;
            const cy = y + Math.random() * h;
            ctx.beginPath();
            ctx.arc(cx, cy, 2 + Math.random() * 3, 0, Math.PI * 2);
            ctx.fill();
          }
          // Form line
          ctx.strokeStyle = 'rgba(0,0,0,0.2)';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(x, y + h/2);
          ctx.lineTo(x + w, y + h/2);
          ctx.stroke();
          break;

        case 'concrete-column':
          // Concrete column
          ctx.fillStyle = el.color || '#707070';
          ctx.fillRect(x, y, w, h);
          // Aggregate spots
          ctx.fillStyle = 'rgba(0,0,0,0.12)';
          for (let i = 0; i < 6; i++) {
            const cx = x + w * 0.15 + Math.random() * w * 0.7;
            const cy = y + h * 0.15 + Math.random() * h * 0.7;
            ctx.beginPath();
            ctx.arc(cx, cy, 2 + Math.random() * 2, 0, Math.PI * 2);
            ctx.fill();
          }
          // Chamfer indicators at corners
          ctx.strokeStyle = 'rgba(0,0,0,0.3)';
          ctx.lineWidth = 2;
          const chamfer = Math.min(w, h) * 0.1;
          ctx.beginPath();
          ctx.moveTo(x, y + chamfer);
          ctx.lineTo(x + chamfer, y);
          ctx.moveTo(x + w - chamfer, y);
          ctx.lineTo(x + w, y + chamfer);
          ctx.moveTo(x + w, y + h - chamfer);
          ctx.lineTo(x + w - chamfer, y + h);
          ctx.moveTo(x + chamfer, y + h);
          ctx.lineTo(x, y + h - chamfer);
          ctx.stroke();
          break;

        case 'header':
          // Header/Lintel
          ctx.fillStyle = el.color || '#CD853F';
          ctx.fillRect(x, y, w, h);
          // Wood grain
          ctx.strokeStyle = 'rgba(0,0,0,0.2)';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(x, y + h/2);
          ctx.lineTo(x + w, y + h/2);
          ctx.stroke();
          // Highlight
          ctx.fillStyle = 'rgba(255,255,255,0.15)';
          ctx.fillRect(x, y, w, h * 0.2);
          break;

        case 'lvl-beam':
          // LVL (Laminated Veneer Lumber) beam
          ctx.fillStyle = el.color || '#DEB887';
          ctx.fillRect(x, y, w, h);
          // Lamination lines
          ctx.strokeStyle = 'rgba(139,105,20,0.3)';
          ctx.lineWidth = 1;
          const lamSpacing = Math.max(4, h / 8);
          for (let ly = y + lamSpacing; ly < y + h; ly += lamSpacing) {
            ctx.beginPath();
            ctx.moveTo(x, ly);
            ctx.lineTo(x + w, ly);
            ctx.stroke();
          }
          break;

        case 'double-door':
          // Double door with two panels
          ctx.strokeStyle = 'rgba(255,255,255,0.4)';
          ctx.lineWidth = 1.5;
          ctx.fillStyle = 'rgba(180,140,100,0.3)';
          // Left door
          ctx.fillRect(x, y, w * 0.05, h);
          ctx.beginPath();
          ctx.arc(x, y + h, w * 0.45, -Math.PI/2, 0);
          ctx.stroke();
          // Right door
          ctx.fillRect(x + w * 0.95, y, w * 0.05, h);
          ctx.beginPath();
          ctx.arc(x + w, y + h, w * 0.45, Math.PI, -Math.PI/2);
          ctx.stroke();
          break;

        case 'sliding-door':
          // Sliding glass door with outdoor view
          // Outdoor background (green/blue gradient)
          const slidingGrad = ctx.createLinearGradient(x, y, x, y + h);
          slidingGrad.addColorStop(0, 'rgba(135,206,235,0.4)'); // Sky blue
          slidingGrad.addColorStop(0.6, 'rgba(135,206,235,0.3)');
          slidingGrad.addColorStop(0.6, 'rgba(144,238,144,0.3)'); // Light green
          slidingGrad.addColorStop(1, 'rgba(34,139,34,0.3)'); // Forest green
          ctx.fillStyle = slidingGrad;
          ctx.fillRect(x, y, w, h);
          ctx.strokeStyle = 'rgba(100,100,100,0.6)';
          ctx.lineWidth = 2;
          ctx.strokeRect(x, y, w, h);
          // Sliding panels
          ctx.strokeStyle = 'rgba(80,80,80,0.5)';
          ctx.beginPath();
          ctx.moveTo(x + w/2, y);
          ctx.lineTo(x + w/2, y + h);
          ctx.stroke();
          // Arrow indicating slide direction
          ctx.fillStyle = 'rgba(255,255,255,0.6)';
          ctx.beginPath();
          ctx.moveTo(x + w * 0.35, y + h/2);
          ctx.lineTo(x + w * 0.25, y + h/2 - 5);
          ctx.lineTo(x + w * 0.25, y + h/2 + 5);
          ctx.fill();
          break;

        case 'glass-door':
          // Single glass door with outdoor view
          const glassDoorGrad = ctx.createLinearGradient(x, y, x, y + h);
          glassDoorGrad.addColorStop(0, 'rgba(135,206,235,0.35)');
          glassDoorGrad.addColorStop(0.65, 'rgba(135,206,235,0.25)');
          glassDoorGrad.addColorStop(0.65, 'rgba(144,238,144,0.25)');
          glassDoorGrad.addColorStop(1, 'rgba(34,139,34,0.25)');
          ctx.fillStyle = glassDoorGrad;
          ctx.fillRect(x, y, w, h);
          // Frame
          ctx.strokeStyle = 'rgba(255,255,255,0.9)';
          ctx.lineWidth = 3;
          ctx.strokeRect(x, y, w, h);
          // Handle
          ctx.fillStyle = 'rgba(200,200,200,0.8)';
          ctx.fillRect(x + w - 10, y + h/2 - 15, 5, 30);
          break;

        case 'french-door':
          // French door with grid and outdoor view
          const frenchDoorGrad = ctx.createLinearGradient(x, y, x, y + h);
          frenchDoorGrad.addColorStop(0, 'rgba(135,206,235,0.35)');
          frenchDoorGrad.addColorStop(0.6, 'rgba(135,206,235,0.25)');
          frenchDoorGrad.addColorStop(0.6, 'rgba(144,238,144,0.25)');
          frenchDoorGrad.addColorStop(1, 'rgba(34,139,34,0.3)');
          ctx.fillStyle = frenchDoorGrad;
          ctx.fillRect(x, y, w, h);
          // Frame
          ctx.strokeStyle = 'rgba(245,245,220,0.9)';
          ctx.lineWidth = 4;
          ctx.strokeRect(x, y, w, h);
          // Center divider
          ctx.beginPath();
          ctx.moveTo(x + w/2, y);
          ctx.lineTo(x + w/2, y + h);
          ctx.stroke();
          // Grid lines
          ctx.lineWidth = 1.5;
          for (let gy = 1; gy < 4; gy++) {
            ctx.beginPath();
            ctx.moveTo(x, y + gy * h/4);
            ctx.lineTo(x + w, y + gy * h/4);
            ctx.stroke();
          }
          break;

        case 'window-large':
          // Large picture window
          const pictureWinGrad = ctx.createLinearGradient(x, y, x, y + h);
          pictureWinGrad.addColorStop(0, 'rgba(135,206,250,0.5)');
          pictureWinGrad.addColorStop(0.55, 'rgba(135,206,250,0.4)');
          pictureWinGrad.addColorStop(0.55, 'rgba(144,238,144,0.35)');
          pictureWinGrad.addColorStop(1, 'rgba(34,139,34,0.4)');
          ctx.fillStyle = pictureWinGrad;
          ctx.fillRect(x, y, w, h);
          // White frame
          ctx.strokeStyle = 'rgba(255,255,255,0.95)';
          ctx.lineWidth = 4;
          ctx.strokeRect(x, y, w, h);
          break;

        case 'window-bay':
          // Bay window (angled trapezoid shape)
          const bayDepth = h * 0.3;
          const bayGrad = ctx.createLinearGradient(x, y, x, y + h);
          bayGrad.addColorStop(0, 'rgba(135,206,250,0.45)');
          bayGrad.addColorStop(0.5, 'rgba(135,206,250,0.35)');
          bayGrad.addColorStop(0.5, 'rgba(144,238,144,0.3)');
          bayGrad.addColorStop(1, 'rgba(34,139,34,0.35)');
          ctx.fillStyle = bayGrad;
          // Draw trapezoid shape
          ctx.beginPath();
          ctx.moveTo(x + bayDepth, y);
          ctx.lineTo(x + w - bayDepth, y);
          ctx.lineTo(x + w, y + h);
          ctx.lineTo(x, y + h);
          ctx.closePath();
          ctx.fill();
          // Frame
          ctx.strokeStyle = 'rgba(255,255,255,0.9)';
          ctx.lineWidth = 3;
          ctx.stroke();
          // Interior lines for panes
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(x + w * 0.33, y + h * 0.1);
          ctx.lineTo(x + w * 0.25, y + h);
          ctx.moveTo(x + w * 0.67, y + h * 0.1);
          ctx.lineTo(x + w * 0.75, y + h);
          ctx.stroke();
          break;

        case 'entry-archway':
          // Archway opening - shows as a transparent passthrough
          // Supports multiple arch styles: round, pointed, flat, elliptical
          const archFrameWidth = Math.max(4, w * 0.08);
          const archStyle2D = el.archwayStyle || 'round';

          // Calculate arch-specific proportions
          let archTopY, archCurveHeight;
          if (archStyle2D === 'flat') {
            archTopY = y + archFrameWidth * 2;
            archCurveHeight = 0;
          } else if (archStyle2D === 'pointed') {
            archTopY = y;
            archCurveHeight = h * 0.4;
          } else if (archStyle2D === 'elliptical') {
            archTopY = y + h * 0.15;
            archCurveHeight = h * 0.2;
          } else { // round
            archTopY = y + h * 0.3;
            archCurveHeight = h * 0.3;
          }

          // Draw "through" view - darker to simulate depth/another room
          ctx.fillStyle = 'rgba(60,60,70,0.4)';
          ctx.beginPath();
          ctx.moveTo(x + archFrameWidth, y + h);
          if (archStyle2D === 'flat') {
            ctx.lineTo(x + archFrameWidth, archTopY);
            ctx.lineTo(x + w - archFrameWidth, archTopY);
          } else if (archStyle2D === 'pointed') {
            ctx.lineTo(x + archFrameWidth, y + h * 0.35);
            ctx.lineTo(x + w/2, archTopY + archFrameWidth);
            ctx.lineTo(x + w - archFrameWidth, y + h * 0.35);
          } else if (archStyle2D === 'elliptical') {
            ctx.lineTo(x + archFrameWidth, archTopY + archCurveHeight);
            ctx.quadraticCurveTo(x + w/2, archTopY, x + w - archFrameWidth, archTopY + archCurveHeight);
          } else { // round
            ctx.lineTo(x + archFrameWidth, y + h * 0.35);
            ctx.quadraticCurveTo(x + w/2, y + archFrameWidth, x + w - archFrameWidth, y + h * 0.35);
          }
          ctx.lineTo(x + w - archFrameWidth, y + h);
          ctx.closePath();
          ctx.fill();

          // Inner shadow for depth
          ctx.fillStyle = 'rgba(40,40,50,0.3)';
          ctx.beginPath();
          ctx.moveTo(x + archFrameWidth, y + h);
          if (archStyle2D === 'flat') {
            ctx.lineTo(x + archFrameWidth, archTopY);
            ctx.lineTo(x + archFrameWidth + 8, archTopY + 3);
          } else if (archStyle2D === 'pointed') {
            ctx.lineTo(x + archFrameWidth, y + h * 0.35);
            ctx.lineTo(x + archFrameWidth + 8, y + h * 0.38);
          } else {
            ctx.lineTo(x + archFrameWidth, y + h * 0.35);
            ctx.lineTo(x + archFrameWidth + 8, y + h * 0.38);
          }
          ctx.lineTo(x + archFrameWidth + 8, y + h);
          ctx.closePath();
          ctx.fill();

          // Arch frame (outer edge - golden/wood color)
          ctx.strokeStyle = 'rgba(218,165,32,0.9)';
          ctx.lineWidth = archFrameWidth;
          ctx.beginPath();
          ctx.moveTo(x + archFrameWidth/2, y + h);
          if (archStyle2D === 'flat') {
            ctx.lineTo(x + archFrameWidth/2, archTopY - archFrameWidth/2);
            ctx.lineTo(x + w - archFrameWidth/2, archTopY - archFrameWidth/2);
          } else if (archStyle2D === 'pointed') {
            ctx.lineTo(x + archFrameWidth/2, y + h * 0.3);
            ctx.lineTo(x + w/2, y);
            ctx.lineTo(x + w - archFrameWidth/2, y + h * 0.3);
          } else if (archStyle2D === 'elliptical') {
            const ellipseY = archTopY + archCurveHeight * 0.5;
            ctx.lineTo(x + archFrameWidth/2, ellipseY);
            ctx.quadraticCurveTo(x + w/2, y - archFrameWidth, x + w - archFrameWidth/2, ellipseY);
          } else { // round
            ctx.lineTo(x + archFrameWidth/2, y + h * 0.3);
            ctx.quadraticCurveTo(x + w/2, y, x + w - archFrameWidth/2, y + h * 0.3);
          }
          ctx.lineTo(x + w - archFrameWidth/2, y + h);
          ctx.stroke();

          // Inner edge highlight
          ctx.strokeStyle = 'rgba(255,235,180,0.5)';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(x + archFrameWidth, y + h);
          if (archStyle2D === 'flat') {
            ctx.lineTo(x + archFrameWidth, archTopY);
            ctx.lineTo(x + w - archFrameWidth, archTopY);
          } else if (archStyle2D === 'pointed') {
            ctx.lineTo(x + archFrameWidth, y + h * 0.35);
            ctx.lineTo(x + w/2, archTopY + archFrameWidth);
            ctx.lineTo(x + w - archFrameWidth, y + h * 0.35);
          } else if (archStyle2D === 'elliptical') {
            ctx.lineTo(x + archFrameWidth, archTopY + archCurveHeight);
            ctx.quadraticCurveTo(x + w/2, archTopY, x + w - archFrameWidth, archTopY + archCurveHeight);
          } else { // round
            ctx.lineTo(x + archFrameWidth, y + h * 0.35);
            ctx.quadraticCurveTo(x + w/2, y + archFrameWidth, x + w - archFrameWidth, y + h * 0.35);
          }
          ctx.lineTo(x + w - archFrameWidth, y + h);
          ctx.stroke();
          break;

        case 'garage-door':
          // Garage door with sections
          ctx.fillStyle = 'rgba(169,169,169,0.4)';
          ctx.fillRect(x, y, w, h);
          ctx.strokeStyle = 'rgba(100,100,100,0.6)';
          ctx.lineWidth = 2;
          ctx.strokeRect(x, y, w, h);
          // Panel sections
          const panelH = h / 4;
          for (let py = y + panelH; py < y + h; py += panelH) {
            ctx.beginPath();
            ctx.moveTo(x, py);
            ctx.lineTo(x + w, py);
            ctx.stroke();
          }
          // Handle
          ctx.fillStyle = 'rgba(80,80,80,0.6)';
          ctx.fillRect(x + w/2 - 10, y + h - panelH/2 - 3, 20, 6);
          break;

        case 'corner-cabinet': {
          // CORNER CABINET - L-shaped with diagonal door and lazy susan cutout
          // Plan view (top-down): corner at top-left, 24" depth arms, opening faces bottom-right
          const ccArmD = pixelsPerFoot * 2; // 24" standard cabinet depth for each arm
          const ccInnerW = w - ccArmD; // exposed portion of bottom arm
          const ccInnerH = h - ccArmD; // exposed portion of right arm

          // L-shape cabinet body
          ctx.fillStyle = el.color;
          ctx.beginPath();
          ctx.moveTo(x, y);
          ctx.lineTo(x + w, y);
          ctx.lineTo(x + w, y + ccArmD);
          ctx.lineTo(x + ccArmD, y + ccArmD);
          ctx.lineTo(x + ccArmD, y + h);
          ctx.lineTo(x, y + h);
          ctx.closePath();
          ctx.fill();

          // Dark interior in corner overlap area
          ctx.fillStyle = 'rgba(20,20,25,0.5)';
          ctx.fillRect(x + 2, y + 2, ccArmD - 4, ccArmD - 4);

          // Lazy susan cutout circle in corner junction
          const ccLsRadius = Math.min(ccArmD, ccArmD) * 0.38;
          const ccLsCx = x + ccArmD * 0.5;
          const ccLsCy = y + ccArmD * 0.5;

          ctx.fillStyle = 'rgba(180,160,120,0.3)';
          ctx.beginPath();
          ctx.arc(ccLsCx, ccLsCy, ccLsRadius, 0, Math.PI * 2);
          ctx.fill();
          ctx.strokeStyle = 'rgba(0,0,0,0.15)';
          ctx.lineWidth = 1;
          ctx.stroke();

          // Center pivot dot
          ctx.fillStyle = '#A0A0A0';
          ctx.beginPath();
          ctx.arc(ccLsCx, ccLsCy, 2.5, 0, Math.PI * 2);
          ctx.fill();

          // Diagonal door line from inner corner to opposite arm ends
          ctx.strokeStyle = 'rgba(0,0,0,0.35)';
          ctx.lineWidth = 1.5;
          ctx.beginPath();
          ctx.moveTo(x + ccArmD, y + h);
          ctx.lineTo(x + w, y + ccArmD);
          ctx.stroke();

          // Door on bottom arm (front-facing)
          const ccBotDoorY = y + ccArmD + 3;
          const ccBotDoorH = h - ccArmD - 6;
          const ccBotDoorW = ccArmD - 6;
          if (ccBotDoorH > 8) {
            ctx.fillStyle = el.color;
            ctx.fillRect(x + 3, ccBotDoorY, ccBotDoorW, ccBotDoorH);
            ctx.strokeStyle = 'rgba(0,0,0,0.2)';
            ctx.lineWidth = 1;
            ctx.strokeRect(x + 3.5, ccBotDoorY + 0.5, ccBotDoorW - 1, ccBotDoorH - 1);
            const ccPanelInset = Math.min(8, ccBotDoorW * 0.12);
            ctx.strokeStyle = 'rgba(0,0,0,0.12)';
            ctx.strokeRect(x + 3 + ccPanelInset, ccBotDoorY + ccPanelInset, ccBotDoorW - ccPanelInset * 2, ccBotDoorH - ccPanelInset * 2);
            ctx.fillStyle = 'rgba(0,0,0,0.04)';
            ctx.fillRect(x + 3 + ccPanelInset + 1, ccBotDoorY + ccPanelInset + 1, ccBotDoorW - ccPanelInset * 2 - 2, ccBotDoorH - ccPanelInset * 2 - 2);
            // Handle
            ctx.fillStyle = '#C0C0C0';
            ctx.fillRect(x + 3 + ccBotDoorW - 7, ccBotDoorY + ccBotDoorH / 2 - 8, 3, 16);
          }

          // Door on right arm (front-facing)
          const ccRightDoorX = x + ccArmD + 3;
          const ccRightDoorW = w - ccArmD - 6;
          const ccRightDoorH = ccArmD - 6;
          if (ccRightDoorW > 8) {
            ctx.fillStyle = el.color;
            ctx.fillRect(ccRightDoorX, y + 3, ccRightDoorW, ccRightDoorH);
            ctx.strokeStyle = 'rgba(0,0,0,0.2)';
            ctx.lineWidth = 1;
            ctx.strokeRect(ccRightDoorX + 0.5, y + 3.5, ccRightDoorW - 1, ccRightDoorH - 1);
            const ccPanelInset2 = Math.min(8, ccRightDoorH * 0.12);
            ctx.strokeStyle = 'rgba(0,0,0,0.12)';
            ctx.strokeRect(ccRightDoorX + ccPanelInset2, y + 3 + ccPanelInset2, ccRightDoorW - ccPanelInset2 * 2, ccRightDoorH - ccPanelInset2 * 2);
            ctx.fillStyle = 'rgba(0,0,0,0.04)';
            ctx.fillRect(ccRightDoorX + ccPanelInset2 + 1, y + 3 + ccPanelInset2 + 1, ccRightDoorW - ccPanelInset2 * 2 - 2, ccRightDoorH - ccPanelInset2 * 2 - 2);
            // Handle
            ctx.fillStyle = '#C0C0C0';
            ctx.fillRect(ccRightDoorX + ccRightDoorW / 2 - 8, y + 3 + ccRightDoorH - 7, 16, 3);
          }

          // Cabinet outline
          ctx.strokeStyle = 'rgba(0,0,0,0.25)';
          ctx.lineWidth = 1.5;
          ctx.beginPath();
          ctx.moveTo(x, y);
          ctx.lineTo(x + w, y);
          ctx.lineTo(x + w, y + ccArmD);
          ctx.lineTo(x + ccArmD, y + ccArmD);
          ctx.lineTo(x + ccArmD, y + h);
          ctx.lineTo(x, y + h);
          ctx.closePath();
          ctx.stroke();
          break;
        }

        case 'microwave':
          // Draw microwave front
          ctx.strokeStyle = 'rgba(100,100,100,0.6)';
          ctx.lineWidth = 1.5;
          // Door frame
          ctx.strokeRect(x + padding, y + padding, w * 0.75 - padding, h - padding * 2);
          // Glass window
          ctx.fillStyle = 'rgba(20,20,20,0.4)';
          ctx.fillRect(x + padding + 4, y + padding + 4, w * 0.75 - padding - 8, h - padding * 2 - 8);
          // Control panel
          ctx.fillStyle = 'rgba(60,60,60,0.5)';
          ctx.fillRect(x + w * 0.78, y + padding, w * 0.2 - padding, h - padding * 2);
          // Buttons
          ctx.fillStyle = 'rgba(100,100,100,0.6)';
          for (let i = 0; i < 3; i++) {
            ctx.fillRect(x + w * 0.82, y + padding + 8 + i * 12, 8, 8);
          }
          // Handle
          ctx.fillStyle = 'rgba(180,180,180,0.6)';
          ctx.fillRect(x + w * 0.72, y + h/2 - 10, 3, 20);
          break;

        case 'range-hood':
          // Draw range hood (trapezoidal shape from above)
          ctx.strokeStyle = 'rgba(120,120,120,0.6)';
          ctx.lineWidth = 2;
          // Outer shape
          ctx.beginPath();
          ctx.moveTo(x + padding, y + h - padding);
          ctx.lineTo(x + w * 0.2, y + padding);
          ctx.lineTo(x + w * 0.8, y + padding);
          ctx.lineTo(x + w - padding, y + h - padding);
          ctx.closePath();
          ctx.stroke();
          // Filter lines
          ctx.strokeStyle = 'rgba(150,150,150,0.4)';
          ctx.lineWidth = 1;
          const filterLines = 4;
          for (let i = 1; i < filterLines; i++) {
            const yPos = y + padding + (h - padding * 2) * (i / filterLines);
            ctx.beginPath();
            ctx.moveTo(x + w * 0.25, yPos);
            ctx.lineTo(x + w * 0.75, yPos);
            ctx.stroke();
          }
          // Vent duct indicator
          ctx.fillStyle = 'rgba(80,80,80,0.4)';
          ctx.beginPath();
          ctx.arc(x + w/2, y + h * 0.3, Math.min(w, h) * 0.12, 0, Math.PI * 2);
          ctx.fill();
          break;

        case 'oven':
          // Draw wall oven
          ctx.strokeStyle = 'rgba(100,100,100,0.5)';
          ctx.lineWidth = 1.5;
          // Outer frame
          ctx.strokeRect(x + padding, y + padding, w - padding * 2, h - padding * 2);
          // Glass window
          ctx.fillStyle = 'rgba(30,30,30,0.5)';
          ctx.fillRect(x + padding + 6, y + h * 0.25, w - padding * 2 - 12, h * 0.5);
          // Window reflection
          ctx.strokeStyle = 'rgba(255,255,255,0.15)';
          ctx.beginPath();
          ctx.moveTo(x + padding + 10, y + h * 0.3);
          ctx.lineTo(x + w - padding - 20, y + h * 0.3);
          ctx.stroke();
          // Control panel
          ctx.fillStyle = 'rgba(50,50,50,0.6)';
          ctx.fillRect(x + padding + 6, y + padding + 4, w - padding * 2 - 12, h * 0.12);
          // Control knobs
          ctx.fillStyle = 'rgba(120,120,120,0.7)';
          const knobCount = 4;
          for (let i = 0; i < knobCount; i++) {
            const kx = x + padding + 15 + i * (w - padding * 2 - 30) / (knobCount - 1);
            ctx.beginPath();
            ctx.arc(kx, y + padding + 10, 4, 0, Math.PI * 2);
            ctx.fill();
          }
          // Handle
          ctx.fillStyle = 'rgba(180,180,180,0.6)';
          ctx.fillRect(x + w * 0.3, y + h * 0.78, w * 0.4, 3);
          break;

        case 'crown-molding':
          // Crown molding - ornate profile along wall
          ctx.fillStyle = el.color || '#F5F5F5';
          ctx.fillRect(x, y, w, h);
          // Ornate shadow lines
          ctx.strokeStyle = 'rgba(0,0,0,0.2)';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(x, y + h * 0.3);
          ctx.lineTo(x + w, y + h * 0.3);
          ctx.moveTo(x, y + h * 0.6);
          ctx.lineTo(x + w, y + h * 0.6);
          ctx.stroke();
          // Top highlight
          ctx.strokeStyle = 'rgba(255,255,255,0.5)';
          ctx.beginPath();
          ctx.moveTo(x, y + 2);
          ctx.lineTo(x + w, y + 2);
          ctx.stroke();
          // Label
          ctx.fillStyle = 'rgba(0,0,0,0.4)';
          ctx.font = '8px Inter';
          ctx.fillText('Crown', x + 4, y + h - 3);
          break;

        case 'baseboard':
          // Baseboard molding along floor - shadow in FRONT (inside room)
          // First draw shadow (offset outward into room)
          ctx.fillStyle = 'rgba(0,0,0,0.15)';
          ctx.fillRect(x + 2, y + h, w, 4); // Shadow extends into room (below baseboard in plan view)
          // Main baseboard body
          ctx.fillStyle = el.color || '#F5F5F5';
          ctx.fillRect(x, y, w, h);
          // Profile detail lines
          ctx.strokeStyle = 'rgba(0,0,0,0.15)';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(x, y + h * 0.2);
          ctx.lineTo(x + w, y + h * 0.2);
          ctx.moveTo(x, y + h * 0.5);
          ctx.lineTo(x + w, y + h * 0.5);
          ctx.stroke();
          // Top highlight
          ctx.strokeStyle = 'rgba(255,255,255,0.3)';
          ctx.beginPath();
          ctx.moveTo(x, y + 1);
          ctx.lineTo(x + w, y + 1);
          ctx.stroke();
          break;

        case 'chair-rail':
          // Chair rail at mid-height
          ctx.fillStyle = el.color || '#F5F5F5';
          ctx.fillRect(x, y, w, h);
          // Curved profile suggestion
          ctx.strokeStyle = 'rgba(0,0,0,0.2)';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(x, y + h * 0.4);
          ctx.lineTo(x + w, y + h * 0.4);
          ctx.stroke();
          // Top highlight
          ctx.strokeStyle = 'rgba(255,255,255,0.4)';
          ctx.beginPath();
          ctx.moveTo(x, y + 1);
          ctx.lineTo(x + w, y + 1);
          ctx.stroke();
          break;

        case 'fireplace-niche': {
          // Fireplace recess/opening
          const fpPad = padding * 1.5;
          // Outer surround
          ctx.fillStyle = '#4a4a4a';
          ctx.fillRect(x, y, w, h);
          // Inner opening (darker)
          ctx.fillStyle = '#1a1a1a';
          ctx.fillRect(x + fpPad, y + fpPad, w - fpPad * 2, h - fpPad * 2);
          // Fire glow effect
          const glowGrad = ctx.createRadialGradient(
            x + w/2, y + h * 0.7, 0,
            x + w/2, y + h * 0.7, Math.min(w, h) * 0.4
          );
          glowGrad.addColorStop(0, 'rgba(255, 100, 0, 0.7)');
          glowGrad.addColorStop(0.5, 'rgba(255, 50, 0, 0.4)');
          glowGrad.addColorStop(1, 'rgba(0, 0, 0, 0)');
          ctx.fillStyle = glowGrad;
          ctx.fillRect(x + fpPad, y + fpPad, w - fpPad * 2, h - fpPad * 2);
          // Log shapes
          ctx.fillStyle = '#2d1b0e';
          ctx.beginPath();
          ctx.ellipse(x + w * 0.35, y + h * 0.8, w * 0.12, h * 0.06, 0.1, 0, Math.PI * 2);
          ctx.fill();
          ctx.beginPath();
          ctx.ellipse(x + w * 0.65, y + h * 0.78, w * 0.1, h * 0.05, -0.1, 0, Math.PI * 2);
          ctx.fill();
          // Mantel suggestion (top)
          ctx.fillStyle = '#5a4a3a';
          ctx.fillRect(x - 4, y - 6, w + 8, 8);
          break;
        }

        case 'tv-niche': {
          // TV recess/media niche
          const tvPad = padding;
          // Wall frame
          ctx.fillStyle = '#3a3a3a';
          ctx.fillRect(x, y, w, h);
          // Recessed area
          ctx.fillStyle = '#1a1a1a';
          ctx.fillRect(x + tvPad, y + tvPad, w - tvPad * 2, h - tvPad * 2);
          // TV screen
          const screenPad = tvPad * 2;
          ctx.fillStyle = '#111';
          ctx.fillRect(x + screenPad, y + screenPad, w - screenPad * 2, h - screenPad * 2);
          // Screen reflection
          ctx.fillStyle = 'rgba(60, 60, 80, 0.3)';
          ctx.fillRect(x + screenPad + 4, y + screenPad + 4, (w - screenPad * 2) * 0.6, (h - screenPad * 2) * 0.3);
          // TV stand indicator
          ctx.fillStyle = '#2a2a2a';
          ctx.fillRect(x + w * 0.4, y + h - tvPad - 4, w * 0.2, 4);
          break;
        }

        case 'wall-niche':
        case 'shower-niche': {
          // Decorative wall niche
          const nichePad = padding;
          // Frame
          ctx.fillStyle = '#e8e4dc';
          ctx.fillRect(x, y, w, h);
          // Inner recess (shadow)
          ctx.fillStyle = '#c5c0b5';
          ctx.fillRect(x + nichePad, y + nichePad, w - nichePad * 2, h - nichePad * 2);
          // Back of niche
          ctx.fillStyle = '#b5b0a5';
          ctx.fillRect(x + nichePad + 2, y + nichePad + 2, w - nichePad * 2 - 4, h - nichePad * 2 - 4);
          // Shadow on left and top inside
          ctx.fillStyle = 'rgba(0,0,0,0.15)';
          ctx.fillRect(x + nichePad, y + nichePad, 3, h - nichePad * 2);
          ctx.fillRect(x + nichePad, y + nichePad, w - nichePad * 2, 3);
          // Highlight on right and bottom inside
          ctx.fillStyle = 'rgba(255,255,255,0.2)';
          ctx.fillRect(x + w - nichePad - 3, y + nichePad, 3, h - nichePad * 2);
          ctx.fillRect(x + nichePad, y + h - nichePad - 3, w - nichePad * 2, 3);
          break;
        }

        case 'grab-bar':
        case 'grab-bar-24':
        case 'grab-bar-36':
        case 'grab-bar-42': {
          // ADA grab bar
          const barRadius = Math.min(h * 0.4, 6);
          // Mounting plates
          ctx.fillStyle = '#888';
          ctx.beginPath();
          ctx.arc(x + barRadius * 2, y + h/2, barRadius * 1.5, 0, Math.PI * 2);
          ctx.arc(x + w - barRadius * 2, y + h/2, barRadius * 1.5, 0, Math.PI * 2);
          ctx.fill();
          // Bar body
          const barGrad = ctx.createLinearGradient(x, y, x, y + h);
          barGrad.addColorStop(0, '#d0d0d0');
          barGrad.addColorStop(0.3, '#f0f0f0');
          barGrad.addColorStop(0.7, '#c0c0c0');
          barGrad.addColorStop(1, '#a0a0a0');
          ctx.fillStyle = barGrad;
          ctx.beginPath();
          ctx.roundRect(x + barRadius * 2, y + h/2 - barRadius, w - barRadius * 4, barRadius * 2, barRadius);
          ctx.fill();
          // Highlight
          ctx.strokeStyle = 'rgba(255,255,255,0.5)';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(x + barRadius * 3, y + h/2 - barRadius + 2);
          ctx.lineTo(x + w - barRadius * 3, y + h/2 - barRadius + 2);
          ctx.stroke();
          break;
        }

        // ===== DECORATIVE ELEMENTS =====
        case 'mantel': {
          // Fireplace mantel shelf (top-down view)
          ctx.fillStyle = el.color || '#8B7355';
          ctx.strokeStyle = 'rgba(0,0,0,0.3)';
          ctx.lineWidth = 2;

          // Main shelf
          ctx.fillRect(x, y, w, h);
          ctx.strokeRect(x, y, w, h);

          // Front edge detail (thicker/decorative)
          ctx.fillStyle = 'rgba(0,0,0,0.1)';
          ctx.fillRect(x, y + h - 4, w, 4);

          // Corbel indicators on ends
          ctx.fillStyle = 'rgba(0,0,0,0.15)';
          ctx.fillRect(x + 2, y + h * 0.3, 8, h * 0.6);
          ctx.fillRect(x + w - 10, y + h * 0.3, 8, h * 0.6);

          // Wood grain or stone texture lines
          ctx.strokeStyle = 'rgba(0,0,0,0.1)';
          ctx.lineWidth = 1;
          for (let lx = x + 15; lx < x + w - 10; lx += 20) {
            ctx.beginPath();
            ctx.moveTo(lx, y + 2);
            ctx.lineTo(lx, y + h - 2);
            ctx.stroke();
          }
          break;
        }

        case 'fireplace-surround':
        case 'niche-surround': {
          // Stone surround frame (top-down view)
          const isFireplace = el.type === 'fireplace-surround';
          const frameWidth = Math.min(w * 0.15, 15);

          // Outer frame
          ctx.fillStyle = el.color || (isFireplace ? '#8B7355' : '#A09080');
          ctx.strokeStyle = 'rgba(0,0,0,0.3)';
          ctx.lineWidth = 2;
          ctx.fillRect(x, y, w, h);
          ctx.strokeRect(x, y, w, h);

          // Inner opening (dark void)
          ctx.fillStyle = isFireplace ? 'rgba(20,20,20,0.9)' : 'rgba(40,40,40,0.85)';
          ctx.fillRect(x + frameWidth, y + frameWidth, w - frameWidth * 2, h - frameWidth * 2);

          // Inner shadow depth
          ctx.fillStyle = 'rgba(0,0,0,0.3)';
          ctx.fillRect(x + frameWidth, y + frameWidth, w - frameWidth * 2, 4);
          ctx.fillRect(x + frameWidth, y + frameWidth, 4, h - frameWidth * 2);

          // Stone texture on frame
          ctx.fillStyle = 'rgba(255,255,255,0.1)';
          ctx.fillRect(x + 2, y + 2, w - 4, 3);

          if (isFireplace) {
            // Fire glow hint
            const glowGrad = ctx.createRadialGradient(
              x + w/2, y + h * 0.7, 0,
              x + w/2, y + h * 0.7, Math.min(w, h) * 0.25
            );
            glowGrad.addColorStop(0, 'rgba(255, 100, 0, 0.4)');
            glowGrad.addColorStop(1, 'rgba(0, 0, 0, 0)');
            ctx.fillStyle = glowGrad;
            ctx.fillRect(x + frameWidth, y + frameWidth, w - frameWidth * 2, h - frameWidth * 2);
          }
          break;
        }

        case 'fireplace-hearth': {
          // Hearth stone on floor (top-down view)
          ctx.fillStyle = el.color || '#707070';
          ctx.strokeStyle = 'rgba(0,0,0,0.3)';
          ctx.lineWidth = 2;

          // Main hearth
          ctx.beginPath();
          ctx.roundRect(x, y, w, h, 3);
          ctx.fill();
          ctx.stroke();

          // Stone texture - deterministic pattern based on element position
          ctx.fillStyle = 'rgba(0,0,0,0.08)';
          const stoneSpots = [
            { ox: 0.15, oy: 0.25, r: 0.04 },
            { ox: 0.45, oy: 0.4, r: 0.06 },
            { ox: 0.75, oy: 0.2, r: 0.05 },
            { ox: 0.3, oy: 0.7, r: 0.045 },
            { ox: 0.6, oy: 0.65, r: 0.055 }
          ];
          stoneSpots.forEach(spot => {
            const hx = x + 5 + spot.ox * (w - 10);
            const hy = y + 3 + spot.oy * (h - 6);
            const radius = 2 + spot.r * (w + h) / 2;
            ctx.beginPath();
            ctx.arc(hx, hy, radius, 0, Math.PI * 2);
            ctx.fill();
          });

          // Front edge (raised lip)
          ctx.fillStyle = 'rgba(0,0,0,0.15)';
          ctx.fillRect(x, y + h - 5, w, 5);

          // Highlight on front edge
          ctx.fillStyle = 'rgba(255,255,255,0.2)';
          ctx.fillRect(x + 2, y + 2, w - 4, 2);
          break;
        }

        // ===== BATHROOM ELEMENTS =====
        case 'toilet': {
          // Toilet (top-down view)
          const tankW = w * 0.7;
          const tankH = h * 0.35;
          const bowlW = w * 0.85;
          const bowlH = h * 0.65;

          // Tank
          ctx.fillStyle = 'rgba(255,255,255,0.9)';
          ctx.strokeStyle = 'rgba(180,180,180,0.8)';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.roundRect(x + (w - tankW) / 2, y, tankW, tankH, 4);
          ctx.fill();
          ctx.stroke();

          // Bowl (elongated oval)
          ctx.beginPath();
          ctx.ellipse(x + w / 2, y + tankH + bowlH / 2, bowlW / 2, bowlH / 2, 0, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();

          // Seat opening
          ctx.strokeStyle = 'rgba(150,150,150,0.6)';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.ellipse(x + w / 2, y + tankH + bowlH / 2 + 2, bowlW / 2 - 6, bowlH / 2 - 6, 0, 0, Math.PI * 2);
          ctx.stroke();

          // Flush handle
          ctx.fillStyle = 'rgba(192,192,192,0.8)';
          ctx.fillRect(x + (w - tankW) / 2 - 6, y + tankH * 0.4, 8, 4);
          break;
        }

        case 'toilet-round': {
          // Round toilet (top-down view)
          const tankW = w * 0.7;
          const tankH = h * 0.35;
          const bowlW = w * 0.9;
          const bowlH = h * 0.55; // Rounder than elongated

          // Tank
          ctx.fillStyle = 'rgba(255,255,255,0.9)';
          ctx.strokeStyle = 'rgba(180,180,180,0.8)';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.roundRect(x + (w - tankW) / 2, y, tankW, tankH, 4);
          ctx.fill();
          ctx.stroke();

          // Bowl (circular)
          ctx.beginPath();
          const bowlRadius = Math.min(bowlW, bowlH) / 2;
          ctx.arc(x + w / 2, y + tankH + bowlH / 2, bowlRadius, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();

          // Seat opening
          ctx.strokeStyle = 'rgba(150,150,150,0.6)';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.arc(x + w / 2, y + tankH + bowlH / 2 + 2, bowlRadius - 8, 0, Math.PI * 2);
          ctx.stroke();

          // Flush handle
          ctx.fillStyle = 'rgba(192,192,192,0.8)';
          ctx.fillRect(x + (w - tankW) / 2 - 6, y + tankH * 0.4, 8, 4);
          break;
        }

        case 'toilet-wall': {
          // Wall-hung toilet (no visible tank, compact)
          const bowlW = w * 0.9;
          const bowlH = h * 0.85;

          // Wall mount plate
          ctx.fillStyle = 'rgba(200,200,200,0.7)';
          ctx.strokeStyle = 'rgba(160,160,160,0.8)';
          ctx.lineWidth = 2;
          ctx.fillRect(x + w * 0.15, y, w * 0.7, h * 0.12);
          ctx.strokeRect(x + w * 0.15, y, w * 0.7, h * 0.12);

          // Bowl (elongated, floating)
          ctx.fillStyle = 'rgba(255,255,255,0.95)';
          ctx.strokeStyle = 'rgba(180,180,180,0.8)';
          ctx.beginPath();
          ctx.ellipse(x + w / 2, y + h * 0.12 + bowlH / 2, bowlW / 2, bowlH / 2, 0, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();

          // Seat opening
          ctx.strokeStyle = 'rgba(150,150,150,0.6)';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.ellipse(x + w / 2, y + h * 0.12 + bowlH / 2 + 2, bowlW / 2 - 6, bowlH / 2 - 6, 0, 0, Math.PI * 2);
          ctx.stroke();

          // Flush button (on wall)
          ctx.fillStyle = 'rgba(220,220,220,0.9)';
          ctx.strokeStyle = 'rgba(180,180,180,0.8)';
          ctx.beginPath();
          ctx.roundRect(x + w / 2 - 10, y + 2, 20, 8, 2);
          ctx.fill();
          ctx.stroke();
          break;
        }

        case 'bidet': {
          // Bidet (top-down view)
          const rimW = w * 0.85;
          const rimH = h * 0.9;

          // Outer rim
          ctx.fillStyle = 'rgba(255,255,255,0.95)';
          ctx.strokeStyle = 'rgba(180,180,180,0.8)';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.ellipse(x + w / 2, y + h / 2, rimW / 2, rimH / 2, 0, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();

          // Inner basin
          ctx.fillStyle = 'rgba(240,245,250,0.9)';
          ctx.strokeStyle = 'rgba(200,200,200,0.6)';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.ellipse(x + w / 2, y + h / 2, rimW / 2 - 8, rimH / 2 - 8, 0, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();

          // Faucet
          ctx.fillStyle = 'rgba(192,192,192,0.9)';
          ctx.beginPath();
          ctx.arc(x + w / 2, y + 10, 6, 0, Math.PI * 2);
          ctx.fill();

          // Drain
          ctx.fillStyle = 'rgba(128,128,128,0.7)';
          ctx.beginPath();
          ctx.arc(x + w / 2, y + h - 15, 5, 0, Math.PI * 2);
          ctx.fill();
          break;
        }

        case 'bathtub':
        case 'bathtub-freestanding': {
          // Bathtub (top-down view)
          const rimWidth = 6;

          // Outer rim
          ctx.fillStyle = 'rgba(255,255,255,0.95)';
          ctx.strokeStyle = 'rgba(180,180,180,0.8)';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.roundRect(x, y, w, h, 8);
          ctx.fill();
          ctx.stroke();

          // Inner basin
          ctx.fillStyle = 'rgba(240,240,250,0.9)';
          ctx.strokeStyle = 'rgba(200,200,200,0.6)';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.roundRect(x + rimWidth, y + rimWidth, w - rimWidth * 2, h - rimWidth * 2, 6);
          ctx.fill();
          ctx.stroke();

          // Drain
          ctx.fillStyle = 'rgba(128,128,128,0.7)';
          ctx.beginPath();
          ctx.arc(x + w / 2, y + h - rimWidth - 15, 8, 0, Math.PI * 2);
          ctx.fill();

          // Faucet area
          ctx.fillStyle = 'rgba(192,192,192,0.8)';
          ctx.beginPath();
          ctx.arc(x + w / 2, y + rimWidth + 10, 10, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillRect(x + w / 2 - 20, y + rimWidth + 5, 12, 6);
          ctx.fillRect(x + w / 2 + 8, y + rimWidth + 5, 12, 6);
          break;
        }

        case 'bathtub-corner': {
          // Corner bathtub (top-down view - triangular shape)
          const rimWidth = 6;

          // Outer shape (quarter circle)
          ctx.fillStyle = 'rgba(255,255,255,0.95)';
          ctx.strokeStyle = 'rgba(180,180,180,0.8)';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(x, y);
          ctx.lineTo(x + w, y);
          ctx.lineTo(x + w, y + h);
          ctx.arc(x, y + h, Math.min(w, h), 0, -Math.PI / 2, true);
          ctx.closePath();
          ctx.fill();
          ctx.stroke();

          // Inner basin (curved)
          ctx.fillStyle = 'rgba(240,240,250,0.9)';
          ctx.strokeStyle = 'rgba(200,200,200,0.6)';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(x + rimWidth, y + rimWidth);
          ctx.lineTo(x + w - rimWidth, y + rimWidth);
          ctx.lineTo(x + w - rimWidth, y + h - rimWidth);
          ctx.arc(x + rimWidth, y + h - rimWidth, Math.min(w, h) - rimWidth * 2, 0, -Math.PI / 2, true);
          ctx.closePath();
          ctx.fill();
          ctx.stroke();

          // Drain
          ctx.fillStyle = 'rgba(128,128,128,0.7)';
          ctx.beginPath();
          ctx.arc(x + w * 0.6, y + h * 0.6, 8, 0, Math.PI * 2);
          ctx.fill();

          // Faucet area (corner)
          ctx.fillStyle = 'rgba(192,192,192,0.8)';
          ctx.beginPath();
          ctx.arc(x + rimWidth + 15, y + rimWidth + 15, 10, 0, Math.PI * 2);
          ctx.fill();
          break;
        }

        case 'bathtub-walk-in': {
          // Walk-in bathtub with door (top-down view)
          const rimWidth = 6;
          const doorWidth = w * 0.4;

          // Outer tub
          ctx.fillStyle = 'rgba(245,245,245,0.95)';
          ctx.strokeStyle = 'rgba(180,180,180,0.8)';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.roundRect(x, y, w, h, 6);
          ctx.fill();
          ctx.stroke();

          // Inner basin
          ctx.fillStyle = 'rgba(235,235,240,0.9)';
          ctx.strokeStyle = 'rgba(200,200,200,0.6)';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.roundRect(x + rimWidth, y + rimWidth, w - rimWidth * 2, h - rimWidth * 2, 4);
          ctx.fill();
          ctx.stroke();

          // Door indication (on side)
          ctx.strokeStyle = 'rgba(100,100,100,0.7)';
          ctx.lineWidth = 3;
          ctx.setLineDash([4, 2]);
          ctx.beginPath();
          ctx.moveTo(x + (w - doorWidth) / 2, y + h);
          ctx.lineTo(x + (w + doorWidth) / 2, y + h);
          ctx.stroke();
          ctx.setLineDash([]);

          // Door handle
          ctx.fillStyle = 'rgba(192,192,192,0.9)';
          ctx.beginPath();
          ctx.arc(x + w / 2, y + h - 8, 5, 0, Math.PI * 2);
          ctx.fill();

          // Seat (built-in)
          ctx.fillStyle = 'rgba(220,220,225,0.9)';
          ctx.strokeStyle = 'rgba(180,180,180,0.6)';
          ctx.lineWidth = 1;
          ctx.fillRect(x + rimWidth + 4, y + rimWidth + 4, w * 0.35, h * 0.3);
          ctx.strokeRect(x + rimWidth + 4, y + rimWidth + 4, w * 0.35, h * 0.3);

          // Drain
          ctx.fillStyle = 'rgba(128,128,128,0.7)';
          ctx.beginPath();
          ctx.arc(x + w * 0.7, y + h * 0.5, 6, 0, Math.PI * 2);
          ctx.fill();

          // Faucet
          ctx.fillStyle = 'rgba(192,192,192,0.8)';
          ctx.beginPath();
          ctx.arc(x + w - rimWidth - 12, y + rimWidth + 12, 8, 0, Math.PI * 2);
          ctx.fill();
          break;
        }

        case 'shower-base-36':
        case 'shower-base-48':
        case 'shower-base-60': {
          // Shower base/pan (top-down view)
          const isLarge = el.type === 'shower-base-48' || el.type === 'shower-base-60';

          // Base
          ctx.fillStyle = 'rgba(220,220,220,0.95)';
          ctx.strokeStyle = 'rgba(180,180,180,0.8)';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.roundRect(x, y, w, h, 4);
          ctx.fill();
          ctx.stroke();

          // Non-slip texture pattern
          ctx.strokeStyle = 'rgba(200,200,200,0.5)';
          ctx.lineWidth = 1;
          const spacing = 12;
          for (let px = x + spacing; px < x + w - spacing / 2; px += spacing) {
            for (let py = y + spacing; py < y + h - spacing / 2; py += spacing) {
              ctx.beginPath();
              ctx.arc(px, py, 2, 0, Math.PI * 2);
              ctx.stroke();
            }
          }

          // Drain (center or offset)
          ctx.fillStyle = 'rgba(128,128,128,0.8)';
          ctx.strokeStyle = 'rgba(100,100,100,0.7)';
          ctx.lineWidth = 1;
          const drainX = isLarge ? x + w * 0.7 : x + w / 2;
          const drainY = y + h / 2;
          ctx.beginPath();
          ctx.arc(drainX, drainY, 10, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();

          // Drain grate lines
          ctx.strokeStyle = 'rgba(80,80,80,0.6)';
          ctx.lineWidth = 1;
          for (let i = -6; i <= 6; i += 3) {
            ctx.beginPath();
            ctx.moveTo(drainX + i, drainY - 8);
            ctx.lineTo(drainX + i, drainY + 8);
            ctx.stroke();
          }

          // Threshold/curb indication
          ctx.fillStyle = 'rgba(200,200,200,0.8)';
          ctx.fillRect(x, y + h - 6, w, 6);
          break;
        }

        case 'vanity-24':
        case 'vanity-30':
        case 'vanity-36':
        case 'vanity-48':
        case 'vanity-60':
        case 'vanity-72':
        case 'vanity-double-60':
        case 'vanity-double-72':
        case 'vanity-double-84': {
          // Bathroom vanity (top-down view)
          const isDouble = w > pixelsPerFoot * 4;

          // Counter
          ctx.fillStyle = el.color || 'rgba(232,224,216,0.95)';
          ctx.strokeStyle = 'rgba(180,180,180,0.8)';
          ctx.lineWidth = 2;
          ctx.fillRect(x, y, w, h);
          ctx.strokeRect(x, y, w, h);

          // Sink basin(s)
          const sinkPadding = w * 0.15;
          const sinkW = isDouble ? (w - sinkPadding * 3) / 2 : w - sinkPadding * 2;
          const sinkH = h * 0.5;
          const sinkY = y + (h - sinkH) / 2;

          ctx.fillStyle = 'rgba(255,255,255,0.9)';
          ctx.strokeStyle = 'rgba(200,200,200,0.8)';
          ctx.lineWidth = 1;

          if (isDouble) {
            // Left sink
            ctx.beginPath();
            ctx.ellipse(x + sinkPadding + sinkW / 2, sinkY + sinkH / 2, sinkW / 2, sinkH / 2, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            // Right sink
            ctx.beginPath();
            ctx.ellipse(x + w - sinkPadding - sinkW / 2, sinkY + sinkH / 2, sinkW / 2, sinkH / 2, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
          } else {
            // Single sink
            ctx.beginPath();
            ctx.ellipse(x + w / 2, sinkY + sinkH / 2, sinkW / 2, sinkH / 2, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
          }

          // Faucet(s)
          ctx.fillStyle = 'rgba(192,192,192,0.9)';
          if (isDouble) {
            ctx.beginPath();
            ctx.arc(x + sinkPadding + sinkW / 2, y + 8, 5, 0, Math.PI * 2);
            ctx.arc(x + w - sinkPadding - sinkW / 2, y + 8, 5, 0, Math.PI * 2);
            ctx.fill();
          } else {
            ctx.beginPath();
            ctx.arc(x + w / 2, y + 8, 6, 0, Math.PI * 2);
            ctx.fill();
          }
          break;
        }

        case 'vanity-hishers-96':
        case 'vanity-hishers-108': {
          // His/Hers vanity with center powder table
          const sectionW = w * 0.35;
          const centerW = w * 0.3;
          const centerX = x + sectionW;

          // Left vanity section
          ctx.fillStyle = el.color || '#8B7355';
          ctx.strokeStyle = 'rgba(180,180,180,0.8)';
          ctx.lineWidth = 2;
          ctx.fillRect(x, y, sectionW, h);
          ctx.strokeRect(x, y, sectionW, h);

          // Center powder table (lighter color)
          ctx.fillStyle = '#C4A87C';
          ctx.fillRect(centerX, y, centerW, h);
          ctx.strokeRect(centerX, y, centerW, h);

          // Right vanity section
          ctx.fillStyle = el.color || '#8B7355';
          ctx.fillRect(centerX + centerW, y, sectionW, h);
          ctx.strokeRect(centerX + centerW, y, sectionW, h);

          // Left sink ellipse
          ctx.fillStyle = 'rgba(255,255,255,0.9)';
          ctx.strokeStyle = 'rgba(200,200,200,0.8)';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.ellipse(x + sectionW / 2, y + h / 2, sectionW * 0.3, h * 0.25, 0, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();

          // Right sink ellipse
          ctx.beginPath();
          ctx.ellipse(x + w - sectionW / 2, y + h / 2, sectionW * 0.3, h * 0.25, 0, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();

          // Center mirror indicator
          ctx.fillStyle = 'rgba(232,232,255,0.5)';
          ctx.beginPath();
          ctx.arc(centerX + centerW / 2, y + h * 0.35, Math.min(centerW, h) * 0.2, 0, Math.PI * 2);
          ctx.fill();

          // Faucets
          ctx.fillStyle = 'rgba(192,192,192,0.9)';
          ctx.beginPath();
          ctx.arc(x + sectionW / 2, y + 8, 4, 0, Math.PI * 2);
          ctx.arc(x + w - sectionW / 2, y + 8, 4, 0, Math.PI * 2);
          ctx.fill();
          break;
        }

        case 'powder-table': {
          // Rectangular body with mirror circle and drawer handle
          ctx.fillStyle = el.color || '#A08060';
          ctx.strokeStyle = 'rgba(180,180,180,0.8)';
          ctx.lineWidth = 2;
          ctx.fillRect(x, y, w, h);
          ctx.strokeRect(x, y, w, h);

          // Mirror circle
          ctx.fillStyle = 'rgba(232,232,255,0.6)';
          ctx.strokeStyle = 'rgba(200,200,200,0.6)';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.arc(x + w / 2, y + h * 0.35, Math.min(w, h) * 0.2, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();

          // Drawer handle
          ctx.fillStyle = '#C0C0C0';
          const handleW = w * 0.25;
          ctx.fillRect(x + w / 2 - handleW / 2, y + h * 0.75, handleW, 3);
          break;
        }

        case 'makeup-vanity': {
          // Lower body + upper mirror rectangle
          ctx.fillStyle = el.color || '#8B7355';
          ctx.strokeStyle = 'rgba(180,180,180,0.8)';
          ctx.lineWidth = 2;
          ctx.fillRect(x, y + h * 0.3, w, h * 0.7);
          ctx.strokeRect(x, y + h * 0.3, w, h * 0.7);

          // Upper mirror rectangle
          ctx.fillStyle = 'rgba(232,232,255,0.6)';
          ctx.strokeStyle = 'rgba(200,200,200,0.6)';
          ctx.lineWidth = 1;
          const mirrorW = w * 0.7;
          const mirrorH = h * 0.25;
          ctx.fillRect(x + (w - mirrorW) / 2, y + 2, mirrorW, mirrorH);
          ctx.strokeRect(x + (w - mirrorW) / 2, y + 2, mirrorW, mirrorH);

          // Drawer handle
          ctx.fillStyle = '#C0C0C0';
          ctx.fillRect(x + w / 2 - w * 0.12, y + h * 0.85, w * 0.24, 3);
          break;
        }

        case 'pedestal-sink': {
          // Oval basin on narrow pedestal
          const pedastalW = w * 0.3;
          const basinW = w * 0.8;
          const basinH = h * 0.55;

          // Pedestal column
          ctx.fillStyle = '#F0F0F0';
          ctx.strokeStyle = 'rgba(200,200,200,0.8)';
          ctx.lineWidth = 1;
          ctx.fillRect(x + (w - pedastalW) / 2, y + h * 0.4, pedastalW, h * 0.6);
          ctx.strokeRect(x + (w - pedastalW) / 2, y + h * 0.4, pedastalW, h * 0.6);

          // Oval basin
          ctx.fillStyle = '#FFFFFF';
          ctx.strokeStyle = 'rgba(200,200,200,0.8)';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.ellipse(x + w / 2, y + basinH / 2 + 2, basinW / 2, basinH / 2, 0, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();

          // Faucet circle
          ctx.fillStyle = 'rgba(192,192,192,0.9)';
          ctx.beginPath();
          ctx.arc(x + w / 2, y + 6, 4, 0, Math.PI * 2);
          ctx.fill();

          // Drain
          ctx.fillStyle = '#888';
          ctx.beginPath();
          ctx.arc(x + w / 2, y + basinH / 2 + 2, 3, 0, Math.PI * 2);
          ctx.fill();
          break;
        }

        case 'linen-closet':
        case 'linen-tower': {
          // Rectangle with horizontal shelf lines and door handle
          ctx.fillStyle = el.color || '#8B7355';
          ctx.strokeStyle = 'rgba(180,180,180,0.8)';
          ctx.lineWidth = 2;
          ctx.fillRect(x, y, w, h);
          ctx.strokeRect(x, y, w, h);

          // Shelf lines
          ctx.strokeStyle = 'rgba(100,60,30,0.5)';
          ctx.lineWidth = 1;
          const shelfCount = type === 'linen-tower' ? 5 : 4;
          for (let s = 1; s < shelfCount; s++) {
            const sy = y + (h / shelfCount) * s;
            ctx.beginPath();
            ctx.moveTo(x + 3, sy);
            ctx.lineTo(x + w - 3, sy);
            ctx.stroke();
          }

          // Door handle
          ctx.fillStyle = '#C0C0C0';
          const lHandleLen = h * 0.15;
          ctx.fillRect(x + w - 10, y + h / 2 - lHandleLen / 2, 3, lHandleLen);
          break;
        }

        case 'base-cabinet-12':
        case 'base-cabinet-15':
        case 'base-cabinet-18':
        case 'base-cabinet-21':
        case 'base-cabinet-24':
        case 'base-cabinet-27':
        case 'base-cabinet-30':
        case 'base-cabinet-33': {
          // Fall through to base-cabinet rendering
          const bcStyle = el.materialName?.toLowerCase().includes('flat') ? 'flat' : 'shaker';
          const bcToeKickH = Math.max(6, h * 0.12);
          const bcToeKickRecess = Math.max(4, w * 0.05);
          const bcBodyH = h - bcToeKickH;

          ctx.fillStyle = el.color;
          ctx.fillRect(x, y, w, bcBodyH);

          // Toe kick
          ctx.fillStyle = '#0a0a0e';
          ctx.fillRect(x + bcToeKickRecess, y + bcBodyH, w - bcToeKickRecess * 2, bcToeKickH);
          ctx.fillStyle = 'rgba(0,0,0,0.5)';
          ctx.fillRect(x + bcToeKickRecess, y + bcBodyH, w - bcToeKickRecess * 2, 2);

          // Single door
          const bcDx = x + 3;
          const bcDy = y + 3;
          const bcDw = w - 6;
          const bcDh = bcBodyH - 6;
          ctx.fillStyle = el.color;
          ctx.fillRect(bcDx, bcDy, bcDw, bcDh);
          ctx.strokeStyle = 'rgba(0,0,0,0.25)';
          ctx.lineWidth = 1;
          ctx.strokeRect(bcDx + 0.5, bcDy + 0.5, bcDw - 1, bcDh - 1);

          if (bcStyle === 'shaker') {
            const bcPanelInset = Math.min(10, Math.max(6, bcDw * 0.1));
            ctx.strokeStyle = 'rgba(0,0,0,0.18)';
            ctx.strokeRect(bcDx + bcPanelInset + 0.5, bcDy + bcPanelInset + 0.5, bcDw - bcPanelInset * 2 - 1, bcDh - bcPanelInset * 2 - 1);
            ctx.fillStyle = 'rgba(0,0,0,0.05)';
            ctx.fillRect(bcDx + bcPanelInset + 1, bcDy + bcPanelInset + 1, bcDw - bcPanelInset * 2 - 2, bcDh - bcPanelInset * 2 - 2);
          }

          // Handle
          const bcHandleLen = Math.min(20, bcDh * 0.3);
          ctx.fillStyle = '#C0C0C0';
          ctx.fillRect(bcDx + bcDw - 8, bcDy + bcDh / 2 - bcHandleLen / 2, 3, bcHandleLen);
          break;
        }

        case 'shower-bench': {
          // Built-in shower bench (top-down view)
          ctx.fillStyle = el.color || 'rgba(212,212,212,0.9)';
          ctx.strokeStyle = 'rgba(160,160,160,0.8)';
          ctx.lineWidth = 2;
          ctx.fillRect(x, y, w, h);
          ctx.strokeRect(x, y, w, h);

          // Seat indication lines
          ctx.strokeStyle = 'rgba(180,180,180,0.5)';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(x + 4, y + 4);
          ctx.lineTo(x + 4, y + h - 4);
          ctx.moveTo(x + w - 4, y + 4);
          ctx.lineTo(x + w - 4, y + h - 4);
          ctx.stroke();
          break;
        }

        case 'towel-warmer': {
          // Wall-mounted towel warmer (front view)
          ctx.strokeStyle = 'rgba(192,192,192,0.9)';
          ctx.lineWidth = 3;

          // Vertical rails
          ctx.beginPath();
          ctx.moveTo(x + 4, y);
          ctx.lineTo(x + 4, y + h);
          ctx.moveTo(x + w - 4, y);
          ctx.lineTo(x + w - 4, y + h);
          ctx.stroke();

          // Horizontal bars
          const numBars = Math.max(4, Math.floor(h / 15));
          ctx.lineWidth = 2;
          for (let i = 0; i < numBars; i++) {
            const barY = y + 8 + (i * (h - 16) / (numBars - 1));
            ctx.beginPath();
            ctx.moveTo(x + 4, barY);
            ctx.lineTo(x + w - 4, barY);
            ctx.stroke();
          }
          break;
        }

        // ===== LAUNDRY ELEMENTS =====
        case 'washer': {
          // Front-loading washer (top-down view)
          ctx.fillStyle = 'rgba(240,240,240,0.95)';
          ctx.strokeStyle = 'rgba(180,180,180,0.8)';
          ctx.lineWidth = 2;
          ctx.fillRect(x, y, w, h);
          ctx.strokeRect(x, y, w, h);

          // Door circle
          const doorRadius = Math.min(w, h) * 0.35;
          ctx.fillStyle = 'rgba(74,96,128,0.4)';
          ctx.strokeStyle = 'rgba(160,160,160,0.8)';
          ctx.beginPath();
          ctx.arc(x + w / 2, y + h * 0.55, doorRadius, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();

          // Control panel
          ctx.fillStyle = 'rgba(60,60,60,0.7)';
          ctx.fillRect(x + 6, y + 6, w - 12, h * 0.15);

          // Dial
          ctx.fillStyle = 'rgba(192,192,192,0.9)';
          ctx.beginPath();
          ctx.arc(x + w * 0.25, y + 6 + h * 0.075, 8, 0, Math.PI * 2);
          ctx.fill();
          break;
        }

        case 'dryer': {
          // Front-loading dryer (top-down view)
          ctx.fillStyle = 'rgba(232,232,232,0.95)';
          ctx.strokeStyle = 'rgba(180,180,180,0.8)';
          ctx.lineWidth = 2;
          ctx.fillRect(x, y, w, h);
          ctx.strokeRect(x, y, w, h);

          // Door circle (solid)
          const dryerDoorRadius = Math.min(w, h) * 0.35;
          ctx.fillStyle = 'rgba(216,216,216,0.9)';
          ctx.strokeStyle = 'rgba(160,160,160,0.8)';
          ctx.beginPath();
          ctx.arc(x + w / 2, y + h * 0.55, dryerDoorRadius, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();

          // Control panel
          ctx.fillStyle = 'rgba(70,70,70,0.7)';
          ctx.fillRect(x + 6, y + 6, w - 12, h * 0.15);

          // Dials
          ctx.fillStyle = 'rgba(192,192,192,0.9)';
          ctx.beginPath();
          ctx.arc(x + w * 0.25, y + 6 + h * 0.075, 7, 0, Math.PI * 2);
          ctx.arc(x + w * 0.75, y + 6 + h * 0.075, 7, 0, Math.PI * 2);
          ctx.fill();
          break;
        }

        case 'utility-sink':
        case 'laundry-sink': {
          // Deep utility sink (top-down view)
          ctx.fillStyle = 'rgba(245,245,245,0.95)';
          ctx.strokeStyle = 'rgba(180,180,180,0.8)';
          ctx.lineWidth = 2;
          ctx.fillRect(x, y, w, h);
          ctx.strokeRect(x, y, w, h);

          // Basin
          const basinPad = 8;
          ctx.fillStyle = 'rgba(232,232,232,0.9)';
          ctx.strokeStyle = 'rgba(200,200,200,0.8)';
          ctx.lineWidth = 1;
          ctx.fillRect(x + basinPad, y + basinPad, w - basinPad * 2, h - basinPad * 2);
          ctx.strokeRect(x + basinPad, y + basinPad, w - basinPad * 2, h - basinPad * 2);

          // Drain
          ctx.fillStyle = 'rgba(128,128,128,0.7)';
          ctx.beginPath();
          ctx.arc(x + w / 2, y + h / 2, 6, 0, Math.PI * 2);
          ctx.fill();

          // Faucet
          ctx.fillStyle = 'rgba(176,176,176,0.9)';
          ctx.beginPath();
          ctx.arc(x + w / 2, y + basinPad + 8, 8, 0, Math.PI * 2);
          ctx.fill();
          break;
        }

        case 'drying-rack': {
          // Drying rack (top-down view)
          ctx.strokeStyle = 'rgba(192,192,192,0.8)';
          ctx.lineWidth = 2;

          // Frame
          ctx.strokeRect(x, y, w, h);

          // Rods
          const numRods = Math.max(4, Math.floor(h / 12));
          ctx.lineWidth = 1.5;
          for (let i = 0; i < numRods; i++) {
            const rodY = y + 4 + (i * (h - 8) / (numRods - 1));
            ctx.beginPath();
            ctx.moveTo(x + 3, rodY);
            ctx.lineTo(x + w - 3, rodY);
            ctx.stroke();
          }
          break;
        }

        case 'washer-dryer-stack': {
          // Stacked washer/dryer (top-down shows washer on bottom)
          ctx.fillStyle = 'rgba(240,240,240,0.95)';
          ctx.strokeStyle = 'rgba(180,180,180,0.8)';
          ctx.lineWidth = 2;
          ctx.fillRect(x, y, w, h);
          ctx.strokeRect(x, y, w, h);

          // Door circle (washer door, visible from top)
          const doorRadius = Math.min(w, h) * 0.32;
          ctx.fillStyle = 'rgba(74,96,128,0.4)';
          ctx.strokeStyle = 'rgba(160,160,160,0.8)';
          ctx.beginPath();
          ctx.arc(x + w / 2, y + h * 0.55, doorRadius, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();

          // Control panel
          ctx.fillStyle = 'rgba(50,50,50,0.7)';
          ctx.fillRect(x + 6, y + 6, w - 12, h * 0.12);

          // Dial
          ctx.fillStyle = 'rgba(192,192,192,0.9)';
          ctx.beginPath();
          ctx.arc(x + w * 0.25, y + 6 + h * 0.06, 6, 0, Math.PI * 2);
          ctx.fill();

          // Stack indicator line
          ctx.strokeStyle = 'rgba(100,100,100,0.6)';
          ctx.setLineDash([4, 2]);
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(x + 2, y + h * 0.2);
          ctx.lineTo(x + w - 2, y + h * 0.2);
          ctx.stroke();
          ctx.setLineDash([]);

          // "S" label for stacked
          ctx.fillStyle = 'rgba(80,80,80,0.7)';
          ctx.font = 'bold 12px sans-serif';
          ctx.textAlign = 'center';
          ctx.fillText('STACK', x + w / 2, y + h * 0.15);
          break;
        }

        case 'laundry-cabinet': {
          // Laundry room cabinet (top-down view)
          ctx.fillStyle = el.color || 'rgba(139,115,85,0.95)';
          ctx.strokeStyle = 'rgba(100,80,60,0.8)';
          ctx.lineWidth = 2;
          ctx.fillRect(x, y, w, h);
          ctx.strokeRect(x, y, w, h);

          // Door split line
          ctx.strokeStyle = 'rgba(80,60,40,0.5)';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(x + w / 2, y + 2);
          ctx.lineTo(x + w / 2, y + h - 2);
          ctx.stroke();

          // Handles
          ctx.fillStyle = 'rgba(192,192,192,0.9)';
          ctx.fillRect(x + w / 2 - 12, y + h / 2 - 3, 6, 6);
          ctx.fillRect(x + w / 2 + 6, y + h / 2 - 3, 6, 6);

          // Counter top indication
          ctx.strokeStyle = 'rgba(120,100,80,0.4)';
          ctx.lineWidth = 1;
          ctx.strokeRect(x + 2, y + 2, w - 4, h - 4);
          break;
        }

        case 'ironing-board': {
          // Ironing board (top-down view - shows tapered shape)
          // Board shape (wider at one end)
          ctx.fillStyle = 'rgba(200,200,200,0.95)';
          ctx.strokeStyle = 'rgba(160,160,160,0.8)';
          ctx.lineWidth = 2;

          ctx.beginPath();
          // Tapered shape: narrow at top, wider at bottom
          const narrowEnd = w * 0.4;
          const wideEnd = w * 0.9;
          ctx.moveTo(x + (w - narrowEnd) / 2, y);
          ctx.lineTo(x + (w + narrowEnd) / 2, y);
          ctx.lineTo(x + (w + wideEnd) / 2, y + h);
          ctx.lineTo(x + (w - wideEnd) / 2, y + h);
          ctx.closePath();
          ctx.fill();
          ctx.stroke();

          // Padding/cover pattern (subtle lines)
          ctx.strokeStyle = 'rgba(180,180,180,0.4)';
          ctx.lineWidth = 1;
          for (let ly = y + 10; ly < y + h - 5; ly += 8) {
            const progress = (ly - y) / h;
            const lineW = narrowEnd + (wideEnd - narrowEnd) * progress;
            ctx.beginPath();
            ctx.moveTo(x + (w - lineW) / 2 + 4, ly);
            ctx.lineTo(x + (w + lineW) / 2 - 4, ly);
            ctx.stroke();
          }

          // Legs indication (X pattern)
          ctx.strokeStyle = 'rgba(100,100,100,0.5)';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(x + w * 0.3, y + h * 0.3);
          ctx.lineTo(x + w * 0.7, y + h * 0.7);
          ctx.moveTo(x + w * 0.7, y + h * 0.3);
          ctx.lineTo(x + w * 0.3, y + h * 0.7);
          ctx.stroke();
          break;
        }

        // ===== CLOSET ELEMENTS =====
        case 'closet-rod': {
          // Clothing rod (top-down view shows as line)
          ctx.strokeStyle = 'rgba(192,192,192,0.9)';
          ctx.lineWidth = 4;
          ctx.beginPath();
          ctx.moveTo(x, y + h / 2);
          ctx.lineTo(x + w, y + h / 2);
          ctx.stroke();

          // End brackets
          ctx.fillStyle = 'rgba(128,128,128,0.8)';
          ctx.fillRect(x, y + h / 2 - 6, 8, 12);
          ctx.fillRect(x + w - 8, y + h / 2 - 6, 8, 12);
          break;
        }

        case 'closet-shelf': {
          // Closet shelf (top-down view)
          ctx.fillStyle = el.color || 'rgba(232,232,232,0.9)';
          ctx.strokeStyle = 'rgba(200,200,200,0.8)';
          ctx.lineWidth = 1;
          ctx.fillRect(x, y, w, h);
          ctx.strokeRect(x, y, w, h);

          // Front edge
          ctx.fillStyle = 'rgba(210,210,210,0.9)';
          ctx.fillRect(x, y + h - 4, w, 4);
          break;
        }

        case 'closet-drawers': // Alias for drawer-unit
        case 'drawer-unit': {
          // Multi-drawer unit (top-down view)
          ctx.fillStyle = el.color || 'rgba(245,240,230,0.95)';
          ctx.strokeStyle = 'rgba(180,180,180,0.8)';
          ctx.lineWidth = 2;
          ctx.fillRect(x, y, w, h);
          ctx.strokeRect(x, y, w, h);

          // Drawer fronts
          const numDrawers = Math.max(3, Math.floor(h / 20));
          const drawerH = (h - 8) / numDrawers;
          ctx.strokeStyle = 'rgba(160,160,160,0.6)';
          ctx.lineWidth = 1;
          for (let i = 0; i < numDrawers; i++) {
            const dY = y + 4 + i * drawerH;
            ctx.strokeRect(x + 4, dY, w - 8, drawerH - 2);

            // Handle
            ctx.fillStyle = 'rgba(192,192,192,0.8)';
            ctx.fillRect(x + w / 2 - 10, dY + drawerH / 2 - 2, 20, 4);
          }
          break;
        }

        case 'shoe-rack': {
          // Shoe rack (top-down view)
          ctx.fillStyle = el.color || 'rgba(222,184,135,0.9)';
          ctx.strokeStyle = 'rgba(180,160,140,0.8)';
          ctx.lineWidth = 2;
          ctx.fillRect(x, y, w, h);
          ctx.strokeRect(x, y, w, h);

          // Shelves
          const numShelves = Math.max(3, Math.floor(h / 18));
          ctx.strokeStyle = 'rgba(160,140,120,0.6)';
          ctx.lineWidth = 1;
          for (let i = 1; i < numShelves; i++) {
            const shelfY = y + (i * h / numShelves);
            ctx.beginPath();
            ctx.moveTo(x + 4, shelfY);
            ctx.lineTo(x + w - 4, shelfY);
            ctx.stroke();
          }
          break;
        }

        case 'closet-island': {
          // Closet island (top-down view)
          ctx.fillStyle = el.color || 'rgba(245,240,230,0.95)';
          ctx.strokeStyle = 'rgba(180,180,180,0.8)';
          ctx.lineWidth = 2;
          ctx.fillRect(x, y, w, h);
          ctx.strokeRect(x, y, w, h);

          // Top surface (different color)
          ctx.fillStyle = 'rgba(232,224,216,0.9)';
          ctx.fillRect(x + 2, y + 2, w - 4, h - 4);

          // Drawer indication
          ctx.strokeStyle = 'rgba(200,190,180,0.6)';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(x + w / 4, y + 4);
          ctx.lineTo(x + w / 4, y + h - 4);
          ctx.moveTo(x + w * 3 / 4, y + 4);
          ctx.lineTo(x + w * 3 / 4, y + h - 4);
          ctx.stroke();
          break;
        }

        case 'jewelry-drawer': // Alias for jewelry-cabinet style
        case 'jewelry-cabinet': {
          // Jewelry cabinet (front view in 2D)
          ctx.fillStyle = el.color || 'rgba(245,240,230,0.95)';
          ctx.strokeStyle = 'rgba(180,180,180,0.8)';
          ctx.lineWidth = 2;
          ctx.fillRect(x, y, w, h);
          ctx.strokeRect(x, y, w, h);

          // Mirror
          ctx.fillStyle = 'rgba(200,210,220,0.7)';
          ctx.fillRect(x + 6, y + 6, w - 12, h - 12);

          // Mirror shine
          ctx.strokeStyle = 'rgba(255,255,255,0.4)';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(x + w * 0.2, y + 6);
          ctx.lineTo(x + 6, y + h * 0.3);
          ctx.stroke();
          break;
        }

        case 'tie-rack': {
          // Tie/belt rack (top-down view shows as bar with hooks)
          ctx.fillStyle = el.color || 'rgba(160,160,160,0.9)';
          ctx.strokeStyle = 'rgba(128,128,128,0.8)';
          ctx.lineWidth = 2;

          // Main bar
          ctx.fillRect(x, y, w, 8);
          ctx.strokeRect(x, y, w, 8);

          // Hooks/pegs
          const numHooks = Math.max(3, Math.floor(w / 15));
          const hookSpacing = w / (numHooks + 1);
          ctx.fillStyle = 'rgba(192,192,192,0.9)';
          for (let i = 1; i <= numHooks; i++) {
            const hookX = x + i * hookSpacing;
            ctx.beginPath();
            ctx.arc(hookX, y + h / 2, 4, 0, Math.PI * 2);
            ctx.fill();
          }

          // Ties hanging (visual indicator)
          ctx.lineWidth = 3;
          const tieColors = ['#4169E1', '#DC143C', '#228B22', '#8B4513', '#4B0082'];
          for (let i = 1; i <= Math.min(numHooks, 5); i++) {
            const tieX = x + i * hookSpacing;
            ctx.strokeStyle = tieColors[(i - 1) % tieColors.length];
            ctx.beginPath();
            ctx.moveTo(tieX, y + 8);
            ctx.lineTo(tieX - 2, y + h - 4);
            ctx.lineTo(tieX + 2, y + h - 4);
            ctx.closePath();
            ctx.stroke();
          }
          break;
        }

        case 'full-mirror': {
          // Full-length mirror (top-down view shows as thin rectangle)
          // Frame
          ctx.fillStyle = 'rgba(139,115,85,0.9)';
          ctx.strokeStyle = 'rgba(100,80,60,0.8)';
          ctx.lineWidth = 2;
          ctx.fillRect(x, y, w, h);
          ctx.strokeRect(x, y, w, h);

          // Mirror surface (reflective appearance)
          ctx.fillStyle = 'rgba(220,230,240,0.85)';
          ctx.fillRect(x + 3, y + 3, w - 6, h - 6);

          // Shine effect
          ctx.fillStyle = 'rgba(255,255,255,0.3)';
          ctx.beginPath();
          ctx.moveTo(x + 3, y + 3);
          ctx.lineTo(x + w / 3, y + 3);
          ctx.lineTo(x + 3, y + h / 3);
          ctx.closePath();
          ctx.fill();
          break;
        }
      }

      ctx.lineWidth = 1;
    }

    // Z-order constants for element rendering (defined outside function for performance)
    // Layer 0-9: Floor level (flooring, rugs)
    // Layer 10-19: Base level (cabinets, appliances on floor)
    // Layer 20-29: Counter level (countertops, sinks)
    // Layer 30-39: Above counter (backsplash, upper cabs)
    // Layer 40-49: Wall fixtures (windows, doors, niches)
    // Layer 50-59: Walls and partitions
    // Layer 60+: Annotations, labels
    const ELEMENT_Z_ORDER = {
      // Floor level
      'flooring': 0,
      'tile': 1,
      'rug': 2,
      'threshold': 3,
      'fireplace-hearth': 4,

      // Base level
      'island': 10,
      'base-cabinet': 11,
      'drawer-base': 11,
      'sink-base': 11,
      'corner-cabinet': 12,
      'lazy-susan': 12,
      'tall-cabinet': 13,
      'pantry': 13,
      'refrigerator': 14,
      'oven': 14,
      'dishwasher': 14,
      'stove': 15,
      'range': 15,
      'cooktop': 16,

      // Counter level
      'countertop': 20,
      'bar-top': 21,
      'wall-cap': 21,
      'sink': 22,
      'sink-double': 22,
      'sink-farmhouse': 22,

      // Above counter
      'backsplash': 30,
      'wall-cabinet': 31,
      'range-hood': 32,
      'microwave': 32,

      // Wall fixtures
      'window': 40,
      'bay-window': 40,
      'picture-window': 40,
      'door': 41,
      'sliding-door': 41,
      'french-door': 41,
      'glass-door': 41,
      'wall-niche': 42,
      'shower-niche': 42,
      'fireplace-niche': 43,
      'tv-niche': 43,
      'grab-bar': 44,
      'grab-bar-24': 44,
      'grab-bar-36': 44,
      'grab-bar-42': 44,

      // Walls and partitions
      'wall': 50,
      'wall-block': 50,
      'wall-concrete': 50,
      'wall-framed': 50,
      'pony-wall': 51,
      'pony-wall-bar': 51,
      'knee-wall': 51,

      // Fixtures and accessories (bathroom)
      'toilet': 45,
      'toilet-round': 45,
      'toilet-wall': 45,
      'bidet': 45,
      'bathtub': 45,
      'bathtub-freestanding': 45,
      'bathtub-corner': 45,
      'bathtub-walk-in': 45,
      'shower': 45,
      'shower-base-36': 5,
      'shower-base-48': 5,
      'shower-base-60': 5,
      'vanity-24': 46,
      'vanity-30': 46,
      'vanity-36': 46,
      'vanity-48': 46,
      'vanity-60': 46,
      'vanity-72': 46,
      'shower-bench': 44,
      'towel-warmer': 47,

      // Laundry elements
      'washer': 14,
      'dryer': 14,
      'washer-dryer-stack': 14,
      'laundry-cabinet': 13,
      'ironing-board': 15,
      'utility-sink': 22,
      'laundry-sink': 22,
      'drying-rack': 47,

      // Closet elements
      'closet-rod': 35,
      'closet-shelf': 36,
      'drawer-unit': 13,
      'closet-drawers': 13,
      'shoe-rack': 12,
      'closet-island': 11,
      'jewelry-cabinet': 46,
      'jewelry-drawer': 46,
      'tie-rack': 37,
      'full-mirror': 48,

      // Decorative
      'crown-molding': 55,
      'mantel': 55,
      'fireplace-surround': 55,
      'niche-surround': 55
    };

    function drawElements() {
      // Filter out hidden elements based on visibility settings AND by current room
      const visibleElements = elements.filter(el => {
        if (el.hidden) return false;
        // Only show elements belonging to current room (check both room tracking systems)
        const activeRoomId = currentRoomId || currentRoom || 'default';
        if (el.roomId && el.roomId !== activeRoomId && el.roomId !== currentRoom) return false;
        const category = getElementCategory(el.type);
        return !hiddenCategories[category];
      });

      // Sort elements by z-order, then by custom zIndex override, then selected last
      const sortedElements = [...visibleElements].sort((a, b) => {
        // Selected element always draws last (on top)
        if (a === selectedElement) return 1;
        if (b === selectedElement) return -1;

        // Get base z-order from type
        const aBase = ELEMENT_Z_ORDER[a.type] ?? 25;
        const bBase = ELEMENT_Z_ORDER[b.type] ?? 25;

        // Apply custom zIndex offset if set (from send to back/bring to front)
        const aZ = aBase + (a.zIndexOffset || 0);
        const bZ = bBase + (b.zIndexOffset || 0);

        return aZ - bZ;
      });

      sortedElements.forEach(el => {
        drawElement(el, el === selectedElement);
      });

      // Draw link mode overlay: highlight pending elements and connection lines
      if (lockMode && lockPendingElements.size > 0) {
        const pendingEls = [...lockPendingElements]
          .map(id => elements.find(e => e.id === id))
          .filter(Boolean);

        // Draw highlight border on each pending element
        pendingEls.forEach(el => {
          const px = el.x;
          const py = el.y;
          const pw = el.width * pixelsPerFoot;
          const ph = el.height * pixelsPerFoot;

          ctx.save();
          ctx.translate(px + pw/2, py + ph/2);
          ctx.rotate((el.rotation || 0) * Math.PI / 180);
          ctx.translate(-(px + pw/2), -(py + ph/2));

          // Cyan dashed border
          ctx.strokeStyle = '#22d3ee';
          ctx.lineWidth = 3;
          ctx.setLineDash([8, 4]);
          ctx.strokeRect(px, py, pw, ph);
          ctx.setLineDash([]);

          // Number badge in top-left corner
          const idx = pendingEls.indexOf(el) + 1;
          const badgeSize = 18;
          ctx.fillStyle = 'rgba(34, 211, 238, 0.9)';
          ctx.beginPath();
          ctx.arc(px + badgeSize/2 + 4, py + badgeSize/2 + 4, badgeSize/2, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = '#000';
          ctx.font = 'bold 11px Inter';
          ctx.textAlign = 'center';
          ctx.fillText(String(idx), px + badgeSize/2 + 4, py + badgeSize/2 + 8);

          ctx.restore();
        });

        // Draw connection lines between pending elements
        if (pendingEls.length >= 2) {
          ctx.save();
          ctx.strokeStyle = 'rgba(34, 211, 238, 0.5)';
          ctx.lineWidth = 2;
          ctx.setLineDash([6, 4]);

          for (let i = 0; i < pendingEls.length - 1; i++) {
            const a = pendingEls[i];
            const b = pendingEls[i + 1];
            const ax = a.x + (a.width * pixelsPerFoot) / 2;
            const ay = a.y + (a.height * pixelsPerFoot) / 2;
            const bx = b.x + (b.width * pixelsPerFoot) / 2;
            const by = b.y + (b.height * pixelsPerFoot) / 2;
            ctx.beginPath();
            ctx.moveTo(ax, ay);
            ctx.lineTo(bx, by);
            ctx.stroke();
          }

          ctx.setLineDash([]);
          ctx.restore();
        }
      }
    }

    // Get element category for visibility toggles
    function getElementCategory(type) {
      const categories = {
        cabinets: ['base-cabinet', 'drawer-base', 'sink-base', 'corner-cabinet', 'lazy-susan', 'blind-corner', 'wall-cabinet', 'tall-cabinet', 'pantry', 'island', 'vanity', 'microwave-cabinet', 'above-microwave-cabinet', 'single-oven-cabinet', 'tall-oven', 'double-oven-cabinet', 'fridge-cabinet'],
        countertops: ['countertop', 'countertop-corner', 'countertop-l', 'countertop-u', 'bar-top', 'wall-cap', 'backsplash', 'surface-stainless', 'surface-solid', 'surface-laminate', 'surface-butcherblock', 'surface-concrete', 'window-sill'],
        appliances: ['refrigerator', 'stove', 'range', 'slide-in-range', 'cooktop', 'oven', 'wall-oven-double', 'dishwasher', 'microwave', 'range-hood'],
        sinks: ['sink', 'sink-double', 'sink-farmhouse'],
        flooring: ['flooring', 'tile', 'rug', 'threshold'],
        walls: ['wall', 'wall-block', 'wall-concrete', 'wall-framed', 'wall-wood-2x4', 'wall-wood-2x6', 'wall-brick', 'wall-steel', 'wall-aluminum', 'pony-wall', 'pony-wall-bar', 'knee-wall', 'shower-wall', 'wall-tile', 'accent-wall'],
        windows: ['window', 'window-large', 'bay-window', 'picture-window'],
        doors: ['door', 'double-door', 'sliding-door', 'french-door', 'glass-door', 'entry-archway', 'garage-door'],
        niches: ['wall-niche', 'shower-niche', 'fireplace-niche', 'tv-niche', 'niche-surround'],
        fixtures: ['toilet', 'toilet-round', 'toilet-wall', 'bidet', 'bathtub', 'bathtub-freestanding', 'bathtub-corner', 'bathtub-walk-in', 'shower', 'shower-base-36', 'shower-base-48', 'shower-base-60', 'grab-bar', 'grab-bar-24', 'grab-bar-36', 'grab-bar-42', 'shower-pan', 'shower-curb', 'shower-bench', 'towel-warmer'],
        bathroom: ['vanity-24', 'vanity-30', 'vanity-36', 'vanity-48', 'vanity-60', 'vanity-72'],
        laundry: ['washer', 'dryer', 'washer-dryer-stack', 'laundry-cabinet', 'ironing-board', 'utility-sink', 'laundry-sink', 'drying-rack'],
        closet: ['closet-rod', 'closet-shelf', 'drawer-unit', 'closet-drawers', 'shoe-rack', 'closet-island', 'jewelry-cabinet', 'jewelry-drawer', 'tie-rack', 'full-mirror'],
        decorative: ['crown-molding', 'mantel', 'fireplace-surround', 'fireplace-hearth', 'niche-surround'],
        structural: ['steel-beam', 'steel-column', 'wood-beam', 'wood-post', 'concrete-beam', 'concrete-column', 'header', 'lvl-beam', 'baseboard', 'chair-rail']
      };

      for (const [category, types] of Object.entries(categories)) {
        if (types.includes(type)) return category;
      }
      return 'other';
    }

    // Track hidden categories
    let hiddenCategories = {};

    function toggleCategoryVisibility(category, visible) {
      if (visible) {
        delete hiddenCategories[category];
      } else {
        hiddenCategories[category] = true;
      }
      draw();
      update3DScene();
    }

    function showAllCategories() {
      hiddenCategories = {};
      // Reset all checkboxes
      document.querySelectorAll('.visibility-toggle input[type="checkbox"]').forEach(cb => {
        cb.checked = true;
      });
      draw();
      update3DScene();
    }

    function hideElement(el) {
      if (el) {
        el.hidden = true;
        if (el === selectedElement) {
          selectedElement = null;
          updateProperties();
        }
        draw();
        update3DScene();
      }
    }

    function showElement(el) {
      if (el) {
        el.hidden = false;
        draw();
        update3DScene();
      }
    }

    // Cache for texture patterns (performance optimization)
    const texturePatternCache = new Map();

    function drawElement(el, isSelected) {
      const x = el.x;
      const y = el.y;
      const w = el.width * pixelsPerFoot;
      const h = el.height * pixelsPerFoot;

      ctx.save();
      ctx.translate(x + w/2, y + h/2);
      ctx.rotate((el.rotation || 0) * Math.PI / 180);
      ctx.translate(-(x + w/2), -(y + h/2));

      // Shadow only for selected elements or when performance allows (optimization)
      const applyShadow = isSelected || elements.length < 50;
      if (applyShadow) {
        ctx.shadowColor = 'rgba(0,0,0,0.35)';
        ctx.shadowBlur = isSelected ? 12 : 8;
        ctx.shadowOffsetX = 3;
        ctx.shadowOffsetY = 3;
      }

      // Draw base shape with texture or color (skip for L/U shaped - they draw their own shape)
      const isLOrUShape = el.type === 'countertop-l' || el.type === 'countertop-u';
      if (!isLOrUShape) {
        if (el.textureImg) {
          ctx.save();
          ctx.beginPath();
          ctx.rect(x, y, w, h);
          ctx.clip();

          const imgW = el.textureImg.naturalWidth || el.textureImg.width;
          const imgH = el.textureImg.naturalHeight || el.textureImg.height;

          if (imgW > 0 && imgH > 0) {
            // Use cached pattern for performance (much faster than nested loops)
            const cacheKey = `${el.texture || el.textureImg.src}_${pixelsPerFoot}`;
            let pattern = texturePatternCache.get(cacheKey);

            if (!pattern) {
              // Create scaled texture canvas for pattern
              const slabWidthPx = 10 * pixelsPerFoot;
              const drawW = Math.max(w, slabWidthPx);
              const drawH = drawW * (imgH / imgW);

              const patternCanvas = document.createElement('canvas');
              patternCanvas.width = drawW;
              patternCanvas.height = drawH;
              const patternCtx = patternCanvas.getContext('2d');
              patternCtx.drawImage(el.textureImg, 0, 0, drawW, drawH);

              pattern = ctx.createPattern(patternCanvas, 'repeat');
              texturePatternCache.set(cacheKey, pattern);

              // Limit cache size
              if (texturePatternCache.size > 100) {
                const firstKey = texturePatternCache.keys().next().value;
                texturePatternCache.delete(firstKey);
              }
            }

            if (pattern) {
              ctx.fillStyle = pattern;
              ctx.fillRect(x, y, w, h);
            } else {
              ctx.drawImage(el.textureImg, x, y, w, h);
            }
          } else {
            ctx.drawImage(el.textureImg, x, y, w, h);
          }
          ctx.restore();
        } else {
          ctx.fillStyle = el.color;
          ctx.fillRect(x, y, w, h);
        }
      }

      // Reset shadow using proper rgba value
      ctx.shadowColor = 'rgba(0,0,0,0)';
      ctx.shadowBlur = 0;
      ctx.shadowOffsetX = 0;
      ctx.shadowOffsetY = 0;

      // Draw architectural details based on element type
      drawElementDetails(el, x, y, w, h);

      // Border (skip for L/U shaped - they draw their own outline)
      // Locked/grouped elements show a subtle indicator
      const isLocked = el.groupId !== undefined;

      if (!isLOrUShape) {
        ctx.strokeStyle = isSelected ? '#6366f1' : (isLocked ? 'rgba(99, 102, 241, 0.5)' : 'rgba(255,255,255,0.3)');
        ctx.lineWidth = isSelected ? 3 : 1.5;
        ctx.strokeRect(x, y, w, h);
      } else if (isSelected) {
        // Draw L-shape selection outline
        const armWidthFt = el.armWidth || 2.17;
        const armPx = armWidthFt * pixelsPerFoot;
        ctx.strokeStyle = '#6366f1';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x + w, y);
        ctx.lineTo(x + w, y + armPx);
        ctx.lineTo(x + armPx, y + armPx);
        ctx.lineTo(x + armPx, y + h);
        ctx.lineTo(x, y + h);
        ctx.closePath();
        ctx.stroke();
      }

      // Group indicator for grouped elements
      if (el.groupId) {
        // Generate consistent color from group ID
        const groupColors = ['#22d3ee', '#f472b6', '#a78bfa', '#4ade80', '#fb923c', '#f87171'];
        const groupIndex = parseInt(el.groupId.replace('group-', ''), 10) || 0;
        const groupColor = groupColors[groupIndex % groupColors.length];

        // Draw group indicator badge in top-left corner
        const badgeSize = 14;
        const badgeX = x + 3;
        const badgeY = y + 3;

        ctx.fillStyle = groupColor;
        ctx.beginPath();
        ctx.arc(badgeX + badgeSize/2, badgeY + badgeSize/2, badgeSize/2, 0, Math.PI * 2);
        ctx.fill();

        // Link icon in badge
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 8px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('G', badgeX + badgeSize/2, badgeY + badgeSize/2 + 1);

        // Thin colored border around element when grouped
        if (!isSelected) {
          ctx.strokeStyle = groupColor;
          ctx.lineWidth = 2;
          ctx.setLineDash([4, 2]);
          ctx.strokeRect(x + 1, y + 1, w - 2, h - 2);
          ctx.setLineDash([]);
        }
      }

      // Only show label if element is large enough or selected
      const showLabel = w > 60 || h > 60 || isSelected;
      if (showLabel) {
        // Get display label with fallback
        const typeName = el.type ? el.type.replace(/-/g, ' ').replace(/\b\w/g, c => c.toUpperCase()) : '';
        const displayLabel = el.label || typeName || 'Element';
        const labelFontSize = Math.max(9, Math.min(14, pixelsPerFoot / 3));
        ctx.font = `${labelFontSize}px Inter`;
        const labelWidth = ctx.measureText(displayLabel).width + 8;

        // Label background
        ctx.fillStyle = 'rgba(0,0,0,0.6)';
        ctx.fillRect(x + w/2 - labelWidth/2, y + h - labelFontSize - 8, labelWidth, labelFontSize + 4);

        // Label text
        ctx.fillStyle = 'rgba(255,255,255,0.95)';
        ctx.textAlign = 'center';
        ctx.fillText(displayLabel, x + w/2, y + h - 6);
      }

      // Dimensions  always show on elements large enough, highlighted when selected
      const dimFontSize = Math.max(9, Math.min(12, pixelsPerFoot / 4));
      if (isSelected) {
        ctx.fillStyle = '#6366f1';
        ctx.font = `bold ${dimFontSize + 2}px Inter`;
        ctx.textAlign = 'center';
        ctx.fillText(formatSize(el.width, el.height), x + w/2, y - 8);
      } else if (w > 50 && h > 30) {
        // Compact inline dimension on non-selected elements
        const dimText = formatSize(el.width, el.height);
        ctx.font = `${dimFontSize}px Inter`;
        const dimW = ctx.measureText(dimText).width + 6;
        ctx.fillStyle = 'rgba(0,0,0,0.5)';
        ctx.fillRect(x + w/2 - dimW/2, y + 2, dimW, dimFontSize + 3);
        ctx.fillStyle = 'rgba(255,255,255,0.75)';
        ctx.textAlign = 'center';
        ctx.fillText(dimText, x + w/2, y + dimFontSize + 1);
      }

      // Material hover/drop highlight overlay
      const isMaterialHover = (materialHoverElement === el.id || materialDropHighlight === el.id);
      if (isMaterialHover) {
        ctx.save();
        ctx.globalAlpha = 0.3;
        ctx.fillStyle = '#f9cb00';
        if (!isLOrUShape) {
          ctx.fillRect(x, y, w, h);
        }
        ctx.globalAlpha = 1;
        ctx.strokeStyle = '#f9cb00';
        ctx.lineWidth = 3;
        ctx.setLineDash([6, 4]);
        if (!isLOrUShape) {
          ctx.strokeRect(x, y, w, h);
        }
        ctx.setLineDash([]);
        ctx.restore();
      }

      // Lock icon (drawn in rotated context)
      if (isSelected && el.locked) {
        ctx.fillStyle = 'rgba(239, 68, 68, 0.9)';
        ctx.font = '14px Inter';
        ctx.fillText('', x + w - 12, y + 16);
      }

      // Restore context BEFORE drawing handles (handles use world coordinates)
      ctx.restore();

      // Selection handles (8 handles for resize) - drawn in world space
      if (isSelected && !el.locked) {
        const hs = HANDLE_SIZE;
        ctx.fillStyle = '#6366f1';
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;

        // Get all 8 handle positions (already in world coordinates with rotation applied)
        const handles = getResizeHandles(el);
        Object.values(handles).forEach(handle => {
          ctx.fillRect(handle.x - hs/2, handle.y - hs/2, hs, hs);
          ctx.strokeRect(handle.x - hs/2, handle.y - hs/2, hs, hs);
        });
      }

      // Locked element handles - drawn in world space
      if (isSelected && el.locked) {
        const hs = HANDLE_SIZE;
        ctx.fillStyle = '#ef4444';
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        // Use rotated handle positions for locked elements too
        const handles = getResizeHandles(el);
        [handles.nw, handles.ne, handles.sw, handles.se].forEach(handle => {
          ctx.fillRect(handle.x - hs/2, handle.y - hs/2, hs, hs);
          ctx.strokeRect(handle.x - hs/2, handle.y - hs/2, hs, hs);
        });
      }

      // Edge preview indicator for countertops - pulsing dot on front edge
      if (isSelected && (el.type === 'countertop' || el.type === 'countertop-l' || el.type === 'countertop-u')) {
        const rotation = (el.rotation || 0) * Math.PI / 180;
        const cx = x + w / 2;
        const cy = y + h / 2;

        // Calculate indicator position on front edge (bottom of countertop in 2D)
        // Rotate the point based on element rotation
        let indicatorX = cx;
        let indicatorY = y + h + 15; // Below the front edge

        if (rotation !== 0) {
          // Rotate indicator position around center
          const dx = indicatorX - cx;
          const dy = indicatorY - cy;
          indicatorX = cx + dx * Math.cos(rotation) - dy * Math.sin(rotation);
          indicatorY = cy + dx * Math.sin(rotation) + dy * Math.cos(rotation);
        }

        // Store indicator position for click detection
        el._edgeIndicator = { x: indicatorX, y: indicatorY, radius: 14 };

        // Pulsing animation
        const pulse = (Math.sin(Date.now() / 300) + 1) / 2; // 0 to 1
        const baseRadius = 10;
        const pulseRadius = baseRadius + pulse * 4;

        // Outer glow
        const gradient = ctx.createRadialGradient(indicatorX, indicatorY, 0, indicatorX, indicatorY, pulseRadius + 8);
        gradient.addColorStop(0, 'rgba(99, 102, 241, 0.8)');
        gradient.addColorStop(0.5, 'rgba(99, 102, 241, 0.3)');
        gradient.addColorStop(1, 'rgba(99, 102, 241, 0)');
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(indicatorX, indicatorY, pulseRadius + 8, 0, Math.PI * 2);
        ctx.fill();

        // Main indicator dot
        ctx.fillStyle = '#6366f1';
        ctx.beginPath();
        ctx.arc(indicatorX, indicatorY, baseRadius, 0, Math.PI * 2);
        ctx.fill();

        // White border
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.stroke();

        // Eye icon inside
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 10px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('', indicatorX, indicatorY);

        // Label
        ctx.fillStyle = 'rgba(99, 102, 241, 0.9)';
        ctx.font = '10px Inter, sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('Edge', indicatorX, indicatorY + 22);
      }
    }

    // ===== RESIZE HANDLES =====
    function getResizeHandles(el) {
      const x = el.x;
      const y = el.y;
      const w = el.width * pixelsPerFoot;
      const h = el.height * pixelsPerFoot;
      const rotation = (el.rotation || 0) * Math.PI / 180;
      const cx = x + w / 2;
      const cy = y + h / 2;

      // Helper to rotate a point around the center
      function rotatePoint(px, py) {
        if (rotation === 0) return { x: px, y: py };
        const dx = px - cx;
        const dy = py - cy;
        const cosR = Math.cos(rotation);
        const sinR = Math.sin(rotation);
        return {
          x: cx + dx * cosR - dy * sinR,
          y: cy + dx * sinR + dy * cosR
        };
      }

      // Get rotated handle positions
      const nw = rotatePoint(x, y);
      const n = rotatePoint(x + w/2, y);
      const ne = rotatePoint(x + w, y);
      const e = rotatePoint(x + w, y + h/2);
      const se = rotatePoint(x + w, y + h);
      const s = rotatePoint(x + w/2, y + h);
      const sw = rotatePoint(x, y + h);
      const west = rotatePoint(x, y + h/2);

      return {
        nw: { ...nw, cursor: 'nwse-resize' },
        n:  { ...n, cursor: 'ns-resize' },
        ne: { ...ne, cursor: 'nesw-resize' },
        e:  { ...e, cursor: 'ew-resize' },
        se: { ...se, cursor: 'nwse-resize' },
        s:  { ...s, cursor: 'ns-resize' },
        sw: { ...sw, cursor: 'nesw-resize' },
        w:  { ...west, cursor: 'ew-resize' }
      };
    }

    function getHandleAtPosition(el, worldX, worldY) {
      if (!el || el.locked) return null;

      const handles = getResizeHandles(el);
      const hs = HANDLE_SIZE + 4; // Slightly larger hit area

      for (const [name, handle] of Object.entries(handles)) {
        if (worldX >= handle.x - hs/2 && worldX <= handle.x + hs/2 &&
            worldY >= handle.y - hs/2 && worldY <= handle.y + hs/2) {
          return { name, ...handle };
        }
      }
      return null;
    }

    function getCursorForHandle(handleName) {
      const cursors = {
        nw: 'nwse-resize',
        n: 'ns-resize',
        ne: 'nesw-resize',
        e: 'ew-resize',
        se: 'nwse-resize',
        s: 'ns-resize',
        sw: 'nesw-resize',
        w: 'ew-resize'
      };
      return cursors[handleName] || 'default';
    }

    function applyResize(el, handle, dx, dy) {
      // Transform world-space delta to local-space delta based on rotation
      const rotation = (el.rotation || 0) * Math.PI / 180;
      let localDx = dx;
      let localDy = dy;

      if (rotation !== 0) {
        const cosR = Math.cos(-rotation);
        const sinR = Math.sin(-rotation);
        localDx = dx * cosR - dy * sinR;
        localDy = dx * sinR + dy * cosR;
      }

      // Convert pixel delta to feet
      const dxFeet = localDx / pixelsPerFoot;
      const dyFeet = localDy / pixelsPerFoot;

      // Minimum size in feet
      const minSize = 0.5;

      // Calculate fixed edges (the edges that should NOT move)
      // For each resize, we anchor from the opposite edge
      const originalRight = resizeStart.elX + resizeStart.width * pixelsPerFoot;
      const originalBottom = resizeStart.elY + resizeStart.height * pixelsPerFoot;
      const originalLeft = resizeStart.elX;
      const originalTop = resizeStart.elY;

      // Apply resize based on which handle is being dragged
      // Each case anchors the opposite edge(s) to stay fixed
      switch(handle) {
        case 'nw': // Anchor bottom-right corner
          el.width = Math.max(minSize, resizeStart.width - dxFeet);
          el.height = Math.max(minSize, resizeStart.height - dyFeet);
          break;

        case 'n': // Anchor bottom edge
          el.height = Math.max(minSize, resizeStart.height - dyFeet);
          break;

        case 'ne': // Anchor bottom-left corner
          el.width = Math.max(minSize, resizeStart.width + dxFeet);
          el.height = Math.max(minSize, resizeStart.height - dyFeet);
          break;

        case 'e': // Anchor left edge
          el.width = Math.max(minSize, resizeStart.width + dxFeet);
          break;

        case 'se': // Anchor top-left corner
          el.width = Math.max(minSize, resizeStart.width + dxFeet);
          el.height = Math.max(minSize, resizeStart.height + dyFeet);
          break;

        case 's': // Anchor top edge
          el.height = Math.max(minSize, resizeStart.height + dyFeet);
          break;

        case 'sw': // Anchor top-right corner
          el.width = Math.max(minSize, resizeStart.width - dxFeet);
          el.height = Math.max(minSize, resizeStart.height + dyFeet);
          break;

        case 'w': // Anchor right edge
          el.width = Math.max(minSize, resizeStart.width - dxFeet);
          break;
      }

      // Smart snap to standard dimensions if close, otherwise round to 1/16"
      el.width = snapToStandard(el.width, 'width');
      el.height = snapToStandard(el.height, 'depth');
      el.width = roundToSixteenth(el.width);
      el.height = roundToSixteenth(el.height);

      // NOW recalculate position to keep the anchored edge fixed AFTER snapping
      // This ensures the opposite edge doesn't move when we snap to standard sizes
      switch(handle) {
        case 'nw': // Keep bottom-right fixed
          el.x = originalRight - el.width * pixelsPerFoot;
          el.y = originalBottom - el.height * pixelsPerFoot;
          break;

        case 'n': // Keep bottom fixed
          el.y = originalBottom - el.height * pixelsPerFoot;
          break;

        case 'ne': // Keep bottom-left fixed, x stays at originalLeft
          el.x = originalLeft;
          el.y = originalBottom - el.height * pixelsPerFoot;
          break;

        case 'e': // Keep left fixed
          el.x = originalLeft;
          break;

        case 'se': // Keep top-left fixed
          el.x = originalLeft;
          el.y = originalTop;
          break;

        case 's': // Keep top fixed
          el.y = originalTop;
          break;

        case 'sw': // Keep top-right fixed
          el.x = originalRight - el.width * pixelsPerFoot;
          el.y = originalTop;
          break;

        case 'w': // Keep right fixed
          el.x = originalRight - el.width * pixelsPerFoot;
          break;
      }

      // Show snap indicator if snapped to standard
      const suggested = getSuggestedSize(el.type);
      if (suggested && Math.abs(el.width - suggested.width) < 0.01 && Math.abs(el.height - suggested.height) < 0.01) {
        showSnapFeedback(suggested.note);
      }
    }

    // Show brief feedback when snapping to standard
    function showSnapFeedback(message) {
      const hint = document.querySelector('.material-hint');
      if (hint) {
        const original = hint.innerHTML;
        const isSnap = message.toLowerCase().startsWith('snapped') || message.toLowerCase().startsWith('corner snap');
        hint.innerHTML = isSnap ? ` Snapped to: ${message}` : message;
        hint.style.borderColor = 'var(--success)';
        setTimeout(() => {
          hint.innerHTML = original;
          hint.style.borderColor = 'var(--border)';
        }, 1500);
      }
    }

    // ===== MOUSE EVENTS =====
    // Convert screen coordinates to world coordinates (accounting for pan)
    function screenToWorld(screenX, screenY) {
      return {
        x: screenX - panX,
        y: screenY - panY
      };
    }

    function onMouseDown(e) {
      // Ignore right-click - let context menu handle it
      if (e.button === 2) {
        return;
      }

      const rect = canvas.getBoundingClientRect();
      const screenX = e.clientX - rect.left;
      const screenY = e.clientY - rect.top;
      const { x, y } = screenToWorld(screenX, screenY);

      // Check for edge indicator click on selected countertop
      if (selectedElement && selectedElement._edgeIndicator) {
        const ind = selectedElement._edgeIndicator;
        const dist = Math.sqrt((x - ind.x) ** 2 + (y - ind.y) ** 2);
        if (dist <= ind.radius + 5) {
          showEdgePreviewModal(selectedElement);
          return;
        }
      }

      // Check for seam placement mode click
      if (seamPlacementMode && handleSeamPlacementClick(e)) {
        return;
      }

      // Check for room resize handle click (only in select mode)
      if (currentTool === 'select') {
        const roomHandle = getRoomHandleAtPosition(x, y);
        if (roomHandle) {
          isResizingRoom = true;
          roomResizeHandle = roomHandle.name;
          roomResizeStart = {
            x: x,
            y: y,
            width: roomWidth,
            depth: roomDepth
          };
          canvas.style.cursor = roomHandle.cursor;
          return;
        }
      }

      // Pan tool or middle mouse button (unless view is locked)
      if ((currentTool === 'pan' || e.button === 1) && !viewLocked) {
        isPanning = true;
        panStart = { x: screenX - panX, y: screenY - panY };
        canvas.style.cursor = 'grabbing';
        e.preventDefault();
        return;
      }

      // Space + drag to pan (unless view is locked)
      if (spacePressed && !viewLocked) {
        isPanning = true;
        panStart = { x: screenX - panX, y: screenY - panY };
        return;
      }

      if (currentTool === 'wall') {
        isDrawingWall = true;
        wallStart = { x, y };
        return;
      }

      if (currentTool === 'countertop') {
        isDrawingCountertop = true;
        countertopStart = { x, y };
        return;
      }

      if (currentTool === 'layout') {
        startLayoutDraw(x, y);
        return;
      }

      if (currentTool !== 'select') return;

      // Check if clicking on a resize handle of selected element
      if (selectedElement && !selectedElement.locked) {
        const handle = getHandleAtPosition(selectedElement, x, y);
        if (handle) {
          isResizing = true;
          resizeHandle = handle.name;
          resizeStart = {
            x: x,
            y: y,
            width: selectedElement.width,
            height: selectedElement.height,
            elX: selectedElement.x,
            elY: selectedElement.y
          };
          canvas.style.cursor = getCursorForHandle(handle.name);
          return;
        }
      }

      // Get ALL elements at this position (for cycling)
      const elementsAtPoint = [...elements].reverse().filter(el => isPointInElement(x, y, el));

      if (elementsAtPoint.length > 0) {
        const now = Date.now();
        const sameSpot = Math.abs(x - lastClickPos.x) < CLICK_CYCLE_THRESHOLD &&
                         Math.abs(y - lastClickPos.y) < CLICK_CYCLE_THRESHOLD;
        const quickClick = (now - lastClickTime) < CLICK_CYCLE_TIME;

        // Cycle through overlapping elements if clicking same spot quickly
        if (sameSpot && quickClick && elementsAtPoint.length > 1) {
          cycleIndex = (cycleIndex + 1) % elementsAtPoint.length;
          showSnapFeedback(`Element ${cycleIndex + 1} of ${elementsAtPoint.length} at this position`);
        } else {
          cycleIndex = 0;
        }

        lastClickPos = { x, y };
        lastClickTime = now;

        const clicked = elementsAtPoint[cycleIndex];

        // If a material is selected, apply it to the clicked element
        if (selectedMaterial) {
          const applied = applyMaterialToElement(clicked);
          if (applied) {
            selectedElement = clicked;
            updateProperties();
            draw();
          }
          // Always return - either material was applied or error was shown
          return;
        }

        // If a store product is selected, apply it as material
        if (selectedStoreProduct) {
          applyStoreProductToElement(clicked);
          selectedElement = clicked;
          updateProperties();
          draw();
          return;
        }

        // If in lock mode, add/remove clicked element from pending link set
        if (lockMode) {
          completeLock(clicked);
          return;
        }

        selectedElement = clicked;
        updateLockUI();
        if (!clicked.locked) {
          isDragging = true;
          dragOffset = { x: x - clicked.x, y: y - clicked.y };
          autoRotationApplied = false; // Reset auto-rotation tracking for new drag
          lastSnappedWall = null;
        }
        updateProperties();
      } else {
        selectedElement = null;
        // Clicking empty space: finalize link if 2+ elements, otherwise cancel
        if (lockMode) {
          finalizeLockMode();
        }
        cycleIndex = 0;
        updateProperties();
      }

      draw();
    }

    function onMouseMove(e) {
      const rect = canvas.getBoundingClientRect();
      const screenX = e.clientX - rect.left;
      const screenY = e.clientY - rect.top;
      const { x, y } = screenToWorld(screenX, screenY);

      // Handle panning
      if (isPanning) {
        panX = screenX - panStart.x;
        panY = screenY - panStart.y;
        drawThrottled();
        return;
      }

      // Handle room resizing
      if (isResizingRoom && roomResizeHandle) {
        const dx = (x - roomResizeStart.x) / pixelsPerFoot;
        const dy = (y - roomResizeStart.y) / pixelsPerFoot;

        let newWidth = roomResizeStart.width;
        let newDepth = roomResizeStart.depth;

        if (roomResizeHandle === 'e' || roomResizeHandle === 'se') {
          newWidth = Math.max(8, Math.round(roomResizeStart.width + dx));
        }
        if (roomResizeHandle === 's' || roomResizeHandle === 'se') {
          newDepth = Math.max(8, Math.round(roomResizeStart.depth + dy));
        }

        // Update room size
        roomWidth = Math.min(100, newWidth);
        roomDepth = Math.min(100, newDepth);

        // Update UI inputs
        document.getElementById('roomWidth').value = roomWidth;
        document.getElementById('roomDepth').value = roomDepth;

        // Redraw
        if (document.getElementById('scaleMode').value === 'fit') {
          fitToScreen();
        } else {
          updateCanvasSize();
        }
        drawThrottled();
        return;
      }

      // Handle layout brush drawing
      if (currentTool === 'layout' && layoutMode.isDrawing) {
        continueLayoutDraw(x, y);
        return;
      }

      // Handle resizing
      if (isResizing && selectedElement && resizeHandle) {
        const dx = x - resizeStart.x;
        const dy = y - resizeStart.y;
        applyResize(selectedElement, resizeHandle, dx, dy);
        updateProperties();
        drawThrottled();
        return;
      }

      if (isDrawingWall && wallStart) {
        // Preview wall while drawing
        drawThrottled();
        ctx.save();
        ctx.translate(panX, panY);
        ctx.fillStyle = 'rgba(100, 100, 100, 0.5)';
        const wx = Math.min(wallStart.x, x);
        const wy = Math.min(wallStart.y, y);
        const ww = Math.abs(x - wallStart.x) || CONFIG.WALL_THICKNESS;
        const wh = Math.abs(y - wallStart.y) || CONFIG.WALL_THICKNESS;
        ctx.fillRect(wx, wy, ww, wh);
        ctx.restore();
        return;
      }

      if (isDrawingCountertop && countertopStart) {
        // Preview countertop while drawing with measurements
        drawThrottled();
        ctx.save();
        ctx.translate(panX, panY);

        const cx = Math.min(countertopStart.x, x);
        const cy = Math.min(countertopStart.y, y);
        const cw = Math.abs(x - countertopStart.x) || pixelsPerFoot * 2;
        const ch = Math.abs(y - countertopStart.y) || pixelsPerFoot * 2;

        // Draw countertop preview
        ctx.fillStyle = 'rgba(112, 128, 144, 0.6)';
        ctx.fillRect(cx, cy, cw, ch);
        ctx.strokeStyle = '#708090';
        ctx.lineWidth = 2;
        ctx.strokeRect(cx, cy, cw, ch);

        // Show measurements
        const widthFt = (cw / pixelsPerFoot).toFixed(1);
        const depthFt = (ch / pixelsPerFoot).toFixed(1);
        const sqft = (widthFt * depthFt).toFixed(1);

        ctx.fillStyle = '#fff';
        ctx.font = 'bold 14px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(`${widthFt}'  ${depthFt}'`, cx + cw/2, cy + ch/2 - 10);
        ctx.font = '12px Arial';
        ctx.fillText(`${sqft} sq ft`, cx + cw/2, cy + ch/2 + 10);

        ctx.restore();
        return;
      }

      // Material hover preview  highlight element under cursor when a material is selected
      if (selectedMaterial && currentTool === 'select' && !isDragging) {
        const hit = [...elements].reverse().find(el => isPointInElement(x, y, el));
        const newHover = hit ? hit.id : null;
        if (newHover !== materialHoverElement) {
          materialHoverElement = newHover;
          draw();
        }
        canvas.style.cursor = hit ? 'copy' : 'crosshair';
        if (!isDragging && !isResizing) return;
      }

      // Lock mode cursor: show crosshair when hovering elements to add/remove
      if (lockMode && !isDragging && !isResizing) {
        const hovered = [...elements].reverse().find(el => isPointInElement(x, y, el));
        canvas.style.cursor = hovered ? 'cell' : 'default';
        return;
      }

      // Update cursor when hovering over room resize handles
      if (currentTool === 'select' && !isDragging && !isResizing) {
        const roomHandle = getRoomHandleAtPosition(x, y);
        if (roomHandle) {
          canvas.style.cursor = roomHandle.cursor;
          return;
        }
      }

      // Update cursor when hovering over resize handles
      if (selectedElement && !selectedElement.locked && !isDragging) {
        const handle = getHandleAtPosition(selectedElement, x, y);
        if (handle) {
          canvas.style.cursor = getCursorForHandle(handle.name);
        } else if (isPointInElement(x, y, selectedElement)) {
          canvas.style.cursor = 'move';
        } else {
          canvas.style.cursor = 'default';
        }
      }

      if (!isDragging || !selectedElement || selectedElement.locked) return;

      // Hold Shift to disable ALL snapping (completely free placement)
      const freePlace = e.shiftKey;

      if (freePlace) {
        // Completely free movement - no snapping at all
        const newX = x - dragOffset.x;
        const newY = y - dragOffset.y;
        const dx = newX - selectedElement.x;
        const dy = newY - selectedElement.y;

        selectedElement.x = newX;
        selectedElement.y = newY;

        // Mark element as needing 3D update
        markElement3DDirty(selectedElement.id);

        // Move locked elements too
        if (selectedElement.groupId) {
          moveGroupedElements(selectedElement, dx, dy);
        }

        drawThrottled();
        return;
      }

      const gridSnap = pixelsPerFoot / CONFIG.GRID_SUBDIVISIONS;
      let snapX = Math.round((x - dragOffset.x) / gridSnap) * gridSnap;
      let snapY = Math.round((y - dragOffset.y) / gridSnap) * gridSnap;

      // Element-to-element snapping (for placing cabinets together)
      const snapDistance = pixelsPerFoot * 0.4; // Reduced from 0.5 for less aggressive snap
      const elW = selectedElement.width * pixelsPerFoot;
      const elH = selectedElement.height * pixelsPerFoot;

      // Check if this is a cabinet-type element for stricter alignment
      const cabinetTypes = ['base-cabinet', 'drawer-base', 'sink-base', 'wall-cabinet',
                            'tall-cabinet', 'corner-cabinet', 'lazy-susan', 'blind-corner',
                            'island', 'fridge-cabinet', 'single-oven-cabinet', 'tall-oven',
                            'double-oven-cabinet', 'microwave-cabinet', 'above-microwave-cabinet'];

      // Check for sized cabinet variants (base-cabinet-12, wall-cabinet-18, etc.)
      const isCabinetElement = cabinetTypes.includes(selectedElement.type) ||
                               selectedElement.type?.startsWith('base-cabinet-') ||
                               selectedElement.type?.startsWith('wall-cabinet-') ||
                               selectedElement.type?.startsWith('tall-cabinet-') ||
                               selectedElement.type?.startsWith('drawer-base-') ||
                               selectedElement.type?.startsWith('sink-base-');

      // Wall element types - these should ATTRACT cabinets, not repel them
      const wallTypes = ['wall', 'wall-block', 'wall-concrete', 'wall-framed', 'wall-wood-2x4',
                         'wall-wood-2x6', 'wall-brick', 'wall-steel', 'wall-aluminum',
                         'pony-wall', 'pony-wall-bar', 'knee-wall'];

      elements.forEach(other => {
        if (other.id === selectedElement.id) return;

        const otherX = other.x;
        const otherY = other.y;
        const otherW = other.width * pixelsPerFoot;
        const otherH = other.height * pixelsPerFoot;
        const isOtherCabinet = cabinetTypes.includes(other.type) ||
                               other.type?.startsWith('base-cabinet-') ||
                               other.type?.startsWith('wall-cabinet-') ||
                               other.type?.startsWith('tall-cabinet-') ||
                               other.type?.startsWith('drawer-base-') ||
                               other.type?.startsWith('sink-base-');
        const isOtherWall = wallTypes.includes(other.type);

        // WALL ELEMENTS: Cabinets should snap AGAINST walls (back of cabinet to wall surface)
        if (isOtherWall && isCabinetElement) {
          const wallSnapDist = pixelsPerFoot * 0.75; // Generous snap distance for walls

          // Determine wall orientation
          const isVerticalWall = otherH > otherW;

          if (isVerticalWall) {
            // Vertical wall - cabinet can snap to left or right side
            // Snap cabinet's back (left edge) against wall's right face
            if (Math.abs(snapX - (otherX + otherW)) < wallSnapDist) {
              snapX = otherX + otherW; // Cabinet left edge meets wall right edge
            }
            // Snap cabinet's back (right edge) against wall's left face
            if (Math.abs((snapX + elW) - otherX) < wallSnapDist) {
              snapX = otherX - elW; // Cabinet right edge meets wall left edge
            }
          } else {
            // Horizontal wall - cabinet can snap to top or bottom side
            // Snap cabinet's back (top edge) against wall's bottom face
            if (Math.abs(snapY - (otherY + otherH)) < wallSnapDist) {
              snapY = otherY + otherH; // Cabinet top edge meets wall bottom edge
            }
            // Snap cabinet's back (bottom edge) against wall's top face
            if (Math.abs((snapY + elH) - otherY) < wallSnapDist) {
              snapY = otherY - elH; // Cabinet bottom edge meets wall top edge
            }
          }
          return; // Skip regular element snapping for walls
        }

        // Skip walls for regular element-to-element snapping (handled above)
        if (isOtherWall) return;

        // For cabinets, use tighter snap for edge-to-edge (butt joints)
        const edgeSnapDist = isCabinetElement ? pixelsPerFoot * 0.5 : snapDistance;

        // When both are cabinets, use much larger snap distance for forming runs
        const cabinetRunSnapDist = (isCabinetElement && isOtherCabinet) ? pixelsPerFoot * 0.8 : edgeSnapDist;

        // Snap right edge of selected to left edge of other (place side by side)
        if (Math.abs((snapX + elW) - otherX) < cabinetRunSnapDist) {
          snapX = otherX - elW;
          // Only align Y if already close (within 0.3ft) - don't force alignment
          if (isCabinetElement && isOtherCabinet && Math.abs(snapY - otherY) < pixelsPerFoot * 0.3) {
            snapY = otherY;
          }
        }
        // Snap left edge of selected to right edge of other
        if (Math.abs(snapX - (otherX + otherW)) < cabinetRunSnapDist) {
          snapX = otherX + otherW;
          // Only align Y if already close (within 0.3ft) - don't force alignment
          if (isCabinetElement && isOtherCabinet && Math.abs(snapY - otherY) < pixelsPerFoot * 0.3) {
            snapY = otherY;
          }
        }
        // Snap bottom edge of selected to top edge of other (vertical cabinet runs)
        // Use cabinetRunSnapDist for cabinet-to-cabinet vertical runs (left/right walls)
        const verticalSnapDist = (isCabinetElement && isOtherCabinet) ? cabinetRunSnapDist : edgeSnapDist;
        if (Math.abs((snapY + elH) - otherY) < verticalSnapDist) {
          snapY = otherY - elH;
          // Align X (backs) when forming vertical cabinet runs
          if (isCabinetElement && isOtherCabinet && Math.abs(snapX - otherX) < pixelsPerFoot * 0.3) {
            snapX = otherX;
          }
        }
        // Snap top edge of selected to bottom edge of other
        if (Math.abs(snapY - (otherY + otherH)) < verticalSnapDist) {
          snapY = otherY + otherH;
          // Align X (backs) when forming vertical cabinet runs
          if (isCabinetElement && isOtherCabinet && Math.abs(snapX - otherX) < pixelsPerFoot * 0.3) {
            snapX = otherX;
          }
        }

        // Align tops when close (for cabinet runs along a wall)
        if (Math.abs(snapY - otherY) < snapDistance) {
          snapY = otherY;
        }
        // Align bottoms when close
        if (Math.abs((snapY + elH) - (otherY + otherH)) < snapDistance) {
          snapY = otherY + otherH - elH;
        }
        // Align lefts when close
        if (Math.abs(snapX - otherX) < snapDistance) {
          snapX = otherX;
        }
        // Align rights when close
        if (Math.abs((snapX + elW) - (otherX + otherW)) < snapDistance) {
          snapX = otherX + otherW - elW;
        }

        // === CABINET RUN BACK ALIGNMENT ===
        // When placing cabinets in a run, align their backs (wall-facing edge)
        // This ensures a straight cabinet run even with different depth cabinets
        if (isCabinetElement && isOtherCabinet) {
          // Check if we're placing cabinets side by side (horizontally adjacent)
          const isHorizontallyAdjacent = Math.abs((snapX + elW) - otherX) < pixelsPerFoot * 0.2 ||
                                          Math.abs(snapX - (otherX + otherW)) < pixelsPerFoot * 0.2;

          // Check if we're placing cabinets vertically adjacent
          const isVerticallyAdjacent = Math.abs((snapY + elH) - otherY) < pixelsPerFoot * 0.2 ||
                                        Math.abs(snapY - (otherY + otherH)) < pixelsPerFoot * 0.2;

          if (isHorizontallyAdjacent) {
            // Align backs (top edge in 2D = back wall in 3D for back wall cabinets)
            // If other cabinet is near top wall, align our top to theirs
            if (otherY < pixelsPerFoot * 0.5 && Math.abs(snapY - otherY) < pixelsPerFoot * 0.5) {
              snapY = otherY; // Align backs at wall
            }
            // If other cabinet is near bottom wall, align our bottoms
            const roomBottom = roomDepth * pixelsPerFoot;
            if (otherY + otherH > roomBottom - pixelsPerFoot * 0.5 &&
                Math.abs((snapY + elH) - (otherY + otherH)) < pixelsPerFoot * 0.5) {
              snapY = otherY + otherH - elH; // Align fronts at wall
            }
          }

          if (isVerticallyAdjacent) {
            // Align backs for side wall cabinet runs
            // If other cabinet is near left wall, align our lefts
            if (otherX < pixelsPerFoot * 0.5 && Math.abs(snapX - otherX) < pixelsPerFoot * 0.5) {
              snapX = otherX; // Align backs at left wall
            }
            // If other cabinet is near right wall, align our rights
            const roomRight = roomWidth * pixelsPerFoot;
            if (otherX + otherW > roomRight - pixelsPerFoot * 0.5 &&
                Math.abs((snapX + elW) - (otherX + otherW)) < pixelsPerFoot * 0.5) {
              snapX = otherX + otherW - elW; // Align backs at right wall
            }
          }
        }
      });

      // Wall snapping for cabinets and countertops
      const wallSnapDistance = pixelsPerFoot * 0.5; // Snap within 0.5 feet of walls (reduced for less aggressive snap)
      const isCabinetType = ['base-cabinet', 'wall-cabinet', 'tall-cabinet', 'corner-cabinet',
                             'drawer-base', 'sink-base', 'lazy-susan',
                             'island', 'countertop', 'sink', 'stove', 'dishwasher',
                             'refrigerator', 'oven'].includes(selectedElement.type);

      // Track which wall we're snapping to for auto-rotation
      let snappedToWall = null;

      if (isCabinetType) {
        // Room boundary walls (in pixels)
        const roomLeftWall = 0;
        const roomTopWall = 0; // Back wall in 3D view
        const roomRightWall = roomWidth * pixelsPerFoot;
        const roomBottomWall = roomDepth * pixelsPerFoot;

        // Snap to back wall (top of 2D canvas = back wall in 3D)
        if (Math.abs(snapY - roomTopWall) < wallSnapDistance) {
          snapY = roomTopWall;
          snappedToWall = 'back';
        }

        // Snap to left wall
        if (Math.abs(snapX - roomLeftWall) < wallSnapDistance) {
          snapX = roomLeftWall;
          snappedToWall = 'left';
        }

        // Snap to right wall (right edge of element to wall)
        if (Math.abs((snapX + elW) - roomRightWall) < wallSnapDistance) {
          snapX = roomRightWall - elW;
          snappedToWall = 'right';
        }

        // Snap to front (bottom edge in 2D - not usually needed but available)
        if (Math.abs((snapY + elH) - roomBottomWall) < wallSnapDistance) {
          snapY = roomBottomWall - elH;
          snappedToWall = 'front';
        }

        // Auto-rotate cabinets so their FRONT (doors) faces INTO the room
        // Only rotate when element is actually AT the wall (distance < 0.1 ft = ~1 inch)
        const autoRotateTypes = ['base-cabinet', 'wall-cabinet', 'tall-cabinet', 'drawer-base', 'sink-base',
                                  'sink', 'stove', 'dishwasher', 'oven'];
        // Note: refrigerator removed from auto-rotate - users can place it any direction

        // Check if element is actually touching the wall (not just near it)
        const touchingWall = (snappedToWall === 'back' && snapY === 0) ||
                             (snappedToWall === 'left' && snapX === 0) ||
                             (snappedToWall === 'right' && Math.abs((snapX + elW) - roomRightWall) < 1) ||
                             (snappedToWall === 'front' && Math.abs((snapY + elH) - roomBottomWall) < 1);

        // Only apply rotation if this is a NEW wall snap AND element is touching
        if (snappedToWall && snappedToWall !== lastSnappedWall && touchingWall && autoRotateTypes.includes(selectedElement.type)) {
          lastSnappedWall = snappedToWall;

          // Cabinet BACK goes against wall, FRONT (doors) faces into room
          // rotation=0: front faces DOWN, rotation=90: front faces LEFT
          // rotation=180: front faces UP, rotation=270: front faces RIGHT
          let targetRotation;
          switch(snappedToWall) {
            case 'back':
              targetRotation = 0;
              break;
            case 'left':
              targetRotation = 270;
              break;
            case 'right':
              targetRotation = 90;
              break;
            case 'front':
              targetRotation = 180;
              break;
            default:
              targetRotation = selectedElement.rotation || 0;
          }

          selectedElement.rotation = targetRotation;
          showSnapFeedback(`Snapped to ${snappedToWall} wall`);
        } else if (!snappedToWall) {
          // Reset when not snapped to any wall
          lastSnappedWall = null;
        }

        // Snap to custom drawn walls - cabinets snap AGAINST walls (like magnets attracting)
        walls.forEach(wall => {
          const wallLeft = wall.x;
          const wallTop = wall.y;
          const wallRight = wall.x + wall.width;
          const wallBottom = wall.y + wall.height;
          const wallCenterX = wallLeft + wall.width / 2;
          const wallCenterY = wallTop + wall.height / 2;

          // Determine if wall is horizontal or vertical based on aspect ratio
          const isVerticalWall = wall.height > wall.width;

          // Calculate element center
          const elCenterX = snapX + elW / 2;
          const elCenterY = snapY + elH / 2;

          if (isVerticalWall) {
            // Vertical wall - snap cabinet against whichever side is closer
            const distToLeftSide = Math.abs(snapX - wallRight); // Cabinet left to wall right
            const distToRightSide = Math.abs((snapX + elW) - wallLeft); // Cabinet right to wall left

            if (elCenterX < wallCenterX) {
              // Cabinet is to the left of wall - snap cabinet's right edge to wall's left edge
              if (distToRightSide < wallSnapDistance) {
                snapX = wallLeft - elW;
              }
            } else {
              // Cabinet is to the right of wall - snap cabinet's left edge to wall's right edge
              if (distToLeftSide < wallSnapDistance) {
                snapX = wallRight;
              }
            }
          } else {
            // Horizontal wall - snap cabinet against whichever side is closer
            const distToTopSide = Math.abs(snapY - wallBottom); // Cabinet top to wall bottom
            const distToBottomSide = Math.abs((snapY + elH) - wallTop); // Cabinet bottom to wall top

            if (elCenterY < wallCenterY) {
              // Cabinet is above wall - snap cabinet's bottom edge to wall's top edge
              if (distToBottomSide < wallSnapDistance) {
                snapY = wallTop - elH;
              }
            } else {
              // Cabinet is below wall - snap cabinet's top edge to wall's bottom edge
              if (distToTopSide < wallSnapDistance) {
                snapY = wallBottom;
              }
            }
          }
        });

        // Special corner snap for corner cabinets and lazy-susan
        const isCornerCabinet = ['corner-cabinet', 'lazy-susan'].includes(selectedElement.type);
        if (isCornerCabinet) {
          const cornerSnapDistance = pixelsPerFoot * 1.0; // Larger snap distance for corners

          // Check if near top-left corner (back-left in 3D)
          if (Math.abs(snapX - roomLeftWall) < cornerSnapDistance &&
              Math.abs(snapY - roomTopWall) < cornerSnapDistance) {
            snapX = roomLeftWall;
            snapY = roomTopWall;
            selectedElement.rotation = 0; // L opens toward front-right
            showSnapFeedback('Corner Snap: Back-Left');
          }
          // Check if near top-right corner (back-right in 3D)
          else if (Math.abs((snapX + elW) - roomRightWall) < cornerSnapDistance &&
                   Math.abs(snapY - roomTopWall) < cornerSnapDistance) {
            snapX = roomRightWall - elW;
            snapY = roomTopWall;
            selectedElement.rotation = 270; // L opens toward front-left
            showSnapFeedback('Corner Snap: Back-Right');
          }
          // Check if near bottom-left corner (front-left in 3D)
          else if (Math.abs(snapX - roomLeftWall) < cornerSnapDistance &&
                   Math.abs((snapY + elH) - roomBottomWall) < cornerSnapDistance) {
            snapX = roomLeftWall;
            snapY = roomBottomWall - elH;
            selectedElement.rotation = 90; // L opens toward back-right
            showSnapFeedback('Corner Snap: Front-Left');
          }
          // Check if near bottom-right corner (front-right in 3D)
          else if (Math.abs((snapX + elW) - roomRightWall) < cornerSnapDistance &&
                   Math.abs((snapY + elH) - roomBottomWall) < cornerSnapDistance) {
            snapX = roomRightWall - elW;
            snapY = roomBottomWall - elH;
            selectedElement.rotation = 180; // L opens toward back-left
            showSnapFeedback('Corner Snap: Front-Right');
          }
        }

        // Cabinet-to-cabinet alignment for L and U shaped runs
        // Find adjacent cabinets and align depth with them
        const adjacentCabinets = elements.filter(el => {
          if (el === selectedElement) return false;
          if (!['base-cabinet', 'wall-cabinet', 'tall-cabinet', 'drawer-base', 'sink-base'].includes(el.type)) return false;

          const elX = el.x;
          const elY = el.y;
          const elRight = elX + el.width * pixelsPerFoot;
          const elBottom = elY + el.height * pixelsPerFoot;

          // Check if horizontally adjacent (within 0.5 feet)
          const horizGap = Math.min(
            Math.abs(snapX - elRight),
            Math.abs((snapX + elW) - elX)
          );

          // Check if vertically adjacent
          const vertGap = Math.min(
            Math.abs(snapY - elBottom),
            Math.abs((snapY + elH) - elY)
          );

          return horizGap < pixelsPerFoot * 0.5 || vertGap < pixelsPerFoot * 0.5;
        });

        // If there are adjacent cabinets, help align for L-shape connections
        if (adjacentCabinets.length > 0) {
          adjacentCabinets.forEach(adj => {
            const adjRight = adj.x + adj.width * pixelsPerFoot;
            const adjBottom = adj.y + adj.height * pixelsPerFoot;

            // Snap to form perpendicular L-connection
            // If adjacent cabinet is horizontal (on back wall), connect vertically (on side wall)
            if (Math.abs(adj.y - roomTopWall) < wallSnapDistance) {
              // Adjacent is on back wall, snap our top to their bottom for L
              if (Math.abs(snapY - adjBottom) < pixelsPerFoot * 0.5) {
                snapY = adjBottom;
              }
            }

            // If we're forming an L, snap our edge to their edge
            if (Math.abs(snapX - adjRight) < pixelsPerFoot * 0.3) {
              snapX = adjRight;
            }
            if (Math.abs((snapX + elW) - adj.x) < pixelsPerFoot * 0.3) {
              snapX = adj.x - elW;
            }
          });
        }
      }

      // Allow elements to be placed anywhere (no canvas boundary restriction)
      // Calculate movement delta before updating position
      const dx = snapX - selectedElement.x;
      const dy = snapY - selectedElement.y;

      selectedElement.x = snapX;
      selectedElement.y = snapY;

      // Mark element as needing 3D update
      markElement3DDirty(selectedElement.id);

      // Move all locked elements together
      if (selectedElement.groupId) {
        moveGroupedElements(selectedElement, dx, dy);
      }

      drawThrottled();
    }

    function onMouseUp(e) {
      // End room resizing
      if (isResizingRoom) {
        isResizingRoom = false;
        roomResizeHandle = null;
        canvas.style.cursor = 'default';

        // Update 3D if in 3D view
        if (currentView === '3d') {
          init3D();
          render3D();
        }

        saveUndoState();
        showSnapFeedback(`Room size: ${roomWidth}'  ${roomDepth}'`);
        return;
      }

      // End resizing
      if (isResizing) {
        isResizing = false;
        resizeHandle = null;
        canvas.style.cursor = 'default';
        calculateQuote();
        saveUndoState();
        return;
      }

      if (isPanning) {
        isPanning = false;
        canvas.style.cursor = currentTool === 'pan' ? 'grab' : (currentTool === 'wall' ? 'crosshair' : 'default');
        return;
      }

      if (isDrawingWall && wallStart) {
        const rect = canvas.getBoundingClientRect();
        const screenX = e.clientX - rect.left;
        const screenY = e.clientY - rect.top;
        const { x, y } = screenToWorld(screenX, screenY);

        const wx = Math.min(wallStart.x, x);
        const wy = Math.min(wallStart.y, y);
        let ww = Math.abs(x - wallStart.x);
        let wh = Math.abs(y - wallStart.y);

        // Make it a proper wall (thin in one dimension)
        if (ww < wh) {
          ww = CONFIG.WALL_THICKNESS;
        } else {
          wh = CONFIG.WALL_THICKNESS;
        }

        if (ww > 10 || wh > 10) {
          addWall(wx, wy, ww, wh);
          saveUndoState();
        }

        isDrawingWall = false;
        wallStart = null;
        draw();
        return;
      }

      if (isDrawingCountertop && countertopStart) {
        const rect = canvas.getBoundingClientRect();
        const screenX = e.clientX - rect.left;
        const screenY = e.clientY - rect.top;
        const { x, y } = screenToWorld(screenX, screenY);

        const cx = Math.min(countertopStart.x, x);
        const cy = Math.min(countertopStart.y, y);
        let cw = Math.abs(x - countertopStart.x);
        let ch = Math.abs(y - countertopStart.y);

        // Minimum size of 1 foot
        if (cw < pixelsPerFoot) cw = pixelsPerFoot * 2;
        if (ch < pixelsPerFoot) ch = pixelsPerFoot * 2;

        // Create countertop element
        const countertop = {
          id: 'countertop-' + Date.now(),
          type: 'countertop',
          x: cx,
          y: cy,
          width: cw / pixelsPerFoot,
          height: ch / pixelsPerFoot,
          color: '#708090',
          label: 'Countertop',
          rotation: 0,
          locked: false,
          roomId: currentRoom
        };

        elements.push(countertop);
        selectedElement = countertop;
        calculateQuote();
        saveUndoState();

        isDrawingCountertop = false;
        countertopStart = null;
        draw();
        updateProperties();
        return;
      }

      // Handle layout brush release
      if (currentTool === 'layout' && layoutMode.isDrawing) {
        finishLayoutDraw();
        return;
      }

      // Save undo state if we were dragging an element
      if (isDragging && selectedElement) {
        saveUndoState();
      }

      isDragging = false;
    }

    function onContextMenu(e) {
      e.preventDefault();

      const rect = canvas.getBoundingClientRect();
      const screenX = e.clientX - rect.left;
      const screenY = e.clientY - rect.top;
      const { x, y } = screenToWorld(screenX, screenY);

      const clicked = [...elements].reverse().find(el => isPointInElement(x, y, el));

      if (clicked) {
        selectedElement = clicked;
        contextMenuElement = clicked;
        showContextMenu(e.clientX, e.clientY, clicked);
        draw();
      }
    }

    function onDoubleClick(e) {
      // If in layout mode, finalize the cabinet run
      if (currentTool === 'layout' && layoutMode.points.length >= 2) {
        finalizeLayoutRun();
        return;
      }

      const rect = canvas.getBoundingClientRect();
      const screenX = e.clientX - rect.left;
      const screenY = e.clientY - rect.top;
      const { x, y } = screenToWorld(screenX, screenY);

      const clicked = [...elements].reverse().find(el => isPointInElement(x, y, el));

      if (clicked) {
        const newLabel = prompt('Enter label:', clicked.label);
        if (newLabel) {
          clicked.label = newLabel;
          draw();
        }
      }
    }

    function isPointInElement(px, py, el) {
      const w = el.width * pixelsPerFoot;
      const h = el.height * pixelsPerFoot;
      const rotation = (el.rotation || 0) * Math.PI / 180;

      // If no rotation, use simple bounds check
      if (rotation === 0) {
        return px >= el.x && px <= el.x + w && py >= el.y && py <= el.y + h;
      }

      // For rotated elements, transform the click point to element's local space
      const cx = el.x + w / 2;
      const cy = el.y + h / 2;

      // Translate point to origin (element center)
      const dx = px - cx;
      const dy = py - cy;

      // Rotate point in opposite direction to get local coordinates
      const cosR = Math.cos(-rotation);
      const sinR = Math.sin(-rotation);
      const localX = dx * cosR - dy * sinR;
      const localY = dx * sinR + dy * cosR;

      // Check if local point is within unrotated bounds (centered at origin)
      return localX >= -w/2 && localX <= w/2 && localY >= -h/2 && localY <= h/2;
    }

    // ===== KEYBOARD EVENTS =====
    let spacePressed = false;

    function onKeyDown(e) {
      if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') return;

      // Space to pan
      if (e.code === 'Space' && !spacePressed) {
        spacePressed = true;
        canvas.style.cursor = 'grab';
        e.preventDefault();
        return;
      }

      switch(e.key.toLowerCase()) {
        case 'v': setTool('select'); break;
        case 'w': setTool('wall'); break;
        case 'c': setTool('countertop'); break;
        case 'h': setTool('pan'); break;
        case 'l': setTool('layout'); break; // L for layout tool
        case 'f': fitToScreen(); break; // F to fit
        case 'delete':
        case 'backspace':
          if (selectedElement && !selectedElement.locked) {
            deleteElementWithUndo(selectedElement);
          }
          break;
        case 'r':
          if (selectedElement && !selectedElement.locked) {
            selectedElement.rotation = ((selectedElement.rotation || 0) + 90) % 360;
            updateProperties();
            draw();
          }
          break;
        case 'd':
          if (selectedElement && !selectedElement.locked) {
            e.preventDefault();
            duplicateElement(selectedElement);
          }
          break;
        case 'x':
          // X to flip/mirror horizontally (swap width and height for asymmetric elements)
          if (selectedElement && !selectedElement.locked) {
            // For countertops and surfaces, this swaps dimensions
            const temp = selectedElement.width;
            selectedElement.width = selectedElement.height;
            selectedElement.height = temp;
            markElement3DDirty(selectedElement.id);
            saveUndoState();
            updateProperties();
            draw();
          }
          break;
        case 'g':
          // G to toggle grid visibility
          if (typeof CONFIG !== 'undefined') {
            CONFIG.SHOW_GRID = !CONFIG.SHOW_GRID;
            showSnapFeedback(CONFIG.SHOW_GRID ? 'Grid: ON' : 'Grid: OFF');
            draw();
          }
          break;
        case 't':
          // T to cycle through tab panels (Elements, Materials, Properties)
          const tabs = document.querySelectorAll('.panel-tabs .panel-tab');
          if (tabs.length > 0) {
            const activeIdx = Array.from(tabs).findIndex(t => t.classList.contains('active'));
            const nextIdx = (activeIdx + 1) % tabs.length;
            tabs[nextIdx].click();
          }
          break;
        case 'l':
          // L key to toggle link mode (when not in layout tool)
          if (currentTool !== 'layout') {
            lockElementsTogether();
          }
          break;
        case 'u':
          // U key to unlock element
          if (selectedElement && selectedElement.groupId) {
            unlockElement();
          }
          break;
        case 'escape':
          // Cancel layout tool if active
          if (currentTool === 'layout' && layoutMode.points.length > 0) {
            layoutMode.points = [];
            showSnapFeedback('Layout cancelled');
          }
          // Cancel seam placement mode
          if (seamPlacementMode) {
            seamPlacementMode = false;
            const btn = document.getElementById('seamPlaceModeBtn');
            if (btn) {
              btn.style.background = 'rgba(139, 92, 246, 0.3)';
              btn.textContent = ' Click to Place';
            }
          }
          // Finalize or cancel lock mode
          if (lockMode) {
            finalizeLockMode();
          }
          // Cancel material selection
          if (selectedMaterial) {
            selectedMaterial = null;
            materialHoverElement = null;
            materialDropHighlight = null;
            renderMaterials(currentMaterialCategory);
            const hint = document.querySelector('.material-hint');
            if (hint) {
              hint.innerHTML = 'Click material, then click element to apply';
              hint.style.borderColor = 'var(--border)';
            }
            canvas.style.cursor = 'default';
          }
          selectedElement = null;
          hideContextMenu();
          updateProperties();
          draw();
          break;
        case '=':
        case '+':
          if (e.ctrlKey || e.metaKey) {
            e.preventDefault();
            zoomIn();
          }
          break;
        case '-':
          if (e.ctrlKey || e.metaKey) {
            e.preventDefault();
            zoomOut();
          }
          break;
        case '0':
          if (e.ctrlKey || e.metaKey) {
            e.preventDefault();
            fitToScreen();
          } else {
            // Plain 0 resets view
            resetView();
          }
          break;
        case 'home':
          // Home key resets view
          e.preventDefault();
          resetView();
          break;
        case 'arrowup':
        case 'arrowdown':
        case 'arrowleft':
        case 'arrowright':
          // Arrow keys nudge selected element
          if (selectedElement && !selectedElement.locked) {
            e.preventDefault();
            // Shift = fine nudge (1"), Ctrl = large nudge (1'), default = 3"
            const nudgeAmount = e.shiftKey ? pixelsPerFoot / 12 : // 1 inch
                                e.ctrlKey ? pixelsPerFoot :        // 1 foot
                                pixelsPerFoot / 4;                 // 3 inches

            const prevX = selectedElement.x;
            const prevY = selectedElement.y;

            switch(e.key.toLowerCase()) {
              case 'arrowup':
                selectedElement.y -= nudgeAmount;
                break;
              case 'arrowdown':
                selectedElement.y += nudgeAmount;
                break;
              case 'arrowleft':
                selectedElement.x -= nudgeAmount;
                break;
              case 'arrowright':
                selectedElement.x += nudgeAmount;
                break;
            }

            // Constrain to room boundaries
            const roomW = roomWidth * pixelsPerFoot;
            const roomH = roomDepth * pixelsPerFoot;
            const elW = selectedElement.width * pixelsPerFoot;
            const elH = selectedElement.height * pixelsPerFoot;

            selectedElement.x = Math.max(0, Math.min(roomW - elW, selectedElement.x));
            selectedElement.y = Math.max(0, Math.min(roomH - elH, selectedElement.y));

            // Move grouped elements too
            if (selectedElement.groupId) {
              const dx = selectedElement.x - prevX;
              const dy = selectedElement.y - prevY;
              moveGroupedElements(selectedElement, dx, dy);
            }

            markElement3DDirty(selectedElement.id);
            saveUndoState();
            draw();
            updateProperties();
          }
          break;
      }
    }

    function onKeyUp(e) {
      if (e.code === 'Space') {
        spacePressed = false;
        canvas.style.cursor = currentTool === 'pan' ? 'grab' : (currentTool === 'wall' ? 'crosshair' : 'default');
      }
    }

    // Track if HTML5 drag is in progress
    let isHtmlDragging = false;
    let materialDropHighlight = null; // Element ID highlighted during material drag
    let materialHoverElement = null; // Element highlighted during material select+hover

    // Mouse wheel zoom with throttling for smooth trackpad support
    let lastWheelTime = 0;
    let wheelAccumulator = 0;
    let wheelTimeout = null;

    function onWheel(e) {
      // Don't zoom if view is locked or during any drag operation
      if (viewLocked || isDragging || isResizing || isHtmlDragging || isPanning) {
        e.preventDefault();
        return;
      }

      e.preventDefault();

      const now = Date.now();
      const timeDelta = now - lastWheelTime;
      lastWheelTime = now;

      // Detect if this is a trackpad gesture (small, frequent deltas) or mouse wheel (larger, less frequent)
      const isTrackpad = Math.abs(e.deltaY) < 50 && timeDelta < 50;

      // Accumulate for trackpad, apply immediately for mouse wheel
      if (isTrackpad) {
        wheelAccumulator += e.deltaY;

        // Clear existing timeout
        if (wheelTimeout) clearTimeout(wheelTimeout);

        // Apply accumulated zoom after brief pause
        wheelTimeout = setTimeout(() => {
          applyZoom(wheelAccumulator, e.clientX, e.clientY);
          wheelAccumulator = 0;
        }, 16); // ~60fps
      } else {
        // Mouse wheel - apply immediately but with gentler factor
        applyZoom(e.deltaY, e.clientX, e.clientY);
      }
    }

    function applyZoom(deltaY, clientX, clientY) {
      // Safety check - don't zoom if values are invalid
      if (!isFinite(deltaY) || !isFinite(clientX) || !isFinite(clientY)) {
        wheelAccumulator = 0;
        return;
      }

      const rect = canvas.getBoundingClientRect();
      const mouseX = clientX - rect.left;
      const mouseY = clientY - rect.top;

      // Get world position before zoom
      const worldX = (mouseX - panX) / pixelsPerFoot;
      const worldY = (mouseY - panY) / pixelsPerFoot;

      // Safety check for world coordinates
      if (!isFinite(worldX) || !isFinite(worldY)) {
        wheelAccumulator = 0;
        return;
      }

      // Calculate zoom factor - gentler for accumulated trackpad gestures
      const normalizedDelta = Math.max(-100, Math.min(100, deltaY)); // Clamp extreme values
      const zoomFactor = normalizedDelta < 0 ? 1.08 : 0.92;
      const newPixelsPerFoot = Math.max(5, Math.min(200, pixelsPerFoot * zoomFactor)); // Extended range: 5-200

      // Adjust pan to zoom toward mouse position
      const newPanX = mouseX - worldX * newPixelsPerFoot;
      const newPanY = mouseY - worldY * newPixelsPerFoot;

      // Safety check for new pan values
      if (!isFinite(newPanX) || !isFinite(newPanY)) {
        wheelAccumulator = 0;
        return;
      }

      panX = newPanX;
      panY = newPanY;

      pixelsPerFoot = newPixelsPerFoot;

      document.getElementById('scaleMode').value = 'fit'; // Reset dropdown
      document.getElementById('zoomLevel').textContent = Math.round(pixelsPerFoot / 40 * 100) + '%';

      draw();
    }

    // Reset view to default pan and zoom
    function resetView() {
      panX = 50;
      panY = 50;
      pixelsPerFoot = 40;
      wheelAccumulator = 0;
      if (wheelTimeout) {
        clearTimeout(wheelTimeout);
        wheelTimeout = null;
      }
      document.getElementById('scaleMode').value = 'fit';
      document.getElementById('zoomLevel').textContent = '100%';
      draw();
      showSnapFeedback('View reset');
    }

    // ===== DRAG & DROP =====
    function onDrop(e) {
      e.preventDefault();
      const rect = canvas.getBoundingClientRect();
      const screenX = e.clientX - rect.left;
      const screenY = e.clientY - rect.top;
      const { x, y } = screenToWorld(screenX, screenY);

      console.log('onDrop called at', x, y);

      // Check for material swatch drag-and-drop
      const materialId = e.dataTransfer.getData('material-id');
      if (materialId) {
        const hitElement = [...elements].reverse().find(el => isPointInElement(x, y, el));
        if (hitElement) {
          // Select the material first (if not already)
          selectMaterial(materialId);
          const applied = applyMaterialToElement(hitElement);
          if (applied) {
            selectedElement = hitElement;
            updateProperties();
            draw();
          }
        }
        materialDropHighlight = null;
        draw();
        return;
      }

      // Check for element-type (sidebar elements)
      const type = e.dataTransfer.getData('element-type');
      if (type) {
        console.log('Creating element type:', type);
        createElement(type, x, y);
        return;
      }

      // Check for store product or other JSON data
      const jsonData = e.dataTransfer.getData('text/plain');
      console.log('JSON data from drop:', jsonData);
      if (jsonData) {
        try {
          const data = JSON.parse(jsonData);
          console.log('Parsed drop data:', data);
          if (data.type === 'store-product' && data.product) {
            console.log('Handling store product drop:', data.product.name);
            handleStoreProductDrop(data.product, x, y, e);
            return;
          }
          if (data.type === 'marketplace-product' && data.product) {
            console.log('Handling marketplace product drop:', data.product.name);
            handleStoreProductDrop(data.product, x, y, e);
            return;
          }
        } catch (parseErr) {
          console.log('Not JSON data, ignoring');
        }
      }
    }

    // Handle dropping a store product onto the canvas or an element
    function handleStoreProductDrop(product, x, y, e) {
      console.log('handleStoreProductDrop called', { product: product.name, x, y });

      // Check if dropped on an existing element using world coordinates
      const hitElement = [...elements].reverse().find(el => isPointInElement(x, y, el));
      console.log('Hit element:', hitElement ? hitElement.type : 'none');

      if (hitElement) {
        // Apply product as material/texture to existing element
        console.log('Applying product to existing element');
        applyStoreProductToExistingElement(hitElement, product);
      } else {
        // Create a new element with the product
        console.log('Creating new element from product');
        createElementFromStoreProduct(product, x, y);
      }
    }

    // Apply store product to an existing element
    function applyStoreProductToExistingElement(element, product) {
      // Determine best element type match
      const productType = product.type?.toLowerCase() || '';

      // Check material type compatibility
      if (!canApplyMaterialToElement(productType, element)) {
        return false;
      }

      // Get image URL - prefer primaryImage, fall back to images array or image property
      const imageUrl = product.primaryImage || product.images?.[0] || product.image;

      // Store product info on element
      element.storeProduct = {
        name: product.name,
        slug: product.slug,
        brand: product.brand,
        sku: product.sku,
        price: product.price,
        image: imageUrl
      };

      // Also store on element for material panel reference
      element.materialId = product.slug;
      element.materialName = product.name;
      element.materialBrand = product.brand;
      element.materialCategory = productType || product.category || null;

      // Apply as texture if product has image
      if (imageUrl) {
        element.texture = imageUrl;
        element.textureImg = null; // Force reload

        console.log('Applying texture to element:', element.type, 'URL:', imageUrl);

        // Load texture image
        const img = new Image();
        img.crossOrigin = 'anonymous';
        img.onload = () => {
          element.textureImg = img;
          console.log('Texture loaded successfully for', element.type);
          draw();
          if (currentView === '3d') {
            console.log('Updating 3D scene with new texture');
            update3DScene();
          }
        };
        img.onerror = (err) => {
          console.warn('Failed to load texture for', element.type, ':', imageUrl, err);
        };
        img.src = imageUrl;
      }

      // Update price if product has price
      if (product.price) {
        element.priceOverride = parseFloat(product.price);
        element.costPrice = parseFloat(product.price);
      }

      // Update label
      element.label = product.name || element.label;

      selectedElement = element;
      updateProperties();
      draw();
      calculateQuote();

      showToast(`Applied ${product.name} to ${element.type}`, 'success');
    }

    // Create new element from store product
    function createElementFromStoreProduct(product, x, y) {
      console.log('createElementFromStoreProduct called', { product: product.name, x, y });
      const productType = product.type?.toLowerCase() || '';
      console.log('Product type:', productType);

      // Map product types to element types
      let elementType = 'stove'; // default fallback (valid appliance type)
      let width = 2.5;
      let height = 2;
      let color = '#4a90d9';

      if (productType.includes('sink')) {
        elementType = 'sink';
        width = 2.75;
        height = 1.75;
      } else if (productType.includes('faucet')) {
        elementType = 'sink'; // Use sink type for faucets
        width = 0.75;
        height = 0.5;
      } else if (productType.includes('range') || productType.includes('stove')) {
        elementType = 'stove';
        width = 2.5;
        height = 2.5;
      } else if (productType.includes('refrigerator') || productType.includes('fridge')) {
        elementType = 'refrigerator';
        width = 3;
        height = 3;
      } else if (productType.includes('dishwasher')) {
        elementType = 'dishwasher';
        width = 2;
        height = 2;
      } else if (productType.includes('microwave')) {
        elementType = 'microwave';
        width = 2;
        height = 1;
      } else if (productType.includes('hood') || productType.includes('vent')) {
        elementType = 'range-hood';
        width = 2.5;
        height = 1.5;
      } else if (productType.includes('cabinet')) {
        elementType = 'base-cabinet';
        width = 3;
        height = 2;
      } else if (productType.includes('countertop') || productType.includes('granite') ||
                 productType.includes('quartz') || productType.includes('dekton') ||
                 productType.includes('marble') || productType.includes('quartzite') ||
                 productType.includes('soapstone') || productType.includes('porcelain') ||
                 productType.includes('sintered') || productType.includes('onyx') ||
                 productType.includes('travertine') || productType.includes('limestone')) {
        elementType = 'countertop';
        width = 4;
        height = 2;
      } else if (productType.includes('tile') || productType.includes('backsplash')) {
        elementType = 'backsplash';
        width = 4;
        height = 1.5;
      } else if (productType.includes('vanity')) {
        elementType = 'vanity-36';
        width = 3;
        height = 1.75;
      } else if (productType.includes('toilet')) {
        elementType = 'toilet';
        width = 1.5;
        height = 2.3;
      } else if (productType.includes('bathtub') || productType.includes('tub')) {
        elementType = 'bathtub';
        width = 5;
        height = 2.7;
      }

      // Find the color from ELEMENT_TYPES by searching all categories
      let foundColor = color;
      for (const category of Object.values(ELEMENT_TYPES)) {
        const found = category.find(e => e.type === elementType);
        if (found) {
          foundColor = found.color;
          break;
        }
      }

      const gridSnap = pixelsPerFoot / CONFIG.GRID_SUBDIVISIONS;
      const element = {
        id: Date.now() + Math.random(),
        type: elementType,
        x: Math.round(x / gridSnap) * gridSnap,
        y: Math.round(y / gridSnap) * gridSnap,
        width: width,
        height: height,
        color: foundColor,
        label: product.name || 'Store Product',
        rotation: 0,
        locked: false,
        roomId: currentRoom,
        storeProduct: {
          name: product.name,
          slug: product.slug,
          brand: product.brand,
          sku: product.sku,
          price: product.price,
          image: product.images?.[0] || product.image
        },
        priceOverride: product.price ? parseFloat(product.price) : null,
        costPrice: product.price ? parseFloat(product.price) : null,
        priceUnit: 'unit',
        marginPercent: null
      };

      // Apply texture from product image
      if (product.images?.[0] || product.image) {
        const imageUrl = product.images?.[0] || product.image;
        element.texture = imageUrl;

        const img = new Image();
        img.crossOrigin = 'anonymous';
        img.onload = () => {
          element.textureImg = img;
          draw();
          if (currentView === '3d') update3DScene();
        };
        img.src = imageUrl;
      }

      elements.push(element);
      console.log('Element created and added:', element);
      console.log('Total elements now:', elements.length);

      selectedElement = element;
      updateProperties();
      draw();
      calculateQuote();
      saveUndoState();

      showToast(`Added ${product.name} to design`, 'success');
    }

    function createElement(type, x, y) {
      let defaults = null;
      Object.values(ELEMENT_TYPES).forEach(cat => {
        const found = cat.find(el => el.type === type);
        if (found) defaults = found;
      });

      if (!defaults) return;

      const gridSnap = pixelsPerFoot / CONFIG.GRID_SUBDIVISIONS;
      // All cabinet types that should receive cabinet settings (construction, doorStyle, etc.)
      const CABINET_TYPES = ['base-cabinet', 'wall-cabinet', 'tall-cabinet', 'corner-cabinet',
                             'drawer-base', 'sink-base', 'lazy-susan', 'blind-corner', 'island',
                             'microwave-cabinet', 'above-microwave-cabinet', 'fridge-cabinet',
                             'single-oven-cabinet', 'tall-oven', 'double-oven-cabinet', 'laundry-cabinet',
                             'linen-closet', 'linen-tower',
                             'base-cabinet-12', 'base-cabinet-15', 'base-cabinet-18', 'base-cabinet-21',
                             'base-cabinet-24', 'base-cabinet-27', 'base-cabinet-30', 'base-cabinet-33'];
      const isCabinet = CABINET_TYPES.includes(type);
      const isVanity = type.startsWith('vanity-') || type === 'powder-table' || type === 'makeup-vanity';
      const isCountertop = type === 'countertop' || type === 'countertop-l' || type === 'countertop-u';

      // For countertops, check if dropping on/near a cabinet to auto-fit
      let finalX = Math.round(x / gridSnap) * gridSnap;
      let finalY = Math.round(y / gridSnap) * gridSnap;
      let finalWidth = defaults.width;
      let finalHeight = defaults.height;
      let snappedToCabinet = null;

      if (isCountertop) {
        // Find cabinet under or near drop point
        const baseCabinetTypes = ['base-cabinet', 'drawer-base', 'sink-base', 'corner-cabinet', 'lazy-susan', 'island'];
        const snapDistance = pixelsPerFoot * 1; // 1 foot snap zone

        // Check each cabinet to find the best match
        let bestCabinet = null;
        let bestDistance = Infinity;

        elements.forEach(el => {
          if (!baseCabinetTypes.includes(el.type)) return;

          const cabCenterX = el.x + (el.width * pixelsPerFoot) / 2;
          const cabCenterY = el.y + ((el.height || el.depth || 2) * pixelsPerFoot) / 2;
          const distance = Math.sqrt(Math.pow(x - cabCenterX, 2) + Math.pow(y - cabCenterY, 2));

          if (distance < snapDistance && distance < bestDistance) {
            bestDistance = distance;
            bestCabinet = el;
          }
        });

        if (bestCabinet) {
          // Snap countertop to fit on cabinet with 1.5" overhang
          const overhangFeet = 0.125; // 1.5 inches in feet
          const overhangPx = overhangFeet * pixelsPerFoot;

          finalX = bestCabinet.x - overhangPx;
          finalY = bestCabinet.y - overhangPx;
          finalWidth = bestCabinet.width + (overhangFeet * 2);
          finalHeight = (bestCabinet.height || bestCabinet.depth || 2) + (overhangFeet * 2);
          snappedToCabinet = bestCabinet;
        }
      }

      // Check if this is a sink type
      const isSink = type === 'sink' || type === 'sink-double' || type === 'sink-farmhouse';

      const element = {
        id: Date.now() + Math.random(),
        type: type,
        x: finalX,
        y: finalY,
        width: finalWidth,
        height: finalHeight,
        color: defaults.color,
        label: defaults.label,
        rotation: snappedToCabinet ? (snappedToCabinet.rotation || 0) : 0,
        locked: false,
        roomId: currentRoom,
        texture: elementTextures[type] || null,
        textureImg: null,
        floorLevel: cabinetSettings.currentFloor,
        // Wall-specific settings (pony walls, knee walls, etc.)
        wallHeight: defaults.wallHeight || undefined,
        // Cabinet-specific settings
        construction: isCabinet ? cabinetSettings.construction : undefined,
        doorStyle: isCabinet ? cabinetSettings.doorStyle : undefined,
        doorOverlay: isCabinet ? cabinetSettings.doorOverlay : undefined,
        cabinetFinish: isCabinet ? cabinetSettings.cabinetFinish : undefined,
        grainType: isCabinet ? cabinetSettings.grainType : undefined,
        // Sink-specific settings
        mountType: isSink ? (defaults.mountType || 'undermount') : undefined,
        sinkColor: isSink ? 'stainless' : undefined,
        // Countertop-specific settings - 2" front overhang covers cabinet door faces
        overhangFront: isCountertop ? 0.167 : undefined, // 2" front overhang
        overhangBack: isCountertop ? 0 : undefined,       // 0" back (against wall)
        overhangLeft: isCountertop ? 0.125 : undefined,   // 1.5" sides
        overhangRight: isCountertop ? 0.125 : undefined,  // 1.5" sides
        edgeProfile: isCountertop ? 'eased' : undefined,
        thickness: isCountertop ? '3cm' : undefined,
        // Pricing fields
        priceOverride: null,
        priceUnit: 'sqft',
        marginPercent: null,
        costPrice: null,
        retailPrice: null
      };

      // Load texture if exists
      if (element.texture) {
        const img = new Image();
        img.onload = () => {
          element.textureImg = img;
          draw();
        };
        img.src = element.texture;
      }

      elements.push(element);
      selectedElement = element;
      updateProperties();
      calculateQuote();
      saveUndoState();
      draw();

      // Show feedback if snapped to cabinet
      if (snappedToCabinet) {
        showSnapFeedback('Countertop fitted to cabinet with 1.5" overhang');
      }
    }

    function duplicateElement(el) {
      const gridSnap = pixelsPerFoot / CONFIG.GRID_SUBDIVISIONS;
      const newEl = {
        ...el,
        id: Date.now() + Math.random(),
        x: el.x + gridSnap * 2,
        y: el.y + gridSnap * 2,
        locked: false
      };
      elements.push(newEl);
      selectedElement = newEl;
      updateProperties();
      calculateQuote();
      saveUndoState();
      draw();
    }

    // Quick action wrapper functions
    function duplicateSelectedElement() {
      if (selectedElement && !selectedElement.locked) {
        duplicateElement(selectedElement);
        showSnapFeedback('Element duplicated');
      }
    }

    function rotateSelectedElement(degrees) {
      if (selectedElement && !selectedElement.locked) {
        selectedElement.rotation = ((selectedElement.rotation || 0) + degrees) % 360;
        updateProperties();
        saveUndoState();
        draw();
        update3DScene();
        showSnapFeedback(`Rotated ${degrees}`);
      }
    }

    function flipSelectedElement(axis) {
      if (selectedElement && !selectedElement.locked) {
        // Flip by swapping width/height for some types or adjusting position
        if (axis === 'h') {
          // Horizontal flip - mirror position relative to room center
          const centerX = roomWidth * pixelsPerFoot / 2;
          const elCenterX = selectedElement.x + (selectedElement.width * pixelsPerFoot) / 2;
          const newCenterX = centerX + (centerX - elCenterX);
          selectedElement.x = newCenterX - (selectedElement.width * pixelsPerFoot) / 2;
        } else {
          // Vertical flip
          const centerY = roomDepth * pixelsPerFoot / 2;
          const elCenterY = selectedElement.y + (selectedElement.height * pixelsPerFoot) / 2;
          const newCenterY = centerY + (centerY - elCenterY);
          selectedElement.y = newCenterY - (selectedElement.height * pixelsPerFoot) / 2;
        }
        saveUndoState();
        draw();
        update3DScene();
        showSnapFeedback(`Flipped ${axis === 'h' ? 'horizontally' : 'vertically'}`);
      }
    }

    function bringToFront() {
      if (selectedElement) {
        // Move element to end of array (renders on top in both 2D and 3D)
        const idx = elements.indexOf(selectedElement);
        if (idx !== -1 && idx < elements.length - 1) {
          elements.splice(idx, 1);
          elements.push(selectedElement);
        }
        // Also adjust zIndexOffset for 2D canvas layering within same render order
        selectedElement.zIndexOffset = (selectedElement.zIndexOffset || 0) + 100;
        saveUndoState();
        draw();
        update3DScene();
        showSnapFeedback('Brought to front');
      }
    }

    function sendToBack() {
      if (selectedElement) {
        // Move element to beginning of array (renders behind others in both 2D and 3D)
        const idx = elements.indexOf(selectedElement);
        if (idx !== -1 && idx > 0) {
          elements.splice(idx, 1);
          elements.unshift(selectedElement);
        }
        // Also adjust zIndexOffset for 2D canvas layering
        selectedElement.zIndexOffset = (selectedElement.zIndexOffset || 0) - 100;
        saveUndoState();
        draw();
        update3DScene();
        showSnapFeedback('Sent to back');
      }
    }

    function resetLayering() {
      if (selectedElement) {
        selectedElement.zIndexOffset = 0;
        // Note: Array position stays the same - only resets zIndex offset
        saveUndoState();
        draw();
        update3DScene();
        showSnapFeedback('Layering reset');
      }
    }

    // ===== ELEMENT LOCKING (Multi-element link mode) =====

    // Lock mode state
    let lockMode = false;
    let lockPendingElements = new Set(); // Element IDs queued for linking

    // Toggle lock mode - click elements to add them, press L again or Escape to finish
    function lockElementsTogether() {
      if (lockMode) {
        // Already in lock mode - pressing L again finalizes the link
        finalizeLockMode();
        return;
      }

      lockMode = true;
      lockPendingElements.clear();

      // Seed with currently selected element if there is one
      if (selectedElement) {
        lockPendingElements.add(selectedElement.id);
      }

      const btn = document.getElementById('lockTogetherBtn');
      if (btn) {
        btn.style.background = 'rgba(34, 211, 238, 0.7)';
        btn.title = 'Link mode active - press L again to finish';
        btn.style.boxShadow = '0 0 12px rgba(34, 211, 238, 0.6)';
      }

      const count = lockPendingElements.size;
      showSnapFeedback(`Link mode: click elements to add (${count} selected). Press L or Esc to finish.`);
      draw();
    }

    // Handle a click on an element while in lock mode
    function completeLock(targetElement) {
      if (!targetElement) {
        return;
      }

      // Toggle element in/out of the pending set
      if (lockPendingElements.has(targetElement.id)) {
        lockPendingElements.delete(targetElement.id);
      } else {
        lockPendingElements.add(targetElement.id);
      }

      selectedElement = targetElement;
      updateLockUI();
      updateProperties();
      draw();

      const count = lockPendingElements.size;
      if (count < 2) {
        showSnapFeedback(`Link mode: ${count} element${count !== 1 ? 's' : ''} selected. Click more to add.`);
      } else {
        showSnapFeedback(`Link mode: ${count} elements selected. Press L or Esc to link.`);
      }
    }

    // Finalize: link all pending elements and exit lock mode
    function finalizeLockMode() {
      if (lockPendingElements.size >= 2) {
        // Find existing groupId or create new one
        let groupId = null;
        for (const id of lockPendingElements) {
          const el = elements.find(e => e.id === id);
          if (el && el.groupId) {
            groupId = el.groupId;
            break;
          }
        }
        if (!groupId) {
          groupId = 'group-' + nextGroupId++;
        }

        // Assign all pending elements to the group
        for (const id of lockPendingElements) {
          const el = elements.find(e => e.id === id);
          if (el) {
            el.groupId = groupId;
          }
        }

        saveUndoState();
        const count = lockPendingElements.size;
        showSnapFeedback(`Locked! ${count} elements now move together`);
      } else if (lockPendingElements.size === 1) {
        showSnapFeedback('Need 2+ elements to link. Lock mode cancelled.');
      }

      cancelLockMode();
      draw();
    }

    // Cancel lock mode without linking
    function cancelLockMode() {
      const wasActive = lockMode;
      lockMode = false;
      lockPendingElements.clear();

      const btn = document.getElementById('lockTogetherBtn');
      if (btn) {
        btn.style.background = 'rgba(99, 102, 241, 0.3)';
        btn.title = 'Lock with another element';
        btn.style.boxShadow = 'none';
      }

      // Reset cursor from lock mode cell cursor
      if (wasActive && canvas) {
        canvas.style.cursor = currentTool === 'pan' ? 'grab' : (currentTool === 'wall' ? 'crosshair' : 'default');
      }

      if (wasActive) {
        draw();
      }
    }

    // Auto-group adjacent cabinets in a run
    function groupAdjacentCabinets() {
      if (!selectedElement) {
        showToast('Select a cabinet first', 'warning', 2000);
        return;
      }

      const cabinetTypes = ['base-cabinet', 'drawer-base', 'sink-base', 'wall-cabinet',
                            'tall-cabinet', 'corner-cabinet', 'lazy-susan', 'blind-corner',
                            'island', 'fridge-cabinet', 'single-oven-cabinet', 'tall-oven',
                            'double-oven-cabinet', 'microwave-cabinet', 'above-microwave-cabinet'];

      // Check if selected is a cabinet (including sized variants)
      const isCabinet = cabinetTypes.includes(selectedElement.type) ||
                        selectedElement.type?.startsWith('base-cabinet-') ||
                        selectedElement.type?.startsWith('wall-cabinet-') ||
                        selectedElement.type?.startsWith('tall-cabinet-') ||
                        selectedElement.type?.startsWith('drawer-base-') ||
                        selectedElement.type?.startsWith('sink-base-');

      if (!isCabinet) {
        showToast('Select a cabinet element', 'warning', 2000);
        return;
      }

      // Find all adjacent cabinets using flood fill
      const visited = new Set();
      const group = new Set();
      const threshold = pixelsPerFoot * 0.2; // 2.4" tolerance for adjacency

      function findAdjacent(element) {
        if (visited.has(element.id)) return;
        visited.add(element.id);

        const isElCabinet = cabinetTypes.includes(element.type) ||
                            element.type?.startsWith('base-cabinet-') ||
                            element.type?.startsWith('wall-cabinet-') ||
                            element.type?.startsWith('tall-cabinet-') ||
                            element.type?.startsWith('drawer-base-') ||
                            element.type?.startsWith('sink-base-');

        if (!isElCabinet) return;

        group.add(element.id);

        const elLeft = element.x;
        const elRight = element.x + element.width * pixelsPerFoot;
        const elTop = element.y;
        const elBottom = element.y + element.height * pixelsPerFoot;

        elements.forEach(other => {
          if (visited.has(other.id)) return;

          const isOtherCabinet = cabinetTypes.includes(other.type) ||
                                  other.type?.startsWith('base-cabinet-') ||
                                  other.type?.startsWith('wall-cabinet-') ||
                                  other.type?.startsWith('tall-cabinet-') ||
                                  other.type?.startsWith('drawer-base-') ||
                                  other.type?.startsWith('sink-base-');

          if (!isOtherCabinet) return;

          const otherLeft = other.x;
          const otherRight = other.x + other.width * pixelsPerFoot;
          const otherTop = other.y;
          const otherBottom = other.y + other.height * pixelsPerFoot;

          // Check if adjacent horizontally (side by side)
          const hAdjacent = (Math.abs(elRight - otherLeft) < threshold || Math.abs(otherRight - elLeft) < threshold) &&
                            !(elBottom < otherTop || otherBottom < elTop);

          // Check if adjacent vertically (stacked)
          const vAdjacent = (Math.abs(elBottom - otherTop) < threshold || Math.abs(otherBottom - elTop) < threshold) &&
                            !(elRight < otherLeft || otherRight < elLeft);

          if (hAdjacent || vAdjacent) {
            findAdjacent(other);
          }
        });
      }

      findAdjacent(selectedElement);

      if (group.size < 2) {
        showToast('No adjacent cabinets found', 'info', 2000);
        return;
      }

      // Create new group
      const groupId = 'group-' + nextGroupId++;
      group.forEach(id => {
        const el = elements.find(e => e.id === id);
        if (el) {
          el.groupId = groupId;
        }
      });

      saveUndoState();
      showToast(`Grouped ${group.size} adjacent cabinets`, 'success', 2000);
      draw();
      updateProperties();
    }

    // Unlock element from its group
    function unlockElement() {
      if (!selectedElement || !selectedElement.groupId) {
        showToast('Element is not locked', 'warning', 2000);
        return;
      }

      const groupId = selectedElement.groupId;

      // Remove this element from group
      delete selectedElement.groupId;

      // Check if any elements remain in the group
      const remaining = elements.filter(el => el.groupId === groupId);
      if (remaining.length === 1) {
        // Only one left, remove its groupId too
        delete remaining[0].groupId;
      }

      saveUndoState();
      updateLockUI();
      draw();
      showSnapFeedback('Element unlocked');
    }

    // Ungroup all cabinets in a group
    function ungroupCabinets(element) {
      const el = element || selectedElement;
      if (!el || !el.groupId) {
        showToast('Element is not in a group', 'warning', 2000);
        return;
      }

      const groupId = el.groupId;
      let count = 0;

      // Remove groupId from all elements in this group
      elements.forEach(other => {
        if (other.groupId === groupId) {
          delete other.groupId;
          count++;
        }
      });

      saveUndoState();
      showToast(`Ungrouped ${count} cabinets`, 'success', 2000);
      draw();
      updateProperties();
    }

    // Get all elements in the same group as the given element
    function getGroupMembers(element) {
      if (!element || !element.groupId) return [element];
      return elements.filter(el => el.groupId === element.groupId);
    }

    // Move all locked elements together
    function moveGroupedElements(primaryElement, dx, dy) {
      if (!primaryElement) return;

      const members = getGroupMembers(primaryElement);
      members.forEach(el => {
        if (el !== primaryElement) {
          el.x += dx;
          el.y += dy;
        }
      });
    }

    // Update lock-related UI (show/hide unlock button, update badge)
    function updateLockUI() {
      const unlockBtn = document.getElementById('unlockBtn');
      const selectionCount = document.getElementById('selectionCount');
      const selectionType = document.getElementById('selectionType');

      // Show unlock button if selected element is locked with others
      if (unlockBtn) {
        unlockBtn.style.display = (selectedElement && selectedElement.groupId) ? 'flex' : 'none';
      }

      // Update selection badge
      if (selectionCount) {
        if (lockMode && lockPendingElements.size > 0) {
          selectionCount.textContent = lockPendingElements.size;
          selectionType.textContent = 'Linking';
        } else if (selectedElement && selectedElement.groupId) {
          const groupSize = getGroupMembers(selectedElement).length;
          selectionCount.textContent = groupSize;
          selectionType.textContent = 'Locked';
        } else if (selectedElement) {
          selectionCount.textContent = '1';
          selectionType.textContent = 'Selected';
        }
      }
    }

    // ===== ITEM PICKER / QUOTE LIST =====
    let itemPickerFilter = 'all';
    let selectedItems = new Set(); // Track multi-selected items for bulk operations

    function updateItemPicker() {
      const listContainer = document.getElementById('itemPickerList');
      const totalDisplay = document.getElementById('itemPickerTotal');
      const itemCountDisplay = document.getElementById('itemCount');
      const subtotalDisplay = document.getElementById('itemSubtotal');

      if (!listContainer) return;

      // Filter elements based on current filter
      const filteredElements = elements.filter(el => {
        if (itemPickerFilter === 'all') return true;
        const category = getElementCategory(el.type);
        return category === itemPickerFilter;
      });

      // Calculate totals by category (only if pricing access)
      const canShowPricing = PRICING_ACCESS.canViewPricing;
      let totalPrice = 0;
      const categoryTotals = {
        cabinets: { count: 0, total: 0 },
        countertops: { count: 0, sqft: 0, total: 0 },
        appliances: { count: 0, total: 0 },
        fixtures: { count: 0, total: 0 },
        flooring: { count: 0, sqft: 0, total: 0 },
        other: { count: 0, total: 0 }
      };

      elements.forEach(el => {
        const price = canShowPricing ? calculateElementPrice(el) : 0;
        totalPrice += price;

        const cat = getElementCategory(el.type);
        const catKey = cat === 'countertops' || cat === 'flooring' ? cat :
                       cat === 'cabinets' ? 'cabinets' :
                       cat === 'appliances' ? 'appliances' :
                       cat === 'fixtures' || cat === 'bathroom' ? 'fixtures' : 'other';

        if (categoryTotals[catKey]) {
          categoryTotals[catKey].count++;
          categoryTotals[catKey].total += price;
          if (catKey === 'countertops' || catKey === 'flooring') {
            categoryTotals[catKey].sqft += getElementSqft(el);
          }
        }
      });

      // Update displays (show prices only if pricing access)
      if (totalDisplay) totalDisplay.textContent = canShowPricing ? formatCurrency(totalPrice) : '--';
      if (itemCountDisplay) itemCountDisplay.textContent = elements.length;
      if (subtotalDisplay) subtotalDisplay.textContent = canShowPricing ? formatCurrency(totalPrice) : '--';

      // Update category summary (show prices only if pricing access)
      const categorySummary = document.getElementById('itemCategorySummary');
      if (categorySummary) {
        let summaryHtml = '';
        if (categoryTotals.cabinets.count > 0) {
          summaryHtml += `<div class="summary-row"><span>Cabinets (${categoryTotals.cabinets.count})</span><span>${canShowPricing ? formatCurrency(categoryTotals.cabinets.total) : '--'}</span></div>`;
        }
        if (categoryTotals.countertops.count > 0) {
          summaryHtml += `<div class="summary-row"><span>Countertops (${categoryTotals.countertops.sqft.toFixed(1)} sqft)</span><span>${canShowPricing ? formatCurrency(categoryTotals.countertops.total) : '--'}</span></div>`;
        }
        if (categoryTotals.appliances.count > 0) {
          summaryHtml += `<div class="summary-row"><span>Appliances (${categoryTotals.appliances.count})</span><span>${canShowPricing ? formatCurrency(categoryTotals.appliances.total) : '--'}</span></div>`;
        }
        if (categoryTotals.fixtures.count > 0) {
          summaryHtml += `<div class="summary-row"><span>Fixtures (${categoryTotals.fixtures.count})</span><span>${canShowPricing ? formatCurrency(categoryTotals.fixtures.total) : '--'}</span></div>`;
        }
        if (categoryTotals.flooring.count > 0) {
          summaryHtml += `<div class="summary-row"><span>Flooring (${categoryTotals.flooring.sqft.toFixed(1)} sqft)</span><span>${canShowPricing ? formatCurrency(categoryTotals.flooring.total) : '--'}</span></div>`;
        }
        if (categoryTotals.other.count > 0) {
          summaryHtml += `<div class="summary-row"><span>Other (${categoryTotals.other.count})</span><span>${canShowPricing ? formatCurrency(categoryTotals.other.total) : '--'}</span></div>`;
        }
        categorySummary.innerHTML = summaryHtml;
      }

      // Build list HTML
      if (filteredElements.length === 0) {
        listContainer.innerHTML = `<div class="item-picker-empty">
          ${elements.length === 0 ? 'No items on canvas yet.<br>Drag elements from the left panel.' : 'No items match the filter.'}
        </div>`;
        return;
      }

      const canShowPrice = PRICING_ACCESS.canViewPricing;
      let html = '';
      filteredElements.forEach((el, idx) => {
        const isSelected = el === selectedElement;
        const isChecked = selectedItems.has(String(el.id));
        const typeName = formatElementType(el.type);
        const icon = getElementIcon(el.type);
        const price = canShowPrice ? calculateElementPrice(el) : 0;
        const dims = `${el.width.toFixed(1)}'  ${el.height.toFixed(1)}'`;
        const area = getElementSqft(el).toFixed(1);
        const material = el.materialName || el.storeProduct?.name || '';
        const realIdx = elements.indexOf(el);

        // Get additional info for different element types
        const areaTypes = ['countertop', 'backsplash', 'flooring', 'tile', 'wall-tile', 'bar-top', 'wall-cap'];
        const cabinetTypes = ['base-cabinet', 'wall-cabinet', 'tall-cabinet', 'corner-cabinet', 'island', 'drawer-base', 'sink-base', 'lazy-susan'];

        let detailLine = '';
        if (cabinetTypes.includes(el.type)) {
          // Show SKU and catalog for cabinets
          if (el.sku) {
            detailLine = `<span class="item-sku">${el.sku}</span>`;
            if (el.catalog) {
              const catalogName = el.catalog.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
              detailLine += ` <span class="item-catalog">(${catalogName})</span>`;
            }
          }
        } else if (areaTypes.includes(el.type)) {
          // Show sqft and unit price for area-based items (only if pricing access)
          let unitPrice = 0;
          if (canShowPrice) {
            if (el.priceOverride) unitPrice = el.priceOverride;
            else if (el.storeProduct?.price) unitPrice = el.storeProduct.price;
            else if (el.materialId && typeof MATERIALS !== 'undefined') {
              for (const cat in MATERIALS) {
                const mat = MATERIALS[cat].find(m => m.id === el.materialId);
                if (mat && (mat.price || mat.pricePerSqFt)) { unitPrice = mat.price || mat.pricePerSqFt; break; }
              }
            }
            else if (typeof CONFIG !== 'undefined') unitPrice = CONFIG.PRICING?.[el.type] || 0;
          }

          detailLine = `<span class="item-sqft">${area} sqft</span>`;
          if (canShowPrice && unitPrice > 0) detailLine += ` <span class="item-rate">@ $${unitPrice.toFixed(2)}/sqft</span>`;
        }

        html += `
          <div class="item-picker-item ${isSelected ? 'selected' : ''}"
               onclick="selectItemFromPicker(${realIdx})"
               data-id="${el.id}">
            <div class="item-row-main">
              <input type="checkbox" class="item-checkbox"
                     ${isChecked ? 'checked' : ''}
                     onclick="event.stopPropagation(); toggleItemSelection('${el.id}')">
              <div class="item-icon">${icon}</div>
              <div class="item-details">
                <div class="item-name">${el.label || typeName}</div>
                <div class="item-meta">
                  <span>${dims}</span>
                  ${!areaTypes.includes(el.type) ? `<span>${area} sq ft</span>` : ''}
                </div>
                ${detailLine ? `<div class="item-detail-line">${detailLine}</div>` : ''}
              </div>
              <div class="item-price">${price > 0 ? formatCurrency(price) : '--'}</div>
            </div>
            ${material ? `<div class="item-row-secondary">
              <span class="item-material">${material}</span>
              <span class="item-dims">Layer ${realIdx + 1}</span>
            </div>` : ''}
          </div>
        `;
      });

      listContainer.innerHTML = html;
    }

    // getElementCategory is defined earlier at line ~21225 (visibility toggles)

    function getElementIcon(type) {
      const icons = {
        // Cabinets
        'base-cabinet': '',
        'wall-cabinet': '',
        'tall-cabinet': '',
        'fridge-cabinet': '',
        'corner-cabinet': '',
        'island': '',
        'drawer-base': '',
        'sink-base': '',
        'lazy-susan': '',
        'blind-corner': '',
        'single-oven-cabinet': '',
        'tall-oven': '',
        'double-oven-cabinet': '',
        'microwave-cabinet': '',
        'above-microwave-cabinet': '',
        // Surfaces
        'countertop': '',
        'countertop-corner': '',
        'backsplash': '',
        'bar-top': '',
        'wall-cap': '',
        // Sinks
        'sink': '',
        'sink-double': '',
        'sink-farmhouse': '',
        // Appliances
        'stove': '',
        'range': '',
        'cooktop': '',
        'slide-in-range': '',
        'refrigerator': '',
        'dishwasher': '',
        'microwave': '',
        'oven': '',
        'wall-oven-double': '',
        'range-hood': '',
        // Flooring
        'flooring': '',
        'tile': '',
        'shower-pan': '',
        // Windows/Doors
        'window': '',
        'window-large': '',
        'window-bay': '',
        'bay-window': '',
        'picture-window': '',
        'door': '',
        'double-door': '',
        'sliding-door': '',
        'french-door': '',
        'glass-door': '',
        // Walls
        'wall': '',
        'pony-wall': '',
        'pony-wall-bar': '',
        'knee-wall': '',
        'accent-wall': '',
        'wall-tile': '',
        'shower-wall': '',
        // Bathroom
        'toilet': '',
        'bathtub': '',
        'bathtub-freestanding': '',
        'bathtub-corner': '',
        'bathtub-walk-in': '',
        'shower': '',
        'shower-base-36': '',
        'shower-base-48': '',
        'shower-base-60': '',
        'shower-bench': '',
        'towel-warmer': '',
        'grab-bar': '',
        'grab-bar-24': '',
        'grab-bar-36': '',
        'grab-bar-42': '',
        'toilet-round': '',
        'toilet-wall': '',
        'bidet': '',
        'vanity': '',
        'vanity-24': '',
        'vanity-30': '',
        'vanity-36': '',
        'vanity-48': '',
        'vanity-60': '',
        'vanity-72': '',
        // Laundry
        'washer': '',
        'dryer': '',
        'washer-dryer-stack': '',
        'laundry-cabinet': '',
        'ironing-board': '',
        'utility-sink': '',
        'laundry-sink': '',
        'drying-rack': '',
        // Closet
        'closet-rod': '',
        'closet-shelf': '',
        'drawer-unit': '',
        'closet-drawers': '',
        'shoe-rack': '',
        'closet-island': '',
        'jewelry-cabinet': '',
        'jewelry-drawer': '',
        'tie-rack': '',
        'full-mirror': '',
        // Niches
        'wall-niche': '',
        'shower-niche': '',
        'fireplace-niche': '',
        'tv-niche': '',
        'niche-surround': '',
        'fireplace-surround': '',
        'mantel': '',
        'fireplace-hearth': '',
        // Structural
        'steel-beam': '',
        'wood-beam': '',
        'concrete-beam': '',
        'header': '',
        'lvl-beam': '',
        'steel-column': '',
        'wood-post': '',
        'concrete-column': ''
      };
      return icons[type] || '';
    }

    function calculateElementPrice(el) {
      // Use the comprehensive getElementPrice function (defined later in file)
      // This function is called after all main functions are defined

      // Get price info using the comprehensive pricing system
      let priceInfo = { price: 0, source: 'default' };

      // 1) Manual override takes highest priority
      if (el.priceOverride !== null && el.priceOverride !== undefined) {
        priceInfo = { price: el.priceOverride, source: 'override' };
      }
      // 2) Check for cabinet catalog pricing (by SKU)
      else if (el.sku && el.catalog && typeof CABINET_CATALOGS !== 'undefined') {
        const catalog = CABINET_CATALOGS[el.catalog];
        if (catalog) {
          for (const category of Object.values(catalog.cabinets)) {
            const cab = category.find(c => c.sku === el.sku);
            if (cab && cab.price) {
              priceInfo = { price: cab.price, source: 'catalog' };
              break;
            }
          }
        }
      }
      // 3) Check store product price
      else if (el.storeProduct?.price) {
        priceInfo = { price: el.storeProduct.price, source: 'product' };
      }
      // 4) Check for material-specific pricing
      else if (el.materialId && typeof MATERIALS !== 'undefined') {
        for (const category in MATERIALS) {
          const mat = MATERIALS[category].find(m => m.id === el.materialId);
          if (mat && (mat.price || mat.pricePerSqFt)) {
            priceInfo = { price: mat.price || mat.pricePerSqFt, source: 'material' };
            break;
          }
        }
      }
      // 5) Check element's own pricePerSqFt
      else if (el.pricePerSqFt) {
        priceInfo = { price: el.pricePerSqFt, source: 'element' };
      }
      // 6) Check element's own price property
      else if (el.price) {
        priceInfo = { price: el.price, source: 'element' };
      }
      // 7) Check custom prices from Excel import
      else if (el.materialId && typeof PRICING_STATE !== 'undefined' && PRICING_STATE.customPrices?.[el.materialId]) {
        priceInfo = { price: PRICING_STATE.customPrices[el.materialId], source: 'pricelist' };
      }
      // 8) Fall back to default type pricing
      else if (typeof CONFIG !== 'undefined' && CONFIG.PRICING?.[el.type]) {
        priceInfo = { price: CONFIG.PRICING[el.type], source: 'default' };
      }

      let baseCost = priceInfo.price;

      // Calculate based on area for surface elements
      const areaTypes = ['countertop', 'countertop-corner', 'countertop-l', 'countertop-u', 'backsplash', 'flooring', 'tile', 'wall-tile', 'bar-top', 'wall-cap'];
      if (areaTypes.includes(el.type)) {
        const area = getElementSqft(el);
        baseCost = area * priceInfo.price;
      }

      // Get margin for retail pricing
      let margin = 30; // Default margin
      if (typeof PRICING_STATE !== 'undefined') {
        if (el.marginPercent !== null && el.marginPercent !== undefined) {
          margin = el.marginPercent;
        } else {
          // Get category-specific margin
          const cat = getElementCategory(el.type);
          const catMargins = { cabinets: 25, countertops: 35, appliances: 15, flooring: 30 };
          margin = PRICING_STATE.categoryMargins?.[cat] || catMargins[cat] || PRICING_STATE.globalMargin || 30;
        }
      }

      // Return retail price (cost + margin)
      return baseCost * (1 + margin / 100);
    }

    function formatCurrency(amount) {
      return '$' + amount.toFixed(2).replace(/\B(?=(\d{3})+(?!\d))/g, ',');
    }

    function selectItemFromPicker(idx) {
      if (idx >= 0 && idx < elements.length) {
        selectedElement = elements[idx];
        expandedElementType = selectedElement.type;
        updateProperties();
        updateElementSelector();
        updateItemPicker();
        draw();
      }
    }

    function toggleItemSelection(id) {
      // Convert to string for consistent comparison
      const strId = String(id);
      if (selectedItems.has(strId)) {
        selectedItems.delete(strId);
      } else {
        selectedItems.add(strId);
      }
      updateItemPicker();
    }

    function selectAllItems() {
      elements.forEach(el => selectedItems.add(String(el.id)));
      updateItemPicker();
    }

    function deselectAllItems() {
      selectedItems.clear();
      updateItemPicker();
    }

    function deleteSelectedItems() {
      if (selectedItems.size === 0) {
        showToast('No items selected', 'warning');
        return;
      }

      const count = selectedItems.size;
      elements = elements.filter(el => !selectedItems.has(String(el.id)));
      selectedItems.clear();
      selectedElement = null;

      saveUndoState();
      updateProperties();
      updateElementList();
      updateItemPicker();
      draw();
      showToast(`Deleted ${count} item${count > 1 ? 's' : ''}`, 'success');
    }

    function filterItemList() {
      const filterSelect = document.getElementById('itemFilterType');
      itemPickerFilter = filterSelect ? filterSelect.value : 'all';
      updateItemPicker();
    }

    // Update element layer list panel
    function updateElementList() {
      const listContainer = domCache.elementLayerList || document.getElementById('elementLayerList');
      const countDisplay = domCache.elementCountDisplay || document.getElementById('elementCountDisplay');
      if (!listContainer) return;

      // Check if anything actually changed - skip rebuild if nothing changed
      const currentSelectedId = selectedElement ? selectedElement.id : null;
      if (!elementListDirty && currentSelectedId === lastSelectedElementId) {
        return; // Skip rebuild - nothing changed
      }
      elementListDirty = false;
      lastSelectedElementId = currentSelectedId;

      // Update count
      if (countDisplay) countDisplay.textContent = elements.length;

      // Also update the element selector dropdown and item picker
      updateElementSelector();
      updateItemPicker();

      // Build list HTML
      if (elements.length === 0) {
        listContainer.innerHTML = '<div style="color: #888; padding: 8px; text-align: center;">No elements yet</div>';
        return;
      }

      // Sort by z-order for display
      const sortedElements = [...elements].sort((a, b) => {
        const aZ = (a.zIndexOffset || 0);
        const bZ = (b.zIndexOffset || 0);
        return bZ - aZ; // Higher z-index first
      });

      let html = '';
      sortedElements.forEach((el, idx) => {
        const isSelected = el === selectedElement;
        const label = el.label || el.materialName || formatElementType(el.type);
        const truncatedLabel = label.length > 20 ? label.substring(0, 18) + '...' : label;
        const layerNum = elements.length - idx;

        html += `
          <div class="element-layer-item ${isSelected ? 'selected' : ''}"
               onclick="selectElementFromList(${elements.indexOf(el)})"
               ondblclick="centerOnElement(${elements.indexOf(el)})"
               style="
                 display: flex;
                 align-items: center;
                 padding: 4px 8px;
                 cursor: pointer;
                 border-radius: 4px;
                 margin-bottom: 2px;
                 background: ${isSelected ? 'var(--gold)' : 'rgba(255,255,255,0.05)'};
                 color: ${isSelected ? '#000' : 'inherit'};
               ">
            <span style="
              width: 12px;
              height: 12px;
              border-radius: 2px;
              background: ${el.color || '#808080'};
              margin-right: 6px;
              flex-shrink: 0;
            "></span>
            <span style="flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">
              ${truncatedLabel}
            </span>
            <span style="font-size: 9px; color: ${isSelected ? '#333' : '#666'}; margin-left: 4px;">
              ${el.hidden ? '' : ''}
            </span>
          </div>
        `;
      });

      listContainer.innerHTML = html;
    }

    // Format element type for display
    function formatElementType(type) {
      return type.split('-').map(word =>
        word.charAt(0).toUpperCase() + word.slice(1)
      ).join(' ');
    }

    // Select element from the list
    function selectElementFromList(index) {
      if (index >= 0 && index < elements.length) {
        selectedElement = elements[index];
        updateProperties();
        updateElementList();
        updateElementSelector();
        draw();
      }
    }

    // Update the element selector dropdown in the right panel
    // Track which element type is currently expanded in the selector
    let expandedElementType = null;

    function updateElementSelector() {
      const flatList = document.getElementById('elementFlatList');
      const totalCount = document.getElementById('elementTotalCount');
      const actions = document.getElementById('elementSelectorActions');
      const filterSelect = document.getElementById('elementListFilter');

      if (!flatList) return;

      // Update total count
      if (totalCount) totalCount.textContent = elements.length;

      // Get current filter
      const filter = filterSelect ? filterSelect.value : 'all';

      // Filter elements
      const filteredElements = elements.filter(el => {
        if (filter === 'all') return true;
        const cat = getElementCategory(el.type);
        if (filter === 'cabinets') return cat === 'cabinets';
        if (filter === 'countertops') return cat === 'countertops';
        if (filter === 'appliances') return cat === 'appliances';
        if (filter === 'fixtures') return ['fixtures', 'bathroom'].includes(cat);
        return !['cabinets', 'countertops', 'appliances', 'fixtures', 'bathroom'].includes(cat);
      });

      // Build flat list
      if (elements.length === 0) {
        flatList.innerHTML = '<div class="no-elements-msg">No elements on canvas.<br>Drag items from the left panel.</div>';
        if (actions) actions.style.display = 'none';
        return;
      }

      if (filteredElements.length === 0) {
        flatList.innerHTML = '<div class="no-elements-msg">No elements match filter.</div>';
        if (actions) actions.style.display = 'none';
        return;
      }

      let html = '';
      filteredElements.forEach((el) => {
        const realIdx = elements.indexOf(el);
        const isSelected = selectedElement && selectedElement.id === el.id;
        const icon = getElementIcon(el.type);
        const typeName = el.type.replace(/-/g, ' ').replace(/\b\w/g, c => c.toUpperCase());
        const label = el.label || el.sku || typeName;
        const dims = `${el.width.toFixed(1)}'  ${el.height.toFixed(1)}'`;
        const material = el.materialName || '';

        html += `
          <div class="element-list-item ${isSelected ? 'selected' : ''}"
               onclick="selectAndFocusElement(${realIdx})"
               ondblclick="centerOnElement(${realIdx})"
               data-idx="${realIdx}">
            <span class="element-list-icon">${icon}</span>
            <div class="element-list-info">
              <div class="element-list-name">${label}</div>
              <div class="element-list-meta">${dims}${material ? '  ' + material : ''}</div>
            </div>
          </div>
        `;
      });

      flatList.innerHTML = html;

      // Show/hide actions based on selection
      if (actions) {
        actions.style.display = selectedElement ? 'flex' : 'none';
      }

      // Scroll selected element into view
      if (selectedElement) {
        const selectedItem = flatList.querySelector('.element-list-item.selected');
        if (selectedItem) {
          selectedItem.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }
      }
    }

    // Toggle element type expansion
    function toggleElementType(type) {
      if (expandedElementType === type) {
        // Collapse if already expanded
        expandedElementType = null;
      } else {
        // Expand this type
        expandedElementType = type;

        // Auto-select first element of this type if nothing selected
        const firstOfType = elements.find(el => el.type === type);
        if (firstOfType && (!selectedElement || selectedElement.type !== type)) {
          selectedElement = firstOfType;
          updateProperties();
          draw();
        }
      }
      updateElementSelector();
    }

    // Select element by index
    function selectElementByIndex(idx) {
      if (idx >= 0 && idx < elements.length) {
        selectedElement = elements[idx];
        expandedElementType = selectedElement.type;
        updateProperties();
        updateElementList();
        updateElementSelector();
        draw();
      }
    }

    // Select element and focus on it - called from element list
    function selectAndFocusElement(idx) {
      if (idx >= 0 && idx < elements.length) {
        selectedElement = elements[idx];
        expandedElementType = selectedElement.type;

        // Update UI
        updateProperties();
        updateElementList();
        updateElementSelector();
        updateItemPicker();
        draw();

        // Show a brief highlight effect on the canvas
        showSnapFeedback(`Selected: ${formatElementType(selectedElement.type)}`);
      }
    }

    // Handle selection from dropdown (legacy - keeping for compatibility)
    function selectElementFromDropdown() {
      // This function is now replaced by the type selector
      // Keeping for backward compatibility
      if (!selectedElement) return;
      updateProperties();
      updateElementList();
      draw();
    }

    // Focus/center view on selected element
    function focusSelectedElement() {
      if (!selectedElement) return;
      const idx = elements.indexOf(selectedElement);
      if (idx >= 0) {
        centerOnElement(idx);
      }
    }

    // Duplicate selected element
    // NOTE: duplicateSelectedElement and deleteSelectedElement are defined earlier
    // with proper locked status checks and 3D scene updates

    // Center view on element
    function centerOnElement(index) {
      if (index >= 0 && index < elements.length) {
        const el = elements[index];
        // Calculate center of element
        const centerX = el.x + (el.width * pixelsPerFoot) / 2;
        const centerY = el.y + (el.height * pixelsPerFoot) / 2;

        // Scroll canvas to center on element (if canvas is scrollable)
        const canvas = document.getElementById('canvas');
        if (canvas) {
          const container = canvas.parentElement;
          if (container) {
            container.scrollLeft = centerX - container.clientWidth / 2;
            container.scrollTop = centerY - container.clientHeight / 2;
          }
        }

        selectElementFromList(index);
        showSnapFeedback(`Centered on ${formatElementType(el.type)}`);
      }
    }

    // Move selected element up in layer order (higher z-index)
    function moveLayerUp() {
      if (selectedElement) {
        selectedElement.zIndexOffset = (selectedElement.zIndexOffset || 0) + 10;
        saveUndoState();
        draw();
        update3DScene();
        updateElementList();
        showSnapFeedback('Moved layer up');
      }
    }

    // Move selected element down in layer order (lower z-index)
    function moveLayerDown() {
      if (selectedElement) {
        selectedElement.zIndexOffset = (selectedElement.zIndexOffset || 0) - 10;
        saveUndoState();
        draw();
        update3DScene();
        updateElementList();
        showSnapFeedback('Moved layer down');
      }
    }

    // Delete with undo toast - allows quick undo without confirmation dialog
    let lastDeletedElement = null;
    let deleteUndoTimeout = null;

    function deleteElementWithUndo(element) {
      if (!element || element.locked) return;

      // Store element for potential undo
      lastDeletedElement = JSON.parse(JSON.stringify(element));
      lastDeletedElement._originalIndex = elements.indexOf(element);

      // Remove element
      elements = elements.filter(el => el !== element);
      elementListDirty = true;
      selectedElement = null;
      updateProperties();
      calculateQuote();
      saveUndoState();
      draw();
      update3DScene();

      // Show undo toast
      showUndoToast(element.label || formatElementType(element.type));
    }

    function showUndoToast(itemName) {
      // Remove existing undo toast
      const existingToast = document.getElementById('undoToast');
      if (existingToast) existingToast.remove();

      // Clear existing timeout
      if (deleteUndoTimeout) clearTimeout(deleteUndoTimeout);

      const toast = document.createElement('div');
      toast.id = 'undoToast';
      toast.className = 'undo-toast';
      toast.innerHTML = `
        <span>Deleted "${itemName}"</span>
        <button onclick="undoLastDelete()">Undo</button>
        <button class="dismiss" onclick="dismissUndoToast()"></button>
      `;
      document.body.appendChild(toast);

      // Auto-dismiss after 5 seconds
      deleteUndoTimeout = setTimeout(() => {
        dismissUndoToast();
        lastDeletedElement = null;
      }, 5000);

      // Animate in
      requestAnimationFrame(() => toast.classList.add('show'));
    }

    function undoLastDelete() {
      if (!lastDeletedElement) return;

      // Restore element
      const restoredEl = {
        ...lastDeletedElement,
        id: Date.now() + Math.random() // New ID
      };
      delete restoredEl._originalIndex;

      // Insert at original position or at end
      const index = lastDeletedElement._originalIndex;
      if (index !== undefined && index >= 0 && index <= elements.length) {
        elements.splice(index, 0, restoredEl);
      } else {
        elements.push(restoredEl);
      }

      elementListDirty = true;
      selectedElement = restoredEl;
      updateProperties();
      calculateQuote();
      saveUndoState();
      draw();
      update3DScene();

      dismissUndoToast();
      showToast('Element restored', 'success');
      lastDeletedElement = null;
    }

    function dismissUndoToast() {
      const toast = document.getElementById('undoToast');
      if (toast) {
        toast.classList.remove('show');
        setTimeout(() => toast.remove(), 300);
      }
      if (deleteUndoTimeout) {
        clearTimeout(deleteUndoTimeout);
        deleteUndoTimeout = null;
      }
    }

    function deleteSelectedElement() {
      if (selectedElement && !selectedElement.locked) {
        deleteElementWithUndo(selectedElement);
      }
    }

    // ===== CONTEXT MENU =====
    const CABINET_TYPES_FOR_MENU = ['base-cabinet', 'wall-cabinet', 'tall-cabinet', 'corner-cabinet',
                                     'drawer-base', 'sink-base', 'lazy-susan', 'blind-corner', 'island',
                                     'microwave-cabinet', 'above-microwave-cabinet', 'fridge-cabinet',
                                     'single-oven-cabinet', 'tall-oven', 'double-oven-cabinet', 'laundry-cabinet'];

    function showContextMenu(x, y, element) {
      const menu = document.getElementById('contextMenu');
      menu.style.display = 'block';
      menu.style.left = x + 'px';
      menu.style.top = y + 'px';

      document.getElementById('contextMenuLabel').textContent = element.label;
      document.getElementById('lockText').textContent = element.locked ? 'Unlock' : 'Lock';

      // Show/hide cabinet-specific options
      const cabinetTypes = ['base-cabinet', 'drawer-base', 'sink-base', 'wall-cabinet',
                            'tall-cabinet', 'corner-cabinet', 'lazy-susan', 'blind-corner',
                            'island', 'fridge-cabinet', 'single-oven-cabinet', 'tall-oven',
                            'double-oven-cabinet', 'microwave-cabinet', 'above-microwave-cabinet'];
      const isCabinet = CABINET_TYPES_FOR_MENU.includes(element.type) ||
                        cabinetTypes.includes(element.type) ||
                        element.type?.startsWith('base-cabinet-') ||
                        element.type?.startsWith('wall-cabinet-') ||
                        element.type?.startsWith('tall-cabinet-') ||
                        element.type?.startsWith('drawer-base-') ||
                        element.type?.startsWith('sink-base-');
      const replaceItem = document.getElementById('replaceMenuItem');
      const resizeItem = document.getElementById('resizeMenuItem');
      if (replaceItem) replaceItem.style.display = isCabinet ? 'flex' : 'none';
      if (resizeItem) resizeItem.style.display = isCabinet ? 'flex' : 'none';

      // Show/hide group options
      const groupItem = document.getElementById('groupAdjacentMenuItem');
      const ungroupItem = document.getElementById('ungroupMenuItem');
      const isInGroup = !!element.groupId;
      if (groupItem) groupItem.style.display = (isCabinet && !isInGroup) ? 'flex' : 'none';
      if (ungroupItem) ungroupItem.style.display = isInGroup ? 'flex' : 'none';
    }

    function hideContextMenu() {
      document.getElementById('contextMenu').style.display = 'none';
      contextMenuElement = null;
    }

    function contextAction(action) {
      if (!contextMenuElement) return;

      switch(action) {
        case 'rotate':
          if (!contextMenuElement.locked) {
            contextMenuElement.rotation = ((contextMenuElement.rotation || 0) + 90) % 360;
          }
          break;
        case 'duplicate':
          duplicateElement(contextMenuElement);
          break;
        case 'texture':
          selectedElement = contextMenuElement;
          openMaterialPicker();
          break;
        case 'lock':
          contextMenuElement.locked = !contextMenuElement.locked;
          break;
        case 'front':
          elements = elements.filter(el => el !== contextMenuElement);
          elements.push(contextMenuElement);
          break;
        case 'back':
          elements = elements.filter(el => el !== contextMenuElement);
          elements.unshift(contextMenuElement);
          break;
        case 'delete':
          if (!contextMenuElement.locked) {
            elements = elements.filter(el => el !== contextMenuElement);
            if (selectedElement === contextMenuElement) {
              selectedElement = null;
              updateProperties();
            }
          }
          break;
        case 'replace':
          openReplaceCabinetModal(contextMenuElement);
          break;
        case 'resize':
          openResizeCabinetModal(contextMenuElement);
          break;
        case 'groupAdjacent':
          groupAdjacentCabinets();
          break;
        case 'ungroupCabinets':
          ungroupCabinets(contextMenuElement);
          break;
      }

      hideContextMenu();
      draw();
    }

    // ===== CABINET REPLACE/RESIZE MODALS =====
    let cabinetToReplace = null;
    let cabinetToResize = null;

    function openReplaceCabinetModal(element) {
      cabinetToReplace = element;
      const modal = document.getElementById('replaceCabinetModal');
      const typeSelect = document.getElementById('replaceCabinetType');
      const widthSelect = document.getElementById('replaceCabinetWidth');

      // Pre-select current type if available
      if (typeSelect) {
        const currentType = element.type;
        const options = typeSelect.options;
        for (let i = 0; i < options.length; i++) {
          if (options[i].value === currentType) {
            typeSelect.selectedIndex = i;
            break;
          }
        }
      }

      // Pre-select current width
      if (widthSelect) {
        const currentWidth = element.width || 2;
        const options = widthSelect.options;
        let closestIndex = 0;
        let closestDiff = Infinity;
        for (let i = 0; i < options.length; i++) {
          const diff = Math.abs(parseFloat(options[i].value) - currentWidth);
          if (diff < closestDiff) {
            closestDiff = diff;
            closestIndex = i;
          }
        }
        widthSelect.selectedIndex = closestIndex;
      }

      if (modal) modal.style.display = 'flex';
    }

    function closeReplaceCabinetModal() {
      const modal = document.getElementById('replaceCabinetModal');
      if (modal) modal.style.display = 'none';
      cabinetToReplace = null;
    }

    function applyReplaceCabinet() {
      if (!cabinetToReplace) return;

      const typeSelect = document.getElementById('replaceCabinetType');
      const widthSelect = document.getElementById('replaceCabinetWidth');
      const newType = typeSelect ? typeSelect.value : 'base-cabinet';
      const newWidth = widthSelect ? parseFloat(widthSelect.value) : 2;

      // Handle filler types specially
      let actualType = newType;
      let isFiller = false;
      if (newType === 'filler-3') {
        actualType = 'base-cabinet';
        isFiller = true;
        cabinetToReplace.width = 0.25; // 3"
      } else if (newType === 'filler-6') {
        actualType = 'base-cabinet';
        isFiller = true;
        cabinetToReplace.width = 0.5; // 6"
      } else {
        cabinetToReplace.width = newWidth;
      }

      // Get cabinet style info
      const widthInches = Math.round(cabinetToReplace.width * 12);
      const styles = {
        'base-cabinet': { color: '#8B4513', label: `Base ${widthInches}"` },
        'drawer-base': { color: '#8B5A2B', label: `Drawer ${widthInches}"` },
        'sink-base': { color: '#6B4423', label: `Sink Base ${widthInches}"` },
        'corner-cabinet': { color: '#A0522D', label: 'Corner 36"' },
        'lazy-susan': { color: '#A0522D', label: 'Lazy Susan' },
        'blind-corner': { color: '#7B5513', label: 'Blind Corner' },
        'wall-cabinet': { color: '#D2691E', label: `Wall ${widthInches}"` },
        'tall-cabinet': { color: '#5D4037', label: `Tall ${widthInches}"` },
        'fridge-cabinet': { color: '#5D4037', label: 'Fridge Cab' },
        'single-oven-cabinet': { color: '#5D4037', label: 'Oven Cab' },
        'tall-oven': { color: '#5D4037', label: 'Tall Oven' },
        'double-oven-cabinet': { color: '#5D4037', label: 'Dbl Oven Cab' },
        'dishwasher': { color: '#607D8B', label: 'Dishwasher' },
        'range': { color: '#455A64', label: 'Range' },
        'microwave-cabinet': { color: '#5D4037', label: 'Microwave Cab' }
      };

      const style = isFiller ? { color: '#654321', label: `Filler ${widthInches}"` } : (styles[actualType] || { color: '#8B4513', label: `${widthInches}"` });

      // Update the cabinet
      cabinetToReplace.type = actualType;
      cabinetToReplace.color = style.color;
      cabinetToReplace.label = style.label;
      cabinetToReplace.isFiller = isFiller;

      // Update depth based on type
      if (actualType === 'wall-cabinet') {
        cabinetToReplace.height = 1; // 12" depth
      } else if (actualType === 'corner-cabinet' || actualType === 'lazy-susan') {
        cabinetToReplace.width = 3; // 36" square
        cabinetToReplace.height = 3;
      } else if (actualType === 'tall-cabinet' || actualType === 'fridge-cabinet' || actualType === 'single-oven-cabinet' || actualType === 'tall-oven' || actualType === 'double-oven-cabinet') {
        cabinetToReplace.height = 2; // 24" depth
      }

      saveUndoState();
      closeReplaceCabinetModal();
      draw();
      update3DScene();
      showSnapFeedback(`Replaced with ${style.label}`);
    }

    function openResizeCabinetModal(element) {
      cabinetToResize = element;
      const modal = document.getElementById('resizeCabinetModal');
      const widthSelect = document.getElementById('resizeCabinetWidth');

      // Pre-select current width
      if (widthSelect) {
        const currentWidth = element.width || 2;
        const options = widthSelect.options;
        let closestIndex = 0;
        let closestDiff = Infinity;
        for (let i = 0; i < options.length; i++) {
          const diff = Math.abs(parseFloat(options[i].value) - currentWidth);
          if (diff < closestDiff) {
            closestDiff = diff;
            closestIndex = i;
          }
        }
        widthSelect.selectedIndex = closestIndex;
      }

      if (modal) modal.style.display = 'flex';
    }

    function closeResizeCabinetModal() {
      const modal = document.getElementById('resizeCabinetModal');
      if (modal) modal.style.display = 'none';
      cabinetToResize = null;
    }

    function applyResizeCabinet() {
      if (!cabinetToResize) return;

      const widthSelect = document.getElementById('resizeCabinetWidth');
      const newWidth = widthSelect ? parseFloat(widthSelect.value) : 2;
      const widthInches = Math.round(newWidth * 12);

      cabinetToResize.width = newWidth;

      // Update label to reflect new size
      const typeLabel = cabinetToResize.type.replace(/-/g, ' ').replace(/\b\w/g, c => c.toUpperCase()).replace('Cabinet', '').trim();
      cabinetToResize.label = `${typeLabel} ${widthInches}"`;

      saveUndoState();
      closeResizeCabinetModal();
      draw();
      update3DScene();
      showSnapFeedback(`Resized to ${widthInches}"`);
    }

    // ===== TOOLS =====
    function setTool(tool) {
      try {
        currentTool = tool;
        document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('active'));
        const btn = document.getElementById('tool' + tool.charAt(0).toUpperCase() + tool.slice(1));
        if (btn) btn.classList.add('active');

        // Show/hide layout options panel
        const layoutPanel = document.getElementById('layoutOptionsPanel');
        if (layoutPanel) {
          layoutPanel.style.display = tool === 'layout' ? 'block' : 'none';
        }

        // Reset layout mode when switching tools
        if (tool !== 'layout') {
          resetLayoutMode();
        }

        canvas.style.cursor = (tool === 'wall' || tool === 'countertop' || tool === 'layout') ? 'crosshair' : (tool === 'pan' ? 'grab' : 'default');
        draw();
      } catch (err) {
        console.error('setTool error:', err);
        currentTool = 'select';
      }
    }

    // Layout tool option handlers
    function updateLayoutElementType() {
      const select = document.getElementById('layoutElementType');
      layoutMode.cabinetType = select.value;

      // Auto-adjust depth based on element type
      const depthSelect = document.getElementById('layoutDepth');
      switch (select.value) {
        // Wall cabinets - 12" deep
        case 'wall-cabinet':
        case 'wall-corner':
          depthSelect.value = '1';
          layoutMode.cabinetDepth = 1;
          break;

        // Base cabinets - 24" deep
        case 'base-cabinet':
        case 'drawer-base':
        case 'sink-base':
        case 'corner-cabinet':
        case 'lazy-susan':
        case 'blind-corner':
          depthSelect.value = '2';
          layoutMode.cabinetDepth = 2;
          break;

        // Tall cabinets - 24" deep
        case 'tall-cabinet':
        case 'tall-oven':
        case 'fridge-cabinet':
          depthSelect.value = '2';
          layoutMode.cabinetDepth = 2;
          break;

        // Islands - 24-36" deep
        case 'island':
          depthSelect.value = '2';
          layoutMode.cabinetDepth = 2;
          break;

        // Walls - 6" thick
        case 'pony-wall':
        case 'pony-wall-bar':
        case 'knee-wall':
        case 'wall':
          depthSelect.value = '0.5';
          layoutMode.cabinetDepth = 0.5;
          // Add wall thickness option if not present
          if (!depthSelect.querySelector('option[value="0.5"]')) {
            const opt = document.createElement('option');
            opt.value = '0.5';
            opt.textContent = '6" (Wall)';
            depthSelect.insertBefore(opt, depthSelect.firstChild);
          }
          break;

        // Countertops - match cabinet depth (26" with overhang)
        case 'countertop':
        case 'countertop-corner':
          depthSelect.value = '2';
          layoutMode.cabinetDepth = 2.17; // 26" = 25" cabinet + 1" overhang
          break;

        // Backsplash - thin
        case 'backsplash':
          depthSelect.value = '1';
          layoutMode.cabinetDepth = 0.08; // Very thin for backsplash
          break;
      }

      // Disable "Draw Both Levels" if not a base cabinet type
      const bothLevelsCheckbox = document.getElementById('layoutBothLevels');
      const isBaseCabinet = ['base-cabinet', 'drawer-base', 'sink-base', 'corner-cabinet', 'lazy-susan', 'blind-corner'].includes(select.value);
      if (bothLevelsCheckbox && !isBaseCabinet && layoutMode.drawBothLevels) {
        bothLevelsCheckbox.checked = false;
        layoutMode.drawBothLevels = false;
      }

      showSnapFeedback(`Layout: ${select.options[select.selectedIndex].text}`);
    }

    function updateLayoutDepth() {
      const select = document.getElementById('layoutDepth');
      layoutMode.cabinetDepth = parseFloat(select.value);
      showSnapFeedback(`Depth: ${Math.round(layoutMode.cabinetDepth * 12)}"`);
    }

    function updateLayoutCountertop() {
      const checkbox = document.getElementById('layoutAddCountertop');
      layoutMode.addCountertop = checkbox.checked;
    }

    function updateLayoutWallSnap() {
      const checkbox = document.getElementById('layoutSnapToWalls');
      layoutMode.snapToWalls = checkbox.checked;
    }

    function updateLayoutBothLevels() {
      const checkbox = document.getElementById('layoutBothLevels');
      layoutMode.drawBothLevels = checkbox.checked;

      // When enabled, force base cabinet type and standard depth
      if (checkbox.checked) {
        const typeSelect = document.getElementById('layoutElementType');
        const depthSelect = document.getElementById('layoutDepth');
        if (typeSelect) {
          typeSelect.value = 'base-cabinet';
          layoutMode.cabinetType = 'base-cabinet';
        }
        if (depthSelect) {
          depthSelect.value = '2';
          layoutMode.cabinetDepth = 2;
        }
        showSnapFeedback('Drawing upper + lower cabinets together');
      } else {
        showSnapFeedback('Drawing single level cabinets');
      }
    }

    function updateLayoutCornerType() {
      const select = document.getElementById('layoutCornerType');
      layoutMode.cornerType = select.value;
      showSnapFeedback(`Corner: ${select.options[select.selectedIndex].text}`);
    }

    // ===== CABINET LAYOUT TOOL =====
    // ===== DRAFTING-STYLE LAYOUT BRUSH =====
    // Click-drag to draw straight orthogonal cabinet runs
    // Automatically creates corners when direction changes significantly
    const layoutMode = {
      isDrawing: false,     // Currently dragging
      corners: [],          // Corner points (where direction changes)
      currentEnd: null,     // Current endpoint (snapped to orthogonal)
      currentDirection: null, // 'horizontal' or 'vertical'
      points: [],           // Legacy array for backward compatibility
      active: false,        // Legacy flag
      cabinetType: 'base-cabinet',
      cabinetDepth: 2,      // 24" depth (standard base cabinet)
      cornerType: 'corner-cabinet', // How to handle corners
      addCountertop: false, // Don't auto-add countertop - user can add separately
      snapToWalls: true,    // Auto-snap to walls and room boundaries
      gridSnap: 0.5,        // Snap to 6" grid
      turnThreshold: 1.5,   // Feet of movement in perpendicular direction to trigger turn
      minRunLength: 1,      // Minimum 1 foot run
      // Upper + Lower cabinet pairing
      drawBothLevels: true,    // Draw wall cabinets above base cabinets
      wallCabinetDepth: 1,     // 12" depth for wall cabinets
      // Standard cabinet widths (in feet): 36", 33", 30", 27", 24", 21", 18", 15", 12", 9"
      standardWidths: [3, 2.75, 2.5, 2.25, 2, 1.75, 1.5, 1.25, 1, 0.75],
      // Filler widths for gaps (in feet): 6", 3"
      fillerWidths: [0.5, 0.25]
    };

    // Snap a value to the grid
    function snapToGrid(val) {
      return Math.round(val / layoutMode.gridSnap) * layoutMode.gridSnap;
    }

    // Snap to walls - find nearest wall edge and snap to it if within threshold
    function snapToWalls(worldX, worldY, direction) {
      const snapThreshold = 1.0; // 1 foot snap threshold
      const depth = layoutMode.cabinetDepth || 2;
      let snappedX = worldX;
      let snappedY = worldY;
      let snappedToWall = null;

      // Get all wall-like elements (including room boundaries)
      const wallElements = elements.filter(el =>
        el.type === 'wall' ||
        el.type === 'pony-wall' ||
        el.type === 'knee-wall' ||
        el.type === 'pony-wall-bar'
      );

      // Also consider room boundaries as virtual walls
      const roomWalls = [
        { edge: 'top', y: 0, isHorizontal: true },
        { edge: 'bottom', y: roomDepth, isHorizontal: true },
        { edge: 'left', x: 0, isHorizontal: false },
        { edge: 'right', x: roomWidth, isHorizontal: false }
      ];

      // Check room boundaries first
      roomWalls.forEach(rw => {
        if (rw.isHorizontal) {
          // Top/bottom walls - snap Y position
          const distToWall = Math.abs(worldY - rw.y);
          const distWithDepth = Math.abs(worldY - depth/2 - rw.y);
          const distWithDepthOther = Math.abs(worldY + depth/2 - rw.y);

          if (distToWall < snapThreshold) {
            // Snap cabinet to be against this wall
            snappedY = rw.edge === 'top' ? depth/2 : rw.y - depth/2;
            snappedToWall = rw.edge + ' wall';
          } else if (distWithDepth < snapThreshold || distWithDepthOther < snapThreshold) {
            snappedY = rw.edge === 'top' ? depth/2 : rw.y - depth/2;
            snappedToWall = rw.edge + ' wall';
          }
        } else {
          // Left/right walls - snap X position
          const distToWall = Math.abs(worldX - rw.x);

          if (distToWall < snapThreshold) {
            snappedX = rw.edge === 'left' ? depth/2 : rw.x - depth/2;
            snappedToWall = rw.edge + ' wall';
          }
        }
      });

      // Check drawn walls
      wallElements.forEach(wall => {
        const wallX = wall.x / pixelsPerFoot;
        const wallY = wall.y / pixelsPerFoot;
        const wallW = wall.width;
        const wallH = wall.height;
        const wallCenterX = wallX + wallW/2;
        const wallCenterY = wallY + wallH/2;

        // Determine if wall is horizontal or vertical
        const wallIsHorizontal = wallW > wallH;

        if (wallIsHorizontal) {
          // Check if we're near the top or bottom edge of this horizontal wall
          const topEdge = wallY;
          const bottomEdge = wallY + wallH;

          // Snap to top edge (place cabinets above wall)
          if (Math.abs(worldY - topEdge) < snapThreshold) {
            snappedY = topEdge - depth/2;
            snappedToWall = wall.label || 'wall';
          }
          // Snap to bottom edge (place cabinets below wall)
          else if (Math.abs(worldY - bottomEdge) < snapThreshold) {
            snappedY = bottomEdge + depth/2;
            snappedToWall = wall.label || 'wall';
          }
        } else {
          // Check if we're near the left or right edge of this vertical wall
          const leftEdge = wallX;
          const rightEdge = wallX + wallW;

          // Snap to left edge
          if (Math.abs(worldX - leftEdge) < snapThreshold) {
            snappedX = leftEdge - depth/2;
            snappedToWall = wall.label || 'wall';
          }
          // Snap to right edge
          else if (Math.abs(worldX - rightEdge) < snapThreshold) {
            snappedX = rightEdge + depth/2;
            snappedToWall = wall.label || 'wall';
          }
        }
      });

      return {
        x: snapToGrid(snappedX),
        y: snapToGrid(snappedY),
        snappedTo: snappedToWall
      };
    }

    // Start drawing layout path on mouse down
    function startLayoutDraw(screenX, screenY) {
      try {
        const rawX = screenX / pixelsPerFoot;
        const rawY = screenY / pixelsPerFoot;

        let worldX, worldY;

        // Try to snap to nearby walls if enabled
        if (layoutMode.snapToWalls) {
          const snapped = snapToWalls(rawX, rawY, null);
          worldX = snapped.x;
          worldY = snapped.y;

          if (snapped.snappedTo) {
            showSnapFeedback(`Snapped to ${snapped.snappedTo}`);
          }
        } else {
          worldX = snapToGrid(rawX);
          worldY = snapToGrid(rawY);
        }

        layoutMode.isDrawing = true;
        layoutMode.corners = [{ x: worldX, y: worldY }];
        layoutMode.currentEnd = { x: worldX, y: worldY };
        layoutMode.currentDirection = null;

        canvas.style.cursor = 'crosshair';
        draw();
      } catch (err) {
        console.error('Layout startDraw error:', err);
        resetLayoutMode();
      }
    }

    // Reset layout mode to clean state
    function resetLayoutMode() {
      layoutMode.isDrawing = false;
      layoutMode.corners = [];
      layoutMode.currentEnd = null;
      layoutMode.currentDirection = null;
      layoutMode.active = false;
      layoutMode.points = [];
      canvas.style.cursor = currentTool === 'layout' ? 'crosshair' : 'default';
    }

    // Continue drawing layout path on mouse move
    function continueLayoutDraw(screenX, screenY) {
      try {
        if (!layoutMode.isDrawing) return;
        if (!layoutMode.corners || layoutMode.corners.length === 0) {
          resetLayoutMode();
          return;
        }

        const worldX = screenX / pixelsPerFoot;
        const worldY = screenY / pixelsPerFoot;

        const lastCorner = layoutMode.corners[layoutMode.corners.length - 1];
        if (!lastCorner) {
          resetLayoutMode();
          return;
        }

        const dx = worldX - lastCorner.x;
        const dy = worldY - lastCorner.y;
        const absDx = Math.abs(dx);
        const absDy = Math.abs(dy);

        // Determine if we should be drawing horizontal or vertical
        if (layoutMode.currentDirection === null) {
          // First movement - determine direction based on which axis has more movement
          if (absDx > 0.5 || absDy > 0.5) {
            layoutMode.currentDirection = absDx > absDy ? 'horizontal' : 'vertical';
          }
        }

        // Check if user is trying to turn (significant movement in perpendicular direction)
        if (layoutMode.currentDirection === 'horizontal' && absDy > layoutMode.turnThreshold && absDx > layoutMode.minRunLength) {
          // User wants to turn from horizontal to vertical
          // First, finalize the horizontal segment
          const endX = snapToGrid(worldX);
          layoutMode.corners.push({ x: endX, y: lastCorner.y });
          layoutMode.currentDirection = 'vertical';
        } else if (layoutMode.currentDirection === 'vertical' && absDx > layoutMode.turnThreshold && absDy > layoutMode.minRunLength) {
          // User wants to turn from vertical to horizontal
          const endY = snapToGrid(worldY);
          layoutMode.corners.push({ x: lastCorner.x, y: endY });
          layoutMode.currentDirection = 'horizontal';
        }

        // Update current end point (constrained to current direction)
        const currentCorner = layoutMode.corners[layoutMode.corners.length - 1];
        if (!currentCorner) {
          resetLayoutMode();
          return;
        }

        if (layoutMode.currentDirection === 'horizontal') {
          layoutMode.currentEnd = {
            x: snapToGrid(worldX),
            y: currentCorner.y
          };
        } else if (layoutMode.currentDirection === 'vertical') {
          layoutMode.currentEnd = {
            x: currentCorner.x,
            y: snapToGrid(worldY)
          };
        } else {
          // No direction yet - show preview in dominant direction
          layoutMode.currentEnd = {
            x: absDx > absDy ? snapToGrid(worldX) : currentCorner.x,
            y: absDy > absDx ? snapToGrid(worldY) : currentCorner.y
          };
        }

        draw();
      } catch (err) {
        console.error('Layout continueDraw error:', err);
        resetLayoutMode();
      }
    }

    // Finish drawing and generate cabinets on mouse up
    function finishLayoutDraw() {
      try {
        if (!layoutMode.isDrawing) return;
        layoutMode.isDrawing = false;

        // Safety check
        if (!layoutMode.corners || layoutMode.corners.length === 0) {
          resetLayoutMode();
          draw();
          return;
        }

        // Add the current end as the final point
        const lastCorner = layoutMode.corners[layoutMode.corners.length - 1];
        if (lastCorner && layoutMode.currentEnd &&
            (layoutMode.currentEnd.x !== lastCorner.x || layoutMode.currentEnd.y !== lastCorner.y)) {
          layoutMode.corners.push({ ...layoutMode.currentEnd });
        }

        // Need at least 2 points to make a run
        if (layoutMode.corners.length < 2) {
          showSnapFeedback('Drag to create a cabinet run');
          resetLayoutMode();
          draw();
          return;
        }

        // Check total path length
        let totalLength = 0;
        for (let i = 0; i < layoutMode.corners.length - 1; i++) {
          const p1 = layoutMode.corners[i];
          const p2 = layoutMode.corners[i + 1];
          if (p1 && p2) {
            totalLength += Math.abs(p2.x - p1.x) + Math.abs(p2.y - p1.y);
          }
        }

        if (totalLength < layoutMode.minRunLength) {
          showSnapFeedback('Drag further to create a cabinet run');
          resetLayoutMode();
          draw();
          return;
        }

        // Generate cabinets along the path
        const newElements = generateCabinetsAlongPath(layoutMode.corners);

        if (!newElements || newElements.length === 0) {
          showSnapFeedback('Could not place cabinets');
          resetLayoutMode();
          draw();
          return;
        }

        // Add elements to canvas
        newElements.forEach(el => elements.push(el));

        // Generate wall cabinets above base cabinets if "Draw Both Levels" is enabled
        let wallCabinets = [];
        if (layoutMode.drawBothLevels && newElements.length > 0) {
          wallCabinets = generateWallCabinetsForRun(newElements);
          wallCabinets.forEach(el => elements.push(el));
        }

        // Add countertop
        if (layoutMode.addCountertop && newElements.length > 0) {
          const countertop = generateCountertopForRun(newElements);
          if (countertop) elements.push(countertop);
        }

        const cornerCount = layoutMode.corners.length - 1;
        const shapeDesc = cornerCount === 1 ? 'straight run' :
                          cornerCount === 2 ? 'L-shape' :
                          cornerCount === 3 ? 'U-shape' : `${cornerCount}-turn layout`;
        const counterMsg = layoutMode.addCountertop ? ' + countertop' : '';
        const wallMsg = wallCabinets.length > 0 ? ` + ${wallCabinets.length} wall cabs` : '';
        const typeLabel = document.getElementById('layoutElementType')?.options[document.getElementById('layoutElementType')?.selectedIndex]?.text || 'elements';
        showSnapFeedback(`Added ${newElements.length} ${typeLabel} (${shapeDesc})${counterMsg}${wallMsg}`);
        saveUndoState();

        // Reset
        resetLayoutMode();
        draw();
        update3DScene();
      } catch (err) {
        console.error('Layout finishDraw error:', err);
        resetLayoutMode();
        draw();
      }
    }

    // Legacy function for compatibility
    function handleLayoutClick(screenX, screenY) {
      startLayoutDraw(screenX, screenY);
    }

    function finalizeLayoutRun() {
      finishLayoutDraw();
    }

    // Determine which wall an element is against based on position
    // Returns wall info with suggested rotation for cabinet fronts to face into room
    function getWallOrientation(element) {
      const elX = element.x / pixelsPerFoot;
      const elY = element.y / pixelsPerFoot;
      const elWidth = element.width || 2;
      const elHeight = element.height || 2;
      const threshold = 1.5; // Within 1.5 feet of wall

      // Check which wall this element is closest to
      const distToBack = elY;                           // Distance to Y=0 (back wall)
      const distToFront = roomDepth - (elY + elHeight); // Distance to Y=max (front wall)
      const distToLeft = elX;                           // Distance to X=0 (left wall)
      const distToRight = roomWidth - (elX + elWidth);  // Distance to X=max (right wall)

      // Find minimum distance
      const minDist = Math.min(distToBack, distToFront, distToLeft, distToRight);

      // If not near any wall, it's likely an island
      if (minDist > threshold) {
        return { wall: null, rotation: 0, facingDirection: 'south', isIsland: true };
      }

      // Determine which wall based on minimum distance
      if (minDist === distToBack && distToBack <= threshold) {
        return { wall: 'back', rotation: 0, facingDirection: 'south', isIsland: false };
      }
      if (minDist === distToFront && distToFront <= threshold) {
        return { wall: 'front', rotation: 180, facingDirection: 'north', isIsland: false };
      }
      if (minDist === distToLeft && distToLeft <= threshold) {
        return { wall: 'left', rotation: 270, facingDirection: 'east', isIsland: false };
      }
      if (minDist === distToRight && distToRight <= threshold) {
        return { wall: 'right', rotation: 90, facingDirection: 'west', isIsland: false };
      }

      // Default to back wall
      return { wall: 'back', rotation: 0, facingDirection: 'south', isIsland: false };
    }

    // Generate wall cabinets above a run of base cabinets
    // Used when "Draw Upper + Lower Together" is enabled
    function generateWallCabinetsForRun(baseCabinets) {
      const wallCabs = [];
      const baseTypes = ['base-cabinet', 'drawer-base', 'sink-base'];
      const wallCabDepth = layoutMode.wallCabinetDepth || 1; // 12" depth

      baseCabinets.forEach(base => {
        // Only create wall cabs for regular base cabinets
        if (!baseTypes.includes(base.type)) return;

        // Skip corner cabinets - they need special handling
        if (base.type === 'corner-cabinet' || base.type === 'lazy-susan') return;

        // Skip fillers - no wall cabinet above filler pieces
        if (base.isFiller) return;

        // Skip sink bases - typically no wall cabinet above sink (window)
        // User can manually add if needed
        if (base.type === 'sink-base') return;

        // Get cabinet width - handle both horizontal and vertical orientations
        const rotation = base.rotation || 0;
        const isVertical = rotation === 90 || rotation === 270;
        const cabinetWidth = isVertical ? base.height : base.width;
        const widthInches = Math.round(cabinetWidth * 12);

        // Create wall cabinet with same position and width
        // In 2D, position is the same - 3D handles vertical placement
        const wallCab = {
          type: 'wall-cabinet',
          x: base.x,
          y: base.y,
          width: base.width,
          height: wallCabDepth,  // 12" depth (2D depth = 3D depth)
          rotation: rotation,
          color: '#D2691E',      // Lighter brown for wall cabs
          label: `Wall ${widthInches}"`,
          id: generateId(),
          roomId: currentRoom,
          // Copy cabinet settings from base cabinet
          construction: base.construction || cabinetSettings.construction,
          doorStyle: base.doorStyle || cabinetSettings.doorStyle,
          doorOverlay: base.doorOverlay || cabinetSettings.doorOverlay,
          cabinetFinish: base.cabinetFinish || cabinetSettings.cabinetFinish,
          grainType: base.grainType || cabinetSettings.grainType,
          floorLevel: base.floorLevel || cabinetSettings.currentFloor
        };

        // Adjust position based on wall orientation
        // Wall cabinets are shallower, so position closer to wall
        const baseDepth = isVertical ? base.width : base.height;
        const depthDiff = baseDepth - wallCabDepth;

        if (rotation === 0) {
          // Back wall - wall cabinet flush with back, adjust width to match base
          wallCab.y = base.y;
          wallCab.height = wallCabDepth;
          wallCab.width = base.width;
        } else if (rotation === 90) {
          // Right wall - wall cabinet flush with right
          wallCab.x = base.x + depthDiff * pixelsPerFoot;
          wallCab.width = wallCabDepth;
          wallCab.height = base.height;
        } else if (rotation === 180) {
          // Front wall - wall cabinet flush with front
          wallCab.y = base.y + depthDiff * pixelsPerFoot;
          wallCab.height = wallCabDepth;
          wallCab.width = base.width;
        } else if (rotation === 270) {
          // Left wall - wall cabinet flush with left
          wallCab.x = base.x;
          wallCab.width = wallCabDepth;
          wallCab.height = base.height;
        }

        wallCabs.push(wallCab);
      });

      // Also generate wall cabinet fillers to match base fillers for continuity
      baseCabinets.forEach(base => {
        if (!base.isFiller) return;

        const rotation = base.rotation || 0;
        const isVertical = rotation === 90 || rotation === 270;
        const fillerWidth = isVertical ? base.height : base.width;
        const widthInches = Math.round(fillerWidth * 12);
        const baseDepth = isVertical ? base.width : base.height;
        const depthDiff = baseDepth - wallCabDepth;

        const wallFiller = {
          type: 'wall-cabinet',
          x: base.x,
          y: base.y,
          width: base.width,
          height: wallCabDepth,
          rotation: rotation,
          color: '#654321',
          label: `Wall Filler ${widthInches}"`,
          id: generateId(),
          isFiller: true,
          roomId: currentRoom,
          construction: base.construction || cabinetSettings.construction,
          doorStyle: 'flat',
          doorOverlay: base.doorOverlay || cabinetSettings.doorOverlay,
          cabinetFinish: base.cabinetFinish || cabinetSettings.cabinetFinish,
          grainType: base.grainType || cabinetSettings.grainType,
          floorLevel: base.floorLevel || cabinetSettings.currentFloor
        };

        // Adjust position based on rotation
        if (rotation === 0) {
          wallFiller.height = wallCabDepth;
          wallFiller.width = base.width;
        } else if (rotation === 90) {
          wallFiller.x = base.x + depthDiff * pixelsPerFoot;
          wallFiller.width = wallCabDepth;
          wallFiller.height = base.height;
        } else if (rotation === 180) {
          wallFiller.y = base.y + depthDiff * pixelsPerFoot;
          wallFiller.height = wallCabDepth;
          wallFiller.width = base.width;
        } else if (rotation === 270) {
          wallFiller.width = wallCabDepth;
          wallFiller.height = base.height;
        }

        wallCabs.push(wallFiller);
      });

      return wallCabs;
    }

    // Generate elements along a path of orthogonal points
    // Handles corners properly with corner cabinets or fillers
    function generateCabinetsAlongPath(points) {
      try {
        if (!points || points.length < 2) return [];

        const elements = [];
        // Standard cabinet widths (in feet): 36", 33", 30", 27", 24", 21", 18", 15", 12", 9"
        const cabinetWidths = layoutMode.standardWidths || [3, 2.75, 2.5, 2.25, 2, 1.75, 1.5, 1.25, 1, 0.75];
        // Filler widths for small gaps (in feet): 6", 3"
        const fillerWidths = layoutMode.fillerWidths || [0.5, 0.25];
        const depth = layoutMode.cabinetDepth || 2;
        const elType = layoutMode.cabinetType || 'base-cabinet';
        const cornerSize = 3; // 36" corner cabinet
        let globalIndex = 0;

      // Get color and label prefix based on element type
      function getElementStyle(type, widthInches) {
        const styles = {
          'base-cabinet': { color: '#8B4513', label: `Base ${widthInches}"` },
          'drawer-base': { color: '#8B5A2B', label: `Drawer ${widthInches}"` },
          'sink-base': { color: '#6B4423', label: `Sink Base ${widthInches}"` },
          'corner-cabinet': { color: '#A0522D', label: 'Corner 36"' },
          'lazy-susan': { color: '#A0522D', label: 'Lazy Susan' },
          'wall-cabinet': { color: '#D2691E', label: `Wall ${widthInches}"` },
          'tall-cabinet': { color: '#5D4037', label: `Tall ${widthInches}"` },
          'pony-wall': { color: '#9E9E9E', label: 'Pony Wall' },
          'knee-wall': { color: '#757575', label: 'Knee Wall' },
          'wall': { color: '#616161', label: 'Wall' },
          'countertop': { color: '#2F4F4F', label: 'Counter' },
          'backsplash': { color: '#708090', label: 'Backsplash' }
        };
        return styles[type] || { color: '#8B4513', label: `${widthInches}"` };
      }

      // Analyze corners - find where we need corner cabinets
      const corners = [];
      for (let i = 1; i < points.length - 1; i++) {
        const prev = points[i - 1];
        const curr = points[i];
        const next = points[i + 1];

        // Determine directions
        const dir1Horiz = Math.abs(curr.x - prev.x) > Math.abs(curr.y - prev.y);
        const dir2Horiz = Math.abs(next.x - curr.x) > Math.abs(next.y - curr.y);

        // If direction changes, it's a corner
        if (dir1Horiz !== dir2Horiz) {
          // Determine corner type based on which quadrant it opens to
          const fromRight = prev.x > curr.x;
          const fromLeft = prev.x < curr.x;
          const fromTop = prev.y < curr.y;
          const fromBottom = prev.y > curr.y;
          const toRight = next.x > curr.x;
          const toLeft = next.x < curr.x;
          const toTop = next.y < curr.y;
          const toBottom = next.y > curr.y;

          corners.push({
            index: i,
            point: curr,
            fromHoriz: dir1Horiz,
            // Determine which way the corner "opens" (where the toe kick faces)
            opensRight: (fromTop && toRight) || (fromBottom && toRight) || (fromLeft && toBottom) || (fromLeft && toTop),
            opensLeft: (fromTop && toLeft) || (fromBottom && toLeft) || (fromRight && toBottom) || (fromRight && toTop),
            opensUp: (fromLeft && toTop) || (fromRight && toTop),
            opensDown: (fromLeft && toBottom) || (fromRight && toBottom)
          });
        }
      }

      // For walls and continuous elements, create one element for the whole segment
      const isContinuous = ['wall', 'pony-wall', 'knee-wall', 'countertop', 'backsplash'].includes(elType);
      const isCabinet = ['base-cabinet', 'drawer-base', 'sink-base', 'wall-cabinet', 'tall-cabinet', 'corner-cabinet',
                         'lazy-susan', 'blind-corner', 'island', 'microwave-cabinet', 'above-microwave-cabinet',
                         'fridge-cabinet', 'single-oven-cabinet', 'tall-oven', 'double-oven-cabinet', 'laundry-cabinet'].includes(elType);

      // Process each segment
      for (let segIdx = 0; segIdx < points.length - 1; segIdx++) {
        const p1 = points[segIdx];
        const p2 = points[segIdx + 1];

        // Check if this segment starts or ends at a corner
        const startsAtCorner = corners.find(c => c.index === segIdx);
        const endsAtCorner = corners.find(c => c.index === segIdx + 1);

        // Determine if segment is horizontal or vertical
        const isHorizontal = Math.abs(p2.x - p1.x) > Math.abs(p2.y - p1.y);

        // Calculate run direction and bounds
        const goingRight = p2.x > p1.x;
        const goingDown = p2.y > p1.y;

        // Calculate run length
        let runLength = isHorizontal ? Math.abs(p2.x - p1.x) : Math.abs(p2.y - p1.y);

        // Adjust for corner cabinets at each end
        let startOffset = 0;
        let endOffset = 0;

        if (isCabinet && startsAtCorner) {
          startOffset = cornerSize - depth; // Leave room for corner cabinet
        }
        if (isCabinet && endsAtCorner) {
          endOffset = cornerSize - depth;
        }

        const effectiveLength = runLength - startOffset - endOffset;
        if (effectiveLength < 0.5) continue;

        // Starting position
        let startX, startY;
        if (isHorizontal) {
          startX = goingRight ? p1.x + startOffset : p2.x + endOffset;
          startY = p1.y;
        } else {
          startX = p1.x;
          startY = goingDown ? p1.y + startOffset : p2.y + endOffset;
        }

        if (isContinuous) {
          // Single continuous element
          const style = getElementStyle(elType, Math.round(effectiveLength * 12));
          const el = {
            id: 'el-' + Date.now() + '-' + globalIndex++,
            type: elType,
            x: isHorizontal ? startX * pixelsPerFoot : (startX - depth / 2) * pixelsPerFoot,
            y: isHorizontal ? (startY - depth / 2) * pixelsPerFoot : startY * pixelsPerFoot,
            width: isHorizontal ? effectiveLength : depth,
            height: isHorizontal ? depth : effectiveLength,
            rotation: 0,
            color: style.color,
            label: style.label,
            roomId: currentRoom,
            // Cabinet settings from global settings
            construction: isCabinet ? cabinetSettings.construction : undefined,
            doorStyle: isCabinet ? cabinetSettings.doorStyle : undefined,
            doorOverlay: isCabinet ? cabinetSettings.doorOverlay : undefined,
            cabinetFinish: isCabinet ? cabinetSettings.cabinetFinish : undefined,
            grainType: isCabinet ? cabinetSettings.grainType : undefined,
            floorLevel: cabinetSettings.currentFloor
          };
          elements.push(el);
        } else {
          // Fill with individual cabinets using standard sizes
          // Smart algorithm: try to fill optimally with standard widths, use fillers for gaps
          let filled = 0;
          const minCabinetWidth = cabinetWidths[cabinetWidths.length - 1]; // 9" = 0.75ft
          const minFillerWidth = fillerWidths[fillerWidths.length - 1]; // 3" = 0.25ft

          // Calculate optimal cabinet arrangement
          function findBestCabinetWidth(remaining) {
            // Try each standard width
            for (const w of cabinetWidths) {
              if (w <= remaining + 0.02) {
                // Check if the leftover can be filled with another cabinet or filler
                const leftover = remaining - w;
                if (leftover < 0.02) return w; // Perfect fit
                if (leftover >= minCabinetWidth) return w; // Can fit another cabinet
                // Check if leftover fits a filler
                for (const fw of fillerWidths) {
                  if (Math.abs(leftover - fw) < 0.02) return w; // Exact filler fit
                }
                // Try smaller cabinet to see if combo works better
                continue;
              }
            }
            // Return smallest that fits
            for (let i = cabinetWidths.length - 1; i >= 0; i--) {
              if (cabinetWidths[i] <= remaining + 0.02) return cabinetWidths[i];
            }
            return null; // Need a filler instead
          }

          while (filled < effectiveLength - 0.02) {
            const remaining = effectiveLength - filled;

            // Try to fit a standard cabinet
            let bestWidth = findBestCabinetWidth(remaining);
            let isFiller = false;

            if (bestWidth === null || remaining < minCabinetWidth) {
              // Need a filler piece for the gap
              // Find best filler size
              isFiller = true;
              bestWidth = null;
              for (const fw of fillerWidths) {
                if (fw <= remaining + 0.02) {
                  bestWidth = fw;
                  break;
                }
              }
              // If even smallest filler is too big, use remaining width as custom filler
              if (bestWidth === null) {
                bestWidth = remaining;
              }
            }

            // Calculate position with proper orientation
            // Toe kick should face outward (into the room)
            let elX, elY, rotation = 0;

            if (isHorizontal) {
              elX = (startX + filled) * pixelsPerFoot;
              elY = (startY - depth / 2) * pixelsPerFoot;
              // No rotation needed for horizontal runs
            } else {
              elX = (startX - depth / 2) * pixelsPerFoot;
              elY = (startY + filled) * pixelsPerFoot;
              // No rotation - width/height swap handles orientation
            }

            const widthInches = Math.round(bestWidth * 12);
            let style, currentType;

            if (isFiller) {
              // Create a filler piece
              style = { color: '#654321', label: `Filler ${widthInches}"` };
              currentType = 'filler';
            } else {
              style = getElementStyle(elType, widthInches);
              currentType = elType;
            }

            const el = {
              id: 'el-' + Date.now() + '-' + globalIndex++,
              type: isFiller ? 'base-cabinet' : elType, // Fillers are rendered as slim cabinets
              x: elX,
              y: elY,
              width: isHorizontal ? bestWidth : depth,
              height: isHorizontal ? depth : bestWidth,
              rotation: rotation,
              color: style.color,
              label: style.label,
              isFiller: isFiller,
              roomId: currentRoom,
              // Cabinet settings from global settings
              construction: isCabinet ? cabinetSettings.construction : undefined,
              doorStyle: isFiller ? 'flat' : (isCabinet ? cabinetSettings.doorStyle : undefined),
              doorOverlay: isCabinet ? cabinetSettings.doorOverlay : undefined,
              cabinetFinish: isCabinet ? cabinetSettings.cabinetFinish : undefined,
              grainType: isCabinet ? cabinetSettings.grainType : undefined,
              floorLevel: cabinetSettings.currentFloor
            };

            // Auto-detect wall orientation and set proper rotation
            // so cabinet fronts face into the room
            const wallInfo = getWallOrientation(el);
            if (!wallInfo.isIsland && isCabinet) {
              el.rotation = wallInfo.rotation;
            }

            elements.push(el);
            filled += bestWidth;
          }
        }

        // Add corner element at end of this segment if there's a corner
        if (isCabinet && endsAtCorner && layoutMode.cornerType !== 'none') {
          const corner = endsAtCorner;
          const cornerPoint = corner.point;

          // Position corner element at the corner junction
          const cornerX = (cornerPoint.x - cornerSize / 2) * pixelsPerFoot;
          const cornerY = (cornerPoint.y - cornerSize / 2) * pixelsPerFoot;

          // Determine corner element based on setting
          let cornerElType = layoutMode.cornerType;
          let cornerLabel = 'Corner 36"';
          let cornerColor = '#A0522D';

          if (cornerElType === 'lazy-susan') {
            cornerLabel = 'Lazy Susan';
            cornerColor = '#8B6914';
          } else if (cornerElType === 'blind-corner') {
            cornerLabel = 'Blind Corner';
            cornerColor = '#7B5513';
          } else if (cornerElType === 'filler') {
            cornerLabel = 'Filler';
            cornerColor = '#654321';
          }

          // Calculate corner cabinet rotation based on which room corner it's in
          // The L-shaped cabinet should have arms against the walls and door facing into room
          // Default model has arms at -X (left) and -Z (back), door faces +X,+Z (front-right)
          let cornerRotation = 0;
          const cornerWorldX = cornerPoint.x;
          const cornerWorldY = cornerPoint.y;
          const nearBackWall = cornerWorldY < roomDepth / 2;
          const nearLeftWall = cornerWorldX < roomWidth / 2;

          if (nearBackWall && nearLeftWall) {
            // Back-left corner: door faces front-right (+X, +Z into room)
            cornerRotation = 0;
          } else if (nearBackWall && !nearLeftWall) {
            // Back-right corner: door faces front-left (-X, +Z into room)
            cornerRotation = 90;
          } else if (!nearBackWall && nearLeftWall) {
            // Front-left corner: door faces back-right (+X, -Z into room)
            cornerRotation = 270;
          } else {
            // Front-right corner: door faces back-left (-X, -Z into room)
            cornerRotation = 180;
          }

          const cornerEl = {
            id: 'el-' + Date.now() + '-corner-' + corner.index,
            type: cornerElType === 'filler' ? 'base-cabinet' : cornerElType,
            x: cornerX,
            y: cornerY,
            width: cornerSize,
            height: cornerSize,
            rotation: cornerRotation,
            color: cornerColor,
            label: cornerLabel,
            isCorner: true,
            roomId: currentRoom,
            // Cabinet settings from global settings
            construction: cabinetSettings.construction,
            doorStyle: cabinetSettings.doorStyle,
            doorOverlay: cabinetSettings.doorOverlay,
            cabinetFinish: cabinetSettings.cabinetFinish,
            grainType: cabinetSettings.grainType,
            floorLevel: cabinetSettings.currentFloor
          };

          // Only add if we haven't already added this corner
          if (!elements.find(e => e.isCorner && Math.abs(e.x - cornerX) < 10 && Math.abs(e.y - cornerY) < 10)) {
            elements.push(cornerEl);
          }
        }
      }

      return elements;
      } catch (err) {
        console.error('generateCabinetsAlongPath error:', err);
        return [];
      }
    }

    // Generate countertop to cover cabinet run
    function generateCountertopForRun(cabinets) {
      if (!cabinets || cabinets.length === 0) return null;

      // Find bounding box of all cabinets
      let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;

      cabinets.forEach(cab => {
        minX = Math.min(minX, cab.x);
        minY = Math.min(minY, cab.y);
        maxX = Math.max(maxX, cab.x + cab.width * pixelsPerFoot);
        maxY = Math.max(maxY, cab.y + cab.height * pixelsPerFoot);
      });

      // Add overhang (1.5" = 0.125 ft)
      const overhang = 0.125 * pixelsPerFoot;

      return {
        id: 'el-' + Date.now() + '-counter',
        type: 'countertop',
        x: minX - overhang,
        y: minY - overhang,
        width: (maxX - minX + overhang * 2) / pixelsPerFoot,
        height: (maxY - minY + overhang * 2) / pixelsPerFoot,
        rotation: 0,
        color: '#2F4F4F',
        label: 'Countertop',
        material: 'granite',
        roomId: currentRoom,
        edgeProfile: 'eased'
      };
    }

    // Draw the layout tool preview on canvas - drafting style
    function drawLayoutToolPreview() {
      try {
        if (currentTool !== 'layout') return;
        if (!layoutMode.isDrawing && (!layoutMode.corners || layoutMode.corners.length === 0)) return;

      // Build the complete path including current endpoint
      const allPoints = [...layoutMode.corners];
      if (layoutMode.isDrawing && layoutMode.currentEnd) {
        allPoints.push(layoutMode.currentEnd);
      }

      if (allPoints.length === 0) return;

      const depth = layoutMode.cabinetDepth;

      // Draw the center line path (straight orthogonal lines)
      ctx.strokeStyle = '#FF9800';
      ctx.lineWidth = 3;
      ctx.lineCap = 'square';
      ctx.lineJoin = 'miter';
      ctx.setLineDash([]);

      ctx.beginPath();
      allPoints.forEach((p, i) => {
        const screenX = p.x * pixelsPerFoot;
        const screenY = p.y * pixelsPerFoot;
        if (i === 0) {
          ctx.moveTo(screenX, screenY);
        } else {
          ctx.lineTo(screenX, screenY);
        }
      });
      ctx.stroke();

      // Draw cabinet outline preview for each segment
      ctx.strokeStyle = 'rgba(139, 69, 19, 0.9)';
      ctx.fillStyle = 'rgba(139, 69, 19, 0.25)';
      ctx.lineWidth = 2;

      for (let i = 0; i < allPoints.length - 1; i++) {
        const p1 = allPoints[i];
        const p2 = allPoints[i + 1];

        // Determine if horizontal or vertical segment
        const isHorizontal = Math.abs(p2.x - p1.x) > Math.abs(p2.y - p1.y);

        let rect;
        if (isHorizontal) {
          // Horizontal run - depth goes up/down
          const minX = Math.min(p1.x, p2.x);
          const maxX = Math.max(p1.x, p2.x);
          rect = {
            x: minX * pixelsPerFoot,
            y: (p1.y - depth / 2) * pixelsPerFoot,
            w: (maxX - minX) * pixelsPerFoot,
            h: depth * pixelsPerFoot
          };
        } else {
          // Vertical run - depth goes left/right
          const minY = Math.min(p1.y, p2.y);
          const maxY = Math.max(p1.y, p2.y);
          rect = {
            x: (p1.x - depth / 2) * pixelsPerFoot,
            y: minY * pixelsPerFoot,
            w: depth * pixelsPerFoot,
            h: (maxY - minY) * pixelsPerFoot
          };
        }

        // Draw the cabinet rectangle
        ctx.fillRect(rect.x, rect.y, rect.w, rect.h);
        ctx.strokeRect(rect.x, rect.y, rect.w, rect.h);

        // Draw dimension label for this segment
        const segmentLength = isHorizontal ?
          Math.abs(p2.x - p1.x) :
          Math.abs(p2.y - p1.y);

        if (segmentLength >= 1) {
          const midX = ((p1.x + p2.x) / 2) * pixelsPerFoot;
          const midY = ((p1.y + p2.y) / 2) * pixelsPerFoot;

          ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
          ctx.font = 'bold 11px Inter';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';

          // Background for text
          const dimText = formatDimension(segmentLength);
          const textMetrics = ctx.measureText(dimText);
          ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
          ctx.fillRect(midX - textMetrics.width / 2 - 4, midY - 8, textMetrics.width + 8, 16);

          ctx.fillStyle = '#fff';
          ctx.fillText(dimText, midX, midY);
        }

        // Reset fill for next iteration
        ctx.fillStyle = 'rgba(139, 69, 19, 0.25)';
      }

      // Draw corner markers
      allPoints.forEach((p, i) => {
        const screenX = p.x * pixelsPerFoot;
        const screenY = p.y * pixelsPerFoot;

        // Corner square
        ctx.fillStyle = i === 0 ? '#4CAF50' : (i === allPoints.length - 1 && layoutMode.isDrawing ? '#FF5722' : '#2196F3');
        ctx.fillRect(screenX - 6, screenY - 6, 12, 12);

        // Corner border
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.strokeRect(screenX - 6, screenY - 6, 12, 12);

        // Corner number
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 10px Inter';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(i === 0 ? 'S' : (i === allPoints.length - 1 ? 'E' : String(i)), screenX, screenY);
      });

      // Draw direction indicator at current end
      if (layoutMode.isDrawing && layoutMode.currentDirection) {
        const endPoint = allPoints[allPoints.length - 1];
        const endX = endPoint.x * pixelsPerFoot;
        const endY = endPoint.y * pixelsPerFoot;

        ctx.strokeStyle = '#FF9800';
        ctx.lineWidth = 2;
        ctx.setLineDash([4, 4]);

        // Show constraint direction
        ctx.beginPath();
        if (layoutMode.currentDirection === 'horizontal') {
          ctx.moveTo(endX - 30, endY);
          ctx.lineTo(endX + 30, endY);
        } else {
          ctx.moveTo(endX, endY - 30);
          ctx.lineTo(endX, endY + 30);
        }
        ctx.stroke();
        ctx.setLineDash([]);
      }

      // Instructions overlay
      ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
      const boxHeight = layoutMode.isDrawing ? 65 : 45;
      ctx.fillRect(10, 10, 300, boxHeight);

      ctx.fillStyle = '#fff';
      ctx.font = '12px Inter';
      ctx.textAlign = 'left';

      if (layoutMode.isDrawing) {
        ctx.fillText(' Drafting cabinet run...', 20, 28);
        const dirText = layoutMode.currentDirection ?
          `Direction: ${layoutMode.currentDirection.toUpperCase()}` :
          'Move to set direction';
        ctx.fillText(dirText, 20, 44);
        ctx.fillText('Turn: move perpendicular  Release: place', 20, 60);
      } else {
        ctx.fillText(' Layout Tool - Click & drag to draw', 20, 28);
        ctx.fillText('Straight lines snap to H/V  Auto-turns at corners', 20, 44);
      }
      } catch (err) {
        console.error('drawLayoutToolPreview error:', err);
        // Don't break the draw loop - just skip the preview
      }
    }

    // Fill room with flooring
    function fillRoomWithFlooring() {
      // Check if flooring already exists
      const existingFlooring = elements.find(el => el.type === 'flooring' && el.width >= roomWidth * 0.9 && el.height >= roomDepth * 0.9);
      if (existingFlooring) {
        // Select existing flooring so user can modify it
        selectedElement = existingFlooring;
        updateProperties();
        showSnapFeedback('Room already has flooring - selected for editing');
        draw();
        return;
      }

      // Create flooring that fills the entire room
      const flooring = {
        id: 'floor-' + Date.now(),
        type: 'flooring',
        x: 0,
        y: 0,
        width: roomWidth,
        height: roomDepth,
        color: '#D2B48C',
        label: 'Room Flooring',
        rotation: 0,
        locked: false,
        roomId: currentRoom,
        grainDirection: 0, // 0 = horizontal, 90 = vertical
        floorLevel: cabinetSettings.currentFloor || 1,
        zIndexOffset: -100 // Keep flooring behind other elements
      };

      // Find flooring color from ELEMENT_TYPES
      const flooringDef = ELEMENT_TYPES.surfaces?.find(e => e.type === 'flooring');
      if (flooringDef) {
        flooring.color = flooringDef.color;
      }

      elements.push(flooring);
      selectedElement = flooring;
      updateProperties();
      saveUndoState();
      draw();
      update3DScene();
      showSnapFeedback('Flooring added - select material in properties');
    }

    // Auto-generate countertops over base cabinets and wall caps over walls
    function generateCountertopsOverCabinets() {
      // Types that can receive countertops/caps
      const baseCabinetTypes = ['base-cabinet', 'drawer-base', 'sink-base', 'corner-cabinet', 'lazy-susan', 'island'];
      const wallTypes = ['pony-wall', 'pony-wall-bar', 'knee-wall', 'wall', 'wall-block', 'wall-concrete', 'wall-brick'];

      const baseCabinets = elements.filter(el => baseCabinetTypes.includes(el.type));
      const capableWalls = elements.filter(el => wallTypes.includes(el.type) &&
        // Only half-height walls get caps (not full walls unless selected)
        (['pony-wall', 'pony-wall-bar', 'knee-wall'].includes(el.type) ||
         (el === selectedElement && wallTypes.includes(el.type)))
      );

      if (baseCabinets.length === 0 && capableWalls.length === 0) {
        showSnapFeedback('No base cabinets or walls found to cover');
        return;
      }

      // Also generate caps for walls
      let wallCapsCreated = generateWallCaps(capableWalls);

      // Group cabinets by their Y position (row) - with 0.5ft tolerance
      const rows = [];
      baseCabinets.forEach(cab => {
        const cabCenterY = cab.y + (cab.height * pixelsPerFoot) / 2;
        let foundRow = rows.find(row => Math.abs(row.y - cabCenterY) < pixelsPerFoot * 0.5);
        if (foundRow) {
          foundRow.cabinets.push(cab);
        } else {
          rows.push({ y: cabCenterY, cabinets: [cab] });
        }
      });

      let countersCreated = 0;

      rows.forEach(row => {
        // Sort cabinets by X position
        row.cabinets.sort((a, b) => a.x - b.x);

        // Find contiguous runs of cabinets
        const runs = [];
        let currentRun = [row.cabinets[0]];

        for (let i = 1; i < row.cabinets.length; i++) {
          const prev = row.cabinets[i - 1];
          const curr = row.cabinets[i];
          const prevRight = prev.x + prev.width * pixelsPerFoot;
          const currLeft = curr.x;
          const gap = currLeft - prevRight;

          // If gap is small (< 6 inches), consider them adjacent
          if (gap < pixelsPerFoot * 0.5) {
            currentRun.push(curr);
          } else {
            runs.push(currentRun);
            currentRun = [curr];
          }
        }
        runs.push(currentRun);

        // Create a countertop for each run
        runs.forEach(run => {
          const leftCab = run[0];
          const rightCab = run[run.length - 1];

          // Calculate bounds with 1.5" overhang
          const overhang = 0.125; // 1.5 inches in feet
          const leftX = leftCab.x / pixelsPerFoot - overhang;
          const rightX = (rightCab.x + rightCab.width * pixelsPerFoot) / pixelsPerFoot + overhang;

          // Find the max depth in the run
          let maxDepth = 0;
          let frontY = Infinity;
          run.forEach(cab => {
            maxDepth = Math.max(maxDepth, cab.height);
            frontY = Math.min(frontY, cab.y / pixelsPerFoot);
          });

          // Countertop positioned to align with cabinet fronts with overhang
          const counterWidth = rightX - leftX;
          const counterDepth = maxDepth + overhang * 2;
          const counterY = frontY - overhang;

          // Check if countertop already exists at this location
          const existingCounter = elements.find(el =>
            el.type === 'countertop' &&
            Math.abs(el.x / pixelsPerFoot - leftX) < 0.5 &&
            Math.abs(el.y / pixelsPerFoot - counterY) < 0.5 &&
            Math.abs(el.width - counterWidth) < 0.5
          );

          if (!existingCounter) {
            const counter = {
              id: Date.now() + Math.random(),
              type: 'countertop',
              x: leftX * pixelsPerFoot,
              y: counterY * pixelsPerFoot,
              width: counterWidth,
              height: counterDepth,
              color: '#708090',
              rotation: 0,
              roomId: currentRoom,
              edgeProfile: 'eased',
              finishedEnds: ['left', 'right']
            };
            elements.push(counter);
            countersCreated++;
          }
        });
      });

      const totalCreated = countersCreated + wallCapsCreated;
      if (totalCreated > 0) {
        saveUndoState();
        draw();
        update3DScene();
        let msg = '';
        if (countersCreated > 0) msg += `${countersCreated} countertop${countersCreated > 1 ? 's' : ''}`;
        if (wallCapsCreated > 0) {
          if (msg) msg += ', ';
          msg += `${wallCapsCreated} wall cap${wallCapsCreated > 1 ? 's' : ''}`;
        }
        showSnapFeedback(`Generated ${msg}`);
      } else {
        showSnapFeedback('Countertops/caps already exist');
      }
    }

    // Generate wall caps over pony walls, knee walls, bar walls, etc.
    function generateWallCaps(walls) {
      if (!walls || walls.length === 0) return 0;

      let capsCreated = 0;
      const overhang = 0.0833; // 1 inch overhang in feet
      const capThickness = 0.125; // 1.5" cap thickness in feet

      walls.forEach(wall => {
        // Get wall dimensions and position
        const wallX = wall.x / pixelsPerFoot;
        const wallY = wall.y / pixelsPerFoot;
        const wallW = wall.width;
        const wallD = wall.height;
        const rotation = wall.rotation || 0;

        // Check if cap already exists at this location
        const existingCap = elements.find(el =>
          (el.type === 'wall-cap' || el.type === 'countertop' || el.type === 'bar-top') &&
          Math.abs(el.x / pixelsPerFoot - (wallX - overhang)) < 0.3 &&
          Math.abs(el.y / pixelsPerFoot - (wallY - overhang)) < 0.3 &&
          Math.abs(el.width - (wallW + overhang * 2)) < 0.3
        );

        if (!existingCap) {
          // Determine cap type based on wall type
          let capType = 'wall-cap';
          let capColor = '#708090';
          if (wall.type === 'pony-wall-bar') {
            capType = 'bar-top';
            capColor = '#8B4513';
          }

          // Get wall height for positioning the cap in 3D
          const wallHeight = wall.wallHeight || (wall.type === 'knee-wall' ? 2 : 3.5);

          const cap = {
            id: Date.now() + Math.random() + capsCreated,
            type: capType,
            x: (wallX - overhang) * pixelsPerFoot,
            y: (wallY - overhang) * pixelsPerFoot,
            width: wallW + overhang * 2,
            height: wallD + overhang * 2,
            color: capColor,
            rotation: rotation,
            roomId: currentRoom,
            edgeProfile: 'eased',
            finishedEnds: ['left', 'right', 'front', 'back'],
            capHeight: wallHeight,          // Height where cap sits
            thickness: capThickness,        // Cap thickness
            parentWallId: wall.id           // Link to parent wall
          };
          elements.push(cap);
          capsCreated++;
        }
      });

      return capsCreated;
    }

    // Generate cap/top for a single selected element (wall, cabinet, etc.)
    function generateCapForSelected() {
      if (!selectedElement) {
        showSnapFeedback('Select an element first');
        return;
      }

      const wallTypes = ['pony-wall', 'pony-wall-bar', 'knee-wall', 'wall', 'wall-block', 'wall-concrete', 'wall-brick'];
      const cabinetTypes = ['base-cabinet', 'drawer-base', 'sink-base', 'corner-cabinet', 'lazy-susan', 'island'];

      if (wallTypes.includes(selectedElement.type)) {
        const created = generateWallCaps([selectedElement]);
        if (created > 0) {
          saveUndoState();
          draw();
          update3DScene();
          showSnapFeedback('Wall cap added');
        } else {
          showSnapFeedback('Cap already exists on this wall');
        }
      } else if (cabinetTypes.includes(selectedElement.type)) {
        // Generate countertop just for this cabinet
        const counter = generateCountertopForRun([selectedElement]);
        if (counter) {
          elements.push(counter);
          saveUndoState();
          draw();
          update3DScene();
          showSnapFeedback('Countertop added');
        }
      } else {
        showSnapFeedback('Select a wall or cabinet first');
      }
    }

    // Alignment menu for selected elements
    function showAlignMenu() {
      // Create a simple dropdown menu for alignment options
      const menu = document.createElement('div');
      menu.id = 'alignMenu';
      menu.className = 'context-menu';
      menu.style.cssText = `
        position: fixed;
        background: rgba(30, 30, 40, 0.95);
        backdrop-filter: blur(20px);
        -webkit-backdrop-filter: blur(20px);
        border: 1px solid rgba(255, 255, 255, 0.15);
        border-radius: 12px;
        padding: 8px 0;
        box-shadow: 0 8px 32px rgba(0,0,0,0.5);
        z-index: 9999;
        min-width: 180px;
      `;

      const options = [
        { label: 'Align Left', icon: '', action: () => alignElements('left') },
        { label: 'Align Center', icon: '', action: () => alignElements('center') },
        { label: 'Align Right', icon: '', action: () => alignElements('right') },
        { label: 'Align Top', icon: '', action: () => alignElements('top') },
        { label: 'Align Middle', icon: '', action: () => alignElements('middle') },
        { label: 'Align Bottom', icon: '', action: () => alignElements('bottom') },
        { divider: true },
        { label: 'Distribute Horizontal', icon: '', action: () => distributeElements('horizontal') },
        { label: 'Distribute Vertical', icon: '', action: () => distributeElements('vertical') },
        { divider: true },
        { label: 'Snap to Wall', icon: '', action: () => snapSelectionToWall() }
      ];

      options.forEach(opt => {
        if (opt.divider) {
          const div = document.createElement('div');
          div.style.cssText = 'height: 1px; background: rgba(255, 255, 255, 0.1); margin: 6px 8px;';
          menu.appendChild(div);
        } else {
          const item = document.createElement('div');
          item.style.cssText = `
            padding: 10px 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 13px;
            color: #e0e0e0;
            transition: all 0.15s ease;
            margin: 2px 6px;
            border-radius: 6px;
          `;
          item.innerHTML = `<span style="width: 18px; text-align: center; font-size: 14px;">${opt.icon}</span>${opt.label}`;
          item.onmouseenter = () => {
            item.style.background = 'rgba(255, 255, 255, 0.1)';
            item.style.color = '#ffffff';
          };
          item.onmouseleave = () => {
            item.style.background = 'transparent';
            item.style.color = '#e0e0e0';
          };
          item.onclick = () => {
            opt.action();
            menu.remove();
          };
          menu.appendChild(item);
        }
      });

      // Position near the Align button
      const btn = document.getElementById('toolAlign');
      const rect = btn.getBoundingClientRect();
      menu.style.left = rect.right + 5 + 'px';
      menu.style.top = rect.top + 'px';

      document.body.appendChild(menu);

      // Close on click outside
      setTimeout(() => {
        document.addEventListener('click', function closeMenu(e) {
          if (!menu.contains(e.target)) {
            menu.remove();
            document.removeEventListener('click', closeMenu);
          }
        });
      }, 10);
    }

    // Align multiple selected elements (or all cabinets if none selected)
    function alignElements(alignment) {
      const cabinetTypes = ['base-cabinet', 'wall-cabinet', 'tall-cabinet', 'corner-cabinet', 'drawer-base', 'sink-base', 'lazy-susan', 'island'];
      const targets = elements.filter(el => cabinetTypes.includes(el.type));

      if (targets.length < 2) {
        showSnapFeedback('Need at least 2 cabinets to align');
        return;
      }

      // Find the reference point based on alignment
      let refValue;
      switch (alignment) {
        case 'left':
          refValue = Math.min(...targets.map(el => el.x));
          targets.forEach(el => el.x = refValue);
          break;
        case 'right':
          refValue = Math.max(...targets.map(el => el.x + el.width * pixelsPerFoot));
          targets.forEach(el => el.x = refValue - el.width * pixelsPerFoot);
          break;
        case 'center':
          const avgX = targets.reduce((sum, el) => sum + el.x + (el.width * pixelsPerFoot) / 2, 0) / targets.length;
          targets.forEach(el => el.x = avgX - (el.width * pixelsPerFoot) / 2);
          break;
        case 'top':
          refValue = Math.min(...targets.map(el => el.y));
          targets.forEach(el => el.y = refValue);
          break;
        case 'bottom':
          refValue = Math.max(...targets.map(el => el.y + el.height * pixelsPerFoot));
          targets.forEach(el => el.y = refValue - el.height * pixelsPerFoot);
          break;
        case 'middle':
          const avgY = targets.reduce((sum, el) => sum + el.y + (el.height * pixelsPerFoot) / 2, 0) / targets.length;
          targets.forEach(el => el.y = avgY - (el.height * pixelsPerFoot) / 2);
          break;
      }

      saveUndoState();
      draw();
      update3DScene();
      showSnapFeedback(`Aligned ${targets.length} elements`);
    }

    // Distribute elements evenly
    function distributeElements(direction) {
      const cabinetTypes = ['base-cabinet', 'wall-cabinet', 'tall-cabinet', 'corner-cabinet', 'drawer-base', 'sink-base', 'lazy-susan', 'island'];
      const targets = elements.filter(el => cabinetTypes.includes(el.type));

      if (targets.length < 3) {
        showSnapFeedback('Need at least 3 cabinets to distribute');
        return;
      }

      if (direction === 'horizontal') {
        targets.sort((a, b) => a.x - b.x);
        const first = targets[0];
        const last = targets[targets.length - 1];
        const totalWidth = targets.reduce((sum, el) => sum + el.width * pixelsPerFoot, 0);
        const availableSpace = (last.x + last.width * pixelsPerFoot) - first.x - totalWidth;
        const gap = availableSpace / (targets.length - 1);

        let currentX = first.x;
        targets.forEach(el => {
          el.x = currentX;
          currentX += el.width * pixelsPerFoot + gap;
        });
      } else {
        targets.sort((a, b) => a.y - b.y);
        const first = targets[0];
        const last = targets[targets.length - 1];
        const totalHeight = targets.reduce((sum, el) => sum + el.height * pixelsPerFoot, 0);
        const availableSpace = (last.y + last.height * pixelsPerFoot) - first.y - totalHeight;
        const gap = availableSpace / (targets.length - 1);

        let currentY = first.y;
        targets.forEach(el => {
          el.y = currentY;
          currentY += el.height * pixelsPerFoot + gap;
        });
      }

      saveUndoState();
      draw();
      update3DScene();
      showSnapFeedback(`Distributed ${targets.length} elements ${direction}ly`);
    }

    // Snap selection to nearest wall
    function snapSelectionToWall() {
      if (!selectedElement) {
        showSnapFeedback('Select an element first');
        return;
      }

      const el = selectedElement;
      const elLeft = el.x / pixelsPerFoot;
      const elRight = elLeft + el.width;
      const elTop = el.y / pixelsPerFoot;
      const elBottom = elTop + el.height;

      // Check distances to room walls
      const distToLeft = elLeft;
      const distToRight = roomWidth - elRight;
      const distToTop = elTop;
      const distToBottom = roomDepth - elBottom;

      // Find minimum distance
      const min = Math.min(distToLeft, distToRight, distToTop, distToBottom);

      if (min === distToLeft) {
        el.x = 0;
      } else if (min === distToRight) {
        el.x = (roomWidth - el.width) * pixelsPerFoot;
      } else if (min === distToTop) {
        el.y = 0;
      } else {
        el.y = (roomDepth - el.height) * pixelsPerFoot;
      }

      saveUndoState();
      draw();
      update3DScene();
      showSnapFeedback('Snapped to wall');
    }

    function toggleSection(header) {
      // Find the sidebar-content, skipping over any tooltip elements
      const section = header.parentElement;
      const content = section.querySelector('.sidebar-content');
      const toggle = header.querySelector('.sidebar-toggle');
      if (content) {
        const isCollapsing = !content.classList.contains('collapsed');
        content.classList.toggle('collapsed');
        section.classList.toggle('expanded', !isCollapsing);
        toggle.textContent = isCollapsing ? '' : '';
      }
    }

    function togglePanelSectionOld(header) {
      // Toggle collapsible panel sections in the right panel (legacy)
      const section = header.parentElement;
      const content = section.querySelector('.panel-content');
      const toggle = header.querySelector('.panel-toggle');
      if (content) {
        content.classList.toggle('collapsed');
        toggle.textContent = content.classList.contains('collapsed') ? '' : '';
      }
    }

    // ===== VIEW =====
    function setView(view) {
      currentView = view;
      document.getElementById('view2D').classList.toggle('active', view === '2d');
      document.getElementById('view3D').classList.toggle('active', view === '3d');

      const canvasWrapper = document.getElementById('canvasWrapper');
      const threeContainer = document.getElementById('three-container');

      // Cancel any existing animation when switching views
      if (animationId) {
        cancelAnimationFrame(animationId);
        animationId = null;
      }

      if (view === '3d') {
        canvasWrapper.style.display = 'none';
        threeContainer.classList.add('active');

        // Wait for layout to compute before initializing 3D
        // This ensures container has proper dimensions
        requestAnimationFrame(() => {
          init3D();

          // Update renderer size in case container size changed
          if (renderer) {
            const w = threeContainer.clientWidth || window.innerWidth * 0.6;
            const h = threeContainer.clientHeight || window.innerHeight - 150;
            if (w > 0 && h > 0) {
              renderer.setSize(w, h);
              camera.aspect = w / h;
              camera.updateProjectionMatrix();
            }
          }

          render3D();
        });
      } else {
        // Cleanup 3D resources when switching to 2D
        cleanup3D();
        canvasWrapper.style.display = 'block';
        threeContainer.classList.remove('active');
        // Redraw 2D canvas after switching from 3D
        requestAnimationFrame(() => draw());
      }
    }

    // Helper function to check if 3D mode is active
    function get3DMode() {
      return currentView === '3d';
    }

    // Expose is3DMode as a getter
    Object.defineProperty(window, 'is3DMode', {
      get: function() { return currentView === '3d'; }
    });

    // Toggle between 2D and 3D views
    function toggle3DView() {
      if (currentView === '3d') {
        setView('2d');
      } else {
        setView('3d');
      }
      // Update button text in review room if present
      const toggle3DBtn = document.getElementById('toggle3DBtn');
      if (toggle3DBtn) {
        toggle3DBtn.textContent = currentView === '3d' ? '2D View' : '3D View';
      }
    }

    // Alias for update3DScene - rebuilds the 3D scene with current elements
    function update3DScene() {
      if (currentView === '3d') {
        init3D();
        render3D();
      }
    }

    // ===== 3D VIEW =====
    function cleanup3D() {
      if (animationId) {
        cancelAnimationFrame(animationId);
        animationId = null;
      }

      if (scene) {
        // Dispose all objects in scene
        scene.traverse(obj => {
          if (obj.geometry) obj.geometry.dispose();
          if (obj.material) {
            if (Array.isArray(obj.material)) {
              obj.material.forEach(m => {
                // Dispose material textures
                if (m.map) m.map.dispose();
                if (m.normalMap) m.normalMap.dispose();
                if (m.roughnessMap) m.roughnessMap.dispose();
                m.dispose();
              });
            } else {
              // Dispose material textures
              if (obj.material.map) obj.material.map.dispose();
              if (obj.material.normalMap) obj.material.normalMap.dispose();
              if (obj.material.roughnessMap) obj.material.roughnessMap.dispose();
              obj.material.dispose();
            }
          }
        });
        scene.clear();
        scene = null;
      }

      // Clear texture cache to free memory (uses LRU cache cleanup)
      if (typeof clearTextureCache === 'function') {
        clearTextureCache();
      }

      // Clear geometry pool
      if (typeof clearGeometryPool === 'function') {
        clearGeometryPool();
      }

      // Clear incremental update caches
      clearAll3DCaches();

      if (renderer) {
        renderer.dispose();
        renderer = null;
      }

      if (controls) {
        controls.dispose();
        controls = null;
      }

      // Cleanup axis indicator
      if (window._axisIndicator) {
        const axis = window._axisIndicator;
        if (axis.renderer) axis.renderer.dispose();
        if (axis.scene) axis.scene.clear();
        if (axis.container && axis.container.parentNode) {
          axis.container.parentNode.removeChild(axis.container);
        }
        window._axisIndicator = null;
      }

      const container = document.getElementById('three-container');
      if (container) container.innerHTML = '';
    }

    function init3D() {
      console.log('=== init3D called ===');

      // Clean up existing 3D resources first
      cleanup3D();

      // Preload textures before building scene
      preload3DTextures();

      const container = document.getElementById('three-container');
      if (!container) {
        console.error('init3D: three-container not found!');
        return;
      }

      let width = container.clientWidth;
      let height = container.clientHeight;

      console.log('init3D: container dimensions:', width, 'x', height);

      // If container has no size, try to get size from parent or use fallback
      if (width === 0 || height === 0) {
        const parent = container.parentElement;
        if (parent) {
          width = parent.clientWidth || window.innerWidth * 0.6;
          height = parent.clientHeight || window.innerHeight - 150;
          console.log('init3D: using parent/fallback dimensions:', width, 'x', height);
        }
      }

      // Final fallback
      if (width === 0) width = 800;
      if (height === 0) height = 600;

      // Get current theme for background
      const timeOfDay = sceneSettings?.timeOfDay || 'noon';
      const bgColors = {
        morning: 0xFFF8E7,   // Warm cream
        noon: 0xF5F8FA,      // Bright neutral
        evening: 0xFFE8D6,   // Sunset warm
        night: 0x1E2A3A      // Dark blue-gray
      };

      scene = new THREE.Scene();
      scene.background = new THREE.Color(bgColors[timeOfDay] || 0xF5F8FA);

      // Camera - positioned for optimal room viewing
      camera = new THREE.PerspectiveCamera(50, width / height, 0.5, 150);
      const roomDiag = Math.sqrt(roomWidth * roomWidth + roomDepth * roomDepth);
      const camDist = Math.max(roomDiag * 0.8, 10);
      const camHeight = Math.max(6, (roomHeight || 8) * 0.7);
      camera.position.set(roomWidth / 2 + camDist * 0.7, camHeight, roomDepth / 2 + camDist * 0.7);
      camera.lookAt(roomWidth / 2, 3, roomDepth / 2);

      // Renderer with enhanced quality for better texture visibility
      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setSize(width, height);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      renderer.shadowMap.autoUpdate = true;
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 1.15; // Balanced exposure for realistic look
      renderer.physicallyCorrectLights = true; // More realistic light falloff
      renderer.outputColorSpace = THREE.SRGBColorSpace; // Proper color encoding (r128 API)
      container.appendChild(renderer.domElement);

      // Orbit controls with smooth zoom - allows close-up inspection
      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.08;
      controls.target.set(roomWidth / 2, 1.5, roomDepth / 2);
      controls.maxPolarAngle = Math.PI / 2.05;
      controls.minPolarAngle = Math.PI / 12; // Allow flatter angles for detail viewing
      controls.minDistance = 0.5;  // Allow very close zoom for detail inspection (0.5 ft / 6 inches)
      controls.maxDistance = 150; // Allow zooming out much further for large rooms and overview

      // Moderate zoom sensitivity for fine control
      controls.zoomSpeed = 0.4;

      // Reduce pan sensitivity
      controls.panSpeed = 0.3;

      // Reduce rotation sensitivity
      controls.rotateSpeed = 0.35;

      // Disable right-click completely - only left-click rotates, middle zooms
      // Shift+Left or middle mouse for panning
      controls.mouseButtons = {
        LEFT: THREE.MOUSE.ROTATE,
        MIDDLE: THREE.MOUSE.DOLLY,
        RIGHT: THREE.MOUSE.PAN  // Allow right-click for panning instead of disabling
      };

      // Handle trackpad pinch-to-zoom more smoothly
      controls.enableZoom = true;
      controls.screenSpacePanning = true;  // Pan in screen space for more intuitive control

      // Enable keyboard controls for panning (arrow keys)
      controls.enableKeys = true;
      controls.keys = {
        LEFT: 37,  // left arrow
        UP: 38,    // up arrow
        RIGHT: 39, // right arrow
        BOTTOM: 40 // down arrow
      };

      // Store initial camera state for reset
      const initialCameraPosition = camera.position.clone();
      const initialTarget = controls.target.clone();

      controls.update();

      // ===== POST-PROCESSING EFFECTS =====
      // Setup EffectComposer for enhanced visuals
      try {
        composer = new THREE.EffectComposer(renderer);

        // Render pass - renders the scene normally first
        const renderPass = new THREE.RenderPass(scene, camera);
        composer.addPass(renderPass);

        // SAO (Scalable Ambient Obscurance) for realistic ambient occlusion - optional
        let saoPass = null;
        try {
          if (THREE.SAOPass && THREE.SAOShader) {
            saoPass = new THREE.SAOPass(scene, camera, false, true);
            saoPass.params.saoBias = 0.5;
            saoPass.params.saoIntensity = 0.002;
            saoPass.params.saoScale = 10;
            saoPass.params.saoKernelRadius = 30;
            saoPass.params.saoMinResolution = 0;
            saoPass.params.saoBlur = true;
            saoPass.params.saoBlurRadius = 12;
            saoPass.params.saoBlurStdDev = 6;
            saoPass.params.saoBlurDepthCutoff = 0.01;
            composer.addPass(saoPass);
            console.log('SAO pass initialized');
          } else {
            console.warn('SAOPass or SAOShader not available, skipping ambient occlusion');
          }
        } catch (saoErr) {
          console.warn('SAO pass failed to initialize:', saoErr.message);
        }

        // Bloom pass for subtle glow on bright/reflective surfaces
        const bloomPass = new THREE.UnrealBloomPass(
          new THREE.Vector2(width, height),
          0.15,   // strength - subtle glow
          0.5,    // radius
          0.85    // threshold - only very bright areas bloom
        );
        composer.addPass(bloomPass);

        // FXAA anti-aliasing pass for smoother edges
        const fxaaPass = new THREE.ShaderPass(THREE.FXAAShader);
        const pixelRatio = renderer.getPixelRatio();
        fxaaPass.material.uniforms['resolution'].value.x = 1 / (width * pixelRatio);
        fxaaPass.material.uniforms['resolution'].value.y = 1 / (height * pixelRatio);
        composer.addPass(fxaaPass);

        // Store passes for dynamic adjustment
        window._postProcessing = {
          composer,
          saoPass,
          bloomPass,
          fxaaPass,
          enabled: true
        };

        console.log('Post-processing initialized: Bloom + FXAA' + (saoPass ? ' + SAO' : ''));
      } catch (e) {
        console.warn('Post-processing not available, using standard rendering:', e);
        composer = null;
        postProcessingEnabled = false;
      }

      // Prevent context menu on 3D view
      container.addEventListener('contextmenu', (e) => e.preventDefault());

      // ===== 3D AXIS INDICATOR (Orientation Key) =====
      // Create axis indicator scene, camera, and renderer
      const axisScene = new THREE.Scene();
      const axisCamera = new THREE.PerspectiveCamera(50, 1, 0.1, 100);
      axisCamera.position.set(0, 0, 3);
      axisCamera.lookAt(0, 0, 0);

      const axisRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      axisRenderer.setSize(100, 100);
      axisRenderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      axisRenderer.setClearColor(0x000000, 0);

      // Create axis container and add to DOM
      const axisContainer = document.createElement('div');
      axisContainer.className = 'axis-indicator-container';
      axisContainer.appendChild(axisRenderer.domElement);
      container.appendChild(axisContainer);

      // Create colored axis arrows
      const axisLength = 0.8;
      const arrowHeadLength = 0.2;
      const arrowHeadWidth = 0.1;

      // X axis (Red) - Right direction
      const xDir = new THREE.Vector3(1, 0, 0);
      const xArrow = new THREE.ArrowHelper(xDir, new THREE.Vector3(0, 0, 0), axisLength, 0xff4444, arrowHeadLength, arrowHeadWidth);
      axisScene.add(xArrow);

      // Y axis (Green) - Up direction
      const yDir = new THREE.Vector3(0, 1, 0);
      const yArrow = new THREE.ArrowHelper(yDir, new THREE.Vector3(0, 0, 0), axisLength, 0x44ff44, arrowHeadLength, arrowHeadWidth);
      axisScene.add(yArrow);

      // Z axis (Blue) - Forward direction
      const zDir = new THREE.Vector3(0, 0, 1);
      const zArrow = new THREE.ArrowHelper(zDir, new THREE.Vector3(0, 0, 0), axisLength, 0x4488ff, arrowHeadLength, arrowHeadWidth);
      axisScene.add(zArrow);

      // Add axis labels
      function createAxisLabels() {
        const labelX = document.createElement('div');
        labelX.className = 'axis-label axis-label-x';
        labelX.textContent = 'X';
        labelX.style.cssText = 'right: 8px; top: 50%; transform: translateY(-50%);';
        axisContainer.appendChild(labelX);

        const labelY = document.createElement('div');
        labelY.className = 'axis-label axis-label-y';
        labelY.textContent = 'Y';
        labelY.style.cssText = 'left: 50%; top: 8px; transform: translateX(-50%);';
        axisContainer.appendChild(labelY);

        const labelZ = document.createElement('div');
        labelZ.className = 'axis-label axis-label-z';
        labelZ.textContent = 'Z';
        labelZ.style.cssText = 'left: 8px; bottom: 8px;';
        axisContainer.appendChild(labelZ);
      }
      createAxisLabels();

      // Add soft ambient light to axis indicator
      const axisAmbient = new THREE.AmbientLight(0xffffff, 1);
      axisScene.add(axisAmbient);

      // Store axis components for animation loop access
      window._axisIndicator = {
        scene: axisScene,
        camera: axisCamera,
        renderer: axisRenderer,
        container: axisContainer
      };

      // Add reset view function to window scope
      window.reset3DView = function() {
        camera.position.copy(initialCameraPosition);
        controls.target.copy(initialTarget);
        controls.update();
      };

      // Preset view angles
      window.set3DViewAngle = function(angle) {
        const centerX = roomWidth / 2;
        const centerZ = roomDepth / 2;
        const distance = Math.max(roomWidth, roomDepth) * 1.2;

        switch(angle) {
          case 'top':
            // Bird's eye view - straight down
            camera.position.set(centerX, distance + 8, centerZ + 0.1);
            controls.target.set(centerX, 0, centerZ);
            break;
          case 'front':
            // Front elevation view
            camera.position.set(centerX, 5, roomDepth + distance * 0.8);
            controls.target.set(centerX, 3, centerZ);
            break;
          case 'side':
            // Side elevation view
            camera.position.set(roomWidth + distance * 0.8, 5, centerZ);
            controls.target.set(centerX, 3, centerZ);
            break;
          case 'counter':
            // Counter-level view - eye height looking at countertop
            // Position camera at human eye level (5.5ft) looking at counter height (3ft)
            camera.position.set(centerX, 5.5, roomDepth * 0.8);
            controls.target.set(centerX, 3, centerZ * 0.5);
            break;
          case 'corner':
            // Corner view - diagonal across room for best overall view
            camera.position.set(-2, 6, roomDepth + 2);
            controls.target.set(centerX, 2.5, centerZ);
            break;
          case 'closeup':
            // Close-up of cabinets/counters
            camera.position.set(centerX, 4, roomDepth * 0.3);
            controls.target.set(centerX, 3, 2);
            break;
          default:
            camera.position.copy(initialCameraPosition);
            controls.target.copy(initialTarget);
        }

        controls.update();
      };

      // Cabinet focus mode - hides walls, windows, doors for clear cabinet view
      let cabinetFocusMode = false;
      window.toggleCabinetFocus = function() {
        cabinetFocusMode = !cabinetFocusMode;
        const btn = document.getElementById('focusCabinetsBtn');

        if (cabinetFocusMode) {
          // Hide structural elements, show only cabinets/counters/appliances
          hiddenCategories['walls'] = true;
          hiddenCategories['windows'] = true;
          hiddenCategories['doors'] = true;
          hiddenCategories['niches'] = true;
          hiddenCategories['decorative'] = true;

          // Update UI checkboxes
          document.querySelectorAll('.visibility-toggle input').forEach(cb => {
            const cat = cb.getAttribute('onchange')?.match(/'(\w+)'/)?.[1];
            if (['walls', 'windows', 'doors', 'niches', 'decorative'].includes(cat)) {
              cb.checked = false;
            }
          });

          if (btn) {
            btn.style.background = 'var(--accent-color)';
            btn.style.color = 'white';
          }

          // Set a good view angle for cabinets
          set3DViewAngle('corner');

          showToast('Focus mode: Showing cabinets & countertops only', 'info');
        } else {
          // Restore all visibility
          delete hiddenCategories['walls'];
          delete hiddenCategories['windows'];
          delete hiddenCategories['doors'];
          delete hiddenCategories['niches'];
          delete hiddenCategories['decorative'];

          // Update UI checkboxes
          document.querySelectorAll('.visibility-toggle input').forEach(cb => {
            const cat = cb.getAttribute('onchange')?.match(/'(\w+)'/)?.[1];
            if (['walls', 'windows', 'doors', 'niches', 'decorative'].includes(cat)) {
              cb.checked = true;
            }
          });

          if (btn) {
            btn.style.background = '';
            btn.style.color = '';
          }

          showToast('Showing all elements', 'info');
        }

        // Refresh the view
        draw();
        if (currentView === '3d') update3DScene();
      };

      // === WALKTHROUGH / FIRST-PERSON MODE ===
      let walkthroughMode = false;
      let walkthroughKeys = { w: false, a: false, s: false, d: false, q: false, e: false };
      let walkthroughMoveSpeed = 0.15;
      let walkthroughLookSpeed = 0.002;
      let walkthroughYaw = 0;
      let walkthroughPitch = 0;
      let walkthroughAnimationId = null;

      window.toggleWalkthroughMode = function() {
        walkthroughMode = !walkthroughMode;
        const btn = document.getElementById('walkthroughBtn');
        const normalHint = document.getElementById('threeHint');
        const walkHint = document.getElementById('walkthroughHint');
        const threeContainer = document.getElementById('three-container');

        if (walkthroughMode) {
          // Enter walkthrough mode
          controls.enabled = false;

          // Position camera at eye level (5.5ft) at entrance
          camera.position.set(roomWidth / 2, 5.5, roomDepth - 2);
          walkthroughYaw = 0;
          walkthroughPitch = 0;

          // Show/hide hints
          if (normalHint) normalHint.style.display = 'none';
          if (walkHint) walkHint.style.display = 'flex';

          // Style button
          if (btn) {
            btn.style.background = 'var(--accent-color)';
            btn.style.color = 'white';
          }

          // Enable pointer lock for mouse look
          threeContainer.addEventListener('click', requestPointerLock);
          document.addEventListener('pointerlockchange', onPointerLockChange);
          document.addEventListener('mousemove', onWalkthroughMouseMove);
          document.addEventListener('keydown', onWalkthroughKeyDown);
          document.addEventListener('keyup', onWalkthroughKeyUp);

          // Start animation loop
          walkthroughAnimate();

          showToast('Walkthrough mode: Click to enable mouse look, WASD to move', 'info');
        } else {
          // Exit walkthrough mode
          exitWalkthroughMode();
        }
      };

      function exitWalkthroughMode() {
        walkthroughMode = false;
        controls.enabled = true;

        const btn = document.getElementById('walkthroughBtn');
        const normalHint = document.getElementById('threeHint');
        const walkHint = document.getElementById('walkthroughHint');
        const threeContainer = document.getElementById('three-container');

        if (normalHint) normalHint.style.display = 'flex';
        if (walkHint) walkHint.style.display = 'none';

        if (btn) {
          btn.style.background = '';
          btn.style.color = '';
        }

        // Exit pointer lock
        if (document.pointerLockElement) {
          document.exitPointerLock();
        }

        // Remove event listeners
        threeContainer?.removeEventListener('click', requestPointerLock);
        document.removeEventListener('pointerlockchange', onPointerLockChange);
        document.removeEventListener('mousemove', onWalkthroughMouseMove);
        document.removeEventListener('keydown', onWalkthroughKeyDown);
        document.removeEventListener('keyup', onWalkthroughKeyUp);

        // Stop animation
        if (walkthroughAnimationId) {
          cancelAnimationFrame(walkthroughAnimationId);
          walkthroughAnimationId = null;
        }

        // Reset controls target
        controls.target.set(roomWidth / 2, 2, roomDepth / 2);
        controls.update();

        showToast('Exited walkthrough mode', 'info');
      }

      // === POST-PROCESSING TOGGLE ===
      window.togglePostProcessing = function() {
        if (!window._postProcessing) {
          showToast('Post-processing not available', 'warning');
          return;
        }

        window._postProcessing.enabled = !window._postProcessing.enabled;
        postProcessingEnabled = window._postProcessing.enabled;

        const btn = document.getElementById('postProcessingBtn');
        if (btn) {
          if (window._postProcessing.enabled) {
            btn.classList.add('active');
            btn.style.background = 'linear-gradient(135deg, #6366f1, #8b5cf6)';
            btn.style.color = '#fff';
            showToast('Enhanced graphics ON (Bloom + AO)', 'success');
          } else {
            btn.classList.remove('active');
            btn.style.background = '';
            btn.style.color = '';
            showToast('Enhanced graphics OFF (faster rendering)', 'info');
          }
        }
      };

      // Adjust post-processing quality
      window.setPostProcessingQuality = function(quality) {
        if (!window._postProcessing) return;

        const { saoPass, bloomPass } = window._postProcessing;

        switch (quality) {
          case 'high':
            if (saoPass) {
              saoPass.params.saoIntensity = 0.003;
              saoPass.params.saoKernelRadius = 50;
              saoPass.params.saoBlurRadius = 16;
            }
            if (bloomPass) {
              bloomPass.strength = 0.2;
              bloomPass.threshold = 0.8;
            }
            break;
          case 'medium':
            if (saoPass) {
              saoPass.params.saoIntensity = 0.002;
              saoPass.params.saoKernelRadius = 30;
              saoPass.params.saoBlurRadius = 12;
            }
            if (bloomPass) {
              bloomPass.strength = 0.15;
              bloomPass.threshold = 0.85;
            }
            break;
          case 'low':
            if (saoPass) {
              saoPass.params.saoIntensity = 0.001;
              saoPass.params.saoKernelRadius = 15;
              saoPass.params.saoBlurRadius = 8;
            }
            if (bloomPass) {
              bloomPass.strength = 0.1;
              bloomPass.threshold = 0.9;
            }
            break;
        }
      };

      function requestPointerLock() {
        const threeContainer = document.getElementById('three-container');
        threeContainer?.requestPointerLock();
      }

      function onPointerLockChange() {
        if (!document.pointerLockElement && walkthroughMode) {
          // Still in walkthrough mode but pointer unlocked - show hint
          showToast('Click 3D view to re-enable mouse look', 'info');
        }
      }

      function onWalkthroughMouseMove(e) {
        if (!walkthroughMode || !document.pointerLockElement) return;

        walkthroughYaw -= e.movementX * walkthroughLookSpeed;
        walkthroughPitch -= e.movementY * walkthroughLookSpeed;

        // Clamp pitch to prevent flipping
        walkthroughPitch = Math.max(-Math.PI / 2 + 0.1, Math.min(Math.PI / 2 - 0.1, walkthroughPitch));
      }

      function onWalkthroughKeyDown(e) {
        if (!walkthroughMode) return;

        const key = e.key.toLowerCase();
        if (key === 'w') walkthroughKeys.w = true;
        if (key === 'a') walkthroughKeys.a = true;
        if (key === 's') walkthroughKeys.s = true;
        if (key === 'd') walkthroughKeys.d = true;
        if (key === 'q') walkthroughKeys.q = true;
        if (key === 'e') walkthroughKeys.e = true;
        if (key === 'escape') exitWalkthroughMode();
        if (key === 'shift') walkthroughMoveSpeed = 0.3; // Sprint
      }

      function onWalkthroughKeyUp(e) {
        if (!walkthroughMode) return;

        const key = e.key.toLowerCase();
        if (key === 'w') walkthroughKeys.w = false;
        if (key === 'a') walkthroughKeys.a = false;
        if (key === 's') walkthroughKeys.s = false;
        if (key === 'd') walkthroughKeys.d = false;
        if (key === 'q') walkthroughKeys.q = false;
        if (key === 'e') walkthroughKeys.e = false;
        if (key === 'shift') walkthroughMoveSpeed = 0.15; // Normal speed
      }

      function walkthroughAnimate() {
        if (!walkthroughMode) return;

        walkthroughAnimationId = requestAnimationFrame(walkthroughAnimate);

        // Calculate forward/right vectors based on yaw
        const forward = new THREE.Vector3(
          Math.sin(walkthroughYaw),
          0,
          Math.cos(walkthroughYaw)
        );
        const right = new THREE.Vector3(
          Math.sin(walkthroughYaw + Math.PI / 2),
          0,
          Math.cos(walkthroughYaw + Math.PI / 2)
        );

        // Apply movement
        if (walkthroughKeys.w) {
          camera.position.add(forward.clone().multiplyScalar(-walkthroughMoveSpeed));
        }
        if (walkthroughKeys.s) {
          camera.position.add(forward.clone().multiplyScalar(walkthroughMoveSpeed));
        }
        if (walkthroughKeys.a) {
          camera.position.add(right.clone().multiplyScalar(-walkthroughMoveSpeed));
        }
        if (walkthroughKeys.d) {
          camera.position.add(right.clone().multiplyScalar(walkthroughMoveSpeed));
        }
        if (walkthroughKeys.q) {
          camera.position.y -= walkthroughMoveSpeed * 0.5;
        }
        if (walkthroughKeys.e) {
          camera.position.y += walkthroughMoveSpeed * 0.5;
        }

        // Keep camera within reasonable bounds
        camera.position.x = Math.max(-5, Math.min(roomWidth + 5, camera.position.x));
        camera.position.y = Math.max(1, Math.min(12, camera.position.y));
        camera.position.z = Math.max(-5, Math.min(roomDepth + 5, camera.position.z));

        // Update camera look direction
        const lookTarget = new THREE.Vector3(
          camera.position.x + Math.sin(walkthroughYaw) * Math.cos(walkthroughPitch),
          camera.position.y + Math.sin(walkthroughPitch),
          camera.position.z + Math.cos(walkthroughYaw) * Math.cos(walkthroughPitch)
        );
        camera.lookAt(lookTarget);

        // Render
        renderer.render(scene, camera);
      }

      // === LIGHTING ===
      // === BALANCED LIGHTING SYSTEM ===
      // Reduced intensity for realistic indoor lighting that preserves material colors
      // Goal: Dark colors stay dark, light colors stay visible without washing out
      const lightingPresets = {
        morning: {
          ambient: { color: 0xFFF8F0, intensity: 0.35 },
          hemisphere: { sky: 0xFFE4C4, ground: 0x8B7355, intensity: 0.25 },
          sun: { color: 0xFFE4B5, intensity: 0.6, pos: [25, 12, 15] },
          fill: { color: 0xFFE8D6, intensity: 0.2 },
          exposure: 0.9
        },
        noon: {
          ambient: { color: 0xFFFFFF, intensity: 0.4 },
          hemisphere: { sky: 0xE0F0FF, ground: 0x8B7355, intensity: 0.3 },
          sun: { color: 0xFFFFF8, intensity: 0.7, pos: [15, 25, 15] },
          fill: { color: 0xFFFFFF, intensity: 0.25 },
          exposure: 0.95
        },
        evening: {
          ambient: { color: 0xFFE0C0, intensity: 0.3 },
          hemisphere: { sky: 0xFFA07A, ground: 0x6B4423, intensity: 0.2 },
          sun: { color: 0xFF8C00, intensity: 0.5, pos: [-20, 8, 10] },
          fill: { color: 0xFFD4B8, intensity: 0.25 },
          exposure: 0.85
        },
        night: {
          ambient: { color: 0xC0C8D8, intensity: 0.25 },
          hemisphere: { sky: 0x4169E1, ground: 0x2F3F4F, intensity: 0.15 },
          sun: { color: 0xB0C4DE, intensity: 0.15, pos: [-15, 20, 10] },
          fill: { color: 0xFFF8E0, intensity: 0.35 }, // Interior lights
          exposure: 0.75
        },
        // SHOWROOM: Optimized for showcasing countertop colors accurately
        // Bright, neutral white lighting with minimal color cast
        showroom: {
          ambient: { color: 0xFFFFFF, intensity: 0.55 },
          hemisphere: { sky: 0xFFFFFF, ground: 0xF0F0F0, intensity: 0.35 },
          sun: { color: 0xFFFFFF, intensity: 0.85, pos: [10, 20, 10] },
          fill: { color: 0xFFFFFF, intensity: 0.4 },
          exposure: 1.1
        }
      };

      const preset = lightingPresets[timeOfDay] || lightingPresets.noon;

      // Apply exposure setting - controls overall brightness
      renderer.toneMappingExposure = preset.exposure;

      // Ambient light - soft overall illumination (reduced to preserve color contrast)
      const ambient = new THREE.AmbientLight(preset.ambient.color, preset.ambient.intensity);
      ambient.name = 'ambientLight';
      scene.add(ambient);

      // Hemisphere light (subtle sky/ground gradient for natural feel)
      const hemi = new THREE.HemisphereLight(preset.hemisphere.sky, preset.hemisphere.ground, preset.hemisphere.intensity);
      hemi.name = 'hemisphereLight';
      scene.add(hemi);

      // Main directional (sun/moon) with shadows - primary light source
      // Enhanced shadow quality for realistic rendering
      const sun = new THREE.DirectionalLight(preset.sun.color, preset.sun.intensity);
      sun.name = 'sunLight';
      sun.position.set(...preset.sun.pos);
      sun.castShadow = true;
      sun.shadow.mapSize.width = 4096;  // Higher resolution shadows
      sun.shadow.mapSize.height = 4096;
      sun.shadow.camera.near = 0.5;
      sun.shadow.camera.far = 60;
      sun.shadow.camera.left = -30;
      sun.shadow.camera.right = 30;
      sun.shadow.camera.top = 30;
      sun.shadow.camera.bottom = -30;
      sun.shadow.bias = -0.0001;  // Reduced bias for sharper shadows
      sun.shadow.normalBias = 0.02;  // Helps with shadow acne on curved surfaces
      sun.shadow.radius = 1.5;  // Soft shadow edges
      scene.add(sun);

      // Fill light - softens shadows, subtle
      const fill = new THREE.DirectionalLight(preset.fill.color, preset.fill.intensity);
      fill.name = 'fillLight';
      fill.position.set(-roomWidth, 12, roomDepth);
      scene.add(fill);

      // Enhanced countertop showcase lighting system
      // Multiple soft spotlights positioned to highlight stone colors and textures

      // Primary countertop spotlight - centered, warm white for color accuracy
      const countertopSpot1 = new THREE.SpotLight(0xFFFAF0, 0.55);
      countertopSpot1.name = 'countertopSpot1';
      countertopSpot1.position.set(roomWidth / 2, 8, roomDepth / 3);
      countertopSpot1.target.position.set(roomWidth / 2, 3, roomDepth / 3);
      countertopSpot1.angle = Math.PI / 4;
      countertopSpot1.penumbra = 0.6;
      countertopSpot1.decay = 1.5;
      countertopSpot1.distance = 15;
      scene.add(countertopSpot1);
      scene.add(countertopSpot1.target);

      // Secondary countertop spotlight - back wall coverage
      const countertopSpot2 = new THREE.SpotLight(0xFFFAF0, 0.45);
      countertopSpot2.name = 'countertopSpot2';
      countertopSpot2.position.set(roomWidth / 3, 8, 2);
      countertopSpot2.target.position.set(roomWidth / 3, 3, 1);
      countertopSpot2.angle = Math.PI / 5;
      countertopSpot2.penumbra = 0.5;
      countertopSpot2.decay = 1.5;
      countertopSpot2.distance = 12;
      scene.add(countertopSpot2);
      scene.add(countertopSpot2.target);

      // Third spotlight for island/peninsula if room is large enough
      if (roomWidth > 10 || roomDepth > 10) {
        const countertopSpot3 = new THREE.SpotLight(0xFFFAF0, 0.4);
        countertopSpot3.name = 'countertopSpot3';
        countertopSpot3.position.set(roomWidth * 0.6, 8, roomDepth * 0.6);
        countertopSpot3.target.position.set(roomWidth * 0.6, 3, roomDepth * 0.6);
        countertopSpot3.angle = Math.PI / 4;
        countertopSpot3.penumbra = 0.6;
        countertopSpot3.decay = 1.5;
        countertopSpot3.distance = 12;
        scene.add(countertopSpot3);
        scene.add(countertopSpot3.target);
      }

      // Subtle surface light for overall countertop visibility
      const surfaceLight = new THREE.DirectionalLight(0xFFFFFF, 0.18);
      surfaceLight.name = 'surfaceLight';
      surfaceLight.position.set(roomWidth / 2, 12, roomDepth / 2);
      surfaceLight.target.position.set(roomWidth / 2, 0, roomDepth / 2);
      scene.add(surfaceLight);
      scene.add(surfaceLight.target);

      // Subtle rim light for depth separation
      const back = new THREE.DirectionalLight(0xE8F0FF, 0.12);
      back.name = 'backLight';
      back.position.set(roomWidth / 2, 5, -10);
      scene.add(back);

      // Edge accent light - highlights countertop edges and profiles
      // Enhanced for better definition on white/light countertops
      const edgeLight = new THREE.DirectionalLight(0xF0F8FF, 0.15);
      edgeLight.name = 'edgeLight';
      edgeLight.position.set(-5, 4, roomDepth / 2);
      scene.add(edgeLight);

      // === ENHANCED WHITE SURFACE DEFINITION ===
      // Additional lighting for light-colored/white countertops visibility
      // Low-angle light creates subtle shadows on edges for definition
      const contrastLight = new THREE.DirectionalLight(0xE8E8F0, 0.12);
      contrastLight.name = 'contrastLight';
      contrastLight.position.set(roomWidth * 0.8, 3.5, -3);
      contrastLight.castShadow = true;
      contrastLight.shadow.mapSize.width = 2048;
      contrastLight.shadow.mapSize.height = 2048;
      contrastLight.shadow.camera.near = 0.1;
      contrastLight.shadow.camera.far = 25;
      contrastLight.shadow.bias = -0.0003;
      scene.add(contrastLight);

      // Side definition light - grazing angle for edge highlight on white surfaces
      const sideDefinition = new THREE.DirectionalLight(0xFFF8F0, 0.08);
      sideDefinition.name = 'sideDefinition';
      sideDefinition.position.set(roomWidth + 5, 4, roomDepth / 2);
      scene.add(sideDefinition);

      // Under-cabinet subtle shadow light for countertop edge definition
      const underCabinetShadow = new THREE.DirectionalLight(0xF5F5FF, 0.06);
      underCabinetShadow.name = 'underCabinetShadow';
      underCabinetShadow.position.set(roomWidth / 2, 5, roomDepth + 3);
      scene.add(underCabinetShadow);

      // === ENHANCED ENVIRONMENT MAP FOR REALISTIC REFLECTIONS ===
      // High-quality HDR-like environment for polished stone and metallic surfaces
      const pmremGenerator = new THREE.PMREMGenerator(renderer);
      pmremGenerator.compileEquirectangularShader();

      // Environment colors based on time of day - enhanced for better reflections
      const envColors = {
        morning: {
          sky: '#FFE4B5', skyDark: '#DEC99A',
          horizon: '#FFF8DC',
          ground: '#D2B48C', groundDark: '#A08060',
          sunColor: '#FFE5A0', sunIntensity: 0.9
        },
        noon: {
          sky: '#A8CCE8', skyDark: '#7BA8D0',
          horizon: '#F0F4F8',
          ground: '#D4C4B0', groundDark: '#A09080',
          sunColor: '#FFFEF0', sunIntensity: 1.0
        },
        evening: {
          sky: '#FFA07A', skyDark: '#E08050',
          horizon: '#FFE4C4',
          ground: '#8B6545', groundDark: '#5A4030',
          sunColor: '#FFC080', sunIntensity: 0.7
        },
        night: {
          sky: '#1A2840', skyDark: '#0F1A28',
          horizon: '#2A3A50',
          ground: '#1A2030', groundDark: '#101520',
          sunColor: '#6080A0', sunIntensity: 0.2
        }
      };

      const envCol = envColors[timeOfDay] || envColors.noon;

      // Create high-resolution environment map canvas
      const envCanvas = document.createElement('canvas');
      envCanvas.width = 1024;  // Higher resolution for better reflections
      envCanvas.height = 512;
      const envCtx = envCanvas.getContext('2d');

      // Create detailed vertical gradient (sky to ground)
      const mainGradient = envCtx.createLinearGradient(0, 0, 0, 512);
      mainGradient.addColorStop(0, envCol.skyDark);
      mainGradient.addColorStop(0.15, envCol.sky);
      mainGradient.addColorStop(0.4, envCol.horizon);
      mainGradient.addColorStop(0.5, envCol.horizon);
      mainGradient.addColorStop(0.6, envCol.ground);
      mainGradient.addColorStop(1, envCol.groundDark);
      envCtx.fillStyle = mainGradient;
      envCtx.fillRect(0, 0, 1024, 512);

      // Add soft ambient light variations for more natural reflections
      if (timeOfDay !== 'night') {
        // Subtle sun/bright area simulation
        const sunX = timeOfDay === 'morning' ? 200 : (timeOfDay === 'evening' ? 800 : 512);
        const sunY = timeOfDay === 'noon' ? 120 : 160;

        // Sun glow (softer, more realistic)
        const sunGradient = envCtx.createRadialGradient(sunX, sunY, 0, sunX, sunY, 150);
        sunGradient.addColorStop(0, `rgba(255, 255, 240, ${envCol.sunIntensity * 0.5})`);
        sunGradient.addColorStop(0.3, `rgba(255, 250, 220, ${envCol.sunIntensity * 0.3})`);
        sunGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
        envCtx.fillStyle = sunGradient;
        envCtx.fillRect(0, 0, 1024, 512);

        // Soft cloud/light variations for more interesting reflections
        envCtx.fillStyle = 'rgba(255, 255, 255, 0.08)';
        envCtx.fillRect(150, 140, 200, 40);
        envCtx.fillRect(400, 160, 150, 35);
        envCtx.fillRect(700, 150, 180, 38);

        // Ground reflections (floor/counter bounce light)
        envCtx.fillStyle = 'rgba(255, 248, 240, 0.06)';
        envCtx.fillRect(0, 350, 1024, 80);
      } else {
        // Night: subtle window/artificial light reflections
        envCtx.fillStyle = 'rgba(180, 200, 220, 0.1)';
        envCtx.fillRect(100, 200, 80, 60);
        envCtx.fillRect(300, 190, 100, 70);
        envCtx.fillRect(600, 195, 90, 65);
        envCtx.fillRect(850, 200, 70, 55);
      }

      // Add subtle horizontal bands for indoor lighting simulation
      for (let y = 180; y < 280; y += 40) {
        envCtx.fillStyle = `rgba(255, 255, 255, ${timeOfDay === 'night' ? 0.02 : 0.04})`;
        envCtx.fillRect(0, y, 1024, 15);
      }

      const envTexture = new THREE.CanvasTexture(envCanvas);
      envTexture.mapping = THREE.EquirectangularReflectionMapping;
      envTexture.colorSpace = THREE.SRGBColorSpace;

      // Generate environment map with higher quality
      const envMap = pmremGenerator.fromEquirectangular(envTexture).texture;
      scene.environment = envMap;

      // Store for use in materials
      window.roomEnvMap = envMap;

      // Cleanup
      pmremGenerator.dispose();
      envTexture.dispose();

      // Note: Background is already set above based on time of day

      // Resize handler
      window.addEventListener('resize', () => {
        if (!renderer || !camera || !container) return;
        const w = container.clientWidth;
        const h = container.clientHeight;
        if (w > 0 && h > 0) {
          camera.aspect = w / h;
          camera.updateProjectionMatrix();
          renderer.setSize(w, h);

          // Update post-processing composer on resize
          if (composer) {
            composer.setSize(w, h);
            // Update FXAA resolution
            if (window._postProcessing?.fxaaPass) {
              const pixelRatio = renderer.getPixelRatio();
              window._postProcessing.fxaaPass.material.uniforms['resolution'].value.x = 1 / (w * pixelRatio);
              window._postProcessing.fxaaPass.material.uniforms['resolution'].value.y = 1 / (h * pixelRatio);
            }
            // Update bloom resolution
            if (window._postProcessing?.bloomPass) {
              window._postProcessing.bloomPass.resolution.set(w, h);
            }
          }
        }
      });
    }

    // Get proper 3D height for element types
    // Can accept element object to use custom heights
    function get3DHeight(typeOrElement) {
      let type = typeof typeOrElement === 'string' ? typeOrElement : typeOrElement?.type;
      const el = typeof typeOrElement === 'object' ? typeOrElement : null;

      // Validate input
      if (!type) {
        console.warn('get3DHeight: No type provided', typeOrElement);
        return 1; // Default 1 foot
      }

      // Check for custom 3D height override on the element
      if (el?.actualHeight !== undefined && el.actualHeight > 0) {
        return el.actualHeight;
      }
      if (el?.height3D !== undefined) {
        return el.height3D;
      }

      // Normalize sized cabinet types to base types (e.g., base-cabinet-12 -> base-cabinet)
      const normalizeTypeFor3DHeight = (t) => {
        if (t.startsWith('base-cabinet-')) return 'base-cabinet';
        if (t.startsWith('wall-cabinet-')) return 'wall-cabinet';
        if (t.startsWith('tall-cabinet-')) return 'tall-cabinet';
        if (t.startsWith('drawer-base-')) return 'drawer-base';
        if (t.startsWith('sink-base-')) return 'sink-base';
        if (t.startsWith('corner-cabinet-')) return 'corner-cabinet';
        return t;
      };
      type = normalizeTypeFor3DHeight(type);

      // Window-specific height override
      if (el?.windowHeight !== undefined && (type === 'window' || type === 'window-large' || type === 'window-bay' || type === 'bay-window' || type === 'picture-window')) {
        return el.windowHeight;
      }

      // Full-height wall types use room ceiling height
      const fullHeightTypes = [
        'wall', 'wall-block', 'wall-concrete', 'wall-framed',
        'wall-wood-2x4', 'wall-wood-2x6', 'wall-brick'
      ];
      if (fullHeightTypes.includes(type)) {
        // Use element's wallHeight if set, otherwise room ceiling height
        return el?.wallHeight || roomHeight || 8;
      }

      const heights = {
        'base-cabinet': 2.9,      // 35 inches standard
        'drawer-base': 2.9,       // 35 inches (same as base)
        'sink-base': 2.9,         // 35 inches (same as base)
        'wall-cabinet': 2.5,      // 30 inches
        'tall-cabinet': 7,        // 84 inches
        'corner-cabinet': 2.9,
        'lazy-susan': 2.9,        // 35 inches (corner base)
        'island': 3,              // 36 inches with countertop
        'countertop': 0.12,       // 1.5 inch thick
        'backsplash': 1.5,        // 18 inches
        'flooring': 0.05,         // Very thin
        'tile': 0.05,
        'shower-pan': 0.08,       // Shower pan thickness
        'shower-curb': 0.5,       // 6" high curb
        'shower-wall': el?.wallHeight || 7, // Full shower height
        'wall-tile': el?.wallHeight || 8,   // Full wall height
        'accent-wall': el?.wallHeight || 8, // Full wall height
        'sink': 0.3,              // Recessed
        'stove': 3,               // Full range height
        'range': 3,               // Full range height
        'cooktop': 0.2,           // Cooktop inset into counter (~2.5" thick)
        'refrigerator': 5.8,      // 70 inches
        'dishwasher': 2.9,        // 35 inches (flush with base cabinets under counter)
        'microwave': 1.25,        // 15 inches (typical OTR microwave)
        'range-hood': 1.5,        // 18 inches tall
        'oven': 2.4,              // 29 inches
        'wall-oven-double': 4.5,  // 54 inches (double wall oven)
        'slide-in-range': 3,      // 36 inches (same as range)
        'microwave-cabinet': 1.5, // 18 inches (open shelf for microwave)
        'above-microwave-cabinet': 1.25, // 15 inches (cabinet above microwave, matches wall cab alignment)
        'single-oven-cabinet': 7, // 84 inches (standard tall oven cabinet)
        'tall-oven': 7, // 84 inches (alias for single oven cabinet)
        'double-oven-cabinet': 8, // 96 inches (tall cabinet with double oven)
        'fridge-cabinet': 7,      // 84 inches (surrounds refrigerator)
        'blind-corner': 2.9,      // 35 inches (same as base cabinet)
        'door': 6.8,              // 82 inches
        'double-door': 6.8,       // 82 inches
        'sliding-door': 6.8,      // 82 inches
        'french-door': 6.8,       // 82 inches
        'glass-door': 6.8,        // 82 inches
        'entry-archway': 7,       // 84 inches (arched opening)
        'garage-door': 7,         // 84 inches
        'window': 4.5,            // 54 inches - standard double-hung (IRC)
        'window-large': 5,        // 60 inches (picture)
        'window-bay': 4,          // 48 inches (bay)
        'bay-window': 4,          // 48 inches
        'picture-window': 5,      // 60 inches
        // Niches - these are the opening heights
        'wall-niche': 3,          // 36 inches
        'fireplace-niche': 2.5,   // 30 inches
        'tv-niche': 2.5,          // 30 inches (for TV)
        'shower-niche': 1.5,      // 18 inches (small)
        // ADA grab bars
        'grab-bar': 0.25,         // 3 inches diameter
        'grab-bar-24': 0.25,      // 3 inches diameter (24" length)
        'grab-bar-36': 0.25,      // 3 inches diameter (36" length)
        'grab-bar-42': 0.25,      // 3 inches diameter (42" length)
        // Pony walls (use element's wallHeight if set)
        'pony-wall': el?.wallHeight || 3.5,         // 42 inches
        'pony-wall-bar': el?.wallHeight || 3.5,     // 42 inches
        'knee-wall': el?.wallHeight || 2.5,         // 30 inches

        // Stone caps and ledges
        'wall-cap': el?.thickness || 0.1,           // 1.25" cap thickness
        'bar-top': el?.thickness || 0.125,          // 1.5" bar top thickness
        'window-sill': el?.stoneThickness || 0.06,  // 3/4" sill
        'threshold': el?.stoneThickness || 0.04,    // 1/2" threshold
        'mantel': el?.stoneThickness || 0.1,        // Mantel shelf thickness
        'fireplace-hearth': el?.stoneThickness || 0.125, // Hearth slab
        'fireplace-surround': el?.surroundWidth || 0.67, // Surround width as height
        'niche-surround': el?.surroundWidth || 0.5, // Niche surround

        // Bathroom fixtures
        'toilet': 2.3,                  // 27.6" standard toilet (to top of tank)
        'toilet-round': 2.3,            // 27.6" round bowl toilet
        'toilet-wall': 1.5,             // 18" wall-hung (no tank visible)
        'bidet': 1.3,                   // 15.6" bidet height
        'bathtub': 1.5,                 // 18" standard alcove tub
        'bathtub-freestanding': 2,      // 24" freestanding (higher sides)
        'bathtub-corner': 1.5,          // 18" corner tub
        'bathtub-walk-in': 3.2,         // 38.4" walk-in tub (tall sides)
        'vanity-24': 2.7,              // 32.4" standard vanity height
        'vanity-30': 2.7,
        'vanity-36': 2.7,
        'vanity-48': 2.7,
        'vanity-60': 2.7,
        'vanity-72': 2.7,
        'shower-bench': 1.5,            // 18" bench seat height
        'shower-glass': 6.5,            // 78" shower glass panel
        'shower-door': 6.5,             // 78" shower door
        'shower-base-36': 0.08,         // Same as shower pan
        'shower-base-48': 0.08,
        'shower-base-60': 0.08,
        'mirror': 3,                    // 36" typical bathroom mirror
        'medicine-cabinet': 2.5,        // 30" medicine cabinet
        'towel-bar': 0.25,              // 3" bar diameter
        'toilet-paper': 0.5,            // 6" holder

        // Laundry elements
        'washer': 3,                    // 36" front-load washer height
        'dryer': 3,                     // 36" dryer height
        'washer-dryer-stack': 6,        // 72" stacked unit
        'utility-sink': 2.9,            // 34.8" utility sink on legs
        'laundry-sink': 2.7,            // 32.4" laundry sink
        'laundry-cabinet': 2.9,         // 34.8" same as base cabinet
        'ironing-board': 3,             // 36" standing height
        'drying-rack': 5,               // 60" drying rack

        // Closet elements
        'closet-rod': 0.1,              // 1.2" rod diameter
        'closet-shelf': 0.08,           // ~1" shelf thickness
        'closet-drawers': 2.5,          // 30" drawer stack
        'drawer-unit': 2.5,             // 30" drawer unit
        'shoe-rack': 2.5,               // 30" shoe rack
        'closet-island': 3,             // 36" island with top
        'jewelry-cabinet': 3,           // 36" standing jewelry cabinet
        'jewelry-drawer': 0.5,          // 6" small drawer
        'tie-rack': 2,                  // 24" tie/belt rack
        'full-mirror': 5,               // 60" full-length mirror

        // Trim & Molding
        'crown-molding': 0.4,           // ~5" crown drop
        'baseboard': 0.5,               // 6" baseboard height
        'chair-rail': 0.25,             // 3" chair rail height

        // Work surfaces (countertop-like materials)
        'surface-stainless': 0.1,       // 1.2" stainless steel work surface
        'surface-solid': 0.1,           // 1.2" solid surface (Corian)
        'surface-laminate': 0.125,      // 1.5" laminate on substrate
        'surface-butcherblock': 0.125,  // 1.5" butcher block
        'surface-concrete': 0.15,       // 1.8" concrete countertop (thicker)

        // Structural elements - beams and columns
        'steel-beam': el?.beamDepth || 0.67,        // 8" I-beam depth (W8 section)
        'steel-column': el?.columnHeight || 8,      // Full height (floor to ceiling)
        'wood-beam': el?.beamDepth || 0.5,          // 6" beam depth
        'wood-post': el?.columnHeight || 8,         // Full height post
        'concrete-beam': el?.beamDepth || 0.83,     // 10" concrete beam
        'concrete-column': el?.columnHeight || 8,   // Full height column
        'header': el?.beamDepth || 0.33,            // 4" header/lintel
        'lvl-beam': el?.beamDepth || 0.92           // 11" LVL beam
      };
      return heights[type] || 1;
    }

    // Get Y position (elevation) for element types
    function get3DYPosition(el, height) {
      // Validate inputs to prevent NaN propagation
      if (!el || typeof el.type === 'undefined') {
        console.warn('get3DYPosition: Invalid element', el);
        return (height || 1) / 2; // Default: floor level
      }
      if (typeof height !== 'number' || isNaN(height)) {
        height = 1; // Default 1 foot
      }

      // Proper stacking heights for kitchen elements
      // All heights in feet, Y = center of object
      // Normalize sized cabinet types to base types for proper positioning
      let type = el.type;
      if (type.startsWith('base-cabinet-')) type = 'base-cabinet';
      else if (type.startsWith('wall-cabinet-')) type = 'wall-cabinet';
      else if (type.startsWith('tall-cabinet-')) type = 'tall-cabinet';
      else if (type.startsWith('drawer-base-')) type = 'drawer-base';
      else if (type.startsWith('sink-base-')) type = 'sink-base';
      else if (type.startsWith('corner-cabinet-')) type = 'corner-cabinet';

      switch(type) {
        // Ground level surfaces (slightly above floor to prevent Z-fighting)
        case 'flooring':
        case 'tile':
        case 'shower-pan':
          return height / 2 + 0.02; // Bottom edge at 0.02ft above floor plane

        case 'shower-curb':
          return height / 2; // Sits on floor

        case 'shower-wall':
        case 'wall-tile':
        case 'accent-wall':
          return height / 2; // Wall panels sit on floor

        // Base level (on floor)
        case 'base-cabinet':
        case 'drawer-base':
        case 'sink-base':
        case 'corner-cabinet':
        case 'lazy-susan':
        case 'blind-corner':
        case 'island':
          return height / 2; // Base sits on floor

        // Counter height items (on top of base cabinets at ~35")
        case 'countertop':
        case 'countertop-l':
        case 'countertop-corner':
        case 'countertop-u': {
          // Smart stacking: detect what's beneath this countertop and sit ON TOP of it
          const ctopCenterX = el.x / pixelsPerFoot + el.width / 2;
          const ctopCenterY = el.y / pixelsPerFoot + el.height / 2;
          const ctopLeft = el.x / pixelsPerFoot;
          const ctopRight = ctopLeft + el.width;
          const ctopTop = el.y / pixelsPerFoot;
          const ctopBottom = ctopTop + el.height;

          // Types of elements countertops can sit on
          const ponyWallTypes = ['pony-wall', 'pony-wall-bar', 'knee-wall'];
          const cabinetTypes = ['base-cabinet', 'drawer-base', 'sink-base', 'corner-cabinet',
                                'lazy-susan', 'island', 'tall-cabinet'];

          // Find any element that this countertop overlaps with
          let bestMatch = null;
          let bestHeight = 0;

          elements.forEach(other => {
            if (other.id === el.id) return;

            // Calculate other element bounds
            const otherLeft = other.x / pixelsPerFoot;
            const otherRight = otherLeft + other.width;
            const otherTop = other.y / pixelsPerFoot;
            const otherBottom = otherTop + other.height;

            // Check for overlap (countertop should overlap at least 50% with the element below)
            const overlapX = Math.max(0, Math.min(ctopRight, otherRight) - Math.max(ctopLeft, otherLeft));
            const overlapY = Math.max(0, Math.min(ctopBottom, otherBottom) - Math.max(ctopTop, otherTop));
            const overlapArea = overlapX * overlapY;
            const ctopArea = el.width * el.height;

            // Need at least 20% overlap to consider sitting on it
            if (overlapArea / ctopArea < 0.2) return;

            if (ponyWallTypes.includes(other.type)) {
              const wallHeight = other.wallHeight || (other.type === 'knee-wall' ? 2.5 : 3.5);
              if (wallHeight > bestHeight) {
                bestHeight = wallHeight;
                bestMatch = other;
              }
            } else if (cabinetTypes.includes(other.type)) {
              // Get the cabinet's height (top surface)
              const cabHeight = other.type === 'tall-cabinet' ? (other.cabinetHeight || 7) :
                               (other.cabinetHeight || 2.9);
              if (cabHeight > bestHeight) {
                bestHeight = cabHeight;
                bestMatch = other;
              }
            }
          });

          if (bestMatch) {
            // Position countertop on top of the detected element
            return bestHeight + height / 2;
          }

          // Default: Base cabinet is 2.9ft (34.8"), counter sits directly on top
          return 2.9 + height / 2;
        }

        case 'sink':
        case 'sink-double':
        case 'sink-farmhouse': {
          // Smart stacking: sink sits IN/ON countertop surface
          const sinkLeft = el.x / pixelsPerFoot;
          const sinkRight = sinkLeft + el.width;
          const sinkTop = el.y / pixelsPerFoot;
          const sinkBottom = sinkTop + el.height;

          // Find countertop that this sink is in
          let counterSurface = 3.02; // Default: 2.9 cabinet + 0.12 counter

          elements.forEach(other => {
            if (other.id === el.id) return;
            if (other.type !== 'countertop') return;

            const otherLeft = other.x / pixelsPerFoot;
            const otherRight = otherLeft + other.width;
            const otherTop = other.y / pixelsPerFoot;
            const otherBottom = otherTop + other.height;

            // Check if sink overlaps with countertop
            const overlapX = Math.max(0, Math.min(sinkRight, otherRight) - Math.max(sinkLeft, otherLeft));
            const overlapY = Math.max(0, Math.min(sinkBottom, otherBottom) - Math.max(sinkTop, otherTop));

            if (overlapX > 0.1 && overlapY > 0.1) {
              // Found a countertop - calculate its surface height
              counterSurface = 2.9 + 0.12; // Standard cabinet + counter
            }
          });

          // Farmhouse sinks show apron, position slightly lower
          if (el.type === 'sink-farmhouse' || el.mountType === 'farmhouse') {
            return counterSurface - 0.1;
          }
          // Top mount sinks - rim sits ON the countertop surface
          if (el.mountType === 'topmount') {
            return counterSurface;
          }
          // Undermount sinks - the sink origin is at countertop level
          // The basin extends DOWN into the cabinet from here
          // The "hole" elements extend UP to cover the countertop
          return counterSurface;
        }

        case 'cooktop': {
          // Cooktop sits IN countertop, flush with surface
          const ctLeft = el.x / pixelsPerFoot;
          const ctRight = ctLeft + el.width;
          const ctTop = el.y / pixelsPerFoot;
          const ctBottom = ctTop + el.height;

          let counterSurface = 3.02;

          elements.forEach(other => {
            if (other.id === el.id) return;
            if (other.type !== 'countertop') return;

            const otherLeft = other.x / pixelsPerFoot;
            const otherRight = otherLeft + other.width;
            const otherTop = other.y / pixelsPerFoot;
            const otherBottom = otherTop + other.height;

            const overlapX = Math.max(0, Math.min(ctRight, otherRight) - Math.max(ctLeft, otherLeft));
            const overlapY = Math.max(0, Math.min(ctBottom, otherBottom) - Math.max(ctTop, otherTop));

            if (overlapX > 0.1 && overlapY > 0.1) {
              counterSurface = 2.9 + 0.12;
            }
          });

          // Cooktop surface is flush with countertop
          return counterSurface;
        }

        case 'stove':
        case 'range':
        case 'slide-in-range':
        case 'dishwasher':
        case 'oven':
        case 'wall-oven-double':
          return height / 2; // These are floor-standing appliances

        case 'refrigerator':
          return height / 2; // Floor standing, tall

        // Wall mounted (54" from floor is typical bottom edge per NKBA)
        case 'wall-cabinet': {
          // NKBA Standard: Wall cabinet bottom at 54" (4.5 ft) from floor
          // This provides 18" clearance above 36" counter height
          // Can be adjusted if backsplash extends higher
          const wcLeft = el.x / pixelsPerFoot;
          const wcRight = wcLeft + el.width;
          const wcTop = el.y / pixelsPerFoot;
          const wcBottom = wcTop + el.height;

          // Standard heights from BUILDING_STANDARDS
          const standardWallCabBottom = BUILDING_STANDARDS.HEIGHTS?.wallCabBottom || 4.5; // 54" from floor
          const standardCounterHeight = BUILDING_STANDARDS.HEIGHTS?.baseCounter || 3; // 36" counter
          const standardBacksplashClearance = 1.5; // 18" between counter and wall cabinet

          // Find backsplash or countertop beneath this wall cabinet
          let surfaceBelowTop = standardCounterHeight + 0.02; // Default counter surface (36" + counter thickness)
          let hasBacksplash = false;

          elements.forEach(other => {
            if (other.id === el.id) return;

            const otherLeft = other.x / pixelsPerFoot;
            const otherRight = otherLeft + other.width;
            const otherTop = other.y / pixelsPerFoot;
            const otherBottom = otherTop + other.height;

            // Check for horizontal overlap (wall cabinet should be roughly above the element)
            const overlapX = Math.max(0, Math.min(wcRight, otherRight) - Math.max(wcLeft, otherLeft));
            if (overlapX < 0.1) return;

            // Check for overlap or adjacency in Y (floor plan view)
            const overlapY = Math.max(0, Math.min(wcBottom, otherBottom) - Math.max(wcTop, otherTop));
            const adjacentY = Math.abs(wcBottom - otherTop) < 1 || Math.abs(wcTop - otherBottom) < 1;
            if (overlapY < 0.1 && !adjacentY) return;

            if (other.type === 'backsplash') {
              // Backsplash found - wall cabinet sits on top of backsplash
              // Backsplash sits on counter surface + extends up
              const bsHeight = other.verticalHeight || other.wallHeight || BUILDING_STANDARDS.BACKSPLASH?.full || 1.5;
              const bsTop = standardCounterHeight + 0.02 + bsHeight;
              if (bsTop > surfaceBelowTop) {
                surfaceBelowTop = bsTop;
                hasBacksplash = true;
              }
            } else if (other.type === 'countertop' || other.type === 'countertop-l' || other.type === 'countertop-corner') {
              // Countertop found - note its surface height
              const counterSurface = standardCounterHeight + 0.02;
              if (counterSurface > surfaceBelowTop && !hasBacksplash) {
                surfaceBelowTop = counterSurface;
              }
            }
          });

          // Calculate wall cabinet bottom position
          let wallCabBottom;

          if (hasBacksplash) {
            // Wall cabinet sits just above backsplash (small gap for visual clarity)
            wallCabBottom = surfaceBelowTop + 0.02;
          } else {
            // No backsplash found - use standard 18" clearance above counter
            // Or minimum NKBA standard of 54" from floor
            const clearanceBasedBottom = surfaceBelowTop + standardBacksplashClearance;
            wallCabBottom = Math.max(clearanceBasedBottom, standardWallCabBottom);
          }

          // Ensure minimum height per NKBA guidelines (54" min for accessibility)
          wallCabBottom = Math.max(wallCabBottom, BUILDING_STANDARDS.HEIGHTS?.wallCabBottomMin || 4.25);

          // Return Y position (center of cabinet)
          return wallCabBottom + height / 2;
        }

        case 'above-microwave-cabinet': {
          // Combined unit: cabinet with microwave below (rendered as one piece)
          // Aligns with wall cabinets: bottom at 4.5ft (54"), top at 7ft (84")
          // Total height: cabinet (1.25ft/15") + microwave (1.25ft/15") = 2.5ft (30") = wall cabinet height
          //
          // Wall cabinet: bottom 4.5ft, top 7ft, center at 5.75ft
          // This unit: microwave bottom at 4.5ft, cabinet top at 7ft
          //   - Microwave: 4.5ft to 5.75ft
          //   - Cabinet: 5.75ft to 7ft (with small gap)

          const mwHeightIn3D = 1.25; // Microwave portion height (15 inches)
          const wallCabinetBottom = 4.5; // 54 inches from floor (aligns with wall cabs)

          // Cabinet center position: microwave bottom + microwave height + gap + cabinet height/2
          return wallCabinetBottom + mwHeightIn3D + 0.02 + height/2;
        }

        case 'backsplash': {
          // Smart stacking: backsplash sits ON TOP of countertop surface
          const bsLeft = el.x / pixelsPerFoot;
          const bsRight = bsLeft + el.width;
          const bsTop = el.y / pixelsPerFoot;
          const bsBottom = bsTop + el.height;

          // Find countertop beneath this backsplash
          let counterSurfaceHeight = 0;

          elements.forEach(other => {
            if (other.id === el.id) return;
            if (other.type !== 'countertop') return;

            // Calculate other element bounds
            const otherLeft = other.x / pixelsPerFoot;
            const otherRight = otherLeft + other.width;
            const otherTop = other.y / pixelsPerFoot;
            const otherBottom = otherTop + other.height;

            // Check if backsplash is adjacent to or overlapping with countertop
            const overlapX = Math.max(0, Math.min(bsRight, otherRight) - Math.max(bsLeft, otherLeft));
            const adjacentY = Math.abs(bsBottom - otherTop) < 0.5 || Math.abs(bsTop - otherBottom) < 0.5;
            const overlapY = Math.max(0, Math.min(bsBottom, otherBottom) - Math.max(bsTop, otherTop));

            // Consider if there's any horizontal overlap and they're close in Y
            if (overlapX > 0.1 && (overlapY > 0 || adjacentY)) {
              // Calculate countertop's top surface directly (avoid recursive call)
              // Countertop thickness is typically 0.12 ft (1.44 inches)
              const counterThickness = 0.12;
              // Countertop base position is 2.9 ft (on cabinet), or on detected element
              const counterBaseHeight = 2.9; // Standard cabinet height
              const counterSurface = counterBaseHeight + counterThickness;
              if (counterSurface > counterSurfaceHeight) {
                counterSurfaceHeight = counterSurface;
              }
            }
          });

          // Use verticalHeight for actual backsplash height in 3D
          const bsVertHeight = el.verticalHeight || 1.5;

          if (counterSurfaceHeight > 0) {
            // Backsplash sits directly on top of countertop surface
            return counterSurfaceHeight + bsVertHeight / 2;
          }

          // Default: Standard counter surface (2.9 + 0.12 thick counter) + backsplash
          return 3.02 + bsVertHeight / 2;
        }

        case 'range-hood': {
          // Smart stacking: range hood sits above stove/range/cooktop
          const rhLeft = el.x / pixelsPerFoot;
          const rhRight = rhLeft + el.width;
          const rhTop = el.y / pixelsPerFoot;
          const rhBottom = rhTop + el.height;

          // Find stove/range/cooktop beneath this hood
          let applianceTopHeight = 3; // Default: top of stove surface

          elements.forEach(other => {
            if (other.id === el.id) return;

            const stoveTypes = ['stove', 'range', 'cooktop'];
            if (!stoveTypes.includes(other.type)) return;

            const otherLeft = other.x / pixelsPerFoot;
            const otherRight = otherLeft + other.width;
            const otherTop = other.y / pixelsPerFoot;
            const otherBottom = otherTop + other.height;

            // Check for overlap
            const overlapX = Math.max(0, Math.min(rhRight, otherRight) - Math.max(rhLeft, otherLeft));
            const overlapY = Math.max(0, Math.min(rhBottom, otherBottom) - Math.max(rhTop, otherTop));

            if (overlapX > 0.1 && overlapY > 0.1) {
              // Get the top of the appliance
              const appHeight = other.type === 'cooktop' ? 0.1 : 3; // Cooktop is thin, range is tall
              const appTop = other.type === 'cooktop' ? 3.02 + 0.05 : appHeight;
              if (appTop > applianceTopHeight) {
                applianceTopHeight = appTop;
              }
            }
          });

          // Range hood bottom is typically 24-30" above cooktop surface
          // Position hood 2 feet (24") above the cooking surface
          return applianceTopHeight + 2 + height / 2;
        }

        case 'microwave': {
          // Microwave positioned at wall cabinet height
          // Bottom aligns with wall cabinet bottoms at 54" (4.5 feet) from floor
          // This allows room for above-microwave-cabinet above it
          // Standard: wall cabinet bottom = 54", microwave fits below wall cabs
          // Wall cabinet height = 30-36", so tops at 84-90" (7-7.5 feet)
          // Microwave height typically 12-15" (1-1.25 feet)
          // Position bottom at 4.5 feet to align with wall cabinet bottoms

          const wallCabinetBottomHeight = 4.5; // 54 inches from floor (standard)

          // Return center position: bottom at 4.5ft + half the microwave height
          return wallCabinetBottomHeight + height / 2;
        }

        // Windows - use sillHeight property, fall back to construction standard
        case 'window':
        case 'window-large':
        case 'window-bay':
        case 'bay-window':
        case 'picture-window': {
          // sillHeight is the bottom edge from floor (in feet)
          const sillHeight = el.sillHeight !== undefined ? el.sillHeight : getDefaultSillHeight(type);
          return sillHeight + height / 2; // Position center based on sill
        }

        // Doors and archways - sill at floor level
        case 'door':
        case 'double-door':
        case 'sliding-door':
        case 'french-door':
        case 'glass-door':
        case 'entry-archway':
        case 'garage-door': {
          const doorSillHeight = el.sillHeight !== undefined ? el.sillHeight : getDefaultSillHeight(type);
          return doorSillHeight + height / 2;
        }

        case 'wall':
          return height / 2; // Wall sits on floor

        case 'tall-cabinet':
        case 'fridge-cabinet':
          return height / 2; // Tall cabinets and fridge cabinets sit on floor

        // Pony walls / half walls
        case 'pony-wall':
        case 'pony-wall-bar':
        case 'knee-wall':
          return height / 2; // Sits on floor

        // Niches (typically mounted in wall, use height property)
        case 'wall-niche':
        case 'shower-niche': {
          // Shower niches typically at eye level (~4-5ft)
          return el.nicheFloorHeight !== undefined ? el.nicheFloorHeight + height / 2 : 4 + height / 2;
        }
        case 'fireplace-niche':
        case 'tv-niche': {
          // Fireplace/TV at comfortable viewing height
          return el.nicheFloorHeight !== undefined ? el.nicheFloorHeight + height / 2 : 2 + height / 2;
        }

        // Stone surfaces
        case 'wall-cap':
        case 'bar-top': {
          // Position cap at top of wall it sits on
          // If capHeight is not set, try to find a nearby pony wall to match its height
          let capHeight = el.capHeight;
          if (capHeight === undefined) {
            // Look for overlapping pony wall to inherit height from
            const ponyWallTypes = ['pony-wall', 'pony-wall-bar', 'knee-wall'];
            const capCenterX = el.x / pixelsPerFoot + el.width / 2;
            const capCenterY = el.y / pixelsPerFoot + el.height / 2;

            const nearbyWall = elements.find(other => {
              if (!ponyWallTypes.includes(other.type)) return false;
              const wallCenterX = other.x / pixelsPerFoot + other.width / 2;
              const wallCenterY = other.y / pixelsPerFoot + other.height / 2;
              const distX = Math.abs(capCenterX - wallCenterX);
              const distY = Math.abs(capCenterY - wallCenterY);
              // Check if cap overlaps with wall (within 1 foot tolerance)
              return distX < (el.width + other.width) / 2 + 0.5 &&
                     distY < (el.height + other.height) / 2 + 0.5;
            });

            if (nearbyWall) {
              capHeight = nearbyWall.wallHeight || (nearbyWall.type === 'knee-wall' ? 2.5 : 3.5);
            } else {
              // Default to standard pony wall height (3.5 ft = 42 inches)
              capHeight = 3.5;
            }
          }
          return capHeight + height / 2;
        }

        // Work surfaces (countertop alternatives) - positioned at counter height
        case 'surface-stainless':
        case 'surface-solid':
        case 'surface-laminate':
        case 'surface-butcherblock':
        case 'surface-concrete':
          // These sit at standard counter height (on top of base cabinets)
          return 2.9 + height / 2;

        case 'fireplace-hearth':
        case 'threshold':
          return height / 2; // Floor level
        case 'window-sill': {
          // Window sill follows window sillHeight
          const windowSill = el.sillHeight !== undefined ? el.sillHeight : 2;
          return windowSill;
        }
        case 'mantel':
          return 4 + height / 2; // Above fireplace opening
        case 'fireplace-surround':
        case 'niche-surround':
          return 2.5 + height / 2; // Centered around opening

        // ADA grab bars (33-36" from floor per ADA guidelines)
        case 'grab-bar':
          return el.mountHeight !== undefined ? el.mountHeight + height / 2 : 2.875 + height / 2;

        // Structural beams - positioned at ceiling level (bottom of beam touches ceiling)
        case 'steel-beam':
        case 'wood-beam':
        case 'concrete-beam':
        case 'header':
        case 'lvl-beam': {
          // Beams hang from ceiling - use beamElevation if set, otherwise at ceiling
          const ceilingHeight = roomHeight || 8;
          const beamElevation = el.beamElevation !== undefined ? el.beamElevation : ceilingHeight;
          return beamElevation - height / 2; // Bottom of beam at elevation
        }

        // Structural columns - floor to ceiling
        case 'steel-column':
        case 'wood-post':
        case 'concrete-column':
          return height / 2; // Column sits on floor

        // Bathroom elements - floor standing
        case 'toilet':
        case 'bathtub':
        case 'bathtub-freestanding':
        case 'vanity-24':
        case 'vanity-30':
        case 'vanity-36':
        case 'vanity-48':
        case 'vanity-60':
        case 'vanity-72':
        case 'vanity-double-60':
        case 'vanity-double-72':
        case 'vanity-double-84':
        case 'vanity-hishers-96':
        case 'vanity-hishers-108':
        case 'powder-table':
        case 'makeup-vanity':
        case 'pedestal-sink':
        case 'linen-closet':
        case 'linen-tower':
        case 'shower-bench':
          return height / 2; // Floor standing

        case 'towel-warmer':
          return el.mountHeight !== undefined ? el.mountHeight + height / 2 : 3 + height / 2; // Wall mounted ~36" up

        // Laundry elements - floor standing
        case 'washer':
        case 'dryer':
        case 'utility-sink':
        case 'laundry-sink':
        case 'drying-rack':
          return height / 2; // Floor standing

        // Closet elements
        case 'closet-rod':
        case 'tie-rack':
          return el.mountHeight !== undefined ? el.mountHeight + height / 2 : 5.5 + height / 2; // ~66" from floor

        case 'closet-shelf':
          return el.mountHeight !== undefined ? el.mountHeight + height / 2 : 6 + height / 2; // Above rod

        case 'full-mirror':
          return el.mountHeight !== undefined ? el.mountHeight + height / 2 : 3 + height / 2; // Center at ~36" from floor

        case 'drawer-unit':
        case 'closet-drawers':
        case 'shoe-rack':
        case 'closet-island':
        case 'jewelry-cabinet':
        case 'jewelry-drawer':
          return height / 2; // Floor standing

        // Bathroom accessories - wall mounted
        case 'mirror':
          return el.mountHeight !== undefined ? el.mountHeight + height / 2 : 4.5 + height / 2; // ~54" from floor (eye level)

        case 'medicine-cabinet':
          return el.mountHeight !== undefined ? el.mountHeight + height / 2 : 4.5 + height / 2; // ~54" from floor

        case 'towel-bar':
          return el.mountHeight !== undefined ? el.mountHeight + height / 2 : 4 + height / 2; // ~48" from floor

        case 'grab-bar-24':
        case 'grab-bar-36':
        case 'grab-bar-42':
          // ADA grab bars - typically 33-36" from floor for toilet, higher for shower
          return el.mountHeight !== undefined ? el.mountHeight + height / 2 : 2.8 + height / 2; // ~33" from floor

        case 'toilet-paper':
          return el.mountHeight !== undefined ? el.mountHeight + height / 2 : 2.2 + height / 2; // ~26" from floor (seated reach)

        case 'shower-glass':
        case 'shower-door':
          return height / 2; // Floor standing (full height panels)

        // Shower bases (same as shower-pan - floor level)
        case 'shower-base-36':
        case 'shower-base-48':
        case 'shower-base-60':
          return height / 2 + 0.02; // Bottom edge at 0.02ft above floor plane

        // Trim & Molding
        case 'crown-molding': {
          const ceilingH = roomHeight || 8;
          return ceilingH - height / 2; // At ceiling level
        }
        case 'baseboard':
          return height / 2; // At floor level

        case 'chair-rail':
          return 3 + height / 2; // ~36" from floor (standard chair rail height)

        // Bathroom fixtures - floor standing
        case 'toilet-round':
        case 'toilet-wall':
        case 'bidet':
        case 'bathtub-corner':
        case 'bathtub-walk-in':
          return height / 2; // Floor standing

        // Laundry elements - floor standing
        case 'washer-dryer-stack':
        case 'laundry-cabinet':
        case 'laundry-sink':
        case 'ironing-board':
          return height / 2; // Floor standing

        case 'microwave-cabinet':
          // Wall-mounted microwave cabinet - bottom typically at counter height (~3ft)
          return el.mountHeight !== undefined ? el.mountHeight + height / 2 : 3 + height / 2;

        default:
          return height / 2; // Default: bottom on floor
      }
    }

    // ===== LRU TEXTURE CACHE WITH GARBAGE COLLECTION =====
    // Configuration
    const TEXTURE_CACHE_MAX_SIZE = 100; // Maximum textures to keep
    const TEXTURE_CACHE_CLEANUP_SIZE = 20; // Remove this many when full

    // LRU Cache for loaded 3D textures
    const textureCache3D = {};
    const textureCacheOrder = []; // Track access order for LRU
    let textureCacheStats = { hits: 0, misses: 0, evictions: 0 };

    /**
     * Get texture from cache (updates LRU order)
     */
    function getTextureFromCache(url) {
      if (textureCache3D[url]) {
        textureCacheStats.hits++;
        // Move to end of LRU order (most recently used)
        const idx = textureCacheOrder.indexOf(url);
        if (idx > -1) {
          textureCacheOrder.splice(idx, 1);
          textureCacheOrder.push(url);
        }
        return textureCache3D[url];
      }
      textureCacheStats.misses++;
      return null;
    }

    /**
     * Add texture to cache with LRU eviction
     */
    function addTextureToCache(url, texture) {
      // Check if we need to evict old textures
      if (textureCacheOrder.length >= TEXTURE_CACHE_MAX_SIZE) {
        evictOldTextures();
      }

      // Add to cache
      textureCache3D[url] = texture;
      textureCacheOrder.push(url);
    }

    /**
     * Evict least recently used textures
     */
    function evictOldTextures() {
      const toRemove = Math.min(TEXTURE_CACHE_CLEANUP_SIZE, textureCacheOrder.length);

      for (let i = 0; i < toRemove; i++) {
        const url = textureCacheOrder.shift();
        if (url && textureCache3D[url]) {
          // Dispose the texture to free GPU memory
          if (textureCache3D[url].dispose) {
            textureCache3D[url].dispose();
          }
          delete textureCache3D[url];
          textureCacheStats.evictions++;
        }
      }

      console.log(`Texture cache GC: evicted ${toRemove} textures. Stats:`, textureCacheStats);
    }

    /**
     * Clear entire texture cache
     */
    function clearTextureCache() {
      textureCacheOrder.forEach(url => {
        if (textureCache3D[url] && textureCache3D[url].dispose) {
          textureCache3D[url].dispose();
        }
        delete textureCache3D[url];
      });
      textureCacheOrder.length = 0;
      textureCacheStats = { hits: 0, misses: 0, evictions: 0 };
    }

    /**
     * Get cache statistics
     */
    function getTextureCacheStats() {
      return {
        ...textureCacheStats,
        size: textureCacheOrder.length,
        maxSize: TEXTURE_CACHE_MAX_SIZE,
        hitRate: textureCacheStats.hits / (textureCacheStats.hits + textureCacheStats.misses) || 0
      };
    }

    // ===== GEOMETRY POOLING FOR PERFORMANCE =====
    // Reuses geometries for elements with same dimensions
    const geometryPool = new Map();
    let geometryPoolStats = { hits: 0, misses: 0, poolSize: 0 };

    /**
     * Get or create a BoxGeometry from the pool
     * @param {number} width - Box width
     * @param {number} height - Box height
     * @param {number} depth - Box depth
     * @returns {THREE.BoxGeometry} Cached or new geometry
     */
    function getPooledBoxGeometry(width, height, depth) {
      // Round to 2 decimal places for consistent keys
      const w = Math.round(width * 100) / 100;
      const h = Math.round(height * 100) / 100;
      const d = Math.round(depth * 100) / 100;
      const key = `box_${w}_${h}_${d}`;

      if (geometryPool.has(key)) {
        geometryPoolStats.hits++;
        return geometryPool.get(key);
      }

      // Create new geometry and cache it
      const geometry = new THREE.BoxGeometry(w, h, d);
      geometryPool.set(key, geometry);
      geometryPoolStats.misses++;
      geometryPoolStats.poolSize = geometryPool.size;

      return geometry;
    }

    /**
     * Get or create a PlaneGeometry from the pool
     */
    function getPooledPlaneGeometry(width, height) {
      const w = Math.round(width * 100) / 100;
      const h = Math.round(height * 100) / 100;
      const key = `plane_${w}_${h}`;

      if (geometryPool.has(key)) {
        geometryPoolStats.hits++;
        return geometryPool.get(key);
      }

      const geometry = new THREE.PlaneGeometry(w, h);
      geometryPool.set(key, geometry);
      geometryPoolStats.misses++;
      geometryPoolStats.poolSize = geometryPool.size;

      return geometry;
    }

    /**
     * Get geometry pool statistics
     */
    function getGeometryPoolStats() {
      return {
        ...geometryPoolStats,
        hitRate: geometryPoolStats.hits / (geometryPoolStats.hits + geometryPoolStats.misses) || 0
      };
    }

    /**
     * Clear geometry pool (call on cleanup)
     */
    function clearGeometryPool() {
      geometryPool.forEach(geometry => {
        if (geometry.dispose) geometry.dispose();
      });
      geometryPool.clear();
      geometryPoolStats = { hits: 0, misses: 0, poolSize: 0 };
    }

    const textureLoader = new THREE.TextureLoader();
    textureLoader.setCrossOrigin('anonymous');

    // Helper to adjust color brightness (works with numeric colors)
    // Moved to module level for performance - used frequently in 3D rendering
    function adjustColorBrightness(col, amount) {
      const r = Math.max(0, Math.min(255, ((col >> 16) & 0xFF) + amount));
      const g = Math.max(0, Math.min(255, ((col >> 8) & 0xFF) + amount));
      const b = Math.max(0, Math.min(255, (col & 0xFF) + amount));
      return (r << 16) | (g << 8) | b;
    }

    // Cache for 2D-rendered textures
    const texture2DCache = {};

    function render2DElementToTexture(el, canvasWidth = 256, canvasHeight = 256) {
      // Use cached texture if available
      const cacheKey = `${el.id}_${el.type}_${canvasWidth}x${canvasHeight}`;
      if (texture2DCache[cacheKey]) {
        return texture2DCache[cacheKey];
      }

      // Create offscreen canvas
      const canvas = document.createElement('canvas');
      canvas.width = canvasWidth;
      canvas.height = canvasHeight;
      const ctx = canvas.getContext('2d');

      // Set up drawing context
      ctx.fillStyle = el.color || '#808080';
      ctx.strokeStyle = '#333';
      ctx.lineWidth = 2;

      const x = 0;
      const y = 0;
      const w = canvasWidth;
      const h = canvasHeight;
      const padding = Math.min(w, h) * 0.08;

      // Fill background
      ctx.fillRect(x, y, w, h);

      // Draw element-specific details based on type
      switch (el.type) {
        case 'sink':
        case 'sink-double':
        case 'sink-farmhouse': {
          const isDouble = el.type === 'sink-double';
          const isFarmhouse = el.type === 'sink-farmhouse';
          const basinPadding = Math.min(w, h) * 0.12;

          // Background - sink body color
          ctx.fillStyle = isFarmhouse ? '#F5F5DC' : '#C0C0C0';
          ctx.fillRect(x, y, w, h);

          // Outer rim
          ctx.strokeStyle = isFarmhouse ? 'rgba(200,180,140,0.9)' : 'rgba(180,180,180,0.9)';
          ctx.lineWidth = isFarmhouse ? 6 : 3;
          ctx.strokeRect(x + basinPadding/2, y + basinPadding/2, w - basinPadding, h - basinPadding);

          if (isDouble) {
            // Double basin
            const basinW = (w - basinPadding * 2 - 8) / 2;
            // Left basin
            ctx.fillStyle = 'rgba(50,50,50,0.5)';
            ctx.fillRect(x + basinPadding, y + basinPadding, basinW, h - basinPadding * 2);
            // Right basin
            ctx.fillRect(x + basinPadding + basinW + 8, y + basinPadding, basinW, h - basinPadding * 2);
            // Divider
            ctx.fillStyle = 'rgba(180,180,180,0.7)';
            ctx.fillRect(x + w/2 - 4, y + basinPadding, 8, h - basinPadding * 2);
            // Drains
            ctx.fillStyle = 'rgba(40,40,40,0.8)';
            ctx.beginPath();
            ctx.arc(x + basinPadding + basinW/2, y + h/2, Math.min(w, h) * 0.06, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x + w - basinPadding - basinW/2, y + h/2, Math.min(w, h) * 0.06, 0, Math.PI * 2);
            ctx.fill();
          } else {
            // Single basin
            ctx.fillStyle = isFarmhouse ? 'rgba(245,245,220,0.6)' : 'rgba(50,50,50,0.5)';
            ctx.fillRect(x + basinPadding, y + basinPadding, w - basinPadding * 2, h - basinPadding * 2);
            // Inner basin shadow
            ctx.fillStyle = isFarmhouse ? 'rgba(200,180,140,0.35)' : 'rgba(30,30,30,0.35)';
            ctx.fillRect(x + basinPadding + 6, y + basinPadding + 6, w - basinPadding * 2 - 12, h - basinPadding * 2 - 12);
            // Drain
            ctx.fillStyle = 'rgba(40,40,40,0.8)';
            ctx.beginPath();
            ctx.arc(x + w/2, y + h/2 + 8, Math.min(w, h) * 0.07, 0, Math.PI * 2);
            ctx.fill();
          }

          // Faucet (centered at back)
          ctx.fillStyle = 'rgba(210,210,210,0.95)';
          ctx.fillRect(x + w/2 - 12, y + basinPadding/2 - 8, 24, 12);
          // Faucet spout
          ctx.beginPath();
          ctx.arc(x + w/2, y + basinPadding/2 - 8, 12, Math.PI, 0);
          ctx.fill();
          // Handles
          ctx.fillStyle = 'rgba(190,190,190,0.9)';
          ctx.beginPath();
          ctx.arc(x + w/2 - 30, y + basinPadding/2, 7, 0, Math.PI * 2);
          ctx.fill();
          ctx.beginPath();
          ctx.arc(x + w/2 + 30, y + basinPadding/2, 7, 0, Math.PI * 2);
          ctx.fill();
          break;
        }

        case 'stove':
        case 'range':
        case 'cooktop': {
          // Background - stove surface
          ctx.fillStyle = '#2a2a2a';
          ctx.fillRect(x, y, w, h);

          // Draw stove burners
          ctx.strokeStyle = 'rgba(60,60,60,0.9)';
          ctx.lineWidth = 3;
          const burnerRadius = Math.min(w, h) * 0.16;
          const positions = [
            [x + w * 0.3, y + h * 0.38],
            [x + w * 0.7, y + h * 0.38],
            [x + w * 0.3, y + h * 0.72],
            [x + w * 0.7, y + h * 0.72]
          ];
          positions.forEach(([bx, by]) => {
            // Outer ring
            ctx.beginPath();
            ctx.arc(bx, by, burnerRadius, 0, Math.PI * 2);
            ctx.stroke();
            // Inner ring
            ctx.beginPath();
            ctx.arc(bx, by, burnerRadius * 0.6, 0, Math.PI * 2);
            ctx.stroke();
            // Grate lines
            ctx.beginPath();
            ctx.moveTo(bx - burnerRadius, by);
            ctx.lineTo(bx + burnerRadius, by);
            ctx.moveTo(bx, by - burnerRadius);
            ctx.lineTo(bx, by + burnerRadius);
            ctx.stroke();
          });
          // Control panel area
          ctx.fillStyle = 'rgba(50,50,50,0.7)';
          ctx.fillRect(x + padding, y + padding, w - padding * 2, h * 0.12);
          break;
        }

        case 'refrigerator': {
          // Background
          ctx.fillStyle = '#D0D0D0';
          ctx.fillRect(x, y, w, h);

          ctx.strokeStyle = 'rgba(150,150,150,0.6)';
          ctx.lineWidth = 3;
          const fridgeMid = y + h * 0.65;
          // Upper section (freezer)
          ctx.strokeRect(x + padding, y + padding, w - padding * 2, fridgeMid - y - padding * 1.5);
          // Lower section (fridge)
          ctx.strokeRect(x + padding, fridgeMid, w - padding * 2, y + h - fridgeMid - padding);
          // Handles
          ctx.fillStyle = 'rgba(200,200,200,0.7)';
          ctx.fillRect(x + w - padding - 8, y + (fridgeMid - y) / 2 - 15, 4, 30);
          ctx.fillRect(x + w - padding - 8, fridgeMid + (y + h - fridgeMid) / 2 - 18, 4, 36);
          break;
        }

        case 'dishwasher': {
          ctx.fillStyle = '#E0E0E0';
          ctx.fillRect(x, y, w, h);
          ctx.strokeStyle = 'rgba(150,150,150,0.6)';
          ctx.lineWidth = 2;
          ctx.strokeRect(x + padding, y + padding, w - padding * 2, h - padding * 2);
          // Handle
          ctx.fillStyle = 'rgba(180,180,180,0.8)';
          ctx.fillRect(x + w * 0.2, y + padding + 5, w * 0.6, 6);
          break;
        }

        default:
          // Default: just fill with color
          ctx.fillStyle = el.color || '#808080';
          ctx.fillRect(x, y, w, h);
      }

      // Create Three.js texture from canvas
      const texture = new THREE.CanvasTexture(canvas);
      texture.wrapS = THREE.ClampToEdgeWrapping;
      texture.wrapT = THREE.ClampToEdgeWrapping;
      texture.colorSpace = THREE.SRGBColorSpace;
      texture.needsUpdate = true;

      // Cache the texture
      texture2DCache[cacheKey] = texture;

      return texture;
    }

    /**
     * Create a 3D element using 2D texture rendering (simpler, cleaner look)
     * @param {Object} el - The element to create
     * @param {number} w - Width in feet
     * @param {number} h - 3D height in feet
     * @param {number} d - Depth in feet
     * @returns {THREE.Group} The 3D group containing the element
     */
    function create3DElementWith2DTexture(el, w, h, d) {
      const group = new THREE.Group();

      // Render 2D appearance to texture (higher res for quality)
      const textureSize = 512;
      const texture = render2DElementToTexture(el, textureSize, textureSize);

      // Get base color for sides
      let sideColor = 0x808080;
      const typeColors = {
        'sink': 0xC0C0C0,
        'sink-double': 0xC0C0C0,
        'sink-farmhouse': 0xF5F5DC,
        'stove': 0x2a2a2a,
        'range': 0x2a2a2a,
        'cooktop': 0x2a2a2a,
        'refrigerator': 0xD0D0D0,
        'dishwasher': 0xE0E0E0
      };
      sideColor = typeColors[el.type] || sideColor;

      // Create material with the 2D texture for top face
      const topMaterial = new THREE.MeshStandardMaterial({
        map: texture,
        roughness: 0.5,
        metalness: 0.15
      });

      // Create material for sides (solid color matching the element type)
      const sideMaterial = new THREE.MeshStandardMaterial({
        color: sideColor,
        roughness: 0.6,
        metalness: 0.1
      });

      // Materials array: [right, left, top, bottom, front, back]
      // For a countertop-level element, the TOP (index 2) shows the 2D texture
      const materials = [
        sideMaterial,  // right (+X)
        sideMaterial,  // left (-X)
        topMaterial,   // top (+Y) - this shows the 2D appearance
        sideMaterial,  // bottom (-Y)
        sideMaterial,  // front (+Z)
        sideMaterial   // back (-Z)
      ];

      // Create the main box geometry
      const boxGeo = new THREE.BoxGeometry(w, h, d);

      // Create mesh with multi-material
      const mesh = new THREE.Mesh(boxGeo, materials);
      mesh.castShadow = true;
      mesh.receiveShadow = true;
      group.add(mesh);

      return group;
    }

    // Preload textures for elements that have them
    function preload3DTextures() {
      const textureUrls = new Set();
      elements.forEach(el => {
        if (el.texture) textureUrls.add(el.texture);
        if (el.storeProduct?.image) textureUrls.add(el.storeProduct.image);
      });

      textureUrls.forEach(url => {
        if (!getTextureFromCache(url)) {
          console.log('Preloading texture:', url.substring(0, 50) + '...');
          textureLoader.load(url, (texture) => {
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.colorSpace = THREE.SRGBColorSpace;
            addTextureToCache(url, texture);
            console.log('Preloaded texture successfully:', url.substring(0, 50) + '...');
          }, undefined, (err) => {
            console.warn('Failed to preload texture:', url, err);
          });
        }
      });
    }

    function create3DElement(el) {
      const w = el.width;
      const d = el.height; // In 2D, height is depth in 3D
      const h = get3DHeight(el);

      // Parse color
      let color = el.color || '#808080';
      if (typeof color === 'string') {
        if (color.startsWith('#')) {
          color = parseInt(color.replace('#', ''), 16);
        } else if (color.startsWith('rgb')) {
          const match = color.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
          if (match) {
            color = (parseInt(match[1]) << 16) | (parseInt(match[2]) << 8) | parseInt(match[3]);
          } else {
            color = 0x808080;
          }
        } else {
          color = parseInt(color, 16) || 0x808080;
        }
      }

      const group = new THREE.Group();

      // Helper to create high-quality metallic hardware materials (handles, knobs, faucets)
      // Uses proper environment mapping for realistic reflections
      function createMetalMaterial(finish = 'brushed-nickel') {
        const metalFinishes = {
          'chrome': { color: 0xE8E8E8, roughness: 0.05, metalness: 0.98, envIntensity: 1.8 },
          'polished-chrome': { color: 0xF5F5F5, roughness: 0.02, metalness: 1.0, envIntensity: 2.0 },
          'brushed-nickel': { color: 0xC0C0C0, roughness: 0.2, metalness: 0.9, envIntensity: 1.2 },
          'satin-nickel': { color: 0xB8B8B8, roughness: 0.25, metalness: 0.85, envIntensity: 1.0 },
          'stainless': { color: 0xD0D0D0, roughness: 0.15, metalness: 0.92, envIntensity: 1.4 },
          'matte-black': { color: 0x2A2A2A, roughness: 0.4, metalness: 0.7, envIntensity: 0.5 },
          'oil-rubbed-bronze': { color: 0x3D2B1F, roughness: 0.35, metalness: 0.6, envIntensity: 0.6 },
          'antique-brass': { color: 0xB5A642, roughness: 0.3, metalness: 0.75, envIntensity: 0.8 },
          'polished-brass': { color: 0xD4AF37, roughness: 0.1, metalness: 0.9, envIntensity: 1.5 },
          'gold': { color: 0xFFD700, roughness: 0.08, metalness: 0.95, envIntensity: 1.6 },
          'copper': { color: 0xB87333, roughness: 0.2, metalness: 0.85, envIntensity: 1.2 }
        };

        const config = metalFinishes[finish] || metalFinishes['brushed-nickel'];

        const material = new THREE.MeshStandardMaterial({
          color: config.color,
          roughness: config.roughness,
          metalness: config.metalness,
          envMap: window.roomEnvMap || null,
          envMapIntensity: config.envIntensity
        });

        return material;
      }

      // Helper to create realistic edge profile geometry for countertops
      function createEdgeProfile(width, thickness, profile = 'eased') {
        const profiles = {
          'eased': { bevel: 0.02, rounded: true },
          'bullnose': { bevel: thickness / 2, rounded: true },
          'half-bullnose': { bevel: thickness / 3, rounded: true },
          'ogee': { bevel: 0.04, curved: true },
          'bevel': { bevel: 0.03, angled: true },
          'dupont': { bevel: 0.025, curved: true },
          'waterfall': { bevel: 0, rounded: false }, // Perfect 90 corner - NO bevel for waterfall
          'square': { bevel: 0, rounded: false }
        };

        const p = profiles[profile] || profiles['eased'];
        const shape = new THREE.Shape();

        // Create edge profile shape
        if (p.rounded && p.bevel > 0) {
          // Rounded edge (bullnose, eased)
          shape.moveTo(0, 0);
          shape.lineTo(width, 0);
          shape.lineTo(width, thickness - p.bevel);
          shape.quadraticCurveTo(width, thickness, width - p.bevel, thickness);
          shape.lineTo(p.bevel, thickness);
          shape.quadraticCurveTo(0, thickness, 0, thickness - p.bevel);
          shape.lineTo(0, 0);
        } else if (p.angled && p.bevel > 0) {
          // Beveled edge (chamfer)
          shape.moveTo(0, p.bevel);
          shape.lineTo(p.bevel, 0);
          shape.lineTo(width - p.bevel, 0);
          shape.lineTo(width, p.bevel);
          shape.lineTo(width, thickness);
          shape.lineTo(0, thickness);
          shape.lineTo(0, p.bevel);
        } else {
          // Square edge
          shape.moveTo(0, 0);
          shape.lineTo(width, 0);
          shape.lineTo(width, thickness);
          shape.lineTo(0, thickness);
          shape.lineTo(0, 0);
        }

        return shape;
      }

      // Load and apply texture to countertop material with enhanced quality settings
      function loadCountertopTexture(material, textureUrl, options, hdMode = false) {
        // Resolve relative URLs to absolute
        let fullUrl = textureUrl;
        if (textureUrl.startsWith('/') && !textureUrl.startsWith('//')) {
          fullUrl = window.location.origin + textureUrl;
        } else if (!textureUrl.startsWith('http') && !textureUrl.startsWith('data:')) {
          fullUrl = window.location.origin + '/' + textureUrl;
        }

        // Standard granite/quartz slab: 120" x 60" = 10ft x 5ft
        const slabWidthFt = 10;
        const slabDepthFt = 5;

        // Calculate texture repeat based on countertop dimensions
        let repeatX = 1, repeatY = 1;
        if (options.width && options.depth) {
          repeatX = options.width / slabWidthFt;
          repeatY = options.depth / slabDepthFt;
          repeatX = Math.max(0.3, repeatX);
          repeatY = Math.max(0.3, repeatY);
        }

        // Check texture cache (uses LRU cache)
        const cachedTexture = getTextureFromCache(fullUrl) || getTextureFromCache(textureUrl);

        const applyTexture = (texture) => {
          texture.wrapS = THREE.RepeatWrapping;
          texture.wrapT = THREE.RepeatWrapping;
          texture.repeat.set(repeatX, repeatY);
          texture.colorSpace = THREE.SRGBColorSpace; // Updated for Three.js r152+
          // Maximum anisotropy for sharp textures at viewing angles
          texture.anisotropy = renderer ? renderer.capabilities.getMaxAnisotropy() : 16;
          texture.minFilter = THREE.LinearMipmapLinearFilter;
          texture.magFilter = THREE.LinearFilter;
          texture.generateMipmaps = true;

          material.map = texture;
          material.color.setHex(0xFFFFFF); // Pure white base for accurate texture colors

          // Normal map from texture for realistic surface depth
          // Use bumpMap instead of normalMap to avoid shader issues
          if (options.enableBumpMap !== false) {
            material.bumpMap = texture;
            material.bumpScale = 0.02; // Subtle depth effect
          }

          // In HD mode, also add roughness variation
          if (hdMode && material.roughnessMap !== undefined) {
            material.roughnessMap = texture;
            material.roughness = Math.max(0.05, material.roughness);
          }

          material.needsUpdate = true;

          // Re-render will happen in animation loop, don't call directly here
          // to avoid WebGL context issues
        };

        if (cachedTexture) {
          const clonedTexture = cachedTexture.clone();
          clonedTexture.needsUpdate = true;
          applyTexture(clonedTexture);
        } else {
          textureLoader.load(fullUrl, (texture) => {
            // Cache texture using LRU cache
            addTextureToCache(fullUrl, texture);
            if (textureUrl !== fullUrl) {
              addTextureToCache(textureUrl, texture);
            }
            applyTexture(texture);
          },
          undefined,
          (err) => {
            console.warn('Countertop texture load failed:', textureUrl);
            material.color.setHex(options.baseColor || 0x808080);
            material.needsUpdate = true;
          });
        }
      }

      // Helper to create material with optional texture
      function createTexturedMaterial(baseColor, textureUrl, options = {}) {
        // Material settings optimized for accurate color reproduction
        // Uses MeshPhysicalMaterial for countertops (clearcoat, sheen) for realistic stone

        // Determine material type for optimal settings
        const isStone = options.isStone || options.materialType === 'stone';
        const isPolished = options.finish === 'polished' || options.roughness < 0.3;
        const isCountertop = options.isCountertop || false;
        const hdMode = window.hdRenderMode || false; // High-definition mode toggle

        // Detect if this is a light/white colored surface for enhanced definition
        const colorHex = typeof baseColor === 'number' ? baseColor : parseInt(baseColor.replace('#', ''), 16);
        const r = (colorHex >> 16) & 255;
        const g = (colorHex >> 8) & 255;
        const b = colorHex & 255;
        const brightness = (r + g + b) / 3;
        const isLightColored = brightness > 180;
        const isDarkColored = brightness < 80;

        // Finish-specific settings for realistic stone appearance
        const finishSettings = {
          polished: { roughness: 0.08, clearcoat: 0.2, clearcoatRoughness: 0.2, sheen: 0.3 },
          honed: { roughness: 0.45, clearcoat: 0.1, clearcoatRoughness: 0.6, sheen: 0.1 },
          leathered: { roughness: 0.7, clearcoat: 0.05, clearcoatRoughness: 0.8, sheen: 0.5 },
          brushed: { roughness: 0.55, clearcoat: 0.08, clearcoatRoughness: 0.7, sheen: 0.2 },
          flamed: { roughness: 0.8, clearcoat: 0, clearcoatRoughness: 1, sheen: 0 },
          natural: { roughness: 0.6, clearcoat: 0.05, clearcoatRoughness: 0.9, sheen: 0.1 },
          matte: { roughness: 0.5, clearcoat: 0.02, clearcoatRoughness: 0.9, sheen: 0.05 }
        };

        const finish = options.finish || 'polished';
        const settings = finishSettings[finish] || finishSettings.polished;

        // Adjust for light/dark colors
        let adjustedRoughness = settings.roughness;
        if (isLightColored) adjustedRoughness = Math.min(settings.roughness + 0.05, 0.5);
        if (isDarkColored) adjustedRoughness = Math.max(settings.roughness - 0.02, 0.05);

        // Use MeshPhysicalMaterial for countertops - supports clearcoat for sealed stone look
        if (isCountertop) {
          try {
            const physicalMatOptions = {
              color: textureUrl ? 0xFFFFFF : baseColor,
              roughness: options.roughness !== undefined ? options.roughness : adjustedRoughness,
              metalness: 0.0, // Stone is not metallic
              clearcoat: settings.clearcoat,
              clearcoatRoughness: settings.clearcoatRoughness,
              side: options.side || THREE.FrontSide,
              flatShading: false
            };

            if (options.transparent) physicalMatOptions.transparent = options.transparent;
            if (options.opacity !== undefined) physicalMatOptions.opacity = options.opacity;

            const material = new THREE.MeshPhysicalMaterial(physicalMatOptions);

          // Environment map for reflections
          if (window.roomEnvMap) {
            material.envMap = window.roomEnvMap;
            // Adjust reflection based on finish and color
            if (finish === 'polished') {
              material.envMapIntensity = isLightColored ? 0.35 : 0.55;
            } else if (finish === 'honed') {
              material.envMapIntensity = 0.15;
            } else if (finish === 'leathered') {
              material.envMapIntensity = 0.08;
            } else {
              material.envMapIntensity = 0.25;
            }
          }

          // Texture loading for countertops
          if (textureUrl) {
            loadCountertopTexture(material, textureUrl, options, hdMode);
          }

          return material;
          } catch (physicalMatError) {
            console.warn('MeshPhysicalMaterial failed, falling back to standard:', physicalMatError);
            // Fall through to standard material below
          }
        }

        // Standard material for non-countertop elements (also used as fallback)
        // Apply finish-based roughness if a finish is specified and no explicit roughness given
        const finishRoughness = (options.finish && options.roughness === undefined) ? adjustedRoughness : undefined;
        const matOptions = {
          color: textureUrl ? 0xFFFFFF : baseColor,
          roughness: options.roughness !== undefined ? options.roughness : (finishRoughness !== undefined ? finishRoughness : 0.45),
          metalness: options.metalness !== undefined ? options.metalness : 0.02,
          side: options.side || THREE.FrontSide,
          flatShading: false
        };

        if (options.transparent) matOptions.transparent = options.transparent;
        if (options.opacity !== undefined) matOptions.opacity = options.opacity;

        const material = new THREE.MeshStandardMaterial(matOptions);

        // Apply environment reflection based on finish
        if (window.roomEnvMap) {
          if (options.finish) {
            material.envMap = window.roomEnvMap;
            material.envMapIntensity = finish === 'polished' ? 0.35 : (finish === 'honed' ? 0.12 : 0.08);
          } else if (isPolished) {
            material.envMap = window.roomEnvMap;
            material.envMapIntensity = 0.35;
          }
        }

        // Apply environment map for metallic surfaces
        if (window.roomEnvMap && matOptions.metalness > 0.3) {
          material.envMap = window.roomEnvMap;
          material.envMapIntensity = Math.min(0.8, matOptions.metalness * 1.0);
        }

        // Load texture if available
        if (textureUrl) {
          // Resolve relative URLs to absolute
          let fullUrl = textureUrl;
          if (textureUrl.startsWith('/') && !textureUrl.startsWith('//')) {
            fullUrl = window.location.origin + textureUrl;
          } else if (!textureUrl.startsWith('http') && !textureUrl.startsWith('data:')) {
            fullUrl = window.location.origin + '/' + textureUrl;
          }

          // Get texture dimensions for proper scaling (stone slabs are typically ~10ft x 5ft)
          // Standard granite/quartz slab: 120" x 60" = 10ft x 5ft
          const slabWidthFt = 10;
          const slabDepthFt = 5;

          // Calculate texture repeat based on countertop dimensions
          let repeatX = 1, repeatY = 1;
          if (options.width && options.depth && isCountertop) {
            // Scale texture to realistic stone pattern size
            repeatX = options.width / slabWidthFt;
            repeatY = options.depth / slabDepthFt;
            // Ensure minimum repeat for small surfaces (avoid stretched look)
            repeatX = Math.max(0.3, repeatX);
            repeatY = Math.max(0.3, repeatY);
          }

          // Check LRU cache with both URL variants
          const cachedTexture = getTextureFromCache(fullUrl) || getTextureFromCache(textureUrl);

          if (cachedTexture) {
            material.map = cachedTexture.clone();
            material.map.wrapS = THREE.RepeatWrapping;
            material.map.wrapT = THREE.RepeatWrapping;
            material.map.repeat.set(repeatX, repeatY);
            material.map.needsUpdate = true;
            material.color.setHex(0xFFFFFF);
            material.needsUpdate = true;

            // Generate bump map from texture for depth perception
            if (isCountertop && options.enableBumpMap !== false) {
              material.bumpMap = material.map;
              material.bumpScale = 0.015; // Subtle depth for stone grain
            }
          } else {
            // Load texture with optimized settings for maximum quality
            textureLoader.load(fullUrl, (texture) => {
              texture.wrapS = THREE.RepeatWrapping;
              texture.wrapT = THREE.RepeatWrapping;
              texture.repeat.set(repeatX, repeatY);
              texture.colorSpace = THREE.SRGBColorSpace;
              // Maximum anisotropy for sharpest textures at angles
              texture.anisotropy = renderer ? renderer.capabilities.getMaxAnisotropy() : 16;
              // Use trilinear filtering for best quality
              texture.minFilter = THREE.LinearMipmapLinearFilter;
              texture.magFilter = THREE.LinearFilter;
              texture.generateMipmaps = true;

              // Cache using LRU cache
              addTextureToCache(fullUrl, texture);
              if (textureUrl !== fullUrl) {
                addTextureToCache(textureUrl, texture);
              }

              material.map = texture;
              material.color.setHex(0xFFFFFF);

              // Generate bump map from texture for depth perception on countertops
              if (isCountertop && options.enableBumpMap !== false) {
                material.bumpMap = texture;
                material.bumpScale = 0.015; // Subtle depth for stone grain
              }

              material.needsUpdate = true;

              // Re-render to show texture
              if (renderer && scene && camera) {
                renderer.render(scene, camera);
              }
            },
            undefined,
            (err) => {
              console.warn('Texture load failed:', textureUrl);
              // Keep the base color as fallback
              material.color.setHex(baseColor || 0x808080);
              material.needsUpdate = true;
              // Show subtle toast for texture loading issues
              if (typeof showToast === 'function') {
                showToast('Some textures may not display correctly', 'warning');
              }
            });
          }
        }

        return material;
      }

      // Get texture URL from element - check multiple sources
      let textureUrl = null;
      if (el.texture) {
        textureUrl = el.texture;
      } else if (el.textureImg && el.textureImg.src) {
        textureUrl = el.textureImg.src;
      } else if (el.storeProduct && el.storeProduct.image) {
        textureUrl = el.storeProduct.image;
      } else if (el.materialId && el.materialName) {
        // Try to find from store products
        const product = storeProducts.find(p => p.slug === el.materialId);
        if (product && product.primaryImage) {
          textureUrl = product.primaryImage;
          el.texture = textureUrl; // Cache for next time
        }
      } else if (elementTextures && elementTextures[el.type]) {
        textureUrl = elementTextures[el.type];
      }

      // Log texture status for debugging
      if (textureUrl) {
        console.log(`Element ${el.type} (${el.label || 'unnamed'}) has texture:`, textureUrl.substring(0, 60) + '...');
      }

      // === WOOD GRAIN TEXTURE GENERATOR ===
      // Creates procedural wood grain texture for cabinet materials
      // grainType: 'oak', 'walnut', 'cherry', 'maple', 'hickory', 'flat' (no grain)
      function createWoodGrainTexture(baseColor, grainIntensity = 0.15, grainType = 'oak') {
        const canvas = document.createElement('canvas');
        canvas.width = 1024;  // Higher resolution
        canvas.height = 1024;
        const ctx = canvas.getContext('2d');
        const size = 1024;

        // Parse base color to RGB
        const tempColor = new THREE.Color(baseColor);
        const r = Math.floor(tempColor.r * 255);
        const g = Math.floor(tempColor.g * 255);
        const b = Math.floor(tempColor.b * 255);

        // Fill with base color
        ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
        ctx.fillRect(0, 0, size, size);

        // FLAT/NO GRAIN - for painted finishes
        if (grainType === 'flat' || grainType === 'none' || grainType === 'painted') {
          // Just add subtle surface texture for painted look
          ctx.globalAlpha = 0.015;
          for (let i = 0; i < 3000; i++) {
            const nx = Math.random() * size;
            const ny = Math.random() * size;
            const shade = Math.random() > 0.5 ? 255 : 0;
            ctx.fillStyle = `rgb(${shade}, ${shade}, ${shade})`;
            ctx.fillRect(nx, ny, 1, 1);
          }
          // Add very subtle gradient for depth
          ctx.globalAlpha = 0.02;
          const paintGrad = ctx.createLinearGradient(0, 0, size, size);
          paintGrad.addColorStop(0, `rgba(255, 255, 255, 1)`);
          paintGrad.addColorStop(0.5, 'transparent');
          paintGrad.addColorStop(1, `rgba(0, 0, 0, 1)`);
          ctx.fillStyle = paintGrad;
          ctx.fillRect(0, 0, size, size);
          ctx.globalAlpha = 1;

          const texture = new THREE.CanvasTexture(canvas);
          texture.wrapS = THREE.RepeatWrapping;
          texture.wrapT = THREE.RepeatWrapping;
          texture.repeat.set(1, 1);
          texture.anisotropy = 16;
          texture.colorSpace = THREE.SRGBColorSpace;
          texture.needsUpdate = true;
          return texture;
        }

        // Grain type configurations
        const grainConfigs = {
          oak: {
            lineCount: 100,
            lineThicknessMin: 1.0,
            lineThicknessMax: 3.5,
            waveFreqMin: 0.006,
            waveFreqMax: 0.012,
            waveAmpMin: 3,
            waveAmpMax: 10,
            secondaryLines: 50,
            knots: 2,
            colorVariation: 35,
            spacing: 'medium'
          },
          walnut: {
            lineCount: 150,
            lineThicknessMin: 0.5,
            lineThicknessMax: 2.0,
            waveFreqMin: 0.002,
            waveFreqMax: 0.005,
            waveAmpMin: 1,
            waveAmpMax: 3,
            secondaryLines: 80,
            knots: 1,
            colorVariation: 45,
            spacing: 'tight'
          },
          cherry: {
            lineCount: 80,
            lineThicknessMin: 0.3,
            lineThicknessMax: 1.5,
            waveFreqMin: 0.004,
            waveFreqMax: 0.008,
            waveAmpMin: 1,
            waveAmpMax: 4,
            secondaryLines: 40,
            knots: 0,
            colorVariation: 25,
            spacing: 'fine'
          },
          maple: {
            lineCount: 60,
            lineThicknessMin: 0.2,
            lineThicknessMax: 0.8,
            waveFreqMin: 0.003,
            waveFreqMax: 0.006,
            waveAmpMin: 0.5,
            waveAmpMax: 2,
            secondaryLines: 30,
            knots: 0,
            colorVariation: 15,
            spacing: 'very-fine'
          },
          hickory: {
            lineCount: 120,
            lineThicknessMin: 1.5,
            lineThicknessMax: 4.5,
            waveFreqMin: 0.008,
            waveFreqMax: 0.018,
            waveAmpMin: 5,
            waveAmpMax: 15,
            secondaryLines: 70,
            knots: 4,
            colorVariation: 55,
            spacing: 'dramatic'
          }
        };

        const config = grainConfigs[grainType] || grainConfigs.oak;

        // Add subtle base noise for texture
        ctx.globalAlpha = 0.03;
        for (let i = 0; i < 5000; i++) {
          const nx = Math.random() * size;
          const ny = Math.random() * size;
          const shade = Math.random() > 0.5 ? 255 : 0;
          ctx.fillStyle = `rgb(${shade}, ${shade}, ${shade})`;
          ctx.fillRect(nx, ny, 1, 1);
        }

        // Add primary wood grain lines (horizontal)
        ctx.globalAlpha = grainIntensity;
        for (let i = 0; i < config.lineCount; i++) {
          const y = (i / config.lineCount) * size + (Math.random() - 0.5) * 20;
          const thickness = config.lineThicknessMin + Math.random() * (config.lineThicknessMax - config.lineThicknessMin);
          const variation = (Math.random() - 0.5) * config.colorVariation;

          // Grain color - varied between lighter and darker
          const lightness = Math.random() > 0.6 ? 1 : -1;
          const grainR = Math.max(0, Math.min(255, r + (lightness * 15) + variation));
          const grainG = Math.max(0, Math.min(255, g + (lightness * 12) + variation));
          const grainB = Math.max(0, Math.min(255, b + (lightness * 8) + variation));

          ctx.strokeStyle = `rgb(${grainR}, ${grainG}, ${grainB})`;
          ctx.lineWidth = thickness;
          ctx.beginPath();

          // Organic wavy grain line with more natural curvature
          ctx.moveTo(0, y);
          const waveFreq = config.waveFreqMin + Math.random() * (config.waveFreqMax - config.waveFreqMin);
          const waveAmp = config.waveAmpMin + Math.random() * (config.waveAmpMax - config.waveAmpMin);

          // Different wave patterns per grain type
          for (let x = 0; x < size; x += 8) {
            let waveY;
            if (grainType === 'walnut') {
              // Walnut: straighter, tighter lines
              waveY = y + Math.sin(x * waveFreq + i * 0.3) * waveAmp * 0.5;
            } else if (grainType === 'hickory') {
              // Hickory: dramatic, irregular waves
              waveY = y + Math.sin(x * waveFreq + i * 0.7) * waveAmp +
                      Math.sin(x * 0.005 + i) * 5 +
                      (Math.random() - 0.5) * 3;
            } else if (grainType === 'cherry') {
              // Cherry: subtle, smooth waves
              waveY = y + Math.sin(x * waveFreq + i * 0.4) * waveAmp * 0.7;
            } else if (grainType === 'maple') {
              // Maple: very subtle, almost straight
              waveY = y + Math.sin(x * waveFreq + i * 0.2) * waveAmp * 0.3;
            } else {
              // Oak: classic wavy grain
              waveY = y + Math.sin(x * waveFreq + i * 0.5) * waveAmp + Math.sin(x * 0.003) * 3;
            }
            ctx.lineTo(x, waveY);
          }
          ctx.stroke();
        }

        // Add secondary finer grain lines
        ctx.globalAlpha = grainIntensity * 0.4;
        for (let i = 0; i < config.secondaryLines; i++) {
          const y = Math.random() * size;
          ctx.strokeStyle = `rgba(${Math.max(0, r - 30)}, ${Math.max(0, g - 25)}, ${Math.max(0, b - 20)}, 0.5)`;
          ctx.lineWidth = 0.5;
          ctx.beginPath();
          ctx.moveTo(0, y);
          for (let x = 0; x < size; x += 15) {
            const waveY = y + Math.sin(x * 0.015 + i) * 2;
            ctx.lineTo(x, waveY);
          }
          ctx.stroke();
        }

        // Add knots based on grain type
        if (config.knots > 0) {
          ctx.globalAlpha = grainIntensity * 0.6;
          for (let i = 0; i < config.knots; i++) {
            const kx = 100 + Math.random() * (size - 200);
            const ky = 100 + Math.random() * (size - 200);
            const kr = (grainType === 'hickory' ? 18 : 12) + Math.random() * 20;

            // Concentric rings for knot
            for (let ring = 0; ring < 5; ring++) {
              const ringR = kr - ring * 3;
              if (ringR < 2) break;
              ctx.strokeStyle = `rgba(${Math.max(0, r - 45 + ring * 5)}, ${Math.max(0, g - 40 + ring * 5)}, ${Math.max(0, b - 35 + ring * 5)}, ${0.4 - ring * 0.06})`;
              ctx.lineWidth = 1.5;
              ctx.beginPath();
              ctx.arc(kx, ky, ringR, 0, Math.PI * 2);
              ctx.stroke();
            }

            // Dark center
            const gradient = ctx.createRadialGradient(kx, ky, 0, kx, ky, kr * 0.3);
            gradient.addColorStop(0, `rgba(${Math.max(0, r - 60)}, ${Math.max(0, g - 55)}, ${Math.max(0, b - 50)}, 0.7)`);
            gradient.addColorStop(1, 'transparent');
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(kx, ky, kr * 0.3, 0, Math.PI * 2);
            ctx.fill();
          }
        }

        // Add subtle color variation (slightly warmer/cooler areas)
        ctx.globalAlpha = 0.04;
        const colorGrad = ctx.createLinearGradient(0, 0, size, size);
        colorGrad.addColorStop(0, `rgba(${Math.min(255, r + 15)}, ${Math.min(255, g + 10)}, ${b}, 1)`);
        colorGrad.addColorStop(0.5, 'transparent');
        colorGrad.addColorStop(1, `rgba(${Math.max(0, r - 10)}, ${Math.max(0, g - 5)}, ${Math.min(255, b + 5)}, 1)`);
        ctx.fillStyle = colorGrad;
        ctx.fillRect(0, 0, size, size);

        ctx.globalAlpha = 1;

        const texture = new THREE.CanvasTexture(canvas);
        texture.wrapS = THREE.RepeatWrapping;
        texture.wrapT = THREE.RepeatWrapping;
        // Adjust repeat based on grain type
        const repeatVal = grainType === 'maple' ? 1.2 : (grainType === 'hickory' ? 1.8 : 1.5);
        texture.repeat.set(repeatVal, repeatVal);
        texture.anisotropy = 16;  // Better quality at angles
        texture.colorSpace = THREE.SRGBColorSpace;  // Correct color encoding for r128
        texture.needsUpdate = true;  // Ensure texture is uploaded to GPU
        return texture;
      }

      // === MODERN BAR HANDLE CREATOR ===
      // Creates realistic cabinet pull with standoffs - enhanced for better visibility
      function createModernBarHandle(length = 0.25, finish = 'brushed-nickel') {
        const handleGroup = new THREE.Group();

        // Handle finishes with enhanced metallic properties
        const finishes = {
          'brushed-nickel': { color: 0xB8B8B8, metalness: 0.92, roughness: 0.18 },
          'matte-black': { color: 0x1a1a1a, metalness: 0.75, roughness: 0.35 },
          'polished-chrome': { color: 0xE8E8E8, metalness: 0.98, roughness: 0.05 },
          'brass': { color: 0xD4AF37, metalness: 0.92, roughness: 0.15 },
          'oil-rubbed-bronze': { color: 0x3D2B1F, metalness: 0.80, roughness: 0.28 },
          'satin-gold': { color: 0xCFB53B, metalness: 0.88, roughness: 0.22 }
        };

        const mat = finishes[finish] || finishes['brushed-nickel'];
        const handleMat = new THREE.MeshStandardMaterial({
          color: mat.color,
          metalness: mat.metalness,
          roughness: mat.roughness,
          envMap: window.roomEnvMap || null,
          envMapIntensity: 1.5
        });

        // Main bar - THICKER for better visibility
        const barRadius = 0.016;  // Increased from 0.012
        const barLength = length;
        const barGeo = new THREE.CylinderGeometry(barRadius, barRadius, barLength, 20);
        const bar = new THREE.Mesh(barGeo, handleMat);
        bar.rotation.z = Math.PI / 2; // Horizontal
        bar.castShadow = true;
        bar.receiveShadow = true;
        handleGroup.add(bar);

        // Standoffs (mounting posts) - LARGER
        const standoffHeight = 0.032;  // Increased from 0.025
        const standoffRadius = 0.018;  // Increased from 0.015
        const standoffSpacing = barLength * 0.72;

        // Left standoff
        const standoffGeo = new THREE.CylinderGeometry(standoffRadius, standoffRadius * 0.9, standoffHeight, 16);
        const leftStandoff = new THREE.Mesh(standoffGeo, handleMat);
        leftStandoff.position.set(-standoffSpacing / 2, 0, -standoffHeight / 2);
        leftStandoff.rotation.x = Math.PI / 2;
        leftStandoff.castShadow = true;
        handleGroup.add(leftStandoff);

        // Right standoff
        const rightStandoff = new THREE.Mesh(standoffGeo, handleMat);
        rightStandoff.position.set(standoffSpacing / 2, 0, -standoffHeight / 2);
        rightStandoff.rotation.x = Math.PI / 2;
        rightStandoff.castShadow = true;
        handleGroup.add(rightStandoff);

        // Mounting plates (decorative) - LARGER
        const plateGeo = new THREE.CylinderGeometry(standoffRadius * 1.4, standoffRadius * 1.4, 0.006, 20);
        const leftPlate = new THREE.Mesh(plateGeo, handleMat);
        leftPlate.position.set(-standoffSpacing / 2, 0, -standoffHeight - 0.003);
        leftPlate.rotation.x = Math.PI / 2;
        leftPlate.castShadow = true;
        handleGroup.add(leftPlate);

        const rightPlate = new THREE.Mesh(plateGeo, handleMat);
        rightPlate.position.set(standoffSpacing / 2, 0, -standoffHeight - 0.003);
        rightPlate.rotation.x = Math.PI / 2;
        rightPlate.castShadow = true;
        handleGroup.add(rightPlate);

        // Add subtle highlight on bar top for depth
        const highlightMat = new THREE.MeshBasicMaterial({
          color: 0xffffff,
          transparent: true,
          opacity: 0.08
        });
        const highlightGeo = new THREE.PlaneGeometry(barLength, barRadius * 0.5);
        const highlight = new THREE.Mesh(highlightGeo, highlightMat);
        highlight.position.set(0, barRadius * 0.95, 0);
        highlight.rotation.x = -Math.PI / 2;
        handleGroup.add(highlight);

        return handleGroup;
      }

      // Helper to create cabinet with doors
      function createCabinet(width, height, depth, cabinetColor, isWallCab, doorStyle, construction, overlay, finish, elementId, customTextureUrl, grainType) {
        const cabGroup = new THREE.Group();
        cabGroup.userData.doors = []; // Track door groups for animation

        // Construction affects door gaps
        // Frameless: minimal gaps, doors cover most of face (full overlay default)
        // Framed: visible face frame, doors reveal frame edges
        const isFramed = construction === 'framed';
        const overlayType = overlay || 'full';
        const cabinetFinish = finish || 'wood-grain';
        const woodGrainType = grainType || 'oak'; // Default to oak grain pattern

        // Gap based on overlay type
        let gap;
        if (isFramed) {
          gap = overlayType === 'inset' ? 0.08 : (overlayType === 'partial' ? 0.06 : 0.04);
        } else {
          gap = overlayType === 'inset' ? 0.06 : 0.02; // Frameless has smaller gaps
        }

        // Cabinet body - interior with darker finish (using pooled geometry)
        const bodyMat = new THREE.MeshStandardMaterial({
          color: 0x1a1a1a,
          roughness: 0.9,
          metalness: 0.0
        });
        const bodyGeometry = getPooledBoxGeometry(width - 0.1, height - 0.1, depth - 0.1);
        const body = new THREE.Mesh(bodyGeometry, bodyMat);
        body.position.z = -0.02;
        body.castShadow = true;
        body.receiveShadow = true;
        cabGroup.add(body);

        // Create texture and material based on finish type
        let woodTexture = null;
        let baseRoughness, baseMetalness;

        // Check for custom uploaded texture first
        if (customTextureUrl) {
          // Load custom texture image
          const textureLoader = new THREE.TextureLoader();
          try {
            woodTexture = textureLoader.load(customTextureUrl, (texture) => {
              texture.wrapS = THREE.RepeatWrapping;
              texture.wrapT = THREE.RepeatWrapping;
              texture.repeat.set(2, 2);
              // Update all materials that use this texture
              cabGroup.traverse(child => {
                if (child.material && child.material.map === woodTexture) {
                  child.material.needsUpdate = true;
                }
              });
              if (renderer && scene && camera) {
                renderer.render(scene, camera);
              }
            });
            woodTexture.wrapS = THREE.RepeatWrapping;
            woodTexture.wrapT = THREE.RepeatWrapping;
            woodTexture.repeat.set(2, 2);
          } catch (e) {
            console.warn('Failed to load custom cabinet texture:', e);
            woodTexture = createWoodGrainTexture(cabinetColor, 0.12, woodGrainType);
          }
          baseRoughness = 0.3;
          baseMetalness = 0.02;
        } else if (cabinetFinish === 'wood-grain') {
          woodTexture = createWoodGrainTexture(cabinetColor, 0.12, woodGrainType);
          baseRoughness = 0.3;
          baseMetalness = 0.02;
        } else if (cabinetFinish === 'painted') {
          // Smooth painted finish - use flat texture for subtle surface variation
          woodTexture = createWoodGrainTexture(cabinetColor, 0.05, 'flat');
          baseRoughness = 0.4;
          baseMetalness = 0.01;
        } else if (cabinetFinish === 'matte') {
          // Matte laminate - use flat texture
          woodTexture = createWoodGrainTexture(cabinetColor, 0.03, 'flat');
          baseRoughness = 0.7;
          baseMetalness = 0.0;
        } else if (cabinetFinish === 'gloss') {
          // High gloss - use flat texture with minimal variation
          woodTexture = createWoodGrainTexture(cabinetColor, 0.02, 'flat');
          baseRoughness = 0.1;
          baseMetalness = 0.05;
        } else {
          woodTexture = createWoodGrainTexture(cabinetColor, 0.12, woodGrainType);
          baseRoughness = 0.3;
          baseMetalness = 0.02;
        }

        // Face frame for framed cabinets
        if (isFramed) {
          const frameMat = new THREE.MeshStandardMaterial({
            color: cabinetColor,
            map: woodTexture,
            roughness: baseRoughness + 0.05,
            metalness: baseMetalness,
            bumpScale: woodTexture ? 0.002 : 0
          });
          const frameW = 0.06; // 1.5" face frame

          // Top rail
          const topFrame = new THREE.Mesh(new THREE.BoxGeometry(width, frameW, 0.04), frameMat);
          topFrame.position.set(0, height/2 - frameW/2 - 0.01, depth/2 - 0.01);
          topFrame.castShadow = true;
          cabGroup.add(topFrame);

          // Bottom rail
          const botFrame = new THREE.Mesh(new THREE.BoxGeometry(width, frameW, 0.04), frameMat);
          botFrame.position.set(0, -height/2 + frameW/2 + 0.01, depth/2 - 0.01);
          botFrame.castShadow = true;
          cabGroup.add(botFrame);

          // Left stile
          const leftFrame = new THREE.Mesh(new THREE.BoxGeometry(frameW, height - frameW*2, 0.04), frameMat);
          leftFrame.position.set(-width/2 + frameW/2 + 0.01, 0, depth/2 - 0.01);
          leftFrame.castShadow = true;
          cabGroup.add(leftFrame);

          // Right stile
          const rightFrame = new THREE.Mesh(new THREE.BoxGeometry(frameW, height - frameW*2, 0.04), frameMat);
          rightFrame.position.set(width/2 - frameW/2 - 0.01, 0, depth/2 - 0.01);
          rightFrame.castShadow = true;
          cabGroup.add(rightFrame);
        }

        // Face material - with or without wood grain based on finish
        const faceMat = new THREE.MeshStandardMaterial({
          color: cabinetColor,
          map: woodTexture,
          roughness: baseRoughness,
          metalness: baseMetalness,
          bumpScale: woodTexture ? 0.002 : 0
        });

        // Door(s) - each door is a Group with pivot at hinge edge for proper animation
        const numDoors = Math.max(1, Math.round(width / 1.5));
        const doorW = (width - gap * (numDoors + 1)) / numDoors;
        const doorH = height - gap * 2;

        const style = doorStyle || 'shaker';

        // Door style details - material matches finish type
        const doorFrameMat = new THREE.MeshStandardMaterial({
          color: cabinetColor,
          map: woodTexture,
          roughness: baseRoughness - 0.02,
          metalness: baseMetalness
        });

        for (let i = 0; i < numDoors; i++) {
          // Door group - positioned at hinge edge for proper pivot rotation
          const doorGroup = new THREE.Group();

          // Determine hinge side: left doors hinge left, right doors hinge right
          const hingeOnLeft = i < numDoors / 2;
          const hingeOffset = hingeOnLeft ? -doorW / 2 : doorW / 2;

          // Position door group at the hinge location
          const doorCenterX = -width/2 + gap + doorW/2 + i * (doorW + gap);
          doorGroup.position.set(doorCenterX + hingeOffset, 0, depth/2);

          // Door mesh offset from group origin (which is at hinge)
          const doorMeshOffset = hingeOnLeft ? doorW / 2 : -doorW / 2;

          // Main door panel - offset from pivot point
          const door = new THREE.Mesh(new THREE.BoxGeometry(doorW, doorH, 0.06), faceMat);
          door.position.set(doorMeshOffset, 0, 0);
          door.castShadow = true;
          door.receiveShadow = true;
          doorGroup.add(door);

          if (style === 'shaker' || style === 'shaker-beaded') {
            // Shaker: flat center panel with raised frame
            const fw = 0.08;

            // Top rail
            const top = new THREE.Mesh(new THREE.BoxGeometry(doorW - 0.02, fw, 0.02), doorFrameMat);
            top.position.set(doorMeshOffset, doorH/2 - fw/2 - 0.01, 0.04);
            top.castShadow = true;
            doorGroup.add(top);

            // Bottom rail
            const bot = new THREE.Mesh(new THREE.BoxGeometry(doorW - 0.02, fw, 0.02), doorFrameMat);
            bot.position.set(doorMeshOffset, -doorH/2 + fw/2 + 0.01, 0.04);
            bot.castShadow = true;
            doorGroup.add(bot);

            // Left stile
            const left = new THREE.Mesh(new THREE.BoxGeometry(fw, doorH - fw*2, 0.02), doorFrameMat);
            left.position.set(doorMeshOffset - doorW/2 + fw/2 + 0.01, 0, 0.04);
            left.castShadow = true;
            doorGroup.add(left);

            // Right stile
            const right = new THREE.Mesh(new THREE.BoxGeometry(fw, doorH - fw*2, 0.02), doorFrameMat);
            right.position.set(doorMeshOffset + doorW/2 - fw/2 - 0.01, 0, 0.04);
            right.castShadow = true;
            doorGroup.add(right);

            // Beaded detail for shaker-beaded style
            if (style === 'shaker-beaded') {
              const beadMat = new THREE.MeshStandardMaterial({
                color: cabinetColor,
                roughness: baseRoughness - 0.1,
                metalness: baseMetalness + 0.02
              });
              const beadRadius = 0.008;
              const beadGeo = new THREE.CylinderGeometry(beadRadius, beadRadius, doorW - fw * 2 - 0.04, 8);

              // Top bead (horizontal)
              const topBead = new THREE.Mesh(beadGeo, beadMat);
              topBead.rotation.z = Math.PI / 2;
              topBead.position.set(doorMeshOffset, doorH/2 - fw - 0.02, 0.05);
              doorGroup.add(topBead);

              // Bottom bead (horizontal)
              const botBead = new THREE.Mesh(beadGeo, beadMat);
              botBead.rotation.z = Math.PI / 2;
              botBead.position.set(doorMeshOffset, -doorH/2 + fw + 0.02, 0.05);
              doorGroup.add(botBead);

              // Side beads (vertical)
              const sideBeadGeo = new THREE.CylinderGeometry(beadRadius, beadRadius, doorH - fw * 2 - 0.04, 8);

              const leftBead = new THREE.Mesh(sideBeadGeo, beadMat);
              leftBead.position.set(doorMeshOffset - doorW/2 + fw + 0.02, 0, 0.05);
              doorGroup.add(leftBead);

              const rightBead = new THREE.Mesh(sideBeadGeo, beadMat);
              rightBead.position.set(doorMeshOffset + doorW/2 - fw - 0.02, 0, 0.05);
              doorGroup.add(rightBead);
            }
          } else if (style === 'raised') {
            // Raised panel: outer frame with raised center
            const fw = 0.1;

            // Frame pieces
            const top = new THREE.Mesh(new THREE.BoxGeometry(doorW - 0.02, fw, 0.02), doorFrameMat);
            top.position.set(doorMeshOffset, doorH/2 - fw/2 - 0.01, 0.04);
            top.castShadow = true;
            doorGroup.add(top);

            const bot = new THREE.Mesh(new THREE.BoxGeometry(doorW - 0.02, fw, 0.02), doorFrameMat);
            bot.position.set(doorMeshOffset, -doorH/2 + fw/2 + 0.01, 0.04);
            bot.castShadow = true;
            doorGroup.add(bot);

            const left = new THREE.Mesh(new THREE.BoxGeometry(fw, doorH - fw*2, 0.02), doorFrameMat);
            left.position.set(doorMeshOffset - doorW/2 + fw/2 + 0.01, 0, 0.04);
            left.castShadow = true;
            doorGroup.add(left);

            const right = new THREE.Mesh(new THREE.BoxGeometry(fw, doorH - fw*2, 0.02), doorFrameMat);
            right.position.set(doorMeshOffset + doorW/2 - fw/2 - 0.01, 0, 0.04);
            right.castShadow = true;
            doorGroup.add(right);

            // Raised center panel - matches cabinet finish
            const raisedW = doorW - fw * 2 - 0.06;
            const raisedH = doorH - fw * 2 - 0.06;
            const raisedMat = new THREE.MeshStandardMaterial({
              color: cabinetColor,
              map: woodTexture,
              roughness: baseRoughness - 0.08,
              metalness: baseMetalness
            });
            const raised = new THREE.Mesh(new THREE.BoxGeometry(raisedW, raisedH, 0.04), raisedMat);
            raised.position.set(doorMeshOffset, 0, 0.06);
            raised.castShadow = true;
            doorGroup.add(raised);
          } else if (style === 'thin-shaker' || style === 'shaker-slim') {
            // Thin/Slim Shaker: narrower frame rails for modern minimalist look
            const fw = 0.05; // Thinner frame than standard shaker

            // Top rail
            const top = new THREE.Mesh(new THREE.BoxGeometry(doorW - 0.02, fw, 0.015), doorFrameMat);
            top.position.set(doorMeshOffset, doorH/2 - fw/2 - 0.01, 0.035);
            top.castShadow = true;
            doorGroup.add(top);

            // Bottom rail
            const bot = new THREE.Mesh(new THREE.BoxGeometry(doorW - 0.02, fw, 0.015), doorFrameMat);
            bot.position.set(doorMeshOffset, -doorH/2 + fw/2 + 0.01, 0.035);
            bot.castShadow = true;
            doorGroup.add(bot);

            // Left stile
            const left = new THREE.Mesh(new THREE.BoxGeometry(fw, doorH - fw*2, 0.015), doorFrameMat);
            left.position.set(doorMeshOffset - doorW/2 + fw/2 + 0.01, 0, 0.035);
            left.castShadow = true;
            doorGroup.add(left);

            // Right stile
            const right = new THREE.Mesh(new THREE.BoxGeometry(fw, doorH - fw*2, 0.015), doorFrameMat);
            right.position.set(doorMeshOffset + doorW/2 - fw/2 - 0.01, 0, 0.035);
            right.castShadow = true;
            doorGroup.add(right);

          } else if (style === 'recessed' || style === 'recessed-panel') {
            // Recessed Panel: outer frame with deeply recessed center
            const fw = 0.09;

            // Frame pieces
            const top = new THREE.Mesh(new THREE.BoxGeometry(doorW - 0.02, fw, 0.025), doorFrameMat);
            top.position.set(doorMeshOffset, doorH/2 - fw/2 - 0.01, 0.045);
            top.castShadow = true;
            doorGroup.add(top);

            const bot = new THREE.Mesh(new THREE.BoxGeometry(doorW - 0.02, fw, 0.025), doorFrameMat);
            bot.position.set(doorMeshOffset, -doorH/2 + fw/2 + 0.01, 0.045);
            bot.castShadow = true;
            doorGroup.add(bot);

            const left = new THREE.Mesh(new THREE.BoxGeometry(fw, doorH - fw*2, 0.025), doorFrameMat);
            left.position.set(doorMeshOffset - doorW/2 + fw/2 + 0.01, 0, 0.045);
            left.castShadow = true;
            doorGroup.add(left);

            const right = new THREE.Mesh(new THREE.BoxGeometry(fw, doorH - fw*2, 0.025), doorFrameMat);
            right.position.set(doorMeshOffset + doorW/2 - fw/2 - 0.01, 0, 0.045);
            right.castShadow = true;
            doorGroup.add(right);

            // Deeply recessed center (set back into door)
            const recessedMat = new THREE.MeshStandardMaterial({
              color: new THREE.Color(cabinetColor).multiplyScalar(0.92),
              map: woodTexture,
              roughness: baseRoughness + 0.05
            });
            const recessed = new THREE.Mesh(new THREE.BoxGeometry(doorW - fw*2 - 0.04, doorH - fw*2 - 0.04, 0.02), recessedMat);
            recessed.position.set(doorMeshOffset, 0, 0.01);
            doorGroup.add(recessed);

          } else if (style === 'mission' || style === 'craftsman') {
            // Mission/Craftsman: double recessed panel detail
            const fw = 0.07;

            // Outer frame
            const top = new THREE.Mesh(new THREE.BoxGeometry(doorW - 0.02, fw, 0.02), doorFrameMat);
            top.position.set(doorMeshOffset, doorH/2 - fw/2 - 0.01, 0.04);
            doorGroup.add(top);

            const bot = new THREE.Mesh(new THREE.BoxGeometry(doorW - 0.02, fw, 0.02), doorFrameMat);
            bot.position.set(doorMeshOffset, -doorH/2 + fw/2 + 0.01, 0.04);
            doorGroup.add(bot);

            const left = new THREE.Mesh(new THREE.BoxGeometry(fw, doorH - fw*2, 0.02), doorFrameMat);
            left.position.set(doorMeshOffset - doorW/2 + fw/2 + 0.01, 0, 0.04);
            doorGroup.add(left);

            const right = new THREE.Mesh(new THREE.BoxGeometry(fw, doorH - fw*2, 0.02), doorFrameMat);
            right.position.set(doorMeshOffset + doorW/2 - fw/2 - 0.01, 0, 0.04);
            doorGroup.add(right);

            // Center mullion (vertical divider)
            const mullion = new THREE.Mesh(new THREE.BoxGeometry(fw * 0.6, doorH - fw*2 - 0.02, 0.02), doorFrameMat);
            mullion.position.set(doorMeshOffset, 0, 0.04);
            doorGroup.add(mullion);

          } else if (style === 'flat') {
            // Flat panel: minimal detail, recessed center
            const grooveMat = new THREE.MeshStandardMaterial({
              color: new THREE.Color(cabinetColor).multiplyScalar(0.85),
              roughness: 0.5
            });
            const groove = new THREE.Mesh(new THREE.BoxGeometry(doorW - 0.1, doorH - 0.1, 0.015), grooveMat);
            groove.position.set(doorMeshOffset, 0, 0.025);
            doorGroup.add(groove);
          }
          // 'slab' style = no detail, just plain door with wood grain

          // Modern Bar Handle with standoffs
          const handleLength = Math.min(doorW * 0.6, 0.3);
          const handleFinish = 'brushed-nickel';
          const handle = createModernBarHandle(handleLength, handleFinish);

          // Position handle - vertical for tall handles, horizontal positioning
          const handleY = isWallCab ? -doorH * 0.28 : doorH * 0.28;
          const handleX = hingeOnLeft ? doorW/2 - 0.15 : -doorW/2 + 0.15;

          handle.position.set(doorMeshOffset + handleX, handleY, 0.085);
          handle.rotation.z = Math.PI / 2; // Vertical orientation
          doorGroup.add(handle);

          // Add userData for click detection and animation
          doorGroup.userData = {
            partType: 'door',
            elementId: elementId,
            doorIndex: i,
            hingeOnLeft: hingeOnLeft,
            isOpen: false,
            openAngle: hingeOnLeft ? Math.PI / 2 : -Math.PI / 2 // Direction to swing
          };

          // Make all children clickable with same userData
          doorGroup.traverse(child => {
            if (child.isMesh) {
              child.userData.partType = 'door';
              child.userData.elementId = elementId;
              child.userData.doorGroup = doorGroup;
            }
          });

          cabGroup.add(doorGroup);
          cabGroup.userData.doors.push(doorGroup);
        }

        return cabGroup;
      }

      // === CREATE DETAILED 3D MODELS ===
      // Normalize cabinet types for 3D rendering (base-cabinet-12 -> base-cabinet, etc.)
      const normalizeType = (type) => {
        if (type.startsWith('base-cabinet-')) return 'base-cabinet';
        if (type.startsWith('wall-cabinet-')) return 'wall-cabinet';
        if (type.startsWith('tall-cabinet-')) return 'tall-cabinet';
        if (type.startsWith('drawer-base-')) return 'drawer-base';
        if (type.startsWith('sink-base-')) return 'sink-base';
        if (type.startsWith('corner-cabinet-')) return 'corner-cabinet';
        return type;
      };
      const renderType = normalizeType(el.type);

      switch(renderType) {
        case 'base-cabinet':
        case 'wall-cabinet': {
          const isBaseCab = renderType === 'base-cabinet';

          // Toe kick dimensions (4" tall, 3" recessed)
          const toeKickHeight = isBaseCab ? 0.33 : 0;
          const toeKickRecess = isBaseCab ? 0.25 : 0;

          // Cabinet body height (minus toe kick for base cabinets)
          const bodyHeight = h - toeKickHeight;

          // Create cabinet body at reduced height for base cabinets
          const cab = createCabinet(w, bodyHeight, d, color, !isBaseCab, el.doorStyle, el.construction, el.doorOverlay, el.cabinetFinish, el.id, textureUrl);

          // Position cabinet body above toe kick
          if (isBaseCab) {
            cab.position.y = toeKickHeight / 2;
          }
          group.add(cab);

          // Create toe kick for base cabinets - proper recessed void
          if (isBaseCab) {
            // Toe kick back panel (visible back of recess)
            const tkBackMat = new THREE.MeshStandardMaterial({ color: 0x0a0a0a, roughness: 0.95 });
            const tkBack = new THREE.Mesh(
              new THREE.BoxGeometry(w - 0.1, toeKickHeight - 0.02, 0.02),
              tkBackMat
            );
            tkBack.position.set(0, -h/2 + toeKickHeight/2, d/2 - toeKickRecess);
            group.add(tkBack);

            // Toe kick bottom (floor of recess)
            const tkBottom = new THREE.Mesh(
              new THREE.BoxGeometry(w - 0.1, 0.02, toeKickRecess - 0.02),
              tkBackMat
            );
            tkBottom.position.set(0, -h/2 + 0.01, d/2 - toeKickRecess/2);
            group.add(tkBottom);

            // Left side panel of toe kick recess
            const tkLeft = new THREE.Mesh(
              new THREE.BoxGeometry(0.02, toeKickHeight - 0.02, toeKickRecess),
              tkBackMat
            );
            tkLeft.position.set(-w/2 + 0.05, -h/2 + toeKickHeight/2, d/2 - toeKickRecess/2);
            group.add(tkLeft);

            // Right side panel of toe kick recess
            const tkRight = new THREE.Mesh(
              new THREE.BoxGeometry(0.02, toeKickHeight - 0.02, toeKickRecess),
              tkBackMat
            );
            tkRight.position.set(w/2 - 0.05, -h/2 + toeKickHeight/2, d/2 - toeKickRecess/2);
            group.add(tkRight);

            // Cabinet overhang lip (bottom edge of cabinet above toe kick)
            const lipMat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.4 });
            const lip = new THREE.Mesh(
              new THREE.BoxGeometry(w, 0.03, 0.04),
              lipMat
            );
            lip.position.set(0, -h/2 + toeKickHeight + 0.015, d/2 - 0.02);
            group.add(lip);
          }
          break;
        }

        case 'microwave-cabinet': {
          // Simple open box shelf with microwave inside
          // No doors - just an open cabinet frame with microwave face visible
          const mwcCabinetMat = new THREE.MeshStandardMaterial({
            color: color,
            roughness: 0.5
          });
          const mwcDarkMat = new THREE.MeshStandardMaterial({
            color: 0x1a1a1a,
            roughness: 0.8
          });
          const mwcMicrowaveMat = new THREE.MeshStandardMaterial({
            color: 0x2a2a2a,
            roughness: 0.3,
            metalness: 0.3
          });
          const mwcHandleMat = new THREE.MeshStandardMaterial({
            color: 0xB0B0B0,
            roughness: 0.2,
            metalness: 0.85
          });

          const panelThickness = 0.05; // ~0.6" thick panels

          // Back panel
          const backPanel = new THREE.Mesh(
            new THREE.BoxGeometry(w, h, panelThickness),
            mwcCabinetMat
          );
          backPanel.position.set(0, 0, -d/2 + panelThickness/2);
          group.add(backPanel);

          // Side panels (left and right)
          [-1, 1].forEach(side => {
            const sidePanel = new THREE.Mesh(
              new THREE.BoxGeometry(panelThickness, h, d - panelThickness),
              mwcCabinetMat
            );
            sidePanel.position.set(side * (w/2 - panelThickness/2), 0, panelThickness/2);
            group.add(sidePanel);
          });

          // Top panel
          const topPanel = new THREE.Mesh(
            new THREE.BoxGeometry(w - panelThickness * 2, panelThickness, d - panelThickness),
            mwcCabinetMat
          );
          topPanel.position.set(0, h/2 - panelThickness/2, panelThickness/2);
          group.add(topPanel);

          // Bottom panel
          const bottomPanel = new THREE.Mesh(
            new THREE.BoxGeometry(w - panelThickness * 2, panelThickness, d - panelThickness),
            mwcCabinetMat
          );
          bottomPanel.position.set(0, -h/2 + panelThickness/2, panelThickness/2);
          group.add(bottomPanel);

          // Dark interior
          const interiorBack = new THREE.Mesh(
            new THREE.BoxGeometry(w - panelThickness * 2 - 0.02, h - panelThickness * 2 - 0.02, 0.01),
            mwcDarkMat
          );
          interiorBack.position.set(0, 0, -d/2 + panelThickness + 0.01);
          group.add(interiorBack);

          // Microwave body
          const mwWidth = w * 0.9;
          const mwHeight = h * 0.8;
          const mwDepth = d * 0.85;

          const microwaveBody = new THREE.Mesh(
            new THREE.BoxGeometry(mwWidth, mwHeight, mwDepth),
            mwcMicrowaveMat
          );
          microwaveBody.position.set(0, 0, d/2 - mwDepth/2 - panelThickness);
          group.add(microwaveBody);

          // Microwave glass door (left side)
          const mwGlass = new THREE.Mesh(
            new THREE.BoxGeometry(mwWidth * 0.6, mwHeight * 0.8, 0.02),
            new THREE.MeshStandardMaterial({
              color: 0x111111,
              transparent: true,
              opacity: 0.85,
              roughness: 0.1
            })
          );
          mwGlass.position.set(-mwWidth * 0.15, 0, d/2 - 0.01);
          group.add(mwGlass);

          // Control panel (right side)
          const controlPanel = new THREE.Mesh(
            new THREE.BoxGeometry(mwWidth * 0.28, mwHeight * 0.8, 0.02),
            new THREE.MeshStandardMaterial({ color: 0x3a3a3a, roughness: 0.4 })
          );
          controlPanel.position.set(mwWidth * 0.3, 0, d/2 - 0.01);
          group.add(controlPanel);

          // Buttons on control panel
          for (let row = 0; row < 3; row++) {
            for (let col = 0; col < 3; col++) {
              const btn = new THREE.Mesh(
                new THREE.BoxGeometry(0.03, 0.025, 0.01),
                new THREE.MeshStandardMaterial({ color: 0x5a5a5a })
              );
              btn.position.set(
                mwWidth * 0.22 + col * 0.045,
                0.1 - row * 0.045,
                d/2
              );
              group.add(btn);
            }
          }

          // Door handle (vertical bar on left of glass)
          const doorHandle = new THREE.Mesh(
            new THREE.BoxGeometry(0.02, mwHeight * 0.4, 0.03),
            mwcHandleMat
          );
          doorHandle.position.set(-mwWidth/2 + 0.08, 0, d/2 + 0.01);
          group.add(doorHandle);

          break;
        }

        case 'drawer-base': {
          // Drawer base cabinet with 3-4 stacked drawer fronts
          const dbToeKickHeight = 0.33;
          const dbToeKickRecess = 0.25;
          const dbBodyHeight = h - dbToeKickHeight;
          const dbIsFramed = el.construction === 'framed';

          // Use wood grain texture like other cabinets for consistency
          const dbCabinetFinish = el.cabinetFinish || 'wood-grain';
          const dbGrainType = el.grainType || 'oak';
          let dbWoodTexture = null;
          let dbBaseRoughness = 0.35;
          let dbBaseMetalness = 0.02;

          // Check for custom texture first
          if (textureUrl) {
            const textureLoader = new THREE.TextureLoader();
            try {
              dbWoodTexture = textureLoader.load(textureUrl);
              dbWoodTexture.wrapS = THREE.RepeatWrapping;
              dbWoodTexture.wrapT = THREE.RepeatWrapping;
              dbWoodTexture.repeat.set(2, 2);
            } catch (e) {
              dbWoodTexture = createWoodGrainTexture(color, 0.12, dbGrainType);
            }
            dbBaseRoughness = 0.3;
            dbBaseMetalness = 0.02;
          } else if (dbCabinetFinish === 'wood-grain') {
            dbWoodTexture = createWoodGrainTexture(color, 0.12, dbGrainType);
            dbBaseRoughness = 0.3;
            dbBaseMetalness = 0.02;
          } else if (dbCabinetFinish === 'painted') {
            dbWoodTexture = createWoodGrainTexture(color, 0.05, 'flat');
            dbBaseRoughness = 0.4;
            dbBaseMetalness = 0.01;
          } else if (dbCabinetFinish === 'matte') {
            dbWoodTexture = createWoodGrainTexture(color, 0.03, 'flat');
            dbBaseRoughness = 0.7;
            dbBaseMetalness = 0.0;
          } else if (dbCabinetFinish === 'gloss') {
            dbWoodTexture = createWoodGrainTexture(color, 0.02, 'flat');
            dbBaseRoughness = 0.1;
            dbBaseMetalness = 0.05;
          }

          const cabinetMat = new THREE.MeshStandardMaterial({
            color: color,
            map: dbWoodTexture,
            roughness: dbBaseRoughness,
            metalness: dbBaseMetalness,
            bumpScale: dbWoodTexture ? 0.002 : 0
          });
          const bodyMat = new THREE.MeshStandardMaterial({ color: 0x2a2a2a, roughness: 0.8 });
          const handleMat = new THREE.MeshStandardMaterial({ color: 0xaaaaaa, metalness: 0.9, roughness: 0.15 });

          // Face frame for framed construction
          if (dbIsFramed) {
            const frameW = 0.06;
            // Top rail
            const topFrame = new THREE.Mesh(new THREE.BoxGeometry(w, frameW, 0.04), cabinetMat);
            topFrame.position.set(0, dbToeKickHeight/2 + dbBodyHeight/2 - frameW/2, d/2 - 0.01);
            group.add(topFrame);
            // Bottom rail
            const botFrame = new THREE.Mesh(new THREE.BoxGeometry(w, frameW, 0.04), cabinetMat);
            botFrame.position.set(0, dbToeKickHeight/2 - dbBodyHeight/2 + frameW/2, d/2 - 0.01);
            group.add(botFrame);
            // Left stile
            const leftFrame = new THREE.Mesh(new THREE.BoxGeometry(frameW, dbBodyHeight - frameW*2, 0.04), cabinetMat);
            leftFrame.position.set(-w/2 + frameW/2, dbToeKickHeight/2, d/2 - 0.01);
            group.add(leftFrame);
            // Right stile
            const rightFrame = new THREE.Mesh(new THREE.BoxGeometry(frameW, dbBodyHeight - frameW*2, 0.04), cabinetMat);
            rightFrame.position.set(w/2 - frameW/2, dbToeKickHeight/2, d/2 - 0.01);
            group.add(rightFrame);
          }

          // Cabinet body (sides, top, back)
          // Back panel
          const back = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.04, dbBodyHeight - 0.04, 0.03),
            bodyMat
          );
          back.position.set(0, dbToeKickHeight/2, -d/2 + 0.02);
          group.add(back);

          // Left side
          const leftSide = new THREE.Mesh(
            new THREE.BoxGeometry(0.04, dbBodyHeight, d),
            cabinetMat
          );
          leftSide.position.set(-w/2 + 0.02, dbToeKickHeight/2, 0);
          group.add(leftSide);

          // Right side
          const rightSide = new THREE.Mesh(
            new THREE.BoxGeometry(0.04, dbBodyHeight, d),
            cabinetMat
          );
          rightSide.position.set(w/2 - 0.02, dbToeKickHeight/2, 0);
          group.add(rightSide);

          // Top
          const topPanel = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.08, 0.04, d - 0.02),
            cabinetMat
          );
          topPanel.position.set(0, dbToeKickHeight/2 + dbBodyHeight/2 - 0.02, 0);
          group.add(topPanel);

          // Draw stacked drawers (3-4 based on width)
          const numDrawers = w > 1.5 ? 4 : 3;
          const drawerGap = 0.02;
          const totalGapHeight = drawerGap * (numDrawers - 1);
          const drawerHeight = (dbBodyHeight - 0.08 - totalGapHeight) / numDrawers;

          // Get door style from element or default
          const dbDoorStyle = el.doorStyle || 'shaker';

          for (let i = 0; i < numDrawers; i++) {
            // Create a drawer group for interactive animation
            const drawerGroup = new THREE.Group();
            const drawerY = dbToeKickHeight/2 + dbBodyHeight/2 - 0.04 - drawerHeight/2 - i * (drawerHeight + drawerGap);

            // Position the drawer group
            drawerGroup.position.set(0, drawerY, d/2);

            // === ENHANCED DRAWER BOX (visible when open) ===
            const drawerBoxMat = new THREE.MeshStandardMaterial({
              color: 0x4a3828,
              roughness: 0.55,
              metalness: 0.02
            });
            const drawerBox = new THREE.Mesh(
              new THREE.BoxGeometry(w - 0.12, drawerHeight - 0.06, d * 0.7),
              drawerBoxMat
            );
            drawerBox.position.set(0, 0, -d * 0.35 + 0.04);
            drawerBox.castShadow = true;
            drawerBox.receiveShadow = true;
            drawerGroup.add(drawerBox);

            // === DRAWER FRONT FACE WITH BETTER CONTRAST ===
            // Use polygon offset to prevent z-fighting
            const drawerFrontMat = new THREE.MeshStandardMaterial({
              color: color,
              map: dbWoodTexture,
              roughness: dbBaseRoughness - 0.05,
              metalness: dbBaseMetalness,
              polygonOffset: true,
              polygonOffsetFactor: -1,
              polygonOffsetUnits: -1
            });
            const drawerFront = new THREE.Mesh(
              new THREE.BoxGeometry(w - 0.05, drawerHeight - 0.015, 0.045),
              drawerFrontMat
            );
            drawerFront.position.set(0, 0, 0.023);
            drawerFront.castShadow = true;
            drawerFront.receiveShadow = true;
            drawerGroup.add(drawerFront);

            // === SHADOW LINE ABOVE DRAWER (creates separation) ===
            const shadowLineMat = new THREE.MeshBasicMaterial({
              color: 0x000000,
              transparent: true,
              opacity: 0.4
            });
            const shadowLine = new THREE.Mesh(
              new THREE.BoxGeometry(w - 0.04, 0.008, 0.05),
              shadowLineMat
            );
            shadowLine.position.set(0, drawerHeight/2 - 0.002, 0.05);
            drawerGroup.add(shadowLine);

            // === DRAWER DETAIL BASED ON DOOR STYLE ===
            // Enhanced frame material with better contrast
            const frameMat = new THREE.MeshStandardMaterial({
              color: new THREE.Color(color).multiplyScalar(1.05),
              map: dbWoodTexture,
              roughness: dbBaseRoughness - 0.08,
              metalness: dbBaseMetalness + 0.01,
              polygonOffset: true,
              polygonOffsetFactor: -2,
              polygonOffsetUnits: -2
            });

            if (dbDoorStyle === 'shaker' || dbDoorStyle === 'shaker-beaded') {
              // Shaker: recessed panel with raised frame
              const frameWidth = 0.075;

              // Dark recessed shadow channel
              const recessedMat = new THREE.MeshStandardMaterial({
                color: 0x0a0a0a,
                roughness: 0.9,
                metalness: 0.0
              });
              const recess = new THREE.Mesh(
                new THREE.BoxGeometry(w - 0.05 - frameWidth * 2 + 0.015, drawerHeight - 0.015 - frameWidth * 2 + 0.015, 0.012),
                recessedMat
              );
              recess.position.set(0, 0, 0.035);
              drawerGroup.add(recess);

              // Raised inner panel with wood texture
              const innerPanel = new THREE.Mesh(
                new THREE.BoxGeometry(w - 0.05 - frameWidth * 2 - 0.01, drawerHeight - 0.015 - frameWidth * 2 - 0.01, 0.025),
                frameMat
              );
              innerPanel.position.set(0, 0, 0.055);
              innerPanel.castShadow = true;
              drawerGroup.add(innerPanel);

              // Edge highlight lines for depth
              const highlightMat = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.15
              });

              // Top edge highlight
              const topHighlight = new THREE.Mesh(
                new THREE.BoxGeometry(w - 0.05 - frameWidth * 2, 0.004, 0.004),
                highlightMat
              );
              topHighlight.position.set(0, (drawerHeight - 0.015)/2 - frameWidth - 0.002, 0.068);
              drawerGroup.add(topHighlight);

            } else if (dbDoorStyle === 'raised') {
              // Raised panel: beveled center with enhanced depth
              const frameWidth = 0.09;

              // Shadow channel
              const shadowMat = new THREE.MeshStandardMaterial({
                color: 0x151515,
                roughness: 0.85
              });
              const shadowChannel = new THREE.Mesh(
                new THREE.BoxGeometry(w - 0.05 - frameWidth * 2 + 0.02, drawerHeight - 0.015 - frameWidth * 2 + 0.02, 0.01),
                shadowMat
              );
              shadowChannel.position.set(0, 0, 0.038);
              drawerGroup.add(shadowChannel);

              // Raised center panel
              const raisedMat = new THREE.MeshStandardMaterial({
                color: new THREE.Color(color).multiplyScalar(1.08),
                map: dbWoodTexture,
                roughness: 0.22,
                metalness: dbBaseMetalness + 0.02
              });
              const raised = new THREE.Mesh(
                new THREE.BoxGeometry(w - 0.05 - frameWidth * 2, drawerHeight - 0.015 - frameWidth * 2, 0.045),
                raisedMat
              );
              raised.position.set(0, 0, 0.065);
              raised.castShadow = true;
              drawerGroup.add(raised);

            } else if (dbDoorStyle === 'flat') {
              // Flat panel: subtle groove line
              const grooveMat = new THREE.MeshStandardMaterial({
                color: new THREE.Color(color).multiplyScalar(0.85),
                roughness: 0.5
              });
              const groove = new THREE.Mesh(
                new THREE.BoxGeometry(w - 0.12, drawerHeight - 0.08, 0.008),
                grooveMat
              );
              groove.position.set(0, 0, 0.035);
              drawerGroup.add(groove);
            }
            // 'slab' style = no additional detail, just plain front

            // === MODERN BAR PULL HANDLE ===
            const handleLen = Math.min(w * 0.5, 0.4);
            const handleFinish = el.handleFinish || 'brushed-nickel';
            const handle = createModernBarHandle(handleLen, handleFinish);
            handle.position.set(0, 0, 0.09);
            drawerGroup.add(handle);

            // Add userData for click detection and animation
            drawerGroup.userData = {
              partType: 'drawer',
              elementId: el.id,
              drawerIndex: i,
              isOpen: false,
              slideDistance: d * 0.6 // How far drawer slides out
            };

            // Make all children clickable with same userData
            drawerGroup.traverse(child => {
              if (child.isMesh) {
                child.userData.partType = 'drawer';
                child.userData.elementId = el.id;
                child.userData.doorGroup = drawerGroup; // Use doorGroup for compatibility
              }
            });

            group.add(drawerGroup);
          }

          // Toe kick
          const tkBackMat = new THREE.MeshStandardMaterial({ color: 0x0a0a0a, roughness: 0.95 });
          const tkBack = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.1, dbToeKickHeight - 0.02, 0.02),
            tkBackMat
          );
          tkBack.position.set(0, -h/2 + dbToeKickHeight/2, d/2 - dbToeKickRecess);
          group.add(tkBack);

          const tkFloor = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.1, 0.02, dbToeKickRecess - 0.02),
            tkBackMat
          );
          tkFloor.position.set(0, -h/2 + 0.01, d/2 - dbToeKickRecess/2);
          group.add(tkFloor);

          break;
        }

        case 'sink-base': {
          // Sink base cabinet - false drawer front + double doors, open interior
          const sbToeKickHeight = 0.33;
          const sbToeKickRecess = 0.25;
          const sbBodyHeight = h - sbToeKickHeight;
          const sbIsFramed = el.construction === 'framed';
          const sbDoorStyle = el.doorStyle || 'shaker';

          // Use wood grain texture like other cabinets for consistency
          const sbCabinetFinish = el.cabinetFinish || 'wood-grain';
          const sbGrainType = el.grainType || 'oak';
          let sbWoodTexture = null;
          let sbBaseRoughness = 0.35;
          let sbBaseMetalness = 0.02;

          // Check for custom texture first
          if (textureUrl) {
            const textureLoader = new THREE.TextureLoader();
            try {
              sbWoodTexture = textureLoader.load(textureUrl);
              sbWoodTexture.wrapS = THREE.RepeatWrapping;
              sbWoodTexture.wrapT = THREE.RepeatWrapping;
              sbWoodTexture.repeat.set(2, 2);
            } catch (e) {
              sbWoodTexture = createWoodGrainTexture(color, 0.12, sbGrainType);
            }
            sbBaseRoughness = 0.3;
            sbBaseMetalness = 0.02;
          } else if (sbCabinetFinish === 'wood-grain') {
            sbWoodTexture = createWoodGrainTexture(color, 0.12, sbGrainType);
            sbBaseRoughness = 0.3;
            sbBaseMetalness = 0.02;
          } else if (sbCabinetFinish === 'painted') {
            sbWoodTexture = createWoodGrainTexture(color, 0.05, 'flat');
            sbBaseRoughness = 0.4;
            sbBaseMetalness = 0.01;
          } else if (sbCabinetFinish === 'matte') {
            sbWoodTexture = createWoodGrainTexture(color, 0.03, 'flat');
            sbBaseRoughness = 0.7;
            sbBaseMetalness = 0.0;
          } else if (sbCabinetFinish === 'gloss') {
            sbWoodTexture = createWoodGrainTexture(color, 0.02, 'flat');
            sbBaseRoughness = 0.1;
            sbBaseMetalness = 0.05;
          }

          const cabinetMat = new THREE.MeshStandardMaterial({
            color: color,
            map: sbWoodTexture,
            roughness: sbBaseRoughness,
            metalness: sbBaseMetalness,
            bumpScale: sbWoodTexture ? 0.002 : 0
          });
          const bodyMat = new THREE.MeshStandardMaterial({ color: 0x2a2a2a, roughness: 0.8 });
          const handleMat = new THREE.MeshStandardMaterial({ color: 0xaaaaaa, metalness: 0.9, roughness: 0.15 });

          // Face frame for framed construction
          if (sbIsFramed) {
            const frameW = 0.06;
            const topFrame = new THREE.Mesh(new THREE.BoxGeometry(w, frameW, 0.04), cabinetMat);
            topFrame.position.set(0, sbToeKickHeight/2 + sbBodyHeight/2 - frameW/2, d/2 - 0.01);
            group.add(topFrame);
            const botFrame = new THREE.Mesh(new THREE.BoxGeometry(w, frameW, 0.04), cabinetMat);
            botFrame.position.set(0, sbToeKickHeight/2 - sbBodyHeight/2 + frameW/2, d/2 - 0.01);
            group.add(botFrame);
            const leftFrame = new THREE.Mesh(new THREE.BoxGeometry(frameW, sbBodyHeight - frameW*2, 0.04), cabinetMat);
            leftFrame.position.set(-w/2 + frameW/2, sbToeKickHeight/2, d/2 - 0.01);
            group.add(leftFrame);
            const rightFrame = new THREE.Mesh(new THREE.BoxGeometry(frameW, sbBodyHeight - frameW*2, 0.04), cabinetMat);
            rightFrame.position.set(w/2 - frameW/2, sbToeKickHeight/2, d/2 - 0.01);
            group.add(rightFrame);
            // Center stile for double door
            const centerFrame = new THREE.Mesh(new THREE.BoxGeometry(frameW, sbBodyHeight - frameW*2 - 0.2, 0.04), cabinetMat);
            centerFrame.position.set(0, sbToeKickHeight/2 - 0.1, d/2 - 0.01);
            group.add(centerFrame);
          }

          // Cabinet body - open interior for plumbing
          // Back panel (partial - allows plumbing access)
          const back = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.04, sbBodyHeight * 0.6, 0.03),
            bodyMat
          );
          back.position.set(0, sbToeKickHeight/2 - sbBodyHeight * 0.2, -d/2 + 0.02);
          group.add(back);

          // Left side
          const leftSide = new THREE.Mesh(
            new THREE.BoxGeometry(0.04, sbBodyHeight, d),
            cabinetMat
          );
          leftSide.position.set(-w/2 + 0.02, sbToeKickHeight/2, 0);
          group.add(leftSide);

          // Right side
          const rightSide = new THREE.Mesh(
            new THREE.BoxGeometry(0.04, sbBodyHeight, d),
            cabinetMat
          );
          rightSide.position.set(w/2 - 0.02, sbToeKickHeight/2, 0);
          group.add(rightSide);

          // False drawer front (top, non-functional) - at front face
          const falseDrawerH = 0.2;
          const falseDrawer = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.06, falseDrawerH, 0.04),
            cabinetMat
          );
          falseDrawer.position.set(0, sbToeKickHeight/2 + sbBodyHeight/2 - falseDrawerH/2 - 0.02, d/2 + 0.02);
          group.add(falseDrawer);

          // False drawer shaker detail
          if (sbDoorStyle === 'shaker') {
            const recessMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.8 });
            const fdRecess = new THREE.Mesh(
              new THREE.BoxGeometry(w - 0.16, falseDrawerH - 0.06, 0.01),
              recessMat
            );
            fdRecess.position.set(0, sbToeKickHeight/2 + sbBodyHeight/2 - falseDrawerH/2 - 0.02, d/2 + 0.03);
            group.add(fdRecess);
          }

          // False drawer - modern bar handle
          const fdHandleLen = Math.min(w * 0.4, 0.3);
          const fdHandleFinish = el.handleFinish || 'brushed-nickel';
          const fdHandle = createModernBarHandle(fdHandleLen, fdHandleFinish);
          fdHandle.position.set(0, sbToeKickHeight/2 + sbBodyHeight/2 - falseDrawerH/2 - 0.02, d/2 + 0.085);
          group.add(fdHandle);

          // Double doors below false drawer
          const doorsHeight = sbBodyHeight - falseDrawerH - 0.08;
          const doorsY = sbToeKickHeight/2 - 0.02;
          const doorW = (w - 0.1) / 2;
          const doorGap = 0.02;

          for (let i = 0; i < 2; i++) {
            const doorX = i === 0 ? -doorW/2 - doorGap/2 : doorW/2 + doorGap/2;

            // Door face - at front
            const door = new THREE.Mesh(
              new THREE.BoxGeometry(doorW, doorsHeight, 0.04),
              cabinetMat
            );
            door.position.set(doorX, doorsY, d/2 + 0.02);
            group.add(door);

            // Door detail based on style - use wood texture
            const frameMat = new THREE.MeshStandardMaterial({
              color: color,
              map: sbWoodTexture,
              roughness: sbBaseRoughness,
              metalness: sbBaseMetalness
            });
            if (sbDoorStyle === 'shaker') {
              const frameInset = 0.1;
              const recessMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.8 });
              const recess = new THREE.Mesh(
                new THREE.BoxGeometry(doorW - frameInset * 2 + 0.02, doorsHeight - frameInset * 2 + 0.02, 0.01),
                recessMat
              );
              recess.position.set(doorX, doorsY, d/2 + 0.03);
              group.add(recess);
              const frame = new THREE.Mesh(
                new THREE.BoxGeometry(doorW - frameInset * 2, doorsHeight - frameInset * 2, 0.02),
                frameMat
              );
              frame.position.set(doorX, doorsY, d/2 + 0.05);
              group.add(frame);
            } else if (sbDoorStyle === 'raised') {
              const frameInset = 0.1;
              const raisedMat = new THREE.MeshStandardMaterial({
                color: color,
                map: sbWoodTexture,
                roughness: 0.25,
                metalness: sbBaseMetalness
              });
              const raised = new THREE.Mesh(
                new THREE.BoxGeometry(doorW - frameInset * 2, doorsHeight - frameInset * 2, 0.04),
                raisedMat
              );
              raised.position.set(doorX, doorsY, d/2 + 0.06);
              group.add(raised);
            }
            // flat/slab = no detail

            // Modern bar handle for door
            const doorHandleLen = Math.min(doorsHeight * 0.35, 0.25);
            const doorHandleFinish = el.handleFinish || 'brushed-nickel';
            const doorHandle = createModernBarHandle(doorHandleLen, doorHandleFinish);
            const handleX = i === 0 ? doorX + doorW/2 - 0.12 : doorX - doorW/2 + 0.12;
            doorHandle.position.set(handleX, doorsY, d/2 + 0.085);
            doorHandle.rotation.z = Math.PI / 2; // Vertical orientation
            group.add(doorHandle);
          }

          // Toe kick
          const tkMat = new THREE.MeshStandardMaterial({ color: 0x0a0a0a, roughness: 0.95 });
          const tkBack = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.1, sbToeKickHeight - 0.02, 0.02),
            tkMat
          );
          tkBack.position.set(0, -h/2 + sbToeKickHeight/2, d/2 - sbToeKickRecess);
          group.add(tkBack);

          const tkFloor = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.1, 0.02, sbToeKickRecess - 0.02),
            tkMat
          );
          tkFloor.position.set(0, -h/2 + 0.01, d/2 - sbToeKickRecess/2);
          group.add(tkFloor);

          break;
        }

        case 'lazy-susan': {
          // LAZY SUSAN CORNER CABINET - L-shaped with rotating shelves inside
          // Similar to corner cabinet but with bi-fold doors revealing lazy susan mechanism

          // Use wood grain texture like other cabinets for consistency
          const lsCabinetFinish = el.cabinetFinish || 'wood-grain';
          const lsGrainType = el.grainType || 'oak';
          let lsWoodTexture = null;
          let lsBaseRoughness = 0.35;
          let lsBaseMetalness = 0.02;

          // Check for custom texture first
          if (textureUrl) {
            const textureLoader = new THREE.TextureLoader();
            try {
              lsWoodTexture = textureLoader.load(textureUrl);
              lsWoodTexture.wrapS = THREE.RepeatWrapping;
              lsWoodTexture.wrapT = THREE.RepeatWrapping;
              lsWoodTexture.repeat.set(2, 2);
            } catch (e) {
              lsWoodTexture = createWoodGrainTexture(color, 0.12, lsGrainType);
            }
            lsBaseRoughness = 0.3;
            lsBaseMetalness = 0.02;
          } else if (lsCabinetFinish === 'wood-grain') {
            lsWoodTexture = createWoodGrainTexture(color, 0.12, lsGrainType);
            lsBaseRoughness = 0.3;
            lsBaseMetalness = 0.02;
          } else if (lsCabinetFinish === 'painted') {
            lsWoodTexture = createWoodGrainTexture(color, 0.05, 'flat');
            lsBaseRoughness = 0.4;
            lsBaseMetalness = 0.01;
          } else if (lsCabinetFinish === 'matte') {
            lsWoodTexture = createWoodGrainTexture(color, 0.03, 'flat');
            lsBaseRoughness = 0.7;
            lsBaseMetalness = 0.0;
          } else if (lsCabinetFinish === 'gloss') {
            lsWoodTexture = createWoodGrainTexture(color, 0.02, 'flat');
            lsBaseRoughness = 0.1;
            lsBaseMetalness = 0.05;
          }

          const cabinetMat = new THREE.MeshStandardMaterial({
            color: color,
            map: lsWoodTexture,
            roughness: lsBaseRoughness,
            metalness: lsBaseMetalness,
            bumpScale: lsWoodTexture ? 0.002 : 0
          });
          const bodyMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.9 });
          const handleMat = new THREE.MeshStandardMaterial({ color: 0xc0c0c0, metalness: 0.8, roughness: 0.2 });
          const shelfMat = new THREE.MeshStandardMaterial({ color: 0x8B7355, roughness: 0.5 }); // Wood colored shelves
          const doorMat = new THREE.MeshStandardMaterial({
            color: color,
            map: lsWoodTexture,
            roughness: lsBaseRoughness,
            metalness: lsBaseMetalness,
            bumpScale: lsWoodTexture ? 0.002 : 0
          });

          // Cabinet dimensions
          const toeKickHeight = 0.33;
          const toeKickRecess = 0.25;
          const cabinetBodyHeight = h - toeKickHeight;
          const armDepth = 2; // Standard 24" arm depth
          const panelThickness = 0.06;

          const bodyYOffset = toeKickHeight / 2;

          // Create L-shaped cabinet body using THREE.Shape
          // Shape Y maps to -Z: Y=+d/2  Z=-d/2 (back), Y=-d/2  Z=+d/2 (front)
          const lsShape = new THREE.Shape();
          lsShape.moveTo(-w/2, d/2);                          // Back-left
          lsShape.lineTo(-w/2, -d/2);                         // Front-left
          lsShape.lineTo(-w/2 + armDepth, -d/2);              // Front of left arm
          lsShape.lineTo(-w/2 + armDepth, d/2 - armDepth);    // Inner corner
          lsShape.lineTo(w/2, d/2 - armDepth);                // Back arm inner, right
          lsShape.lineTo(w/2, d/2);                           // Back-right

          const lsExtrudeSettings = { depth: cabinetBodyHeight, bevelEnabled: false };
          const lsGeometry = new THREE.ExtrudeGeometry(lsShape, lsExtrudeSettings);
          lsGeometry.rotateX(-Math.PI / 2);
          lsGeometry.translate(0, -cabinetBodyHeight/2, 0);

          const cabinetBody = new THREE.Mesh(lsGeometry, cabinetMat);
          cabinetBody.position.y = bodyYOffset;
          group.add(cabinetBody);

          // Dark interior panels
          const backPanel = new THREE.Mesh(
            new THREE.BoxGeometry(w - armDepth - 0.1, cabinetBodyHeight - 0.1, panelThickness),
            bodyMat
          );
          backPanel.position.set(armDepth/2, bodyYOffset, -d/2 + armDepth - panelThickness/2);
          group.add(backPanel);

          const sidePanel = new THREE.Mesh(
            new THREE.BoxGeometry(panelThickness, cabinetBodyHeight - 0.1, d - armDepth - 0.1),
            bodyMat
          );
          sidePanel.position.set(-w/2 + armDepth - panelThickness/2, bodyYOffset, armDepth/2);
          group.add(sidePanel);

          // LAZY SUSAN ROTATING SHELVES - visible through diagonal opening
          const shelfRadius = Math.min(w, d) * 0.42;
          const shelfCenterX = 0;  // Center of cabinet opening
          const shelfCenterZ = 0;
          const numShelves = 2;

          // Center pole (chrome/metal)
          const poleMat = new THREE.MeshStandardMaterial({ color: 0x888888, metalness: 0.7, roughness: 0.3 });
          const centerPole = new THREE.Mesh(
            new THREE.CylinderGeometry(0.025, 0.025, cabinetBodyHeight - 0.2, 16),
            poleMat
          );
          centerPole.position.set(shelfCenterX, bodyYOffset, shelfCenterZ);
          group.add(centerPole);

          // Create kidney/pie-shaped lazy susan shelves
          for (let s = 0; s < numShelves; s++) {
            const shelfY = bodyYOffset - cabinetBodyHeight/2 + 0.5 + s * (cabinetBodyHeight * 0.4);

            // Create pie-shaped shelf (270 degrees)
            const pieShape = new THREE.Shape();
            const pieAngleStart = Math.PI * 0.75;  // Start at back-left
            const pieAngleEnd = Math.PI * 2.25;    // 270 degrees
            const segments = 32;

            pieShape.moveTo(0, 0);
            for (let i = 0; i <= segments; i++) {
              const angle = pieAngleStart + (pieAngleEnd - pieAngleStart) * (i / segments);
              pieShape.lineTo(Math.cos(angle) * shelfRadius, Math.sin(angle) * shelfRadius);
            }
            pieShape.lineTo(0, 0);

            const shelfGeom = new THREE.ExtrudeGeometry(pieShape, { depth: 0.025, bevelEnabled: false });
            shelfGeom.rotateX(-Math.PI / 2);

            const shelf = new THREE.Mesh(shelfGeom, shelfMat);
            shelf.position.set(shelfCenterX, shelfY, shelfCenterZ);
            shelf.rotation.y = Math.PI / 4; // Rotate to face opening
            group.add(shelf);

            // Shelf rim (edge)
            const rimMat = new THREE.MeshStandardMaterial({ color: 0x665544, roughness: 0.6 });
            const rimCurve = new THREE.EllipseCurve(0, 0, shelfRadius, shelfRadius, pieAngleStart, pieAngleEnd, false);
            const rimPoints = rimCurve.getPoints(32);
            const rimGeom = new THREE.BufferGeometry().setFromPoints(
              rimPoints.map(p => new THREE.Vector3(p.x, 0, p.y))
            );
            const rim = new THREE.Line(rimGeom, new THREE.LineBasicMaterial({ color: 0x444444 }));
            rim.position.set(shelfCenterX, shelfY + 0.015, shelfCenterZ);
            rim.rotation.y = Math.PI / 4;
            group.add(rim);
          }

          // DIAGONAL BI-FOLD DOORS (characteristic of lazy susan cabinets)
          const diagP1 = { x: -w/2 + armDepth, z: d/2 };
          const diagP2 = { x: w/2, z: -d/2 + armDepth };
          const diagDoorWidth = Math.sqrt(Math.pow(diagP2.x - diagP1.x, 2) + Math.pow(diagP1.z - diagP2.z, 2));
          const doorHeight = cabinetBodyHeight - 0.15;
          const halfDoorWidth = (diagDoorWidth - 0.1) / 2;

          const diagCenterX = (diagP1.x + diagP2.x) / 2;
          const diagCenterZ = (diagP1.z + diagP2.z) / 2;

          // Create two doors (bi-fold style)
          for (let doorIdx = 0; doorIdx < 2; doorIdx++) {
            const doorGroup = new THREE.Group();

            // Door panel
            const doorPanel = new THREE.Mesh(
              new THREE.BoxGeometry(halfDoorWidth, doorHeight, panelThickness),
              doorMat
            );
            doorGroup.add(doorPanel);

            // Shaker inset
            const insetW = halfDoorWidth - 0.15;
            const insetH = doorHeight - 0.2;
            const inset = new THREE.Mesh(
              new THREE.BoxGeometry(insetW, insetH, 0.02),
              new THREE.MeshStandardMaterial({ color: adjustColorBrightness(color, -10), roughness: 0.5 })
            );
            inset.position.z = panelThickness/2 + 0.01;
            doorGroup.add(inset);

            // Modern bar handle
            const handleLen = Math.min(doorHeight * 0.3, 0.2);
            const lsHandleFinish = el.handleFinish || 'brushed-nickel';
            const handle = createModernBarHandle(handleLen, lsHandleFinish);
            const handleXPos = doorIdx === 0 ? halfDoorWidth/2 - 0.1 : -halfDoorWidth/2 + 0.1;
            handle.position.set(handleXPos, 0, panelThickness/2 + 0.04);
            handle.rotation.z = Math.PI / 2; // Vertical
            doorGroup.add(handle);

            // Position door
            const doorXOffset = doorIdx === 0 ? -halfDoorWidth/2 - 0.02 : halfDoorWidth/2 + 0.02;
            doorGroup.rotation.y = Math.PI / 4;

            // Calculate position along diagonal
            const offsetDir = doorIdx === 0 ? -1 : 1;
            const offsetAmount = halfDoorWidth/2 + 0.02;
            doorGroup.position.set(
              diagCenterX + offsetDir * offsetAmount * Math.cos(Math.PI/4) * 0.5,
              bodyYOffset,
              diagCenterZ + offsetDir * offsetAmount * Math.sin(Math.PI/4) * 0.5
            );
            group.add(doorGroup);
          }

          // TOE KICK (same orientation as body, inset by recess)
          const tkMat = new THREE.MeshStandardMaterial({ color: 0x080808, roughness: 0.95 });
          const tkHeight = toeKickHeight - 0.02;

          const tkShape = new THREE.Shape();
          tkShape.moveTo(-w/2 + toeKickRecess, d/2 - toeKickRecess);
          tkShape.lineTo(-w/2 + toeKickRecess, -d/2 + toeKickRecess);
          tkShape.lineTo(-w/2 + armDepth - toeKickRecess, -d/2 + toeKickRecess);
          tkShape.lineTo(-w/2 + armDepth - toeKickRecess, d/2 - armDepth + toeKickRecess);
          tkShape.lineTo(w/2 - toeKickRecess, d/2 - armDepth + toeKickRecess);
          tkShape.lineTo(w/2 - toeKickRecess, d/2 - toeKickRecess);
          tkShape.closePath();

          const tkExtrudeSettings = { depth: tkHeight, bevelEnabled: false };
          const tkGeometry = new THREE.ExtrudeGeometry(tkShape, tkExtrudeSettings);
          tkGeometry.rotateX(-Math.PI / 2);
          tkGeometry.translate(0, -h/2, 0);

          const toeKick = new THREE.Mesh(tkGeometry, tkMat);
          group.add(toeKick);

          // Floor shadow
          const tkFloor = new THREE.Mesh(
            new THREE.PlaneGeometry(w, d),
            new THREE.MeshStandardMaterial({ color: 0x0a0a0a, roughness: 1 })
          );
          tkFloor.rotation.x = -Math.PI / 2;
          tkFloor.position.y = -h/2 + 0.01;
          group.add(tkFloor);

          break;
        }

        case 'corner-cabinet': {
          // L-SHAPED CORNER CABINET - Sits in corner with diagonal door
          // Standard corner cabinet: 36" x 36" footprint, arms are 24" deep
          // Cabinet sits in back-left corner with diagonal door facing front-right

          // Use wood grain texture like other cabinets for consistency
          const ccCabinetFinish = el.cabinetFinish || 'wood-grain';
          const ccGrainType = el.grainType || 'oak';
          let ccWoodTexture = null;
          let ccBaseRoughness = 0.35;
          let ccBaseMetalness = 0.02;

          // Check for custom texture first
          if (textureUrl) {
            const textureLoader = new THREE.TextureLoader();
            try {
              ccWoodTexture = textureLoader.load(textureUrl);
              ccWoodTexture.wrapS = THREE.RepeatWrapping;
              ccWoodTexture.wrapT = THREE.RepeatWrapping;
              ccWoodTexture.repeat.set(2, 2);
            } catch (e) {
              ccWoodTexture = createWoodGrainTexture(color, 0.12, ccGrainType);
            }
            ccBaseRoughness = 0.3;
            ccBaseMetalness = 0.02;
          } else if (ccCabinetFinish === 'wood-grain') {
            ccWoodTexture = createWoodGrainTexture(color, 0.12, ccGrainType);
            ccBaseRoughness = 0.3;
            ccBaseMetalness = 0.02;
          } else if (ccCabinetFinish === 'painted') {
            ccWoodTexture = createWoodGrainTexture(color, 0.05, 'flat');
            ccBaseRoughness = 0.4;
            ccBaseMetalness = 0.01;
          } else if (ccCabinetFinish === 'matte') {
            ccWoodTexture = createWoodGrainTexture(color, 0.03, 'flat');
            ccBaseRoughness = 0.7;
            ccBaseMetalness = 0.0;
          } else if (ccCabinetFinish === 'gloss') {
            ccWoodTexture = createWoodGrainTexture(color, 0.02, 'flat');
            ccBaseRoughness = 0.1;
            ccBaseMetalness = 0.05;
          }

          const cabinetMat = new THREE.MeshStandardMaterial({
            color: color,
            map: ccWoodTexture,
            roughness: ccBaseRoughness,
            metalness: ccBaseMetalness,
            bumpScale: ccWoodTexture ? 0.002 : 0
          });
          const bodyMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.9 });
          const shelfMat = new THREE.MeshStandardMaterial({ color: 0x8B7355, roughness: 0.5 }); // Wood colored shelves
          const doorMat = new THREE.MeshStandardMaterial({
            color: color,
            map: ccWoodTexture,
            roughness: ccBaseRoughness,
            metalness: ccBaseMetalness,
            bumpScale: ccWoodTexture ? 0.002 : 0
          });

          // Cabinet dimensions
          const toeKickHeight = 0.33; // 4" toe kick
          const toeKickRecess = 0.25; // 3" recess
          const cabinetBodyHeight = h - toeKickHeight;
          const armDepth = 2; // Standard 24" arm depth
          const panelThickness = 0.06; // 3/4" panels

          // Y offset for body (centered on cabinet body, not including toe kick)
          const bodyYOffset = toeKickHeight / 2;

          // Create L-shaped cabinet using THREE.Shape for proper geometry
          // Shape Y maps to -Z after rotateX(-PI/2), so:
          //   shape Y=+d/2  world Z=-d/2 (back wall)
          //   shape Y=-d/2  world Z=+d/2 (front, toward camera)
          const lShape = new THREE.Shape();
          lShape.moveTo(-w/2, d/2);                          // Back-left corner (into walls)
          lShape.lineTo(-w/2, -d/2);                         // Front-left (along left wall)
          lShape.lineTo(-w/2 + armDepth, -d/2);              // Front of left arm
          lShape.lineTo(-w/2 + armDepth, d/2 - armDepth);    // Inner corner
          lShape.lineTo(w/2, d/2 - armDepth);                // Back arm inner edge, right
          lShape.lineTo(w/2, d/2);                           // Back-right corner

          // Extrude L-shape for cabinet body
          const extrudeSettings = {
            depth: cabinetBodyHeight,
            bevelEnabled: false
          };
          const lGeometry = new THREE.ExtrudeGeometry(lShape, extrudeSettings);
          lGeometry.rotateX(-Math.PI / 2); // Rotate to stand upright
          lGeometry.translate(0, -cabinetBodyHeight/2, 0); // Center vertically

          const cabinetBody = new THREE.Mesh(lGeometry, cabinetMat);
          cabinetBody.position.y = bodyYOffset;
          cabinetBody.castShadow = true;
          group.add(cabinetBody);

          // Dark interior back panels (visible through diagonal opening)
          const backPanel = new THREE.Mesh(
            new THREE.BoxGeometry(w - armDepth - 0.1, cabinetBodyHeight - 0.1, panelThickness),
            bodyMat
          );
          backPanel.position.set(armDepth/2, bodyYOffset, -d/2 + armDepth - panelThickness/2);
          group.add(backPanel);

          // Side interior panel
          const sidePanel = new THREE.Mesh(
            new THREE.BoxGeometry(panelThickness, cabinetBodyHeight - 0.1, d - armDepth - 0.1),
            bodyMat
          );
          sidePanel.position.set(-w/2 + armDepth - panelThickness/2, bodyYOffset, armDepth/2);
          group.add(sidePanel);

          // INTERIOR SHELVES - triangular/pie-shaped shelves visible through door
          const shelfRadius = Math.min(w, d) * 0.4;
          const shelfCenterX = 0;
          const shelfCenterZ = 0;
          const numShelves = 2;

          for (let s = 0; s < numShelves; s++) {
            const shelfY = bodyYOffset - cabinetBodyHeight/2 + 0.4 + s * (cabinetBodyHeight * 0.35);

            // Create pie-shaped shelf (270 degrees, open toward diagonal door)
            const pieShape = new THREE.Shape();
            const pieAngleStart = Math.PI * 0.75;  // Start at back-left
            const pieAngleEnd = Math.PI * 2.25;    // 270 degrees
            const segments = 24;

            pieShape.moveTo(0, 0);
            for (let i = 0; i <= segments; i++) {
              const angle = pieAngleStart + (pieAngleEnd - pieAngleStart) * (i / segments);
              pieShape.lineTo(Math.cos(angle) * shelfRadius, Math.sin(angle) * shelfRadius);
            }
            pieShape.lineTo(0, 0);

            const shelfGeom = new THREE.ExtrudeGeometry(pieShape, { depth: 0.02, bevelEnabled: false });
            shelfGeom.rotateX(-Math.PI / 2);

            const shelf = new THREE.Mesh(shelfGeom, shelfMat);
            shelf.position.set(shelfCenterX, shelfY, shelfCenterZ);
            shelf.rotation.y = Math.PI / 4; // Rotate to face diagonal opening
            shelf.castShadow = true;
            group.add(shelf);
          }

          // DIAGONAL DOOR - angled at 45 across the open corner with bi-fold style
          const diagP1 = { x: -w/2 + armDepth, z: d/2 };  // End of left arm
          const diagP2 = { x: w/2, z: -d/2 + armDepth };  // End of back arm

          const diagDoorWidth = Math.sqrt(Math.pow(diagP2.x - diagP1.x, 2) + Math.pow(diagP1.z - diagP2.z, 2));
          const doorHeight = cabinetBodyHeight - 0.15;
          const halfDoorWidth = (diagDoorWidth - 0.12) / 2;

          const diagCenterX = (diagP1.x + diagP2.x) / 2;
          const diagCenterZ = (diagP1.z + diagP2.z) / 2;

          // Create two bi-fold doors
          for (let doorIdx = 0; doorIdx < 2; doorIdx++) {
            const doorGroup = new THREE.Group();

            // Door panel with proper thickness
            const doorPanel = new THREE.Mesh(
              new THREE.BoxGeometry(halfDoorWidth, doorHeight, panelThickness),
              doorMat
            );
            doorPanel.castShadow = true;
            doorGroup.add(doorPanel);

            // Shaker inset panel
            const insetW = halfDoorWidth - 0.18;
            const insetH = doorHeight - 0.22;
            const insetMat = new THREE.MeshStandardMaterial({
              color: adjustColorBrightness(color, -10),
              roughness: 0.5,
              map: ccWoodTexture
            });
            const inset = new THREE.Mesh(
              new THREE.BoxGeometry(insetW, insetH, 0.025),
              insetMat
            );
            inset.position.z = panelThickness/2 + 0.012;
            doorGroup.add(inset);

            // Shaker frame grooves (more visible)
            const grooveMat = new THREE.MeshStandardMaterial({
              color: adjustColorBrightness(color, -30),
              roughness: 0.7
            });
            const grooveThick = 0.015;

            // Top frame
            const topFrame = new THREE.Mesh(
              new THREE.BoxGeometry(insetW + 0.04, grooveThick, 0.008),
              grooveMat
            );
            topFrame.position.set(0, insetH/2 + 0.02, panelThickness/2 + 0.02);
            doorGroup.add(topFrame);

            // Bottom frame
            const botFrame = new THREE.Mesh(
              new THREE.BoxGeometry(insetW + 0.04, grooveThick, 0.008),
              grooveMat
            );
            botFrame.position.set(0, -insetH/2 - 0.02, panelThickness/2 + 0.02);
            doorGroup.add(botFrame);

            // Left frame
            const leftFrame = new THREE.Mesh(
              new THREE.BoxGeometry(grooveThick, insetH + 0.04, 0.008),
              grooveMat
            );
            leftFrame.position.set(-insetW/2 - 0.02, 0, panelThickness/2 + 0.02);
            doorGroup.add(leftFrame);

            // Right frame
            const rightFrame = new THREE.Mesh(
              new THREE.BoxGeometry(grooveThick, insetH + 0.04, 0.008),
              grooveMat
            );
            rightFrame.position.set(insetW/2 + 0.02, 0, panelThickness/2 + 0.02);
            doorGroup.add(rightFrame);

            // Modern bar handle
            const handleLen = Math.min(doorHeight * 0.25, 0.18);
            const ccHandleFinish = el.handleFinish || 'brushed-nickel';
            const handle = createModernBarHandle(handleLen, ccHandleFinish);
            const handleXPos = doorIdx === 0 ? halfDoorWidth/2 - 0.12 : -halfDoorWidth/2 + 0.12;
            handle.position.set(handleXPos, 0, panelThickness/2 + 0.045);
            handle.rotation.z = Math.PI / 2; // Vertical
            doorGroup.add(handle);

            // Position each door half
            doorGroup.rotation.y = Math.PI / 4;
            const offsetDir = doorIdx === 0 ? -1 : 1;
            const offsetAmount = halfDoorWidth/2 + 0.03;
            doorGroup.position.set(
              diagCenterX + offsetDir * offsetAmount * Math.cos(Math.PI/4) * 0.5,
              bodyYOffset,
              diagCenterZ + offsetDir * offsetAmount * Math.sin(Math.PI/4) * 0.5
            );
            group.add(doorGroup);
          }

          // TOE KICK - L-shaped recessed base
          const tkMat = new THREE.MeshStandardMaterial({ color: 0x080808, roughness: 0.95 });
          const tkHeight = toeKickHeight - 0.02;

          const tkShape = new THREE.Shape();
          tkShape.moveTo(-w/2 + toeKickRecess, d/2 - toeKickRecess);
          tkShape.lineTo(-w/2 + toeKickRecess, -d/2 + toeKickRecess);
          tkShape.lineTo(-w/2 + armDepth - toeKickRecess, -d/2 + toeKickRecess);
          tkShape.lineTo(-w/2 + armDepth - toeKickRecess, d/2 - armDepth + toeKickRecess);
          tkShape.lineTo(w/2 - toeKickRecess, d/2 - armDepth + toeKickRecess);
          tkShape.lineTo(w/2 - toeKickRecess, d/2 - toeKickRecess);
          tkShape.closePath();

          const tkExtrudeSettings = { depth: tkHeight, bevelEnabled: false };
          const tkGeometry = new THREE.ExtrudeGeometry(tkShape, tkExtrudeSettings);
          tkGeometry.rotateX(-Math.PI / 2);
          tkGeometry.translate(0, -h/2, 0);

          const toeKick = new THREE.Mesh(tkGeometry, tkMat);
          group.add(toeKick);

          // Floor shadow
          const tkFloor = new THREE.Mesh(
            new THREE.PlaneGeometry(w, d),
            new THREE.MeshStandardMaterial({ color: 0x0a0a0a, roughness: 1 })
          );
          tkFloor.rotation.x = -Math.PI / 2;
          tkFloor.position.y = -h/2 + 0.01;
          group.add(tkFloor);

          break;
        }

        case 'tall-cabinet': {
          // Tall pantry cabinet with two door sections
          // Use wood grain texture like other cabinets for consistency
          const tallCabinetFinish = el.cabinetFinish || 'wood-grain';
          const tallGrainType = el.grainType || 'oak';
          let tallWoodTexture = null;
          let tallBaseRoughness = 0.35;
          let tallBaseMetalness = 0.02;

          // Check for custom texture first
          if (textureUrl) {
            const textureLoader = new THREE.TextureLoader();
            try {
              tallWoodTexture = textureLoader.load(textureUrl);
              tallWoodTexture.wrapS = THREE.RepeatWrapping;
              tallWoodTexture.wrapT = THREE.RepeatWrapping;
              tallWoodTexture.repeat.set(2, 2);
            } catch (e) {
              tallWoodTexture = createWoodGrainTexture(color, 0.12, tallGrainType);
            }
            tallBaseRoughness = 0.3;
            tallBaseMetalness = 0.02;
          } else if (tallCabinetFinish === 'wood-grain') {
            tallWoodTexture = createWoodGrainTexture(color, 0.12, tallGrainType);
            tallBaseRoughness = 0.3;
            tallBaseMetalness = 0.02;
          } else if (tallCabinetFinish === 'painted') {
            tallWoodTexture = createWoodGrainTexture(color, 0.05, 'flat');
            tallBaseRoughness = 0.4;
            tallBaseMetalness = 0.01;
          } else if (tallCabinetFinish === 'matte') {
            tallWoodTexture = createWoodGrainTexture(color, 0.03, 'flat');
            tallBaseRoughness = 0.7;
            tallBaseMetalness = 0.0;
          } else if (tallCabinetFinish === 'gloss') {
            tallWoodTexture = createWoodGrainTexture(color, 0.02, 'flat');
            tallBaseRoughness = 0.1;
            tallBaseMetalness = 0.05;
          }

          // Main cabinet body (dark interior)
          const bodyMat = new THREE.MeshStandardMaterial({
            color: 0x2a2a2a,
            roughness: 0.8
          });
          const body = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.08, h - 0.08, d - 0.1),
            bodyMat
          );
          body.position.z = -0.02;
          group.add(body);

          // Cabinet face material with wood grain texture
          const faceMat = new THREE.MeshStandardMaterial({
            color: color,
            map: tallWoodTexture,
            roughness: tallBaseRoughness,
            metalness: tallBaseMetalness,
            bumpScale: tallWoodTexture ? 0.002 : 0
          });

          // Door calculation
          const numDoors = Math.max(1, Math.round(w / 1.5));
          const doorGap = 0.03;
          const totalGaps = doorGap * (numDoors + 1);
          const doorWidth = (w - totalGaps) / numDoors;
          const doorHeight = h - doorGap * 2;

          for (let i = 0; i < numDoors; i++) {
            // Door panel (main)
            const door = new THREE.Mesh(
              new THREE.BoxGeometry(doorWidth, doorHeight, 0.06),
              faceMat
            );
            const doorX = -w/2 + doorGap + doorWidth/2 + i * (doorWidth + doorGap);
            door.position.set(doorX, 0, d/2);
            group.add(door);

            // SHAKER FRAME DETAIL
            const frameW = 0.1;
            const frameD = 0.02;
            const frameMat = new THREE.MeshStandardMaterial({
              color: color,
              roughness: 0.3,
              metalness: 0.01
            });

            // Top rail
            const topRail = new THREE.Mesh(
              new THREE.BoxGeometry(doorWidth - 0.04, frameW, frameD),
              frameMat
            );
            topRail.position.set(doorX, doorHeight/2 - frameW/2 - 0.02, d/2 + 0.04);
            group.add(topRail);

            // Bottom rail
            const bottomRail = new THREE.Mesh(
              new THREE.BoxGeometry(doorWidth - 0.04, frameW, frameD),
              frameMat
            );
            bottomRail.position.set(doorX, -doorHeight/2 + frameW/2 + 0.02, d/2 + 0.04);
            group.add(bottomRail);

            // Left stile
            const leftStile = new THREE.Mesh(
              new THREE.BoxGeometry(frameW, doorHeight - frameW * 2 - 0.04, frameD),
              frameMat
            );
            leftStile.position.set(doorX - doorWidth/2 + frameW/2 + 0.02, 0, d/2 + 0.04);
            group.add(leftStile);

            // Right stile
            const rightStile = new THREE.Mesh(
              new THREE.BoxGeometry(frameW, doorHeight - frameW * 2 - 0.04, frameD),
              frameMat
            );
            rightStile.position.set(doorX + doorWidth/2 - frameW/2 - 0.02, 0, d/2 + 0.04);
            group.add(rightStile);

            // Recessed center panel
            const panelMat = new THREE.MeshStandardMaterial({
              color: color,
              roughness: 0.45
            });
            const panelWidth = doorWidth - frameW * 2 - 0.08;
            const panelHeight = doorHeight - frameW * 2 - 0.08;
            const centerPanel = new THREE.Mesh(
              new THREE.BoxGeometry(panelWidth, panelHeight, 0.015),
              panelMat
            );
            centerPanel.position.set(doorX, 0, d/2 + 0.02);
            group.add(centerPanel);

            // Modern bar handle with standoffs
            const handleY = el.type === 'wall-cabinet' ? -doorHeight * 0.25 : doorHeight * 0.25;
            const handleSide = (i < numDoors / 2) ? 1 : -1;
            const handleX = doorX + handleSide * (doorWidth/2 - 0.15);

            const tallHandleLen = Math.min(doorHeight * 0.2, 0.35);
            const tallHandleFinish = el.handleFinish || 'brushed-nickel';
            const pull = createModernBarHandle(tallHandleLen, tallHandleFinish);
            pull.position.set(handleX, handleY, d/2 + 0.095);
            pull.rotation.z = Math.PI / 2; // Vertical orientation
            group.add(pull);
          }

          // Toe kick for tall cabinet - proper recessed void
          const toeKickHeight = 0.33;
          const toeKickRecess = 0.25;

          // Toe kick back panel (visible back of recess)
          const tkBackMat = new THREE.MeshStandardMaterial({ color: 0x0a0a0a, roughness: 0.95 });
          const tkBack = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.1, toeKickHeight - 0.02, 0.02),
            tkBackMat
          );
          tkBack.position.set(0, -h/2 + toeKickHeight/2, d/2 - toeKickRecess);
          group.add(tkBack);

          // Toe kick bottom (floor of recess)
          const tkBottom = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.1, 0.02, toeKickRecess - 0.02),
            tkBackMat
          );
          tkBottom.position.set(0, -h/2 + 0.01, d/2 - toeKickRecess/2);
          group.add(tkBottom);

          // Left side panel of toe kick recess
          const tkLeft = new THREE.Mesh(
            new THREE.BoxGeometry(0.02, toeKickHeight - 0.02, toeKickRecess),
            tkBackMat
          );
          tkLeft.position.set(-w/2 + 0.05, -h/2 + toeKickHeight/2, d/2 - toeKickRecess/2);
          group.add(tkLeft);

          // Right side panel of toe kick recess
          const tkRight = new THREE.Mesh(
            new THREE.BoxGeometry(0.02, toeKickHeight - 0.02, toeKickRecess),
            tkBackMat
          );
          tkRight.position.set(w/2 - 0.05, -h/2 + toeKickHeight/2, d/2 - toeKickRecess/2);
          group.add(tkRight);

          // Cabinet overhang lip (bottom edge of cabinet above toe kick)
          const lipMat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.4 });
          const lip = new THREE.Mesh(
            new THREE.BoxGeometry(w, 0.03, 0.04),
            lipMat
          );
          lip.position.set(0, -h/2 + toeKickHeight + 0.015, d/2 - 0.02);
          group.add(lip);
          break;
        }

        case 'fridge-cabinet': {
          // Fridge cabinet - enclosure that goes up and over refrigerator
          // Standard dimensions: 84" tall (7ft), with 12" cabinet above, ~68" fridge opening, 4" toe kick
          // The fridge cabinet includes an integrated refrigerator in the opening

          // Use wood grain texture for cabinet parts
          const fcCabinetFinish = el.cabinetFinish || 'wood-grain';
          const fcGrainType = el.grainType || 'oak';
          let fcWoodTexture = null;
          let fcBaseRoughness = 0.35;

          // Check for custom texture first
          if (textureUrl) {
            const textureLoader = new THREE.TextureLoader();
            try {
              fcWoodTexture = textureLoader.load(textureUrl);
              fcWoodTexture.wrapS = THREE.RepeatWrapping;
              fcWoodTexture.wrapT = THREE.RepeatWrapping;
              fcWoodTexture.repeat.set(2, 2);
            } catch (e) {
              fcWoodTexture = createWoodGrainTexture(color, 0.12, fcGrainType);
            }
            fcBaseRoughness = 0.3;
          } else if (fcCabinetFinish === 'wood-grain') {
            fcWoodTexture = createWoodGrainTexture(color, 0.12, fcGrainType);
            fcBaseRoughness = 0.3;
          } else if (fcCabinetFinish === 'painted' || fcCabinetFinish === 'matte' || fcCabinetFinish === 'gloss') {
            fcWoodTexture = createWoodGrainTexture(color, 0.03, 'flat');
            fcBaseRoughness = fcCabinetFinish === 'gloss' ? 0.1 : (fcCabinetFinish === 'matte' ? 0.7 : 0.4);
          }

          const fridgeCabMat = new THREE.MeshStandardMaterial({
            color: color,
            map: fcWoodTexture,
            roughness: fcBaseRoughness,
            metalness: 0.02,
            bumpScale: fcWoodTexture ? 0.002 : 0
          });

          // Dimensions - use standard building proportions
          const panelWidth = 0.125;  // 1.5" side panel thickness
          const toeKickHeight = 0.33;  // 4" toe kick (standard)
          const topCabinetH = 1.0;  // 12" cabinet above fridge (fixed size)
          const fridgeOpeningH = h - topCabinetH - toeKickHeight;  // Remaining height for fridge
          const fridgeOpeningW = w - panelWidth * 2;  // Width of fridge opening

          // Dark interior material for opening
          const interiorMat = new THREE.MeshStandardMaterial({
            color: 0x1a1a1a,
            roughness: 0.9
          });

          // === LEFT SIDE PANEL ===
          const leftPanel = new THREE.Mesh(
            new THREE.BoxGeometry(panelWidth, h - toeKickHeight, d),
            fridgeCabMat
          );
          leftPanel.position.set(-w/2 + panelWidth/2, toeKickHeight/2, 0);
          group.add(leftPanel);

          // === RIGHT SIDE PANEL ===
          const rightPanel = new THREE.Mesh(
            new THREE.BoxGeometry(panelWidth, h - toeKickHeight, d),
            fridgeCabMat
          );
          rightPanel.position.set(w/2 - panelWidth/2, toeKickHeight/2, 0);
          group.add(rightPanel);

          // === TOP CABINET SECTION (above fridge opening) ===
          const topCabinet = new THREE.Mesh(
            new THREE.BoxGeometry(fridgeOpeningW, topCabinetH, d),
            fridgeCabMat
          );
          topCabinet.position.set(0, h/2 - topCabinetH/2, 0);
          group.add(topCabinet);

          // === CABINET DOOR ON TOP SECTION ===
          const doorMat = new THREE.MeshStandardMaterial({
            color: color,
            map: fcWoodTexture,
            roughness: fcBaseRoughness,
            metalness: 0.02
          });

          const doorGap = 0.03;
          const doorW = fridgeOpeningW - doorGap * 2;
          const doorH = topCabinetH - doorGap * 2;

          // Door panel
          const topDoor = new THREE.Mesh(
            new THREE.BoxGeometry(doorW, doorH, 0.06),
            doorMat
          );
          topDoor.position.set(0, h/2 - topCabinetH/2, d/2);
          group.add(topDoor);

          // Shaker frame detail on door
          const frameW = 0.08;
          const frameD = 0.02;
          const frameMat = new THREE.MeshStandardMaterial({
            color: color,
            map: fcWoodTexture,
            roughness: fcBaseRoughness - 0.02,
            metalness: 0.01
          });

          // Top rail
          const topRail = new THREE.Mesh(
            new THREE.BoxGeometry(doorW - 0.04, frameW, frameD),
            frameMat
          );
          topRail.position.set(0, h/2 - doorGap - frameW/2 - 0.02, d/2 + 0.04);
          group.add(topRail);

          // Bottom rail
          const bottomRail = new THREE.Mesh(
            new THREE.BoxGeometry(doorW - 0.04, frameW, frameD),
            frameMat
          );
          bottomRail.position.set(0, h/2 - topCabinetH + doorGap + frameW/2 + 0.02, d/2 + 0.04);
          group.add(bottomRail);

          // Left stile
          const leftStile = new THREE.Mesh(
            new THREE.BoxGeometry(frameW, doorH - frameW * 2 - 0.04, frameD),
            frameMat
          );
          leftStile.position.set(-doorW/2 + frameW/2 + 0.02, h/2 - topCabinetH/2, d/2 + 0.04);
          group.add(leftStile);

          // Right stile
          const rightStile = new THREE.Mesh(
            new THREE.BoxGeometry(frameW, doorH - frameW * 2 - 0.04, frameD),
            frameMat
          );
          rightStile.position.set(doorW/2 - frameW/2 - 0.02, h/2 - topCabinetH/2, d/2 + 0.04);
          group.add(rightStile);

          // Door handle (centered, horizontal bar)
          const handleMat = new THREE.MeshStandardMaterial({
            color: 0xAAAAAA,
            roughness: 0.15,
            metalness: 0.9
          });
          const handleLength = Math.min(0.3, doorW * 0.6);
          const handle = new THREE.Mesh(
            new THREE.CylinderGeometry(0.012, 0.012, handleLength, 8),
            handleMat
          );
          handle.rotation.z = Math.PI / 2;  // Horizontal
          handle.position.set(0, h/2 - topCabinetH + doorGap + doorH * 0.3, d/2 + 0.1);
          group.add(handle);

          // Handle standoffs
          const standoffMat = new THREE.MeshStandardMaterial({
            color: 0x888888,
            roughness: 0.2,
            metalness: 0.85
          });
          [-handleLength/2 + 0.04, handleLength/2 - 0.04].forEach(xOffset => {
            const standoff = new THREE.Mesh(
              new THREE.CylinderGeometry(0.015, 0.015, 0.035, 8),
              standoffMat
            );
            standoff.rotation.x = Math.PI / 2;
            standoff.position.set(xOffset, h/2 - topCabinetH + doorGap + doorH * 0.3, d/2 + 0.08);
            group.add(standoff);
          });

          // === FRIDGE OPENING (dark recess) ===
          // Back panel of fridge space
          const fridgeBack = new THREE.Mesh(
            new THREE.BoxGeometry(fridgeOpeningW - 0.02, fridgeOpeningH, 0.02),
            interiorMat
          );
          fridgeBack.position.set(0, -h/2 + toeKickHeight + fridgeOpeningH/2, -d/2 + 0.02);
          group.add(fridgeBack);

          // Bottom of fridge space (above toe kick)
          const fridgeBottom = new THREE.Mesh(
            new THREE.BoxGeometry(fridgeOpeningW - 0.02, 0.02, d - 0.1),
            interiorMat
          );
          fridgeBottom.position.set(0, -h/2 + toeKickHeight + 0.01, 0);
          group.add(fridgeBottom);

          // === INTEGRATED REFRIGERATOR IN OPENING ===
          // Render a built-in refrigerator inside the cabinet opening
          const fridgeW = fridgeOpeningW - 0.1;  // Slightly smaller than opening
          const fridgeH = fridgeOpeningH - 0.1;  // Slightly smaller than opening
          const fridgeD = d - 0.15;  // Leave small gap at back

          const fridgeMat = new THREE.MeshStandardMaterial({
            color: 0xD5D5D5,
            roughness: 0.25,
            metalness: 0.55
          });

          // Main fridge body
          const fridgeBody = new THREE.Mesh(
            new THREE.BoxGeometry(fridgeW, fridgeH, fridgeD),
            fridgeMat
          );
          fridgeBody.position.set(0, -h/2 + toeKickHeight + fridgeOpeningH/2, 0.05);
          group.add(fridgeBody);

          // Upper doors (French style - two doors) - 65% of fridge height
          const fridgeDoorMat = new THREE.MeshStandardMaterial({
            color: 0xE0E0E0,
            roughness: 0.2,
            metalness: 0.6
          });

          const upperDoorH = fridgeH * 0.65;
          const fridgeDoorW = (fridgeW - 0.08) / 2;
          const fridgeCenterY = -h/2 + toeKickHeight + fridgeOpeningH/2;

          // Left upper door
          const leftFridgeDoor = new THREE.Mesh(
            new THREE.BoxGeometry(fridgeDoorW, upperDoorH, 0.04),
            fridgeDoorMat
          );
          leftFridgeDoor.position.set(-fridgeDoorW/2 - 0.02, fridgeCenterY + fridgeH * 0.15, fridgeD/2 + 0.07);
          group.add(leftFridgeDoor);

          // Right upper door
          const rightFridgeDoor = new THREE.Mesh(
            new THREE.BoxGeometry(fridgeDoorW, upperDoorH, 0.04),
            fridgeDoorMat
          );
          rightFridgeDoor.position.set(fridgeDoorW/2 + 0.02, fridgeCenterY + fridgeH * 0.15, fridgeD/2 + 0.07);
          group.add(rightFridgeDoor);

          // Freezer drawer - 28% of fridge height
          const freezerDrawer = new THREE.Mesh(
            new THREE.BoxGeometry(fridgeW - 0.08, fridgeH * 0.28, 0.04),
            fridgeDoorMat
          );
          freezerDrawer.position.set(0, fridgeCenterY - fridgeH * 0.33, fridgeD/2 + 0.07);
          group.add(freezerDrawer);

          // Fridge handles
          const fridgeHandleMat = new THREE.MeshStandardMaterial({
            color: 0xA0A0A0,
            roughness: 0.15,
            metalness: 0.9
          });

          // Left handle
          const leftFridgeHandle = new THREE.Mesh(
            new THREE.BoxGeometry(0.035, upperDoorH * 0.5, 0.05),
            fridgeHandleMat
          );
          leftFridgeHandle.position.set(-0.06, fridgeCenterY + fridgeH * 0.15, fridgeD/2 + 0.12);
          group.add(leftFridgeHandle);

          // Right handle
          const rightFridgeHandle = new THREE.Mesh(
            new THREE.BoxGeometry(0.035, upperDoorH * 0.5, 0.05),
            fridgeHandleMat
          );
          rightFridgeHandle.position.set(0.06, fridgeCenterY + fridgeH * 0.15, fridgeD/2 + 0.12);
          group.add(rightFridgeHandle);

          // Freezer handle
          const freezerFridgeHandle = new THREE.Mesh(
            new THREE.BoxGeometry(fridgeW * 0.5, 0.035, 0.05),
            fridgeHandleMat
          );
          freezerFridgeHandle.position.set(0, fridgeCenterY - fridgeH * 0.22, fridgeD/2 + 0.12);
          group.add(freezerFridgeHandle);

          // Water/ice dispenser
          const dispenserMat = new THREE.MeshStandardMaterial({
            color: 0x2a2a2a,
            roughness: 0.3
          });
          const dispenser = new THREE.Mesh(
            new THREE.BoxGeometry(0.25, 0.2, 0.02),
            dispenserMat
          );
          dispenser.position.set(0, fridgeCenterY + fridgeH * 0.25, fridgeD/2 + 0.1);
          group.add(dispenser);

          // === TOE KICK ===
          const tkMat = new THREE.MeshStandardMaterial({ color: 0x0a0a0a, roughness: 0.95 });
          const toeKickRecess = 0.2;

          // Toe kick back
          const tkBack = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.1, toeKickHeight - 0.02, 0.02),
            tkMat
          );
          tkBack.position.set(0, -h/2 + toeKickHeight/2, d/2 - toeKickRecess);
          group.add(tkBack);

          // Toe kick bottom
          const tkBottom = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.1, 0.02, toeKickRecess - 0.02),
            tkMat
          );
          tkBottom.position.set(0, -h/2 + 0.01, d/2 - toeKickRecess/2);
          group.add(tkBottom);

          // Left toe kick side
          const tkLeft = new THREE.Mesh(
            new THREE.BoxGeometry(0.02, toeKickHeight - 0.02, toeKickRecess),
            tkMat
          );
          tkLeft.position.set(-w/2 + 0.05, -h/2 + toeKickHeight/2, d/2 - toeKickRecess/2);
          group.add(tkLeft);

          // Right toe kick side
          const tkRight = new THREE.Mesh(
            new THREE.BoxGeometry(0.02, toeKickHeight - 0.02, toeKickRecess),
            tkMat
          );
          tkRight.position.set(w/2 - 0.05, -h/2 + toeKickHeight/2, d/2 - toeKickRecess/2);
          group.add(tkRight);

          // Lip above toe kick
          const lipMat = new THREE.MeshStandardMaterial({
            color: color,
            map: fcWoodTexture,
            roughness: fcBaseRoughness
          });
          const lip = new THREE.Mesh(
            new THREE.BoxGeometry(w, 0.03, 0.04),
            lipMat
          );
          lip.position.set(0, -h/2 + toeKickHeight + 0.015, d/2 - 0.02);
          group.add(lip);

          break;
        }

        case 'island': {
          // Kitchen island with overhang and proper toe kick
          const baseMat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.4 });

          // Toe kick dimensions
          const toeKickHeight = 0.33;
          const toeKickRecess = 0.25;
          const bodyHeight = h - toeKickHeight - 0.12; // Minus toe kick and countertop

          // Base cabinet portion (raised above toe kick)
          const base = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.4, bodyHeight, d - 0.4),
            baseMat
          );
          base.position.y = -h/2 + toeKickHeight + bodyHeight/2;
          group.add(base);

          // Countertop with overhang
          const counterMat = new THREE.MeshStandardMaterial({
            color: 0x4a4a4a,
            roughness: 0.15,
            metalness: 0.1
          });
          const counter = new THREE.Mesh(
            new THREE.BoxGeometry(w, 0.12, d),
            counterMat
          );
          counter.position.y = h/2 - 0.06;
          group.add(counter);

          // Add door details on front (adjusted for toe kick)
          const doorMat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.35 });
          const numDoors = Math.round(w / 2);
          const doorW = (w - 0.5) / numDoors - 0.05;
          const doorH = bodyHeight - 0.1;
          for (let i = 0; i < numDoors; i++) {
            const door = new THREE.Mesh(
              new THREE.BoxGeometry(doorW, doorH, 0.05),
              doorMat
            );
            door.position.set(-w/2 + 0.25 + doorW/2 + i * (doorW + 0.05), -h/2 + toeKickHeight + bodyHeight/2, d/2 - 0.2);
            group.add(door);
          }

          // Toe kick void on all four sides (island is free-standing)
          const tkBackMat = new THREE.MeshStandardMaterial({ color: 0x0a0a0a, roughness: 0.95 });

          // Front toe kick
          const tkFront = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.5, toeKickHeight - 0.02, 0.02),
            tkBackMat
          );
          tkFront.position.set(0, -h/2 + toeKickHeight/2, d/2 - 0.2 - toeKickRecess);
          group.add(tkFront);

          // Back toe kick
          const tkBackPanel = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.5, toeKickHeight - 0.02, 0.02),
            tkBackMat
          );
          tkBackPanel.position.set(0, -h/2 + toeKickHeight/2, -d/2 + 0.2 + toeKickRecess);
          group.add(tkBackPanel);

          // Left toe kick
          const tkLeftPanel = new THREE.Mesh(
            new THREE.BoxGeometry(0.02, toeKickHeight - 0.02, d - 0.5),
            tkBackMat
          );
          tkLeftPanel.position.set(-w/2 + 0.2 + toeKickRecess, -h/2 + toeKickHeight/2, 0);
          group.add(tkLeftPanel);

          // Right toe kick
          const tkRightPanel = new THREE.Mesh(
            new THREE.BoxGeometry(0.02, toeKickHeight - 0.02, d - 0.5),
            tkBackMat
          );
          tkRightPanel.position.set(w/2 - 0.2 - toeKickRecess, -h/2 + toeKickHeight/2, 0);
          group.add(tkRightPanel);

          // Toe kick floor
          const tkFloor = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.5, 0.02, d - 0.5),
            tkBackMat
          );
          tkFloor.position.set(0, -h/2 + 0.01, 0);
          group.add(tkFloor);

          // Cabinet overhang lip (all around)
          const lipMat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.4 });

          // Front lip
          const lipFront = new THREE.Mesh(new THREE.BoxGeometry(w - 0.4, 0.03, 0.04), lipMat);
          lipFront.position.set(0, -h/2 + toeKickHeight + 0.015, d/2 - 0.2);
          group.add(lipFront);

          // Back lip
          const lipBack = new THREE.Mesh(new THREE.BoxGeometry(w - 0.4, 0.03, 0.04), lipMat);
          lipBack.position.set(0, -h/2 + toeKickHeight + 0.015, -d/2 + 0.2);
          group.add(lipBack);

          // Left lip
          const lipLeft = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.03, d - 0.4), lipMat);
          lipLeft.position.set(-w/2 + 0.2, -h/2 + toeKickHeight + 0.015, 0);
          group.add(lipLeft);

          // Right lip
          const lipRight = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.03, d - 0.4), lipMat);
          lipRight.position.set(w/2 - 0.2, -h/2 + toeKickHeight + 0.015, 0);
          group.add(lipRight);

          break;
        }

        case 'countertop': {
          // Realistic countertop with texture support and detailed edge profiles
          // Thickness handling: 2cm vs 3cm
          const thickness = el.thickness || '3cm';
          const is2cm = thickness === '2cm';
          const edgeBuildStyle = el.edgeBuildStyle || 'mitered';

          // Slab thickness in feet: 3cm = ~0.1 ft (1.2"), 2cm = ~0.065 ft (0.78")
          const slabThickness = is2cm ? 0.065 : 0.1;
          // For 2cm counters, add plywood and drop edge to create full thickness appearance
          const totalVisibleHeight = is2cm ? 0.1 : slabThickness; // 2cm appears same as 3cm with buildup

          // Seam gap for clean butting between adjacent countertops
          const seamGap = 0.01;

          // WATERFALL SIDES: NO overhang on waterfall sides
          // The countertop edge must be flush with the waterfall panel (perfect 90 corner)
          const waterfallSides = el.waterfallSides || [];
          const hasLeftWaterfall = waterfallSides.includes('left');
          const hasRightWaterfall = waterfallSides.includes('right');
          const hasFrontWaterfall = waterfallSides.includes('front');
          const hasBackWaterfall = waterfallSides.includes('back');

          // WATERFALL EDGES: For waterfalls, the countertop maintains its full dimensions
          // The waterfall drops from the countertop's outer edge (including overhang)
          // No overhang reduction needed - the waterfall IS the edge, it just goes vertical

          // Slab dimensions - full width/depth with small seam gap
          const slabW = w - seamGap;
          const slabD = d - seamGap;
          const slabOffsetX = 0;
          const slabOffsetZ = 0;

          const edgeProfile = el.edgeProfile || 'eased';

          // Create countertop material with proper texture scaling based on dimensions
          // Roughness is controlled by finish settings (polished=0.08, honed=0.45, etc.)
          // Do NOT pass explicit roughness  it overrides finish-based values
          const ctopMat = createTexturedMaterial(color, textureUrl, {
            isCountertop: true,
            width: w,
            depth: d,
            finish: el.finish || 'polished'
          });

          // For 2cm counters: add plywood underlayment
          // Skip on waterfall sides - waterfall handles the edge
          if (is2cm && !hasFrontWaterfall) {
            const plywoodMat = new THREE.MeshStandardMaterial({
              color: 0xD4A76A, // Plywood color
              roughness: 0.8,
              metalness: 0
            });

            // Plywood thickness (3/4" = 0.0625 ft)
            const plywoodThickness = 0.0625;

            // Calculate plywood dimensions - shorten for waterfall corners
            const wfT = 0.065; // 2cm waterfall thickness
            let plywoodW = slabW - 0.1;
            let plywoodPosX = slabOffsetX;
            if (hasLeftWaterfall) {
              plywoodW -= wfT;
              plywoodPosX += wfT / 2;
            }
            if (hasRightWaterfall) {
              plywoodW -= wfT;
              plywoodPosX -= wfT / 2;
            }

            // Plywood sheet under the stone (visible from below/back)
            const plywood = new THREE.Mesh(
              new THREE.BoxGeometry(plywoodW, plywoodThickness, slabD - 0.3),
              plywoodMat
            );
            plywood.position.set(plywoodPosX, -slabThickness/2 - plywoodThickness/2 + 0.02, -0.1 + slabOffsetZ);
            group.add(plywood);

            // Drop edge strips (laminated, mitered, or stacked)
            // These go on front edge only - shorten for L/R waterfalls
            let dropEdgeW = slabW;
            let dropEdgePosX = slabOffsetX;
            if (hasLeftWaterfall) {
              dropEdgeW -= wfT;
              dropEdgePosX += wfT / 2;
            }
            if (hasRightWaterfall) {
              dropEdgeW -= wfT;
              dropEdgePosX -= wfT / 2;
            }

            const dropEdgeMat = createTexturedMaterial(color, textureUrl, {
              isCountertop: true,
              width: dropEdgeW,
              depth: 0.06,
              finish: el.finish || 'polished',
              enableBumpMap: false // No bump on thin edge strips
            });

            // Drop height creates appearance of 4cm (1.5") thick stone
            const dropHeight = 0.035; // ~0.4" additional drop for 4cm look

            if (edgeBuildStyle === 'laminated') {
              // Laminated edge - seamless 4cm look, no visible joint
              const lamEdge = new THREE.Mesh(
                new THREE.BoxGeometry(dropEdgeW, dropHeight, 0.06),
                dropEdgeMat
              );
              lamEdge.position.set(dropEdgePosX, -slabThickness/2 - dropHeight/2, slabD/2 - 0.03 + slabOffsetZ);
              group.add(lamEdge);

            } else if (edgeBuildStyle === 'mitered') {
              // Mitered edge - 45 angled seam, nearly invisible
              const miterEdge = new THREE.Mesh(
                new THREE.BoxGeometry(dropEdgeW, dropHeight, 0.05),
                dropEdgeMat
              );
              miterEdge.position.set(dropEdgePosX, -slabThickness/2 - dropHeight/2, slabD/2 - 0.025 + slabOffsetZ);
              group.add(miterEdge);

              // Subtle 45 seam line (barely visible)
              const miterSeamMat = new THREE.MeshStandardMaterial({ color: 0x555555, roughness: 0.4, transparent: true, opacity: 0.6 });
              const miterSeam = new THREE.Mesh(
                new THREE.BoxGeometry(dropEdgeW + 0.005, 0.002, 0.055),
                miterSeamMat
              );
              miterSeam.rotation.x = Math.PI * 0.25;
              miterSeam.position.set(dropEdgePosX, -slabThickness/2 - 0.002, slabD/2 - 0.015 + slabOffsetZ);
              group.add(miterSeam);

            } else {
              // Stacked edge - vertical seam visible at joint
              const stackedEdge = new THREE.Mesh(
                new THREE.BoxGeometry(dropEdgeW, dropHeight, 0.06),
                dropEdgeMat
              );
              stackedEdge.position.set(dropEdgePosX, -slabThickness/2 - dropHeight/2, slabD/2 - 0.03 + slabOffsetZ);
              group.add(stackedEdge);

              // Visible horizontal seam line (vertical cut joint)
              const seamMat = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.6 });
              const seam = new THREE.Mesh(
                new THREE.BoxGeometry(dropEdgeW + 0.01, 0.004, 0.065),
                seamMat
              );
              seam.position.set(dropEdgePosX, -slabThickness/2 + 0.002, slabD/2 - 0.03 + slabOffsetZ);
              group.add(seam);
            }
          }

          // Adjust h to use actual slab thickness for edge profile calculations
          const effectiveH = slabThickness;

          // Create edge profile geometry based on type
          function createEdgeGeometry(profile, length) {
            const shape = new THREE.Shape();
            const t = effectiveH; // Use actual slab thickness (accounts for 2cm vs 3cm)

            switch(profile) {
              case 'flat-polish':
              case 'square':
                // Perfectly square polished edge - no rounding
                shape.moveTo(0, 0);
                shape.lineTo(t, 0);
                shape.lineTo(t, t);
                shape.lineTo(0, t);
                shape.lineTo(0, 0);
                break;

              case 'pencil':
                // Pencil round - small rounded top, eased bottom
                shape.moveTo(0, 0);
                shape.lineTo(t, 0);
                shape.lineTo(t, t * 0.75);
                shape.quadraticCurveTo(t, t, t * 0.85, t);
                shape.lineTo(0, t);
                shape.lineTo(0, 0);
                break;

              case 'quarter-round':
                // Quarter round - larger radius than pencil
                shape.moveTo(0, 0);
                shape.lineTo(t, 0);
                shape.lineTo(t, t * 0.5);
                shape.quadraticCurveTo(t, t, t * 0.5, t);
                shape.lineTo(0, t);
                shape.lineTo(0, 0);
                break;

              case 'half-bullnose':
                // Rounded top edge, square bottom
                shape.moveTo(0, 0);
                shape.lineTo(t, 0);
                shape.lineTo(t, t * 0.6);
                shape.quadraticCurveTo(t, t, t * 0.6, t);
                shape.lineTo(0, t);
                shape.lineTo(0, 0);
                break;

              case 'full-bullnose':
                // Fully rounded edge
                shape.moveTo(t * 0.3, 0);
                shape.lineTo(t * 0.7, 0);
                shape.quadraticCurveTo(t, 0, t, t * 0.3);
                shape.lineTo(t, t * 0.7);
                shape.quadraticCurveTo(t, t, t * 0.7, t);
                shape.lineTo(t * 0.3, t);
                shape.quadraticCurveTo(0, t, 0, t * 0.7);
                shape.lineTo(0, t * 0.3);
                shape.quadraticCurveTo(0, 0, t * 0.3, 0);
                break;

              case 'ogee':
                // S-curve profile
                shape.moveTo(0, 0);
                shape.lineTo(t, 0);
                shape.lineTo(t, t * 0.5);
                shape.bezierCurveTo(t, t * 0.7, t * 0.8, t * 0.8, t * 0.6, t * 0.85);
                shape.bezierCurveTo(t * 0.4, t * 0.9, t * 0.2, t, 0, t);
                shape.lineTo(0, 0);
                break;

              case 'double-ogee':
                // Double S-curve profile
                shape.moveTo(0, 0);
                shape.lineTo(t, 0);
                shape.lineTo(t, t * 0.3);
                shape.bezierCurveTo(t, t * 0.4, t * 0.85, t * 0.45, t * 0.7, t * 0.5);
                shape.bezierCurveTo(t * 0.55, t * 0.55, t * 0.55, t * 0.65, t * 0.7, t * 0.7);
                shape.bezierCurveTo(t * 0.85, t * 0.75, t * 0.9, t * 0.85, t * 0.6, t * 0.9);
                shape.bezierCurveTo(t * 0.3, t * 0.95, t * 0.1, t, 0, t);
                shape.lineTo(0, 0);
                break;

              case 'cove':
                // Inward concave curve
                shape.moveTo(0, 0);
                shape.lineTo(t, 0);
                shape.lineTo(t, t * 0.7);
                shape.quadraticCurveTo(t * 0.7, t, 0, t);
                shape.lineTo(0, 0);
                break;

              case 'mitered':
                // 45-degree mitered edge (creates thicker appearance)
                shape.moveTo(0, 0);
                shape.lineTo(t, 0);
                shape.lineTo(t, t * 0.85);
                shape.lineTo(t * 0.85, t);
                shape.lineTo(0, t);
                shape.lineTo(0, 0);
                break;

              case 'bevel':
              case 'quarter-bevel':
                // 45-degree bevel
                shape.moveTo(0, 0);
                shape.lineTo(t, 0);
                shape.lineTo(t, t * 0.7);
                shape.lineTo(t * 0.7, t);
                shape.lineTo(0, t);
                shape.lineTo(0, 0);
                break;

              case 'dupont':
                // Complex multi-step profile
                shape.moveTo(0, 0);
                shape.lineTo(t, 0);
                shape.lineTo(t, t * 0.4);
                shape.lineTo(t * 0.85, t * 0.5);
                shape.quadraticCurveTo(t * 0.7, t * 0.6, t * 0.7, t * 0.75);
                shape.lineTo(t * 0.7, t);
                shape.lineTo(0, t);
                shape.lineTo(0, 0);
                break;

              case 'chiseled':
                // Rough-hewn textured edge appearance
                shape.moveTo(0, 0);
                shape.lineTo(t * 0.95, 0);
                shape.lineTo(t, t * 0.1);
                shape.lineTo(t * 0.92, t * 0.25);
                shape.lineTo(t * 1.02, t * 0.4);
                shape.lineTo(t * 0.95, t * 0.55);
                shape.lineTo(t * 1.03, t * 0.7);
                shape.lineTo(t * 0.94, t * 0.85);
                shape.lineTo(t * 0.98, t);
                shape.lineTo(0, t);
                shape.lineTo(0, 0);
                break;

              case 'waterfall':
                // Waterfall edge - clean square profile for seamless miter joint
                // The waterfall vertical panel creates the visual interest, edge stays flat
                shape.moveTo(0, 0);
                shape.lineTo(t, 0);
                shape.lineTo(t, t);
                shape.lineTo(0, t);
                shape.lineTo(0, 0);
                break;

              case 'eased':
              default:
                // Simple eased/softened corners
                shape.moveTo(0, 0);
                shape.lineTo(t, 0);
                shape.lineTo(t, t * 0.9);
                shape.quadraticCurveTo(t, t, t * 0.9, t);
                shape.lineTo(0, t);
                shape.lineTo(0, 0);
                break;
            }

            const extrudeSettings = {
              steps: 1,
              depth: length,
              bevelEnabled: false
            };

            return new THREE.ExtrudeGeometry(shape, extrudeSettings);
          }

          // Main slab body - full size, no inset to avoid visible seams
          // Edge profiles are rendered as decorative overlays on the front face

          // Find sinks that overlap with this countertop to create cutouts
          const sinkCutouts = [];
          const ctopLeftFt = el.x / pixelsPerFoot;
          const ctopTopFt = el.y / pixelsPerFoot;
          const ctopRightFt = ctopLeftFt + w;
          const ctopBottomFt = ctopTopFt + d;

          elements.forEach(other => {
            if (other.id === el.id) return;
            if (!['sink', 'sink-double', 'sink-farmhouse'].includes(other.type)) return;

            // Get sink bounds - x/y are pixels, width/height are already in feet
            const sinkLeftFt = other.x / pixelsPerFoot;
            const sinkTopFt = other.y / pixelsPerFoot;
            const sinkWFt = other.width;  // Already in feet
            const sinkDFt = other.height; // Already in feet
            const sinkRightFt = sinkLeftFt + sinkWFt;
            const sinkBottomFt = sinkTopFt + sinkDFt;

            // Check overlap
            if (sinkRightFt > ctopLeftFt && sinkLeftFt < ctopRightFt &&
                sinkBottomFt > ctopTopFt && sinkTopFt < ctopBottomFt) {
              // Calculate sink position relative to countertop center
              const relX = (sinkLeftFt + sinkWFt/2) - (ctopLeftFt + w/2);
              const relZ = (sinkTopFt + sinkDFt/2) - (ctopTopFt + d/2);
              sinkCutouts.push({ x: relX, z: relZ, w: sinkWFt, d: sinkDFt });
            }
          });

          // Determine if edge profile needs separate geometry
          // Skip flat/square/eased edges - main body geometry handles these
          const skipEdgeProfile = ['flat-polish', 'square', 'eased'].includes(edgeProfile);

          // For decorative edges, inset the main body front by the full slab thickness
          // so the edge profile geometry fills the gap exactly (no overlap)
          const edgeInset = skipEdgeProfile ? 0 : effectiveH;

          // Main slab body - full size for flat/square/eased, or front-inset for decorative edges
          // Skip when sinks present (use ExtrudeGeometry with cutouts instead)
          if (sinkCutouts.length === 0) {
            const bodyDepth = slabD - (hasFrontWaterfall ? 0 : edgeInset);
            const bodyOffsetZ = (hasFrontWaterfall ? 0 : -edgeInset / 2);
            const mainBody = new THREE.Mesh(
              new THREE.BoxGeometry(slabW, effectiveH, bodyDepth),
              ctopMat
            );
            mainBody.position.set(slabOffsetX, 0, slabOffsetZ + bodyOffsetZ);
            mainBody.castShadow = true;
            mainBody.receiveShadow = true;
            group.add(mainBody);
          }

          // Edge rendering - decorative profile geometry fills the front face gap
          // Same material as body, DoubleSide for correct visibility after rotation
          const frontEdgeMat = ctopMat.clone();
          frontEdgeMat.side = THREE.DoubleSide;

          // Front edge - SKIP if front has waterfall (waterfall replaces the edge)
          // Also skip for flat/square/eased edges (main body handles these)
          // Also shorten front edge if left/right waterfalls exist (they handle the corners)
          if (!hasFrontWaterfall && !skipEdgeProfile) {
            const wfThicknessForEdge = is2cm ? 0.065 : 0.1;
            let frontEdgeLen = slabW;
            let frontEdgePosX = slabOffsetX;
            if (hasLeftWaterfall) {
              frontEdgeLen -= wfThicknessForEdge;
              frontEdgePosX += wfThicknessForEdge / 2;
            }
            if (hasRightWaterfall) {
              frontEdgeLen -= wfThicknessForEdge;
              frontEdgePosX -= wfThicknessForEdge / 2;
            }
            try {
              const frontEdgeGeo = createEdgeGeometry(edgeProfile, frontEdgeLen);
              const frontEdge = new THREE.Mesh(frontEdgeGeo, frontEdgeMat);
              // Single rotation: extrusion (Z)  runs along X (counter width)
              // Shape X (profile depth)  Z (toward viewer), Y (height)  Y (vertical)
              frontEdge.rotation.y = -Math.PI / 2;
              // Position: edge back (shape x=0) at body front, edge front (shape x=t) at slab front
              frontEdge.position.set(
                frontEdgeLen / 2 + frontEdgePosX,
                -effectiveH / 2,
                slabD / 2 - effectiveH + slabOffsetZ
              );
              frontEdge.castShadow = true;
              group.add(frontEdge);
            } catch(e) {
              // Fallback: thin decorative strip on front face
              const edgeDepth = 0.02;
              const frontEdge = new THREE.Mesh(
                new THREE.BoxGeometry(frontEdgeLen, effectiveH * 0.9, edgeDepth),
                frontEdgeMat
              );
              frontEdge.position.set(frontEdgePosX, 0, slabD/2 + edgeDepth/2 + slabOffsetZ);
              group.add(frontEdge);
            }
          }

          // Side edges for finished ends  thin decorative strips
          // IMPORTANT: Do NOT render on waterfall sides - the waterfall IS the edge
          // Skip for flat/square/eased edges (main body handles these)
          if (el.finishedEnds && !skipEdgeProfile) {
            const sideEdgeDepth = 0.015;
            // Left finished end
            if (el.finishedEnds.includes('left') && !hasLeftWaterfall) {
              const leftEdge = new THREE.Mesh(
                new THREE.BoxGeometry(sideEdgeDepth, effectiveH * 0.95, slabD),
                frontEdgeMat
              );
              leftEdge.position.set(-slabW/2 - sideEdgeDepth/2 + slabOffsetX, 0, slabOffsetZ);
              group.add(leftEdge);
            }
            // Right finished end
            if (el.finishedEnds.includes('right') && !hasRightWaterfall) {
              const rightEdge = new THREE.Mesh(
                new THREE.BoxGeometry(sideEdgeDepth, effectiveH * 0.95, slabD),
                frontEdgeMat
              );
              rightEdge.position.set(slabW/2 + sideEdgeDepth/2 + slabOffsetX, 0, slabOffsetZ);
              group.add(rightEdge);
            }
          }

          // Back edge removed - it's against the wall and not visible
          // The main body is now full-size so no separate back edge needed

          // Countertop with sink cutouts  uses ExtrudeGeometry with holes
          if (sinkCutouts.length > 0) {
            // Create full-thickness countertop with sink holes using ExtrudeGeometry
            const topShape = new THREE.Shape();
            const topHalfW = slabW / 2;
            const topHalfD = slabD / 2;

            // Outer rectangle (CCW when viewed from above)
            topShape.moveTo(-topHalfW, -topHalfD);
            topShape.lineTo(topHalfW, -topHalfD);
            topShape.lineTo(topHalfW, topHalfD);
            topShape.lineTo(-topHalfW, topHalfD);
            topShape.lineTo(-topHalfW, -topHalfD);

            // Add sink holes (CW for holes - clockwise when viewed from above)
            sinkCutouts.forEach(sink => {
              // Use basin size with small reveal for the hole
              const holeW = sink.w * 0.85;
              const holeD = sink.d * 0.85;

              const hole = new THREE.Path();
              // CW winding: start bottom-left, go left to top-left, then top-right, etc.
              hole.moveTo(sink.x - holeW/2, sink.z - holeD/2);
              hole.lineTo(sink.x - holeW/2, sink.z + holeD/2);
              hole.lineTo(sink.x + holeW/2, sink.z + holeD/2);
              hole.lineTo(sink.x + holeW/2, sink.z - holeD/2);
              hole.lineTo(sink.x - holeW/2, sink.z - holeD/2);
              topShape.holes.push(hole);
            });

            // Extrude with full countertop thickness
            const extrudeSettings = {
              depth: effectiveH,
              bevelEnabled: false
            };
            const topGeo = new THREE.ExtrudeGeometry(topShape, extrudeSettings);
            topGeo.rotateX(-Math.PI / 2);
            const countertopWithHole = new THREE.Mesh(topGeo, ctopMat);
            countertopWithHole.position.set(slabOffsetX, -effectiveH/2, slabOffsetZ);
            group.add(countertopWithHole);
          }
          // NOTE: Removed separate top surface mesh - was causing visible seam/cut line
          // The main body already has the textured top face from ctopMat

          // Render seams as subtle grooves in the countertop
          if (el.seams && el.seams.length > 0) {
            const seamMat = new THREE.MeshStandardMaterial({
              color: 0x333333,
              roughness: 0.9,
              metalness: 0
            });

            el.seams.forEach(seam => {
              const seamX = -slabW/2 + slabW * seam.position + slabOffsetX;
              const seamGroove = new THREE.Mesh(
                new THREE.BoxGeometry(0.008, effectiveH + 0.01, slabD),
                seamMat
              );
              seamGroove.position.set(seamX, 0, slabOffsetZ);
              group.add(seamGroove);
            });
          }

          // Render backsplash if enabled
          if (el.backsplash && el.backsplash.height > 0) {
            const bsHeight = el.backsplash.height / 12; // Convert inches to feet
            const bsThickness = 0.04; // ~0.5 inch thick

            // Use same texture as countertop or a different material
            const bsMat = createTexturedMaterial(color, textureUrl, {
              isCountertop: true,
              width: slabW,
              depth: bsThickness,
              finish: el.finish || 'polished'
            });

            // Main backsplash panel - sits behind countertop, on top of counter surface
            const bsPanel = new THREE.Mesh(
              new THREE.BoxGeometry(slabW, bsHeight, bsThickness),
              bsMat
            );
            // Position: centered on counter width, height starts at top of counter, against back wall
            bsPanel.position.set(slabOffsetX, h/2 + bsHeight/2, -slabD/2 + bsThickness/2 + slabOffsetZ);
            group.add(bsPanel);

            // Top edge detail (eased edge on backsplash)
            const bsTopEdge = new THREE.Mesh(
              new THREE.BoxGeometry(slabW + 0.01, 0.015, bsThickness + 0.02),
              createTexturedMaterial(color, textureUrl, { isCountertop: true, finish: el.finish || 'polished' })
            );
            bsTopEdge.position.set(slabOffsetX, h/2 + bsHeight - 0.0075, -slabD/2 + bsThickness/2 + slabOffsetZ);
            group.add(bsTopEdge);

            // Side returns if finished ends are enabled
            if (el.finishedEnds) {
              if (el.finishedEnds.includes('left')) {
                const leftReturn = new THREE.Mesh(
                  new THREE.BoxGeometry(bsThickness, bsHeight, 0.15),
                  bsMat
                );
                leftReturn.position.set(-slabW/2 + bsThickness/2 + slabOffsetX, h/2 + bsHeight/2, -slabD/2 + 0.075 + slabOffsetZ);
                group.add(leftReturn);
              }
              if (el.finishedEnds.includes('right')) {
                const rightReturn = new THREE.Mesh(
                  new THREE.BoxGeometry(bsThickness, bsHeight, 0.15),
                  bsMat
                );
                rightReturn.position.set(slabW/2 - bsThickness/2 + slabOffsetX, h/2 + bsHeight/2, -slabD/2 + 0.075 + slabOffsetZ);
                group.add(rightReturn);
              }
            }
          }

          // Render waterfall edges (vertical stone panels dropping down from countertop)
          // Waterfalls render regardless of edge profile - user can add to any countertop
          if (el.waterfallSides && el.waterfallSides.length > 0) {
            const waterfallMat = createTexturedMaterial(color, textureUrl, {
              isCountertop: true,
              width: w,
              depth: d,
              finish: el.finish || 'polished'
            });

            // Waterfall drop height (default to floor = counter height)
            const dropHeight = el.waterfallDropFeet || 2.9; // Default counter height from floor

            // For 2cm stone, waterfall gets laminated edges on all visible sides
            const wfThickness = is2cm ? 0.065 : slabThickness;
            const wfEdgeThickness = is2cm ? 0.035 : 0; // Laminated edge build for 2cm

            el.waterfallSides.forEach(side => {
              let wfW, wfD, wfPosX, wfPosZ;

              // WATERFALL: Perfect 90 turn - NO overhang, NO lip
              // The waterfall outer face must be FLUSH with countertop edge
              // Position waterfall so its INNER face is at the adjusted slab edge
              // This way the countertop ends right where the waterfall begins

              switch(side) {
                case 'left':
                  // LEFT waterfall - outer face flush with countertop left edge
                  wfW = wfThickness;
                  wfD = d - seamGap;
                  // Outer face at slab left edge: -slabW/2 + slabOffsetX
                  // Center = outer face + thickness/2
                  wfPosX = (-slabW/2 + slabOffsetX) + wfThickness/2;
                  wfPosZ = 0;
                  break;
                case 'right':
                  // RIGHT waterfall - outer face flush with countertop right edge
                  wfW = wfThickness;
                  wfD = d - seamGap;
                  // Outer face at slab right edge: slabW/2 + slabOffsetX
                  // Center = outer face - thickness/2
                  wfPosX = (slabW/2 + slabOffsetX) - wfThickness/2;
                  wfPosZ = 0;
                  break;
                case 'front':
                  // FRONT waterfall - outer face flush with countertop front edge
                  wfW = w - seamGap;
                  wfD = wfThickness;
                  wfPosX = 0;
                  // Outer face at slab front edge: slabD/2 + slabOffsetZ
                  // Center = outer face - thickness/2
                  wfPosZ = (slabD/2 + slabOffsetZ) - wfThickness/2;
                  break;
                case 'back':
                  // BACK waterfall - outer face flush with countertop back edge
                  wfW = w - seamGap;
                  wfD = wfThickness;
                  wfPosX = 0;
                  // Outer face at slab back edge: -slabD/2 + slabOffsetZ
                  // Center = outer face + thickness/2
                  wfPosZ = (-slabD/2 + slabOffsetZ) + wfThickness/2;
                  break;
              }

              // Main waterfall panel - drops from countertop TOP level
              // TOP of waterfall at TOP of countertop = continuous surface turning 90
              const wfPanel = new THREE.Mesh(
                new THREE.BoxGeometry(wfW, dropHeight, wfD),
                waterfallMat
              );
              // Y position: panel top at countertop top (slabThickness/2 above countertop center)
              wfPanel.position.set(wfPosX, slabThickness/2 - dropHeight/2, wfPosZ);
              wfPanel.castShadow = true;
              wfPanel.receiveShadow = true;
              group.add(wfPanel);

              // For 2cm stone, add laminated edge on the INNER visible face (faces cabinet)
              // The outer face is continuous with countertop - no lamination needed there
              if (is2cm && wfEdgeThickness > 0) {
                const lamStripMat = createTexturedMaterial(color, textureUrl, {
                  roughness: 0.1,
                  metalness: 0.08
                });
                const yPos = slabThickness/2 - dropHeight/2; // Match waterfall Y position

                if (side === 'left') {
                  // Inner face (right side of left waterfall)
                  const innerStrip = new THREE.Mesh(
                    new THREE.BoxGeometry(wfEdgeThickness, dropHeight, slabD),
                    lamStripMat
                  );
                  innerStrip.position.set(wfPosX + wfThickness/2 + wfEdgeThickness/2, yPos, slabOffsetZ);
                  group.add(innerStrip);
                } else if (side === 'right') {
                  // Inner face (left side of right waterfall)
                  const innerStrip = new THREE.Mesh(
                    new THREE.BoxGeometry(wfEdgeThickness, dropHeight, slabD),
                    lamStripMat
                  );
                  innerStrip.position.set(wfPosX - wfThickness/2 - wfEdgeThickness/2, yPos, slabOffsetZ);
                  group.add(innerStrip);
                } else if (side === 'front') {
                  // Inner face (back of front waterfall)
                  const innerStrip = new THREE.Mesh(
                    new THREE.BoxGeometry(wfW, dropHeight, wfEdgeThickness),
                    lamStripMat
                  );
                  innerStrip.position.set(wfPosX, yPos, wfPosZ - wfThickness/2 - wfEdgeThickness/2);
                  group.add(innerStrip);
                } else if (side === 'back') {
                  // Inner face (front of back waterfall)
                  const innerStrip = new THREE.Mesh(
                    new THREE.BoxGeometry(wfW, dropHeight, wfEdgeThickness),
                    lamStripMat
                  );
                  innerStrip.position.set(wfPosX, yPos, wfPosZ + wfThickness/2 + wfEdgeThickness/2);
                  group.add(innerStrip);
                }
              }
              // No visible seam - mitered joint is polished smooth to appear seamless
            });
          }
          break;
        }

        case 'countertop-l': {
          // L-shaped countertop - two separate runs meeting at 90 degrees
          // Like real fabrication: horizontal run along X, perpendicular run along Z
          const lMat = createTexturedMaterial(color, textureUrl, {
            roughness: 0.1,
            metalness: 0.08,
            finish: el.finish || 'polished'
          });
          const thickness = 0.1; // 3cm thickness (1.2")

          // Arm depth is standard countertop depth: 26" = 2.17ft
          const armDepth = el.armWidth || 2.17;

          // HORIZONTAL ARM: runs along X-axis (full width w, depth = armDepth)
          // Positioned at front (positive Z side)
          const horizArm = new THREE.Mesh(
            new THREE.BoxGeometry(w, thickness, armDepth),
            lMat
          );
          // Position at front edge of the L footprint
          horizArm.position.set(0, 0, d/2 - armDepth/2);
          group.add(horizArm);

          // PERPENDICULAR ARM: runs along Z-axis (width = armDepth, extends back)
          // Positioned at left side (negative X), extending back from horizontal arm
          // This creates the perpendicular leg of the L
          const perpLength = d - armDepth; // Length extends back from horizontal arm
          if (perpLength > 0.1) {
            const perpArm = new THREE.Mesh(
              new THREE.BoxGeometry(armDepth, thickness, perpLength),
              lMat
            );
            // Position: left edge of footprint, centered behind horizontal arm
            // X: left side (-w/2 + armDepth/2 centers the arm at left edge)
            // Z: front edge of perpArm meets back edge of horizArm at z = d/2 - armDepth
            //    So center = (d/2 - armDepth) - perpLength/2 = -armDepth/2 when simplified
            const perpZ = (d/2 - armDepth) - perpLength/2;
            perpArm.position.set(-w/2 + armDepth/2, 0, perpZ);
            group.add(perpArm);

            // Add seam line where the two arms meet (realistic fabrication detail)
            const seamMat = new THREE.MeshBasicMaterial({ color: 0x333333 });
            const seamLine = new THREE.Mesh(
              new THREE.BoxGeometry(armDepth, thickness + 0.002, 0.01),
              seamMat
            );
            // Seam is at the junction: z = d/2 - armDepth (back of horiz, front of perp)
            seamLine.position.set(-w/2 + armDepth/2, 0.001, d/2 - armDepth);
            group.add(seamLine);

            // Top polish highlight for perpendicular arm
            const topPerpMat = createTexturedMaterial(color, textureUrl, {
              roughness: 0.05,
              metalness: 0.15
            });
            const topPerp = new THREE.Mesh(
              new THREE.BoxGeometry(armDepth - 0.02, 0.005, perpLength - 0.02),
              topPerpMat
            );
            topPerp.position.set(-w/2 + armDepth/2, thickness/2, perpZ);
            group.add(topPerp);
          }

          // Top polish highlight for horizontal arm
          const topMat = createTexturedMaterial(color, textureUrl, {
            roughness: 0.05,
            metalness: 0.15
          });
          const topHoriz = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.02, 0.005, armDepth - 0.02),
            topMat
          );
          topHoriz.position.set(0, thickness/2, d/2 - armDepth/2);
          group.add(topHoriz);
          break;
        }

        case 'countertop-corner': {
          // Corner countertop - simple square slab for corner transitions
          const cornerMat = createTexturedMaterial(color, textureUrl, {
            roughness: 0.1,
            metalness: 0.08,
            finish: el.finish || 'polished'
          });
          const thickness = 0.1; // 3cm thickness

          // Simple square slab
          const cornerSlab = new THREE.Mesh(
            new THREE.BoxGeometry(w, thickness, d),
            cornerMat
          );
          group.add(cornerSlab);

          // Top polish highlight
          const cornerTop = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.02, 0.005, d - 0.02),
            createTexturedMaterial(color, textureUrl, { roughness: 0.05, metalness: 0.15 })
          );
          cornerTop.position.set(0, thickness/2, 0);
          group.add(cornerTop);
          break;
        }

        case 'countertop-u': {
          // U-shaped countertop
          const uMat = createTexturedMaterial(color, textureUrl, {
            roughness: 0.1,
            metalness: 0.08,
            finish: el.finish || 'polished'
          });
          const thickness = 0.1; // 3cm thickness

          // U-shape: back arm full width, two side arms
          const armDepth = d * 0.3; // Back arm depth
          const sideWidth = w * 0.25; // Side arm width

          // Back arm (full width, partial depth)
          const backArm = new THREE.Mesh(
            new THREE.BoxGeometry(w, thickness, armDepth),
            uMat
          );
          backArm.position.set(0, 0, -d/2 + armDepth/2);
          group.add(backArm);

          // Left side arm
          const leftArm = new THREE.Mesh(
            new THREE.BoxGeometry(sideWidth, thickness, d - armDepth),
            uMat
          );
          leftArm.position.set(-w/2 + sideWidth/2, 0, armDepth/2);
          group.add(leftArm);

          // Right side arm
          const rightArm = new THREE.Mesh(
            new THREE.BoxGeometry(sideWidth, thickness, d - armDepth),
            uMat
          );
          rightArm.position.set(w/2 - sideWidth/2, 0, armDepth/2);
          group.add(rightArm);

          // Top highlights
          const topMat = createTexturedMaterial(color, textureUrl, {
            roughness: 0.05,
            metalness: 0.15
          });
          const topBack = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.02, 0.005, armDepth - 0.02),
            topMat
          );
          topBack.position.set(0, thickness/2, -d/2 + armDepth/2);
          group.add(topBack);

          const topLeft = new THREE.Mesh(
            new THREE.BoxGeometry(sideWidth - 0.02, 0.005, d - armDepth - 0.02),
            topMat
          );
          topLeft.position.set(-w/2 + sideWidth/2, thickness/2, armDepth/2);
          group.add(topLeft);

          const topRight = new THREE.Mesh(
            new THREE.BoxGeometry(sideWidth - 0.02, 0.005, d - armDepth - 0.02),
            topMat
          );
          topRight.position.set(w/2 - sideWidth/2, thickness/2, armDepth/2);
          group.add(topRight);
          break;
        }

        case 'surface-stainless': {
          // Stainless steel work surface with realistic reflections
          const ssMat = new THREE.MeshStandardMaterial({
            color: 0xD8D8D8,
            roughness: 0.15,
            metalness: 0.9,
            envMap: window.roomEnvMap || null,
            envMapIntensity: 1.2
          });
          const ssTop = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), ssMat);
          group.add(ssTop);

          // Add subtle brushed texture lines
          const lineMat = new THREE.MeshStandardMaterial({
            color: 0xC0C0C0,
            roughness: 0.3,
            metalness: 0.85,
            envMap: window.roomEnvMap || null,
            envMapIntensity: 0.8
          });
          for (let lz = -d/2 + 0.15; lz < d/2; lz += 0.15) {
            const brushLine = new THREE.Mesh(new THREE.BoxGeometry(w - 0.05, h + 0.002, 0.01), lineMat);
            brushLine.position.set(0, 0.001, lz);
            group.add(brushLine);
          }

          // Welded edge (slightly raised rim)
          const rimMat = new THREE.MeshStandardMaterial({
            color: 0xE0E0E0,
            roughness: 0.2,
            metalness: 0.85,
            envMap: window.roomEnvMap || null,
            envMapIntensity: 1.0
          });
          const frontRim = new THREE.Mesh(new THREE.BoxGeometry(w, h + 0.02, 0.02), rimMat);
          frontRim.position.set(0, 0.01, d/2);
          group.add(frontRim);
          break;
        }

        case 'surface-solid': {
          // Solid surface (Corian-style) - matte, seamless look
          const solidMat = createTexturedMaterial(color, textureUrl, {
            roughness: 0.4,
            metalness: 0.02
          });
          const solidTop = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), solidMat);
          group.add(solidTop);

          // Integrated edge (slightly rounded)
          const edgeMat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.35, metalness: 0.01 });
          const frontEdge = new THREE.Mesh(new THREE.BoxGeometry(w - 0.02, h, 0.03), edgeMat);
          frontEdge.position.set(0, 0, d/2 + 0.01);
          group.add(frontEdge);
          break;
        }

        case 'surface-laminate': {
          // Laminate/Formica - thin top layer on substrate
          // Substrate (particle board)
          const substrateMat = new THREE.MeshStandardMaterial({ color: 0xC4A76C, roughness: 0.8 });
          const substrate = new THREE.Mesh(new THREE.BoxGeometry(w, h * 0.85, d), substrateMat);
          substrate.position.y = -h * 0.075;
          group.add(substrate);

          // Laminate top
          const lamMat = createTexturedMaterial(color, textureUrl, {
            roughness: 0.25,
            metalness: 0.05
          });
          const lamTop = new THREE.Mesh(new THREE.BoxGeometry(w + 0.01, h * 0.15, d + 0.01), lamMat);
          lamTop.position.y = h * 0.425;
          group.add(lamTop);

          // Edge banding
          const edgeBandMat = new THREE.MeshStandardMaterial({ color: 0x4A4A4A, roughness: 0.3 });
          const frontBand = new THREE.Mesh(new THREE.BoxGeometry(w + 0.01, h, 0.02), edgeBandMat);
          frontBand.position.set(0, 0, d/2 + 0.01);
          group.add(frontBand);
          break;
        }

        case 'surface-butcherblock': {
          // Butcher block - wood strips
          const bbMat = createTexturedMaterial(color, textureUrl, {
            roughness: 0.55,
            metalness: 0.0
          });
          const bbTop = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), bbMat);
          group.add(bbTop);

          // Wood strip lines (end grain or edge grain pattern)
          const stripMat = new THREE.MeshStandardMaterial({ color: 0x8B6914, roughness: 0.7 });
          const stripWidth = 0.15;
          for (let sx = -w/2 + stripWidth; sx < w/2; sx += stripWidth) {
            const strip = new THREE.Mesh(new THREE.BoxGeometry(0.005, h + 0.002, d - 0.02), stripMat);
            strip.position.set(sx, 0.001, 0);
            group.add(strip);
          }
          break;
        }

        case 'surface-concrete': {
          // Concrete countertop - industrial look
          const concMat = createTexturedMaterial(color, textureUrl, {
            roughness: 0.7,
            metalness: 0.05
          });
          const concTop = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), concMat);
          group.add(concTop);

          // Add subtle aggregate texture spots
          const aggMat = new THREE.MeshStandardMaterial({ color: 0x909090, roughness: 0.8 });
          for (let i = 0; i < 15; i++) {
            const agg = new THREE.Mesh(new THREE.SphereGeometry(0.02 + Math.random() * 0.02, 6, 6), aggMat);
            agg.position.set(
              (Math.random() - 0.5) * (w - 0.1),
              h/2 + 0.01,
              (Math.random() - 0.5) * (d - 0.1)
            );
            agg.scale.y = 0.3;
            group.add(agg);
          }
          break;
        }

        case 'backsplash': {
          // Tile backsplash - vertical against wall
          // verticalHeight is the actual height: 4" (0.333), 6" (0.5), 18" (1.5), or full height
          // Convert backsplash property to proper height
          let bsVerticalHeight = el.verticalHeight;
          if (!bsVerticalHeight && el.backsplash) {
            // Parse backsplash setting
            if (el.backsplash.height === 4) bsVerticalHeight = 0.333; // 4"
            else if (el.backsplash.height === 6) bsVerticalHeight = 0.5; // 6"
            else if (el.backsplash.height === 18) bsVerticalHeight = 1.5; // 18"
            else if (el.backsplash.type === 'full') bsVerticalHeight = 1.5; // Full height to wall cab
          }
          bsVerticalHeight = bsVerticalHeight || 1.5; // Default 18" backsplash
          const bsThickness = d > 0.2 ? 0.08 : Math.max(d, 0.04); // Minimum 0.5" thick

          // Detect tile type from label or texture
          const tileType = el.tileType || (el.label?.toLowerCase().includes('subway') ? 'subway' :
                          el.label?.toLowerCase().includes('mosaic') ? 'mosaic' :
                          el.label?.toLowerCase().includes('herringbone') ? 'herringbone' : 'standard');

          // Tile dimensions based on type
          const tileSizes = {
            subway: { width: 0.25, height: 0.125 }, // 3"1.5" (scaled to ft)
            mosaic: { width: 0.083, height: 0.083 }, // 1"1" mosaic
            standard: { width: 0.333, height: 0.333 }, // 4"4" tile
            herringbone: { width: 0.25, height: 0.0625 }, // 3"0.75" for herringbone
            chevron: { width: 0.25, height: 0.0625 },
            hexagon: { width: 0.167, height: 0.167 }
          };
          const tileSize = tileSizes[tileType] || tileSizes.standard;

          // Check for shop product texture - prioritize this for accurate material display
          let bsTextureUrl = textureUrl;
          if (!bsTextureUrl && el.storeProduct?.image) {
            bsTextureUrl = el.storeProduct.image;
          }
          if (!bsTextureUrl && el.materialId) {
            const product = storeProducts.find(p => p.slug === el.materialId);
            if (product?.primaryImage) bsTextureUrl = product.primaryImage;
          }

          // Determine if this is a stone backsplash (from shop) or tile
          const isStoneBacksplash = el.materialCategory &&
            ['granite', 'quartz', 'marble', 'quartzite', 'dekton', 'porcelain', 'stone'].includes(el.materialCategory.toLowerCase());

          // Create backsplash material - use different settings for stone vs tile
          let bsMat;
          if (bsTextureUrl) {
            // Shop material with texture - create proper material
            bsMat = createTexturedMaterial(color, bsTextureUrl, {
              roughness: isStoneBacksplash ? 0.15 : 0.25,
              metalness: 0.02,
              isCountertop: isStoneBacksplash, // Use countertop settings for stone
              width: w,
              depth: bsVerticalHeight,
              finish: el.finish || (isStoneBacksplash ? 'polished' : 'matte')
            });
            console.log(`Backsplash using shop texture: ${bsTextureUrl.substring(0, 50)}...`);
          } else {
            // No texture - use solid color with glossy tile finish
            bsMat = new THREE.MeshStandardMaterial({
              color: color,
              roughness: 0.2,
              metalness: 0.02
            });
            // Add subtle environment reflection for tile look
            if (window.roomEnvMap) {
              bsMat.envMap = window.roomEnvMap;
              bsMat.envMapIntensity = 0.3;
            }
          }

          const bs = new THREE.Mesh(
            new THREE.BoxGeometry(w, bsVerticalHeight, bsThickness),
            bsMat
          );
          bs.castShadow = true;
          bs.receiveShadow = true;
          group.add(bs);

          // Only add grout lines for tile backsplash (not stone slab)
          if (!isStoneBacksplash || tileType !== 'standard') {
            // Grout color based on tile color (contrast)
            const groutLuminance = new THREE.Color(color).getHSL({}).l;
            const groutColor = groutLuminance > 0.5 ? 0x888888 : 0xCCCCCC;
            const groutMat = new THREE.MeshStandardMaterial({ color: groutColor, roughness: 0.95 });

            // Vertical grout lines
            const numVLines = Math.floor(w / tileSize.width);
            for (let i = 1; i < numVLines; i++) {
              const vGrout = new THREE.Mesh(
                new THREE.BoxGeometry(0.008, bsVerticalHeight - 0.02, 0.005),
                groutMat
              );
              vGrout.position.set(-w/2 + i * tileSize.width, 0, bsThickness/2 + 0.003);
              group.add(vGrout);
            }

            // Horizontal grout lines
            const numHLines = Math.floor(bsVerticalHeight / tileSize.height);
            for (let i = 1; i < numHLines; i++) {
              const hGrout = new THREE.Mesh(
                new THREE.BoxGeometry(w - 0.02, 0.008, 0.005),
                groutMat
              );
              hGrout.position.set(0, -bsVerticalHeight/2 + i * tileSize.height, bsThickness/2 + 0.003);
              group.add(hGrout);
            }
          }

          // Top edge cap (small lip at top of backsplash)
          if (bsVerticalHeight > 0.4) { // Only for taller backsplashes
            const capMat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.3 });
            const cap = new THREE.Mesh(
              new THREE.BoxGeometry(w, 0.02, bsThickness + 0.01),
              capMat
            );
            cap.position.set(0, bsVerticalHeight/2 + 0.01, 0);
            group.add(cap);
          }
          break;
        }

        case 'flooring': {
          // Wood plank flooring with texture support and grain direction
          const floorGrainDir = el.grainDirection || 0;
          const plankMat = createTexturedMaterial(color, textureUrl, {
            roughness: 0.6,
            metalness: 0.0
          });

          // Apply texture rotation based on grain direction
          if (plankMat.map) {
            plankMat.map.rotation = floorGrainDir * Math.PI / 180;
            plankMat.map.center.set(0.5, 0.5);
          }

          const floorBase = new THREE.Mesh(
            new THREE.BoxGeometry(w, h, d),
            plankMat
          );
          group.add(floorBase);

          // Plank grooves - adjust based on grain direction
          const grooveMat = new THREE.MeshStandardMaterial({ color: 0x3a2a1a, roughness: 0.9 });
          const plankW = 0.5;

          if (floorGrainDir === 90) {
            // Vertical planks - grooves run along Z axis
            for (let pz = -d/2 + plankW; pz < d/2; pz += plankW) {
              const groove = new THREE.Mesh(
                new THREE.BoxGeometry(w + 0.01, h + 0.01, 0.008),
                grooveMat
              );
              groove.position.set(0, 0.002, pz);
              group.add(groove);
            }
          } else if (floorGrainDir === 45 || floorGrainDir === 135) {
            // Diagonal planks
            const angle = floorGrainDir * Math.PI / 180;
            const diagonal = Math.sqrt(w * w + d * d);
            for (let p = -diagonal/2 + plankW; p < diagonal/2; p += plankW) {
              const groove = new THREE.Mesh(
                new THREE.BoxGeometry(diagonal, h + 0.01, 0.008),
                grooveMat
              );
              groove.rotation.y = -angle;
              groove.position.set(
                p * Math.sin(angle),
                0.002,
                p * Math.cos(angle)
              );
              group.add(groove);
            }
          } else {
            // Horizontal planks (default) - grooves run along X axis
            for (let px = -w/2 + plankW; px < w/2; px += plankW) {
              const groove = new THREE.Mesh(
                new THREE.BoxGeometry(0.008, h + 0.01, d + 0.01),
                grooveMat
              );
              groove.position.set(px, 0.002, 0);
              group.add(groove);
            }
          }
          break;
        }

        case 'tile': {
          // Tile floor/surface with texture support and direction
          const tileDir = el.grainDirection || 0;
          const tileMat = createTexturedMaterial(color, textureUrl, {
            roughness: 0.3,
            metalness: 0.05,
            finish: el.finish || 'polished'
          });

          // Apply texture rotation based on tile direction
          if (tileMat.map) {
            tileMat.map.rotation = tileDir * Math.PI / 180;
            tileMat.map.center.set(0.5, 0.5);
          }

          const tileBase = new THREE.Mesh(
            new THREE.BoxGeometry(w, h, d),
            tileMat
          );
          group.add(tileBase);

          // Grout lines - create a group that can be rotated
          const groutGroup = new THREE.Group();
          const tileGroutMat = new THREE.MeshStandardMaterial({ color: 0x888888, roughness: 0.9 });
          const tileSz = 0.5;

          // Grout line dimensions: thin strips sitting ON the tile surface
          const groutH = 0.008; // Thin grout strip
          const groutY = h / 2;  // Position at tile top surface

          if (tileDir === 45 || tileDir === 135) {
            // Diagonal tiles - rotate grout lines
            const diagonal = Math.sqrt(w * w + d * d);
            for (let t = -diagonal/2 + tileSz; t < diagonal/2; t += tileSz) {
              const line1 = new THREE.Mesh(
                new THREE.BoxGeometry(0.015, groutH, diagonal + 0.5),
                tileGroutMat
              );
              line1.position.set(t, groutY, 0);
              groutGroup.add(line1);

              const line2 = new THREE.Mesh(
                new THREE.BoxGeometry(diagonal + 0.5, groutH, 0.015),
                tileGroutMat
              );
              line2.position.set(0, groutY, t);
              groutGroup.add(line2);
            }
            groutGroup.rotation.y = tileDir * Math.PI / 180;
          } else {
            // Standard grid pattern
            for (let tx = -w/2 + tileSz; tx < w/2; tx += tileSz) {
              const vLine = new THREE.Mesh(
                new THREE.BoxGeometry(0.015, groutH, d + 0.005),
                tileGroutMat
              );
              vLine.position.set(tx, groutY, 0);
              groutGroup.add(vLine);
            }
            for (let tz = -d/2 + tileSz; tz < d/2; tz += tileSz) {
              const hLine = new THREE.Mesh(
                new THREE.BoxGeometry(w + 0.005, groutH, 0.015),
                tileGroutMat
              );
              hLine.position.set(0, groutY, tz);
              groutGroup.add(hLine);
            }
          }
          group.add(groutGroup);
          break;
        }

        // ===== SHOWER COMPONENTS =====
        case 'shower-pan': {
          // Shower pan/base with slope and drain
          const panMat = createTexturedMaterial(color, textureUrl, {
            roughness: 0.6,
            metalness: 0.1,
            finish: el.finish || 'polished'
          });

          // Main pan surface (slightly recessed in center for slope)
          const panBase = new THREE.Mesh(
            new THREE.BoxGeometry(w, 0.08, d),
            panMat
          );
          panBase.receiveShadow = true;
          group.add(panBase);

          // Drain in center
          const drainMat = new THREE.MeshStandardMaterial({
            color: 0x666666,
            roughness: 0.3,
            metalness: 0.8
          });
          const drain = new THREE.Mesh(
            new THREE.CylinderGeometry(0.15, 0.15, 0.02, 16),
            drainMat
          );
          drain.rotation.x = Math.PI / 2;
          drain.position.set(0, 0.05, 0);
          group.add(drain);

          // Drain grate
          const grateMat = new THREE.MeshStandardMaterial({ color: 0x888888, metalness: 0.7 });
          for (let gi = -2; gi <= 2; gi++) {
            const grate = new THREE.Mesh(
              new THREE.BoxGeometry(0.25, 0.01, 0.015),
              grateMat
            );
            grate.position.set(0, 0.055, gi * 0.04);
            group.add(grate);
          }
          break;
        }

        case 'shower-curb': {
          // Shower curb/threshold
          const curbMat = createTexturedMaterial(color, textureUrl, {
            roughness: 0.5,
            metalness: 0.05
          });

          // Main curb body
          const curb = new THREE.Mesh(
            new THREE.BoxGeometry(w, 0.5, d),  // 6" high curb
            curbMat
          );
          curb.castShadow = true;
          curb.receiveShadow = true;
          group.add(curb);

          // Rounded top edge
          const edgeRadius = 0.05;
          const edgeShape = new THREE.Shape();
          edgeShape.absarc(0, 0, edgeRadius, 0, Math.PI, false);
          const edgeGeom = new THREE.ExtrudeGeometry(edgeShape, { steps: 1, depth: w, bevelEnabled: false });
          const edge = new THREE.Mesh(edgeGeom, curbMat);
          edge.rotation.y = Math.PI / 2;
          edge.position.set(w/2, 0.25 - edgeRadius, d/2);
          group.add(edge);
          break;
        }

        case 'shower-wall':
        case 'wall-tile':
        case 'accent-wall': {
          // Vertical wall panel with tile texture
          const isShower = el.type === 'shower-wall';
          const panelThickness = isShower ? 0.05 : 0.04;

          const panelMat = createTexturedMaterial(color, textureUrl, {
            roughness: isShower ? 0.15 : 0.3,
            metalness: isShower ? 0.1 : 0.05,
            finish: el.finish || 'polished'
          });

          // Main panel (vertical orientation)
          const panelHeight = el.wallHeight || (isShower ? 7 : 8);
          const panel = new THREE.Mesh(
            new THREE.BoxGeometry(w, panelHeight, panelThickness),
            panelMat
          );
          panel.position.y = panelHeight / 2 - h / 2;
          panel.castShadow = true;
          panel.receiveShadow = true;
          group.add(panel);

          // Add grout lines for tile look
          if (el.showGrout !== false) {
            const groutMat = new THREE.MeshStandardMaterial({ color: 0x9a9a9a, roughness: 0.9 });
            const tileSz = el.tileSize || 0.5;

            // Vertical grout lines
            for (let tx = -w/2 + tileSz; tx < w/2; tx += tileSz) {
              const vGrout = new THREE.Mesh(
                new THREE.BoxGeometry(0.01, panelHeight - 0.1, 0.005),
                groutMat
              );
              vGrout.position.set(tx, panelHeight/2 - h/2, panelThickness/2 + 0.003);
              group.add(vGrout);
            }

            // Horizontal grout lines
            for (let ty = tileSz; ty < panelHeight; ty += tileSz) {
              const hGrout = new THREE.Mesh(
                new THREE.BoxGeometry(w - 0.05, 0.01, 0.005),
                groutMat
              );
              hGrout.position.set(0, ty - h/2, panelThickness/2 + 0.003);
              group.add(hGrout);
            }
          }

          // Add trim for shower walls
          if (isShower) {
            const trimMat = new THREE.MeshStandardMaterial({ color: 0xC0C0C0, roughness: 0.3, metalness: 0.5 });

            // Top trim/cap
            const topTrim = new THREE.Mesh(
              new THREE.BoxGeometry(w + 0.02, 0.02, panelThickness + 0.02),
              trimMat
            );
            topTrim.position.set(0, panelHeight - h/2, 0);
            group.add(topTrim);

            // Side trims
            [-1, 1].forEach(side => {
              const sideTrim = new THREE.Mesh(
                new THREE.BoxGeometry(0.02, panelHeight, panelThickness + 0.02),
                trimMat
              );
              sideTrim.position.set(side * (w/2 + 0.01), panelHeight/2 - h/2, 0);
              group.add(sideTrim);
            });
          }
          break;
        }

        // ===== STONE CAPS & LEDGES =====
        case 'wall-cap':
        case 'bar-top': {
          // Stone cap/ledge for pony walls, bars, entryways
          // Enhanced rendering with visible overhang and edge profiles
          const isBarTop = el.type === 'bar-top';
          const capThickness = el.thickness || el.stoneThickness || (isBarTop ? 0.125 : 0.1);
          const overhang = el.overhang || (isBarTop ? 0.12 : 0.06); // How much cap extends beyond wall

          // Material with accurate color/texture display
          const capMat = createTexturedMaterial(color, textureUrl, {
            roughness: 0.35,
            metalness: 0.03,
            finish: el.finish || 'polished'
          });

          // Main cap surface with overhang on all visible sides
          const capWidth = w + overhang * 2;
          const capDepth = d + overhang;
          const cap = new THREE.Mesh(
            new THREE.BoxGeometry(capWidth, capThickness, capDepth),
            capMat
          );
          cap.position.set(0, 0, overhang / 2);
          cap.castShadow = true;
          cap.receiveShadow = true;
          group.add(cap);

          // Edge profile
          const edgeProfile = el.edgeProfile || 'eased';
          const edgeRadius = capThickness * 0.4;

          if (edgeProfile === 'bullnose' || edgeProfile === 'half-bullnose' || edgeProfile === 'full-bullnose') {
            // Front bullnose edge - rounded profile at TOP of front edge
            const frontEdge = new THREE.Mesh(
              new THREE.CylinderGeometry(edgeRadius, edgeRadius, capWidth, 16, 1, false, 0, Math.PI),
              capMat
            );
            frontEdge.rotation.x = Math.PI / 2;
            frontEdge.rotation.z = Math.PI / 2;
            // Position at TOP of edge (positive Y), not bottom
            frontEdge.position.set(0, capThickness / 2 - edgeRadius * 0.3, d / 2 + overhang);
            frontEdge.castShadow = true;
            group.add(frontEdge);

            // Side bullnose edges (left and right) - also at TOP
            [-1, 1].forEach(side => {
              const sideEdge = new THREE.Mesh(
                new THREE.CylinderGeometry(edgeRadius * 0.8, edgeRadius * 0.8, capDepth - 0.04, 12, 1, false, 0, Math.PI),
                capMat
              );
              sideEdge.rotation.x = 0;
              sideEdge.rotation.z = side * Math.PI / 2;
              // Position at TOP of edge
              sideEdge.position.set(side * (capWidth / 2 - edgeRadius * 0.3), capThickness / 2 - edgeRadius * 0.3, overhang / 2);
              group.add(sideEdge);
            });
          } else if (edgeProfile === 'ogee') {
            // Ogee profile - decorative S-curve with bulge at TOP of edge
            // Upper decorative bulge (convex portion - visible from top)
            const ogeeBulge = new THREE.Mesh(
              new THREE.BoxGeometry(capWidth - 0.02, capThickness * 0.2, 0.025),
              capMat
            );
            ogeeBulge.position.set(0, capThickness * 0.15, d / 2 + overhang + 0.015);
            ogeeBulge.castShadow = true;
            group.add(ogeeBulge);

            // Middle concave suggestion (step back creates shadow line)
            const ogeeMiddle = new THREE.Mesh(
              new THREE.BoxGeometry(capWidth - 0.04, capThickness * 0.15, 0.012),
              capMat
            );
            ogeeMiddle.position.set(0, -capThickness * 0.1, d / 2 + overhang + 0.005);
            group.add(ogeeMiddle);

            // Lower portion - flat face leading to underside
            const ogeeLower = new THREE.Mesh(
              new THREE.BoxGeometry(capWidth - 0.02, capThickness * 0.2, 0.015),
              capMat
            );
            ogeeLower.position.set(0, -capThickness * 0.35, d / 2 + overhang + 0.008);
            group.add(ogeeLower);
          } else if (edgeProfile === 'double-ogee') {
            // Double ogee - two S-curves stacked with bulges at top of each
            // Upper S-curve bulge
            const dblOgeeTop = new THREE.Mesh(
              new THREE.BoxGeometry(capWidth - 0.02, capThickness * 0.15, 0.02),
              capMat
            );
            dblOgeeTop.position.set(0, capThickness * 0.2, d / 2 + overhang + 0.012);
            dblOgeeTop.castShadow = true;
            group.add(dblOgeeTop);

            // Upper concave
            const dblOgeeUpperMid = new THREE.Mesh(
              new THREE.BoxGeometry(capWidth - 0.04, capThickness * 0.1, 0.008),
              capMat
            );
            dblOgeeUpperMid.position.set(0, capThickness * 0.05, d / 2 + overhang + 0.003);
            group.add(dblOgeeUpperMid);

            // Lower S-curve bulge
            const dblOgeeLowerBulge = new THREE.Mesh(
              new THREE.BoxGeometry(capWidth - 0.02, capThickness * 0.12, 0.018),
              capMat
            );
            dblOgeeLowerBulge.position.set(0, -capThickness * 0.15, d / 2 + overhang + 0.01);
            group.add(dblOgeeLowerBulge);

            // Lower portion
            const dblOgeeLower = new THREE.Mesh(
              new THREE.BoxGeometry(capWidth - 0.04, capThickness * 0.15, 0.012),
              capMat
            );
            dblOgeeLower.position.set(0, -capThickness * 0.35, d / 2 + overhang + 0.005);
            group.add(dblOgeeLower);
          } else if (edgeProfile === 'dupont') {
            // Dupont - stepped profile with rounded top
            // Rounded top portion (bullnose-like)
            const dupontTop = new THREE.Mesh(
              new THREE.CylinderGeometry(capThickness * 0.2, capThickness * 0.2, capWidth - 0.02, 12, 1, false, 0, Math.PI),
              capMat
            );
            dupontTop.rotation.x = Math.PI / 2;
            dupontTop.rotation.z = Math.PI / 2;
            dupontTop.position.set(0, capThickness * 0.15, d / 2 + overhang + 0.01);
            dupontTop.castShadow = true;
            group.add(dupontTop);

            // Middle step (the characteristic dupont ledge)
            const dupontLedge = new THREE.Mesh(
              new THREE.BoxGeometry(capWidth - 0.04, capThickness * 0.12, 0.03),
              capMat
            );
            dupontLedge.position.set(0, -capThickness * 0.1, d / 2 + overhang - 0.005);
            group.add(dupontLedge);

            // Lower flat portion
            const dupontLower = new THREE.Mesh(
              new THREE.BoxGeometry(capWidth - 0.02, capThickness * 0.25, 0.015),
              capMat
            );
            dupontLower.position.set(0, -capThickness * 0.35, d / 2 + overhang + 0.008);
            group.add(dupontLower);
          } else {
            // Eased edge - subtle chamfer
            const easedEdge = new THREE.Mesh(
              new THREE.BoxGeometry(capWidth, capThickness * 0.2, 0.015),
              capMat
            );
            easedEdge.rotation.x = Math.PI / 6;
            easedEdge.position.set(0, -capThickness * 0.42, d / 2 + overhang + 0.008);
            group.add(easedEdge);
          }

          // Underside detail for depth and shadow
          const undersideMat = new THREE.MeshStandardMaterial({
            color: adjustColorBrightness(color, -35),
            roughness: 0.65
          });

          // Front underside reveal
          const frontReveal = new THREE.Mesh(
            new THREE.BoxGeometry(capWidth - 0.04, 0.025, 0.025),
            undersideMat
          );
          frontReveal.position.set(0, -capThickness / 2 - 0.012, d / 2 + overhang - 0.012);
          group.add(frontReveal);

          // Side reveals for depth
          [-1, 1].forEach(side => {
            const sideReveal = new THREE.Mesh(
              new THREE.BoxGeometry(0.025, 0.02, capDepth - 0.06),
              undersideMat
            );
            sideReveal.position.set(side * (capWidth / 2 - 0.015), -capThickness / 2 - 0.01, overhang / 2);
            group.add(sideReveal);
          });

          break;
        }

        case 'window-sill':
        case 'threshold': {
          // Window sill or door threshold - with visible depth and edge profile
          const isWindowSill = el.type === 'window-sill';
          const slabThickness = el.stoneThickness || (isWindowSill ? 0.08 : 0.04);
          const overhang = isWindowSill ? 0.08 : 0.02; // How much sill sticks out from wall

          const slabMat = createTexturedMaterial(color, textureUrl, {
            roughness: 0.35,
            metalness: 0.05,
            finish: el.finish || 'polished'
          });

          // Main slab with overhang for visibility
          const slab = new THREE.Mesh(
            new THREE.BoxGeometry(w + (isWindowSill ? 0.1 : 0), slabThickness, d + overhang),
            slabMat
          );
          slab.position.set(0, 0, overhang / 2);
          slab.castShadow = true;
          slab.receiveShadow = true;
          group.add(slab);

          // Edge profile based on type
          const edgeProfile = el.edgeProfile || 'eased';
          const edgeRadius = slabThickness * 0.4;

          if (edgeProfile === 'bullnose' || edgeProfile === 'half-bullnose') {
            // Bullnose front edge
            const frontEdge = new THREE.Mesh(
              new THREE.CylinderGeometry(edgeRadius, edgeRadius, w + (isWindowSill ? 0.1 : 0), 12, 1, false, 0, Math.PI),
              slabMat
            );
            frontEdge.rotation.x = Math.PI / 2;
            frontEdge.rotation.z = Math.PI / 2;
            frontEdge.position.set(0, -slabThickness / 2 + edgeRadius * 0.5, d / 2 + overhang);
            group.add(frontEdge);
          } else {
            // Eased edge (chamfer)
            const easedEdge = new THREE.Mesh(
              new THREE.BoxGeometry(w + (isWindowSill ? 0.08 : 0), slabThickness * 0.25, 0.015),
              slabMat
            );
            easedEdge.rotation.x = Math.PI / 6; // Slight angle
            easedEdge.position.set(0, -slabThickness * 0.4, d / 2 + overhang + 0.008);
            group.add(easedEdge);
          }

          // For window sill, add subtle return sides for depth
          if (isWindowSill && d > 0.2) {
            const returnDepth = 0.06;
            // Left return
            const leftReturn = new THREE.Mesh(
              new THREE.BoxGeometry(returnDepth, slabThickness, d * 0.8),
              slabMat
            );
            leftReturn.position.set(-w / 2 - returnDepth / 2 + 0.02, 0, -d * 0.1);
            group.add(leftReturn);

            // Right return
            const rightReturn = new THREE.Mesh(
              new THREE.BoxGeometry(returnDepth, slabThickness, d * 0.8),
              slabMat
            );
            rightReturn.position.set(w / 2 + returnDepth / 2 - 0.02, 0, -d * 0.1);
            group.add(rightReturn);
          }

          // Underside shadow detail for depth
          const undersideMat = new THREE.MeshStandardMaterial({
            color: adjustColorBrightness(color, -40),
            roughness: 0.7
          });
          const underside = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.02, 0.01, 0.03),
            undersideMat
          );
          underside.position.set(0, -slabThickness / 2 - 0.005, d / 2 + overhang - 0.015);
          group.add(underside);

          break;
        }

        case 'mantel': {
          // Fireplace mantel/shelf
          const mantelThickness = el.stoneThickness || 0.1;
          const mantelMat = createTexturedMaterial(color, textureUrl, {
            roughness: 0.5,
            metalness: 0,
            finish: el.finish || 'polished'
          });

          // Main mantel shelf
          const mantelShelf = new THREE.Mesh(
            new THREE.BoxGeometry(w, mantelThickness, d),
            mantelMat
          );
          group.add(mantelShelf);

          // Corbels/brackets on each end
          const corbelMat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.6 });
          const leftCorbel = new THREE.Mesh(
            new THREE.BoxGeometry(0.15, 0.25, d * 0.8),
            corbelMat
          );
          leftCorbel.position.set(-w / 2 + 0.1, -0.175, 0);
          group.add(leftCorbel);

          const rightCorbel = new THREE.Mesh(
            new THREE.BoxGeometry(0.15, 0.25, d * 0.8),
            corbelMat
          );
          rightCorbel.position.set(w / 2 - 0.1, -0.175, 0);
          group.add(rightCorbel);
          break;
        }

        // ===== STONE SURROUNDS WITH RECESSED VOID =====
        case 'niche-surround':
        case 'fireplace-surround': {
          // Stone surround with proper recessed dark void and stone ledges wrapping into the recess
          const isFireplace = el.type === 'fireplace-surround';
          const frameW = el.frameWidth || 0.15; // ~2" frame width on face
          const frameD = el.stoneThickness || 0.1; // Stone face thickness
          const recessDepth = el.nicheDepth || (isFireplace ? 1.0 : 0.5); // Depth of void (6" standard, 12" fireplace)

          // Opening dimensions (inside the frame)
          const openingW = w - frameW * 2;
          const openingH = h - frameW * 2;

          // Stone material with texture
          const surroundMat = createTexturedMaterial(color, textureUrl, {
            roughness: 0.35,
            metalness: 0.08,
            finish: el.finish || 'polished'
          });

          // Darker interior material for the void
          const voidMat = new THREE.MeshStandardMaterial({
            color: 0x0a0a0a,
            roughness: 0.95,
            metalness: 0
          });

          // === RECESSED VOID (dark box behind the frame) ===
          // Back wall of void
          const backWall = new THREE.Mesh(
            new THREE.PlaneGeometry(openingW, openingH),
            voidMat
          );
          backWall.position.set(0, 0, -recessDepth);
          group.add(backWall);

          // Left void wall
          const leftVoid = new THREE.Mesh(
            new THREE.PlaneGeometry(recessDepth, openingH),
            voidMat
          );
          leftVoid.rotation.y = Math.PI / 2;
          leftVoid.position.set(-openingW / 2, 0, -recessDepth / 2);
          group.add(leftVoid);

          // Right void wall
          const rightVoid = new THREE.Mesh(
            new THREE.PlaneGeometry(recessDepth, openingH),
            voidMat
          );
          rightVoid.rotation.y = -Math.PI / 2;
          rightVoid.position.set(openingW / 2, 0, -recessDepth / 2);
          group.add(rightVoid);

          // Top void ceiling
          const topVoid = new THREE.Mesh(
            new THREE.PlaneGeometry(openingW, recessDepth),
            voidMat
          );
          topVoid.rotation.x = Math.PI / 2;
          topVoid.position.set(0, openingH / 2, -recessDepth / 2);
          group.add(topVoid);

          // Bottom void floor
          const bottomVoid = new THREE.Mesh(
            new THREE.PlaneGeometry(openingW, recessDepth),
            voidMat
          );
          bottomVoid.rotation.x = -Math.PI / 2;
          bottomVoid.position.set(0, -openingH / 2, -recessDepth / 2);
          group.add(bottomVoid);

          // === STONE FRAME (Front Face) ===
          // Top stone piece (face)
          const topFace = new THREE.Mesh(
            new THREE.BoxGeometry(w, frameW, frameD),
            surroundMat
          );
          topFace.position.set(0, h / 2 - frameW / 2, frameD / 2);
          topFace.castShadow = true;
          group.add(topFace);

          // Bottom stone piece (face) - wider for fireplace hearth ledge
          const bottomFaceH = isFireplace ? frameW * 1.5 : frameW;
          const bottomFace = new THREE.Mesh(
            new THREE.BoxGeometry(w, bottomFaceH, isFireplace ? frameD * 1.5 : frameD),
            surroundMat
          );
          bottomFace.position.set(0, -h / 2 + bottomFaceH / 2, isFireplace ? frameD * 0.75 : frameD / 2);
          bottomFace.castShadow = true;
          group.add(bottomFace);

          // Left stone piece (face)
          const leftFace = new THREE.Mesh(
            new THREE.BoxGeometry(frameW, openingH, frameD),
            surroundMat
          );
          leftFace.position.set(-w / 2 + frameW / 2, 0, frameD / 2);
          leftFace.castShadow = true;
          group.add(leftFace);

          // Right stone piece (face)
          const rightFace = new THREE.Mesh(
            new THREE.BoxGeometry(frameW, openingH, frameD),
            surroundMat
          );
          rightFace.position.set(w / 2 - frameW / 2, 0, frameD / 2);
          rightFace.castShadow = true;
          group.add(rightFace);

          // === STONE LEDGES (Returns into the recess - visible from front) ===
          const ledgeDepth = Math.min(recessDepth * 0.3, 0.25); // How far ledges go into void

          // Top ledge (stone sill at top of opening, goes into void)
          const topLedge = new THREE.Mesh(
            new THREE.BoxGeometry(openingW, frameD * 0.6, ledgeDepth),
            surroundMat
          );
          topLedge.position.set(0, openingH / 2 - frameD * 0.3, -ledgeDepth / 2);
          topLedge.castShadow = true;
          topLedge.receiveShadow = true;
          group.add(topLedge);

          // Bottom ledge/sill (most visible - like a window sill)
          const sillThickness = frameD * 0.8;
          const sillDepth = ledgeDepth * 1.2;
          const bottomSill = new THREE.Mesh(
            new THREE.BoxGeometry(openingW + 0.02, sillThickness, sillDepth),
            surroundMat
          );
          bottomSill.position.set(0, -openingH / 2 + sillThickness / 2, -sillDepth / 2 + 0.01);
          bottomSill.castShadow = true;
          bottomSill.receiveShadow = true;
          group.add(bottomSill);

          // Left inside ledge (return into void)
          const leftLedge = new THREE.Mesh(
            new THREE.BoxGeometry(frameD * 0.5, openingH - sillThickness * 2, ledgeDepth),
            surroundMat
          );
          leftLedge.position.set(-openingW / 2 + frameD * 0.25, 0, -ledgeDepth / 2);
          leftLedge.castShadow = true;
          group.add(leftLedge);

          // Right inside ledge (return into void)
          const rightLedge = new THREE.Mesh(
            new THREE.BoxGeometry(frameD * 0.5, openingH - sillThickness * 2, ledgeDepth),
            surroundMat
          );
          rightLedge.position.set(openingW / 2 - frameD * 0.25, 0, -ledgeDepth / 2);
          rightLedge.castShadow = true;
          group.add(rightLedge);

          // === EDGE DETAIL (Eased edge on front of sill) ===
          const edgeProfile = el.edgeProfile || 'eased';
          if (edgeProfile !== 'square' && edgeProfile !== 'flat') {
            const edgeRadius = sillThickness * 0.4;
            // Small rounded edge on the front of bottom sill
            const sillEdge = new THREE.Mesh(
              new THREE.CylinderGeometry(edgeRadius * 0.3, edgeRadius * 0.3, openingW, 8, 1, false, 0, Math.PI),
              surroundMat
            );
            sillEdge.rotation.x = Math.PI / 2;
            sillEdge.rotation.z = Math.PI / 2;
            sillEdge.position.set(0, -openingH / 2 + sillThickness * 0.15, frameD * 0.3);
            group.add(sillEdge);
          }

          break;
        }

        case 'fireplace-hearth': {
          // Hearth stone (floor piece in front of fireplace)
          const hearthThickness = el.stoneThickness || 0.08;
          const hearthMat = createTexturedMaterial(color, textureUrl, {
            roughness: 0.35,
            metalness: 0.05,
            finish: el.finish || 'polished'
          });

          // Main hearth slab
          const hearth = new THREE.Mesh(
            new THREE.BoxGeometry(w, hearthThickness, d),
            hearthMat
          );
          group.add(hearth);

          // Raised edge at back
          const backEdge = new THREE.Mesh(
            new THREE.BoxGeometry(w, 0.15, hearthThickness),
            hearthMat
          );
          backEdge.position.set(0, 0.035, -d / 2 + hearthThickness / 2);
          group.add(backEdge);

          // Bullnose front edge
          const edgeRadius = hearthThickness / 2;
          const frontEdge = new THREE.Mesh(
            new THREE.CylinderGeometry(edgeRadius, edgeRadius, w, 12, 1, false, 0, Math.PI),
            hearthMat
          );
          frontEdge.rotation.z = Math.PI / 2;
          frontEdge.rotation.y = Math.PI / 2;
          frontEdge.position.set(0, 0, d / 2);
          group.add(frontEdge);
          break;
        }

        case 'sink':
        case 'sink-double':
        case 'sink-farmhouse': {
          // Determine sink style
          const isDouble = el.type === 'sink-double';
          const isFarmhouse = el.type === 'sink-farmhouse' || el.mountType === 'farmhouse';
          const isTopmount = el.mountType === 'topmount';
          const isUndermount = el.mountType === 'undermount' || (!isTopmount && !isFarmhouse);

          // Debug logging
          console.log('Sink render:', el.type, 'mountType:', el.mountType, 'isTopmount:', isTopmount, 'isUndermount:', isUndermount);

          // Get sink color/finish from element property
          const sinkFinish = el.sinkColor || (isFarmhouse ? 'white' : 'stainless');

          // Sink finish color configurations
          const sinkFinishes = {
            stainless: { color: 0xD8D8D8, roughness: 0.25, metalness: 0.85, basinColor: 0x3a3a3a, basinMetal: 0.6 },
            black: { color: 0x2A2A2A, roughness: 0.35, metalness: 0.4, basinColor: 0x1a1a1a, basinMetal: 0.3 },
            white: { color: 0xFFFEF7, roughness: 0.6, metalness: 0.05, basinColor: 0xF8F8F0, basinMetal: 0 },
            graphite: { color: 0x4A4A4A, roughness: 0.4, metalness: 0.3, basinColor: 0x2a2a2a, basinMetal: 0.2 },
            bisque: { color: 0xF5E6D3, roughness: 0.5, metalness: 0.05, basinColor: 0xE8D8C8, basinMetal: 0 },
            bronze: { color: 0x5C4033, roughness: 0.35, metalness: 0.7, basinColor: 0x3a2a20, basinMetal: 0.5 }
          };

          const finish = sinkFinishes[sinkFinish] || sinkFinishes.stainless;

          // Materials based on selected finish with environment maps for reflections
          const sinkMat = new THREE.MeshStandardMaterial({
            color: finish.color,
            roughness: finish.roughness,
            metalness: finish.metalness,
            envMap: finish.metalness > 0.3 ? window.roomEnvMap : null,
            envMapIntensity: finish.metalness > 0.5 ? 1.0 : 0.5
          });

          const basinMat = new THREE.MeshStandardMaterial({
            color: finish.basinColor,
            roughness: finish.roughness + 0.1,
            metalness: finish.basinMetal,
            envMap: finish.basinMetal > 0.3 ? window.roomEnvMap : null,
            envMapIntensity: 0.6
          });

          // Chrome for faucets - adjust based on sink finish
          const chromeFinishes = {
            stainless: { color: 0xE0E0E0, metalness: 0.95 },
            black: { color: 0x1a1a1a, metalness: 0.7 },
            white: { color: 0xE0E0E0, metalness: 0.95 },
            graphite: { color: 0x3a3a3a, metalness: 0.8 },
            bisque: { color: 0xE0E0E0, metalness: 0.95 },
            bronze: { color: 0x5C4033, metalness: 0.8 }
          };
          const chromeConfig = chromeFinishes[sinkFinish] || chromeFinishes.stainless;

          const chromeMat = new THREE.MeshStandardMaterial({
            color: chromeConfig.color,
            roughness: 0.05,
            metalness: chromeConfig.metalness,
            envMap: window.roomEnvMap || null,
            envMapIntensity: 1.5 // Chrome is highly reflective
          });

          // Sink depth (how deep the basin goes)
          const basinDepth = isFarmhouse ? 0.75 : 0.6;

          if (isFarmhouse) {
            // Farmhouse/Apron sink - visible front face
            // Outer shell
            const shell = new THREE.Mesh(
              new THREE.BoxGeometry(w, basinDepth, d),
              sinkMat
            );
            shell.position.y = -basinDepth/2 + 0.05;
            group.add(shell);

            // Apron front (visible below counter)
            const apron = new THREE.Mesh(
              new THREE.BoxGeometry(w + 0.02, basinDepth + 0.1, 0.08),
              sinkMat
            );
            apron.position.set(0, -basinDepth/2, d/2);
            group.add(apron);

            // Inner basin
            const innerBasin = new THREE.Mesh(
              new THREE.BoxGeometry(w - 0.12, basinDepth - 0.1, d - 0.12),
              basinMat
            );
            innerBasin.position.y = -basinDepth/2 + 0.02;
            group.add(innerBasin);

            // Drain
            const drain = new THREE.Mesh(
              new THREE.CylinderGeometry(0.04, 0.04, 0.05, 16),
              chromeMat
            );
            drain.position.set(0, -basinDepth + 0.1, 0);
            group.add(drain);

          } else if (isDouble) {
            // Double basin sink
            const rimThickness = 0.06;
            const dividerWidth = 0.08;

            // Outer rim
            const rim = new THREE.Mesh(
              new THREE.BoxGeometry(w, rimThickness, d),
              sinkMat
            );
            rim.position.y = rimThickness/2;
            group.add(rim);

            // Left basin
            const leftBasinW = (w - dividerWidth) / 2 - 0.08;
            const leftBasin = new THREE.Mesh(
              new THREE.BoxGeometry(leftBasinW, basinDepth, d - 0.12),
              basinMat
            );
            leftBasin.position.set(-w/4 - dividerWidth/4, -basinDepth/2 + rimThickness, 0);
            group.add(leftBasin);

            // Right basin
            const rightBasin = new THREE.Mesh(
              new THREE.BoxGeometry(leftBasinW, basinDepth, d - 0.12),
              basinMat
            );
            rightBasin.position.set(w/4 + dividerWidth/4, -basinDepth/2 + rimThickness, 0);
            group.add(rightBasin);

            // Center divider
            const divider = new THREE.Mesh(
              new THREE.BoxGeometry(dividerWidth, basinDepth * 0.8, d - 0.15),
              sinkMat
            );
            divider.position.set(0, -basinDepth/2 + rimThickness + 0.05, 0);
            group.add(divider);

            // Drains
            const leftDrain = new THREE.Mesh(
              new THREE.CylinderGeometry(0.03, 0.03, 0.04, 16),
              chromeMat
            );
            leftDrain.position.set(-w/4 - dividerWidth/4, -basinDepth + rimThickness + 0.05, 0);
            group.add(leftDrain);

            const rightDrain = new THREE.Mesh(
              new THREE.CylinderGeometry(0.03, 0.03, 0.04, 16),
              chromeMat
            );
            rightDrain.position.set(w/4 + dividerWidth/4, -basinDepth + rimThickness + 0.05, 0);
            group.add(rightDrain);

          } else {
            // ================================================================
            // SINGLE BASIN SINK - Realistic undermount or top-mount design
            // Based on actual sink construction: 16-gauge stainless steel,
            // 10" deep basin, tight radius corners, 3.5" drain opening
            // ================================================================

            // Sink dimensions (realistic proportions)
            const sinkDepth = 0.83; // 10 inches deep (standard kitchen sink)
            const wallThickness = 0.025; // 16-gauge stainless (~1/16")
            const cornerRadius = 0.08; // Tight radius corners
            const countertopThick = 0.1; // 1.2" countertop thickness

            // Basin interior dimensions
            const basinW = w - wallThickness * 2;
            const basinD = d - wallThickness * 2;

            // Stainless steel material for sink body
            const stainlessMat = new THREE.MeshStandardMaterial({
              color: finish.color,
              roughness: finish.roughness,
              metalness: finish.metalness,
              envMap: window.roomEnvMap || null,
              envMapIntensity: 1.2,
              side: THREE.DoubleSide
            });

            // Darker interior for depth perception - use DoubleSide to ensure visibility
            const interiorMat = new THREE.MeshStandardMaterial({
              color: new THREE.Color(finish.basinColor).multiplyScalar(0.7),
              roughness: 0.35,
              metalness: finish.basinMetal + 0.2,
              envMap: window.roomEnvMap || null,
              envMapIntensity: 0.5,
              side: THREE.DoubleSide
            });

            // Very dark bottom - also use DoubleSide
            const bottomMat = new THREE.MeshStandardMaterial({
              color: new THREE.Color(finish.basinColor).multiplyScalar(0.4),
              roughness: 0.4,
              metalness: finish.basinMetal + 0.3,
              side: THREE.DoubleSide
            });

            // === TOP MOUNT (Drop-in) - Visible rim on countertop ===
            if (isTopmount) {
              const rimWidth = 0.05; // 5/8" rim flange
              const rimHeight = 0.025;

              // Rim flange (sits on countertop)
              const rimGeo = new THREE.BoxGeometry(w + rimWidth * 2, rimHeight, d + rimWidth * 2);
              const rim = new THREE.Mesh(rimGeo, stainlessMat);
              rim.position.y = rimHeight / 2;
              group.add(rim);

              // Rim lip edge (slight raised edge)
              const lipHeight = 0.015;
              const lip = new THREE.Mesh(
                new THREE.BoxGeometry(w + rimWidth * 2 + 0.01, lipHeight, d + rimWidth * 2 + 0.01),
                stainlessMat
              );
              lip.position.y = rimHeight + lipHeight / 2;
              group.add(lip);
            }

            // === UNDERMOUNT - Basin visible through countertop cutout ===
            // For undermount sinks, the countertop has a hole cut out and the basin
            // is attached underneath. The countertop ShapeGeometry with holes provides
            // the visible edge - no additional geometry needed here.

            // === SINK BASIN (the actual stainless steel bowl) ===
            // Basin starts below countertop surface
            // For undermount: basin top is at countertop bottom (negative reveal - slight countertop overhang)
            // For top mount: basin starts at rim level
            const basinTop = isUndermount ? -0.10 : 0; // Undermount: at countertop bottom (1.2" thick countertop)

            // Basin wall thickness (stainless steel gauge)
            const wallThick = 0.025; // ~0.3 inches thick for visibility
            const btmY = basinTop - sinkDepth;
            const basinHeight = sinkDepth; // Total depth of basin

            // Use BoxGeometry for solid 3D walls that render from all angles
            // Front wall (facing into room)
            const frontWallMesh = new THREE.Mesh(
              new THREE.BoxGeometry(basinW, basinHeight, wallThick),
              interiorMat
            );
            frontWallMesh.position.set(0, basinTop - basinHeight/2, basinD/2 - wallThick/2);
            group.add(frontWallMesh);

            // Back wall
            const backWallMesh = new THREE.Mesh(
              new THREE.BoxGeometry(basinW, basinHeight, wallThick),
              interiorMat
            );
            backWallMesh.position.set(0, basinTop - basinHeight/2, -basinD/2 + wallThick/2);
            group.add(backWallMesh);

            // Left wall
            const leftWallMesh = new THREE.Mesh(
              new THREE.BoxGeometry(wallThick, basinHeight, basinD - wallThick * 2),
              interiorMat
            );
            leftWallMesh.position.set(-basinW/2 + wallThick/2, basinTop - basinHeight/2, 0);
            group.add(leftWallMesh);

            // Right wall
            const rightWallMesh = new THREE.Mesh(
              new THREE.BoxGeometry(wallThick, basinHeight, basinD - wallThick * 2),
              interiorMat
            );
            rightWallMesh.position.set(basinW/2 - wallThick/2, basinTop - basinHeight/2, 0);
            group.add(rightWallMesh);

            // Basin bottom - solid box for better visibility
            const bottomMesh = new THREE.Mesh(
              new THREE.BoxGeometry(basinW - wallThick * 2, wallThick, basinD - wallThick * 2),
              bottomMat
            );
            bottomMesh.position.set(0, btmY + wallThick/2, 0);
            group.add(bottomMesh);

            // === DRAIN ASSEMBLY (3.5" standard) ===
            const drainRadius = 0.145; // 3.5" diameter / 2

            // Drain flange (chrome ring flush with basin bottom)
            const flangeMat = new THREE.MeshStandardMaterial({
              color: 0xCCCCCC,
              roughness: 0.1,
              metalness: 0.9,
              envMap: window.roomEnvMap || null
            });

            const flange = new THREE.Mesh(
              new THREE.RingGeometry(drainRadius - 0.02, drainRadius, 24),
              flangeMat
            );
            flange.rotation.x = -Math.PI / 2;
            flange.position.y = btmY + 0.01;
            group.add(flange);

            // Drain basket/strainer
            const strainerMat = new THREE.MeshStandardMaterial({
              color: 0x888888,
              roughness: 0.2,
              metalness: 0.85
            });

            // Strainer cross bars
            const crossBar1 = new THREE.Mesh(
              new THREE.BoxGeometry(drainRadius * 1.6, 0.008, 0.015),
              strainerMat
            );
            crossBar1.position.y = btmY + 0.015;
            group.add(crossBar1);

            const crossBar2 = new THREE.Mesh(
              new THREE.BoxGeometry(0.015, 0.008, drainRadius * 1.6),
              strainerMat
            );
            crossBar2.position.y = btmY + 0.015;
            group.add(crossBar2);

            // Center drain hole (dark)
            const drainHole = new THREE.Mesh(
              new THREE.CircleGeometry(drainRadius - 0.03, 24),
              new THREE.MeshBasicMaterial({ color: 0x000000 })
            );
            drainHole.rotation.x = -Math.PI / 2;
            drainHole.position.y = btmY + 0.008;
            group.add(drainHole);
          }

          // === PROFESSIONAL GOOSENECK FAUCET ===
          // Large, bold commercial-style kitchen faucet with realistic proportions

          // Enhanced chrome material for faucet with high reflectivity
          const faucetChromeMat = new THREE.MeshStandardMaterial({
            color: chromeConfig.color,
            roughness: 0.03,
            metalness: 0.98,
            envMap: window.roomEnvMap || null,
            envMapIntensity: 2.0
          });

          // Base deck plate/escutcheon - larger and more detailed
          const deckPlate = new THREE.Mesh(
            new THREE.CylinderGeometry(0.08, 0.09, 0.02, 24),
            faucetChromeMat
          );
          deckPlate.position.set(0, 0.05, -d/2 + 0.15);
          deckPlate.castShadow = true;
          deckPlate.receiveShadow = true;
          group.add(deckPlate);

          // Faucet body base - thicker column
          const faucetBodyBase = new THREE.Mesh(
            new THREE.CylinderGeometry(0.035, 0.045, 0.12, 20),
            faucetChromeMat
          );
          faucetBodyBase.position.set(0, 0.12, -d/2 + 0.15);
          faucetBodyBase.castShadow = true;
          group.add(faucetBodyBase);

          // Create dramatic gooseneck curve - BIGGER and BOLDER
          // Professional kitchen faucet stands about 16-18 inches tall
          const gooseneckPoints = [
            new THREE.Vector3(0, 0.18, -d/2 + 0.15),      // Start at body top
            new THREE.Vector3(0, 0.35, -d/2 + 0.15),      // Rise straight up
            new THREE.Vector3(0, 0.55, -d/2 + 0.16),      // Continue rising
            new THREE.Vector3(0, 0.72, -d/2 + 0.20),      // Start curving forward
            new THREE.Vector3(0, 0.82, -d/2 + 0.30),      // Peak of gooseneck curve
            new THREE.Vector3(0, 0.80, -d/2 + 0.45),      // Curve over
            new THREE.Vector3(0, 0.70, -d/2 + 0.55),      // Descend towards sink
            new THREE.Vector3(0, 0.58, -d/2 + 0.60),      // Spout pointing down
          ];

          const gooseneckCurve = new THREE.CatmullRomCurve3(gooseneckPoints);

          // Thicker tube radius for bold appearance
          const faucetTubeRadius = 0.028;
          const faucetTubeGeo = new THREE.TubeGeometry(
            gooseneckCurve,
            48,  // More segments for smoother curve
            faucetTubeRadius,
            16,  // More radial segments for rounder tube
            false
          );

          const faucetNeck = new THREE.Mesh(faucetTubeGeo, faucetChromeMat);
          faucetNeck.castShadow = true;
          faucetNeck.receiveShadow = true;
          group.add(faucetNeck);

          // Spout tip with aerator detail
          const spoutOuter = new THREE.Mesh(
            new THREE.CylinderGeometry(0.032, 0.028, 0.06, 16),
            faucetChromeMat
          );
          spoutOuter.position.set(0, 0.55, -d/2 + 0.62);
          spoutOuter.rotation.x = Math.PI / 4; // Angled down
          spoutOuter.castShadow = true;
          group.add(spoutOuter);

          // Aerator insert (dark)
          const aeratorMat = new THREE.MeshStandardMaterial({
            color: 0x2a2a2a,
            roughness: 0.6,
            metalness: 0.3
          });
          const aerator = new THREE.Mesh(
            new THREE.CylinderGeometry(0.018, 0.018, 0.02, 12),
            aeratorMat
          );
          aerator.position.set(0, 0.52, -d/2 + 0.64);
          aerator.rotation.x = Math.PI / 4;
          group.add(aerator);

          // Single-handle lever (modern style) - more substantial
          const leverBaseMat = new THREE.MeshStandardMaterial({
            color: chromeConfig.color,
            roughness: 0.05,
            metalness: 0.95,
            envMap: window.roomEnvMap || null,
            envMapIntensity: 1.8
          });

          // Lever pivot base
          const leverPivot = new THREE.Mesh(
            new THREE.CylinderGeometry(0.04, 0.04, 0.04, 16),
            leverBaseMat
          );
          leverPivot.position.set(0, 0.20, -d/2 + 0.15);
          leverPivot.castShadow = true;
          group.add(leverPivot);

          // Lever arm - sleek modern handle
          const leverArm = new THREE.Mesh(
            new THREE.BoxGeometry(0.16, 0.025, 0.035),
            leverBaseMat
          );
          leverArm.position.set(0.06, 0.23, -d/2 + 0.15);
          leverArm.rotation.z = -0.15; // Slight angle
          leverArm.castShadow = true;
          group.add(leverArm);

          // Lever end cap
          const leverEnd = new THREE.Mesh(
            new THREE.SphereGeometry(0.022, 12, 12),
            leverBaseMat
          );
          leverEnd.position.set(0.14, 0.21, -d/2 + 0.15);
          leverEnd.castShadow = true;
          group.add(leverEnd);

          break;
        }

        case 'stove':
        case 'range':
        case 'cooktop': {
          // High-detail professional range/stove/cooktop
          const isCooktopOnly = (el.type === 'cooktop');

          const stoveMat = new THREE.MeshStandardMaterial({
            color: 0x2a2a2a,
            roughness: 0.25,
            metalness: 0.55,
            envMap: window.roomEnvMap || null,
            envMapIntensity: 0.6
          });

          // Main body
          const stoveBody = new THREE.Mesh(
            new THREE.BoxGeometry(w, h, d),
            stoveMat
          );
          group.add(stoveBody);

          // Cooktop surface (black glass)
          const cooktopMat = new THREE.MeshStandardMaterial({
            color: 0x0a0a0a,
            roughness: 0.05,
            metalness: 0.3,
            envMap: window.roomEnvMap || null,
            envMapIntensity: 0.8
          });
          const cooktopSurface = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.06, 0.04, d - 0.1),
            cooktopMat
          );
          cooktopSurface.position.y = h/2 - 0.02;
          group.add(cooktopSurface);

          // Cast iron burner grates with cross-bar detail
          const grateMat = new THREE.MeshStandardMaterial({
            color: 0x1a1a1a,
            roughness: 0.7,
            metalness: 0.25
          });

          const burnerLayout = [
            [-w * 0.25, -d * 0.2], [w * 0.25, -d * 0.2],
            [-w * 0.25, d * 0.2], [w * 0.25, d * 0.2]
          ];

          burnerLayout.forEach(([bx, bz]) => {
            // Grate frame
            const grate = new THREE.Mesh(
              new THREE.BoxGeometry(0.48, 0.035, 0.48),
              grateMat
            );
            grate.position.set(bx, h/2 + 0.018, bz);
            group.add(grate);

            // Grate cross bars (2 perpendicular bars for realism)
            for (let barDir = 0; barDir < 2; barDir++) {
              const bar = new THREE.Mesh(
                new THREE.BoxGeometry(barDir === 0 ? 0.44 : 0.04, 0.03, barDir === 0 ? 0.04 : 0.44),
                grateMat
              );
              bar.position.set(bx, h/2 + 0.025, bz);
              group.add(bar);
            }

            // Burner ring (cast brass look)
            const ringMat = new THREE.MeshStandardMaterial({
              color: 0x444444,
              roughness: 0.4,
              metalness: 0.5
            });
            const ring = new THREE.Mesh(
              new THREE.TorusGeometry(0.14, 0.018, 12, 32),
              ringMat
            );
            ring.rotation.x = Math.PI / 2;
            ring.position.set(bx, h/2 - 0.005, bz);
            group.add(ring);

            // Inner burner cap
            const capMat = new THREE.MeshStandardMaterial({
              color: 0x555555,
              roughness: 0.3,
              metalness: 0.6
            });
            const cap = new THREE.Mesh(
              new THREE.CylinderGeometry(0.06, 0.07, 0.025, 16),
              capMat
            );
            cap.position.set(bx, h/2, bz);
            group.add(cap);
          });

          // Control knobs (polished metal with indicator lines)
          const knobBaseMat = new THREE.MeshStandardMaterial({
            color: 0x505050,
            roughness: 0.2,
            metalness: 0.6,
            envMap: window.roomEnvMap || null,
            envMapIntensity: 0.8
          });
          const knobAccentMat = new THREE.MeshStandardMaterial({
            color: 0xE0E0E0,
            roughness: 0.1,
            metalness: 0.9
          });

          const knobCount = isCooktopOnly ? 4 : 5;
          const knobSpacing = (w - 0.3) / (knobCount + 1);
          for (let i = 0; i < knobCount; i++) {
            // Knob body
            const knob = new THREE.Mesh(
              new THREE.CylinderGeometry(0.04, 0.035, 0.035, 16),
              knobBaseMat
            );
            knob.rotation.x = Math.PI / 2;
            const knobX = -w/2 + 0.15 + (i + 1) * knobSpacing;
            knob.position.set(knobX, h/2 - 0.3, d/2 + 0.025);
            group.add(knob);

            // Knob indicator dot
            const indicator = new THREE.Mesh(
              new THREE.CircleGeometry(0.008, 6),
              knobAccentMat
            );
            indicator.position.set(knobX, h/2 - 0.275, d/2 + 0.045);
            group.add(indicator);
          }

          // Oven section (only for full stove/range, not cooktop)
          if (!isCooktopOnly) {
            // Oven door (brushed stainless)
            const ovenDoorMat = new THREE.MeshStandardMaterial({
              color: 0x353535,
              roughness: 0.2,
              metalness: 0.5,
              envMap: window.roomEnvMap || null,
              envMapIntensity: 0.6
            });
            const ovenDoor = new THREE.Mesh(
              new THREE.BoxGeometry(w - 0.12, h * 0.48, 0.04),
              ovenDoorMat
            );
            ovenDoor.position.set(0, -h * 0.15, d/2 + 0.01);
            group.add(ovenDoor);

            // Oven window (tempered glass, slightly reflective)
            const glassMat = new THREE.MeshStandardMaterial({
              color: 0x0a0a0a,
              roughness: 0.02,
              metalness: 0.15,
              transparent: true,
              opacity: 0.88,
              envMap: window.roomEnvMap || null,
              envMapIntensity: 0.6
            });
            const ovenWindow = new THREE.Mesh(
              new THREE.BoxGeometry(w * 0.55, h * 0.32, 0.015),
              glassMat
            );
            ovenWindow.position.set(0, -h * 0.15, d/2 + 0.04);
            group.add(ovenWindow);

            // Window frame (thin chrome border)
            const frameMat = new THREE.MeshStandardMaterial({
              color: 0x888888,
              roughness: 0.1,
              metalness: 0.85
            });
            // Top frame
            const frameTop = new THREE.Mesh(
              new THREE.BoxGeometry(w * 0.58, 0.02, 0.01),
              frameMat
            );
            frameTop.position.set(0, -h * 0.15 + h * 0.16 + 0.01, d/2 + 0.045);
            group.add(frameTop);
            // Bottom frame
            const frameBottom = new THREE.Mesh(
              new THREE.BoxGeometry(w * 0.58, 0.02, 0.01),
              frameMat
            );
            frameBottom.position.set(0, -h * 0.15 - h * 0.16 - 0.01, d/2 + 0.045);
            group.add(frameBottom);

            // Oven handle (professional towel-bar style)
            const stoveHandleMat = new THREE.MeshStandardMaterial({
              color: 0xC0C0C0,
              roughness: 0.08,
              metalness: 0.95,
              envMap: window.roomEnvMap || null,
              envMapIntensity: 1.6
            });
            const ovenHandle = new THREE.Mesh(
              new THREE.CylinderGeometry(0.02, 0.02, w * 0.65, 12),
              stoveHandleMat
            );
            ovenHandle.rotation.z = Math.PI / 2;
            ovenHandle.position.set(0, h * 0.12, d/2 + 0.09);
            group.add(ovenHandle);
            // Handle brackets
            for (let hSide = -1; hSide <= 1; hSide += 2) {
              const hBracket = new THREE.Mesh(
                new THREE.BoxGeometry(0.03, 0.03, 0.05),
                stoveHandleMat
              );
              hBracket.position.set(hSide * w * 0.28, h * 0.12, d/2 + 0.06);
              group.add(hBracket);
            }

            // Broiler drawer at very bottom
            const broilerMat = new THREE.MeshStandardMaterial({
              color: 0x2e2e2e,
              roughness: 0.3,
              metalness: 0.45
            });
            const broilerDrawer = new THREE.Mesh(
              new THREE.BoxGeometry(w - 0.15, h * 0.1, 0.035),
              broilerMat
            );
            broilerDrawer.position.set(0, -h * 0.44, d/2 + 0.01);
            group.add(broilerDrawer);

            // Broiler handle
            const broilerHandle = new THREE.Mesh(
              new THREE.CylinderGeometry(0.012, 0.012, w * 0.4, 8),
              stoveHandleMat
            );
            broilerHandle.rotation.z = Math.PI / 2;
            broilerHandle.position.set(0, -h * 0.44, d/2 + 0.05);
            group.add(broilerHandle);

            // Brand badge
            const stoveBadgeMat = new THREE.MeshStandardMaterial({
              color: 0x999999,
              roughness: 0.05,
              metalness: 0.95
            });
            const stoveBadge = new THREE.Mesh(
              new THREE.BoxGeometry(0.2, 0.04, 0.004),
              stoveBadgeMat
            );
            stoveBadge.position.set(0, h * 0.05, d/2 + 0.04);
            group.add(stoveBadge);
          }

          break;
        }

        case 'slide-in-range': {
          // Slide-in range - no side panels, fits between cabinets
          // Controls on front face, continuous cooktop surface
          const slideRangeMat = new THREE.MeshStandardMaterial({
            color: 0x303030,
            roughness: 0.3,
            metalness: 0.5
          });

          // Main body (recessed sides to fit between cabinets)
          const rangeBody = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.08, h - 0.1, d - 0.08),
            slideRangeMat
          );
          rangeBody.position.y = 0.05;
          group.add(rangeBody);

          // Cooktop surface extends slightly over countertop
          const cooktopMat = new THREE.MeshStandardMaterial({
            color: 0x1a1a1a,
            roughness: 0.1,
            metalness: 0.4
          });
          const slideCooktop = new THREE.Mesh(
            new THREE.BoxGeometry(w, 0.05, d - 0.1),
            cooktopMat
          );
          slideCooktop.position.y = h/2 + 0.02;
          group.add(slideCooktop);

          // Burner grates
          const slideGrateMat = new THREE.MeshStandardMaterial({
            color: 0x1a1a1a,
            roughness: 0.6,
            metalness: 0.3
          });

          const slideBurnerLayout = [
            [-w * 0.25, -d * 0.15], [w * 0.25, -d * 0.15],
            [-w * 0.25, d * 0.15], [w * 0.25, d * 0.15]
          ];

          slideBurnerLayout.forEach(([bx, bz]) => {
            const grate = new THREE.Mesh(
              new THREE.BoxGeometry(0.45, 0.04, 0.45),
              slideGrateMat
            );
            grate.position.set(bx, h/2 + 0.05, bz);
            group.add(grate);

            const ringMat = new THREE.MeshStandardMaterial({
              color: 0x333333,
              roughness: 0.5,
              metalness: 0.4
            });
            const ring = new THREE.Mesh(
              new THREE.TorusGeometry(0.13, 0.02, 8, 24),
              ringMat
            );
            ring.rotation.x = Math.PI / 2;
            ring.position.set(bx, h/2 + 0.02, bz);
            group.add(ring);
          });

          // Front control panel (distinctive slide-in feature)
          const controlPanelMat = new THREE.MeshStandardMaterial({
            color: 0x404040,
            roughness: 0.2,
            metalness: 0.6
          });
          const controlPanel = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.04, 0.25, 0.03),
            controlPanelMat
          );
          controlPanel.position.set(0, h/2 - 0.15, d/2 + 0.02);
          group.add(controlPanel);

          // Front knobs
          const slideKnobMat = new THREE.MeshStandardMaterial({
            color: 0xC0C0C0,
            roughness: 0.2,
            metalness: 0.8
          });
          for (let i = 0; i < 5; i++) {
            const knob = new THREE.Mesh(
              new THREE.CylinderGeometry(0.035, 0.035, 0.02, 16),
              slideKnobMat
            );
            knob.rotation.x = Math.PI / 2;
            knob.position.set(-w/2 + 0.25 + i * (w - 0.5) / 4, h/2 - 0.15, d/2 + 0.05);
            group.add(knob);
          }

          // Oven door
          const slideOvenDoorMat = new THREE.MeshStandardMaterial({
            color: 0x2a2a2a,
            roughness: 0.25,
            metalness: 0.45
          });
          const slideOvenDoor = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.15, h * 0.55, 0.05),
            slideOvenDoorMat
          );
          slideOvenDoor.position.set(0, -h * 0.2, d/2);
          group.add(slideOvenDoor);

          // Oven window
          const slideGlassMat = new THREE.MeshStandardMaterial({
            color: 0x111111,
            roughness: 0.05,
            metalness: 0.1,
            transparent: true,
            opacity: 0.85
          });
          const slideOvenWindow = new THREE.Mesh(
            new THREE.BoxGeometry(w * 0.55, h * 0.35, 0.02),
            slideGlassMat
          );
          slideOvenWindow.position.set(0, -h * 0.2, d/2 + 0.04);
          group.add(slideOvenWindow);

          // Oven handle
          const slideHandleMat = new THREE.MeshStandardMaterial({
            color: 0xB0B0B0,
            roughness: 0.15,
            metalness: 0.85
          });
          const slideOvenHandle = new THREE.Mesh(
            new THREE.CylinderGeometry(0.02, 0.02, w * 0.65, 12),
            slideHandleMat
          );
          slideOvenHandle.rotation.z = Math.PI / 2;
          slideOvenHandle.position.set(0, h * 0.1, d/2 + 0.08);
          group.add(slideOvenHandle);

          break;
        }

        case 'single-oven-cabinet':
        case 'tall-oven':
        case 'double-oven-cabinet': {
          // Wall oven cabinet - tall cabinet with built-in oven(s)
          // Layout for 84" single oven cabinet:
          //   - Top cabinet door: ~24" (storage)
          //   - Oven: ~30"
          //   - Bottom drawer: ~12"
          //   - Toe kick: ~4" (built into base)
          // Layout for 96" double oven cabinet:
          //   - Top oven: ~30"
          //   - Bottom oven: ~30"
          //   - Storage drawer: ~12"

          const isDouble = el.type === 'double-oven-cabinet';
          const ovenCabinetFinish = el.cabinetFinish || 'wood-grain';
          const ovenCabGrainType = el.grainType || 'oak';
          let ovenCabWoodTexture = null;
          let ovenCabBaseRoughness = 0.35;

          // Check for custom texture first
          if (textureUrl) {
            const textureLoader = new THREE.TextureLoader();
            try {
              ovenCabWoodTexture = textureLoader.load(textureUrl);
              ovenCabWoodTexture.wrapS = THREE.RepeatWrapping;
              ovenCabWoodTexture.wrapT = THREE.RepeatWrapping;
              ovenCabWoodTexture.repeat.set(2, 2);
            } catch (e) {
              ovenCabWoodTexture = createWoodGrainTexture(color, 0.12, ovenCabGrainType);
            }
            ovenCabBaseRoughness = 0.3;
          } else if (ovenCabinetFinish === 'wood-grain') {
            ovenCabWoodTexture = createWoodGrainTexture(color, 0.12, ovenCabGrainType);
            ovenCabBaseRoughness = 0.3;
          } else if (ovenCabinetFinish === 'painted' || ovenCabinetFinish === 'matte' || ovenCabinetFinish === 'gloss') {
            ovenCabWoodTexture = createWoodGrainTexture(color, 0.03, 'flat');
            ovenCabBaseRoughness = ovenCabinetFinish === 'gloss' ? 0.1 : (ovenCabinetFinish === 'matte' ? 0.7 : 0.4);
          }

          // Cabinet wood material
          const ovenCabMat = new THREE.MeshStandardMaterial({
            color: color,
            map: ovenCabWoodTexture,
            roughness: ovenCabBaseRoughness,
            metalness: 0.02
          });

          // Darker interior material
          const interiorMat = new THREE.MeshStandardMaterial({
            color: 0x1a1a1a,
            roughness: 0.9
          });

          const panelThick = 0.05;
          const doorThick = 0.06;
          const doorGap = 0.02;

          // === CABINET BOX (sides, top, bottom, back) ===

          // Left side panel (full height)
          const leftPanel = new THREE.Mesh(
            new THREE.BoxGeometry(panelThick, h, d),
            ovenCabMat
          );
          leftPanel.position.set(-w/2 + panelThick/2, 0, 0);
          group.add(leftPanel);

          // Right side panel (full height)
          const rightPanel = new THREE.Mesh(
            new THREE.BoxGeometry(panelThick, h, d),
            ovenCabMat
          );
          rightPanel.position.set(w/2 - panelThick/2, 0, 0);
          group.add(rightPanel);

          // Top panel
          const topPanel = new THREE.Mesh(
            new THREE.BoxGeometry(w, panelThick, d),
            ovenCabMat
          );
          topPanel.position.set(0, h/2 - panelThick/2, 0);
          group.add(topPanel);

          // Back panel
          const backPanel = new THREE.Mesh(
            new THREE.BoxGeometry(w - panelThick * 2, h, panelThick),
            interiorMat
          );
          backPanel.position.set(0, 0, -d/2 + panelThick/2);
          group.add(backPanel);

          // === LAYOUT CALCULATIONS ===
          const toeKickH = 0.35;  // 4"
          const drawerH = 1.0;    // 12" drawer
          const ovenH = 2.5;      // 30" oven
          const midDrawerH = 0.65; // ~8" drawer/spacer between ovens (double only)
          const topFillerH = isDouble ? 1.0 : 0;  // ~12" filler/door at top for double
          const topCabH = isDouble ? 0 : (h - toeKickH - drawerH - ovenH);  // Remaining space for single

          // Y positions (from bottom up)
          const toeKickY = -h/2 + toeKickH/2;
          const drawerY = -h/2 + toeKickH + drawerH/2;
          const oven1Y = isDouble
            ? (-h/2 + toeKickH + drawerH + ovenH/2)  // Bottom oven for double
            : (drawerY + drawerH/2 + ovenH/2);       // Single oven above drawer
          const midDrawerY = oven1Y + ovenH/2 + midDrawerH/2;  // Between ovens (double only)
          const oven2Y = midDrawerY + midDrawerH/2 + ovenH/2;  // Top oven for double
          const topFillerY = oven2Y + ovenH/2 + topFillerH/2;  // Top filler position
          const topCabY = h/2 - topCabH/2;

          // === TOE KICK (recessed) ===
          const toeKick = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.2, toeKickH, d * 0.6),
            interiorMat
          );
          toeKick.position.set(0, toeKickY, -d * 0.15);
          group.add(toeKick);

          // === BOTTOM DRAWER ===
          // Drawer front
          const drawerFront = new THREE.Mesh(
            new THREE.BoxGeometry(w - doorGap * 2, drawerH - doorGap * 2, doorThick),
            ovenCabMat
          );
          drawerFront.position.set(0, drawerY, d/2 - doorThick/2);
          group.add(drawerFront);

          // Drawer shaker frame
          const frameW = 0.08;
          const drawerFrameMat = new THREE.MeshStandardMaterial({
            color: color,
            map: ovenCabWoodTexture,
            roughness: ovenCabBaseRoughness - 0.05,
            metalness: 0.02
          });

          // Top frame
          const drawerFrameTop = new THREE.Mesh(
            new THREE.BoxGeometry(w - doorGap * 2, frameW, 0.02),
            drawerFrameMat
          );
          drawerFrameTop.position.set(0, drawerY + drawerH/2 - frameW/2 - doorGap, d/2 + 0.01);
          group.add(drawerFrameTop);

          // Bottom frame
          const drawerFrameBot = new THREE.Mesh(
            new THREE.BoxGeometry(w - doorGap * 2, frameW, 0.02),
            drawerFrameMat
          );
          drawerFrameBot.position.set(0, drawerY - drawerH/2 + frameW/2 + doorGap, d/2 + 0.01);
          group.add(drawerFrameBot);

          // Drawer handle
          const drawerHandle = createModernBarHandle(0.3, 'brushed-nickel');
          drawerHandle.position.set(0, drawerY, d/2 + 0.06);
          group.add(drawerHandle);

          // === OVEN(S) ===
          const ovenPositions = isDouble ? [oven1Y, oven2Y] : [oven1Y];

          ovenPositions.forEach((ovenY, idx) => {
            const ovenW = w - 0.15;

            // Oven housing (stainless steel frame)
            const ovenFrameMat = new THREE.MeshStandardMaterial({
              color: 0x4a4a4a,
              roughness: 0.3,
              metalness: 0.7
            });

            // Oven outer frame
            const ovenFrame = new THREE.Mesh(
              new THREE.BoxGeometry(ovenW, ovenH - 0.05, 0.08),
              ovenFrameMat
            );
            ovenFrame.position.set(0, ovenY, d/2 - 0.04);
            group.add(ovenFrame);

            // Oven door (black glass with stainless trim)
            const ovenDoorMat = new THREE.MeshStandardMaterial({
              color: 0x1a1a1a,
              roughness: 0.15,
              metalness: 0.3
            });
            const ovenDoor = new THREE.Mesh(
              new THREE.BoxGeometry(ovenW - 0.08, ovenH - 0.15, 0.04),
              ovenDoorMat
            );
            ovenDoor.position.set(0, ovenY - 0.1, d/2);
            group.add(ovenDoor);

            // Oven window (dark glass, slightly reflective)
            const ovenGlassMat = new THREE.MeshStandardMaterial({
              color: 0x0a0a0a,
              roughness: 0.02,
              metalness: 0.15,
              transparent: true,
              opacity: 0.9
            });
            const windowH = ovenH * 0.55;
            const ovenWindow = new THREE.Mesh(
              new THREE.BoxGeometry(ovenW - 0.2, windowH, 0.01),
              ovenGlassMat
            );
            ovenWindow.position.set(0, ovenY - 0.15, d/2 + 0.025);
            group.add(ovenWindow);

            // Control panel (above oven door)
            const controlMat = new THREE.MeshStandardMaterial({
              color: 0x2a2a2a,
              roughness: 0.2,
              metalness: 0.5
            });
            const controlPanel = new THREE.Mesh(
              new THREE.BoxGeometry(ovenW - 0.08, 0.35, 0.03),
              controlMat
            );
            controlPanel.position.set(0, ovenY + ovenH/2 - 0.25, d/2 + 0.01);
            group.add(controlPanel);

            // Control knobs
            const knobMat = new THREE.MeshStandardMaterial({
              color: 0x888888,
              roughness: 0.2,
              metalness: 0.8
            });
            for (let k = 0; k < 4; k++) {
              const knob = new THREE.Mesh(
                new THREE.CylinderGeometry(0.04, 0.04, 0.03, 16),
                knobMat
              );
              knob.rotation.x = Math.PI / 2;
              knob.position.set(-0.25 + k * 0.17, ovenY + ovenH/2 - 0.25, d/2 + 0.04);
              group.add(knob);
            }

            // Oven handle (horizontal bar)
            const handleMat = new THREE.MeshStandardMaterial({
              color: 0xc0c0c0,
              roughness: 0.15,
              metalness: 0.9
            });
            const ovenHandle = new THREE.Mesh(
              new THREE.CylinderGeometry(0.025, 0.025, ovenW * 0.7, 12),
              handleMat
            );
            ovenHandle.rotation.z = Math.PI / 2;
            ovenHandle.position.set(0, ovenY + ovenH/2 - 0.55, d/2 + 0.07);
            group.add(ovenHandle);

            // Handle mounts
            const mountMat = new THREE.MeshStandardMaterial({
              color: 0xa0a0a0,
              roughness: 0.2,
              metalness: 0.85
            });
            [-ovenW * 0.3, ovenW * 0.3].forEach(xPos => {
              const mount = new THREE.Mesh(
                new THREE.BoxGeometry(0.04, 0.06, 0.08),
                mountMat
              );
              mount.position.set(xPos, ovenY + ovenH/2 - 0.55, d/2 + 0.04);
              group.add(mount);
            });
          });

          // === MID-DRAWER (spacer between ovens for double oven) ===
          if (isDouble) {
            // Mid drawer front (between the two ovens)
            const midDrawerFront = new THREE.Mesh(
              new THREE.BoxGeometry(w - doorGap * 2, midDrawerH - doorGap * 2, doorThick),
              ovenCabMat
            );
            midDrawerFront.position.set(0, midDrawerY, d/2 - doorThick/2);
            group.add(midDrawerFront);

            // Mid drawer shaker frame - top rail
            const midFrameTop = new THREE.Mesh(
              new THREE.BoxGeometry(w - doorGap * 2, frameW * 0.7, 0.02),
              drawerFrameMat
            );
            midFrameTop.position.set(0, midDrawerY + midDrawerH/2 - frameW/2 - doorGap, d/2 + 0.01);
            group.add(midFrameTop);

            // Mid drawer shaker frame - bottom rail
            const midFrameBot = new THREE.Mesh(
              new THREE.BoxGeometry(w - doorGap * 2, frameW * 0.7, 0.02),
              drawerFrameMat
            );
            midFrameBot.position.set(0, midDrawerY - midDrawerH/2 + frameW/2 + doorGap, d/2 + 0.01);
            group.add(midFrameBot);

            // Mid drawer handle
            const midHandle = createModernBarHandle(0.25, 'brushed-nickel');
            midHandle.position.set(0, midDrawerY, d/2 + 0.06);
            group.add(midHandle);
          }

          // === TOP FILLER PANEL (for double oven) ===
          if (isDouble && topFillerH > 0.2) {
            // Top filler/cabinet door
            const topFillerDoor = new THREE.Mesh(
              new THREE.BoxGeometry(w - doorGap * 2, topFillerH - doorGap * 2, doorThick),
              ovenCabMat
            );
            topFillerDoor.position.set(0, topFillerY, d/2 - doorThick/2);
            group.add(topFillerDoor);

            // Shaker frame for top filler - top rail
            const topFillerRailTop = new THREE.Mesh(
              new THREE.BoxGeometry(w - doorGap * 2, frameW, 0.02),
              drawerFrameMat
            );
            topFillerRailTop.position.set(0, topFillerY + topFillerH/2 - frameW/2 - doorGap, d/2 + 0.01);
            group.add(topFillerRailTop);

            // Bottom rail
            const topFillerRailBot = new THREE.Mesh(
              new THREE.BoxGeometry(w - doorGap * 2, frameW, 0.02),
              drawerFrameMat
            );
            topFillerRailBot.position.set(0, topFillerY - topFillerH/2 + frameW/2 + doorGap, d/2 + 0.01);
            group.add(topFillerRailBot);

            // Left stile
            const topFillerStileL = new THREE.Mesh(
              new THREE.BoxGeometry(frameW, topFillerH - doorGap * 2, 0.02),
              drawerFrameMat
            );
            topFillerStileL.position.set(-w/2 + frameW/2 + doorGap, topFillerY, d/2 + 0.01);
            group.add(topFillerStileL);

            // Right stile
            const topFillerStileR = new THREE.Mesh(
              new THREE.BoxGeometry(frameW, topFillerH - doorGap * 2, 0.02),
              drawerFrameMat
            );
            topFillerStileR.position.set(w/2 - frameW/2 - doorGap, topFillerY, d/2 + 0.01);
            group.add(topFillerStileR);

            // Top filler handle (small knob or bar)
            const topFillerHandle = createModernBarHandle(0.15, 'brushed-nickel');
            topFillerHandle.position.set(0, topFillerY, d/2 + 0.06);
            group.add(topFillerHandle);
          }

          // === TOP CABINET DOOR (for single oven only) ===
          if (!isDouble && topCabH > 0.3) {
            // Cabinet door
            const topDoor = new THREE.Mesh(
              new THREE.BoxGeometry(w - doorGap * 2, topCabH - doorGap * 2, doorThick),
              ovenCabMat
            );
            topDoor.position.set(0, topCabY, d/2 - doorThick/2);
            group.add(topDoor);

            // Shaker frame for top door
            // Top rail
            const topRail = new THREE.Mesh(
              new THREE.BoxGeometry(w - doorGap * 2, frameW, 0.02),
              drawerFrameMat
            );
            topRail.position.set(0, topCabY + topCabH/2 - frameW/2 - doorGap, d/2 + 0.01);
            group.add(topRail);

            // Bottom rail
            const botRail = new THREE.Mesh(
              new THREE.BoxGeometry(w - doorGap * 2, frameW, 0.02),
              drawerFrameMat
            );
            botRail.position.set(0, topCabY - topCabH/2 + frameW/2 + doorGap, d/2 + 0.01);
            group.add(botRail);

            // Left stile
            const leftStile = new THREE.Mesh(
              new THREE.BoxGeometry(frameW, topCabH - doorGap * 2, 0.02),
              drawerFrameMat
            );
            leftStile.position.set(-w/2 + frameW/2 + doorGap, topCabY, d/2 + 0.01);
            group.add(leftStile);

            // Right stile
            const rightStile = new THREE.Mesh(
              new THREE.BoxGeometry(frameW, topCabH - doorGap * 2, 0.02),
              drawerFrameMat
            );
            rightStile.position.set(w/2 - frameW/2 - doorGap, topCabY, d/2 + 0.01);
            group.add(rightStile);

            // Top cabinet handle
            const topHandle = createModernBarHandle(0.2, 'brushed-nickel');
            topHandle.position.set(0, topCabY - topCabH/4, d/2 + 0.06);
            group.add(topHandle);
          }

          break;
        }

        case 'above-microwave-cabinet': {
          // Combined unit: Short wall cabinet with microwave below
          const aboveMwFinish = el.cabinetFinish || 'wood-grain';
          const aboveMwGrainType = el.grainType || 'oak';
          let aboveMwWoodTexture = null;
          let aboveMwBaseRoughness = 0.35;

          // Check for custom texture first
          if (textureUrl) {
            const textureLoader = new THREE.TextureLoader();
            try {
              aboveMwWoodTexture = textureLoader.load(textureUrl);
              aboveMwWoodTexture.wrapS = THREE.RepeatWrapping;
              aboveMwWoodTexture.wrapT = THREE.RepeatWrapping;
              aboveMwWoodTexture.repeat.set(2, 2);
            } catch (e) {
              aboveMwWoodTexture = createWoodGrainTexture(color, 0.12, aboveMwGrainType);
            }
            aboveMwBaseRoughness = 0.3;
          } else if (aboveMwFinish === 'wood-grain') {
            aboveMwWoodTexture = createWoodGrainTexture(color, 0.12, aboveMwGrainType);
            aboveMwBaseRoughness = 0.3;
          } else if (aboveMwFinish === 'painted' || aboveMwFinish === 'matte' || aboveMwFinish === 'gloss') {
            aboveMwWoodTexture = createWoodGrainTexture(color, 0.03, 'flat');
            aboveMwBaseRoughness = aboveMwFinish === 'gloss' ? 0.1 : (aboveMwFinish === 'matte' ? 0.7 : 0.4);
          }

          const aboveMwMat = new THREE.MeshStandardMaterial({
            color: color,
            map: aboveMwWoodTexture,
            roughness: aboveMwBaseRoughness,
            metalness: 0.02,
            bumpScale: aboveMwWoodTexture ? 0.002 : 0
          });

          // Microwave dimensions (below the cabinet)
          const mwHeight = 1.25; // 15 inches
          const mwDepth = d * 1.2; // Microwave slightly deeper than cabinet
          const mwYOffset = -(h / 2) - (mwHeight / 2) - 0.02; // Position below cabinet

          // === CABINET SECTION (top) ===
          // Cabinet body
          const bodyMat = new THREE.MeshStandardMaterial({ color: 0x2a2a2a, roughness: 0.8 });
          const body = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.08, h - 0.08, d - 0.08),
            bodyMat
          );
          body.position.z = -0.02;
          group.add(body);

          // Door
          const doorGap = 0.02;
          const door = new THREE.Mesh(
            new THREE.BoxGeometry(w - doorGap * 2, h - doorGap * 2, 0.05),
            aboveMwMat
          );
          door.position.set(0, 0, d/2);
          group.add(door);

          // Shaker style frame
          const frameW = 0.06;
          const frameMat = new THREE.MeshStandardMaterial({
            color: color,
            map: aboveMwWoodTexture,
            roughness: aboveMwBaseRoughness - 0.02,
            metalness: 0.02
          });

          // Top rail
          const topFrame = new THREE.Mesh(new THREE.BoxGeometry(w - doorGap * 2 - 0.04, frameW, 0.02), frameMat);
          topFrame.position.set(0, (h - doorGap * 2)/2 - frameW/2 - 0.02, d/2 + 0.03);
          group.add(topFrame);

          // Bottom rail
          const botFrame = new THREE.Mesh(new THREE.BoxGeometry(w - doorGap * 2 - 0.04, frameW, 0.02), frameMat);
          botFrame.position.set(0, -(h - doorGap * 2)/2 + frameW/2 + 0.02, d/2 + 0.03);
          group.add(botFrame);

          // Stiles
          const leftStile = new THREE.Mesh(new THREE.BoxGeometry(frameW, h - doorGap * 2 - frameW * 2, 0.02), frameMat);
          leftStile.position.set(-(w - doorGap * 2)/2 + frameW/2 + 0.02, 0, d/2 + 0.03);
          group.add(leftStile);

          const rightStile = new THREE.Mesh(new THREE.BoxGeometry(frameW, h - doorGap * 2 - frameW * 2, 0.02), frameMat);
          rightStile.position.set((w - doorGap * 2)/2 - frameW/2 - 0.02, 0, d/2 + 0.03);
          group.add(rightStile);

          // Cabinet Handle
          const cabHandle = createModernBarHandle(0.2, 'brushed-nickel');
          cabHandle.position.set(0, -(h - doorGap * 2) * 0.25, d/2 + 0.08);
          cabHandle.rotation.z = Math.PI / 2;
          group.add(cabHandle);

          // === MICROWAVE SECTION (below cabinet) ===
          // Microwave body
          const mwMat = new THREE.MeshStandardMaterial({ color: 0x3a3a3a, roughness: 0.4, metalness: 0.3 });
          const mwBody = new THREE.Mesh(new THREE.BoxGeometry(w, mwHeight, mwDepth), mwMat);
          mwBody.position.set(0, mwYOffset, mwDepth/2 - d/2);
          group.add(mwBody);

          // Glass door window
          const mwGlass = new THREE.Mesh(
            new THREE.BoxGeometry(w * 0.55, mwHeight - 0.15, 0.02),
            new THREE.MeshStandardMaterial({ color: 0x111111, transparent: true, opacity: 0.85, roughness: 0.1 })
          );
          mwGlass.position.set(-w * 0.15, mwYOffset, mwDepth + 0.02 - d/2);
          group.add(mwGlass);

          // Control panel
          const mwCtrlMat = new THREE.MeshStandardMaterial({ color: 0x2a2a2a, roughness: 0.3, metalness: 0.2 });
          const mwCtrl = new THREE.Mesh(
            new THREE.BoxGeometry(w * 0.25, mwHeight - 0.15, 0.02),
            mwCtrlMat
          );
          mwCtrl.position.set(w * 0.32, mwYOffset, mwDepth + 0.02 - d/2);
          group.add(mwCtrl);

          // Control buttons (3x3 grid)
          const mwBtnMat = new THREE.MeshStandardMaterial({ color: 0x555555, roughness: 0.5 });
          for (let i = 0; i < 3; i++) {
            for (let j = 0; j < 3; j++) {
              const btn = new THREE.Mesh(
                new THREE.BoxGeometry(0.04, 0.04, 0.01),
                mwBtnMat
              );
              btn.position.set(
                w * 0.28 + j * 0.06,
                mwYOffset + mwHeight * 0.15 - i * 0.08,
                mwDepth + 0.04 - d/2
              );
              group.add(btn);
            }
          }

          // Digital display (glowing green)
          const mwDisplayMat = new THREE.MeshStandardMaterial({
            color: 0x00ff00,
            emissive: 0x00ff00,
            emissiveIntensity: 0.3,
            roughness: 0.2
          });
          const mwDisplay = new THREE.Mesh(
            new THREE.BoxGeometry(0.12, 0.04, 0.01),
            mwDisplayMat
          );
          mwDisplay.position.set(w * 0.32, mwYOffset + mwHeight * 0.35, mwDepth + 0.04 - d/2);
          group.add(mwDisplay);

          // Handle
          const mwHandleMat = new THREE.MeshStandardMaterial({ color: 0x888888, metalness: 0.8, roughness: 0.2 });
          const mwHandle = new THREE.Mesh(
            new THREE.BoxGeometry(0.03, mwHeight * 0.4, 0.03),
            mwHandleMat
          );
          mwHandle.position.set(-w * 0.42, mwYOffset, mwDepth + 0.06 - d/2);
          group.add(mwHandle);

          // Bottom vent (over-the-range microwave feature)
          const mwVentMat = new THREE.MeshStandardMaterial({ color: 0x4a4a4a, roughness: 0.6 });
          const mwVent = new THREE.Mesh(
            new THREE.BoxGeometry(w * 0.8, 0.05, mwDepth * 0.5),
            mwVentMat
          );
          mwVent.position.set(0, mwYOffset - mwHeight/2 - 0.03, mwDepth/2 - d/2);
          group.add(mwVent);

          // Vent grille lines
          for (let i = 0; i < 6; i++) {
            const grilleLine = new THREE.Mesh(
              new THREE.BoxGeometry(w * 0.7, 0.01, 0.01),
              mwVentMat
            );
            grilleLine.position.set(0, mwYOffset - mwHeight/2 - 0.01, mwDepth * 0.2 + i * (mwDepth * 0.4 / 6) - d/2);
            group.add(grilleLine);
          }

          // Light under microwave (illuminates cooktop below)
          const lightMat = new THREE.MeshStandardMaterial({
            color: 0xffffcc,
            emissive: 0xffffaa,
            emissiveIntensity: 0.2,
            transparent: true,
            opacity: 0.8
          });
          const mwLight = new THREE.Mesh(
            new THREE.BoxGeometry(w * 0.5, 0.02, 0.15),
            lightMat
          );
          mwLight.position.set(0, mwYOffset - mwHeight/2 - 0.06, mwDepth * 0.3 - d/2);
          group.add(mwLight);

          break;
        }

        case 'refrigerator': {
          // High-detail French door refrigerator (stainless steel)
          const fridgeMat = new THREE.MeshStandardMaterial({
            color: 0xCCCCCC,
            roughness: 0.18,
            metalness: 0.65,
            envMap: window.roomEnvMap || null,
            envMapIntensity: 0.9
          });

          // Main body
          const fridgeBody = new THREE.Mesh(
            new THREE.BoxGeometry(w, h, d),
            fridgeMat
          );
          group.add(fridgeBody);

          // Side panels (slightly darker, visible texture difference)
          const fridgeSideMat = new THREE.MeshStandardMaterial({
            color: 0xB8B8B8,
            roughness: 0.25,
            metalness: 0.5
          });
          // Left side panel
          const leftSidePanel = new THREE.Mesh(
            new THREE.BoxGeometry(0.01, h - 0.08, d - 0.04),
            fridgeSideMat
          );
          leftSidePanel.position.set(-w/2 + 0.005, 0, 0);
          group.add(leftSidePanel);
          // Right side panel
          const rightSidePanel = new THREE.Mesh(
            new THREE.BoxGeometry(0.01, h - 0.08, d - 0.04),
            fridgeSideMat
          );
          rightSidePanel.position.set(w/2 - 0.005, 0, 0);
          group.add(rightSidePanel);

          // Upper doors (French style - two doors) with brushed stainless look
          const doorMat = new THREE.MeshStandardMaterial({
            color: 0xDCDCDC,
            roughness: 0.12,
            metalness: 0.72,
            envMap: window.roomEnvMap || null,
            envMapIntensity: 1.2
          });

          const upperDoorH = h * 0.63;
          const doorGap = 0.04; // Gap between doors
          const doorW = (w - 0.12 - doorGap) / 2;

          // Left upper door
          const leftDoor = new THREE.Mesh(
            new THREE.BoxGeometry(doorW, upperDoorH, 0.035),
            doorMat
          );
          leftDoor.position.set(-doorW/2 - doorGap/2, h * 0.15, d/2 + 0.018);
          group.add(leftDoor);

          // Right upper door
          const rightDoor = new THREE.Mesh(
            new THREE.BoxGeometry(doorW, upperDoorH, 0.035),
            doorMat
          );
          rightDoor.position.set(doorW/2 + doorGap/2, h * 0.15, d/2 + 0.018);
          group.add(rightDoor);

          // Door gap line (dark vertical line between French doors)
          const gapLineMat = new THREE.MeshStandardMaterial({
            color: 0x222222, roughness: 0.8
          });
          const doorGapLine = new THREE.Mesh(
            new THREE.BoxGeometry(0.015, upperDoorH + 0.02, 0.005),
            gapLineMat
          );
          doorGapLine.position.set(0, h * 0.15, d/2 + 0.038);
          group.add(doorGapLine);

          // Horizontal divider line between fridge and freezer
          const dividerLine = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.08, 0.015, 0.005),
            gapLineMat
          );
          dividerLine.position.set(0, -h * 0.17, d/2 + 0.038);
          group.add(dividerLine);

          // Freezer drawer
          const freezerDrawerMat = new THREE.MeshStandardMaterial({
            color: 0xD8D8D8,
            roughness: 0.14,
            metalness: 0.7,
            envMap: window.roomEnvMap || null,
            envMapIntensity: 1.1
          });
          const freezerDrawer = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.12, h * 0.28, 0.035),
            freezerDrawerMat
          );
          freezerDrawer.position.set(0, -h * 0.35, d/2 + 0.018);
          group.add(freezerDrawer);

          // Professional handles (cylindrical bar style)
          const fHandleMat = new THREE.MeshStandardMaterial({
            color: 0xC0C0C0,
            roughness: 0.08,
            metalness: 0.95,
            envMap: window.roomEnvMap || null,
            envMapIntensity: 1.8
          });

          // Left door handle (vertical bar)
          const lHandle = new THREE.Mesh(
            new THREE.CylinderGeometry(0.018, 0.018, upperDoorH * 0.55, 12),
            fHandleMat
          );
          lHandle.position.set(-doorGap/2 - 0.06, h * 0.15, d/2 + 0.08);
          group.add(lHandle);
          // Left handle mounting brackets
          for (let bOff = -1; bOff <= 1; bOff += 2) {
            const bracket = new THREE.Mesh(
              new THREE.BoxGeometry(0.03, 0.04, 0.04),
              fHandleMat
            );
            bracket.position.set(-doorGap/2 - 0.06, h * 0.15 + bOff * upperDoorH * 0.22, d/2 + 0.055);
            group.add(bracket);
          }

          // Right door handle (vertical bar)
          const rHandle = new THREE.Mesh(
            new THREE.CylinderGeometry(0.018, 0.018, upperDoorH * 0.55, 12),
            fHandleMat
          );
          rHandle.position.set(doorGap/2 + 0.06, h * 0.15, d/2 + 0.08);
          group.add(rHandle);
          // Right handle mounting brackets
          for (let bOff = -1; bOff <= 1; bOff += 2) {
            const bracket = new THREE.Mesh(
              new THREE.BoxGeometry(0.03, 0.04, 0.04),
              fHandleMat
            );
            bracket.position.set(doorGap/2 + 0.06, h * 0.15 + bOff * upperDoorH * 0.22, d/2 + 0.055);
            group.add(bracket);
          }

          // Freezer handle (horizontal bar)
          const frzHandle = new THREE.Mesh(
            new THREE.CylinderGeometry(0.018, 0.018, w * 0.5, 12),
            fHandleMat
          );
          frzHandle.rotation.z = Math.PI / 2;
          frzHandle.position.set(0, -h * 0.22, d/2 + 0.08);
          group.add(frzHandle);
          // Freezer handle brackets
          for (let bSide = -1; bSide <= 1; bSide += 2) {
            const frzBracket = new THREE.Mesh(
              new THREE.BoxGeometry(0.04, 0.03, 0.04),
              fHandleMat
            );
            frzBracket.position.set(bSide * w * 0.2, -h * 0.22, d/2 + 0.055);
            group.add(frzBracket);
          }

          // Water/ice dispenser recess
          const dispenserRecessMat = new THREE.MeshStandardMaterial({
            color: 0x1a1a1a,
            roughness: 0.4,
            metalness: 0.3
          });
          const dispenserRecess = new THREE.Mesh(
            new THREE.BoxGeometry(0.35, 0.3, 0.04),
            dispenserRecessMat
          );
          dispenserRecess.position.set(0, h * 0.22, d/2 + 0.02);
          group.add(dispenserRecess);

          // Dispenser paddle
          const paddleMat = new THREE.MeshStandardMaterial({
            color: 0x3a3a3a,
            roughness: 0.5,
            metalness: 0.2
          });
          const paddle = new THREE.Mesh(
            new THREE.BoxGeometry(0.2, 0.08, 0.015),
            paddleMat
          );
          paddle.position.set(0, h * 0.17, d/2 + 0.045);
          group.add(paddle);

          // Dispenser LED indicator
          const fridgeLedMat = new THREE.MeshStandardMaterial({
            color: 0x00ccff,
            emissive: 0x0088cc,
            emissiveIntensity: 0.2
          });
          const fridgeLed = new THREE.Mesh(
            new THREE.CircleGeometry(0.015, 8),
            fridgeLedMat
          );
          fridgeLed.position.set(0, h * 0.28, d/2 + 0.045);
          group.add(fridgeLed);

          // Top cap (slightly darker top panel)
          const topCapMat = new THREE.MeshStandardMaterial({
            color: 0xB0B0B0,
            roughness: 0.3,
            metalness: 0.5
          });
          const topCap = new THREE.Mesh(
            new THREE.BoxGeometry(w + 0.02, 0.03, d + 0.02),
            topCapMat
          );
          topCap.position.set(0, h/2 + 0.015, 0);
          group.add(topCap);

          // Toe kick grille (bottom ventilation)
          const fridgeToeKickMat = new THREE.MeshStandardMaterial({
            color: 0x1a1a1a,
            roughness: 0.8
          });
          const fridgeToeKick = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.04, 0.12, 0.06),
            fridgeToeKickMat
          );
          fridgeToeKick.position.set(0, -h/2 + 0.06, d/2 - 0.03);
          group.add(fridgeToeKick);

          // Brand badge
          const fridgeBadgeMat = new THREE.MeshStandardMaterial({
            color: 0xAAAAAA,
            roughness: 0.05,
            metalness: 0.98
          });
          const fridgeBadge = new THREE.Mesh(
            new THREE.BoxGeometry(0.3, 0.05, 0.005),
            fridgeBadgeMat
          );
          fridgeBadge.position.set(0, -h * 0.06, d/2 + 0.04);
          group.add(fridgeBadge);

          break;
        }

        case 'dishwasher': {
          // High-detail built-in dishwasher (stainless steel)
          const dwBodyMat = new THREE.MeshStandardMaterial({
            color: 0xC8C8C8,
            roughness: 0.2,
            metalness: 0.65,
            envMap: window.roomEnvMap || null,
            envMapIntensity: 0.8
          });

          // Main body (slightly inset from front face)
          const dwBody = new THREE.Mesh(
            new THREE.BoxGeometry(w, h, d),
            dwBodyMat
          );
          group.add(dwBody);

          // Front door panel - slightly proud of body for depth
          const dwDoorMat = new THREE.MeshStandardMaterial({
            color: 0xD8D8D8,
            roughness: 0.15,
            metalness: 0.7,
            envMap: window.roomEnvMap || null,
            envMapIntensity: 1.0
          });
          const dwDoor = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.06, h - 0.35, 0.03),
            dwDoorMat
          );
          dwDoor.position.set(0, -0.05, d/2 + 0.015);
          group.add(dwDoor);

          // Hidden top-mount control panel (recessed dark strip at top)
          const dwPanelMat = new THREE.MeshStandardMaterial({
            color: 0x1a1a1a,
            roughness: 0.4,
            metalness: 0.3
          });
          const dwPanel = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.08, 0.18, 0.025),
            dwPanelMat
          );
          dwPanel.position.set(0, h/2 - 0.15, d/2 + 0.02);
          group.add(dwPanel);

          // Control panel indicator lights (small LED dots)
          const dwLedMat = new THREE.MeshStandardMaterial({
            color: 0x00aaff,
            emissive: 0x0066cc,
            emissiveIntensity: 0.3
          });
          for (let li = 0; li < 4; li++) {
            const led = new THREE.Mesh(
              new THREE.CircleGeometry(0.012, 8),
              dwLedMat
            );
            led.position.set(-w/4 + li * 0.12, h/2 - 0.15, d/2 + 0.035);
            group.add(led);
          }

          // Pocket handle (recessed bar handle at top of door)
          const dwHandleMat = new THREE.MeshStandardMaterial({
            color: 0xB0B0B0,
            roughness: 0.1,
            metalness: 0.92,
            envMap: window.roomEnvMap || null,
            envMapIntensity: 1.5
          });
          // Handle bar
          const dwHandleBar = new THREE.Mesh(
            new THREE.CylinderGeometry(0.02, 0.02, w * 0.65, 12),
            dwHandleMat
          );
          dwHandleBar.rotation.z = Math.PI / 2;
          dwHandleBar.position.set(0, h/2 - 0.38, d/2 + 0.07);
          group.add(dwHandleBar);
          // Handle end caps
          for (let side = -1; side <= 1; side += 2) {
            const endCap = new THREE.Mesh(
              new THREE.SphereGeometry(0.022, 8, 8),
              dwHandleMat
            );
            endCap.position.set(side * w * 0.325, h/2 - 0.38, d/2 + 0.07);
            group.add(endCap);
          }

          // Brand badge (small metallic rectangle)
          const dwBadgeMat = new THREE.MeshStandardMaterial({
            color: 0x999999,
            roughness: 0.08,
            metalness: 0.95
          });
          const dwBadge = new THREE.Mesh(
            new THREE.BoxGeometry(0.25, 0.06, 0.005),
            dwBadgeMat
          );
          dwBadge.position.set(0, -h * 0.35, d/2 + 0.035);
          group.add(dwBadge);

          // Toe kick (dark recess at bottom)
          const dwToeKickMat = new THREE.MeshStandardMaterial({
            color: 0x1a1a1a,
            roughness: 0.8
          });
          const dwToeKick = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.04, 0.08, 0.06),
            dwToeKickMat
          );
          dwToeKick.position.set(0, -h/2 + 0.04, d/2 - 0.03);
          group.add(dwToeKick);

          break;
        }

        case 'microwave': {
          // Over-the-range microwave in open-face cabinet box
          // Cabinet box dimensions slightly larger than microwave
          const mwCabinetPadding = 0.05; // 0.6" padding around microwave
          const mwCabinetW = w + mwCabinetPadding * 2;
          const mwCabinetH = h + mwCabinetPadding;
          const mwCabinetD = d + mwCabinetPadding;

          // Get wood texture for cabinet box
          const mwCabFinish = el.cabinetFinish || 'wood-grain';
          const mwCabGrainType = el.grainType || 'oak';
          let mwCabTexture = null;
          let mwCabRoughness = 0.35;

          // Check for custom texture first
          if (textureUrl) {
            const textureLoader = new THREE.TextureLoader();
            try {
              mwCabTexture = textureLoader.load(textureUrl);
              mwCabTexture.wrapS = THREE.RepeatWrapping;
              mwCabTexture.wrapT = THREE.RepeatWrapping;
              mwCabTexture.repeat.set(2, 2);
            } catch (e) {
              mwCabTexture = createWoodGrainTexture(color, 0.12, mwCabGrainType);
            }
            mwCabRoughness = 0.3;
          } else if (mwCabFinish === 'wood-grain') {
            mwCabTexture = createWoodGrainTexture(color, 0.12, mwCabGrainType);
            mwCabRoughness = 0.3;
          } else if (mwCabFinish === 'painted' || mwCabFinish === 'matte' || mwCabFinish === 'gloss') {
            mwCabTexture = createWoodGrainTexture(color, 0.03, 'flat');
            mwCabRoughness = mwCabFinish === 'gloss' ? 0.1 : (mwCabFinish === 'matte' ? 0.7 : 0.4);
          }

          const mwCabMat = new THREE.MeshStandardMaterial({
            color: color,
            map: mwCabTexture,
            roughness: mwCabRoughness,
            metalness: 0.02
          });

          const mwBodyMat = new THREE.MeshStandardMaterial({ color: 0x2a2a2a, roughness: 0.8 });

          // Cabinet box - open front (no door)
          // Top panel
          const mwCabTop = new THREE.Mesh(
            new THREE.BoxGeometry(mwCabinetW, 0.04, mwCabinetD),
            mwCabMat
          );
          mwCabTop.position.set(0, mwCabinetH / 2 - 0.02, 0);
          group.add(mwCabTop);

          // Bottom panel
          const mwCabBottom = new THREE.Mesh(
            new THREE.BoxGeometry(mwCabinetW, 0.04, mwCabinetD),
            mwCabMat
          );
          mwCabBottom.position.set(0, -mwCabinetH / 2 + 0.02, 0);
          group.add(mwCabBottom);

          // Left side panel
          const mwCabLeft = new THREE.Mesh(
            new THREE.BoxGeometry(0.04, mwCabinetH, mwCabinetD),
            mwCabMat
          );
          mwCabLeft.position.set(-mwCabinetW / 2 + 0.02, 0, 0);
          group.add(mwCabLeft);

          // Right side panel
          const mwCabRight = new THREE.Mesh(
            new THREE.BoxGeometry(0.04, mwCabinetH, mwCabinetD),
            mwCabMat
          );
          mwCabRight.position.set(mwCabinetW / 2 - 0.02, 0, 0);
          group.add(mwCabRight);

          // Back panel
          const mwCabBack = new THREE.Mesh(
            new THREE.BoxGeometry(mwCabinetW - 0.08, mwCabinetH - 0.08, 0.03),
            mwBodyMat
          );
          mwCabBack.position.set(0, 0, -mwCabinetD / 2 + 0.02);
          group.add(mwCabBack);

          // Microwave body (inside cabinet)
          const mwMat = new THREE.MeshStandardMaterial({ color: 0x3a3a3a, roughness: 0.4, metalness: 0.3 });
          const mwBody = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), mwMat);
          mwBody.position.set(0, -mwCabinetPadding / 2, mwCabinetPadding / 2);
          group.add(mwBody);

          // Glass door
          const mwGlass = new THREE.Mesh(
            new THREE.BoxGeometry(w * 0.6, h - 0.15, 0.02),
            new THREE.MeshStandardMaterial({ color: 0x111111, transparent: true, opacity: 0.8, roughness: 0.1 })
          );
          mwGlass.position.set(-w * 0.15, -mwCabinetPadding / 2, d / 2 + 0.02 + mwCabinetPadding / 2);
          group.add(mwGlass);

          // Control panel
          const mwCtrlMat = new THREE.MeshStandardMaterial({ color: 0x2a2a2a, roughness: 0.3, metalness: 0.2 });
          const mwCtrl = new THREE.Mesh(
            new THREE.BoxGeometry(w * 0.25, h - 0.15, 0.02),
            mwCtrlMat
          );
          mwCtrl.position.set(w * 0.32, -mwCabinetPadding / 2, d / 2 + 0.02 + mwCabinetPadding / 2);
          group.add(mwCtrl);

          // Control buttons
          const mwBtnMat = new THREE.MeshStandardMaterial({ color: 0x555555, roughness: 0.5 });
          for (let i = 0; i < 3; i++) {
            for (let j = 0; j < 3; j++) {
              const btn = new THREE.Mesh(
                new THREE.BoxGeometry(0.04, 0.04, 0.01),
                mwBtnMat
              );
              btn.position.set(
                w * 0.28 + j * 0.06,
                h * 0.2 - i * 0.08 - mwCabinetPadding / 2,
                d / 2 + 0.04 + mwCabinetPadding / 2
              );
              group.add(btn);
            }
          }

          // Digital display
          const mwDisplayMat = new THREE.MeshStandardMaterial({
            color: 0x00ff00,
            emissive: 0x00ff00,
            emissiveIntensity: 0.3,
            roughness: 0.2
          });
          const mwDisplay = new THREE.Mesh(
            new THREE.BoxGeometry(0.12, 0.04, 0.01),
            mwDisplayMat
          );
          mwDisplay.position.set(w * 0.32, h * 0.35 - mwCabinetPadding / 2, d / 2 + 0.04 + mwCabinetPadding / 2);
          group.add(mwDisplay);

          // Handle
          const mwHandleMat = new THREE.MeshStandardMaterial({ color: 0x888888, metalness: 0.8, roughness: 0.2 });
          const mwHandle = new THREE.Mesh(
            new THREE.BoxGeometry(0.03, h * 0.4, 0.03),
            mwHandleMat
          );
          mwHandle.position.set(-w * 0.42, -mwCabinetPadding / 2, d / 2 + 0.06 + mwCabinetPadding / 2);
          group.add(mwHandle);

          // Vent at bottom (over-the-range feature)
          const mwVentMat = new THREE.MeshStandardMaterial({ color: 0x4a4a4a, roughness: 0.6 });
          const mwVent = new THREE.Mesh(
            new THREE.BoxGeometry(w * 0.8, 0.05, d * 0.6),
            mwVentMat
          );
          mwVent.position.set(0, -h / 2 - 0.03 - mwCabinetPadding / 2, 0);
          group.add(mwVent);

          // Vent grille lines
          for (let i = 0; i < 8; i++) {
            const grilleLine = new THREE.Mesh(
              new THREE.BoxGeometry(w * 0.7, 0.01, 0.01),
              mwVentMat
            );
            grilleLine.position.set(0, -h / 2 - 0.01 - mwCabinetPadding / 2, -d * 0.25 + i * (d * 0.5 / 8));
            group.add(grilleLine);
          }
          break;
        }

        case 'range-hood':
          // Trapezoidal range hood
          const hoodMat = new THREE.MeshStandardMaterial({ color: 0x808080, metalness: 0.6, roughness: 0.3 });
          const hoodShape = new THREE.Shape();
          hoodShape.moveTo(-w/2, 0);
          hoodShape.lineTo(-w/3, h);
          hoodShape.lineTo(w/3, h);
          hoodShape.lineTo(w/2, 0);
          hoodShape.closePath();

          const extrudeSettings = { depth: d, bevelEnabled: false };
          const hoodGeom = new THREE.ExtrudeGeometry(hoodShape, extrudeSettings);
          hoodGeom.rotateX(Math.PI / 2);
          hoodGeom.translate(0, h/2, -d/2);
          const hood = new THREE.Mesh(hoodGeom, hoodMat);
          group.add(hood);
          break;

        case 'oven':
          const ovenMat = new THREE.MeshStandardMaterial({ color: 0x2a2a2a, roughness: 0.3, metalness: 0.4 });
          const ovenBody = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), ovenMat);
          group.add(ovenBody);

          // Glass door
          const ovenGlass = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.2, h * 0.6, 0.02),
            new THREE.MeshStandardMaterial({ color: 0x1a1a1a, transparent: true, opacity: 0.7 })
          );
          ovenGlass.position.set(0, -h * 0.1, d/2 + 0.02);
          group.add(ovenGlass);

          // Handle
          const ovenHandle = new THREE.Mesh(
            new THREE.BoxGeometry(w * 0.6, 0.05, 0.1),
            new THREE.MeshStandardMaterial({ color: 0xA0A0A0, metalness: 0.7 })
          );
          ovenHandle.position.set(0, h * 0.3, d/2 + 0.08);
          group.add(ovenHandle);
          break;

        case 'wall-oven-double': {
          // Double wall oven with two stacked oven cavities
          const woBodyMat = new THREE.MeshStandardMaterial({ color: 0x2a2a2a, roughness: 0.3, metalness: 0.4 });
          const woChromeMat = new THREE.MeshStandardMaterial({
            color: 0xCCCCCC, roughness: 0.15, metalness: 0.85,
            envMap: window.roomEnvMap || null
          });
          const woGlassMat = new THREE.MeshStandardMaterial({
            color: 0x111111, transparent: true, opacity: 0.75, roughness: 0.1, metalness: 0.3
          });

          // Main body shell
          const woBody = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), woBodyMat);
          group.add(woBody);

          // Split height: upper oven ~45%, divider ~3%, lower oven ~45%, control strip ~7%
          const controlH = h * 0.07;
          const dividerH = h * 0.03;
          const cavityH = (h - controlH - dividerH) / 2;
          const upperCenterY = h/2 - controlH - cavityH/2;
          const lowerCenterY = upperCenterY - cavityH - dividerH;

          // Control panel strip at top
          const woControlPanel = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.06, controlH, 0.03),
            new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.4, metalness: 0.5 })
          );
          woControlPanel.position.set(0, h/2 - controlH/2, d/2 + 0.02);
          group.add(woControlPanel);

          // Digital display
          const woDisplay = new THREE.Mesh(
            new THREE.BoxGeometry(w * 0.25, controlH * 0.5, 0.005),
            new THREE.MeshStandardMaterial({ color: 0x003366, emissive: 0x001133, roughness: 0.2 })
          );
          woDisplay.position.set(0, h/2 - controlH/2, d/2 + 0.04);
          group.add(woDisplay);

          // Control knobs (left and right of display)
          for (let ki = -1; ki <= 1; ki += 2) {
            const woKnob = new THREE.Mesh(
              new THREE.CylinderGeometry(controlH * 0.2, controlH * 0.2, 0.04, 16),
              woChromeMat
            );
            woKnob.rotation.x = Math.PI / 2;
            woKnob.position.set(ki * w * 0.35, h/2 - controlH/2, d/2 + 0.04);
            group.add(woKnob);
          }

          // Render each oven cavity (upper and lower)
          [upperCenterY, lowerCenterY].forEach((cy) => {
            // Oven door face (slightly proud of body)
            const woDoor = new THREE.Mesh(
              new THREE.BoxGeometry(w - 0.06, cavityH - 0.04, 0.025),
              new THREE.MeshStandardMaterial({ color: 0x303030, roughness: 0.35, metalness: 0.4 })
            );
            woDoor.position.set(0, cy, d/2 + 0.015);
            group.add(woDoor);

            // Glass window (centered on door, ~60% of door height)
            const glassH = cavityH * 0.55;
            const woGlass = new THREE.Mesh(
              new THREE.BoxGeometry(w - 0.25, glassH, 0.015),
              woGlassMat
            );
            woGlass.position.set(0, cy - cavityH * 0.05, d/2 + 0.03);
            group.add(woGlass);

            // Chrome frame around glass
            const frameThick = 0.025;
            // Top frame
            const woFrameT = new THREE.Mesh(
              new THREE.BoxGeometry(w - 0.22, frameThick, 0.02),
              woChromeMat
            );
            woFrameT.position.set(0, cy - cavityH * 0.05 + glassH/2 + frameThick/2, d/2 + 0.03);
            group.add(woFrameT);
            // Bottom frame
            const woFrameB = new THREE.Mesh(
              new THREE.BoxGeometry(w - 0.22, frameThick, 0.02),
              woChromeMat
            );
            woFrameB.position.set(0, cy - cavityH * 0.05 - glassH/2 - frameThick/2, d/2 + 0.03);
            group.add(woFrameB);

            // Towel-bar handle
            const handleW = w * 0.55;
            const handleY = cy + cavityH/2 - 0.06;
            // Bar
            const woBar = new THREE.Mesh(
              new THREE.CylinderGeometry(0.015, 0.015, handleW, 8),
              woChromeMat
            );
            woBar.rotation.z = Math.PI / 2;
            woBar.position.set(0, handleY, d/2 + 0.08);
            group.add(woBar);
            // Brackets
            for (let bi = -1; bi <= 1; bi += 2) {
              const woBracket = new THREE.Mesh(
                new THREE.BoxGeometry(0.02, 0.02, 0.05),
                woChromeMat
              );
              woBracket.position.set(bi * handleW/2, handleY, d/2 + 0.055);
              group.add(woBracket);
            }
          });

          // Center divider strip between ovens
          const woDivider = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.04, dividerH, 0.03),
            woChromeMat
          );
          woDivider.position.set(0, (upperCenterY + lowerCenterY) / 2, d/2 + 0.02);
          group.add(woDivider);

          // Side trim panels
          for (let si = -1; si <= 1; si += 2) {
            const woSide = new THREE.Mesh(
              new THREE.BoxGeometry(0.02, h, d * 0.98),
              new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.3, metalness: 0.5 })
            );
            woSide.position.set(si * (w/2 - 0.01), 0, 0);
            group.add(woSide);
          }

          // Brand badge
          const woBadge = new THREE.Mesh(
            new THREE.BoxGeometry(w * 0.12, 0.02, 0.01),
            woChromeMat
          );
          woBadge.position.set(0, h/2 - controlH - 0.04, d/2 + 0.04);
          group.add(woBadge);

          break;
        }

        case 'door': {
          // Standard interior/exterior door with full frame
          // Construction-standard dimensions
          const doorColor = el.color ? parseInt(el.color.replace('#', ''), 16) : 0xDEB887;
          const doorMat2 = new THREE.MeshStandardMaterial({ color: doorColor, roughness: 0.6 });
          const doorFrameMat = new THREE.MeshStandardMaterial({ color: 0xF5F5F0, roughness: 0.45 });
          const dFrameW = 0.17;  // ~2" casing face width
          const dFrameD = 0.33;  // ~4" frame depth (wall depth)
          const dPanelD = 0.15;  // ~1.75" door slab thickness

          // Door panel (slab)
          const doorPanel = new THREE.Mesh(
            new THREE.BoxGeometry(w - dFrameW * 2, h - dFrameW, dPanelD),
            doorMat2
          );
          doorPanel.position.set(0, -dFrameW / 2, 0);
          doorPanel.castShadow = true;
          group.add(doorPanel);

          // Door panel detail (raised panel effect)
          const panelDetailMat = new THREE.MeshStandardMaterial({
            color: adjustColorBrightness(doorColor, -20),
            roughness: 0.5
          });
          const panelInset = new THREE.Mesh(
            new THREE.BoxGeometry(w * 0.55, h * 0.33, 0.02),
            panelDetailMat
          );
          panelInset.position.set(0, h * 0.15, dPanelD / 2 + 0.01);
          group.add(panelInset);

          const panelInset2 = new THREE.Mesh(
            new THREE.BoxGeometry(w * 0.55, h * 0.33, 0.02),
            panelDetailMat
          );
          panelInset2.position.set(0, -h * 0.25, dPanelD / 2 + 0.01);
          group.add(panelInset2);

          // Frame - head (top casing)
          const frameTop = new THREE.Mesh(
            new THREE.BoxGeometry(w + dFrameW * 2, dFrameW, dFrameD),
            doorFrameMat
          );
          frameTop.position.set(0, h / 2, 0);
          frameTop.castShadow = true;
          group.add(frameTop);

          // Frame - left jamb
          const frameLeft = new THREE.Mesh(
            new THREE.BoxGeometry(dFrameW, h, dFrameD),
            doorFrameMat
          );
          frameLeft.position.set(-w / 2 - dFrameW / 2, 0, 0);
          frameLeft.castShadow = true;
          group.add(frameLeft);

          // Frame - right jamb
          const frameRight = new THREE.Mesh(
            new THREE.BoxGeometry(dFrameW, h, dFrameD),
            doorFrameMat
          );
          frameRight.position.set(w / 2 + dFrameW / 2, 0, 0);
          frameRight.castShadow = true;
          group.add(frameRight);

          // Threshold
          const thresholdMat = new THREE.MeshStandardMaterial({ color: 0x8B7355, roughness: 0.6 });
          const threshold = new THREE.Mesh(
            new THREE.BoxGeometry(w, 0.06, dFrameD + 0.05),
            thresholdMat
          );
          threshold.position.set(0, -h / 2 + 0.03, 0.025);
          group.add(threshold);

          // Door handle (lever style)
          const handleMat = new THREE.MeshStandardMaterial({
            color: 0xC0C0C0,
            metalness: 0.8,
            roughness: 0.2
          });

          // Handle plate (escutcheon)
          const handlePlate = new THREE.Mesh(
            new THREE.BoxGeometry(0.06, 0.18, 0.02),
            handleMat
          );
          handlePlate.position.set(w / 2 - 0.2, 0, dPanelD / 2 + 0.02);
          group.add(handlePlate);

          // Handle lever
          const handleLever = new THREE.Mesh(
            new THREE.BoxGeometry(0.14, 0.035, 0.035),
            handleMat
          );
          handleLever.position.set(w / 2 - 0.15, 0, dPanelD / 2 + 0.04);
          group.add(handleLever);

          break;
        }

        case 'window':
        case 'window-large':
        case 'bay-window':
        case 'picture-window': {
          // Professional Window with proper architectural details
          // Note: window-bay handled separately below with angled bay projection geometry
          // Supports: double-hung, single-hung, casement, sliding, fixed, picture
          // Picture windows and window-large default to fixed (single pane, no sashes)
          const isPictureType = el.type === 'picture-window' || el.type === 'window-large';
          const windowStyle = el.windowStyle || (isPictureType ? 'fixed' : 'double-hung');
          const mullionPattern = el.mullionPattern || (isPictureType ? 'none' : 'standard');
          const frameColor = el.frameColor ? parseInt(el.frameColor.replace('#', ''), 16) : 0x3D2B1F;

          // Standard window dimensions (IRC / AAMA construction standards)
          const frameThickness = 0.25; // ~3" frame depth (proper wall depth)
          const frameWidth = 0.2; // ~2.4" frame face width
          const sashWidth = 0.10; // ~1.2" sash profile
          const muntinWidth = 0.04; // ~0.5" muntin (grille) bars

          // Materials
          const frameMat = new THREE.MeshStandardMaterial({
            color: frameColor,
            roughness: 0.35,
            metalness: 0.15
          });
          const sashMat = new THREE.MeshStandardMaterial({
            color: frameColor,
            roughness: 0.4,
            metalness: 0.1
          });
          const muntinMat = new THREE.MeshStandardMaterial({
            color: frameColor,
            roughness: 0.45,
            metalness: 0.05
          });
          const hardwareMat = new THREE.MeshStandardMaterial({
            color: 0xC0C0C0,
            roughness: 0.2,
            metalness: 0.9
          });
          const weatherstripMat = new THREE.MeshStandardMaterial({
            color: 0x333333,
            roughness: 0.8
          });

          // === MAIN FRAME (Jamb, Head, Sill) ===
          // Head (top jamb)
          const headJamb = new THREE.Mesh(
            new THREE.BoxGeometry(w + 0.05, frameWidth, frameThickness),
            frameMat
          );
          headJamb.position.set(0, h/2 - frameWidth/2, 0);
          headJamb.castShadow = true;
          group.add(headJamb);

          // Side jambs
          [-1, 1].forEach(side => {
            const sideJamb = new THREE.Mesh(
              new THREE.BoxGeometry(frameWidth, h - frameWidth, frameThickness),
              frameMat
            );
            sideJamb.position.set(side * (w/2 - frameWidth/2), -frameWidth/2, 0);
            sideJamb.castShadow = true;
            group.add(sideJamb);
          });

          // Sill (sloped for water drainage)
          const sillHeight = frameWidth * 1.2;
          const sillDepth = frameThickness + 0.15;
          const sillMat = new THREE.MeshStandardMaterial({ color: 0xF5F5F0, roughness: 0.45 });
          const sill = new THREE.Mesh(
            new THREE.BoxGeometry(w + 0.2, sillHeight, sillDepth),
            sillMat
          );
          sill.position.set(0, -h/2 + sillHeight/2, sillDepth/2 - frameThickness/2);
          sill.castShadow = true;
          group.add(sill);

          // Sill nose (drip edge)
          const sillNose = new THREE.Mesh(
            new THREE.BoxGeometry(w + 0.22, 0.02, 0.03),
            sillMat
          );
          sillNose.position.set(0, -h/2 + 0.02, sillDepth - frameThickness/2 + 0.01);
          group.add(sillNose);

          // Calculate glass/sash area
          const openingWidth = w - frameWidth * 2;
          const openingHeight = h - frameWidth - sillHeight;
          const outdoorZ = -frameThickness/2 + 0.01;

          // === OUTDOOR VIEW ===
          const outdoorPalette = OUTDOOR_COLORS[sceneSettings.timeOfDay] || OUTDOOR_COLORS.noon;

          if (textureUrl) {
            const viewMat = createTexturedMaterial(0xFFFFFF, textureUrl, {
              roughness: 0.1,
              side: THREE.DoubleSide
            });
            const viewPane = new THREE.Mesh(
              new THREE.PlaneGeometry(openingWidth - 0.1, openingHeight - 0.1),
              viewMat
            );
            viewPane.position.set(0, (openingHeight - h)/2 + sillHeight/2, outdoorZ);
            group.add(viewPane);
          } else {
            // Sky
            const skyMat = new THREE.MeshBasicMaterial({ color: outdoorPalette.sky, side: THREE.DoubleSide });
            const skyPane = new THREE.Mesh(
              new THREE.PlaneGeometry(openingWidth - 0.05, openingHeight - 0.05),
              skyMat
            );
            skyPane.position.set(0, (openingHeight - h)/2 + sillHeight/2, outdoorZ);
            group.add(skyPane);

            // Horizon
            const horizonMat = new THREE.MeshBasicMaterial({ color: outdoorPalette.horizon });
            const horizonPane = new THREE.Mesh(
              new THREE.PlaneGeometry(openingWidth - 0.05, openingHeight * 0.35),
              horizonMat
            );
            horizonPane.position.set(0, -h/2 + sillHeight + openingHeight * 0.17, outdoorZ + 0.002);
            group.add(horizonPane);

            // Trees and sky elements
            if (sceneSettings.timeOfDay !== 'night') {
              const treeMat = new THREE.MeshBasicMaterial({ color: 0x228B22 });
              for (let t = 0; t < 3; t++) {
                const treeSize = 0.12 + Math.random() * 0.12;
                const tree = new THREE.Mesh(new THREE.ConeGeometry(treeSize, treeSize * 2, 6), treeMat);
                tree.position.set((t - 1) * openingWidth * 0.3, -h/2 + sillHeight + openingHeight * 0.25, outdoorZ + 0.005);
                group.add(tree);
              }
              if (sceneSettings.timeOfDay === 'noon') {
                const sunMat = new THREE.MeshBasicMaterial({ color: 0xFFFF99 });
                const sun = new THREE.Mesh(new THREE.CircleGeometry(0.12, 16), sunMat);
                sun.position.set(openingWidth * 0.25, h/2 - frameWidth - openingHeight * 0.25, outdoorZ + 0.003);
                group.add(sun);
              }
            } else {
              const starMat = new THREE.MeshBasicMaterial({ color: 0xFFFFFF });
              for (let i = 0; i < 10; i++) {
                const star = new THREE.Mesh(new THREE.SphereGeometry(0.015, 4, 4), starMat);
                star.position.set(
                  (Math.random() - 0.5) * openingWidth * 0.8,
                  h/2 - frameWidth - openingHeight * 0.3 - Math.random() * openingHeight * 0.4,
                  outdoorZ + 0.003
                );
                group.add(star);
              }
              const moonMat = new THREE.MeshBasicMaterial({ color: 0xFFFACD });
              const moon = new THREE.Mesh(new THREE.CircleGeometry(0.1, 16), moonMat);
              moon.position.set(openingWidth * 0.3, h/2 - frameWidth - openingHeight * 0.25, outdoorZ + 0.004);
              group.add(moon);
            }
          }

          // === SASH AND GLASS based on window style ===
          const glassColor = sceneSettings.timeOfDay === 'night' ? 0x2a3a5a : 0xADD8E6;
          const glassMat = new THREE.MeshStandardMaterial({
            color: glassColor,
            transparent: true,
            opacity: 0.12,
            roughness: 0.02,
            metalness: 0.35
          });

          // Function to create muntin/grille pattern
          const createMuntinPattern = (sashW, sashH, centerX, centerY, zPos) => {
            if (mullionPattern === 'none' || el.type === 'picture-window') return;

            const muntinGroup = new THREE.Group();

            if (mullionPattern === 'colonial') {
              // Colonial: 6 over 6 or 4 over 4 pattern
              const cols = sashW > 1.5 ? 3 : 2;
              const rows = sashH > 1.5 ? 3 : 2;

              // Vertical muntins
              for (let c = 1; c < cols; c++) {
                const vMuntin = new THREE.Mesh(
                  new THREE.BoxGeometry(muntinWidth, sashH - sashWidth * 2, muntinWidth),
                  muntinMat
                );
                vMuntin.position.set(centerX - sashW/2 + sashWidth + c * (sashW - sashWidth * 2) / cols, centerY, zPos + 0.02);
                muntinGroup.add(vMuntin);
              }

              // Horizontal muntins
              for (let r = 1; r < rows; r++) {
                const hMuntin = new THREE.Mesh(
                  new THREE.BoxGeometry(sashW - sashWidth * 2, muntinWidth, muntinWidth),
                  muntinMat
                );
                hMuntin.position.set(centerX, centerY - sashH/2 + sashWidth + r * (sashH - sashWidth * 2) / rows, zPos + 0.02);
                muntinGroup.add(hMuntin);
              }
            } else if (mullionPattern === 'prairie') {
              // Prairie: border pattern with clear center
              const borderInset = Math.min(sashW, sashH) * 0.2;

              // Inner frame
              const borderW = sashW - sashWidth * 2 - borderInset * 2;
              const borderH = sashH - sashWidth * 2 - borderInset * 2;

              // Top border line
              const topBorder = new THREE.Mesh(
                new THREE.BoxGeometry(sashW - sashWidth * 2, muntinWidth, muntinWidth),
                muntinMat
              );
              topBorder.position.set(centerX, centerY + borderH/2 + borderInset/2, zPos + 0.02);
              muntinGroup.add(topBorder);

              // Bottom border line
              const botBorder = new THREE.Mesh(
                new THREE.BoxGeometry(sashW - sashWidth * 2, muntinWidth, muntinWidth),
                muntinMat
              );
              botBorder.position.set(centerX, centerY - borderH/2 - borderInset/2, zPos + 0.02);
              muntinGroup.add(botBorder);

              // Side border lines
              [-1, 1].forEach(side => {
                const sideBorder = new THREE.Mesh(
                  new THREE.BoxGeometry(muntinWidth, sashH - sashWidth * 2, muntinWidth),
                  muntinMat
                );
                sideBorder.position.set(centerX + side * (borderW/2 + borderInset/2), centerY, zPos + 0.02);
                muntinGroup.add(sideBorder);
              });
            } else {
              // Standard: single cross divider
              const vMuntin = new THREE.Mesh(
                new THREE.BoxGeometry(muntinWidth * 1.5, sashH - sashWidth * 2, muntinWidth * 1.5),
                muntinMat
              );
              vMuntin.position.set(centerX, centerY, zPos + 0.02);
              muntinGroup.add(vMuntin);
            }

            group.add(muntinGroup);
          };

          if (windowStyle === 'double-hung' || windowStyle === 'single-hung') {
            // Two sashes - upper and lower
            const sashH = (openingHeight - 0.02) / 2;
            const upperSashY = h/2 - frameWidth - sashH/2;
            const lowerSashY = -h/2 + sillHeight + sashH/2;

            // Upper sash (fixed in single-hung, operable in double-hung)
            const upperSashGroup = new THREE.Group();

            // Upper sash frame
            const upperTop = new THREE.Mesh(new THREE.BoxGeometry(openingWidth, sashWidth, frameThickness * 0.6), sashMat);
            upperTop.position.set(0, sashH/2 - sashWidth/2, 0);
            upperSashGroup.add(upperTop);

            const upperBot = new THREE.Mesh(new THREE.BoxGeometry(openingWidth, sashWidth, frameThickness * 0.6), sashMat);
            upperBot.position.set(0, -sashH/2 + sashWidth/2, 0);
            upperSashGroup.add(upperBot);

            [-1, 1].forEach(side => {
              const upperSide = new THREE.Mesh(new THREE.BoxGeometry(sashWidth, sashH, frameThickness * 0.6), sashMat);
              upperSide.position.set(side * (openingWidth/2 - sashWidth/2), 0, 0);
              upperSashGroup.add(upperSide);
            });

            // Upper glass
            const upperGlass = new THREE.Mesh(
              new THREE.PlaneGeometry(openingWidth - sashWidth * 2 - 0.02, sashH - sashWidth * 2 - 0.02),
              glassMat
            );
            upperGlass.position.z = 0.02;
            upperSashGroup.add(upperGlass);

            upperSashGroup.position.set(0, upperSashY, -0.01);
            group.add(upperSashGroup);
            createMuntinPattern(openingWidth, sashH, 0, upperSashY, -0.01);

            // Lower sash (always operable)
            const lowerSashGroup = new THREE.Group();

            const lowerTop = new THREE.Mesh(new THREE.BoxGeometry(openingWidth, sashWidth, frameThickness * 0.6), sashMat);
            lowerTop.position.set(0, sashH/2 - sashWidth/2, 0);
            lowerSashGroup.add(lowerTop);

            const lowerBot = new THREE.Mesh(new THREE.BoxGeometry(openingWidth, sashWidth, frameThickness * 0.6), sashMat);
            lowerBot.position.set(0, -sashH/2 + sashWidth/2, 0);
            lowerSashGroup.add(lowerBot);

            [-1, 1].forEach(side => {
              const lowerSide = new THREE.Mesh(new THREE.BoxGeometry(sashWidth, sashH, frameThickness * 0.6), sashMat);
              lowerSide.position.set(side * (openingWidth/2 - sashWidth/2), 0, 0);
              lowerSashGroup.add(lowerSide);
            });

            // Lower glass
            const lowerGlass = new THREE.Mesh(
              new THREE.PlaneGeometry(openingWidth - sashWidth * 2 - 0.02, sashH - sashWidth * 2 - 0.02),
              glassMat
            );
            lowerGlass.position.z = 0.02;
            lowerSashGroup.add(lowerGlass);

            lowerSashGroup.position.set(0, lowerSashY, 0.02);
            group.add(lowerSashGroup);
            createMuntinPattern(openingWidth, sashH, 0, lowerSashY, 0.02);

            // Meeting rail (where sashes overlap)
            const meetingRail = new THREE.Mesh(
              new THREE.BoxGeometry(openingWidth, sashWidth * 0.6, frameThickness * 0.3),
              sashMat
            );
            meetingRail.position.set(0, (upperSashY + lowerSashY) / 2, 0.02);
            group.add(meetingRail);

            // Window lock (at meeting rail)
            const lockBase = new THREE.Mesh(
              new THREE.BoxGeometry(0.04, 0.025, 0.015),
              hardwareMat
            );
            lockBase.position.set(0, (upperSashY + lowerSashY) / 2 + 0.03, frameThickness/2 + 0.02);
            group.add(lockBase);

            const lockLever = new THREE.Mesh(
              new THREE.BoxGeometry(0.05, 0.015, 0.01),
              hardwareMat
            );
            lockLever.position.set(0.02, (upperSashY + lowerSashY) / 2 + 0.035, frameThickness/2 + 0.03);
            group.add(lockLever);

          } else if (windowStyle === 'casement') {
            // Side-hinged window with crank operator
            const sashGroup = new THREE.Group();

            // Sash frame (all 4 sides)
            const sashInnerW = openingWidth - 0.02;
            const sashInnerH = openingHeight - 0.02;

            const sTop = new THREE.Mesh(new THREE.BoxGeometry(sashInnerW, sashWidth, frameThickness * 0.5), sashMat);
            sTop.position.set(0, sashInnerH/2 - sashWidth/2, 0);
            sashGroup.add(sTop);

            const sBot = new THREE.Mesh(new THREE.BoxGeometry(sashInnerW, sashWidth, frameThickness * 0.5), sashMat);
            sBot.position.set(0, -sashInnerH/2 + sashWidth/2, 0);
            sashGroup.add(sBot);

            [-1, 1].forEach(side => {
              const sSide = new THREE.Mesh(new THREE.BoxGeometry(sashWidth, sashInnerH, frameThickness * 0.5), sashMat);
              sSide.position.set(side * (sashInnerW/2 - sashWidth/2), 0, 0);
              sashGroup.add(sSide);
            });

            // Glass
            const casementGlass = new THREE.Mesh(
              new THREE.PlaneGeometry(sashInnerW - sashWidth * 2 - 0.02, sashInnerH - sashWidth * 2 - 0.02),
              glassMat
            );
            casementGlass.position.z = 0.01;
            sashGroup.add(casementGlass);

            sashGroup.position.set(0, (openingHeight - h)/2 + sillHeight/2, 0.01);
            group.add(sashGroup);

            createMuntinPattern(sashInnerW, sashInnerH, 0, (openingHeight - h)/2 + sillHeight/2, 0.01);

            // Hinges (on one side)
            [0.25, 0.75].forEach(hPos => {
              const hinge = new THREE.Mesh(
                new THREE.BoxGeometry(0.02, 0.08, 0.025),
                hardwareMat
              );
              hinge.position.set(-openingWidth/2 + 0.02, -h/2 + sillHeight + openingHeight * hPos, frameThickness/2);
              group.add(hinge);
            });

            // Crank operator (at bottom)
            const crankBase = new THREE.Mesh(
              new THREE.BoxGeometry(0.06, 0.03, 0.02),
              hardwareMat
            );
            crankBase.position.set(openingWidth/4, -h/2 + sillHeight + 0.15, frameThickness/2 + 0.02);
            group.add(crankBase);

            const crankHandle = new THREE.Mesh(
              new THREE.CylinderGeometry(0.008, 0.008, 0.08, 8),
              hardwareMat
            );
            crankHandle.rotation.z = Math.PI / 2;
            crankHandle.position.set(openingWidth/4 + 0.04, -h/2 + sillHeight + 0.15, frameThickness/2 + 0.03);
            group.add(crankHandle);

          } else if (windowStyle === 'sliding') {
            // Two panels, one slides horizontally
            const panelW = (openingWidth + 0.02) / 2;

            // Fixed panel (left)
            const fixedPanel = new THREE.Group();

            const fTop = new THREE.Mesh(new THREE.BoxGeometry(panelW, sashWidth, frameThickness * 0.5), sashMat);
            fTop.position.set(0, openingHeight/2 - sashWidth/2, 0);
            fixedPanel.add(fTop);

            const fBot = new THREE.Mesh(new THREE.BoxGeometry(panelW, sashWidth, frameThickness * 0.5), sashMat);
            fBot.position.set(0, -openingHeight/2 + sashWidth/2, 0);
            fixedPanel.add(fBot);

            [-1, 1].forEach(side => {
              const fSide = new THREE.Mesh(new THREE.BoxGeometry(sashWidth, openingHeight, frameThickness * 0.5), sashMat);
              fSide.position.set(side * (panelW/2 - sashWidth/2), 0, 0);
              fixedPanel.add(fSide);
            });

            const fGlass = new THREE.Mesh(
              new THREE.PlaneGeometry(panelW - sashWidth * 2 - 0.02, openingHeight - sashWidth * 2 - 0.02),
              glassMat
            );
            fGlass.position.z = 0.01;
            fixedPanel.add(fGlass);

            fixedPanel.position.set(-panelW/2 + 0.01, (openingHeight - h)/2 + sillHeight/2, -0.01);
            group.add(fixedPanel);

            // Sliding panel (right, in front)
            const slidePanel = new THREE.Group();

            const sTop = new THREE.Mesh(new THREE.BoxGeometry(panelW, sashWidth, frameThickness * 0.5), sashMat);
            sTop.position.set(0, openingHeight/2 - sashWidth/2, 0);
            slidePanel.add(sTop);

            const sBot = new THREE.Mesh(new THREE.BoxGeometry(panelW, sashWidth, frameThickness * 0.5), sashMat);
            sBot.position.set(0, -openingHeight/2 + sashWidth/2, 0);
            slidePanel.add(sBot);

            [-1, 1].forEach(side => {
              const sSide = new THREE.Mesh(new THREE.BoxGeometry(sashWidth, openingHeight, frameThickness * 0.5), sashMat);
              sSide.position.set(side * (panelW/2 - sashWidth/2), 0, 0);
              slidePanel.add(sSide);
            });

            const sGlass = new THREE.Mesh(
              new THREE.PlaneGeometry(panelW - sashWidth * 2 - 0.02, openingHeight - sashWidth * 2 - 0.02),
              glassMat
            );
            sGlass.position.z = 0.01;
            slidePanel.add(sGlass);

            slidePanel.position.set(panelW/2 - 0.01, (openingHeight - h)/2 + sillHeight/2, 0.02);
            group.add(slidePanel);

            // Track (top and bottom)
            const trackMat = new THREE.MeshStandardMaterial({ color: 0x666666, roughness: 0.4, metalness: 0.5 });

            const topTrack = new THREE.Mesh(
              new THREE.BoxGeometry(openingWidth, 0.02, frameThickness * 0.4),
              trackMat
            );
            topTrack.position.set(0, h/2 - frameWidth - 0.01, 0);
            group.add(topTrack);

            const botTrack = new THREE.Mesh(
              new THREE.BoxGeometry(openingWidth, 0.02, frameThickness * 0.4),
              trackMat
            );
            botTrack.position.set(0, -h/2 + sillHeight + 0.01, 0);
            group.add(botTrack);

            // Sliding latch
            const latch = new THREE.Mesh(
              new THREE.BoxGeometry(0.04, 0.06, 0.015),
              hardwareMat
            );
            latch.position.set(panelW - sashWidth, (openingHeight - h)/2 + sillHeight/2, frameThickness/2 + 0.02);
            group.add(latch);

          } else {
            // Fixed/picture window - single pane, no operable hardware
            const fixedGlass = new THREE.Mesh(
              new THREE.PlaneGeometry(openingWidth - 0.05, openingHeight - 0.05),
              glassMat
            );
            fixedGlass.position.set(0, (openingHeight - h)/2 + sillHeight/2, 0.01);
            group.add(fixedGlass);

            // Simple glazing bead around glass
            const beadMat = new THREE.MeshStandardMaterial({ color: frameColor, roughness: 0.5 });
            const beadW = 0.025;

            const topBead = new THREE.Mesh(new THREE.BoxGeometry(openingWidth, beadW, beadW), beadMat);
            topBead.position.set(0, h/2 - frameWidth - beadW/2, 0.02);
            group.add(topBead);

            const botBead = new THREE.Mesh(new THREE.BoxGeometry(openingWidth, beadW, beadW), beadMat);
            botBead.position.set(0, -h/2 + sillHeight + beadW/2, 0.02);
            group.add(botBead);

            [-1, 1].forEach(side => {
              const sideBead = new THREE.Mesh(new THREE.BoxGeometry(beadW, openingHeight, beadW), beadMat);
              sideBead.position.set(side * (openingWidth/2 - beadW/2), (openingHeight - h)/2 + sillHeight/2, 0.02);
              group.add(sideBead);
            });
          }

          // === INTERIOR TRIM (Casing) ===
          const trimMat = new THREE.MeshStandardMaterial({ color: 0xF0EDE8, roughness: 0.55 });
          const casingWidth = 0.09; // 2.25" trim
          const casingThick = 0.02; // 1/2" proud of wall

          // Head casing (with decorative profile)
          const headCasing = new THREE.Mesh(
            new THREE.BoxGeometry(w + casingWidth * 2, casingWidth, casingThick),
            trimMat
          );
          headCasing.position.set(0, h/2 + casingWidth/2, frameThickness/2 + casingThick/2);
          group.add(headCasing);

          // Head casing cap (crown detail)
          const headCap = new THREE.Mesh(
            new THREE.BoxGeometry(w + casingWidth * 2 + 0.02, 0.015, casingThick + 0.01),
            trimMat
          );
          headCap.position.set(0, h/2 + casingWidth, frameThickness/2 + casingThick/2);
          group.add(headCap);

          // Side casings
          [-1, 1].forEach(side => {
            const sideCasing = new THREE.Mesh(
              new THREE.BoxGeometry(casingWidth, h + casingWidth, casingThick),
              trimMat
            );
            sideCasing.position.set(side * (w/2 + casingWidth/2), -casingWidth/2, frameThickness/2 + casingThick/2);
            group.add(sideCasing);
          });

          // Stool (interior sill extension)
          const stoolMat = new THREE.MeshStandardMaterial({ color: 0xFAF8F5, roughness: 0.4 });
          const stool = new THREE.Mesh(
            new THREE.BoxGeometry(w + casingWidth * 2 + 0.05, 0.025, 0.12),
            stoolMat
          );
          stool.position.set(0, -h/2 + sillHeight * 0.5, frameThickness/2 + 0.05);
          group.add(stool);

          // Apron (trim below stool)
          const apron = new THREE.Mesh(
            new THREE.BoxGeometry(w + casingWidth * 2, casingWidth * 0.6, casingThick),
            trimMat
          );
          apron.position.set(0, -h/2 + sillHeight * 0.5 - casingWidth * 0.35, frameThickness/2 + casingThick/2);
          group.add(apron);

          break;
        }

        case 'wall': {
          // Wall segment (drywall)
          // In 2D: width is the thin dimension (thickness), height is the long dimension (length)
          // Need to handle both horizontal and vertical walls
          const rotation = el.rotation || 0;
          const isVertical = rotation === 90 || rotation === 270 || rotation === -90;

          // Determine wall dimensions based on orientation
          let wallLength, wallThickness;
          if (isVertical) {
            // Wall runs along Z axis (top-to-bottom in 2D = into room in 3D)
            wallLength = d;  // The 2D height = wall length
            wallThickness = Math.max(w, 0.35);
          } else {
            // Wall runs along X axis (left-to-right in 2D)
            wallLength = w > d ? w : d;  // Use larger dimension as length
            wallThickness = Math.max(w < d ? w : d, 0.35);
          }

          const wallMat = new THREE.MeshStandardMaterial({
            color: el.color ? parseInt(el.color.replace('#', '0x')) : 0xF5F5DC,
            roughness: 0.8,
            side: THREE.DoubleSide
          });

          // Create wall mesh - length along X, height along Y, thickness along Z
          const wallMesh = new THREE.Mesh(
            new THREE.BoxGeometry(wallLength, h, wallThickness),
            wallMat
          );
          wallMesh.castShadow = true;
          wallMesh.receiveShadow = true;

          // Rotate for vertical walls
          if (isVertical) {
            wallMesh.rotation.y = Math.PI / 2;
          }

          group.add(wallMesh);
          break;
        }

        case 'wall-wood-2x4':
        case 'wall-wood-2x6': {
          // Wood framed wall
          const woodColor = el.type.includes('2x4') ? 0xDEB887 : 0xCD853F;
          const studWidth = el.type.includes('2x4') ? 0.1 : 0.15;
          const woodMat = new THREE.MeshStandardMaterial({ color: woodColor, roughness: 0.7 });

          // Studs (vertical)
          const studSpacing = 1.33; // 16" on center
          for (let sx = -w/2 + studSpacing/2; sx <= w/2; sx += studSpacing) {
            const stud = new THREE.Mesh(
              new THREE.BoxGeometry(studWidth, h - 0.2, d * 0.8),
              woodMat
            );
            stud.position.set(sx, 0, 0);
            group.add(stud);
          }

          // Top and bottom plates
          const plateMat = new THREE.MeshStandardMaterial({ color: woodColor, roughness: 0.6 });
          const topPlate = new THREE.Mesh(new THREE.BoxGeometry(w, 0.1, d * 0.8), plateMat);
          topPlate.position.y = h/2 - 0.05;
          group.add(topPlate);

          const botPlate = new THREE.Mesh(new THREE.BoxGeometry(w, 0.1, d * 0.8), plateMat);
          botPlate.position.y = -h/2 + 0.05;
          group.add(botPlate);
          break;
        }

        case 'wall-steel':
        case 'wall-aluminum': {
          // Metal stud wall
          const metalColor = el.type.includes('steel') ? 0x708090 : 0xC0C0C0;
          const metalMat = new THREE.MeshStandardMaterial({
            color: metalColor,
            roughness: 0.3,
            metalness: 0.7
          });

          // C-channel studs
          const studSpacing = 1.33;
          for (let sx = -w/2 + studSpacing/2; sx <= w/2; sx += studSpacing) {
            const stud = new THREE.Mesh(
              new THREE.BoxGeometry(0.05, h - 0.15, d * 0.7),
              metalMat
            );
            stud.position.set(sx, 0, 0);
            group.add(stud);
          }

          // Track (top and bottom)
          const trackMat = new THREE.MeshStandardMaterial({
            color: metalColor,
            roughness: 0.25,
            metalness: 0.8
          });
          const topTrack = new THREE.Mesh(new THREE.BoxGeometry(w, 0.08, d * 0.8), trackMat);
          topTrack.position.y = h/2 - 0.04;
          group.add(topTrack);

          const botTrack = new THREE.Mesh(new THREE.BoxGeometry(w, 0.08, d * 0.8), trackMat);
          botTrack.position.y = -h/2 + 0.04;
          group.add(botTrack);
          break;
        }

        case 'wall-concrete': {
          // Poured Concrete Wall with realistic form details
          // Features: form tie holes, construction joints, panel lines

          const concreteColor = el.color ? parseInt(el.color.replace('#', ''), 16) : 0x8C8C8C;

          // Main concrete material with slight roughness variation
          const concreteMat = new THREE.MeshStandardMaterial({
            color: concreteColor,
            roughness: 0.92,
            metalness: 0.02
          });

          // Darker concrete for recesses
          const concreteRecessMat = new THREE.MeshStandardMaterial({
            color: adjustColorBrightness(concreteColor, -20),
            roughness: 0.95,
            metalness: 0
          });

          // Form tie hole material (rust-stained)
          const tieHoleMat = new THREE.MeshStandardMaterial({
            color: 0x5C4033,
            roughness: 0.85,
            metalness: 0.1
          });

          // Base concrete wall
          const concreteWall = new THREE.Mesh(
            new THREE.BoxGeometry(w, h, d),
            concreteMat
          );
          concreteWall.castShadow = true;
          concreteWall.receiveShadow = true;
          group.add(concreteWall);

          // Form panel lines (typical 4' x 8' panels)
          const panelWidth = 4;  // 4 feet wide panels
          const panelHeight = 8; // 8 feet tall panels

          // Vertical panel joints
          const jointMat = new THREE.MeshStandardMaterial({
            color: adjustColorBrightness(concreteColor, -15),
            roughness: 0.9
          });

          for (let px = -w/2 + panelWidth; px < w/2; px += panelWidth) {
            const vJoint = new THREE.Mesh(
              new THREE.BoxGeometry(0.015, h, 0.02),
              jointMat
            );
            vJoint.position.set(px, 0, d/2 + 0.008);
            group.add(vJoint);
          }

          // Horizontal pour joints (every 8-10 feet typically)
          for (let py = -h/2 + panelHeight; py < h/2; py += panelHeight) {
            const hJoint = new THREE.Mesh(
              new THREE.BoxGeometry(w + 0.01, 0.02, 0.015),
              jointMat
            );
            hJoint.position.set(0, py, d/2 + 0.008);
            group.add(hJoint);
          }

          // Form tie holes - grid pattern (typically 2' horizontal x 2' vertical spacing)
          const tieSpacingH = 2;  // 2 feet horizontal
          const tieSpacingV = 2;  // 2 feet vertical
          const tieHoleRadius = 0.02; // ~1/2" diameter

          for (let ty = -h/2 + 1; ty < h/2 - 0.5; ty += tieSpacingV) {
            for (let tx = -w/2 + 1; tx < w/2 - 0.5; tx += tieSpacingH) {
              // Circular tie hole depression
              const tieHole = new THREE.Mesh(
                new THREE.CylinderGeometry(tieHoleRadius, tieHoleRadius, 0.03, 8),
                tieHoleMat
              );
              tieHole.rotation.x = Math.PI / 2;
              tieHole.position.set(tx, ty, d/2 + 0.01);
              group.add(tieHole);

              // Rust stain below tie hole
              const rustStain = new THREE.Mesh(
                new THREE.BoxGeometry(0.015, 0.08, 0.005),
                new THREE.MeshStandardMaterial({
                  color: 0x6B4423,
                  transparent: true,
                  opacity: 0.4,
                  roughness: 1
                })
              );
              rustStain.position.set(tx, ty - 0.06, d/2 + 0.005);
              group.add(rustStain);
            }
          }

          // Subtle surface texture variation (aggregate shadow)
          const textureMat = new THREE.MeshStandardMaterial({
            color: adjustColorBrightness(concreteColor, -8),
            transparent: true,
            opacity: 0.3,
            roughness: 1
          });

          // Random aggregate spots
          for (let i = 0; i < Math.min(w * h * 2, 50); i++) {
            const spotX = (Math.random() - 0.5) * w * 0.9;
            const spotY = (Math.random() - 0.5) * h * 0.9;
            const spotSize = 0.02 + Math.random() * 0.03;

            const spot = new THREE.Mesh(
              new THREE.CircleGeometry(spotSize, 6),
              textureMat
            );
            spot.position.set(spotX, spotY, d/2 + 0.003);
            group.add(spot);
          }

          break;
        }

        case 'wall-brick': {
          // Brick Wall with realistic running bond pattern
          // Standard brick: 2.25" x 3.625" x 8" (0.1875' x 0.3' x 0.67')
          // With 3/8" mortar joints

          const brickHeight = 0.1875 + 0.03;  // 2.25" + mortar = ~3" courses
          const brickWidth = 0.67;             // 8" brick length
          const mortarJoint = 0.03;            // 3/8" mortar

          // Brick colors with variation for realism
          const brickBaseColor = el.color ? parseInt(el.color.replace('#', ''), 16) : 0xB22222;
          const brickColors = [
            brickBaseColor,
            adjustColorBrightness(brickBaseColor, 10),
            adjustColorBrightness(brickBaseColor, -10),
            adjustColorBrightness(brickBaseColor, 5),
            adjustColorBrightness(brickBaseColor, -15)
          ];

          // Create materials for each color variation
          const brickMats = brickColors.map(c => new THREE.MeshStandardMaterial({
            color: c,
            roughness: 0.88,
            metalness: 0.02
          }));

          // Mortar material
          const mortarMat = new THREE.MeshStandardMaterial({
            color: 0xC8C8C8,
            roughness: 0.85,
            metalness: 0
          });

          // Base wall (mortar color background)
          const baseWall = new THREE.Mesh(
            new THREE.BoxGeometry(w, h, d),
            mortarMat
          );
          group.add(baseWall);

          // Calculate courses and bricks
          const numCourses = Math.ceil(h / brickHeight);
          const bricksPerRow = Math.ceil(w / brickWidth);

          // Individual brick dimensions
          const singleBrickW = brickWidth - mortarJoint;
          const singleBrickH = brickHeight - mortarJoint;
          const singleBrickD = d - mortarJoint * 2;

          // Create individual bricks with running bond
          for (let row = 0; row < numCourses; row++) {
            // Running bond offset
            const rowOffset = (row % 2) * (brickWidth / 2);
            const brickY = -h/2 + brickHeight/2 + row * brickHeight;

            if (brickY - singleBrickH/2 > h/2) continue;

            for (let col = -1; col <= bricksPerRow; col++) {
              const brickX = -w/2 + brickWidth/2 + col * brickWidth - rowOffset;

              // Skip bricks outside bounds
              if (brickX + singleBrickW/2 < -w/2 || brickX - singleBrickW/2 > w/2) continue;

              // Calculate clipped dimensions
              let actualW = singleBrickW;
              let actualX = brickX;
              let actualH = singleBrickH;
              let actualY = brickY;

              // Clip edges
              if (brickX - singleBrickW/2 < -w/2) {
                const clip = (-w/2) - (brickX - singleBrickW/2);
                actualW -= clip;
                actualX += clip / 2;
              }
              if (brickX + singleBrickW/2 > w/2) {
                const clip = (brickX + singleBrickW/2) - (w/2);
                actualW -= clip;
                actualX -= clip / 2;
              }
              if (brickY + singleBrickH/2 > h/2) {
                const clip = (brickY + singleBrickH/2) - (h/2);
                actualH -= clip;
                actualY -= clip / 2;
              }

              if (actualW < 0.05 || actualH < 0.03) continue;

              // Random color variation for natural look
              const colorIdx = (row * 7 + col * 3) % brickMats.length;
              const brick = new THREE.Mesh(
                new THREE.BoxGeometry(actualW, actualH, singleBrickD),
                brickMats[colorIdx]
              );
              brick.position.set(actualX, actualY, 0);
              brick.castShadow = true;
              brick.receiveShadow = true;
              group.add(brick);
            }
          }

          // Visible mortar lines on front face
          // Horizontal bed joints
          for (let row = 1; row < numCourses; row++) {
            const jointY = -h/2 + row * brickHeight;
            if (jointY > h/2) continue;

            const hJoint = new THREE.Mesh(
              new THREE.BoxGeometry(w + 0.01, mortarJoint * 1.5, 0.01),
              mortarMat
            );
            hJoint.position.set(0, jointY, d/2 + 0.002);
            group.add(hJoint);
          }

          // Vertical head joints
          for (let row = 0; row < numCourses; row++) {
            const rowOffset = (row % 2) * (brickWidth / 2);
            const jointY = -h/2 + brickHeight/2 + row * brickHeight;

            for (let col = 0; col <= bricksPerRow; col++) {
              const jointX = -w/2 + col * brickWidth - rowOffset;
              if (jointX < -w/2 || jointX > w/2) continue;

              const vJoint = new THREE.Mesh(
                new THREE.BoxGeometry(mortarJoint * 1.5, singleBrickH + 0.01, 0.01),
                mortarMat
              );
              vJoint.position.set(jointX, jointY, d/2 + 0.002);
              group.add(vJoint);
            }
          }

          break;
        }

        case 'wall-block': {
          // CMU (Concrete Masonry Unit) Block Wall
          // Standard CMU: 8" x 8" x 16" nominal (0.67' x 0.67' x 1.33')
          // Actual: 7.625" x 7.625" x 15.625" with 3/8" mortar joints

          const cmuHeight = 0.67;  // 8" in feet
          const cmuWidth = 1.33;   // 16" in feet
          const mortarJoint = 0.03; // 3/8" mortar joint

          // CMU concrete colors with slight variation for realism
          const cmuBaseColor = el.color ? parseInt(el.color.replace('#', ''), 16) : 0x808080;
          const cmuMat = new THREE.MeshStandardMaterial({
            color: cmuBaseColor,
            roughness: 0.92,
            metalness: 0.02
          });

          // Slightly darker color for depth/shadow blocks
          const cmuDarkMat = new THREE.MeshStandardMaterial({
            color: adjustColorBrightness(cmuBaseColor, -15),
            roughness: 0.95,
            metalness: 0.02
          });

          // Mortar material (light gray cement)
          const mortarMat = new THREE.MeshStandardMaterial({
            color: 0xB8B8B8,
            roughness: 0.85,
            metalness: 0
          });

          // Calculate number of courses (rows) and blocks per row
          const numCourses = Math.ceil(h / cmuHeight);
          const blocksPerRow = Math.ceil(w / cmuWidth);

          // Create the base wall with mortar color (visible in joints)
          const baseWall = new THREE.Mesh(
            new THREE.BoxGeometry(w, h, d),
            mortarMat
          );
          group.add(baseWall);

          // Individual block dimensions (slightly smaller than nominal for mortar gaps)
          const blockW = cmuWidth - mortarJoint;
          const blockH = cmuHeight - mortarJoint;
          const blockD = d - mortarJoint * 2;

          // Create individual CMU blocks with running bond pattern
          for (let row = 0; row < numCourses; row++) {
            // Running bond: offset every other row by half block
            const rowOffset = (row % 2) * (cmuWidth / 2);
            const blockY = -h/2 + cmuHeight/2 + row * cmuHeight;

            // Skip if block would be above wall height
            if (blockY - blockH/2 > h/2) continue;

            for (let col = -1; col <= blocksPerRow; col++) {
              const blockX = -w/2 + cmuWidth/2 + col * cmuWidth - rowOffset;

              // Skip blocks that are completely outside the wall width
              if (blockX + blockW/2 < -w/2 || blockX - blockW/2 > w/2) continue;

              // Calculate clipped block dimensions for edge blocks
              let actualBlockW = blockW;
              let actualBlockX = blockX;

              // Clip left edge
              if (blockX - blockW/2 < -w/2) {
                const clipAmount = (-w/2) - (blockX - blockW/2);
                actualBlockW -= clipAmount;
                actualBlockX += clipAmount / 2;
              }

              // Clip right edge
              if (blockX + blockW/2 > w/2) {
                const clipAmount = (blockX + blockW/2) - (w/2);
                actualBlockW -= clipAmount;
                actualBlockX -= clipAmount / 2;
              }

              // Clip top edge
              let actualBlockH = blockH;
              let actualBlockY = blockY;
              if (blockY + blockH/2 > h/2) {
                const clipAmount = (blockY + blockH/2) - (h/2);
                actualBlockH -= clipAmount;
                actualBlockY -= clipAmount / 2;
              }

              // Skip very small fragments
              if (actualBlockW < 0.1 || actualBlockH < 0.1) continue;

              // Alternate between normal and slightly darker blocks for texture
              const useDark = (row + col) % 7 === 0 || (row + col) % 11 === 0;
              const blockMaterial = useDark ? cmuDarkMat : cmuMat;

              // Main block face (front)
              const block = new THREE.Mesh(
                new THREE.BoxGeometry(actualBlockW, actualBlockH, blockD),
                blockMaterial
              );
              block.position.set(actualBlockX, actualBlockY, 0);
              block.castShadow = true;
              block.receiveShadow = true;
              group.add(block);

              // Add subtle face texture - horizontal score line typical in CMU
              if (actualBlockW > 0.5) {
                const scoreMat = new THREE.MeshStandardMaterial({
                  color: adjustColorBrightness(cmuBaseColor, -25),
                  roughness: 1
                });
                const scoreLine = new THREE.Mesh(
                  new THREE.BoxGeometry(actualBlockW - 0.08, 0.01, 0.005),
                  scoreMat
                );
                scoreLine.position.set(actualBlockX, actualBlockY, blockD/2 + 0.003);
                group.add(scoreLine);
              }
            }
          }

          // Add exposed mortar joint lines on front face for better visibility
          // Horizontal joints
          for (let row = 1; row < numCourses; row++) {
            const jointY = -h/2 + row * cmuHeight;
            if (jointY > h/2) continue;

            const hJoint = new THREE.Mesh(
              new THREE.BoxGeometry(w + 0.01, mortarJoint * 1.2, 0.01),
              mortarMat
            );
            hJoint.position.set(0, jointY, d/2 + 0.002);
            group.add(hJoint);
          }

          // Vertical joints (staggered for running bond)
          for (let row = 0; row < numCourses; row++) {
            const rowOffset = (row % 2) * (cmuWidth / 2);
            const jointY = -h/2 + cmuHeight/2 + row * cmuHeight;

            for (let col = 0; col <= blocksPerRow; col++) {
              const jointX = -w/2 + col * cmuWidth - rowOffset;

              // Skip joints outside wall bounds
              if (jointX < -w/2 || jointX > w/2) continue;

              const jointH = Math.min(cmuHeight - mortarJoint, (h/2 - (jointY - cmuHeight/2)) + cmuHeight);
              if (jointH < 0.1) continue;

              const vJoint = new THREE.Mesh(
                new THREE.BoxGeometry(mortarJoint * 1.2, jointH, 0.01),
                mortarMat
              );
              vJoint.position.set(jointX, jointY, d/2 + 0.002);
              group.add(vJoint);
            }
          }

          // Add end cap detail showing hollow cores (if wall depth allows)
          if (d >= 0.5) {
            const endCapMat = new THREE.MeshStandardMaterial({
              color: adjustColorBrightness(cmuBaseColor, -10),
              roughness: 0.9
            });

            // Left end cap with core holes
            const leftEndCap = new THREE.Mesh(
              new THREE.BoxGeometry(0.02, h, d - mortarJoint * 2),
              endCapMat
            );
            leftEndCap.position.set(-w/2 - 0.01, 0, 0);
            group.add(leftEndCap);

            // Right end cap
            const rightEndCap = new THREE.Mesh(
              new THREE.BoxGeometry(0.02, h, d - mortarJoint * 2),
              endCapMat
            );
            rightEndCap.position.set(w/2 + 0.01, 0, 0);
            group.add(rightEndCap);

            // Add hollow core indicators on ends (visible from side)
            const coreMat = new THREE.MeshStandardMaterial({
              color: 0x4a4a4a,
              roughness: 1
            });

            for (let row = 0; row < numCourses; row++) {
              const coreY = -h/2 + cmuHeight/2 + row * cmuHeight;
              if (coreY + cmuHeight/2 > h/2) continue;

              // Two cores per block (typical 2-core CMU)
              for (let coreOffset of [-0.18, 0.18]) {
                // Left side cores
                const leftCore = new THREE.Mesh(
                  new THREE.BoxGeometry(0.015, cmuHeight - 0.15, 0.25),
                  coreMat
                );
                leftCore.position.set(-w/2 - 0.005, coreY, coreOffset);
                group.add(leftCore);

                // Right side cores
                const rightCore = new THREE.Mesh(
                  new THREE.BoxGeometry(0.015, cmuHeight - 0.15, 0.25),
                  coreMat
                );
                rightCore.position.set(w/2 + 0.005, coreY, coreOffset);
                group.add(rightCore);
              }
            }
          }

          break;
        }

        // ===== STRUCTURAL ELEMENTS - BEAMS & COLUMNS =====
        case 'steel-beam': {
          // Steel I-Beam (Wide Flange)
          // Standard beam oriented horizontally, spanning across room
          const beamColor = el.color ? parseInt(el.color.replace('#', ''), 16) : 0x4A4A4A;
          const steelMat = new THREE.MeshStandardMaterial({
            color: beamColor,
            roughness: 0.4,
            metalness: 0.85
          });

          // I-beam dimensions (W8x31 typical)
          const flangeWidth = d;              // Flange width (depth in 2D)
          const webHeight = h * 0.7;          // Web height
          const flangeThickness = h * 0.15;   // Flange thickness
          const webThickness = 0.03;          // Web thickness (~3/8")

          // Top flange
          const topFlange = new THREE.Mesh(
            new THREE.BoxGeometry(w, flangeThickness, flangeWidth),
            steelMat
          );
          topFlange.position.y = h/2 - flangeThickness/2;
          topFlange.castShadow = true;
          group.add(topFlange);

          // Bottom flange
          const botFlange = new THREE.Mesh(
            new THREE.BoxGeometry(w, flangeThickness, flangeWidth),
            steelMat
          );
          botFlange.position.y = -h/2 + flangeThickness/2;
          botFlange.castShadow = true;
          group.add(botFlange);

          // Web (vertical center piece)
          const web = new THREE.Mesh(
            new THREE.BoxGeometry(w, webHeight, webThickness),
            steelMat
          );
          web.castShadow = true;
          group.add(web);

          // Edge highlights (subtle rust/weathering)
          const rustMat = new THREE.MeshStandardMaterial({
            color: 0x5C4033,
            roughness: 0.9,
            transparent: true,
            opacity: 0.2
          });
          const rustEdge = new THREE.Mesh(
            new THREE.BoxGeometry(w, 0.01, flangeWidth),
            rustMat
          );
          rustEdge.position.y = h/2 + 0.005;
          group.add(rustEdge);

          break;
        }

        case 'steel-column': {
          // Steel Box Column (HSS - Hollow Structural Section)
          const columnColor = el.color ? parseInt(el.color.replace('#', ''), 16) : 0x4A4A4A;
          const steelMat = new THREE.MeshStandardMaterial({
            color: columnColor,
            roughness: 0.4,
            metalness: 0.85
          });

          // Square HSS column
          const wallThickness = 0.02; // ~1/4" wall

          // Outer shell
          const outer = new THREE.Mesh(
            new THREE.BoxGeometry(w, h, d),
            steelMat
          );
          outer.castShadow = true;
          outer.receiveShadow = true;
          group.add(outer);

          // Hollow interior (dark)
          const innerMat = new THREE.MeshStandardMaterial({
            color: 0x1a1a1a,
            roughness: 0.9
          });

          // Top opening showing hollow
          const topHole = new THREE.Mesh(
            new THREE.BoxGeometry(w - wallThickness*4, 0.01, d - wallThickness*4),
            innerMat
          );
          topHole.position.y = h/2;
          group.add(topHole);

          // Base plate
          const basePlate = new THREE.Mesh(
            new THREE.BoxGeometry(w * 1.3, 0.04, d * 1.3),
            steelMat
          );
          basePlate.position.y = -h/2 - 0.02;
          basePlate.castShadow = true;
          group.add(basePlate);

          break;
        }

        case 'wood-beam': {
          // Solid Wood Beam (Glulam or Solid Timber)
          const woodColor = el.color ? parseInt(el.color.replace('#', ''), 16) : 0x8B6914;
          const woodMat = createTexturedMaterial(woodColor, textureUrl, {
            roughness: 0.7,
            metalness: 0
          });

          // Main beam body
          const beam = new THREE.Mesh(
            new THREE.BoxGeometry(w, h, d),
            woodMat
          );
          beam.castShadow = true;
          beam.receiveShadow = true;
          group.add(beam);

          // Wood grain lines (darker grooves)
          const grainMat = new THREE.MeshStandardMaterial({
            color: adjustColorBrightness(woodColor, -30),
            roughness: 0.9
          });

          // Horizontal grain lines on bottom face
          const grainSpacing = 0.15;
          for (let gz = -d/2 + grainSpacing; gz < d/2; gz += grainSpacing + Math.random() * 0.1) {
            const grain = new THREE.Mesh(
              new THREE.BoxGeometry(w - 0.05, 0.005, 0.008),
              grainMat
            );
            grain.position.set(0, -h/2 - 0.002, gz);
            group.add(grain);
          }

          // End grain (visible at beam ends)
          const endGrainMat = new THREE.MeshStandardMaterial({
            color: adjustColorBrightness(woodColor, 10),
            roughness: 0.6
          });

          // Left end
          const leftEnd = new THREE.Mesh(
            new THREE.BoxGeometry(0.01, h - 0.02, d - 0.02),
            endGrainMat
          );
          leftEnd.position.x = -w/2 - 0.005;
          group.add(leftEnd);

          // Right end
          const rightEnd = new THREE.Mesh(
            new THREE.BoxGeometry(0.01, h - 0.02, d - 0.02),
            endGrainMat
          );
          rightEnd.position.x = w/2 + 0.005;
          group.add(rightEnd);

          break;
        }

        case 'wood-post': {
          // Wood Post (4x4, 6x6)
          const woodColor = el.color ? parseInt(el.color.replace('#', ''), 16) : 0x8B6914;
          const woodMat = createTexturedMaterial(woodColor, textureUrl, {
            roughness: 0.7,
            metalness: 0
          });

          // Main post body
          const post = new THREE.Mesh(
            new THREE.BoxGeometry(w, h, d),
            woodMat
          );
          post.castShadow = true;
          post.receiveShadow = true;
          group.add(post);

          // Vertical grain lines
          const grainMat = new THREE.MeshStandardMaterial({
            color: adjustColorBrightness(woodColor, -25),
            roughness: 0.9
          });

          for (let side = 0; side < 4; side++) {
            const rotation = side * Math.PI / 2;
            const offsetX = side === 1 ? w/2 + 0.002 : (side === 3 ? -w/2 - 0.002 : 0);
            const offsetZ = side === 0 ? d/2 + 0.002 : (side === 2 ? -d/2 - 0.002 : 0);

            for (let i = 0; i < 3; i++) {
              const grain = new THREE.Mesh(
                new THREE.BoxGeometry(0.005, h - 0.1, 0.005),
                grainMat
              );
              const offset = (i - 1) * (side % 2 === 0 ? w : d) * 0.25;
              grain.position.set(
                offsetX + (side % 2 === 0 ? offset : 0),
                0,
                offsetZ + (side % 2 === 1 ? offset : 0)
              );
              group.add(grain);
            }
          }

          break;
        }

        case 'concrete-beam': {
          // Reinforced Concrete Beam
          const concreteColor = el.color ? parseInt(el.color.replace('#', ''), 16) : 0x707070;
          const concreteMat = new THREE.MeshStandardMaterial({
            color: concreteColor,
            roughness: 0.9,
            metalness: 0.02
          });

          // Main beam body
          const beam = new THREE.Mesh(
            new THREE.BoxGeometry(w, h, d),
            concreteMat
          );
          beam.castShadow = true;
          beam.receiveShadow = true;
          group.add(beam);

          // Form lines (horizontal pour joints)
          const formMat = new THREE.MeshStandardMaterial({
            color: adjustColorBrightness(concreteColor, -15),
            roughness: 0.95
          });

          const formLine = new THREE.Mesh(
            new THREE.BoxGeometry(w + 0.01, 0.01, d + 0.01),
            formMat
          );
          formLine.position.y = 0;
          group.add(formLine);

          // Aggregate texture spots
          const spotMat = new THREE.MeshStandardMaterial({
            color: adjustColorBrightness(concreteColor, -10),
            roughness: 1
          });

          for (let i = 0; i < Math.min(w * 8, 20); i++) {
            const spotX = (Math.random() - 0.5) * w * 0.9;
            const spotY = (Math.random() - 0.5) * h * 0.8;
            const spot = new THREE.Mesh(
              new THREE.SphereGeometry(0.015 + Math.random() * 0.01, 6, 6),
              spotMat
            );
            spot.position.set(spotX, spotY, d/2 + 0.005);
            group.add(spot);
          }

          break;
        }

        case 'concrete-column': {
          // Reinforced Concrete Column
          const concreteColor = el.color ? parseInt(el.color.replace('#', ''), 16) : 0x707070;
          const concreteMat = new THREE.MeshStandardMaterial({
            color: concreteColor,
            roughness: 0.9,
            metalness: 0.02
          });

          // Square or rectangular column
          const column = new THREE.Mesh(
            new THREE.BoxGeometry(w, h, d),
            concreteMat
          );
          column.castShadow = true;
          column.receiveShadow = true;
          group.add(column);

          // Chamfered edges (typical on concrete columns)
          const chamferMat = new THREE.MeshStandardMaterial({
            color: adjustColorBrightness(concreteColor, -10),
            roughness: 0.85
          });

          const chamferSize = 0.02;
          const edges = [
            { pos: [-w/2, 0, -d/2], rot: [0, Math.PI/4, 0] },
            { pos: [w/2, 0, -d/2], rot: [0, -Math.PI/4, 0] },
            { pos: [-w/2, 0, d/2], rot: [0, -Math.PI/4, 0] },
            { pos: [w/2, 0, d/2], rot: [0, Math.PI/4, 0] }
          ];

          edges.forEach(edge => {
            const chamfer = new THREE.Mesh(
              new THREE.BoxGeometry(chamferSize, h - 0.1, chamferSize),
              chamferMat
            );
            chamfer.position.set(...edge.pos);
            chamfer.rotation.set(...edge.rot);
            group.add(chamfer);
          });

          break;
        }

        case 'header':
        case 'lvl-beam': {
          // Header/Lintel or LVL (Laminated Veneer Lumber) Beam
          const isLVL = el.type === 'lvl-beam';
          const woodColor = el.color ? parseInt(el.color.replace('#', ''), 16) : (isLVL ? 0xDEB887 : 0xCD853F);
          const woodMat = createTexturedMaterial(woodColor, textureUrl, {
            roughness: 0.65,
            metalness: 0
          });

          // Main beam body
          const beam = new THREE.Mesh(
            new THREE.BoxGeometry(w, h, d),
            woodMat
          );
          beam.castShadow = true;
          beam.receiveShadow = true;
          group.add(beam);

          if (isLVL) {
            // LVL lamination lines (horizontal layers)
            const lamMat = new THREE.MeshStandardMaterial({
              color: adjustColorBrightness(woodColor, -20),
              roughness: 0.8
            });

            const layerHeight = 0.06; // ~3/4" layers
            for (let ly = -h/2 + layerHeight; ly < h/2; ly += layerHeight) {
              const lamLine = new THREE.Mesh(
                new THREE.BoxGeometry(w + 0.01, 0.005, d + 0.01),
                lamMat
              );
              lamLine.position.y = ly;
              group.add(lamLine);
            }
          } else {
            // Regular header - single piece with grain
            const grainMat = new THREE.MeshStandardMaterial({
              color: adjustColorBrightness(woodColor, -25),
              roughness: 0.9
            });

            // Horizontal grain line
            const grain = new THREE.Mesh(
              new THREE.BoxGeometry(w - 0.05, 0.01, 0.005),
              grainMat
            );
            grain.position.set(0, 0, d/2 + 0.002);
            group.add(grain);
          }

          // End grain
          const endMat = new THREE.MeshStandardMaterial({
            color: adjustColorBrightness(woodColor, 15),
            roughness: 0.55
          });

          const leftEnd = new THREE.Mesh(
            new THREE.BoxGeometry(0.01, h - 0.02, d - 0.02),
            endMat
          );
          leftEnd.position.x = -w/2 - 0.005;
          group.add(leftEnd);

          const rightEnd = new THREE.Mesh(
            new THREE.BoxGeometry(0.01, h - 0.02, d - 0.02),
            endMat
          );
          rightEnd.position.x = w/2 + 0.005;
          group.add(rightEnd);

          break;
        }

        // ===== PONY WALLS & HALF WALLS =====
        case 'pony-wall':
        case 'pony-wall-bar':
        case 'knee-wall': {
          // Half-height wall with proper framing construction
          // Shows: drywall both sides, visible studs at ends, top/bottom plates
          const ponyHeight = el.wallHeight || (el.type === 'knee-wall' ? 2.5 : 3.5);
          const ponyDepth = d || 0.5;
          const isBarHeight = el.type === 'pony-wall-bar';
          const baseY = -h / 2;

          // Construction dimensions (standard framing)
          const studWidth = 0.125; // 1.5" stud face
          const studDepth = ponyDepth - 0.08; // Stud depth (leave room for drywall both sides)
          const plateHeight = 0.125; // 1.5" plate thickness
          const drywallThickness = 0.04; // ~1/2" drywall

          // Materials - use applied color if a material is set, otherwise default drywall
          const hasAppliedMaterial = textureUrl || el.materialId;
          const drywallColor = hasAppliedMaterial ? color : (el.materialColor || 0xF5F5F0);
          const drywallMat = createTexturedMaterial(drywallColor, textureUrl, {
            roughness: hasAppliedMaterial ? 0.35 : 0.85
          });
          const drywallTopMat = new THREE.MeshStandardMaterial({
            color: 0xE0E0E0,
            roughness: 0.9
          });
          const studMat = new THREE.MeshStandardMaterial({
            color: 0xD4B896, // Wood color
            roughness: 0.75
          });
          const cornerBeadMat = new THREE.MeshStandardMaterial({
            color: 0xDDDDDD,
            roughness: 0.6,
            metalness: 0.1
          });

          // === FRAMING (visible at ends) ===
          // Bottom plate (sole plate)
          const bottomPlate = new THREE.Mesh(
            new THREE.BoxGeometry(w, plateHeight, studDepth),
            studMat
          );
          bottomPlate.position.set(0, baseY + plateHeight/2, 0);
          group.add(bottomPlate);

          // Top plate (double top plate is standard)
          const topPlate1 = new THREE.Mesh(
            new THREE.BoxGeometry(w, plateHeight, studDepth),
            studMat
          );
          topPlate1.position.set(0, baseY + ponyHeight - plateHeight * 1.5, 0);
          group.add(topPlate1);

          const topPlate2 = new THREE.Mesh(
            new THREE.BoxGeometry(w, plateHeight, studDepth),
            studMat
          );
          topPlate2.position.set(0, baseY + ponyHeight - plateHeight * 0.5, 0);
          group.add(topPlate2);

          // End studs (king studs at each end - visible from the side)
          const studHeight = ponyHeight - plateHeight * 3;
          [-1, 1].forEach(side => {
            const endStud = new THREE.Mesh(
              new THREE.BoxGeometry(studWidth, studHeight, studDepth),
              studMat
            );
            endStud.position.set(
              side * (w/2 - studWidth/2),
              baseY + plateHeight + studHeight/2,
              0
            );
            group.add(endStud);
          });

          // Interior studs (at 16" on center, partially visible through drywall texture)
          const studSpacing = 1.33; // 16" OC
          const numStuds = Math.floor((w - studWidth * 2) / studSpacing);
          for (let s = 1; s <= numStuds; s++) {
            const studX = -w/2 + studWidth + s * studSpacing;
            if (studX < w/2 - studWidth) {
              const interiorStud = new THREE.Mesh(
                new THREE.BoxGeometry(studWidth, studHeight, studDepth),
                studMat
              );
              interiorStud.position.set(studX, baseY + plateHeight + studHeight/2, 0);
              group.add(interiorStud);
            }
          }

          // === DRYWALL SHEATHING ===
          // Front drywall panel
          const frontDrywall = new THREE.Mesh(
            new THREE.BoxGeometry(w, ponyHeight - plateHeight, drywallThickness),
            drywallMat
          );
          frontDrywall.position.set(0, baseY + plateHeight + (ponyHeight - plateHeight)/2, ponyDepth/2 - drywallThickness/2);
          frontDrywall.castShadow = true;
          frontDrywall.receiveShadow = true;
          group.add(frontDrywall);

          // Back drywall panel
          const backDrywall = new THREE.Mesh(
            new THREE.BoxGeometry(w, ponyHeight - plateHeight, drywallThickness),
            drywallMat
          );
          backDrywall.position.set(0, baseY + plateHeight + (ponyHeight - plateHeight)/2, -ponyDepth/2 + drywallThickness/2);
          backDrywall.castShadow = true;
          backDrywall.receiveShadow = true;
          group.add(backDrywall);

          // === TOP SURFACE / CAP ===
          // If a countertop material is applied, show a proper stone cap
          // Otherwise show drywall finish ready for a separate cap element
          if (textureUrl || el.storeProduct || el.materialId) {
            // Stone cap with applied material
            const capThickness = el.capThickness || 0.1; // 1.25" default
            const capOverhang = 0.08; // 1" overhang on each side
            const capMat = createTexturedMaterial(color, textureUrl, {
              roughness: 0.35,
              metalness: 0.02,
              finish: el.finish || 'polished'
            });

            // Main cap surface
            const stoneCap = new THREE.Mesh(
              new THREE.BoxGeometry(w + capOverhang * 2, capThickness, ponyDepth + capOverhang * 2),
              capMat
            );
            stoneCap.position.set(0, baseY + ponyHeight + capThickness / 2, 0);
            stoneCap.castShadow = true;
            stoneCap.receiveShadow = true;
            group.add(stoneCap);

            // Front edge detail (slight lip/drip edge)
            const edgeMat = new THREE.MeshStandardMaterial({
              color: adjustColorBrightness(color, -20),
              roughness: 0.5
            });
            const frontEdge = new THREE.Mesh(
              new THREE.BoxGeometry(w + capOverhang * 2, 0.02, 0.02),
              edgeMat
            );
            frontEdge.position.set(0, baseY + ponyHeight + capThickness - 0.01, ponyDepth / 2 + capOverhang);
            group.add(frontEdge);
          } else {
            // Plain drywall top (no material applied yet)
            const topSurface = new THREE.Mesh(
              new THREE.BoxGeometry(w, 0.02, ponyDepth),
              drywallTopMat
            );
            topSurface.position.set(0, baseY + ponyHeight, 0);
            topSurface.receiveShadow = true;
            group.add(topSurface);
          }

          // === CORNER BEADS (metal edges at corners) ===
          const beadSize = 0.02;
          // Top front corner bead
          const topFrontBead = new THREE.Mesh(
            new THREE.BoxGeometry(w, beadSize, beadSize),
            cornerBeadMat
          );
          topFrontBead.position.set(0, baseY + ponyHeight - beadSize/2, ponyDepth/2 - beadSize/2);
          group.add(topFrontBead);

          // Top back corner bead
          const topBackBead = new THREE.Mesh(
            new THREE.BoxGeometry(w, beadSize, beadSize),
            cornerBeadMat
          );
          topBackBead.position.set(0, baseY + ponyHeight - beadSize/2, -ponyDepth/2 + beadSize/2);
          group.add(topBackBead);

          // Vertical corner beads at ends
          [-1, 1].forEach(side => {
            // Front vertical
            const frontVertBead = new THREE.Mesh(
              new THREE.BoxGeometry(beadSize, ponyHeight - plateHeight, beadSize),
              cornerBeadMat
            );
            frontVertBead.position.set(
              side * (w/2 - beadSize/2),
              baseY + plateHeight + (ponyHeight - plateHeight)/2,
              ponyDepth/2 - beadSize/2
            );
            group.add(frontVertBead);

            // Back vertical
            const backVertBead = new THREE.Mesh(
              new THREE.BoxGeometry(beadSize, ponyHeight - plateHeight, beadSize),
              cornerBeadMat
            );
            backVertBead.position.set(
              side * (w/2 - beadSize/2),
              baseY + plateHeight + (ponyHeight - plateHeight)/2,
              -ponyDepth/2 + beadSize/2
            );
            group.add(backVertBead);
          });

          // === END CAPS (close off the stud cavity at ends) ===
          [-1, 1].forEach(side => {
            const endCap = new THREE.Mesh(
              new THREE.BoxGeometry(drywallThickness, ponyHeight - plateHeight, ponyDepth - drywallThickness * 2),
              drywallMat
            );
            endCap.position.set(
              side * (w/2 + drywallThickness/2),
              baseY + plateHeight + (ponyHeight - plateHeight)/2,
              0
            );
            endCap.castShadow = true;
            group.add(endCap);
          });

          // === BASEBOARD (optional, at floor level) ===
          const baseboardMat = new THREE.MeshStandardMaterial({
            color: 0xFFFFFF,
            roughness: 0.5
          });
          const baseboardHeight = 0.25; // 3" baseboard
          // Front baseboard
          const frontBaseboard = new THREE.Mesh(
            new THREE.BoxGeometry(w + 0.02, baseboardHeight, 0.03),
            baseboardMat
          );
          frontBaseboard.position.set(0, baseY + baseboardHeight/2, ponyDepth/2 + 0.015);
          group.add(frontBaseboard);

          // Back baseboard
          const backBaseboard = new THREE.Mesh(
            new THREE.BoxGeometry(w + 0.02, baseboardHeight, 0.03),
            baseboardMat
          );
          backBaseboard.position.set(0, baseY + baseboardHeight/2, -ponyDepth/2 - 0.015);
          group.add(backBaseboard);

          break;
        }

        // ===== WALL NICHES & RECESSES =====
        case 'wall-niche':
        case 'fireplace-niche':
        case 'tv-niche':
        case 'shower-niche': {
          // Simple recessed niche - dark opening with depth
          const nicheDepth = el.nicheDepth || 0.5; // 6" default recess
          const isFireplace = el.type === 'fireplace-niche';
          const isTV = el.type === 'tv-niche';
          const isShower = el.type === 'shower-niche';

          // Interior colors - brighter to reflect interior lighting
          // TV niches stay dark for screen visibility, others are lighter
          const interiorColor = isFireplace ? 0x2A2A2A : (isTV ? 0x0A0A0A : (isShower ? 0x6A6A70 : 0x5A5A65));

          // Materials with better light reflection for interior illumination
          const interiorMat = new THREE.MeshStandardMaterial({
            color: interiorColor,
            roughness: isTV ? 0.95 : 0.7, // Less rough = better light reflection
            side: THREE.DoubleSide
          });
          const sideMat = new THREE.MeshStandardMaterial({
            color: adjustColorBrightness(interiorColor, 30),
            roughness: isTV ? 0.9 : 0.65,
            side: THREE.DoubleSide
          });

          // === RECESSED BOX INTERIOR ===
          // Back wall (the dark back of the niche)
          const backWall = new THREE.Mesh(
            new THREE.PlaneGeometry(w, h),
            interiorMat
          );
          backWall.position.set(0, 0, -nicheDepth);
          group.add(backWall);

          // Left side wall
          const leftWall = new THREE.Mesh(
            new THREE.PlaneGeometry(nicheDepth, h),
            sideMat
          );
          leftWall.rotation.y = Math.PI / 2;
          leftWall.position.set(-w/2, 0, -nicheDepth/2);
          group.add(leftWall);

          // Right side wall
          const rightWall = new THREE.Mesh(
            new THREE.PlaneGeometry(nicheDepth, h),
            sideMat
          );
          rightWall.rotation.y = -Math.PI / 2;
          rightWall.position.set(w/2, 0, -nicheDepth/2);
          group.add(rightWall);

          // Top wall (ceiling of niche)
          const topWall = new THREE.Mesh(
            new THREE.PlaneGeometry(w, nicheDepth),
            sideMat
          );
          topWall.rotation.x = Math.PI / 2;
          topWall.position.set(0, h/2, -nicheDepth/2);
          group.add(topWall);

          // Bottom wall (floor of niche)
          const bottomWall = new THREE.Mesh(
            new THREE.PlaneGeometry(w, nicheDepth),
            sideMat
          );
          bottomWall.rotation.x = -Math.PI / 2;
          bottomWall.position.set(0, -h/2, -nicheDepth/2);
          group.add(bottomWall);

          // === SIMPLE TRIM FRAME ===
          const trimWidth = 0.06;
          const trimDepth = 0.03;
          const trimMat = new THREE.MeshStandardMaterial({
            color: 0xF0F0F0,
            roughness: 0.4
          });

          // Top trim
          const topTrim = new THREE.Mesh(
            new THREE.BoxGeometry(w + trimWidth * 2, trimWidth, trimDepth),
            trimMat
          );
          topTrim.position.set(0, h/2 + trimWidth/2, trimDepth/2);
          group.add(topTrim);

          // Bottom trim
          const bottomTrim = new THREE.Mesh(
            new THREE.BoxGeometry(w + trimWidth * 2, trimWidth, trimDepth),
            trimMat
          );
          bottomTrim.position.set(0, -h/2 - trimWidth/2, trimDepth/2);
          group.add(bottomTrim);

          // Left trim
          const leftTrim = new THREE.Mesh(
            new THREE.BoxGeometry(trimWidth, h, trimDepth),
            trimMat
          );
          leftTrim.position.set(-w/2 - trimWidth/2, 0, trimDepth/2);
          group.add(leftTrim);

          // Right trim
          const rightTrim = new THREE.Mesh(
            new THREE.BoxGeometry(trimWidth, h, trimDepth),
            trimMat
          );
          rightTrim.position.set(w/2 + trimWidth/2, 0, trimDepth/2);
          group.add(rightTrim);

          // === TYPE-SPECIFIC SIMPLE ADDITIONS ===
          if (isFireplace) {
            // Fire glow at bottom
            const fireMat = new THREE.MeshBasicMaterial({
              color: 0xFF4500,
              transparent: true,
              opacity: 0.7
            });
            const fire = new THREE.Mesh(
              new THREE.SphereGeometry(0.2, 8, 8),
              fireMat
            );
            fire.scale.set(2, 0.8, 0.5);
            fire.position.set(0, -h/2 + 0.2, -nicheDepth * 0.6);
            group.add(fire);

          } else if (isTV) {
            // TV screen rectangle
            const screenMat = new THREE.MeshStandardMaterial({
              color: 0x050505,
              roughness: 0.05,
              metalness: 0.3
            });
            const tvW = w * 0.85;
            const tvH = tvW * 0.5625; // 16:9
            const screen = new THREE.Mesh(
              new THREE.BoxGeometry(tvW, tvH, 0.03),
              screenMat
            );
            screen.position.set(0, 0, -nicheDepth/2);
            group.add(screen);

          } else if (isShower) {
            // Simple shelf
            const shelfMat = new THREE.MeshStandardMaterial({
              color: 0x808080,
              roughness: 0.3
            });
            const shelf = new THREE.Mesh(
              new THREE.BoxGeometry(w - 0.04, 0.02, nicheDepth - 0.04),
              shelfMat
            );
            shelf.position.set(0, 0, -nicheDepth/2);
            group.add(shelf);
          }

          // === STONE SURROUND WITH INTERIOR LEDGES (if applied) ===
          if (el.surroundColor || el.hasStoneSurround || el.texture || el.storeProduct) {
            // Get material texture if available
            const stoneTextureUrl = el.texture || el.storeProduct?.image || null;
            const stoneColor = el.surroundColor || el.color || 0x708090;

            const surroundMat = stoneTextureUrl
              ? createTexturedMaterial(stoneColor, stoneTextureUrl, { roughness: 0.35, metalness: 0.05 })
              : new THREE.MeshStandardMaterial({
                  color: stoneColor,
                  roughness: 0.35,
                  metalness: 0.05
                });

            const surrW = 0.12; // Frame width (~1.5")
            const surrD = el.stoneThickness || 0.1; // Frame depth/thickness
            const returnDepth = Math.min(nicheDepth * 0.4, 0.3); // How far stone goes INTO recess

            // === STONE FACE FRAME ===
            // Top stone piece
            const topSurr = new THREE.Mesh(
              new THREE.BoxGeometry(w + surrW * 2 + trimWidth * 2, surrW, surrD),
              surroundMat
            );
            topSurr.position.set(0, h/2 + trimWidth + surrW/2, surrD/2);
            topSurr.castShadow = true;
            group.add(topSurr);

            // Bottom stone piece (wider for hearth/sill effect)
            const botHeight = isFireplace ? surrW * 1.5 : surrW;
            const botSurr = new THREE.Mesh(
              new THREE.BoxGeometry(w + surrW * 2 + trimWidth * 2, botHeight, isFireplace ? surrD * 2 : surrD),
              surroundMat
            );
            botSurr.position.set(0, -h/2 - trimWidth - botHeight/2, isFireplace ? surrD : surrD/2);
            botSurr.castShadow = true;
            group.add(botSurr);

            // Side stone pieces
            [-1, 1].forEach(side => {
              const sideSurr = new THREE.Mesh(
                new THREE.BoxGeometry(surrW, h + trimWidth * 2, surrD),
                surroundMat
              );
              sideSurr.position.set(side * (w/2 + trimWidth + surrW/2), 0, surrD/2);
              sideSurr.castShadow = true;
              group.add(sideSurr);
            });

            // === STONE RETURNS/LEDGES INTO RECESS ===
            // These wrap around the inside of the opening to show stone depth

            // Top inside ledge (header return)
            const topLedge = new THREE.Mesh(
              new THREE.BoxGeometry(w, surrD * 0.6, returnDepth),
              surroundMat
            );
            topLedge.position.set(0, h/2 - surrD * 0.3, -returnDepth/2);
            topLedge.castShadow = true;
            topLedge.receiveShadow = true;
            group.add(topLedge);

            // Bottom sill (most visible ledge - like a window sill)
            const sillThickness = surrD * 0.8;
            const sillReturn = returnDepth * 1.2;
            const bottomSill = new THREE.Mesh(
              new THREE.BoxGeometry(w + 0.02, sillThickness, sillReturn),
              surroundMat
            );
            bottomSill.position.set(0, -h/2 + sillThickness/2, -sillReturn/2 + 0.01);
            bottomSill.castShadow = true;
            bottomSill.receiveShadow = true;
            group.add(bottomSill);

            // Left side return
            const leftReturn = new THREE.Mesh(
              new THREE.BoxGeometry(surrD * 0.5, h - sillThickness * 2, returnDepth),
              surroundMat
            );
            leftReturn.position.set(-w/2 + surrD * 0.25, 0, -returnDepth/2);
            leftReturn.castShadow = true;
            group.add(leftReturn);

            // Right side return
            const rightReturn = new THREE.Mesh(
              new THREE.BoxGeometry(surrD * 0.5, h - sillThickness * 2, returnDepth),
              surroundMat
            );
            rightReturn.position.set(w/2 - surrD * 0.25, 0, -returnDepth/2);
            rightReturn.castShadow = true;
            group.add(rightReturn);

            // === EDGE DETAIL (Bullnose on sill) ===
            const edgeProfile = el.edgeProfile || 'eased';
            if (edgeProfile !== 'square') {
              const edgeRadius = sillThickness * 0.3;
              const sillEdge = new THREE.Mesh(
                new THREE.CylinderGeometry(edgeRadius, edgeRadius, w, 8, 1, false, 0, Math.PI),
                surroundMat
              );
              sillEdge.rotation.x = Math.PI / 2;
              sillEdge.rotation.z = Math.PI / 2;
              sillEdge.position.set(0, -h/2 + sillThickness * 0.2, surrD * 0.35);
              group.add(sillEdge);
            }
          }

          // === INTERIOR LIGHTING ===
          // Add soft interior light to illuminate the niche (prevents dark void appearance)
          if (!isTV) { // TV niche should stay dark for screen visibility
            // LED strip light at top of niche
            const ledStripMat = new THREE.MeshBasicMaterial({
              color: isFireplace ? 0xFFE4B5 : 0xFFF8F0, // Warm white for fireplace, cool white for others
              transparent: true,
              opacity: 0.9
            });
            const ledStripW = w - 0.1;
            const ledStrip = new THREE.Mesh(
              new THREE.BoxGeometry(ledStripW, 0.01, 0.03),
              ledStripMat
            );
            ledStrip.position.set(0, h/2 - 0.02, -0.08);
            group.add(ledStrip);

            // Add point light for soft interior illumination
            const nicheLight = new THREE.PointLight(
              isFireplace ? 0xFFAA55 : 0xFFFFEE, // Warm glow for fireplace
              isFireplace ? 0.8 : 0.5, // Intensity
              Math.max(w, h) * 1.5, // Range based on niche size
              2 // Decay
            );
            nicheLight.position.set(0, h * 0.3, -nicheDepth * 0.3);
            group.add(nicheLight);

            // For shower niches, add a second light at bottom for shelf visibility
            if (isShower) {
              const shelfLight = new THREE.PointLight(0xFFFFFF, 0.3, 1, 2);
              shelfLight.position.set(0, -h * 0.2, -nicheDepth * 0.4);
              group.add(shelfLight);
            }
          }

          break;
        }

        // ===== ADA GRAB BARS =====
        case 'grab-bar':
        case 'grab-bar-24':
        case 'grab-bar-36':
        case 'grab-bar-42': {
          // ADA compliant grab bar (stainless steel look)
          const barLength = w;
          const barRadius = 0.0625; // 1.5" diameter (ADA spec: 1.25-2")

          // Bar material - brushed stainless steel
          const barMat = new THREE.MeshStandardMaterial({
            color: 0xC0C0C0,
            metalness: 0.8,
            roughness: 0.3
          });

          // Main bar tube
          const barGeo = new THREE.CylinderGeometry(barRadius, barRadius, barLength - 0.2, 16);
          barGeo.rotateZ(Math.PI / 2); // Rotate to horizontal
          const bar = new THREE.Mesh(barGeo, barMat);
          bar.castShadow = true;
          group.add(bar);

          // Mounting flanges (ends)
          const flangeMat = new THREE.MeshStandardMaterial({
            color: 0x888888,
            metalness: 0.6,
            roughness: 0.4
          });

          // Left flange
          const leftFlange = new THREE.Mesh(
            new THREE.CylinderGeometry(barRadius * 2, barRadius * 2, 0.05, 16),
            flangeMat
          );
          leftFlange.rotateZ(Math.PI / 2);
          leftFlange.position.set(-barLength / 2 + 0.05, 0, 0);
          group.add(leftFlange);

          // Right flange
          const rightFlange = new THREE.Mesh(
            new THREE.CylinderGeometry(barRadius * 2, barRadius * 2, 0.05, 16),
            flangeMat
          );
          rightFlange.rotateZ(Math.PI / 2);
          rightFlange.position.set(barLength / 2 - 0.05, 0, 0);
          group.add(rightFlange);

          // Mounting plates (against wall)
          const plateMat = new THREE.MeshStandardMaterial({
            color: 0x666666,
            metalness: 0.5,
            roughness: 0.5
          });

          const leftPlate = new THREE.Mesh(
            new THREE.BoxGeometry(0.15, 0.15, 0.02),
            plateMat
          );
          leftPlate.position.set(-barLength / 2 + 0.1, 0, -barRadius - 0.01);
          group.add(leftPlate);

          const rightPlate = new THREE.Mesh(
            new THREE.BoxGeometry(0.15, 0.15, 0.02),
            plateMat
          );
          rightPlate.position.set(barLength / 2 - 0.1, 0, -barRadius - 0.01);
          group.add(rightPlate);

          break;
        }

        case 'double-door': {
          // Double door with full frame
          const doorColor = el.color ? parseInt(el.color.replace('#', ''), 16) : 0xDEB887;
          const doorMat = new THREE.MeshStandardMaterial({ color: doorColor, roughness: 0.6 });
          const dblFrameMat = new THREE.MeshStandardMaterial({ color: 0xFFFFFF, roughness: 0.5 });
          const frameWidth = 0.08;
          const frameDepth = 0.18;
          const doorGap = 0.03; // Gap between doors
          const doorW = (w - doorGap) / 2 - frameWidth;

          // Left door panel
          const leftDoor = new THREE.Mesh(
            new THREE.BoxGeometry(doorW, h - frameWidth, 0.08),
            doorMat
          );
          leftDoor.position.set(-doorW / 2 - doorGap / 2, -frameWidth / 2, 0);
          leftDoor.castShadow = true;
          group.add(leftDoor);

          // Right door panel
          const rightDoor = new THREE.Mesh(
            new THREE.BoxGeometry(doorW, h - frameWidth, 0.08),
            doorMat
          );
          rightDoor.position.set(doorW / 2 + doorGap / 2, -frameWidth / 2, 0);
          rightDoor.castShadow = true;
          group.add(rightDoor);

          // Panel details on each door
          const panelMat = new THREE.MeshStandardMaterial({
            color: adjustColorBrightness(doorColor, -20),
            roughness: 0.5
          });
          [-1, 1].forEach(side => {
            const panelTop = new THREE.Mesh(
              new THREE.BoxGeometry(doorW * 0.7, h * 0.3, 0.02),
              panelMat
            );
            panelTop.position.set(side * (doorW / 2 + doorGap / 2), h * 0.15, 0.05);
            group.add(panelTop);

            const panelBottom = new THREE.Mesh(
              new THREE.BoxGeometry(doorW * 0.7, h * 0.3, 0.02),
              panelMat
            );
            panelBottom.position.set(side * (doorW / 2 + doorGap / 2), -h * 0.25, 0.05);
            group.add(panelBottom);
          });

          // Frame - top
          const topFrame = new THREE.Mesh(
            new THREE.BoxGeometry(w + frameWidth * 2, frameWidth, frameDepth),
            dblFrameMat
          );
          topFrame.position.set(0, h / 2, 0);
          group.add(topFrame);

          // Frame - left
          const leftFrame = new THREE.Mesh(
            new THREE.BoxGeometry(frameWidth, h, frameDepth),
            dblFrameMat
          );
          leftFrame.position.set(-w / 2 - frameWidth / 2, 0, 0);
          group.add(leftFrame);

          // Frame - right
          const rightFrame = new THREE.Mesh(
            new THREE.BoxGeometry(frameWidth, h, frameDepth),
            dblFrameMat
          );
          rightFrame.position.set(w / 2 + frameWidth / 2, 0, 0);
          group.add(rightFrame);

          // Handles (lever style)
          const handleMat = new THREE.MeshStandardMaterial({
            color: 0xC0C0C0,
            metalness: 0.8,
            roughness: 0.2
          });

          // Left door handle
          const leftHandlePlate = new THREE.Mesh(
            new THREE.BoxGeometry(0.05, 0.12, 0.02),
            handleMat
          );
          leftHandlePlate.position.set(-doorGap / 2 - 0.08, 0, 0.06);
          group.add(leftHandlePlate);

          const leftLever = new THREE.Mesh(
            new THREE.BoxGeometry(0.1, 0.025, 0.025),
            handleMat
          );
          leftLever.position.set(-doorGap / 2 - 0.12, 0, 0.08);
          group.add(leftLever);

          // Right door handle
          const rightHandlePlate = new THREE.Mesh(
            new THREE.BoxGeometry(0.05, 0.12, 0.02),
            handleMat
          );
          rightHandlePlate.position.set(doorGap / 2 + 0.08, 0, 0.06);
          group.add(rightHandlePlate);

          const rightLever = new THREE.Mesh(
            new THREE.BoxGeometry(0.1, 0.025, 0.025),
            handleMat
          );
          rightLever.position.set(doorGap / 2 + 0.12, 0, 0.08);
          group.add(rightLever);

          break;
        }

        case 'sliding-door':
        case 'glass-door':
        case 'french-door': {
          // Professional door variants with proper architectural details
          const isSliding = el.type === 'sliding-door';
          const isFrench = el.type === 'french-door';

          // Materials based on door type
          const frameColor = isSliding ? 0x8A8A8A : (isFrench ? 0xF5F0E6 : 0xFFFFFF);
          const frameMat = new THREE.MeshStandardMaterial({
            color: frameColor,
            roughness: isSliding ? 0.3 : 0.45,
            metalness: isSliding ? 0.6 : 0.1
          });
          const hardwareMat = new THREE.MeshStandardMaterial({
            color: 0xC0C0C0,
            roughness: 0.15,
            metalness: 0.9
          });
          const rubberMat = new THREE.MeshStandardMaterial({
            color: 0x1a1a1a,
            roughness: 0.9
          });

          // Frame dimensions (construction standard)
          const frameDepth = 0.30; // ~3.6" frame depth (wall thickness)
          const frameWidth = isSliding ? 0.12 : 0.17; // Frame profile: sliding 1.5", french/glass 2"

          // Outdoor palette
          const outdoorPalette = OUTDOOR_COLORS[sceneSettings.timeOfDay] || OUTDOOR_COLORS.noon;

          // === OUTDOOR VIEW (behind door) ===
          const skyMat = new THREE.MeshBasicMaterial({ color: outdoorPalette.sky, side: THREE.DoubleSide });
          const skyPane = new THREE.Mesh(
            new THREE.PlaneGeometry(w - frameWidth * 2 - 0.1, h - frameWidth * 2),
            skyMat
          );
          skyPane.position.z = -frameDepth/2 + 0.01;
          group.add(skyPane);

          const horizonMat = new THREE.MeshBasicMaterial({ color: outdoorPalette.horizon });
          const horizonPane = new THREE.Mesh(
            new THREE.PlaneGeometry(w - frameWidth * 2 - 0.1, h * 0.35),
            horizonMat
          );
          horizonPane.position.set(0, -h * 0.32, -frameDepth/2 + 0.015);
          group.add(horizonPane);

          if (sceneSettings.timeOfDay !== 'night') {
            const treeMat = new THREE.MeshBasicMaterial({ color: 0x228B22 });
            for (let i = 0; i < 4; i++) {
              const treeH = 0.4 + Math.random() * 0.25;
              const tree = new THREE.Mesh(new THREE.ConeGeometry(treeH * 0.4, treeH, 6), treeMat);
              tree.position.set((i - 1.5) * w * 0.25, -h * 0.15 + Math.random() * 0.1, -frameDepth/2 + 0.02);
              group.add(tree);
            }
          } else {
            const starMat = new THREE.MeshBasicMaterial({ color: 0xFFFFFF });
            for (let i = 0; i < 12; i++) {
              const star = new THREE.Mesh(new THREE.SphereGeometry(0.015, 4, 4), starMat);
              star.position.set(
                (Math.random() - 0.5) * (w - 0.3),
                h * 0.1 + Math.random() * h * 0.35,
                -frameDepth/2 + 0.02
              );
              group.add(star);
            }
            const moonMat = new THREE.MeshBasicMaterial({ color: 0xFFFACD });
            const moon = new THREE.Mesh(new THREE.CircleGeometry(0.1, 16), moonMat);
            moon.position.set(w * 0.3, h * 0.3, -frameDepth/2 + 0.02);
            group.add(moon);
          }

          // Glass material
          const glassColor = sceneSettings.timeOfDay === 'night' ? 0x2a3a5a : 0xADD8E6;
          const glassMat = new THREE.MeshStandardMaterial({
            color: glassColor,
            transparent: true,
            opacity: 0.15,
            roughness: 0.02,
            metalness: 0.3
          });

          if (isSliding) {
            // === SLIDING PATIO DOOR ===
            // Aluminum frame system with tracks

            // Main frame (jambs, head, sill)
            // Head
            const head = new THREE.Mesh(
              new THREE.BoxGeometry(w, frameWidth, frameDepth),
              frameMat
            );
            head.position.set(0, h/2 - frameWidth/2, 0);
            head.castShadow = true;
            group.add(head);

            // Side jambs
            [-1, 1].forEach(side => {
              const jamb = new THREE.Mesh(
                new THREE.BoxGeometry(frameWidth, h - frameWidth, frameDepth),
                frameMat
              );
              jamb.position.set(side * (w/2 - frameWidth/2), -frameWidth/2, 0);
              jamb.castShadow = true;
              group.add(jamb);
            });

            // Sill/track assembly
            const sillMat = new THREE.MeshStandardMaterial({ color: 0x666666, roughness: 0.4, metalness: 0.5 });
            const sill = new THREE.Mesh(
              new THREE.BoxGeometry(w, 0.06, frameDepth + 0.1),
              sillMat
            );
            sill.position.set(0, -h/2 + 0.03, 0.05);
            group.add(sill);

            // Track channels in sill
            [-1, 1].forEach((track, idx) => {
              const trackChannel = new THREE.Mesh(
                new THREE.BoxGeometry(w - frameWidth * 2, 0.015, 0.025),
                new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.5 })
              );
              trackChannel.position.set(0, -h/2 + 0.045, track * 0.025);
              group.add(trackChannel);
            });

            // Panel dimensions
            const panelW = (w - frameWidth * 2) / 2 + 0.02;
            const panelH = h - frameWidth - 0.06;
            const stileWidth = 0.05; // Vertical frame members
            const railHeight = 0.06; // Horizontal frame members

            // Fixed panel (left/exterior)
            const fixedPanelGroup = new THREE.Group();

            // Stiles (vertical members)
            [-1, 1].forEach(side => {
              const stile = new THREE.Mesh(
                new THREE.BoxGeometry(stileWidth, panelH, 0.04),
                frameMat
              );
              stile.position.set(side * (panelW/2 - stileWidth/2), 0, 0);
              fixedPanelGroup.add(stile);
            });

            // Rails (horizontal members)
            [-1, 1].forEach(pos => {
              const rail = new THREE.Mesh(
                new THREE.BoxGeometry(panelW, railHeight, 0.04),
                frameMat
              );
              rail.position.set(0, pos * (panelH/2 - railHeight/2), 0);
              fixedPanelGroup.add(rail);
            });

            // Glass
            const fixedGlass = new THREE.Mesh(
              new THREE.PlaneGeometry(panelW - stileWidth * 2 - 0.02, panelH - railHeight * 2 - 0.02),
              glassMat
            );
            fixedGlass.position.z = 0.01;
            fixedPanelGroup.add(fixedGlass);

            fixedPanelGroup.position.set(-panelW/2 + 0.01, -frameWidth/2 - 0.03 + panelH/2, -0.025);
            group.add(fixedPanelGroup);

            // Sliding panel (right/interior) - slightly in front
            const slidePanelGroup = new THREE.Group();

            [-1, 1].forEach(side => {
              const stile = new THREE.Mesh(
                new THREE.BoxGeometry(stileWidth, panelH, 0.04),
                frameMat
              );
              stile.position.set(side * (panelW/2 - stileWidth/2), 0, 0);
              slidePanelGroup.add(stile);
            });

            [-1, 1].forEach(pos => {
              const rail = new THREE.Mesh(
                new THREE.BoxGeometry(panelW, railHeight, 0.04),
                frameMat
              );
              rail.position.set(0, pos * (panelH/2 - railHeight/2), 0);
              slidePanelGroup.add(rail);
            });

            const slideGlass = new THREE.Mesh(
              new THREE.PlaneGeometry(panelW - stileWidth * 2 - 0.02, panelH - railHeight * 2 - 0.02),
              glassMat
            );
            slideGlass.position.z = 0.01;
            slidePanelGroup.add(slideGlass);

            // Handle on sliding panel
            const handlePlate = new THREE.Mesh(
              new THREE.BoxGeometry(0.025, 0.2, 0.015),
              hardwareMat
            );
            handlePlate.position.set(-panelW/2 + stileWidth + 0.03, 0, 0.03);
            slidePanelGroup.add(handlePlate);

            const handleGrip = new THREE.Mesh(
              new THREE.BoxGeometry(0.02, 0.12, 0.025),
              hardwareMat
            );
            handleGrip.position.set(-panelW/2 + stileWidth + 0.045, 0, 0.04);
            slidePanelGroup.add(handleGrip);

            // Rollers (visible at bottom)
            [-0.15, 0.15].forEach(rx => {
              const roller = new THREE.Mesh(
                new THREE.CylinderGeometry(0.015, 0.015, 0.02, 12),
                new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.6 })
              );
              roller.rotation.x = Math.PI / 2;
              roller.position.set(rx * panelW, -panelH/2 + 0.01, 0.02);
              slidePanelGroup.add(roller);
            });

            slidePanelGroup.position.set(panelW/2 - 0.01, -frameWidth/2 - 0.03 + panelH/2, 0.025);
            group.add(slidePanelGroup);

            // Interlock (where panels meet)
            const interlock = new THREE.Mesh(
              new THREE.BoxGeometry(0.02, panelH - 0.1, 0.06),
              frameMat
            );
            interlock.position.set(0, -frameWidth/2 - 0.03 + panelH/2, 0);
            group.add(interlock);

            // Weather stripping
            const weatherStrip = new THREE.Mesh(
              new THREE.BoxGeometry(0.01, panelH, 0.02),
              rubberMat
            );
            weatherStrip.position.set(-w/2 + frameWidth + 0.005, -frameWidth/2 - 0.03 + panelH/2, 0);
            group.add(weatherStrip);

          } else if (isFrench) {
            // === FRENCH DOORS (Double doors with true divided lites) ===
            const doorColor = el.color ? parseInt(el.color.replace('#', ''), 16) : 0xF5F0E6;
            const doorMat = new THREE.MeshStandardMaterial({
              color: doorColor,
              roughness: 0.5
            });

            // Frame (jambs, head)
            const head = new THREE.Mesh(
              new THREE.BoxGeometry(w + 0.05, frameWidth, frameDepth),
              frameMat
            );
            head.position.set(0, h/2 - frameWidth/2, 0);
            head.castShadow = true;
            group.add(head);

            [-1, 1].forEach(side => {
              const jamb = new THREE.Mesh(
                new THREE.BoxGeometry(frameWidth, h, frameDepth),
                frameMat
              );
              jamb.position.set(side * (w/2 + frameWidth/2 - 0.025), 0, 0);
              jamb.castShadow = true;
              group.add(jamb);
            });

            // Threshold
            const thresholdMat = new THREE.MeshStandardMaterial({ color: 0x8B7355, roughness: 0.6 });
            const threshold = new THREE.Mesh(
              new THREE.BoxGeometry(w, 0.04, frameDepth + 0.08),
              thresholdMat
            );
            threshold.position.set(0, -h/2 + 0.02, 0.04);
            group.add(threshold);

            // Door panels (2)
            const panelW = (w - 0.08) / 2;
            const panelH = h - frameWidth - 0.04;
            const stileWidth = 0.06;
            const topRailH = 0.08;
            const botRailH = 0.25; // Larger bottom rail (kick area)
            const muntinW = 0.025;

            // Calculate lite (glass pane) grid - 10 lite pattern (2 cols x 5 rows)
            const liteCols = 2;
            const liteRows = 5;

            [-1, 1].forEach((side, doorIdx) => {
              const doorGroup = new THREE.Group();

              // Stiles (vertical members)
              [-1, 1].forEach(stSide => {
                const stile = new THREE.Mesh(
                  new THREE.BoxGeometry(stileWidth, panelH, 0.045),
                  doorMat
                );
                stile.position.set(stSide * (panelW/2 - stileWidth/2), 0, 0);
                stile.castShadow = true;
                doorGroup.add(stile);
              });

              // Top rail
              const topRail = new THREE.Mesh(
                new THREE.BoxGeometry(panelW, topRailH, 0.045),
                doorMat
              );
              topRail.position.set(0, panelH/2 - topRailH/2, 0);
              topRail.castShadow = true;
              doorGroup.add(topRail);

              // Bottom rail (kick panel)
              const botRail = new THREE.Mesh(
                new THREE.BoxGeometry(panelW, botRailH, 0.045),
                doorMat
              );
              botRail.position.set(0, -panelH/2 + botRailH/2, 0);
              botRail.castShadow = true;
              doorGroup.add(botRail);

              // Raised panel detail on bottom rail
              const kickPanel = new THREE.Mesh(
                new THREE.BoxGeometry(panelW - stileWidth * 2 - 0.04, botRailH - 0.06, 0.015),
                new THREE.MeshStandardMaterial({ color: adjustColorBrightness(doorColor, -15), roughness: 0.45 })
              );
              kickPanel.position.set(0, -panelH/2 + botRailH/2, 0.03);
              doorGroup.add(kickPanel);

              // Glass area
              const glassAreaW = panelW - stileWidth * 2;
              const glassAreaH = panelH - topRailH - botRailH;
              const glassAreaY = -botRailH/2 + topRailH/2;

              // Muntins (grille bars)
              // Vertical muntins
              for (let c = 1; c < liteCols; c++) {
                const vMuntin = new THREE.Mesh(
                  new THREE.BoxGeometry(muntinW, glassAreaH, muntinW),
                  doorMat
                );
                vMuntin.position.set(-glassAreaW/2 + c * glassAreaW/liteCols, glassAreaY, 0.02);
                doorGroup.add(vMuntin);
              }

              // Horizontal muntins
              for (let r = 1; r < liteRows; r++) {
                const hMuntin = new THREE.Mesh(
                  new THREE.BoxGeometry(glassAreaW, muntinW, muntinW),
                  doorMat
                );
                hMuntin.position.set(0, glassAreaY - glassAreaH/2 + r * glassAreaH/liteRows, 0.02);
                doorGroup.add(hMuntin);
              }

              // Glass panes (individual lites)
              const liteW = (glassAreaW - muntinW * (liteCols - 1)) / liteCols - 0.01;
              const liteH = (glassAreaH - muntinW * (liteRows - 1)) / liteRows - 0.01;

              for (let c = 0; c < liteCols; c++) {
                for (let r = 0; r < liteRows; r++) {
                  const lite = new THREE.Mesh(
                    new THREE.PlaneGeometry(liteW, liteH),
                    glassMat
                  );
                  const liteX = -glassAreaW/2 + liteW/2 + c * (liteW + muntinW) + 0.005;
                  const liteY = glassAreaY + glassAreaH/2 - liteH/2 - r * (liteH + muntinW) - 0.005;
                  lite.position.set(liteX, liteY, 0.01);
                  doorGroup.add(lite);
                }
              }

              // Hinges (3 per door)
              [0.85, 0, -0.85].forEach((hy, hi) => {
                const hinge = new THREE.Mesh(
                  new THREE.BoxGeometry(0.02, 0.1, 0.025),
                  hardwareMat
                );
                hinge.position.set(side * (panelW/2 - stileWidth/2), panelH * 0.4 * hy, 0.035);
                doorGroup.add(hinge);
              });

              // Handle (opposite side from hinges)
              if (doorIdx === 0) {
                // Active door - lever handle
                const handlePlate = new THREE.Mesh(
                  new THREE.BoxGeometry(0.045, 0.18, 0.015),
                  hardwareMat
                );
                handlePlate.position.set(panelW/2 - stileWidth - 0.05, 0, 0.035);
                doorGroup.add(handlePlate);

                const handleLever = new THREE.Mesh(
                  new THREE.CylinderGeometry(0.012, 0.012, 0.12, 8),
                  hardwareMat
                );
                handleLever.rotation.z = Math.PI / 2;
                handleLever.position.set(panelW/2 - stileWidth - 0.02, 0.02, 0.05);
                doorGroup.add(handleLever);

                // Deadbolt
                const deadbolt = new THREE.Mesh(
                  new THREE.CylinderGeometry(0.018, 0.018, 0.02, 12),
                  hardwareMat
                );
                deadbolt.rotation.x = Math.PI / 2;
                deadbolt.position.set(panelW/2 - stileWidth - 0.05, 0.15, 0.035);
                doorGroup.add(deadbolt);
              }

              doorGroup.position.set(side * (panelW/2 + 0.02), (panelH - h)/2 + frameWidth/2 + 0.02, 0.01);
              group.add(doorGroup);
            });

            // Astragal (center mullion where doors meet)
            const astragal = new THREE.Mesh(
              new THREE.BoxGeometry(0.04, h - frameWidth - 0.04, frameDepth * 0.6),
              frameMat
            );
            astragal.position.set(0, -frameWidth/2 - 0.02, frameDepth * 0.15);
            group.add(astragal);

          } else {
            // === SINGLE GLASS DOOR (Commercial style) ===
            // Aluminum storefront door with push bar

            // Frame
            const head = new THREE.Mesh(
              new THREE.BoxGeometry(w + 0.04, frameWidth, frameDepth),
              frameMat
            );
            head.position.set(0, h/2 - frameWidth/2, 0);
            head.castShadow = true;
            group.add(head);

            [-1, 1].forEach(side => {
              const jamb = new THREE.Mesh(
                new THREE.BoxGeometry(frameWidth, h, frameDepth),
                frameMat
              );
              jamb.position.set(side * (w/2 + frameWidth/2 - 0.02), 0, 0);
              jamb.castShadow = true;
              group.add(jamb);
            });

            // Threshold
            const thresholdMat = new THREE.MeshStandardMaterial({ color: 0x808080, roughness: 0.5, metalness: 0.3 });
            const threshold = new THREE.Mesh(
              new THREE.BoxGeometry(w, 0.03, frameDepth + 0.05),
              thresholdMat
            );
            threshold.position.set(0, -h/2 + 0.015, 0.025);
            group.add(threshold);

            // Door panel
            const doorPanelH = h - frameWidth - 0.03;
            const stileW = 0.06;
            const topRailH = 0.06;
            const botRailH = 0.35; // Kick plate area

            // Door frame (stiles and rails)
            [-1, 1].forEach(side => {
              const stile = new THREE.Mesh(
                new THREE.BoxGeometry(stileW, doorPanelH, 0.05),
                frameMat
              );
              stile.position.set(side * (w/2 - stileW/2), -frameWidth/2 - 0.015, 0.02);
              stile.castShadow = true;
              group.add(stile);
            });

            const topRail = new THREE.Mesh(
              new THREE.BoxGeometry(w, topRailH, 0.05),
              frameMat
            );
            topRail.position.set(0, h/2 - frameWidth - topRailH/2, 0.02);
            group.add(topRail);

            // Bottom rail / kick plate
            const kickPlateMat = new THREE.MeshStandardMaterial({ color: 0x888888, roughness: 0.35, metalness: 0.5 });
            const kickPlate = new THREE.Mesh(
              new THREE.BoxGeometry(w - stileW * 2, botRailH, 0.04),
              kickPlateMat
            );
            kickPlate.position.set(0, -h/2 + 0.03 + botRailH/2, 0.03);
            kickPlate.castShadow = true;
            group.add(kickPlate);

            // Main glass panel
            const glassH = doorPanelH - topRailH - botRailH;
            const glassPane = new THREE.Mesh(
              new THREE.PlaneGeometry(w - stileW * 2 - 0.02, glassH - 0.02),
              glassMat
            );
            glassPane.position.set(0, -h/2 + 0.03 + botRailH + glassH/2, 0.025);
            group.add(glassPane);

            // Push bar (panic bar style)
            const pushBarMat = new THREE.MeshStandardMaterial({ color: 0xC0C0C0, roughness: 0.2, metalness: 0.8 });

            // Bar housing
            const barHousing = new THREE.Mesh(
              new THREE.BoxGeometry(w * 0.7, 0.06, 0.04),
              pushBarMat
            );
            barHousing.position.set(0, 0, frameDepth/2 + 0.02);
            group.add(barHousing);

            // Push bar (touchpad)
            const pushBar = new THREE.Mesh(
              new THREE.BoxGeometry(w * 0.6, 0.04, 0.025),
              pushBarMat
            );
            pushBar.position.set(0, 0, frameDepth/2 + 0.055);
            group.add(pushBar);

            // End caps
            [-1, 1].forEach(side => {
              const endCap = new THREE.Mesh(
                new THREE.BoxGeometry(0.04, 0.08, 0.06),
                pushBarMat
              );
              endCap.position.set(side * w * 0.35, 0, frameDepth/2 + 0.03);
              group.add(endCap);
            });

            // Door closer (at top)
            const closerBody = new THREE.Mesh(
              new THREE.BoxGeometry(0.25, 0.06, 0.08),
              new THREE.MeshStandardMaterial({ color: 0x4a4a4a, roughness: 0.4, metalness: 0.3 })
            );
            closerBody.position.set(w * 0.2, h/2 - frameWidth - 0.08, frameDepth/2 + 0.04);
            group.add(closerBody);

            const closerArm = new THREE.Mesh(
              new THREE.BoxGeometry(0.2, 0.02, 0.025),
              hardwareMat
            );
            closerArm.position.set(w * 0.35, h/2 - frameWidth - 0.06, frameDepth/2 + 0.05);
            closerArm.rotation.z = -0.2;
            group.add(closerArm);

            // Pull handle (outside - cylinder style)
            const pullHandle = new THREE.Mesh(
              new THREE.CylinderGeometry(0.015, 0.015, 0.35, 12),
              hardwareMat
            );
            pullHandle.position.set(w/2 - stileW - 0.08, 0, -frameDepth/2 - 0.04);
            group.add(pullHandle);

            // Handle mounts
            [-1, 1].forEach(pos => {
              const mount = new THREE.Mesh(
                new THREE.CylinderGeometry(0.02, 0.02, 0.04, 12),
                hardwareMat
              );
              mount.rotation.x = Math.PI / 2;
              mount.position.set(w/2 - stileW - 0.08, pos * 0.15, -frameDepth/2 - 0.02);
              group.add(mount);
            });
          }

          break;
        }

        case 'window-bay': {
          // Bay window  clean 3-panel architectural window with square frame
          // No angled fins  proper rectangular frame with mullions, glass, bay shelf
          const bayFrameColor = el.frameColor ? parseInt(el.frameColor.replace('#', ''), 16) : 0x3D2B1F;
          const bayFrameMat = new THREE.MeshStandardMaterial({ color: bayFrameColor, roughness: 0.35, metalness: 0.1 });
          const bayGlassColor = sceneSettings.timeOfDay === 'night' ? 0x2a3a5a : 0xADD8E6;
          const bayGlassMat = new THREE.MeshStandardMaterial({
            color: bayGlassColor, transparent: true, opacity: 0.15,
            roughness: 0.02, metalness: 0.35, side: THREE.DoubleSide
          });
          const outdoorPaletteBay = OUTDOOR_COLORS[sceneSettings.timeOfDay] || OUTDOOR_COLORS.noon;

          // Construction-standard frame dimensions (in feet)
          const bfw = 0.25;   // 3" frame face width
          const bfd = 0.25;   // 3" frame depth
          const bmw = 0.20;   // 2.4" mullion width
          const bmun = 0.04;  // ~0.5" muntin bar

          // 3-panel layout: center 50%, each side 25%
          const bCenterW = w * 0.5;
          const bGlassH = h - bfw * 2;

          // Glass panel dimensions (computed from frame geometry)
          const bCGlassW = bCenterW - bmw;
          const bSGlassW = w / 2 - bfw - bCenterW / 2 - bmw / 2;
          const bSGlassX = (w / 2 - bfw + bCenterW / 2 + bmw / 2) / 2;
          const bGlassZ = -bfd / 2 + 0.02;

          // === OUTER FRAME (head, sill, jambs) ===
          const bHead = new THREE.Mesh(new THREE.BoxGeometry(w, bfw, bfd), bayFrameMat);
          bHead.position.set(0, h / 2 - bfw / 2, 0);
          bHead.castShadow = true;
          group.add(bHead);

          const bSillD = bfd + 0.15;
          const bSill = new THREE.Mesh(new THREE.BoxGeometry(w + 0.12, bfw * 1.1, bSillD), bayFrameMat);
          bSill.position.set(0, -h / 2 + bfw * 0.55, (bSillD - bfd) / 2);
          bSill.castShadow = true;
          group.add(bSill);

          [-1, 1].forEach(side => {
            const bJamb = new THREE.Mesh(new THREE.BoxGeometry(bfw, bGlassH, bfd), bayFrameMat);
            bJamb.position.set(side * (w / 2 - bfw / 2), 0, 0);
            bJamb.castShadow = true;
            group.add(bJamb);
          });

          // === MULLIONS (vertical dividers between 3 panels) ===
          [-1, 1].forEach(side => {
            const bMull = new THREE.Mesh(new THREE.BoxGeometry(bmw, bGlassH, bfd), bayFrameMat);
            bMull.position.set(side * bCenterW / 2, 0, 0);
            group.add(bMull);
          });

          // === MUNTINS (subdivide panes) ===
          // Center panel: cross pattern  4 panes
          const bCHMunt = new THREE.Mesh(new THREE.BoxGeometry(bCGlassW, bmun, bmun), bayFrameMat);
          bCHMunt.position.set(0, 0, bfd / 4);
          group.add(bCHMunt);
          const bCVMunt = new THREE.Mesh(new THREE.BoxGeometry(bmun, bGlassH, bmun), bayFrameMat);
          bCVMunt.position.set(0, 0, bfd / 4);
          group.add(bCVMunt);

          // Side panels: horizontal muntin  2 panes each
          [-1, 1].forEach(side => {
            const bSHMunt = new THREE.Mesh(new THREE.BoxGeometry(bSGlassW, bmun, bmun), bayFrameMat);
            bSHMunt.position.set(side * bSGlassX, 0, bfd / 4);
            group.add(bSHMunt);
          });

          // === GLASS PANELS ===
          const bCGlass = new THREE.Mesh(new THREE.PlaneGeometry(bCGlassW, bGlassH), bayGlassMat);
          bCGlass.position.set(0, 0, bGlassZ);
          group.add(bCGlass);

          [-1, 1].forEach(side => {
            const bSGlass = new THREE.Mesh(new THREE.PlaneGeometry(bSGlassW, bGlassH), bayGlassMat);
            bSGlass.position.set(side * bSGlassX, 0, bGlassZ);
            group.add(bSGlass);
          });

          // === OUTDOOR VIEW (sky + horizon behind glass) ===
          const bSkyMat = new THREE.MeshBasicMaterial({ color: outdoorPaletteBay.sky, side: THREE.DoubleSide });
          const bHorizMat = new THREE.MeshBasicMaterial({ color: outdoorPaletteBay.horizon || 0x87CEEB, side: THREE.DoubleSide });
          const bSkyH = bGlassH * 0.65;
          const bHorizH = bGlassH * 0.35;
          const bSkyZ = bGlassZ - 0.03;

          // Center sky + horizon
          const bCSky = new THREE.Mesh(new THREE.PlaneGeometry(bCGlassW, bSkyH), bSkyMat);
          bCSky.position.set(0, bGlassH * 0.175, bSkyZ);
          group.add(bCSky);
          const bCHoriz = new THREE.Mesh(new THREE.PlaneGeometry(bCGlassW, bHorizH), bHorizMat);
          bCHoriz.position.set(0, -bGlassH * 0.325, bSkyZ);
          group.add(bCHoriz);

          // Side sky + horizon
          [-1, 1].forEach(side => {
            const bSSky = new THREE.Mesh(new THREE.PlaneGeometry(bSGlassW, bSkyH), bSkyMat);
            bSSky.position.set(side * bSGlassX, bGlassH * 0.175, bSkyZ);
            group.add(bSSky);
            const bSHoriz = new THREE.Mesh(new THREE.PlaneGeometry(bSGlassW, bHorizH), bHorizMat);
            bSHoriz.position.set(side * bSGlassX, -bGlassH * 0.325, bSkyZ);
            group.add(bSHoriz);
          });

          // Trees
          if (sceneSettings.timeOfDay !== 'night') {
            const bTreeMat = new THREE.MeshBasicMaterial({ color: 0x228B22 });
            for (let t = 0; t < 3; t++) {
              const treeSize = 0.15 + Math.random() * 0.15;
              const bTree = new THREE.Mesh(new THREE.ConeGeometry(treeSize, treeSize * 2, 6), bTreeMat);
              bTree.position.set((t - 1) * bCGlassW * 0.3, -bGlassH * 0.15, bSkyZ - 0.01);
              group.add(bTree);
            }
          }

          // === BAY SHELF (projects into room as window seat) ===
          const bShelfDepth = 0.8;
          const bShelfMat = new THREE.MeshStandardMaterial({ color: bayFrameColor, roughness: 0.4, metalness: 0.05 });
          const bBayShelf = new THREE.Mesh(new THREE.BoxGeometry(w, 0.06, bShelfDepth), bShelfMat);
          bBayShelf.position.set(0, -h / 2 + bfw * 1.1 + 0.03, bfd / 2 + bShelfDepth / 2);
          bBayShelf.castShadow = true;
          group.add(bBayShelf);

          // === HEADER CROWN (trim above window) ===
          const bHeaderCap = new THREE.Mesh(new THREE.BoxGeometry(w + 0.06, 0.05, bfd + 0.06), bShelfMat);
          bHeaderCap.position.set(0, h / 2 + 0.025, 0.03);
          group.add(bHeaderCap);

          // === APRON (trim below sill, interior side) ===
          const bApron = new THREE.Mesh(new THREE.BoxGeometry(w - 0.1, 0.08, 0.04), bShelfMat);
          bApron.position.set(0, -h / 2 - 0.04, bfd / 2 + 0.02);
          group.add(bApron);

          break;
        }

        case 'window-large': {
          // Dead code  window-large is caught by the professional window case above.
          // Kept for fallback safety only.
          const wlFrameMat = new THREE.MeshStandardMaterial({ color: 0x3D2B1F, roughness: 0.35 });
          const wlOutdoor = OUTDOOR_COLORS[sceneSettings.timeOfDay] || OUTDOOR_COLORS.noon;

          const wlFrame = new THREE.Mesh(new THREE.BoxGeometry(w, h, 0.15), wlFrameMat);
          group.add(wlFrame);
          const wlSky = new THREE.Mesh(new THREE.BoxGeometry(w - 0.2, h - 0.2, 0.01), new THREE.MeshBasicMaterial({ color: wlOutdoor.sky }));
          wlSky.position.z = -0.05;
          group.add(wlSky);
          const wlGlass = new THREE.Mesh(new THREE.BoxGeometry(w - 0.15, h - 0.15, 0.02), new THREE.MeshStandardMaterial({
            color: 0xADD8E6, transparent: true, opacity: 0.15, roughness: 0.05
          }));
          wlGlass.position.z = 0.05;
          group.add(wlGlass);
          break;
        }

        case 'entry-archway': {
          // Simplified archway - dark recessed opening with arch trim
          const archStyle = el.archwayStyle || 'round';
          const archColor = el.color ? parseInt(el.color.replace('#', ''), 16) : 0xDAA520;
          const wallDepth = Math.max(0.5, d || 0.67);
          const archRadius = w / 2;

          // Materials
          const interiorMat = new THREE.MeshStandardMaterial({
            color: 0x1A1A1A,
            roughness: 0.9,
            side: THREE.DoubleSide
          });
          const sideMat = new THREE.MeshStandardMaterial({
            color: 0x2A2A2A,
            roughness: 0.85,
            side: THREE.DoubleSide
          });
          const trimMat = new THREE.MeshStandardMaterial({
            color: archColor,
            roughness: 0.5
          });
          const trimDarkMat = new THREE.MeshStandardMaterial({
            color: adjustColorBrightness(archColor, -30),
            roughness: 0.6
          });

          // === DARK INTERIOR OPENING ===
          // Create arch shape for back wall
          const archShape = new THREE.Shape();
          archShape.moveTo(-w/2, -h/2);
          archShape.lineTo(-w/2, h/2 - archRadius);
          // Arch curve at top
          if (archStyle === 'round') {
            archShape.absarc(0, h/2 - archRadius, archRadius, Math.PI, 0, true);
          } else if (archStyle === 'pointed') {
            // Gothic pointed arch
            archShape.quadraticCurveTo(-w/4, h/2 + archRadius * 0.3, 0, h/2 + archRadius * 0.2);
            archShape.quadraticCurveTo(w/4, h/2 + archRadius * 0.3, w/2, h/2 - archRadius);
          } else if (archStyle === 'elliptical') {
            // Segmental arch
            archShape.absellipse(0, h/2 - archRadius * 0.6, archRadius, archRadius * 0.6, Math.PI, 0, true);
          } else {
            // Flat opening
            archShape.lineTo(w/2, h/2 - archRadius);
            archShape.lineTo(w/2, h/2);
            archShape.lineTo(-w/2, h/2);
          }
          archShape.lineTo(w/2, h/2 - archRadius);
          archShape.lineTo(w/2, -h/2);
          archShape.lineTo(-w/2, -h/2);

          // Back wall (dark opening)
          const backGeom = new THREE.ShapeGeometry(archShape);
          const backWall = new THREE.Mesh(backGeom, interiorMat);
          backWall.position.set(0, 0, -wallDepth);
          group.add(backWall);

          // Side walls (reveals)
          // Left wall
          const leftWall = new THREE.Mesh(
            new THREE.PlaneGeometry(wallDepth, h),
            sideMat
          );
          leftWall.rotation.y = Math.PI / 2;
          leftWall.position.set(-w/2, 0, -wallDepth/2);
          group.add(leftWall);

          // Right wall
          const rightWall = new THREE.Mesh(
            new THREE.PlaneGeometry(wallDepth, h),
            sideMat
          );
          rightWall.rotation.y = -Math.PI / 2;
          rightWall.position.set(w/2, 0, -wallDepth/2);
          group.add(rightWall);

          // Floor of opening
          const floorWall = new THREE.Mesh(
            new THREE.PlaneGeometry(w, wallDepth),
            sideMat
          );
          floorWall.rotation.x = -Math.PI / 2;
          floorWall.position.set(0, -h/2, -wallDepth/2);
          group.add(floorWall);

          // === TRIM/CASING ===
          const trimWidth = 0.12;
          const trimDepth = 0.06;

          // Left trim
          const leftTrim = new THREE.Mesh(
            new THREE.BoxGeometry(trimWidth, h - archRadius, trimDepth),
            trimMat
          );
          leftTrim.position.set(-w/2 - trimWidth/2, -archRadius/2, trimDepth/2);
          group.add(leftTrim);

          // Right trim
          const rightTrim = new THREE.Mesh(
            new THREE.BoxGeometry(trimWidth, h - archRadius, trimDepth),
            trimMat
          );
          rightTrim.position.set(w/2 + trimWidth/2, -archRadius/2, trimDepth/2);
          group.add(rightTrim);

          // Arch curve trim (simplified as segments)
          if (archStyle === 'round' || archStyle === 'elliptical') {
            const numSegs = 12;
            for (let i = 0; i < numSegs; i++) {
              const a1 = Math.PI * (i / numSegs);
              const a2 = Math.PI * ((i + 1) / numSegs);
              const r = archRadius + trimWidth/2;

              const x1 = -Math.cos(a1) * r;
              const y1 = (h/2 - archRadius) + Math.sin(a1) * (archStyle === 'elliptical' ? archRadius * 0.6 : archRadius);
              const x2 = -Math.cos(a2) * r;
              const y2 = (h/2 - archRadius) + Math.sin(a2) * (archStyle === 'elliptical' ? archRadius * 0.6 : archRadius);

              const segLen = Math.sqrt((x2-x1)**2 + (y2-y1)**2);
              const segAng = Math.atan2(y2-y1, x2-x1);

              const archSeg = new THREE.Mesh(
                new THREE.BoxGeometry(segLen * 1.1, trimWidth, trimDepth),
                trimMat
              );
              archSeg.position.set((x1+x2)/2, (y1+y2)/2, trimDepth/2);
              archSeg.rotation.z = segAng;
              group.add(archSeg);
            }
          } else {
            // Flat header
            const headerTrim = new THREE.Mesh(
              new THREE.BoxGeometry(w + trimWidth * 2, trimWidth, trimDepth),
              trimMat
            );
            headerTrim.position.set(0, h/2 + trimWidth/2, trimDepth/2);
            group.add(headerTrim);
          }

          // Keystone (decorative center block at top)
          const keystoneMat = new THREE.MeshStandardMaterial({
            color: adjustColorBrightness(archColor, 15),
            roughness: 0.45
          });
          const keystone = new THREE.Mesh(
            new THREE.BoxGeometry(trimWidth * 1.5, trimWidth * 1.8, trimDepth * 1.2),
            keystoneMat
          );
          const keystoneY = archStyle === 'flat' ? h/2 + trimWidth/2 :
                           (archStyle === 'pointed' ? h/2 + archRadius * 0.2 : h/2);
          keystone.position.set(0, keystoneY, trimDepth * 0.6);
          group.add(keystone);

          // Base blocks (plinths at bottom of trim)
          [-1, 1].forEach(side => {
            const plinth = new THREE.Mesh(
              new THREE.BoxGeometry(trimWidth * 1.3, trimWidth * 0.8, trimDepth * 1.1),
              trimDarkMat
            );
            plinth.position.set(side * (w/2 + trimWidth/2), -h/2 + trimWidth * 0.4, trimDepth * 0.55);
            group.add(plinth);
          });

          break;
        }

        case 'garage-door': {
          // Garage door with proper sectional panel construction
          const doorColor = el.color ? parseInt(el.color.replace('#', ''), 16) : 0xD4D4D4;

          // Materials
          const doorMat = new THREE.MeshStandardMaterial({
            color: doorColor,
            roughness: 0.6,
            metalness: 0.1
          });
          const panelMat = new THREE.MeshStandardMaterial({
            color: adjustColorBrightness(doorColor, -15),
            roughness: 0.5
          });
          const recessMat = new THREE.MeshStandardMaterial({
            color: adjustColorBrightness(doorColor, -30),
            roughness: 0.7
          });
          const hardwareMat = new THREE.MeshStandardMaterial({
            color: 0x3A3A3A,
            roughness: 0.3,
            metalness: 0.7
          });
          const frameMat = new THREE.MeshStandardMaterial({
            color: 0x4A4A4A,
            roughness: 0.5
          });
          const weatherMat = new THREE.MeshStandardMaterial({
            color: 0x2A2A2A,
            roughness: 0.9
          });

          // Door dimensions
          const doorDepth = 0.08;
          const frameWidth = 0.15;
          const sections = 4; // Horizontal sections
          const panelsPerSection = 3; // Raised panels per section
          const sectionHeight = h / sections;
          const panelGap = 0.03;

          // === DOOR FRAME (trim around opening) ===
          // Top frame
          const topFrame = new THREE.Mesh(
            new THREE.BoxGeometry(w + frameWidth * 2, frameWidth, doorDepth + 0.1),
            frameMat
          );
          topFrame.position.set(0, h/2 + frameWidth/2, 0);
          topFrame.castShadow = true;
          group.add(topFrame);

          // Left frame
          const leftFrame = new THREE.Mesh(
            new THREE.BoxGeometry(frameWidth, h + frameWidth, doorDepth + 0.1),
            frameMat
          );
          leftFrame.position.set(-w/2 - frameWidth/2, frameWidth/2, 0);
          leftFrame.castShadow = true;
          group.add(leftFrame);

          // Right frame
          const rightFrame = new THREE.Mesh(
            new THREE.BoxGeometry(frameWidth, h + frameWidth, doorDepth + 0.1),
            frameMat
          );
          rightFrame.position.set(w/2 + frameWidth/2, frameWidth/2, 0);
          rightFrame.castShadow = true;
          group.add(rightFrame);

          // === DOOR SECTIONS (4 horizontal panels) ===
          for (let sec = 0; sec < sections; sec++) {
            const secY = h/2 - sectionHeight/2 - sec * sectionHeight;

            // Section base panel
            const sectionPanel = new THREE.Mesh(
              new THREE.BoxGeometry(w - panelGap, sectionHeight - panelGap, doorDepth),
              doorMat
            );
            sectionPanel.position.set(0, secY, 0);
            sectionPanel.castShadow = true;
            sectionPanel.receiveShadow = true;
            group.add(sectionPanel);

            // Raised panels within each section
            const panelWidth = (w - panelGap * 4) / panelsPerSection;
            const panelHeight = sectionHeight - panelGap * 2 - 0.06;

            for (let p = 0; p < panelsPerSection; p++) {
              const panelX = -w/2 + panelGap * 1.5 + panelWidth/2 + p * (panelWidth + panelGap);

              // Raised panel face
              const raisedPanel = new THREE.Mesh(
                new THREE.BoxGeometry(panelWidth - 0.04, panelHeight, 0.02),
                panelMat
              );
              raisedPanel.position.set(panelX, secY, doorDepth/2 + 0.01);
              group.add(raisedPanel);

              // Panel recess (shadow line around raised panel)
              const recessDepth = 0.015;
              // Top recess
              const topRecess = new THREE.Mesh(
                new THREE.BoxGeometry(panelWidth - 0.02, 0.02, recessDepth),
                recessMat
              );
              topRecess.position.set(panelX, secY + panelHeight/2 + 0.01, doorDepth/2 - recessDepth/2);
              group.add(topRecess);

              // Bottom recess
              const botRecess = new THREE.Mesh(
                new THREE.BoxGeometry(panelWidth - 0.02, 0.02, recessDepth),
                recessMat
              );
              botRecess.position.set(panelX, secY - panelHeight/2 - 0.01, doorDepth/2 - recessDepth/2);
              group.add(botRecess);
            }

            // Section joint line (horizontal gap between sections)
            if (sec < sections - 1) {
              const jointLine = new THREE.Mesh(
                new THREE.BoxGeometry(w, 0.01, 0.01),
                weatherMat
              );
              jointLine.position.set(0, secY - sectionHeight/2, doorDepth/2);
              group.add(jointLine);
            }

            // Hardware - Hinges (2 per section side)
            [-1, 1].forEach(side => {
              const hingeY = secY;
              const hinge = new THREE.Mesh(
                new THREE.BoxGeometry(0.05, 0.12, 0.03),
                hardwareMat
              );
              hinge.position.set(side * (w/2 - 0.06), hingeY, doorDepth/2 + 0.02);
              group.add(hinge);

              // Hinge roller bracket
              const bracket = new THREE.Mesh(
                new THREE.BoxGeometry(0.08, 0.04, 0.02),
                hardwareMat
              );
              bracket.position.set(side * (w/2 - 0.06), hingeY - 0.08, doorDepth/2 + 0.015);
              group.add(bracket);
            });
          }

          // === WINDOW PANELS (top section) ===
          const hasWindows = w > 7; // Windows only on wide doors
          if (hasWindows) {
            const windowGlassMat = new THREE.MeshStandardMaterial({
              color: 0x87CEEB,
              transparent: true,
              opacity: 0.3,
              roughness: 0.1
            });
            const windowFrameMat = new THREE.MeshStandardMaterial({
              color: 0x666666,
              roughness: 0.4
            });

            const windowsPerSection = Math.floor((w - 0.5) / 1.5);
            const windowWidth = 0.8;
            const windowHeight = sectionHeight * 0.6;
            const topSecY = h/2 - sectionHeight/2;

            for (let wn = 0; wn < windowsPerSection; wn++) {
              const wnX = -w/2 + 0.5 + windowWidth/2 + wn * (w - 0.5) / windowsPerSection;

              // Window frame
              const wnFrame = new THREE.Mesh(
                new THREE.BoxGeometry(windowWidth + 0.04, windowHeight + 0.04, 0.025),
                windowFrameMat
              );
              wnFrame.position.set(wnX, topSecY, doorDepth/2 + 0.02);
              group.add(wnFrame);

              // Window glass
              const wnGlass = new THREE.Mesh(
                new THREE.BoxGeometry(windowWidth, windowHeight, 0.01),
                windowGlassMat
              );
              wnGlass.position.set(wnX, topSecY, doorDepth/2 + 0.03);
              group.add(wnGlass);

              // Window muntins (cross pattern)
              const muntinMat = new THREE.MeshStandardMaterial({ color: 0x555555, roughness: 0.4 });
              const vMuntin = new THREE.Mesh(
                new THREE.BoxGeometry(0.02, windowHeight, 0.015),
                muntinMat
              );
              vMuntin.position.set(wnX, topSecY, doorDepth/2 + 0.035);
              group.add(vMuntin);

              const hMuntin = new THREE.Mesh(
                new THREE.BoxGeometry(windowWidth, 0.02, 0.015),
                muntinMat
              );
              hMuntin.position.set(wnX, topSecY, doorDepth/2 + 0.035);
              group.add(hMuntin);
            }
          }

          // === BOTTOM SEAL (weather stripping) ===
          const bottomSeal = new THREE.Mesh(
            new THREE.BoxGeometry(w, 0.04, 0.06),
            weatherMat
          );
          bottomSeal.position.set(0, -h/2 + 0.02, doorDepth/2);
          group.add(bottomSeal);

          // === HANDLE (lift handle at bottom) ===
          const handleBase = new THREE.Mesh(
            new THREE.BoxGeometry(0.35, 0.08, 0.04),
            hardwareMat
          );
          handleBase.position.set(0, -h/2 + sectionHeight/2, doorDepth/2 + 0.03);
          group.add(handleBase);

          const handleGrip = new THREE.Mesh(
            new THREE.BoxGeometry(0.25, 0.04, 0.08),
            hardwareMat
          );
          handleGrip.position.set(0, -h/2 + sectionHeight/2, doorDepth/2 + 0.08);
          group.add(handleGrip);

          break;
        }

        case 'crown-molding': {
          // Crown molding with ornate profile
          const moldColor = el.color ? parseInt(el.color.replace('#', '0x')) : 0xF5F5F5;
          const moldMat = new THREE.MeshStandardMaterial({ color: moldColor, roughness: 0.4 });

          // Create crown molding profile shape
          const crownShape = new THREE.Shape();
          const mh = 0.25; // molding height
          const md = 0.2;  // molding depth

          // Ornate crown profile
          crownShape.moveTo(0, 0);
          crownShape.lineTo(md, 0);
          crownShape.lineTo(md, mh * 0.1);
          crownShape.quadraticCurveTo(md * 0.9, mh * 0.2, md * 0.85, mh * 0.3);
          crownShape.quadraticCurveTo(md * 0.75, mh * 0.5, md * 0.6, mh * 0.6);
          crownShape.bezierCurveTo(md * 0.4, mh * 0.75, md * 0.2, mh * 0.9, 0, mh);
          crownShape.lineTo(0, 0);

          const extrudeSettings = { steps: 1, depth: w, bevelEnabled: false };
          const crownGeom = new THREE.ExtrudeGeometry(crownShape, extrudeSettings);
          crownGeom.rotateY(-Math.PI / 2);
          crownGeom.translate(w/2, 0, 0);

          const crown = new THREE.Mesh(crownGeom, moldMat);
          group.add(crown);

          // Shadow line detail
          const shadowMat = new THREE.MeshStandardMaterial({ color: 0xDDDDDD, roughness: 0.5 });
          const shadowLine = new THREE.Mesh(new THREE.BoxGeometry(w, 0.02, 0.02), shadowMat);
          shadowLine.position.set(0, mh * 0.3, md * 0.7);
          group.add(shadowLine);
          break;
        }

        case 'baseboard': {
          // Baseboard with stepped profile
          const bbColor = el.color ? parseInt(el.color.replace('#', '0x')) : 0xF5F5F5;
          const bbMat = new THREE.MeshStandardMaterial({ color: bbColor, roughness: 0.35 });

          // Create baseboard profile
          const bbShape = new THREE.Shape();
          const bbh = 0.5;  // baseboard height (6 inches)
          const bbd = 0.08; // baseboard depth

          bbShape.moveTo(0, 0);
          bbShape.lineTo(bbd, 0);
          bbShape.lineTo(bbd, bbh * 0.7);
          bbShape.lineTo(bbd * 0.7, bbh * 0.75);
          bbShape.lineTo(bbd * 0.7, bbh * 0.85);
          bbShape.lineTo(bbd * 0.5, bbh * 0.9);
          bbShape.lineTo(bbd * 0.5, bbh);
          bbShape.lineTo(0, bbh);
          bbShape.lineTo(0, 0);

          const bbExtrudeSettings = { steps: 1, depth: w, bevelEnabled: false };
          const bbGeom = new THREE.ExtrudeGeometry(bbShape, bbExtrudeSettings);
          bbGeom.rotateY(-Math.PI / 2);
          bbGeom.translate(w/2, -bbh/2, 0);

          const baseboard = new THREE.Mesh(bbGeom, bbMat);
          group.add(baseboard);
          break;
        }

        case 'chair-rail': {
          // Chair rail molding at mid-height
          const crColor = el.color ? parseInt(el.color.replace('#', '0x')) : 0xF5F5F5;
          const crMat = new THREE.MeshStandardMaterial({ color: crColor, roughness: 0.35 });

          // Create chair rail profile
          const crShape = new THREE.Shape();
          const crh = 0.2;  // chair rail height
          const crd = 0.1;  // chair rail depth

          crShape.moveTo(0, 0);
          crShape.lineTo(crd, 0);
          crShape.lineTo(crd, crh * 0.2);
          crShape.quadraticCurveTo(crd * 0.8, crh * 0.4, crd * 0.7, crh * 0.5);
          crShape.lineTo(crd * 0.7, crh * 0.6);
          crShape.quadraticCurveTo(crd * 0.5, crh * 0.8, 0, crh);
          crShape.lineTo(0, 0);

          const crExtrudeSettings = { steps: 1, depth: w, bevelEnabled: false };
          const crGeom = new THREE.ExtrudeGeometry(crShape, crExtrudeSettings);
          crGeom.rotateY(-Math.PI / 2);
          crGeom.translate(w/2, -crh/2, 0);

          const chairRail = new THREE.Mesh(crGeom, crMat);
          group.add(chairRail);
          break;
        }

        // ===== BATHROOM ELEMENTS =====
        case 'toilet': {
          // Elongated toilet with tank - properly positioned across depth
          const porcelainMat = new THREE.MeshStandardMaterial({
            color: 0xFFFFFF,
            roughness: 0.15,
            metalness: 0.05
          });
          const chromeMat = new THREE.MeshStandardMaterial({
            color: 0xC0C0C0,
            roughness: 0.1,
            metalness: 0.9
          });
          const seatMat = new THREE.MeshStandardMaterial({
            color: 0xF5F5F5,
            roughness: 0.3
          });

          // Calculate proper Z positions
          // Tank at back (-Z), bowl at front (+Z)
          const tankD = 0.6; // Tank depth ~7 inches
          const tankZ = -d / 2 + tankD / 2 + 0.05; // Tank flush with back + small gap
          const bowlZ = d * 0.15; // Bowl forward of center

          // Bowl base
          const bowlBaseH = 0.35;
          const bowlBase = new THREE.Mesh(
            new THREE.CylinderGeometry(w * 0.35, w * 0.4, bowlBaseH, 16),
            porcelainMat
          );
          bowlBase.position.set(0, bowlBaseH / 2 - h / 2, bowlZ);
          group.add(bowlBase);

          // Bowl (elongated shape)
          const bowlH = 0.5;
          const bowlGeom = new THREE.CylinderGeometry(w * 0.42, w * 0.35, bowlH, 16, 1, false);
          const bowl = new THREE.Mesh(bowlGeom, porcelainMat);
          bowl.position.set(0, bowlBaseH + bowlH / 2 - h / 2, bowlZ);
          group.add(bowl);

          // Inner bowl (dark)
          const innerBowlMat = new THREE.MeshStandardMaterial({ color: 0x4a6070, roughness: 0.3 });
          const innerBowl = new THREE.Mesh(
            new THREE.CylinderGeometry(w * 0.32, w * 0.28, 0.3, 16),
            innerBowlMat
          );
          innerBowl.position.set(0, bowlBaseH + bowlH - 0.1 - h / 2, bowlZ);
          group.add(innerBowl);

          // Seat
          const seatH = 0.05;
          const seat = new THREE.Mesh(
            new THREE.CylinderGeometry(w * 0.44, w * 0.44, seatH, 24),
            seatMat
          );
          seat.position.set(0, bowlBaseH + bowlH + seatH / 2 - h / 2, bowlZ);
          group.add(seat);

          // Tank
          const tankW = w * 0.7;
          const tankH = 1.1;
          const tank = new THREE.Mesh(
            new THREE.BoxGeometry(tankW, tankH, tankD),
            porcelainMat
          );
          tank.position.set(0, bowlBaseH + tankH / 2 - h / 2, tankZ);
          group.add(tank);

          // Tank lid
          const lidMat = new THREE.MeshStandardMaterial({ color: 0xF8F8F8, roughness: 0.2 });
          const tankLid = new THREE.Mesh(
            new THREE.BoxGeometry(tankW + 0.05, 0.08, tankD + 0.05),
            lidMat
          );
          tankLid.position.set(0, bowlBaseH + tankH + 0.04 - h / 2, tankZ);
          group.add(tankLid);

          // Flush handle
          const handle = new THREE.Mesh(
            new THREE.BoxGeometry(0.15, 0.04, 0.04),
            chromeMat
          );
          handle.position.set(-tankW / 2 - 0.05, bowlBaseH + tankH * 0.7 - h / 2, tankZ);
          group.add(handle);

          break;
        }

        case 'toilet-round': {
          // Round toilet (more compact bowl) - properly positioned across depth
          const porcelainMat = new THREE.MeshStandardMaterial({
            color: 0xFFFFFF,
            roughness: 0.15,
            metalness: 0.05
          });
          const chromeMat = new THREE.MeshStandardMaterial({
            color: 0xC0C0C0,
            roughness: 0.1,
            metalness: 0.9
          });

          // Calculate proper Z positions
          const tankD = 0.55;
          const tankZ = -d / 2 + tankD / 2 + 0.05; // Tank at back
          const bowlZ = d * 0.12; // Bowl forward of center (slightly less than elongated)

          // Bowl base (rounder)
          const bowlBaseH = 0.35;
          const bowlBase = new THREE.Mesh(
            new THREE.CylinderGeometry(w * 0.38, w * 0.42, bowlBaseH, 16),
            porcelainMat
          );
          bowlBase.position.set(0, bowlBaseH / 2 - h / 2, bowlZ);
          group.add(bowlBase);

          // Bowl (round shape)
          const bowlH = 0.45;
          const bowl = new THREE.Mesh(
            new THREE.SphereGeometry(w * 0.4, 16, 12, 0, Math.PI * 2, 0, Math.PI / 2),
            porcelainMat
          );
          bowl.rotation.x = Math.PI;
          bowl.position.set(0, bowlBaseH + bowlH / 2 - h / 2, bowlZ);
          group.add(bowl);

          // Seat
          const seatMat = new THREE.MeshStandardMaterial({ color: 0xF5F5F5, roughness: 0.3 });
          const seat = new THREE.Mesh(
            new THREE.TorusGeometry(w * 0.35, 0.04, 8, 24),
            seatMat
          );
          seat.rotation.x = Math.PI / 2;
          seat.position.set(0, bowlBaseH + bowlH - h / 2, bowlZ);
          group.add(seat);

          // Tank
          const tankW = w * 0.65;
          const tankH = 1.0;
          const tank = new THREE.Mesh(
            new THREE.BoxGeometry(tankW, tankH, tankD),
            porcelainMat
          );
          tank.position.set(0, bowlBaseH + tankH / 2 - h / 2, tankZ);
          group.add(tank);

          // Tank lid
          const tankLid = new THREE.Mesh(
            new THREE.BoxGeometry(tankW + 0.04, 0.06, tankD + 0.04),
            porcelainMat
          );
          tankLid.position.set(0, bowlBaseH + tankH + 0.03 - h / 2, tankZ);
          group.add(tankLid);

          // Flush handle
          const handleMesh = new THREE.Mesh(
            new THREE.BoxGeometry(0.12, 0.04, 0.04),
            chromeMat
          );
          handleMesh.position.set(-tankW / 2 - 0.04, bowlBaseH + tankH * 0.7 - h / 2, tankZ);
          group.add(handleMesh);

          break;
        }

        case 'toilet-wall': {
          // Wall-hung toilet (no visible tank, modern design)
          const porcelainMat = new THREE.MeshStandardMaterial({
            color: 0xFFFFFF,
            roughness: 0.12,
            metalness: 0.05
          });
          const chromeMat = new THREE.MeshStandardMaterial({
            color: 0xC0C0C0,
            roughness: 0.1,
            metalness: 0.9
          });

          // Wall mounting plate (hidden tank)
          const plateMat = new THREE.MeshStandardMaterial({ color: 0xD0D0D0, roughness: 0.3 });
          const plate = new THREE.Mesh(
            new THREE.BoxGeometry(w * 0.7, 0.8, 0.1),
            plateMat
          );
          plate.position.set(0, 0.2, -d / 2 + 0.05);
          group.add(plate);

          // Flush buttons
          const buttonMat = new THREE.MeshStandardMaterial({ color: 0xE0E0E0, roughness: 0.2 });
          const largeButton = new THREE.Mesh(
            new THREE.BoxGeometry(0.12, 0.08, 0.02),
            buttonMat
          );
          largeButton.position.set(-0.05, 0.5, -d / 2 + 0.11);
          group.add(largeButton);

          const smallButton = new THREE.Mesh(
            new THREE.BoxGeometry(0.08, 0.08, 0.02),
            buttonMat
          );
          smallButton.position.set(0.07, 0.5, -d / 2 + 0.11);
          group.add(smallButton);

          // Bowl (floating, elongated)
          const bowlH = 0.4;
          const bowl = new THREE.Mesh(
            new THREE.CylinderGeometry(w * 0.38, w * 0.35, bowlH, 16),
            porcelainMat
          );
          bowl.rotation.x = Math.PI / 12;
          bowl.position.set(0, -0.1, d * 0.15);
          group.add(bowl);

          // Rim
          const rimMat = new THREE.MeshStandardMaterial({ color: 0xFAFAFA, roughness: 0.1 });
          const rim = new THREE.Mesh(
            new THREE.TorusGeometry(w * 0.36, 0.03, 8, 24),
            rimMat
          );
          rim.rotation.x = Math.PI / 2;
          rim.position.set(0, 0.1, d * 0.15);
          group.add(rim);

          break;
        }

        case 'bidet': {
          // Bidet with spray feature
          const porcelainMat = new THREE.MeshStandardMaterial({
            color: 0xFFFFFF,
            roughness: 0.12,
            metalness: 0.05
          });
          const chromeMat = new THREE.MeshStandardMaterial({
            color: 0xC0C0C0,
            roughness: 0.1,
            metalness: 0.9
          });

          // Base
          const baseH = 0.35;
          const base = new THREE.Mesh(
            new THREE.CylinderGeometry(w * 0.4, w * 0.42, baseH, 16),
            porcelainMat
          );
          base.position.set(0, baseH / 2 - h / 2, 0);
          group.add(base);

          // Basin (oval shape)
          const basinH = 0.3;
          const basin = new THREE.Mesh(
            new THREE.CylinderGeometry(w * 0.42, w * 0.38, basinH, 16),
            porcelainMat
          );
          basin.position.set(0, baseH + basinH / 2 - h / 2, 0);
          group.add(basin);

          // Inner basin (recessed)
          const innerMat = new THREE.MeshStandardMaterial({ color: 0xE8F0F8, roughness: 0.2 });
          const innerBasin = new THREE.Mesh(
            new THREE.CylinderGeometry(w * 0.32, w * 0.28, 0.15, 16),
            innerMat
          );
          innerBasin.position.set(0, baseH + basinH - 0.05 - h / 2, 0);
          group.add(innerBasin);

          // Rim
          const rim = new THREE.Mesh(
            new THREE.TorusGeometry(w * 0.4, 0.03, 8, 24),
            porcelainMat
          );
          rim.rotation.x = Math.PI / 2;
          rim.position.set(0, baseH + basinH + 0.02 - h / 2, 0);
          group.add(rim);

          // Faucet
          const faucetBase = new THREE.Mesh(
            new THREE.CylinderGeometry(0.04, 0.05, 0.06, 12),
            chromeMat
          );
          faucetBase.position.set(0, baseH + basinH + 0.05 - h / 2, -d / 3);
          group.add(faucetBase);

          const spout = new THREE.Mesh(
            new THREE.CylinderGeometry(0.02, 0.02, 0.15, 8),
            chromeMat
          );
          spout.rotation.x = Math.PI / 3;
          spout.position.set(0, baseH + basinH + 0.12 - h / 2, -d / 4);
          group.add(spout);

          // Handles
          [-0.08, 0.08].forEach(offsetX => {
            const handleKnob = new THREE.Mesh(
              new THREE.SphereGeometry(0.025, 8, 8),
              chromeMat
            );
            handleKnob.position.set(offsetX, baseH + basinH + 0.08 - h / 2, -d / 3);
            group.add(handleKnob);
          });

          break;
        }

        case 'bathtub':
        case 'bathtub-freestanding': {
          // Alcove or freestanding bathtub
          const isFreestanding = el.type === 'bathtub-freestanding';
          const tubMat = new THREE.MeshStandardMaterial({
            color: 0xFFFFFF,
            roughness: 0.1,
            metalness: 0.05
          });
          const innerMat = new THREE.MeshStandardMaterial({
            color: 0xE8E8E8,
            roughness: 0.15
          });
          const chromeMat = new THREE.MeshStandardMaterial({
            color: 0xC0C0C0,
            roughness: 0.1,
            metalness: 0.9
          });

          const tubH = isFreestanding ? 1.8 : 1.5;
          const wallThickness = 0.08;

          // Outer tub shell
          const outerTub = new THREE.Mesh(
            new THREE.BoxGeometry(w, tubH, d),
            tubMat
          );
          outerTub.position.set(0, tubH / 2 - h / 2, 0);
          group.add(outerTub);

          // Inner basin (recessed)
          const innerW = w - wallThickness * 2;
          const innerH = tubH - 0.15;
          const innerD = d - wallThickness * 2;
          const innerTub = new THREE.Mesh(
            new THREE.BoxGeometry(innerW, innerH, innerD),
            innerMat
          );
          innerTub.position.set(0, (tubH - innerH) / 2 + tubH / 2 - h / 2, 0);
          group.add(innerTub);

          // Rim
          const rimMat = new THREE.MeshStandardMaterial({ color: 0xFAFAFA, roughness: 0.08 });
          const rim = new THREE.Mesh(
            new THREE.BoxGeometry(w + 0.02, 0.08, d + 0.02),
            rimMat
          );
          rim.position.set(0, tubH + 0.04 - h / 2, 0);
          group.add(rim);

          // Faucet
          const faucetBase = new THREE.Mesh(
            new THREE.CylinderGeometry(0.05, 0.06, 0.08, 16),
            chromeMat
          );
          faucetBase.position.set(0, tubH + 0.1 - h / 2, -d / 2 + 0.2);
          group.add(faucetBase);

          const spout = new THREE.Mesh(
            new THREE.CylinderGeometry(0.025, 0.025, 0.25, 12),
            chromeMat
          );
          spout.rotation.x = Math.PI / 2;
          spout.position.set(0, tubH + 0.15 - h / 2, -d / 2 + 0.32);
          group.add(spout);

          // Drain
          const drainMat = new THREE.MeshStandardMaterial({ color: 0x808080, metalness: 0.7, roughness: 0.3 });
          const drain = new THREE.Mesh(
            new THREE.CylinderGeometry(0.03, 0.03, 0.02, 16),
            drainMat
          );
          drain.position.set(0, 0.1 - h / 2, d / 4);
          group.add(drain);

          if (isFreestanding) {
            // Feet for freestanding tub
            const footMat = new THREE.MeshStandardMaterial({ color: 0xB8860B, roughness: 0.4, metalness: 0.5 });
            const footPositions = [[-w/2 + 0.15, -d/2 + 0.15], [-w/2 + 0.15, d/2 - 0.15], [w/2 - 0.15, -d/2 + 0.15], [w/2 - 0.15, d/2 - 0.15]];
            footPositions.forEach(([fx, fz]) => {
              const foot = new THREE.Mesh(new THREE.SphereGeometry(0.08, 12, 12), footMat);
              foot.position.set(fx, -h / 2 + 0.04, fz);
              group.add(foot);
            });
          }

          break;
        }

        case 'bathtub-corner': {
          // Corner bathtub (triangular/quarter-circle shape)
          const tubMat = new THREE.MeshStandardMaterial({
            color: 0xFFFFFF,
            roughness: 0.1,
            metalness: 0.05
          });
          const innerMat = new THREE.MeshStandardMaterial({
            color: 0xE8F0F8,
            roughness: 0.15
          });
          const chromeMat = new THREE.MeshStandardMaterial({
            color: 0xC0C0C0,
            roughness: 0.1,
            metalness: 0.9
          });

          const tubH = 1.5;
          const wallThickness = 0.08;

          // Create quarter-cylinder shape for corner tub
          const outerRadius = Math.min(w, d) / 2;
          const outerGeom = new THREE.CylinderGeometry(outerRadius, outerRadius, tubH, 16, 1, false, 0, Math.PI / 2);
          const outerTub = new THREE.Mesh(outerGeom, tubMat);
          outerTub.rotation.y = Math.PI;
          outerTub.position.set(-w / 2 + outerRadius, tubH / 2 - h / 2, d / 2 - outerRadius);
          group.add(outerTub);

          // Back walls (to fill the corner)
          const backWall1 = new THREE.Mesh(
            new THREE.BoxGeometry(wallThickness, tubH, d),
            tubMat
          );
          backWall1.position.set(-w / 2 + wallThickness / 2, tubH / 2 - h / 2, 0);
          group.add(backWall1);

          const backWall2 = new THREE.Mesh(
            new THREE.BoxGeometry(w, tubH, wallThickness),
            tubMat
          );
          backWall2.position.set(0, tubH / 2 - h / 2, d / 2 - wallThickness / 2);
          group.add(backWall2);

          // Rim
          const rimMat = new THREE.MeshStandardMaterial({ color: 0xFAFAFA, roughness: 0.08 });
          const rimGeom = new THREE.TorusGeometry(outerRadius - 0.05, 0.05, 8, 12, Math.PI / 2);
          const rim = new THREE.Mesh(rimGeom, rimMat);
          rim.rotation.x = Math.PI / 2;
          rim.rotation.z = Math.PI;
          rim.position.set(-w / 2 + outerRadius, tubH + 0.02 - h / 2, d / 2 - outerRadius);
          group.add(rim);

          // Drain
          const drainMat = new THREE.MeshStandardMaterial({ color: 0x808080, metalness: 0.7, roughness: 0.3 });
          const drain = new THREE.Mesh(
            new THREE.CylinderGeometry(0.04, 0.04, 0.02, 12),
            drainMat
          );
          drain.position.set(0, 0.1 - h / 2, 0);
          group.add(drain);

          // Faucet (corner position)
          const faucetBase = new THREE.Mesh(
            new THREE.CylinderGeometry(0.04, 0.05, 0.08, 12),
            chromeMat
          );
          faucetBase.position.set(-w / 2 + 0.3, tubH + 0.08 - h / 2, d / 2 - 0.3);
          group.add(faucetBase);

          break;
        }

        case 'bathtub-walk-in': {
          // Walk-in bathtub with door
          const tubMat = new THREE.MeshStandardMaterial({
            color: 0xF5F5F5,
            roughness: 0.15,
            metalness: 0.05
          });
          const innerMat = new THREE.MeshStandardMaterial({
            color: 0xE8E8E8,
            roughness: 0.2
          });
          const chromeMat = new THREE.MeshStandardMaterial({
            color: 0xC0C0C0,
            roughness: 0.1,
            metalness: 0.9
          });
          const seatMat = new THREE.MeshStandardMaterial({
            color: 0xF0F0F0,
            roughness: 0.25
          });

          const tubH = 2.8; // Higher walls for walk-in
          const wallThickness = 0.1;

          // Outer shell
          const outerTub = new THREE.Mesh(
            new THREE.BoxGeometry(w, tubH, d),
            tubMat
          );
          outerTub.position.set(0, tubH / 2 - h / 2, 0);
          group.add(outerTub);

          // Inner basin
          const innerW = w - wallThickness * 2;
          const innerH = tubH - 0.15;
          const innerD = d - wallThickness * 2;
          const innerTub = new THREE.Mesh(
            new THREE.BoxGeometry(innerW, innerH, innerD),
            innerMat
          );
          innerTub.position.set(0, (tubH - innerH) / 2 + tubH / 2 - h / 2, 0);
          group.add(innerTub);

          // Built-in seat
          const seatW = w * 0.4;
          const seatH = 1.2;
          const seatD = d - wallThickness * 2;
          const seat = new THREE.Mesh(
            new THREE.BoxGeometry(seatW, seatH, seatD),
            seatMat
          );
          seat.position.set(-w / 2 + wallThickness + seatW / 2, seatH / 2 - h / 2 + 0.1, 0);
          group.add(seat);

          // Door (on front side)
          const doorMat = new THREE.MeshStandardMaterial({
            color: 0xE0E0E0,
            roughness: 0.2,
            metalness: 0.1
          });
          const doorW = w * 0.5;
          const doorH = tubH * 0.85;
          const door = new THREE.Mesh(
            new THREE.BoxGeometry(doorW, doorH, 0.05),
            doorMat
          );
          door.position.set(w * 0.1, doorH / 2 - h / 2, d / 2);
          group.add(door);

          // Door frame
          const frameMat = new THREE.MeshStandardMaterial({ color: 0xA0A0A0, roughness: 0.3 });
          const doorFrame = new THREE.Mesh(
            new THREE.BoxGeometry(doorW + 0.08, doorH + 0.08, 0.03),
            frameMat
          );
          doorFrame.position.set(w * 0.1, doorH / 2 - h / 2, d / 2 + 0.04);
          group.add(doorFrame);

          // Door handle
          const handleMesh = new THREE.Mesh(
            new THREE.BoxGeometry(0.08, 0.2, 0.05),
            chromeMat
          );
          handleMesh.position.set(w * 0.1 + doorW / 3, tubH * 0.4 - h / 2, d / 2 + 0.08);
          group.add(handleMesh);

          // Rim
          const rim = new THREE.Mesh(
            new THREE.BoxGeometry(w + 0.02, 0.06, d + 0.02),
            tubMat
          );
          rim.position.set(0, tubH + 0.03 - h / 2, 0);
          group.add(rim);

          break;
        }

        case 'shower-base-36':
        case 'shower-base-48':
        case 'shower-base-60': {
          // Shower base/pan
          const baseMat = new THREE.MeshStandardMaterial({
            color: 0xE0E0E0,
            roughness: 0.35
          });
          const drainMat = new THREE.MeshStandardMaterial({
            color: 0x808080,
            roughness: 0.3,
            metalness: 0.6
          });

          const baseH = 0.12;
          const curbH = 0.15;

          // Main base
          const base = new THREE.Mesh(
            new THREE.BoxGeometry(w, baseH, d),
            baseMat
          );
          base.position.set(0, baseH / 2 - h / 2, 0);
          group.add(base);

          // Curb (threshold)
          const curb = new THREE.Mesh(
            new THREE.BoxGeometry(w, curbH, 0.1),
            baseMat
          );
          curb.position.set(0, curbH / 2 - h / 2, d / 2 - 0.05);
          group.add(curb);

          // Drain
          const isLarge = el.type === 'shower-base-48';
          const drainX = isLarge ? w * 0.2 : 0;
          const drain = new THREE.Mesh(
            new THREE.CylinderGeometry(0.05, 0.05, 0.02, 12),
            drainMat
          );
          drain.position.set(drainX, baseH + 0.01 - h / 2, 0);
          group.add(drain);

          // Drain grate
          const grateMat = new THREE.MeshStandardMaterial({ color: 0x606060, metalness: 0.7 });
          for (let i = -2; i <= 2; i++) {
            const grateBar = new THREE.Mesh(
              new THREE.BoxGeometry(0.005, 0.01, 0.08),
              grateMat
            );
            grateBar.position.set(drainX + i * 0.015, baseH + 0.02 - h / 2, 0);
            group.add(grateBar);
          }

          // Non-slip texture (subtle bumps)
          const bumpMat = new THREE.MeshStandardMaterial({ color: 0xD8D8D8, roughness: 0.5 });
          for (let bx = -w / 2 + 0.15; bx < w / 2 - 0.1; bx += 0.2) {
            for (let bz = -d / 2 + 0.15; bz < d / 2 - 0.15; bz += 0.2) {
              if (Math.abs(bx - drainX) > 0.1 || Math.abs(bz) > 0.1) {
                const bump = new THREE.Mesh(
                  new THREE.SphereGeometry(0.015, 6, 6),
                  bumpMat
                );
                bump.position.set(bx, baseH + 0.01 - h / 2, bz);
                group.add(bump);
              }
            }
          }

          break;
        }

        case 'vanity-24':
        case 'vanity-30':
        case 'vanity-36':
        case 'vanity-48':
        case 'vanity-60':
        case 'vanity-72':
        case 'vanity-double-60':
        case 'vanity-double-72':
        case 'vanity-double-84':
        case 'vanity-hishers-96':
        case 'vanity-hishers-108':
        case 'powder-table':
        case 'makeup-vanity':
        case 'pedestal-sink':
        case 'linen-closet':
        case 'linen-tower': {
          // Bathroom vanity with sink and mirror
          const vanityMat = new THREE.MeshStandardMaterial({
            color: el.color ? parseInt(el.color.replace('#', ''), 16) : 0x8B7355,
            roughness: 0.6
          });
          const counterMat = new THREE.MeshStandardMaterial({
            color: 0xE8E0D8,
            roughness: 0.25
          });
          const sinkMat = new THREE.MeshStandardMaterial({
            color: 0xFFFFFF,
            roughness: 0.1
          });
          const chromeMat = new THREE.MeshStandardMaterial({
            color: 0xC0C0C0,
            roughness: 0.1,
            metalness: 0.9
          });

          const cabinetH = 2.5;
          const counterH = 0.1;
          const counterOverhang = 0.05;

          // Cabinet body
          const cabinet = new THREE.Mesh(
            new THREE.BoxGeometry(w, cabinetH, d),
            vanityMat
          );
          cabinet.position.set(0, cabinetH / 2 - h / 2, 0);
          group.add(cabinet);

          // Cabinet doors
          const doorMat = new THREE.MeshStandardMaterial({
            color: adjustColorBrightness(el.color ? parseInt(el.color.replace('#', ''), 16) : 0x8B7355, -15),
            roughness: 0.5
          });
          const numDoors = w > 4 ? Math.floor(w / 1.5) : (w > 2 ? 2 : 1);
          const doorW = (w - 0.1) / numDoors;
          for (let di = 0; di < numDoors; di++) {
            const door = new THREE.Mesh(
              new THREE.BoxGeometry(doorW - 0.04, cabinetH - 0.1, 0.03),
              doorMat
            );
            door.position.set(-w / 2 + doorW / 2 + di * doorW + 0.02, cabinetH / 2 - h / 2, d / 2 + 0.02);
            group.add(door);

            // Door handle
            const handleBar = new THREE.Mesh(
              new THREE.BoxGeometry(0.08, 0.02, 0.02),
              chromeMat
            );
            handleBar.position.set(-w / 2 + doorW / 2 + di * doorW + 0.02, cabinetH * 0.6 - h / 2, d / 2 + 0.05);
            group.add(handleBar);
          }

          // Countertop
          const counter = new THREE.Mesh(
            new THREE.BoxGeometry(w + counterOverhang * 2, counterH, d + counterOverhang),
            counterMat
          );
          counter.position.set(0, cabinetH + counterH / 2 - h / 2, counterOverhang / 2);
          group.add(counter);

          // Sink basin(s)
          const isDouble = w >= 5;
          const sinkW = isDouble ? w * 0.35 : w * 0.6;
          const sinkPositions = isDouble ? [-w / 4, w / 4] : [0];

          sinkPositions.forEach(sx => {
            // Basin
            const basin = new THREE.Mesh(
              new THREE.BoxGeometry(sinkW, 0.15, d * 0.5),
              sinkMat
            );
            basin.position.set(sx, cabinetH + 0.02 - h / 2, 0);
            group.add(basin);

            // Faucet
            const faucetBase = new THREE.Mesh(
              new THREE.CylinderGeometry(0.025, 0.03, 0.05, 12),
              chromeMat
            );
            faucetBase.position.set(sx, cabinetH + counterH + 0.03 - h / 2, -d / 4);
            group.add(faucetBase);

            const faucetArm = new THREE.Mesh(
              new THREE.CylinderGeometry(0.015, 0.015, 0.15, 8),
              chromeMat
            );
            faucetArm.position.set(sx, cabinetH + counterH + 0.1 - h / 2, -d / 4);
            group.add(faucetArm);

            const faucetSpout = new THREE.Mesh(
              new THREE.CylinderGeometry(0.012, 0.012, 0.12, 8),
              chromeMat
            );
            faucetSpout.rotation.x = Math.PI / 3;
            faucetSpout.position.set(sx, cabinetH + counterH + 0.16 - h / 2, -d / 4 + 0.06);
            group.add(faucetSpout);
          });

          break;
        }

        case 'shower-bench': {
          // Built-in shower bench
          const benchMat = new THREE.MeshStandardMaterial({
            color: el.color ? parseInt(el.color.replace('#', ''), 16) : 0xD4D4D4,
            roughness: 0.3
          });
          const legMat = new THREE.MeshStandardMaterial({
            color: 0xC0C0C0,
            roughness: 0.3,
            metalness: 0.4
          });

          const benchH = 1.3;
          const seatH = 0.12;
          const seatD = d;

          // Seat top
          const seat = new THREE.Mesh(
            new THREE.BoxGeometry(w, seatH, seatD),
            benchMat
          );
          seat.position.set(0, benchH - h / 2, 0);
          group.add(seat);

          // Support structure
          const supportH = benchH - seatH;
          const support = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.1, supportH, seatD - 0.1),
            benchMat
          );
          support.position.set(0, supportH / 2 - h / 2, 0);
          group.add(support);

          break;
        }

        case 'towel-warmer': {
          // Electric towel warmer rack
          const metalMat = new THREE.MeshStandardMaterial({
            color: 0xC0C0C0,
            roughness: 0.2,
            metalness: 0.85
          });

          const barSpacing = 0.25;
          const numBars = Math.floor((h - 0.3) / barSpacing);
          const barRadius = 0.02;

          // Side rails
          [-1, 1].forEach(side => {
            const rail = new THREE.Mesh(
              new THREE.CylinderGeometry(barRadius, barRadius, h - 0.1, 12),
              metalMat
            );
            rail.position.set(side * (w / 2 - barRadius * 2), 0, 0);
            group.add(rail);
          });

          // Horizontal bars
          for (let bi = 0; bi < numBars; bi++) {
            const barY = -h / 2 + 0.15 + bi * barSpacing;
            const bar = new THREE.Mesh(
              new THREE.CylinderGeometry(barRadius, barRadius, w - barRadius * 4, 12),
              metalMat
            );
            bar.rotation.z = Math.PI / 2;
            bar.position.set(0, barY, 0);
            group.add(bar);
          }

          // Mounting brackets
          const bracketMat = new THREE.MeshStandardMaterial({ color: 0x888888, roughness: 0.3, metalness: 0.6 });
          [-1, 1].forEach(side => {
            const bracket = new THREE.Mesh(
              new THREE.BoxGeometry(0.08, 0.08, 0.04),
              bracketMat
            );
            bracket.position.set(side * (w / 2 - 0.04), h / 3, -d / 2 - 0.01);
            group.add(bracket);
          });

          break;
        }

        // ===== LAUNDRY ELEMENTS =====
        case 'washer': {
          // Front-loading washing machine
          const bodyMat = new THREE.MeshStandardMaterial({
            color: 0xF0F0F0,
            roughness: 0.3,
            metalness: 0.1
          });
          const doorMat = new THREE.MeshStandardMaterial({
            color: 0xE0E0E0,
            roughness: 0.2,
            metalness: 0.15
          });
          const glassMat = new THREE.MeshStandardMaterial({
            color: 0x4a6080,
            transparent: true,
            opacity: 0.6,
            roughness: 0.1
          });
          const chromeMat = new THREE.MeshStandardMaterial({
            color: 0xC0C0C0,
            roughness: 0.1,
            metalness: 0.9
          });

          // Main body
          const body = new THREE.Mesh(
            new THREE.BoxGeometry(w, h, d),
            bodyMat
          );
          group.add(body);

          // Door frame (circle)
          const doorRadius = Math.min(w, h) * 0.35;
          const doorFrame = new THREE.Mesh(
            new THREE.TorusGeometry(doorRadius, 0.04, 12, 24),
            doorMat
          );
          doorFrame.position.set(0, -0.1, d / 2 + 0.01);
          group.add(doorFrame);

          // Door glass
          const glass = new THREE.Mesh(
            new THREE.CircleGeometry(doorRadius - 0.04, 24),
            glassMat
          );
          glass.position.set(0, -0.1, d / 2 + 0.02);
          group.add(glass);

          // Control panel (top)
          const panelMat = new THREE.MeshStandardMaterial({ color: 0x2a2a2a, roughness: 0.4 });
          const panel = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.1, 0.15, d * 0.5),
            panelMat
          );
          panel.position.set(0, h / 2 - 0.1, -d / 4);
          group.add(panel);

          // Dial
          const dial = new THREE.Mesh(
            new THREE.CylinderGeometry(0.06, 0.06, 0.03, 16),
            chromeMat
          );
          dial.rotation.x = Math.PI / 2;
          dial.position.set(-w / 4, h / 2 - 0.08, -d / 4 + d * 0.25 + 0.02);
          group.add(dial);

          // Display
          const displayMat = new THREE.MeshStandardMaterial({ color: 0x004400, emissive: 0x002200 });
          const display = new THREE.Mesh(
            new THREE.BoxGeometry(0.2, 0.06, 0.01),
            displayMat
          );
          display.position.set(w / 6, h / 2 - 0.08, -d / 4 + d * 0.25 + 0.02);
          group.add(display);

          // Door handle
          const handle = new THREE.Mesh(
            new THREE.BoxGeometry(0.08, 0.25, 0.04),
            chromeMat
          );
          handle.position.set(w / 2 - 0.15, -0.1, d / 2 + 0.03);
          group.add(handle);

          break;
        }

        case 'dryer': {
          // Front-loading dryer (similar to washer but with vent)
          const bodyMat = new THREE.MeshStandardMaterial({
            color: 0xE8E8E8,
            roughness: 0.3,
            metalness: 0.1
          });
          const doorMat = new THREE.MeshStandardMaterial({
            color: 0xD8D8D8,
            roughness: 0.2
          });
          const chromeMat = new THREE.MeshStandardMaterial({
            color: 0xC0C0C0,
            roughness: 0.1,
            metalness: 0.9
          });

          // Main body
          const body = new THREE.Mesh(
            new THREE.BoxGeometry(w, h, d),
            bodyMat
          );
          group.add(body);

          // Door (solid, not glass)
          const doorRadius = Math.min(w, h) * 0.35;
          const door = new THREE.Mesh(
            new THREE.CircleGeometry(doorRadius, 24),
            doorMat
          );
          door.position.set(0, -0.1, d / 2 + 0.01);
          group.add(door);

          // Door rim
          const doorRim = new THREE.Mesh(
            new THREE.TorusGeometry(doorRadius, 0.03, 12, 24),
            chromeMat
          );
          doorRim.position.set(0, -0.1, d / 2 + 0.02);
          group.add(doorRim);

          // Control panel
          const panelMat = new THREE.MeshStandardMaterial({ color: 0x3a3a3a, roughness: 0.4 });
          const panel = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.1, 0.15, d * 0.5),
            panelMat
          );
          panel.position.set(0, h / 2 - 0.1, -d / 4);
          group.add(panel);

          // Temperature dial
          const dial = new THREE.Mesh(
            new THREE.CylinderGeometry(0.06, 0.06, 0.03, 16),
            chromeMat
          );
          dial.rotation.x = Math.PI / 2;
          dial.position.set(-w / 4, h / 2 - 0.08, 0);
          group.add(dial);

          // Timer dial
          const timer = new THREE.Mesh(
            new THREE.CylinderGeometry(0.05, 0.05, 0.03, 16),
            chromeMat
          );
          timer.rotation.x = Math.PI / 2;
          timer.position.set(w / 4, h / 2 - 0.08, 0);
          group.add(timer);

          // Door handle
          const handle = new THREE.Mesh(
            new THREE.BoxGeometry(0.08, 0.25, 0.04),
            chromeMat
          );
          handle.position.set(-w / 2 + 0.15, -0.1, d / 2 + 0.03);
          group.add(handle);

          // Vent (back)
          const ventMat = new THREE.MeshStandardMaterial({ color: 0x808080, roughness: 0.5 });
          const vent = new THREE.Mesh(
            new THREE.CylinderGeometry(0.08, 0.08, 0.1, 12),
            ventMat
          );
          vent.rotation.x = Math.PI / 2;
          vent.position.set(0, -h / 3, -d / 2 - 0.05);
          group.add(vent);

          break;
        }

        case 'utility-sink':
        case 'laundry-sink': {
          // Deep utility sink for laundry
          const sinkMat = new THREE.MeshStandardMaterial({
            color: 0xF5F5F5,
            roughness: 0.2
          });
          const basinMat = new THREE.MeshStandardMaterial({
            color: 0xE8E8E8,
            roughness: 0.25
          });
          const legMat = new THREE.MeshStandardMaterial({
            color: 0xC0C0C0,
            roughness: 0.3,
            metalness: 0.6
          });
          const chromeMat = new THREE.MeshStandardMaterial({
            color: 0xB0B0B0,
            roughness: 0.1,
            metalness: 0.9
          });

          const sinkH = 2.9;
          const basinH = 0.8;
          const rimH = 0.08;
          const wallThick = 0.08;

          // Basin (deep tub shape)
          const basinOuter = new THREE.Mesh(
            new THREE.BoxGeometry(w, basinH + rimH, d),
            sinkMat
          );
          basinOuter.position.set(0, sinkH - basinH / 2 - h / 2, 0);
          group.add(basinOuter);

          // Inner basin
          const basinInner = new THREE.Mesh(
            new THREE.BoxGeometry(w - wallThick * 2, basinH, d - wallThick * 2),
            basinMat
          );
          basinInner.position.set(0, sinkH - basinH / 2 + rimH / 2 - h / 2, 0);
          group.add(basinInner);

          // Legs
          const legH = sinkH - basinH - rimH;
          [[-1, -1], [-1, 1], [1, -1], [1, 1]].forEach(([lx, lz]) => {
            const leg = new THREE.Mesh(
              new THREE.BoxGeometry(0.08, legH, 0.08),
              legMat
            );
            leg.position.set(lx * (w / 2 - 0.08), legH / 2 - h / 2, lz * (d / 2 - 0.08));
            group.add(leg);
          });

          // Faucet
          const faucetBase = new THREE.Mesh(
            new THREE.CylinderGeometry(0.04, 0.05, 0.08, 12),
            chromeMat
          );
          faucetBase.position.set(0, sinkH + 0.05 - h / 2, -d / 2 + 0.15);
          group.add(faucetBase);

          const faucetArm = new THREE.Mesh(
            new THREE.CylinderGeometry(0.025, 0.025, 0.35, 8),
            chromeMat
          );
          faucetArm.position.set(0, sinkH + 0.25 - h / 2, -d / 2 + 0.15);
          group.add(faucetArm);

          const spout = new THREE.Mesh(
            new THREE.CylinderGeometry(0.02, 0.02, 0.25, 8),
            chromeMat
          );
          spout.rotation.x = Math.PI / 2.5;
          spout.position.set(0, sinkH + 0.4 - h / 2, -d / 2 + 0.28);
          group.add(spout);

          break;
        }

        case 'drying-rack': {
          // Wall-mounted or freestanding drying rack
          const frameMat = new THREE.MeshStandardMaterial({
            color: 0xE0E0E0,
            roughness: 0.4,
            metalness: 0.3
          });
          const rodMat = new THREE.MeshStandardMaterial({
            color: 0xC0C0C0,
            roughness: 0.25,
            metalness: 0.5
          });

          const numRods = 6;
          const rodSpacing = (h - 0.3) / numRods;
          const rodRadius = 0.015;

          // Side frames
          [-1, 1].forEach(side => {
            const frame = new THREE.Mesh(
              new THREE.BoxGeometry(0.05, h, 0.05),
              frameMat
            );
            frame.position.set(side * (w / 2 - 0.025), 0, 0);
            group.add(frame);
          });

          // Top bar
          const topBar = new THREE.Mesh(
            new THREE.BoxGeometry(w, 0.05, 0.05),
            frameMat
          );
          topBar.position.set(0, h / 2 - 0.025, 0);
          group.add(topBar);

          // Drying rods
          for (let ri = 0; ri < numRods; ri++) {
            const rod = new THREE.Mesh(
              new THREE.CylinderGeometry(rodRadius, rodRadius, w - 0.1, 8),
              rodMat
            );
            rod.rotation.z = Math.PI / 2;
            rod.position.set(0, -h / 2 + 0.15 + ri * rodSpacing, 0);
            group.add(rod);
          }

          break;
        }

        case 'washer-dryer-stack': {
          // Stacked washer/dryer unit
          const bodyMat = new THREE.MeshStandardMaterial({
            color: 0xF0F0F0,
            roughness: 0.3,
            metalness: 0.1
          });
          const glassMat = new THREE.MeshStandardMaterial({
            color: 0x4a6080,
            transparent: true,
            opacity: 0.6,
            roughness: 0.1
          });
          const chromeMat = new THREE.MeshStandardMaterial({
            color: 0xC0C0C0,
            roughness: 0.1,
            metalness: 0.9
          });

          const unitH = h * 2; // Stacked units are taller
          const singleH = unitH / 2;

          // Main body (full height)
          const body = new THREE.Mesh(
            new THREE.BoxGeometry(w, unitH, d),
            bodyMat
          );
          body.position.set(0, unitH / 2 - h / 2, 0);
          group.add(body);

          // Divider line between units
          const dividerMat = new THREE.MeshStandardMaterial({ color: 0xB0B0B0, roughness: 0.4 });
          const divider = new THREE.Mesh(
            new THREE.BoxGeometry(w + 0.02, 0.03, d + 0.02),
            dividerMat
          );
          divider.position.set(0, singleH - h / 2, 0);
          group.add(divider);

          // Bottom unit (washer) - glass door
          const washerDoorRadius = Math.min(w, singleH) * 0.35;
          const washerDoorFrame = new THREE.Mesh(
            new THREE.TorusGeometry(washerDoorRadius, 0.04, 12, 24),
            chromeMat
          );
          washerDoorFrame.position.set(0, singleH / 2 - h / 2, d / 2 + 0.01);
          group.add(washerDoorFrame);

          const washerGlass = new THREE.Mesh(
            new THREE.CircleGeometry(washerDoorRadius - 0.04, 24),
            glassMat
          );
          washerGlass.position.set(0, singleH / 2 - h / 2, d / 2 + 0.02);
          group.add(washerGlass);

          // Top unit (dryer) - solid door
          const dryerDoorMat = new THREE.MeshStandardMaterial({ color: 0xE0E0E0, roughness: 0.2 });
          const dryerDoor = new THREE.Mesh(
            new THREE.CircleGeometry(washerDoorRadius, 24),
            dryerDoorMat
          );
          dryerDoor.position.set(0, singleH + singleH / 2 - h / 2, d / 2 + 0.01);
          group.add(dryerDoor);

          const dryerRim = new THREE.Mesh(
            new THREE.TorusGeometry(washerDoorRadius, 0.03, 12, 24),
            chromeMat
          );
          dryerRim.position.set(0, singleH + singleH / 2 - h / 2, d / 2 + 0.02);
          group.add(dryerRim);

          // Control panels
          const panelMat = new THREE.MeshStandardMaterial({ color: 0x2a2a2a, roughness: 0.4 });
          // Washer panel
          const washerPanel = new THREE.Mesh(
            new THREE.BoxGeometry(w * 0.5, 0.1, 0.02),
            panelMat
          );
          washerPanel.position.set(w * 0.2, singleH - 0.12 - h / 2, d / 2 + 0.02);
          group.add(washerPanel);

          // Dryer panel
          const dryerPanel = new THREE.Mesh(
            new THREE.BoxGeometry(w * 0.5, 0.1, 0.02),
            panelMat
          );
          dryerPanel.position.set(w * 0.2, unitH - 0.12 - h / 2, d / 2 + 0.02);
          group.add(dryerPanel);

          break;
        }

        case 'laundry-cabinet': {
          // Laundry room cabinet/storage
          const cabinetMat = new THREE.MeshStandardMaterial({
            color: el.color ? parseInt(el.color.replace('#', ''), 16) : 0x8B7355,
            roughness: 0.6
          });
          const counterMat = new THREE.MeshStandardMaterial({
            color: 0xE8E0D8,
            roughness: 0.25
          });
          const chromeMat = new THREE.MeshStandardMaterial({
            color: 0xC0C0C0,
            roughness: 0.15,
            metalness: 0.8
          });

          const cabinetH = 2.8;
          const counterH = 0.08;

          // Main cabinet body
          const cabinet = new THREE.Mesh(
            new THREE.BoxGeometry(w, cabinetH, d),
            cabinetMat
          );
          cabinet.position.set(0, cabinetH / 2 - h / 2, 0);
          group.add(cabinet);

          // Counter top
          const counter = new THREE.Mesh(
            new THREE.BoxGeometry(w + 0.04, counterH, d + 0.04),
            counterMat
          );
          counter.position.set(0, cabinetH + counterH / 2 - h / 2, 0);
          group.add(counter);

          // Door split (vertical line in front)
          const splitMat = new THREE.MeshStandardMaterial({ color: 0x5C4A3A, roughness: 0.5 });
          const split = new THREE.Mesh(
            new THREE.BoxGeometry(0.02, cabinetH - 0.1, 0.01),
            splitMat
          );
          split.position.set(0, cabinetH / 2 - h / 2, d / 2 + 0.01);
          group.add(split);

          // Handles
          [-1, 1].forEach(side => {
            const handle = new THREE.Mesh(
              new THREE.BoxGeometry(0.03, 0.15, 0.03),
              chromeMat
            );
            handle.position.set(side * 0.08, cabinetH / 2 - h / 2, d / 2 + 0.04);
            group.add(handle);
          });

          break;
        }

        case 'ironing-board': {
          // Freestanding ironing board
          const boardMat = new THREE.MeshStandardMaterial({
            color: 0xD0D0D0,
            roughness: 0.4
          });
          const legMat = new THREE.MeshStandardMaterial({
            color: 0x808080,
            roughness: 0.3,
            metalness: 0.5
          });
          const coverMat = new THREE.MeshStandardMaterial({
            color: 0xE8E8F0,
            roughness: 0.6
          });

          const boardH = 0.05;
          const boardY = 2.8; // Standard ironing height

          // Board surface (tapered shape - narrower at one end)
          const boardShape = new THREE.Shape();
          const narrowW = w * 0.35;
          const wideW = w * 0.9;
          boardShape.moveTo(-narrowW / 2, -d / 2);
          boardShape.lineTo(narrowW / 2, -d / 2);
          boardShape.lineTo(wideW / 2, d / 2);
          boardShape.lineTo(-wideW / 2, d / 2);
          boardShape.closePath();

          const extrudeSettings = { depth: boardH, bevelEnabled: false };
          const boardGeom = new THREE.ExtrudeGeometry(boardShape, extrudeSettings);
          const board = new THREE.Mesh(boardGeom, coverMat);
          board.rotation.x = -Math.PI / 2;
          board.position.set(0, boardY - h / 2, 0);
          group.add(board);

          // Legs (X-frame)
          const legRadius = 0.02;
          const legLength = boardY + 0.3;

          // Front legs (forming X)
          const leg1 = new THREE.Mesh(
            new THREE.CylinderGeometry(legRadius, legRadius, legLength, 8),
            legMat
          );
          leg1.rotation.z = 0.15;
          leg1.position.set(-w * 0.15, boardY / 2 - h / 2 - 0.1, d * 0.2);
          group.add(leg1);

          const leg2 = new THREE.Mesh(
            new THREE.CylinderGeometry(legRadius, legRadius, legLength, 8),
            legMat
          );
          leg2.rotation.z = -0.15;
          leg2.position.set(w * 0.15, boardY / 2 - h / 2 - 0.1, d * 0.2);
          group.add(leg2);

          // Cross brace
          const brace = new THREE.Mesh(
            new THREE.CylinderGeometry(legRadius * 0.8, legRadius * 0.8, w * 0.5, 8),
            legMat
          );
          brace.rotation.z = Math.PI / 2;
          brace.position.set(0, boardY * 0.4 - h / 2, d * 0.2);
          group.add(brace);

          // Iron rest (at narrow end)
          const restMat = new THREE.MeshStandardMaterial({ color: 0x606060, roughness: 0.4, metalness: 0.3 });
          const rest = new THREE.Mesh(
            new THREE.BoxGeometry(w * 0.25, 0.02, 0.15),
            restMat
          );
          rest.position.set(0, boardY + 0.04 - h / 2, -d / 2 + 0.1);
          group.add(rest);

          break;
        }

        // ===== CLOSET ELEMENTS =====
        case 'closet-rod': {
          // Clothing rod for hanging clothes
          const rodMat = new THREE.MeshStandardMaterial({
            color: 0xC0C0C0,
            roughness: 0.2,
            metalness: 0.8
          });
          const bracketMat = new THREE.MeshStandardMaterial({
            color: 0x808080,
            roughness: 0.3,
            metalness: 0.6
          });

          const rodRadius = 0.0625; // 1.5" diameter rod
          const bracketW = 0.12;

          // Main rod
          const rod = new THREE.Mesh(
            new THREE.CylinderGeometry(rodRadius, rodRadius, w, 16),
            rodMat
          );
          rod.rotation.z = Math.PI / 2;
          group.add(rod);

          // End brackets
          [-1, 1].forEach(side => {
            const bracket = new THREE.Mesh(
              new THREE.BoxGeometry(bracketW, 0.1, 0.08),
              bracketMat
            );
            bracket.position.set(side * (w / 2 - bracketW / 2), 0, -0.06);
            group.add(bracket);
          });

          break;
        }

        case 'closet-shelf': {
          // Wire or solid closet shelf
          const shelfMat = new THREE.MeshStandardMaterial({
            color: el.color ? parseInt(el.color.replace('#', ''), 16) : 0xE8E8E8,
            roughness: 0.4
          });

          const shelfH = 0.03; // Thin shelf

          // Solid shelf
          const shelf = new THREE.Mesh(
            new THREE.BoxGeometry(w, shelfH, d),
            shelfMat
          );
          group.add(shelf);

          // Front lip
          const lipMat = new THREE.MeshStandardMaterial({
            color: adjustColorBrightness(el.color ? parseInt(el.color.replace('#', ''), 16) : 0xE8E8E8, -10),
            roughness: 0.35
          });
          const lip = new THREE.Mesh(
            new THREE.BoxGeometry(w, 0.05, 0.02),
            lipMat
          );
          lip.position.set(0, -0.01, d / 2 + 0.01);
          group.add(lip);

          break;
        }

        case 'closet-drawers': // Alias for drawer-unit
        case 'drawer-unit': {
          // Multi-drawer storage unit for closets
          const bodyMat = new THREE.MeshStandardMaterial({
            color: el.color ? parseInt(el.color.replace('#', ''), 16) : 0xF5F0E6,
            roughness: 0.6
          });
          const drawerMat = new THREE.MeshStandardMaterial({
            color: adjustColorBrightness(el.color ? parseInt(el.color.replace('#', ''), 16) : 0xF5F0E6, -10),
            roughness: 0.5
          });
          const handleMat = new THREE.MeshStandardMaterial({
            color: 0xC0C0C0,
            roughness: 0.2,
            metalness: 0.7
          });

          const numDrawers = Math.max(3, Math.floor(h / 0.6));
          const drawerH = (h - 0.1) / numDrawers;
          const drawerGap = 0.02;

          // Body
          const body = new THREE.Mesh(
            new THREE.BoxGeometry(w, h, d),
            bodyMat
          );
          group.add(body);

          // Drawers
          for (let di = 0; di < numDrawers; di++) {
            const drawerY = h / 2 - drawerH / 2 - di * drawerH - 0.05;

            // Drawer front
            const drawer = new THREE.Mesh(
              new THREE.BoxGeometry(w - 0.04, drawerH - drawerGap, 0.03),
              drawerMat
            );
            drawer.position.set(0, drawerY, d / 2 + 0.02);
            group.add(drawer);

            // Handle
            const handle = new THREE.Mesh(
              new THREE.BoxGeometry(w * 0.3, 0.03, 0.03),
              handleMat
            );
            handle.position.set(0, drawerY, d / 2 + 0.05);
            group.add(handle);
          }

          break;
        }

        case 'shoe-rack': {
          // Angled shoe rack/cubby
          const frameMat = new THREE.MeshStandardMaterial({
            color: el.color ? parseInt(el.color.replace('#', ''), 16) : 0xDEB887,
            roughness: 0.6
          });
          const shelfMat = new THREE.MeshStandardMaterial({
            color: adjustColorBrightness(el.color ? parseInt(el.color.replace('#', ''), 16) : 0xDEB887, 10),
            roughness: 0.5
          });

          const numShelves = Math.max(3, Math.floor(h / 0.5));
          const shelfSpacing = h / numShelves;
          const shelfAngle = Math.PI / 12; // 15 degrees

          // Side panels
          [-1, 1].forEach(side => {
            const sidePanel = new THREE.Mesh(
              new THREE.BoxGeometry(0.03, h, d),
              frameMat
            );
            sidePanel.position.set(side * (w / 2 - 0.015), 0, 0);
            group.add(sidePanel);
          });

          // Angled shelves
          for (let si = 0; si < numShelves; si++) {
            const shelfY = -h / 2 + shelfSpacing * (si + 0.5);
            const shelf = new THREE.Mesh(
              new THREE.BoxGeometry(w - 0.08, 0.02, d - 0.05),
              shelfMat
            );
            shelf.position.set(0, shelfY, 0);
            shelf.rotation.x = -shelfAngle;
            group.add(shelf);

            // Front lip to keep shoes in place
            const lip = new THREE.Mesh(
              new THREE.BoxGeometry(w - 0.08, 0.04, 0.02),
              shelfMat
            );
            lip.position.set(0, shelfY - 0.05, d / 2 - 0.05);
            group.add(lip);
          }

          break;
        }

        case 'closet-island': {
          // Center island with drawers and top surface
          const bodyMat = new THREE.MeshStandardMaterial({
            color: el.color ? parseInt(el.color.replace('#', ''), 16) : 0xF5F0E6,
            roughness: 0.5
          });
          const topMat = new THREE.MeshStandardMaterial({
            color: 0xE8E0D8,
            roughness: 0.25
          });
          const drawerMat = new THREE.MeshStandardMaterial({
            color: adjustColorBrightness(el.color ? parseInt(el.color.replace('#', ''), 16) : 0xF5F0E6, -15),
            roughness: 0.45
          });
          const handleMat = new THREE.MeshStandardMaterial({
            color: 0xB8860B,
            roughness: 0.25,
            metalness: 0.6
          });

          const baseH = h - 0.12;
          const topH = 0.1;

          // Main body
          const body = new THREE.Mesh(
            new THREE.BoxGeometry(w, baseH, d),
            bodyMat
          );
          body.position.set(0, -topH / 2, 0);
          group.add(body);

          // Top surface
          const top = new THREE.Mesh(
            new THREE.BoxGeometry(w + 0.08, topH, d + 0.08),
            topMat
          );
          top.position.set(0, h / 2 - topH / 2, 0);
          group.add(top);

          // Drawers on all four sides
          const drawerH = baseH / 3 - 0.02;
          for (let di = 0; di < 3; di++) {
            const drawerY = h / 2 - topH - drawerH / 2 - di * (drawerH + 0.02) - 0.02;

            // Front drawers
            const frontDrawer = new THREE.Mesh(
              new THREE.BoxGeometry(w / 2 - 0.04, drawerH - 0.02, 0.03),
              drawerMat
            );
            frontDrawer.position.set(0, drawerY, d / 2 + 0.02);
            group.add(frontDrawer);

            // Front handle
            const frontHandle = new THREE.Mesh(
              new THREE.CylinderGeometry(0.015, 0.015, 0.1, 8),
              handleMat
            );
            frontHandle.rotation.z = Math.PI / 2;
            frontHandle.position.set(0, drawerY, d / 2 + 0.05);
            group.add(frontHandle);
          }

          break;
        }

        case 'jewelry-drawer': // Alias for jewelry-cabinet
        case 'jewelry-cabinet': {
          // Mirrored jewelry cabinet
          const bodyMat = new THREE.MeshStandardMaterial({
            color: el.color ? parseInt(el.color.replace('#', ''), 16) : 0xF5F0E6,
            roughness: 0.4
          });
          const mirrorMat = new THREE.MeshStandardMaterial({
            color: 0xE8F0F8,
            roughness: 0.05,
            metalness: 0.9
          });
          const frameMat = new THREE.MeshStandardMaterial({
            color: 0xB8860B,
            roughness: 0.3,
            metalness: 0.5
          });
          const velvetMat = new THREE.MeshStandardMaterial({
            color: 0x4a0020,
            roughness: 0.9
          });

          // Cabinet body
          const cabinet = new THREE.Mesh(
            new THREE.BoxGeometry(w, h, d),
            bodyMat
          );
          group.add(cabinet);

          // Mirror on front
          const mirrorH = h - 0.15;
          const mirrorW = w - 0.1;
          const mirror = new THREE.Mesh(
            new THREE.BoxGeometry(mirrorW, mirrorH, 0.02),
            mirrorMat
          );
          mirror.position.set(0, 0, d / 2 + 0.01);
          group.add(mirror);

          // Mirror frame
          const frameW = 0.04;
          // Top frame
          const topFrame = new THREE.Mesh(
            new THREE.BoxGeometry(mirrorW + frameW * 2, frameW, 0.03),
            frameMat
          );
          topFrame.position.set(0, mirrorH / 2, d / 2 + 0.02);
          group.add(topFrame);
          // Bottom frame
          const bottomFrame = new THREE.Mesh(
            new THREE.BoxGeometry(mirrorW + frameW * 2, frameW, 0.03),
            frameMat
          );
          bottomFrame.position.set(0, -mirrorH / 2, d / 2 + 0.02);
          group.add(bottomFrame);
          // Side frames
          [-1, 1].forEach(side => {
            const sideFrame = new THREE.Mesh(
              new THREE.BoxGeometry(frameW, mirrorH, 0.03),
              frameMat
            );
            sideFrame.position.set(side * (mirrorW / 2 + frameW / 2), 0, d / 2 + 0.02);
            group.add(sideFrame);
          });

          // Handle
          const handle = new THREE.Mesh(
            new THREE.BoxGeometry(0.04, 0.15, 0.04),
            frameMat
          );
          handle.position.set(w / 2 - 0.1, 0, d / 2 + 0.04);
          group.add(handle);

          break;
        }

        case 'tie-rack': {
          // Tie/belt rack with hooks and hanging items
          const barMat = new THREE.MeshStandardMaterial({
            color: 0xC0C0C0,
            roughness: 0.3,
            metalness: 0.6
          });
          const hookMat = new THREE.MeshStandardMaterial({
            color: 0x808080,
            roughness: 0.2,
            metalness: 0.8
          });

          // Main mounting bar
          const bar = new THREE.Mesh(
            new THREE.BoxGeometry(w, 0.08, 0.05),
            barMat
          );
          bar.position.set(0, h / 2 - 0.04, 0);
          group.add(bar);

          // Hooks
          const numHooks = Math.max(3, Math.floor(w / 0.15));
          const hookSpacing = w / (numHooks + 1);

          for (let hi = 1; hi <= numHooks; hi++) {
            const hookX = -w / 2 + hi * hookSpacing;

            // Hook cylinder
            const hook = new THREE.Mesh(
              new THREE.CylinderGeometry(0.015, 0.015, 0.12, 8),
              hookMat
            );
            hook.position.set(hookX, h / 2 - 0.1, 0.04);
            group.add(hook);

            // Hook end
            const hookEnd = new THREE.Mesh(
              new THREE.SphereGeometry(0.02, 8, 8),
              hookMat
            );
            hookEnd.position.set(hookX, h / 2 - 0.16, 0.04);
            group.add(hookEnd);

            // Add ties (decorative)
            if (hi <= 5) {
              const tieColors = [0x4169E1, 0xDC143C, 0x228B22, 0x8B4513, 0x4B0082];
              const tieMat = new THREE.MeshStandardMaterial({
                color: tieColors[(hi - 1) % 5],
                roughness: 0.7
              });

              // Tie shape (simplified as elongated box)
              const tie = new THREE.Mesh(
                new THREE.BoxGeometry(0.06, h - 0.25, 0.01),
                tieMat
              );
              tie.position.set(hookX, 0, 0.02);
              group.add(tie);

              // Tie knot
              const knot = new THREE.Mesh(
                new THREE.BoxGeometry(0.08, 0.06, 0.02),
                tieMat
              );
              knot.position.set(hookX, h / 2 - 0.2, 0.02);
              group.add(knot);
            }
          }

          break;
        }

        case 'full-mirror': {
          // Full-length standing mirror
          const frameMat = new THREE.MeshStandardMaterial({
            color: 0x8B7355,
            roughness: 0.5
          });
          const mirrorMat = new THREE.MeshStandardMaterial({
            color: 0xE8F0F8,
            roughness: 0.02,
            metalness: 0.95,
            envMapIntensity: 1.5
          });

          const frameThickness = 0.04;
          const mirrorDepth = 0.02;

          // Mirror surface
          const mirror = new THREE.Mesh(
            new THREE.BoxGeometry(w - frameThickness * 2, h - frameThickness * 2, mirrorDepth),
            mirrorMat
          );
          mirror.position.set(0, 0, d / 2 - mirrorDepth / 2);
          group.add(mirror);

          // Frame - top
          const topFrame = new THREE.Mesh(
            new THREE.BoxGeometry(w, frameThickness, d),
            frameMat
          );
          topFrame.position.set(0, h / 2 - frameThickness / 2, 0);
          group.add(topFrame);

          // Frame - bottom
          const bottomFrame = new THREE.Mesh(
            new THREE.BoxGeometry(w, frameThickness, d),
            frameMat
          );
          bottomFrame.position.set(0, -h / 2 + frameThickness / 2, 0);
          group.add(bottomFrame);

          // Frame - left
          const leftFrame = new THREE.Mesh(
            new THREE.BoxGeometry(frameThickness, h, d),
            frameMat
          );
          leftFrame.position.set(-w / 2 + frameThickness / 2, 0, 0);
          group.add(leftFrame);

          // Frame - right
          const rightFrame = new THREE.Mesh(
            new THREE.BoxGeometry(frameThickness, h, d),
            frameMat
          );
          rightFrame.position.set(w / 2 - frameThickness / 2, 0, 0);
          group.add(rightFrame);

          // Back panel
          const backMat = new THREE.MeshStandardMaterial({
            color: 0x4a4a4a,
            roughness: 0.8
          });
          const back = new THREE.Mesh(
            new THREE.BoxGeometry(w - frameThickness, h - frameThickness, 0.02),
            backMat
          );
          back.position.set(0, 0, -d / 2 + 0.01);
          group.add(back);

          break;
        }

        // ===== BATHROOM ACCESSORIES =====
        case 'shower-glass': {
          // Shower glass panel (fixed frameless glass)
          const glassMat = new THREE.MeshStandardMaterial({
            color: 0xE8F4FF,
            transparent: true,
            opacity: 0.3,
            roughness: 0.02,
            metalness: 0.1,
            side: THREE.DoubleSide
          });
          const frameMat = new THREE.MeshStandardMaterial({
            color: 0xC0C0C0,
            roughness: 0.2,
            metalness: 0.8
          });

          // Main glass panel
          const glassPanel = new THREE.Mesh(
            new THREE.BoxGeometry(w, h, 0.02),
            glassMat
          );
          group.add(glassPanel);

          // Top channel/rail
          const topRail = new THREE.Mesh(
            new THREE.BoxGeometry(w + 0.04, 0.04, 0.06),
            frameMat
          );
          topRail.position.set(0, h / 2, 0);
          group.add(topRail);

          // Bottom channel
          const bottomRail = new THREE.Mesh(
            new THREE.BoxGeometry(w + 0.04, 0.04, 0.06),
            frameMat
          );
          bottomRail.position.set(0, -h / 2, 0);
          group.add(bottomRail);

          break;
        }

        case 'shower-door': {
          // Hinged or sliding shower door
          const doorGlassMat = new THREE.MeshStandardMaterial({
            color: 0xE8F4FF,
            transparent: true,
            opacity: 0.35,
            roughness: 0.02,
            metalness: 0.1,
            side: THREE.DoubleSide
          });
          const doorFrameMat = new THREE.MeshStandardMaterial({
            color: 0xC0C0C0,
            roughness: 0.2,
            metalness: 0.8
          });

          // Glass door panel
          const doorPanel = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.08, h - 0.1, 0.02),
            doorGlassMat
          );
          group.add(doorPanel);

          // Door frame - vertical sides
          [-1, 1].forEach(side => {
            const frameBar = new THREE.Mesh(
              new THREE.BoxGeometry(0.04, h, 0.05),
              doorFrameMat
            );
            frameBar.position.set(side * (w / 2 - 0.02), 0, 0);
            group.add(frameBar);
          });

          // Frame - top and bottom
          [1, -1].forEach(pos => {
            const hBar = new THREE.Mesh(
              new THREE.BoxGeometry(w, 0.04, 0.05),
              doorFrameMat
            );
            hBar.position.set(0, pos * (h / 2 - 0.02), 0);
            group.add(hBar);
          });

          // Door handle
          const handleMat = new THREE.MeshStandardMaterial({ color: 0xA0A0A0, roughness: 0.2, metalness: 0.9 });
          const handle = new THREE.Mesh(
            new THREE.CylinderGeometry(0.015, 0.015, 0.3, 12),
            handleMat
          );
          handle.rotation.x = Math.PI / 2;
          handle.position.set(w / 2 - 0.1, 0, 0.04);
          group.add(handle);

          break;
        }

        case 'mirror': {
          // Wall-mounted bathroom mirror
          const mirrorSurfaceMat = new THREE.MeshStandardMaterial({
            color: 0xE8F0F8,
            roughness: 0.02,
            metalness: 0.95,
            envMapIntensity: 1.5
          });
          const mirrorFrameMat = new THREE.MeshStandardMaterial({
            color: 0xC0C0C0,
            roughness: 0.3,
            metalness: 0.5
          });

          const mFrameW = 0.03;

          // Mirror surface
          const mirrorSurface = new THREE.Mesh(
            new THREE.BoxGeometry(w - mFrameW * 2, h - mFrameW * 2, 0.01),
            mirrorSurfaceMat
          );
          mirrorSurface.position.set(0, 0, d / 2 - 0.005);
          group.add(mirrorSurface);

          // Frame pieces
          // Top
          const mFrameTop = new THREE.Mesh(new THREE.BoxGeometry(w, mFrameW, d), mirrorFrameMat);
          mFrameTop.position.set(0, h / 2 - mFrameW / 2, 0);
          group.add(mFrameTop);
          // Bottom
          const mFrameBottom = new THREE.Mesh(new THREE.BoxGeometry(w, mFrameW, d), mirrorFrameMat);
          mFrameBottom.position.set(0, -h / 2 + mFrameW / 2, 0);
          group.add(mFrameBottom);
          // Left
          const mFrameLeft = new THREE.Mesh(new THREE.BoxGeometry(mFrameW, h - mFrameW * 2, d), mirrorFrameMat);
          mFrameLeft.position.set(-w / 2 + mFrameW / 2, 0, 0);
          group.add(mFrameLeft);
          // Right
          const mFrameRight = new THREE.Mesh(new THREE.BoxGeometry(mFrameW, h - mFrameW * 2, d), mirrorFrameMat);
          mFrameRight.position.set(w / 2 - mFrameW / 2, 0, 0);
          group.add(mFrameRight);

          break;
        }

        case 'medicine-cabinet': {
          // Medicine cabinet with mirrored door
          const cabinetMat = new THREE.MeshStandardMaterial({
            color: 0xF5F5F5,
            roughness: 0.4
          });
          const medMirrorMat = new THREE.MeshStandardMaterial({
            color: 0xE8F0F8,
            roughness: 0.02,
            metalness: 0.95
          });
          const hingeMat = new THREE.MeshStandardMaterial({
            color: 0x808080,
            roughness: 0.3,
            metalness: 0.7
          });

          // Cabinet body
          const cabBody = new THREE.Mesh(
            new THREE.BoxGeometry(w, h, d),
            cabinetMat
          );
          group.add(cabBody);

          // Interior void
          const interior = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.06, h - 0.06, d - 0.04),
            new THREE.MeshStandardMaterial({ color: 0xE8E8E8, roughness: 0.6 })
          );
          interior.position.set(0, 0, 0.02);
          group.add(interior);

          // Mirrored door
          const doorMirror = new THREE.Mesh(
            new THREE.BoxGeometry(w - 0.02, h - 0.02, 0.02),
            medMirrorMat
          );
          doorMirror.position.set(0, 0, d / 2 + 0.01);
          group.add(doorMirror);

          // Door handle
          const doorHandle = new THREE.Mesh(
            new THREE.BoxGeometry(0.04, 0.15, 0.02),
            hingeMat
          );
          doorHandle.position.set(w / 2 - 0.1, 0, d / 2 + 0.03);
          group.add(doorHandle);

          // Hinges
          [-1, 1].forEach(pos => {
            const hinge = new THREE.Mesh(
              new THREE.CylinderGeometry(0.015, 0.015, 0.03, 8),
              hingeMat
            );
            hinge.position.set(-w / 2 + 0.02, pos * (h / 3), d / 2);
            group.add(hinge);
          });

          break;
        }

        case 'towel-bar': {
          // Wall-mounted towel bar
          const barMat = new THREE.MeshStandardMaterial({
            color: 0xC0C0C0,
            roughness: 0.2,
            metalness: 0.85
          });
          const bracketMat = new THREE.MeshStandardMaterial({
            color: 0xA0A0A0,
            roughness: 0.25,
            metalness: 0.8
          });

          const barRadius = 0.02;
          const bracketSize = 0.06;

          // Main bar
          const bar = new THREE.Mesh(
            new THREE.CylinderGeometry(barRadius, barRadius, w - bracketSize * 2, 16),
            barMat
          );
          bar.rotation.z = Math.PI / 2;
          bar.position.set(0, 0, barRadius + 0.02);
          group.add(bar);

          // End brackets
          [-1, 1].forEach(side => {
            // Bracket base
            const bracket = new THREE.Mesh(
              new THREE.CylinderGeometry(bracketSize / 2, bracketSize / 2, 0.03, 16),
              bracketMat
            );
            bracket.rotation.x = Math.PI / 2;
            bracket.position.set(side * (w / 2 - bracketSize / 2), 0, 0.015);
            group.add(bracket);

            // Bracket arm
            const arm = new THREE.Mesh(
              new THREE.CylinderGeometry(barRadius, barRadius, barRadius * 3, 12),
              barMat
            );
            arm.rotation.x = Math.PI / 2;
            arm.position.set(side * (w / 2 - bracketSize / 2), 0, barRadius + 0.02);
            group.add(arm);
          });

          break;
        }

        case 'grab-bar-24':
        case 'grab-bar-36':
        case 'grab-bar-42': {
          // ADA-compliant grab bars for bathrooms
          // Lengths: 24", 36", 42" (2ft, 3ft, 3.5ft)
          const grabBarMat = createMetalMaterial(el.finish || 'brushed-nickel');
          const flangeMat = new THREE.MeshStandardMaterial({
            color: 0xA0A0A0,
            roughness: 0.25,
            metalness: 0.8,
            envMap: window.roomEnvMap || null,
            envMapIntensity: 1.0
          });

          const barDiameter = 0.042; // 1.25" standard ADA diameter
          const flangeRadius = 0.05;
          const flangeDepth = 0.025;
          const standoffLength = 0.05;

          // Main grab bar
          const bar = new THREE.Mesh(
            new THREE.CylinderGeometry(barDiameter / 2, barDiameter / 2, w - flangeRadius * 4, 24),
            grabBarMat
          );
          bar.rotation.z = Math.PI / 2;
          bar.position.set(0, 0, standoffLength + barDiameter / 2);
          bar.castShadow = true;
          group.add(bar);

          // End flanges (mounting plates)
          [-1, 1].forEach(side => {
            // Wall flange (circular mounting plate)
            const flange = new THREE.Mesh(
              new THREE.CylinderGeometry(flangeRadius, flangeRadius, flangeDepth, 24),
              flangeMat
            );
            flange.rotation.x = Math.PI / 2;
            flange.position.set(side * (w / 2 - flangeRadius - 0.02), 0, flangeDepth / 2);
            flange.castShadow = true;
            group.add(flange);

            // Standoff (connection from flange to bar)
            const standoff = new THREE.Mesh(
              new THREE.CylinderGeometry(barDiameter / 2, barDiameter / 2, standoffLength, 16),
              grabBarMat
            );
            standoff.rotation.x = Math.PI / 2;
            standoff.position.set(side * (w / 2 - flangeRadius - 0.02), 0, flangeDepth + standoffLength / 2);
            standoff.castShadow = true;
            group.add(standoff);

            // 90-degree elbow (curved connection to horizontal bar)
            const elbowRadius = barDiameter;
            const elbow = new THREE.Mesh(
              new THREE.TorusGeometry(elbowRadius, barDiameter / 2, 12, 8, Math.PI / 2),
              grabBarMat
            );
            elbow.rotation.y = side === 1 ? 0 : Math.PI;
            elbow.rotation.z = Math.PI / 2;
            elbow.position.set(
              side * (w / 2 - flangeRadius - 0.02 - elbowRadius),
              0,
              standoffLength + barDiameter / 2
            );
            group.add(elbow);
          });

          // Add mounting screw indicators on flanges
          [-1, 1].forEach(side => {
            [[-0.025, 0.025], [0.025, 0.025], [-0.025, -0.025], [0.025, -0.025]].forEach(([ox, oy]) => {
              const screw = new THREE.Mesh(
                new THREE.CylinderGeometry(0.004, 0.004, 0.005, 8),
                new THREE.MeshStandardMaterial({ color: 0x606060, metalness: 0.9, roughness: 0.3 })
              );
              screw.rotation.x = Math.PI / 2;
              screw.position.set(side * (w / 2 - flangeRadius - 0.02) + ox, oy, 0.002);
              group.add(screw);
            });
          });

          break;
        }

        case 'toilet-paper': {
          // Toilet paper holder
          const holderMat = new THREE.MeshStandardMaterial({
            color: 0xC0C0C0,
            roughness: 0.2,
            metalness: 0.8
          });
          const paperMat = new THREE.MeshStandardMaterial({
            color: 0xFFFAF0,
            roughness: 0.7
          });

          // Back plate
          const backPlate = new THREE.Mesh(
            new THREE.BoxGeometry(0.08, 0.1, 0.015),
            holderMat
          );
          backPlate.position.set(-w / 4, 0, -d / 4);
          group.add(backPlate);

          // Holder arm
          const arm = new THREE.Mesh(
            new THREE.CylinderGeometry(0.012, 0.012, w * 0.8, 12),
            holderMat
          );
          arm.rotation.z = Math.PI / 2;
          arm.position.set(0, 0, 0);
          group.add(arm);

          // Paper roll
          const rollOuter = new THREE.Mesh(
            new THREE.CylinderGeometry(h * 0.4, h * 0.4, w * 0.6, 24),
            paperMat
          );
          rollOuter.rotation.z = Math.PI / 2;
          rollOuter.position.set(0, 0, 0);
          group.add(rollOuter);

          // Roll center (cardboard tube)
          const rollCenter = new THREE.Mesh(
            new THREE.CylinderGeometry(h * 0.12, h * 0.12, w * 0.65, 16),
            new THREE.MeshStandardMaterial({ color: 0xD4A76A, roughness: 0.8 })
          );
          rollCenter.rotation.z = Math.PI / 2;
          rollCenter.position.set(0, 0, 0);
          group.add(rollCenter);

          break;
        }

        case 'closet-drawers':
        case 'jewelry-drawer': {
          // Drawer unit for closets
          const drawerBodyMat = new THREE.MeshStandardMaterial({
            color: el.color ? parseInt(el.color.replace('#', ''), 16) : 0x8B7355,
            roughness: 0.5
          });
          const handleMat = new THREE.MeshStandardMaterial({
            color: 0xC0C0C0,
            roughness: 0.25,
            metalness: 0.7
          });

          // Main body
          const body = new THREE.Mesh(
            new THREE.BoxGeometry(w, h, d),
            drawerBodyMat
          );
          group.add(body);

          // Drawer fronts
          const numDrawers = el.type === 'jewelry-drawer' ? 2 : 4;
          const drawerH = (h - 0.05) / numDrawers;
          const gap = 0.01;

          for (let di = 0; di < numDrawers; di++) {
            const drawerY = -h / 2 + drawerH / 2 + di * drawerH + gap * di;

            // Drawer face
            const face = new THREE.Mesh(
              new THREE.BoxGeometry(w - 0.02, drawerH - gap, 0.03),
              drawerBodyMat
            );
            face.position.set(0, drawerY, d / 2 + 0.015);
            group.add(face);

            // Drawer handle
            const drawHandle = new THREE.Mesh(
              new THREE.BoxGeometry(w * 0.3, 0.02, 0.02),
              handleMat
            );
            drawHandle.position.set(0, drawerY, d / 2 + 0.04);
            group.add(drawHandle);
          }

          break;
        }

        default:
          // Default box
          const defaultMat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.5 });
          const defaultMesh = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), defaultMat);
          group.add(defaultMesh);
      }

      // Set shadows for all meshes in group
      group.traverse(child => {
        if (child.isMesh) {
          child.castShadow = true;
          child.receiveShadow = true;
        }
      });

      return { group, height: h };
    }

    /**
     * Build room structure (floor + walls) - cached for performance
     * Only rebuilds when room dimensions change
     */
    function buildRoomStructure() {
      const wallHeight = roomHeight || 8;

      // Check if we need to rebuild
      const dimensionsChanged =
        cachedRoomDimensions.width !== roomWidth ||
        cachedRoomDimensions.depth !== roomDepth ||
        cachedRoomDimensions.height !== wallHeight;

      if (cachedRoomStructure && !dimensionsChanged && !forceFullRebuild3D) {
        // Return cached structure
        return cachedRoomStructure;
      }

      // Remove old structure if it exists
      if (cachedRoomStructure) {
        cachedRoomStructure.forEach(mesh => {
          if (mesh.geometry) mesh.geometry.dispose();
          if (mesh.material) mesh.material.dispose();
          scene.remove(mesh);
        });
      }

      const structure = [];

      // Floor
      const floorMat = new THREE.MeshStandardMaterial({
        color: 0xD2B48C,
        roughness: 0.8
      });
      const floor = new THREE.Mesh(
        new THREE.PlaneGeometry(roomWidth + 4, roomDepth + 4),
        floorMat
      );
      floor.rotation.x = -Math.PI / 2;
      floor.position.set(roomWidth / 2, 0, roomDepth / 2);
      floor.receiveShadow = true;
      floor.userData.isRoomStructure = true;
      structure.push(floor);

      // Wall material
      const wallMat = new THREE.MeshStandardMaterial({
        color: 0xFFFAF0,
        roughness: 0.9,
        side: THREE.DoubleSide
      });

      // Back wall
      const backWall = new THREE.Mesh(
        new THREE.PlaneGeometry(roomWidth, wallHeight),
        wallMat.clone()
      );
      backWall.position.set(roomWidth / 2, wallHeight / 2, 0);
      backWall.receiveShadow = true;
      backWall.userData.isRoomStructure = true;
      structure.push(backWall);

      // Left wall
      const leftWall = new THREE.Mesh(
        new THREE.PlaneGeometry(roomDepth, wallHeight),
        wallMat.clone()
      );
      leftWall.rotation.y = Math.PI / 2;
      leftWall.position.set(0, wallHeight / 2, roomDepth / 2);
      leftWall.receiveShadow = true;
      leftWall.userData.isRoomStructure = true;
      structure.push(leftWall);

      // Right wall
      const rightWall = new THREE.Mesh(
        new THREE.PlaneGeometry(roomDepth, wallHeight),
        wallMat.clone()
      );
      rightWall.rotation.y = -Math.PI / 2;
      rightWall.position.set(roomWidth, wallHeight / 2, roomDepth / 2);
      rightWall.receiveShadow = true;
      rightWall.userData.isRoomStructure = true;
      structure.push(rightWall);

      // Front wall (optional)
      if (sceneSettings.showFrontWall) {
        const frontWallMat = new THREE.MeshStandardMaterial({
          color: 0xFFFAF0,
          roughness: 0.9,
          side: THREE.DoubleSide,
          transparent: true,
          opacity: sceneSettings.wallTransparency || 0.5
        });
        const frontWall = new THREE.Mesh(
          new THREE.PlaneGeometry(roomWidth, wallHeight),
          frontWallMat
        );
        frontWall.rotation.y = Math.PI;
        frontWall.position.set(roomWidth / 2, wallHeight / 2, roomDepth);
        frontWall.receiveShadow = true;
        frontWall.userData.isRoomStructure = true;
        structure.push(frontWall);
      }

      // Wall labels (3D text sprites)
      function createWallLabel(text) {
        const canvas = document.createElement('canvas');
        const ctx2d = canvas.getContext('2d');
        canvas.width = 256;
        canvas.height = 64;
        ctx2d.fillStyle = 'rgba(99, 102, 241, 0.85)';
        ctx2d.roundRect(0, 8, 256, 48, 8);
        ctx2d.fill();
        ctx2d.fillStyle = '#ffffff';
        ctx2d.font = 'bold 28px Inter, Arial, sans-serif';
        ctx2d.textAlign = 'center';
        ctx2d.textBaseline = 'middle';
        ctx2d.fillText(text, 128, 32);
        const texture = new THREE.CanvasTexture(canvas);
        const spriteMat = new THREE.SpriteMaterial({ map: texture, transparent: true });
        const sprite = new THREE.Sprite(spriteMat);
        sprite.scale.set(3, 0.75, 1);
        sprite.userData.isRoomStructure = true;
        return sprite;
      }

      // Back wall label
      const backLabel = createWallLabel('BACK WALL');
      backLabel.position.set(roomWidth / 2, wallHeight - 0.5, 0.3);
      structure.push(backLabel);

      // Left wall label
      const leftLabel = createWallLabel('LEFT WALL');
      leftLabel.position.set(0.3, wallHeight - 0.5, roomDepth / 2);
      structure.push(leftLabel);

      // Right wall label
      const rightLabel = createWallLabel('RIGHT WALL');
      rightLabel.position.set(roomWidth - 0.3, wallHeight - 0.5, roomDepth / 2);
      structure.push(rightLabel);

      // Front wall label
      const frontLabel = createWallLabel('FRONT WALL');
      frontLabel.position.set(roomWidth / 2, wallHeight - 0.5, roomDepth - 0.3);
      structure.push(frontLabel);

      // Add all to scene
      structure.forEach(mesh => scene.add(mesh));

      // Cache
      cachedRoomStructure = structure;
      cachedRoomDimensions = { width: roomWidth, depth: roomDepth, height: wallHeight };

      return structure;
    }

    function render3D() {
      if (!scene || currentView !== '3d') return;

      try {
      // Check if we need full rebuild or incremental update
      const needsFullRebuild = forceFullRebuild3D || dirtyElements3D.size === 0;

      if (needsFullRebuild) {
        // Properly remove all non-light, non-room-structure children using Three.js API
        // Direct array assignment (scene.children = ...) bypasses parent tracking and causes ghost objects
        const toRemove = [];
        scene.children.forEach(c => {
          if (!c.type.includes('Light') && !c.userData?.isRoomStructure) {
            toRemove.push(c);
          }
        });
        toRemove.forEach(c => {
          scene.remove(c);
          // Dispose geometry/materials to free GPU memory
          if (c.traverse) {
            c.traverse(obj => {
              if (obj.geometry) obj.geometry.dispose();
              if (obj.material) {
                if (Array.isArray(obj.material)) {
                  obj.material.forEach(m => {
                    if (m.map) m.map.dispose();
                    m.dispose();
                  });
                } else {
                  if (obj.material.map) obj.material.map.dispose();
                  obj.material.dispose();
                }
              }
            });
          }
        });

        // Clear mesh cache for full rebuild
        meshCache3D.clear();
      }

      // Build/get room structure (cached)
      buildRoomStructure();

      // Reset full rebuild flag
      forceFullRebuild3D = false;

      // Elements - filter out hidden ones AND filter by current room
      const activeRoomId = currentRoomId || currentRoom || 'default';

      const visibleElements3D = elements.filter(el => {
        if (el.hidden) return false;
        // Only show elements belonging to current room (check both room tracking systems)
        // If element has no roomId, show it (legacy element or shared design)
        if (el.roomId && el.roomId !== activeRoomId && el.roomId !== currentRoom) {
          return false;
        }
        const category = getElementCategory(el.type);
        if (hiddenCategories[category]) return false;

        // Exclude elements whose 2D position is mostly outside the room bounds
        // This prevents ghost/stale elements from old designs or resized rooms
        const elXFt = el.x / pixelsPerFoot;
        const elYFt = el.y / pixelsPerFoot;
        const elRight = elXFt + el.width;
        const elBottom = elYFt + el.height;
        // Element must have at least 25% of its area inside the room
        const overlapX = Math.max(0, Math.min(elRight, roomWidth) - Math.max(elXFt, 0));
        const overlapY = Math.max(0, Math.min(elBottom, roomDepth) - Math.max(elYFt, 0));
        const overlapArea = overlapX * overlapY;
        const elArea = el.width * el.height;
        if (elArea > 0 && overlapArea / elArea < 0.25) {
          return false; // Element is mostly outside room - skip it
        }
        return true;
      });

      // Track which elements are currently visible (for cleanup)
      const visibleElementIds = new Set(visibleElements3D.map(el => el.id));

      // Remove meshes for elements that are no longer visible
      meshCache3D.forEach((cached, elementId) => {
        if (!visibleElementIds.has(elementId)) {
          if (cached && cached.group) {
            scene.remove(cached.group);
            // Dispose resources
            cached.group.traverse(obj => {
              if (obj.geometry) obj.geometry.dispose();
              if (obj.material) {
                if (Array.isArray(obj.material)) {
                  obj.material.forEach(m => m.dispose());
                } else {
                  obj.material.dispose();
                }
              }
            });
          }
          meshCache3D.delete(elementId);
        }
      });

      visibleElements3D.forEach(el => {
        // Check if we can skip this element (cached and not dirty)
        const cached = meshCache3D.get(el.id);
        const currentVersion = elementVersions.get(el.id) || 0;
        const isDirty = dirtyElements3D.has(el.id);

        // Skip if cached, not dirty, and version matches
        if (cached && !isDirty && !needsFullRebuild && cached.version === currentVersion) {
          return; // Skip - already rendered and unchanged
        }

        // Remove old mesh if it exists
        if (cached && cached.group) {
          scene.remove(cached.group);
          cached.group.traverse(obj => {
            if (obj.geometry) obj.geometry.dispose();
            if (obj.material) {
              if (Array.isArray(obj.material)) {
                obj.material.forEach(m => m.dispose());
              } else {
                obj.material.dispose();
              }
            }
          });
        }

        let group, height;
        try {
          const result = create3DElement(el);
          if (result && result.group) {
            group = result.group;
            height = result.height || 1;
          } else {
            throw new Error('create3DElement returned invalid result');
          }
        } catch (err) {
          console.error(`Error creating 3D element for ${el.type} (${el.label}):`, err);
          // Create a fallback simple box
          group = new THREE.Group();
          height = 1;
          const fallbackMat = new THREE.MeshStandardMaterial({ color: 0xff0000, wireframe: true });
          const fallbackBox = new THREE.Mesh(new THREE.BoxGeometry(el.width || 1, 1, el.height || 1), fallbackMat);
          group.add(fallbackBox);
        }

        // Skip if group is still somehow undefined
        if (!group) {
          console.warn(`Skipping element ${el.type} - no 3D group created`);
          return;
        }

        // Convert 2D position to 3D
        // In 2D: origin is top-left, Y goes down
        // In 3D: origin is corner, Z goes forward (into room)
        let xPos = (el.x / pixelsPerFoot) + el.width / 2;
        let zPos = (el.y / pixelsPerFoot) + el.height / 2;
        let yPos = get3DYPosition(el, height);

        // Windows and doors snap to wall surface
        const windowDoorTypes = [
          'window', 'window-large', 'window-bay', 'bay-window', 'picture-window',
          'door', 'double-door', 'sliding-door', 'french-door', 'glass-door',
          'entry-archway', 'garage-door'
        ];
        // Niches embed INTO the wall
        const nicheTypes = ['wall-niche', 'fireplace-niche', 'tv-niche', 'shower-niche'];
        const isNiche = nicheTypes.includes(el.type);
        const isWindowDoor = windowDoorTypes.includes(el.type);

        // Grab bars also mount to walls
        const grabBarTypes = ['grab-bar', 'grab-bar-24', 'grab-bar-36', 'grab-bar-42'];
        const isGrabBar = grabBarTypes.includes(el.type);

        // Backsplash mounts flat against walls (vertical panel)
        const isBacksplash = el.type === 'backsplash';

        // Wall-mounted shelves (mantel, closet-shelf, microwave-cabinet)
        const wallMountedShelfTypes = ['mantel', 'closet-shelf', 'microwave-cabinet'];
        const isWallMountedShelf = wallMountedShelfTypes.includes(el.type);

        // Wall-mounted bathroom/closet accessories (thin items that sit close to wall)
        const wallAccessoryTypes = [
          'mirror', 'medicine-cabinet', 'towel-bar', 'towel-warmer', 'toilet-paper',
          'closet-rod', 'tie-rack', 'full-mirror'
        ];
        const isWallAccessory = wallAccessoryTypes.includes(el.type);

        // Range hood mounts on wall above stove
        const isRangeHood = el.type === 'range-hood';

        // Wall panels (vertical tile/wall surfaces that snap to walls)
        const wallPanelTypes = ['wall-tile', 'accent-wall', 'shower-wall'];
        const isWallPanel = wallPanelTypes.includes(el.type);

        // Cabinets and appliances that should auto-rotate when against side/front walls
        // NOTE: corner-cabinet and lazy-susan are excluded - they have specific L-shaped orientations
        const cabinetApplianceTypes = [
          'base-cabinet', 'wall-cabinet', 'tall-cabinet', 'drawer-base', 'sink-base',
          'fridge-cabinet',
          'refrigerator', 'range', 'stove', 'slide-in-range', 'dishwasher',
          'oven', 'wall-oven-double', 'microwave', 'range-hood', 'cooktop',
          'sink', 'sink-double', 'sink-farmhouse',
          'countertop',
          // Bathroom elements that face into room
          'toilet', 'toilet-round', 'toilet-wall', 'bidet',
          'bathtub', 'bathtub-freestanding', 'bathtub-corner', 'bathtub-walk-in',
          'vanity-24', 'vanity-30', 'vanity-36', 'vanity-48', 'vanity-60', 'vanity-72',
          // Laundry elements that face into room
          'washer', 'dryer', 'washer-dryer-stack', 'laundry-cabinet',
          'utility-sink', 'laundry-sink'
        ];
        const isCabinetAppliance = cabinetApplianceTypes.includes(el.type);

        // Check if element is against a side or front wall (not back wall)
        const el2DX = el.x / pixelsPerFoot;
        const el2DY = el.y / pixelsPerFoot;
        const elRightEdge = el2DX + el.width;
        const elBottomEdge = el2DY + el.height;
        const wallThreshold = 0.5; // Within 0.5ft of wall

        // Detect which wall the element is against
        const isAgainstRightWall = (roomWidth - elRightEdge) < wallThreshold;
        const isAgainstLeftWall = el2DX < wallThreshold;
        const isAgainstFrontWall = (roomDepth - elBottomEdge) < wallThreshold;
        const isAgainstBackWall = el2DY < wallThreshold;

        // Auto-rotate cabinets/appliances based on wall position OR respect manual rotation from 2D snap
        // When el.rotation is set (from 2D drag snap), we need to adjust position accordingly
        let autoRotated = false;
        const hasManualRotation = el.rotation !== undefined && el.rotation !== null;
        const manualRotation = hasManualRotation ? ((el.rotation % 360) + 360) % 360 : null; // Normalize to 0-359

        if (isCabinetAppliance) {
          if (!hasManualRotation) {
            // No rotation set - auto-rotate based on wall position
            if (isAgainstRightWall && !isAgainstBackWall) {
              group.rotation.y = -Math.PI / 2;
              autoRotated = true;
              xPos = roomWidth - el.height / 2;
              zPos = (el.y / pixelsPerFoot) + el.width / 2;
            } else if (isAgainstLeftWall && !isAgainstBackWall) {
              group.rotation.y = Math.PI / 2;
              autoRotated = true;
              xPos = el.height / 2;
              zPos = (el.y / pixelsPerFoot) + el.width / 2;
            } else if (isAgainstFrontWall && !isAgainstBackWall) {
              group.rotation.y = Math.PI;
              autoRotated = true;
              zPos = roomDepth - el.height / 2;
            }
          } else {
            // Manual rotation from 2D snap - apply rotation AND adjust position
            // rotation=270 means left wall (cabinet faces right into room)
            // rotation=90 means right wall (cabinet faces left into room)
            // rotation=180 means front wall (cabinet faces back into room)
            // rotation=0 means back wall (cabinet faces front into room)
            if (manualRotation === 270 && isAgainstLeftWall) {
              // Left wall - cabinet rotated to face right
              group.rotation.y = Math.PI / 2; // Same as -270 degrees
              autoRotated = true;
              xPos = el.height / 2; // Position from left wall using depth (el.height in 2D)
              zPos = (el.y / pixelsPerFoot) + el.width / 2; // Use width for Z position
            } else if (manualRotation === 90 && isAgainstRightWall) {
              // Right wall - cabinet rotated to face left
              group.rotation.y = -Math.PI / 2;
              autoRotated = true;
              xPos = roomWidth - el.height / 2;
              zPos = (el.y / pixelsPerFoot) + el.width / 2;
            } else if (manualRotation === 180 && isAgainstFrontWall) {
              // Front wall - cabinet rotated to face back
              group.rotation.y = Math.PI;
              autoRotated = true;
              zPos = roomDepth - el.height / 2;
            }
            // rotation=0 on back wall keeps default positioning
          }
        }

        // ===== WALL CABINET DEPTH POSITIONING =====
        // Wall cabinets are 12" deep vs base cabinets at 24" deep
        // Both should align at the wall surface, not at the front face
        // This ensures proper visual alignment in 3D view
        const wallCabinetTypes = ['wall-cabinet'];
        const isWallCabinet = wallCabinetTypes.includes(el.type) ||
                              (el.type && el.type.startsWith('wall-cabinet-'));

        if (isWallCabinet && !autoRotated) {
          // Wall cabinet on back wall (no rotation) - adjust Z to align at wall
          // Base cabinet depth: 24" (2 ft), Wall cabinet depth: 12" (1 ft)
          // Difference: 12" (1 ft) - wall cabinet sits 1 ft closer to wall
          const baseCabinetDepth = BUILDING_STANDARDS.CABINETS.BASE?.depth || 2;
          const wallCabinetDepth = BUILDING_STANDARDS.CABINETS.WALL?.depth || 1;
          const depthDifference = baseCabinetDepth - wallCabinetDepth;

          // Move wall cabinet forward (toward the wall) by the depth difference
          // This aligns the back of wall cabinet with back of base cabinet (both at wall)
          zPos = (el.y / pixelsPerFoot) + el.height / 2 - depthDifference / 2;

          // Ensure minimum distance from wall (wall cabinets should be at wall, not inside it)
          if (zPos < wallCabinetDepth / 2) {
            zPos = wallCabinetDepth / 2;
          }
        } else if (isWallCabinet && autoRotated) {
          // Wall cabinet was auto-rotated to face a side or front wall
          // Adjust position based on rotation direction
          const baseCabinetDepth = BUILDING_STANDARDS.CABINETS.BASE?.depth || 2;
          const wallCabinetDepth = BUILDING_STANDARDS.CABINETS.WALL?.depth || 1;
          const depthDifference = baseCabinetDepth - wallCabinetDepth;

          if (isAgainstRightWall) {
            // Cabinet faces left, adjust X position closer to right wall
            xPos = roomWidth - wallCabinetDepth / 2;
          } else if (isAgainstLeftWall) {
            // Cabinet faces right, adjust X position closer to left wall
            xPos = wallCabinetDepth / 2;
          } else if (isAgainstFrontWall) {
            // Cabinet faces back, adjust Z position closer to front wall
            zPos = roomDepth - wallCabinetDepth / 2;
          }
        }

        // ===== BASE CABINET WALL ALIGNMENT =====
        // Ensure base cabinets (24" deep) sit flush against walls
        // Back of cabinet should touch wall surface, not be offset
        const baseCabinetTypes = ['base-cabinet', 'drawer-base', 'sink-base', 'corner-cabinet', 'lazy-susan', 'blind-corner'];
        const isBaseCabinet = baseCabinetTypes.some(t => el.type === t || el.type?.startsWith(t + '-'));

        if (isBaseCabinet) {
          const baseCabinetDepth = el.height || BUILDING_STANDARDS.CABINETS.BASE?.depth || 2; // Use element's depth (height in 2D)

          if (!autoRotated) {
            // Back wall (no rotation) - position so cabinet back is at wall
            if (isAgainstBackWall) {
              zPos = baseCabinetDepth / 2;
            }
          } else {
            // Auto-rotated cabinet - align to the wall it faces
            if (isAgainstRightWall) {
              xPos = roomWidth - baseCabinetDepth / 2;
            } else if (isAgainstLeftWall) {
              xPos = baseCabinetDepth / 2;
            } else if (isAgainstFrontWall) {
              zPos = roomDepth - baseCabinetDepth / 2;
            }
          }
        }

        if (isWindowDoor || isNiche || isGrabBar || isBacksplash || isWallMountedShelf || isWallAccessory || isRangeHood || isWallPanel) {
          // Determine which wall based on 2D position and rotation
          const rotation = (el.rotation || 0) % 360;
          const normalizedRotation = rotation < 0 ? rotation + 360 : rotation;
          const el2DY = el.y / pixelsPerFoot;
          const el2DX = el.x / pixelsPerFoot;
          const elCenterX = el2DX + el.width / 2;
          const elCenterY = el2DY + el.height / 2;

          // Calculate distances to each wall edge
          const distToBack = el2DY;                                    // Top wall (back in 3D)
          const distToFront = roomDepth - (el2DY + el.height);        // Bottom wall (front in 3D)
          const distToLeft = el2DX;                                    // Left wall
          const distToRight = roomWidth - (el2DX + el.width);         // Right wall

          // Wall detection threshold (how close to wall to snap)
          const threshold = 3;

          // Determine wall primarily by rotation, with position as tiebreaker
          let closestWall;

          // Rotation is the primary indicator of which wall the element faces
          if (normalizedRotation === 90) {
            closestWall = 'left';
          } else if (normalizedRotation === 270) {
            closestWall = 'right';
          } else if (normalizedRotation === 180) {
            closestWall = 'front';
          } else if (normalizedRotation === 0) {
            // No rotation - use position to determine wall
            // Find the wall this element is closest to
            const distances = [
              { wall: 'back', dist: distToBack },
              { wall: 'front', dist: distToFront },
              { wall: 'left', dist: distToLeft },
              { wall: 'right', dist: distToRight }
            ];

            // Sort by distance and pick closest within threshold
            distances.sort((a, b) => a.dist - b.dist);
            closestWall = distances[0].dist <= threshold ? distances[0].wall : 'back';
          } else {
            // Non-standard rotation - use closest wall by position
            const distances = [
              { wall: 'back', dist: distToBack },
              { wall: 'front', dist: distToFront },
              { wall: 'left', dist: distToLeft },
              { wall: 'right', dist: distToRight }
            ];
            distances.sort((a, b) => a.dist - b.dist);
            closestWall = distances[0].wall;
          }

          // Calculate wall offset based on element type
          // Niches embed into wall, backsplash sits thin against wall, shelves protrude from wall
          let wallOffset;
          if (isNiche) {
            // Position niche forward so the recess is visible in front of the wall plane
            // Back wall of niche ends up at room wall surface, opening extends into room
            wallOffset = el.nicheDepth || 0.5;
          } else if (isBacksplash) {
            wallOffset = 0.04; // Thin, just off wall
          } else if (isWallAccessory) {
            wallOffset = 0.05; // Thin accessories (mirrors, towel bars) sit very close to wall
          } else if (isWallPanel) {
            wallOffset = 0.03; // Thin panel sits flush against wall
          } else if (isRangeHood) {
            wallOffset = el.height / 2; // Range hood protrudes from wall by its depth
          } else if (isWallMountedShelf) {
            wallOffset = el.height / 2; // Shelf protrudes from wall by its depth
          } else {
            wallOffset = 0.1; // Default offset for windows/doors
          }

          // Position based on closest wall
          switch (closestWall) {
            case 'back':
              zPos = wallOffset;
              group.rotation.y = 0;
              break;
            case 'front':
              zPos = roomDepth - wallOffset;
              group.rotation.y = Math.PI;
              break;
            case 'left':
              zPos = elCenterY;
              xPos = wallOffset;
              group.rotation.y = Math.PI / 2;
              break;
            case 'right':
              zPos = elCenterY;
              xPos = roomWidth - wallOffset;
              group.rotation.y = -Math.PI / 2;
              break;
          }
        } else if (!autoRotated) {
          // Only apply manual rotation if not auto-rotated
          group.rotation.y = -(el.rotation || 0) * Math.PI / 180;
        }

        // Clamp positions to room boundaries (prevent elements protruding through walls)
        // Skip clamping for wall-positioned elements  their position is set by wall snap logic above
        const isWallPositioned = isWindowDoor || isNiche || isGrabBar || isBacksplash || isWallMountedShelf || isWallAccessory || isRangeHood || isWallPanel;
        if (!isWallPositioned) {
          const halfW = el.width / 2;
          const halfD = el.height / 2;
          // For rotated elements, width/depth swap in 3D space
          const rot = (el.rotation || 0) % 360;
          const isRotated90 = (rot === 90 || rot === 270 || rot === -90 || rot === -270) || autoRotated;
          const xHalf = isRotated90 ? halfD : halfW;
          const zHalf = isRotated90 ? halfW : halfD;
          xPos = Math.max(xHalf, Math.min(xPos, roomWidth - xHalf));
          zPos = Math.max(zHalf, Math.min(zPos, roomDepth - zHalf));
        }
        yPos = Math.max(0, yPos);

        group.position.set(xPos, yPos, zPos);

        // Store element data for tooltips
        group.userData.elementData = el;

        // Add to scene
        scene.add(group);

        // Cache the mesh for incremental updates
        meshCache3D.set(el.id, {
          group: group,
          version: currentVersion
        });

        // Clear dirty flag for this element
        dirtyElements3D.delete(el.id);
      });

      // Clear any remaining dirty flags (for elements that weren't visible)
      dirtyElements3D.clear();

      // Render custom walls from wall tool
      if (walls && walls.length > 0) {
        walls.filter(w => w.type === 'wall').forEach(wall => {
          // Convert pixel coordinates to feet
          const wallX = wall.x / pixelsPerFoot;
          const wallY = wall.y / pixelsPerFoot;
          const wallW = wall.width / pixelsPerFoot;
          const wallD = wall.height / pixelsPerFoot;
          const wallH = wall.wallHeight || 3.5; // Default 3.5 feet (42") for pony walls

          // Create wall material
          const wallColor = wall.color || '#444444';
          const customWallMat = new THREE.MeshStandardMaterial({
            color: new THREE.Color(wallColor),
            roughness: 0.8,
            metalness: 0.1
          });

          // Determine if horizontal or vertical wall based on aspect ratio
          const isVertical = wallD > wallW;

          // Create wall mesh - BoxGeometry(widthX, heightY, depthZ)
          const wallMesh = new THREE.Mesh(
            new THREE.BoxGeometry(wallW, wallH, wallD),
            customWallMat
          );

          // Position: center of the wall
          const xPos = wallX + wallW / 2;
          const yPos = wallH / 2; // Center vertically
          const zPos = wallY + wallD / 2;

          wallMesh.position.set(xPos, yPos, zPos);
          wallMesh.castShadow = true;
          wallMesh.receiveShadow = true;

          // Tag as custom wall (so full rebuild cleanup removes it properly)
          wallMesh.userData.isCustomWall = true;

          // Store wall data for tooltips
          wallMesh.userData.elementData = {
            type: 'custom-wall',
            width: wallW,
            height: wallD,
            wallHeight: wallH,
            label: `Wall ${Math.round(isVertical ? wallD * 12 : wallW * 12)}"  ${Math.round(wallH * 12)}"`
          };

          scene.add(wallMesh);
        });
      }

      // Update camera target - aim at center of room at counter height
      const centerX = roomWidth / 2;
      const centerZ = roomDepth / 2;
      const targetHeight = 3; // ~3 feet up (counter height view)
      controls.target.set(centerX, targetHeight, centerZ);

      // Position camera for optimal room view
      // Height should be eye level (~5.5 ft) plus some elevation for overview
      // Distance should scale with room size for good perspective
      const roomDiagonal = Math.sqrt(roomWidth * roomWidth + roomDepth * roomDepth);
      const cameraDistance = Math.max(roomDiagonal * 0.8, 10); // At least 10ft back
      const cameraHeight = Math.max(6, roomHeight * 0.7); // Eye level or 70% of room height

      // Position at corner angle for best 3D perspective
      camera.position.set(
        centerX + cameraDistance * 0.7,  // Offset right from center
        cameraHeight,                     // Eye level height
        centerZ + cameraDistance * 0.7   // Offset forward from center
      );
      controls.update();

      // Animation loop with proper ID tracking
      function animate() {
        if (currentView !== '3d') {
          animationId = null;
          return;
        }
        animationId = requestAnimationFrame(animate);
        controls.update();

        // Use post-processing composer if available, otherwise standard render
        if (composer && postProcessingEnabled && window._postProcessing?.enabled) {
          composer.render();
        } else {
          renderer.render(scene, camera);
        }

        // Update axis indicator to match main camera orientation
        if (window._axisIndicator) {
          const axis = window._axisIndicator;
          // Copy main camera quaternion to axis camera
          // Position axis camera at a fixed distance looking at origin
          const axisDistance = 3;
          axis.camera.position.copy(camera.position).sub(controls.target).normalize().multiplyScalar(axisDistance);
          axis.camera.lookAt(0, 0, 0);
          axis.camera.up.copy(camera.up);
          axis.renderer.render(axis.scene, axis.camera);
        }
      }
      animate();

      // Setup 3D tooltip raycasting
      setup3DTooltips();
      } catch (renderErr) {
        console.error('Error in 3D rendering:', renderErr);
        showSnapFeedback('3D rendering error - check console for details');
      }
    }

    // 3D Tooltip system with raycasting
    const raycaster3D = new THREE.Raycaster();
    const mouse3D = new THREE.Vector2();
    let hoveredObject3D = null;

    function setup3DTooltips() {
      const container = document.getElementById('three-container');
      if (!container) return;

      container.addEventListener('mousemove', on3DMouseMove);
      container.addEventListener('mouseleave', hide3DTooltip);
    }

    function on3DMouseMove(event) {
      if (!renderer || !camera || !scene || currentView !== '3d') return;

      const container = document.getElementById('three-container');
      const rect = container.getBoundingClientRect();

      mouse3D.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
      mouse3D.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

      raycaster3D.setFromCamera(mouse3D, camera);

      // Get all meshes in scene that have userData.elementData
      const intersects = raycaster3D.intersectObjects(scene.children, true);

      let foundElement = null;
      for (const intersect of intersects) {
        // Walk up to find group with element data
        let obj = intersect.object;
        while (obj && !obj.userData?.elementData) {
          obj = obj.parent;
        }
        if (obj?.userData?.elementData) {
          foundElement = obj.userData.elementData;
          break;
        }
      }

      if (foundElement) {
        show3DTooltip(foundElement, event.clientX, event.clientY);
        hoveredObject3D = foundElement;
      } else {
        hide3DTooltip();
        hoveredObject3D = null;
      }
    }

    function show3DTooltip(el, x, y) {
      const tooltip = document.getElementById('tooltip3D');
      const labelEl = document.getElementById('tooltip3DLabel');
      const sizeEl = document.getElementById('tooltip3DSize');

      if (!tooltip) return;

      labelEl.textContent = el.label || el.type;
      sizeEl.textContent = `${formatDimension(el.width)}  ${formatDimension(el.height)}`;

      tooltip.style.display = 'block';
      tooltip.style.left = (x + 15) + 'px';
      tooltip.style.top = (y + 15) + 'px';
    }

    function hide3DTooltip() {
      const tooltip = document.getElementById('tooltip3D');
      if (tooltip) tooltip.style.display = 'none';
    }

    // ===== 3D DIMENSION LABELS & MEASUREMENT TOOL =====
    let measurementMode = false;
    let measurementPoints = [];
    let measurementLine = null;
    let measurementLabels = [];
    let dimensionSprites = [];

    // Create text sprite for 3D labels
    // Helper: Draw rounded rectangle (polyfill for browsers without roundRect)
    function drawRoundedRect(ctx, x, y, width, height, radius) {
      if (typeof ctx.roundRect === 'function') {
        ctx.roundRect(x, y, width, height, radius);
      } else {
        // Fallback for browsers without roundRect support
        ctx.moveTo(x + radius, y);
        ctx.lineTo(x + width - radius, y);
        ctx.arcTo(x + width, y, x + width, y + radius, radius);
        ctx.lineTo(x + width, y + height - radius);
        ctx.arcTo(x + width, y + height, x + width - radius, y + height, radius);
        ctx.lineTo(x + radius, y + height);
        ctx.arcTo(x, y + height, x, y + height - radius, radius);
        ctx.lineTo(x, y + radius);
        ctx.arcTo(x, y, x + radius, y, radius);
        ctx.closePath();
      }
    }

    function createTextSprite(text, options = {}) {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      const fontSize = options.fontSize || 48;
      const padding = 12;

      ctx.font = `bold ${fontSize}px Inter, system-ui, sans-serif`;
      const textMetrics = ctx.measureText(text);
      const textWidth = textMetrics.width;

      canvas.width = textWidth + padding * 2;
      canvas.height = fontSize + padding * 2;

      // Background with rounded corners
      ctx.fillStyle = options.bgColor || 'rgba(30, 41, 59, 0.9)';
      const radius = 8;
      ctx.beginPath();
      drawRoundedRect(ctx, 0, 0, canvas.width, canvas.height, radius);
      ctx.fill();

      // Border
      ctx.strokeStyle = options.borderColor || 'rgba(99, 102, 241, 0.8)';
      ctx.lineWidth = 2;
      ctx.stroke();

      // Text
      ctx.font = `bold ${fontSize}px Inter, system-ui, sans-serif`;
      ctx.fillStyle = options.textColor || '#ffffff';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(text, canvas.width / 2, canvas.height / 2);

      const texture = new THREE.CanvasTexture(canvas);
      texture.minFilter = THREE.LinearFilter;
      texture.colorSpace = THREE.SRGBColorSpace;

      const material = new THREE.SpriteMaterial({
        map: texture,
        transparent: true,
        depthTest: false,
        depthWrite: false
      });

      const sprite = new THREE.Sprite(material);
      const scale = options.scale || 0.015;
      sprite.scale.set(canvas.width * scale, canvas.height * scale, 1);

      return sprite;
    }

    // Show dimension labels for selected element in 3D
    function show3DDimensions(element) {
      clear3DDimensions();
      if (!element || !scene) return;

      const w = element.width;
      const h = element.height || element.depth;
      const d = element.depth || 0.5;
      const x = element.x + w / 2;
      const z = element.y + h / 2;
      const height3D = get3DHeight(element);

      // Width label (front edge)
      const widthLabel = createTextSprite(formatDimension(w), { bgColor: 'rgba(99, 102, 241, 0.9)' });
      widthLabel.position.set(x, height3D - 0.3, z + h / 2 + 0.5);
      scene.add(widthLabel);
      dimensionSprites.push(widthLabel);

      // Depth label (side edge)
      const depthLabel = createTextSprite(formatDimension(h), { bgColor: 'rgba(16, 185, 129, 0.9)' });
      depthLabel.position.set(x + w / 2 + 0.5, height3D - 0.3, z);
      scene.add(depthLabel);
      dimensionSprites.push(depthLabel);

      // Height label (vertical)
      if (height3D > 0.5) {
        const heightLabel = createTextSprite(formatDimension(get3DHeight(element) * 2), { bgColor: 'rgba(245, 158, 11, 0.9)' });
        heightLabel.position.set(x - w / 2 - 0.5, height3D / 2, z - h / 2 - 0.3);
        scene.add(heightLabel);
        dimensionSprites.push(heightLabel);
      }
    }

    // Clear dimension labels
    function clear3DDimensions() {
      if (scene) {
        dimensionSprites.forEach(sprite => {
          if (sprite.material.map) sprite.material.map.dispose();
          sprite.material.dispose();
          scene.remove(sprite);
        });
      }
      dimensionSprites = [];
    }

    // Toggle measurement mode
    window.toggleMeasurementMode = function() {
      measurementMode = !measurementMode;
      const btn = document.getElementById('measureBtn');

      if (measurementMode) {
        if (btn) {
          btn.classList.add('active');
          btn.style.background = 'linear-gradient(135deg, #10b981, #059669)';
          btn.style.color = '#fff';
        }
        showToast('Measurement mode ON - Click two points to measure distance', 'success');
        clearMeasurement();

        // Add click handler for measurement
        const container = document.getElementById('three-container');
        if (container) {
          container.style.cursor = 'crosshair';
          container.addEventListener('click', onMeasurementClick);
        }
      } else {
        if (btn) {
          btn.classList.remove('active');
          btn.style.background = '';
          btn.style.color = '';
        }
        showToast('Measurement mode OFF', 'info');
        clearMeasurement();

        const container = document.getElementById('three-container');
        if (container) {
          container.style.cursor = '';
          container.removeEventListener('click', onMeasurementClick);
        }
      }
    };

    function onMeasurementClick(event) {
      if (!measurementMode || !renderer || !camera || !scene) return;

      const container = document.getElementById('three-container');
      const rect = container.getBoundingClientRect();

      const mouse = new THREE.Vector2(
        ((event.clientX - rect.left) / rect.width) * 2 - 1,
        -((event.clientY - rect.top) / rect.height) * 2 + 1
      );

      const raycaster = new THREE.Raycaster();
      raycaster.setFromCamera(mouse, camera);

      // Get all meshes in the scene
      const meshes = [];
      scene.traverse(obj => {
        if (obj.isMesh) meshes.push(obj);
      });

      const intersects = raycaster.intersectObjects(meshes, false);

      if (intersects.length > 0) {
        const point = intersects[0].point.clone();
        measurementPoints.push(point);

        // Add point marker
        const markerGeom = new THREE.SphereGeometry(0.1, 16, 16);
        const markerMat = new THREE.MeshBasicMaterial({ color: 0x10b981 });
        const marker = new THREE.Mesh(markerGeom, markerMat);
        marker.position.copy(point);
        scene.add(marker);
        measurementLabels.push(marker);

        if (measurementPoints.length === 2) {
          // Calculate and show distance
          const distance = measurementPoints[0].distanceTo(measurementPoints[1]);

          // Create line between points
          const lineGeom = new THREE.BufferGeometry().setFromPoints(measurementPoints);
          const lineMat = new THREE.LineBasicMaterial({ color: 0x10b981, linewidth: 2 });
          measurementLine = new THREE.Line(lineGeom, lineMat);
          scene.add(measurementLine);

          // Create distance label at midpoint
          const midpoint = new THREE.Vector3().addVectors(measurementPoints[0], measurementPoints[1]).multiplyScalar(0.5);
          const distanceLabel = createTextSprite(formatDimension(distance), {
            bgColor: 'rgba(16, 185, 129, 0.95)',
            borderColor: 'rgba(255, 255, 255, 0.5)',
            fontSize: 56,
            scale: 0.018
          });
          distanceLabel.position.copy(midpoint);
          distanceLabel.position.y += 0.3;
          scene.add(distanceLabel);
          measurementLabels.push(distanceLabel);

          showToast(`Distance: ${formatDimension(distance)}`, 'success');

          // Reset for next measurement after a delay
          setTimeout(() => {
            measurementPoints = [];
          }, 100);
        }
      }
    }

    function clearMeasurement() {
      measurementPoints = [];

      if (measurementLine && scene) {
        scene.remove(measurementLine);
        measurementLine.geometry.dispose();
        measurementLine.material.dispose();
        measurementLine = null;
      }

      if (scene) {
        measurementLabels.forEach(obj => {
          scene.remove(obj);
          if (obj.geometry) obj.geometry.dispose();
          if (obj.material) {
            if (obj.material.map) obj.material.map.dispose();
            obj.material.dispose();
          }
        });
      }
      measurementLabels = [];
    }

    // Show room dimensions in 3D
    function showRoomDimensions() {
      const room = rooms[currentRoomIndex];
      if (!room || !scene) return;

      const w = room.width;
      const d = room.depth;
      const h = room.height || 9;

      // Width label (front wall)
      const widthLabel = createTextSprite(`${formatDimension(w)} wide`, {
        bgColor: 'rgba(99, 102, 241, 0.85)',
        fontSize: 52,
        scale: 0.02
      });
      widthLabel.position.set(w / 2, 0.3, d + 1);
      scene.add(widthLabel);
      dimensionSprites.push(widthLabel);

      // Depth label (side wall)
      const depthLabel = createTextSprite(`${formatDimension(d)} deep`, {
        bgColor: 'rgba(16, 185, 129, 0.85)',
        fontSize: 52,
        scale: 0.02
      });
      depthLabel.position.set(w + 1, 0.3, d / 2);
      scene.add(depthLabel);
      dimensionSprites.push(depthLabel);

      // Height label
      const heightLabel = createTextSprite(`${formatDimension(h)} ceiling`, {
        bgColor: 'rgba(245, 158, 11, 0.85)',
        fontSize: 52,
        scale: 0.02
      });
      heightLabel.position.set(-0.8, h / 2, 0);
      scene.add(heightLabel);
      dimensionSprites.push(heightLabel);
    }

    // Toggle room dimensions display
    window.toggleRoomDimensions = function() {
      if (dimensionSprites.length > 0) {
        clear3DDimensions();
        showToast('Room dimensions hidden', 'info');
      } else {
        showRoomDimensions();
        showToast('Room dimensions shown', 'success');
      }
    };

    // ===== LIGHTING CONTROLS =====
    let currentLightingPreset = 'noon';
    let baseLightIntensities = {};

    window.toggleLightingPanel = function() {
      const panel = document.getElementById('lightingPanel');
      const btn = document.getElementById('lightingBtn');
      if (panel) {
        const isVisible = panel.style.display !== 'none';
        panel.style.display = isVisible ? 'none' : 'block';
        if (btn) {
          btn.classList.toggle('active', !isVisible);
          if (!isVisible) {
            btn.style.background = 'linear-gradient(135deg, #f59e0b, #d97706)';
            btn.style.color = '#fff';
          } else {
            btn.style.background = '';
            btn.style.color = '';
          }
        }
      }
    };

    window.setLightingPreset = function(preset, buttonElement) {
      currentLightingPreset = preset;

      // Update preset buttons - find and highlight the correct one
      document.querySelectorAll('.preset-btn').forEach(btn => btn.classList.remove('active'));
      if (buttonElement) {
        buttonElement.classList.add('active');
      } else {
        // Find by preset name if button not passed
        const presetBtn = document.querySelector(`.preset-btn[title="${preset.charAt(0).toUpperCase() + preset.slice(1)}"]`);
        if (presetBtn) presetBtn.classList.add('active');
      }

      const presets = {
        morning: { ambient: 0.4, key: 0.9, fill: 0.3, exposure: 1.0, color: 0xFFF5E0 },
        noon: { ambient: 0.5, key: 1.2, fill: 0.4, exposure: 1.2, color: 0xFFFBF0 },
        evening: { ambient: 0.35, key: 0.7, fill: 0.25, exposure: 0.9, color: 0xFFD4A0 },
        night: { ambient: 0.2, key: 0.3, fill: 0.15, exposure: 0.6, color: 0xC0D0E0 },
        showroom: { ambient: 0.7, key: 1.5, fill: 0.6, exposure: 1.4, color: 0xFFFFFF }
      };

      const p = presets[preset] || presets.noon;

      // Apply lighting changes
      if (scene) {
        scene.traverse(obj => {
          if (obj.isAmbientLight) {
            obj.intensity = p.ambient;
          } else if (obj.isHemisphereLight) {
            obj.intensity = p.ambient * 0.8;
          } else if (obj.isDirectionalLight) {
            if (obj.name === 'keyLight' || obj.name === 'sunLight') {
              obj.intensity = p.key;
              obj.color.setHex(p.color);
            } else if (obj.name === 'fillLight') {
              obj.intensity = p.fill;
            }
          }
        });

        // Update exposure
        if (renderer) {
          renderer.toneMappingExposure = p.exposure;
        }
      }

      // Update sliders
      document.getElementById('brightnessSlider').value = p.key * 100;
      document.getElementById('brightnessValue').textContent = Math.round(p.key * 100) + '%';
      document.getElementById('ambientSlider').value = p.ambient * 100;
      document.getElementById('ambientValue').textContent = Math.round(p.ambient * 100) + '%';

      showToast(`Lighting: ${preset.charAt(0).toUpperCase() + preset.slice(1)}`, 'success');
    };

    window.adjustBrightness = function(value) {
      const intensity = value / 100;
      document.getElementById('brightnessValue').textContent = value + '%';

      if (scene) {
        scene.traverse(obj => {
          if (obj.isDirectionalLight && (obj.name === 'keyLight' || obj.name === 'sunLight')) {
            obj.intensity = intensity;
          }
        });
      }
    };

    window.adjustAmbient = function(value) {
      const intensity = value / 100;
      document.getElementById('ambientValue').textContent = value + '%';

      if (scene) {
        scene.traverse(obj => {
          if (obj.isAmbientLight) {
            obj.intensity = intensity;
          } else if (obj.isHemisphereLight) {
            obj.intensity = intensity * 0.8;
          }
        });
      }
    };

    window.adjustShadows = function(value) {
      document.getElementById('shadowValue').textContent = value + '%';

      if (scene) {
        scene.traverse(obj => {
          if (obj.isDirectionalLight && obj.castShadow) {
            obj.shadow.intensity = value / 100;
          }
        });
      }
    };

    window.toggleShadows = function(enabled) {
      if (renderer) {
        renderer.shadowMap.enabled = enabled;
      }
      if (scene) {
        scene.traverse(obj => {
          if (obj.isMesh) {
            obj.castShadow = enabled;
            obj.receiveShadow = enabled;
          }
        });
      }
      showToast(enabled ? 'Shadows enabled' : 'Shadows disabled', 'info');
    };

    // HD Mode - Enhanced rendering quality for countertop colors
    window.hdRenderMode = false;

    window.toggleHDMode = function(enabled) {
      window.hdRenderMode = enabled;

      if (renderer) {
        // Higher pixel ratio for sharper textures (careful with performance)
        renderer.setPixelRatio(enabled ? Math.min(window.devicePixelRatio * 1.5, 3) : window.devicePixelRatio);

        // Enhanced tone mapping for better color reproduction
        renderer.toneMapping = enabled ? THREE.ACESFilmicToneMapping : THREE.ReinhardToneMapping;
        renderer.toneMappingExposure = enabled ? 1.2 : 1.0;

        // Better shadow quality in HD mode
        if (enabled) {
          renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        }
      }

      // Update countertop materials with enhanced settings
      if (scene) {
        scene.traverse(obj => {
          if (obj.isMesh && obj.material && obj.material.isMeshPhysicalMaterial) {
            // Enhance clearcoat for HD mode
            if (enabled) {
              obj.material.clearcoat = Math.min(obj.material.clearcoat * 1.3, 1);
              obj.material.envMapIntensity = Math.min(obj.material.envMapIntensity * 1.2, 1.5);
            }
            obj.material.needsUpdate = true;
          }
        });
      }

      // Re-render to apply changes
      if (typeof render3D === 'function') {
        render3D();
      } else if (renderer && scene && camera) {
        renderer.render(scene, camera);
      }

      showToast(enabled ? 'HD Mode enabled - Enhanced countertop colors' : 'HD Mode disabled', 'info');
    };

    // ===== INTERACTIVE CABINET DOORS =====
    // Track cabinet door states and animations
    const cabinetDoorStates = new Map(); // elementId -> { doorIndex: isOpen }
    let interactiveModeEnabled = true;

    // Setup interactive cabinet click handler
    function setupCabinetInteraction() {
      const container = document.getElementById('three-container');
      if (!container) return;

      container.addEventListener('dblclick', onCabinetDoubleClick);
    }

    function onCabinetDoubleClick(event) {
      if (!interactiveModeEnabled || !renderer || !camera || !scene || currentView !== '3d') return;

      const container = document.getElementById('three-container');
      const rect = container.getBoundingClientRect();

      const mouse = new THREE.Vector2(
        ((event.clientX - rect.left) / rect.width) * 2 - 1,
        -((event.clientY - rect.top) / rect.height) * 2 + 1
      );

      const raycaster = new THREE.Raycaster();
      raycaster.setFromCamera(mouse, camera);

      // Get all meshes
      const meshes = [];
      scene.traverse(obj => {
        if (obj.isMesh && obj.userData.elementId) meshes.push(obj);
      });

      const intersects = raycaster.intersectObjects(meshes, false);

      if (intersects.length > 0) {
        const hitObject = intersects[0].object;
        const elementId = hitObject.userData.elementId;
        const partType = hitObject.userData.partType;

        // Check if it's a door or drawer
        if (partType === 'door' || partType === 'drawer') {
          toggleCabinetDoor(elementId, hitObject, partType);
        }
      }
    }

    function toggleCabinetDoor(elementId, doorMesh, partType) {
      // Get the door group (pivot point) from the mesh
      const doorGroup = doorMesh.userData.doorGroup || doorMesh;
      const doorId = doorGroup.uuid;

      if (!cabinetDoorStates.has(doorId)) {
        // Get hinge direction from userData
        const hingeOnLeft = doorGroup.userData?.hingeOnLeft ?? true;
        const openAngle = doorGroup.userData?.openAngle ?? (hingeOnLeft ? Math.PI / 2 : -Math.PI / 2);

        cabinetDoorStates.set(doorId, {
          isOpen: false,
          originalRotation: doorGroup.rotation.clone(),
          originalPosition: doorGroup.position.clone(),
          hingeOnLeft: hingeOnLeft,
          openAngle: openAngle
        });
      }

      const state = cabinetDoorStates.get(doorId);
      const targetOpen = !state.isOpen;

      // Animate the door/drawer
      animateCabinetPart(doorGroup, partType, targetOpen, state);

      state.isOpen = targetOpen;
      showToast(targetOpen ? 'Door opened' : 'Door closed', 'info');
    }

    function animateCabinetPart(obj, partType, opening, state) {
      const duration = 400; // ms
      const startTime = performance.now();

      const startRotation = obj.rotation.y;
      const startPosition = obj.position.z;

      // Target values based on door swing direction
      let targetRotation = startRotation;
      let targetPosition = startPosition;

      if (partType === 'door') {
        // Doors swing open - use the openAngle from state (accounts for hinge side)
        const openAngle = state.openAngle || Math.PI / 2;
        targetRotation = opening ? state.originalRotation.y + openAngle : state.originalRotation.y;
      } else if (partType === 'drawer') {
        // Drawers slide out - use slideDistance from userData or default
        const slideDistance = obj.userData?.slideDistance || 0.8;
        targetPosition = opening ? state.originalPosition.z + slideDistance : state.originalPosition.z;
      }

      function animate() {
        const elapsed = performance.now() - startTime;
        const progress = Math.min(elapsed / duration, 1);

        // Ease out cubic
        const eased = 1 - Math.pow(1 - progress, 3);

        if (partType === 'door') {
          obj.rotation.y = startRotation + (targetRotation - startRotation) * eased;
        } else if (partType === 'drawer') {
          obj.position.z = startPosition + (targetPosition - startPosition) * eased;
        }

        if (progress < 1) {
          requestAnimationFrame(animate);
        }

        // Re-render the scene
        if (renderer && scene && camera) {
          renderer.render(scene, camera);
        }
      }

      animate();
    }

    // Toggle interactive mode
    window.toggleInteractiveMode = function() {
      interactiveModeEnabled = !interactiveModeEnabled;
      showToast(interactiveModeEnabled ? 'Interactive mode ON - Double-click doors/drawers to open' : 'Interactive mode OFF', 'info');
    };

    // Initialize cabinet interaction when 3D view is set up
    setTimeout(setupCabinetInteraction, 1000);

    // ===== MATERIAL DRAG & DROP TO 3D VIEW =====
    let draggingMaterial = null;
    let dropPreviewMesh = null;

    function setup3DMaterialDrop() {
      const container = document.getElementById('three-container');
      if (!container) return;

      container.addEventListener('dragover', on3DDragOver);
      container.addEventListener('drop', on3DDrop);
      container.addEventListener('dragleave', on3DDragLeave);
    }

    function on3DDragOver(event) {
      event.preventDefault();
      event.dataTransfer.dropEffect = 'copy';

      if (!renderer || !camera || !scene || currentView !== '3d') return;

      const container = document.getElementById('three-container');
      const rect = container.getBoundingClientRect();

      const mouse = new THREE.Vector2(
        ((event.clientX - rect.left) / rect.width) * 2 - 1,
        -((event.clientY - rect.top) / rect.height) * 2 + 1
      );

      const raycaster = new THREE.Raycaster();
      raycaster.setFromCamera(mouse, camera);

      // Find element under cursor
      const meshes = [];
      scene.traverse(obj => {
        if (obj.isMesh && obj.userData.elementId) meshes.push(obj);
      });

      const intersects = raycaster.intersectObjects(meshes, false);

      // Clear previous highlight
      if (dropPreviewMesh && dropPreviewMesh !== intersects[0]?.object) {
        if (dropPreviewMesh.userData.originalEmissive !== undefined) {
          dropPreviewMesh.material.emissive?.setHex(dropPreviewMesh.userData.originalEmissive);
        }
        dropPreviewMesh = null;
      }

      // Highlight hovered element
      if (intersects.length > 0) {
        const mesh = intersects[0].object;
        if (mesh.material && mesh.material.emissive) {
          if (!dropPreviewMesh || dropPreviewMesh !== mesh) {
            mesh.userData.originalEmissive = mesh.material.emissive.getHex();
            mesh.material.emissive.setHex(0x333366);
            dropPreviewMesh = mesh;
          }
        }
      }
    }

    function on3DDragLeave(event) {
      // Clear highlight
      if (dropPreviewMesh) {
        if (dropPreviewMesh.userData.originalEmissive !== undefined) {
          dropPreviewMesh.material.emissive?.setHex(dropPreviewMesh.userData.originalEmissive);
        }
        dropPreviewMesh = null;
      }
    }

    function on3DDrop(event) {
      event.preventDefault();

      // Clear highlight
      if (dropPreviewMesh) {
        if (dropPreviewMesh.userData.originalEmissive !== undefined) {
          dropPreviewMesh.material.emissive?.setHex(dropPreviewMesh.userData.originalEmissive);
        }
      }

      if (!renderer || !camera || !scene || currentView !== '3d') return;

      // Get dropped material data
      const materialData = event.dataTransfer.getData('application/json');
      if (!materialData) {
        dropPreviewMesh = null;
        return;
      }

      try {
        const material = JSON.parse(materialData);

        const container = document.getElementById('three-container');
        const rect = container.getBoundingClientRect();

        const mouse = new THREE.Vector2(
          ((event.clientX - rect.left) / rect.width) * 2 - 1,
          -((event.clientY - rect.top) / rect.height) * 2 + 1
        );

        const raycaster = new THREE.Raycaster();
        raycaster.setFromCamera(mouse, camera);

        const meshes = [];
        scene.traverse(obj => {
          if (obj.isMesh && obj.userData.elementId) meshes.push(obj);
        });

        const intersects = raycaster.intersectObjects(meshes, false);

        if (intersects.length > 0) {
          const hitMesh = intersects[0].object;
          const elementId = hitMesh.userData.elementId;

          // Find the element in our data
          const room = rooms[currentRoomIndex];
          const element = room?.elements?.find(el => el.id === elementId);

          if (element) {
            // Check material type compatibility before applying
            const materialCategory = material.category || material.type || '';
            if (!canApplyMaterialToElement(materialCategory, element)) {
              dropPreviewMesh = null;
              return;
            }

            // Apply material to element
            element.material = material.name;
            element.materialId = material.id;
            element.texture = material.image || material.texture;
            element.color = material.color;

            // Update 3D view
            update3DScene();

            showToast(`Applied "${material.name}" to ${element.label || element.type}`, 'success');
          }
        }
      } catch (e) {
        console.error('Failed to parse dropped material:', e);
      }

      dropPreviewMesh = null;
    }

    // Make material cards draggable
    function enableMaterialDrag() {
      document.querySelectorAll('.material-card, .product-card').forEach(card => {
        card.draggable = true;
        card.addEventListener('dragstart', (e) => {
          // Try to determine material category from the id or data attributes
          let category = card.dataset.category || card.dataset.type || '';
          if (!category && card.dataset.id) {
            // Look up category from MATERIALS object
            for (const [cat, materials] of Object.entries(MATERIALS)) {
              if (materials.find(m => m.id === card.dataset.id)) {
                category = cat;
                break;
              }
            }
          }
          const materialData = {
            id: card.dataset.id,
            name: card.dataset.name || card.querySelector('.material-name, .product-name')?.textContent,
            image: card.dataset.image || card.querySelector('img')?.src,
            color: card.dataset.color,
            price: card.dataset.price,
            category: category,
            type: card.dataset.type || category
          };
          e.dataTransfer.setData('application/json', JSON.stringify(materialData));
          e.dataTransfer.effectAllowed = 'copy';
        });
      });
    }

    // Initialize drag-drop when ready
    setTimeout(() => {
      setup3DMaterialDrop();
      enableMaterialDrag();
    }, 2000);

    // Re-enable drag after material list updates
    const materialListObserver = new MutationObserver(() => {
      enableMaterialDrag();
    });

    setTimeout(() => {
      const materialContainer = document.querySelector('.material-grid, .product-grid');
      if (materialContainer) {
        materialListObserver.observe(materialContainer, { childList: true, subtree: true });
      }
    }, 3000);

    // ===== HIGH-RESOLUTION SCREENSHOT =====
    window.captureHighResScreenshot = function() {
      if (!renderer || !scene || !camera) {
        showToast('3D view not available', 'error');
        return;
      }

      showToast('Capturing high-resolution screenshot...', 'info');

      // Store original size
      const originalWidth = renderer.domElement.width;
      const originalHeight = renderer.domElement.height;
      const originalPixelRatio = renderer.getPixelRatio();

      // Set high resolution (4x for 4K-like output)
      const scale = 3;
      const newWidth = originalWidth * scale;
      const newHeight = originalHeight * scale;

      renderer.setSize(newWidth, newHeight, false);
      renderer.setPixelRatio(1);

      // Render at high resolution
      if (composer && postProcessingEnabled && window._postProcessing?.enabled) {
        composer.setSize(newWidth, newHeight);
        composer.render();
      } else {
        renderer.render(scene, camera);
      }

      // Capture image
      const dataUrl = renderer.domElement.toDataURL('image/png', 1.0);

      // Restore original size
      renderer.setSize(originalWidth, originalHeight, false);
      renderer.setPixelRatio(originalPixelRatio);
      if (composer) {
        composer.setSize(originalWidth, originalHeight);
      }

      // Create download link
      const link = document.createElement('a');
      const room = rooms[currentRoomIndex];
      const filename = `${room?.name || 'room'}-3d-${Date.now()}.png`;
      link.download = filename;
      link.href = dataUrl;
      link.click();

      showToast('Screenshot saved!', 'success');
    };

    // ===== ZOOM =====
    function zoomIn() {
      const wrapper = document.getElementById('canvasWrapper');
      const centerX = wrapper.clientWidth / 2;
      const centerY = wrapper.clientHeight / 2;

      const worldX = (centerX - panX) / pixelsPerFoot;
      const worldY = (centerY - panY) / pixelsPerFoot;

      pixelsPerFoot = Math.min(pixelsPerFoot * 1.2, 200); // Allow closer zoom (up to 500%)

      panX = centerX - worldX * pixelsPerFoot;
      panY = centerY - worldY * pixelsPerFoot;

      updateZoomDisplay();
      draw();
    }

    function zoomOut() {
      const wrapper = document.getElementById('canvasWrapper');
      const centerX = wrapper.clientWidth / 2;
      const centerY = wrapper.clientHeight / 2;

      const worldX = (centerX - panX) / pixelsPerFoot;
      const worldY = (centerY - panY) / pixelsPerFoot;

      pixelsPerFoot = Math.max(pixelsPerFoot / 1.2, 5); // Allow further zoom out (down to ~12%)

      panX = centerX - worldX * pixelsPerFoot;
      panY = centerY - worldY * pixelsPerFoot;

      updateZoomDisplay();
      draw();
    }

    function updateZoomDisplay() {
      const zoomPercent = Math.round(pixelsPerFoot / 40 * 100);
      document.getElementById('zoomLevel').textContent = zoomPercent + '%';
    }

    // Reset zoom to 100% and center the room
    function resetZoom() {
      const wrapper = document.getElementById('canvasWrapper');
      pixelsPerFoot = 40; // 100%

      // Center the room in the canvas
      panX = (wrapper.clientWidth - roomWidth * pixelsPerFoot) / 2;
      panY = (wrapper.clientHeight - roomDepth * pixelsPerFoot) / 2;

      updateZoomDisplay();
      draw();
      showSnapFeedback('Zoom reset to 100%');
    }

    function toggleViewLock() {
      viewLocked = !viewLocked;
      const btn = document.getElementById('lockViewBtn');
      const icon = document.getElementById('lockIcon');
      if (btn) {
        btn.title = viewLocked ? 'Unlock view (allow pan/zoom)' : 'Lock view (prevent pan/zoom)';
        btn.style.background = viewLocked ? 'rgba(249, 203, 0, 0.2)' : '';
        btn.style.borderColor = viewLocked ? 'var(--gold)' : '';
      }
      if (icon) {
        // Update lock icon - locked shows closed shackle
        const path = icon.querySelector('path');
        if (path) {
          path.setAttribute('d', viewLocked ? 'M7 11V7a5 5 0 0 1 10 0v4' : 'M7 11V7a5 5 0 0 1 9 0');
        }
        icon.style.stroke = viewLocked ? 'var(--gold)' : '';
      }
      showSnapFeedback(viewLocked ? 'View locked - pan/zoom disabled' : 'View unlocked');
    }

    // ===== ROOM =====
    function updateRoom() {
      roomWidth = parseInt(document.getElementById('roomWidth').value) || 20;
      roomDepth = parseInt(document.getElementById('roomDepth').value) || 16;

      if (document.getElementById('scaleMode').value === 'fit') {
        fitToScreen();
      } else {
        updateCanvasSize();
      }

      if (currentView === '3d') {
        init3D();
        render3D();
      }
    }

    // ===== ROOM TEMPLATES =====
    // Rotation guide (top-down view, doors/drawers face INTO room):
    //   Back wall (y=0):    rotation = 0   (faces down/south into room)
    //   Right wall (x=max): rotation = 90  (faces left/west into room)
    //   Front wall (y=max): rotation = 180 (faces up/north into room)
    //   Left wall (x=0):    rotation = 270 (faces right/east into room)
    //
    // Standard dimensions (in feet):
    //   BASE_DEPTH: 2 (24"), WALL_DEPTH: 1 (12"), COUNTER_OVERHANG: 0.125 (1.5")
    //   WALKWAY: 3 (36" min), ISLAND_WALKWAY: 3.5 (42" recommended)
    //   FRIDGE_DEPTH: 2.5 (30"), RANGE_DEPTH: 2.17 (26")
    const ROOM_TEMPLATES = {
      'kitchen-l': {
        name: 'L-Shaped Kitchen',
        roomType: 'kitchen',
        width: 12,
        depth: 10,
        elements: [
          // === BACK WALL (y=0) - faces into room (rotation: 0) ===
          // Design: Work triangle - Fridge (left) to Sink (center) to Range (right wall)
          // Triangle distances: Fridge-Sink ~5', Sink-Range ~6', Range-Fridge ~7' (ideal 12-26' total)
          { type: 'refrigerator', x: 0, y: 0, width: 3, height: 2.5, label: 'Refrigerator 36"', rotation: 0 },
          { type: 'base-cabinet', x: 3, y: 0, width: 2, height: 2, label: 'Base 24"', rotation: 0 },
          { type: 'dishwasher', x: 5, y: 0, width: 2, height: 2, label: 'Dishwasher 24"', rotation: 0 },
          { type: 'sink-base', x: 7, y: 0, width: 3, height: 2, label: 'Sink Base 36"', rotation: 0 },
          // Countertop: base depth 2' + 1.5" overhang = 2.125' total
          { type: 'countertop', x: 2.875, y: -0.04, width: 7.25, height: 2.165, label: 'Back Counter', rotation: 0, overhangFront: 0.125, overhangBack: 0, overhangLeft: 0.125, overhangRight: 0.125 },
          { type: 'sink', x: 7.5, y: 0.25, width: 2.5, height: 1.5, label: 'Undermount Sink', rotation: 0 },
          // Wall cabinets: 12" (1') deep, mounted 18" above counter
          { type: 'wall-cabinet', x: 3, y: 0, width: 4, height: 1, label: 'Upper 48"', rotation: 0 },
          { type: 'wall-cabinet', x: 7, y: 0, width: 3, height: 1, label: 'Upper 36"', rotation: 0 },

          // === RIGHT WALL (x=10) - faces into room (rotation: 90) ===
          // Position: x = roomWidth - cabinetDepth = 12 - 2 = 10
          { type: 'base-cabinet', x: 10, y: 0, width: 2, height: 2, label: 'Corner Base', rotation: 90 },
          { type: 'base-cabinet', x: 10, y: 2, width: 2, height: 2, label: 'Base 24"', rotation: 90 },
          { type: 'range', x: 10, y: 4, width: 2.5, height: 2.5, label: 'Range 30"', rotation: 90 },
          { type: 'range-hood', x: 11, y: 4.25, width: 1, height: 2.5, label: 'Range Hood', rotation: 90 },
          { type: 'base-cabinet', x: 10, y: 6.5, width: 2, height: 2, label: 'Base 24"', rotation: 90 },
          { type: 'base-cabinet', x: 10, y: 8.5, width: 2, height: 1.5, label: 'Base 18"', rotation: 90 },
          // Right wall countertops
          { type: 'countertop', x: 9.835, y: -0.04, width: 2.165, height: 4.21, label: 'Right Counter', rotation: 0, overhangFront: 0.125, overhangBack: 0, overhangLeft: 0.125, overhangRight: 0 },
          { type: 'countertop', x: 9.835, y: 6.375, width: 2.165, height: 3.625, label: 'Right Counter', rotation: 0, overhangFront: 0.125, overhangBack: 0, overhangLeft: 0.125, overhangRight: 0 },
          // Wall cabinets: 1' deep
          { type: 'wall-cabinet', x: 11, y: 0, width: 1, height: 4, label: 'Upper 48"', rotation: 90 },
          { type: 'wall-cabinet', x: 11, y: 6.5, width: 1, height: 3.5, label: 'Upper 42"', rotation: 90 },

          // === BACKSPLASH - thin (1") against wall ===
          { type: 'backsplash', x: 3, y: 0, width: 7, height: 0.08, label: 'Tile Backsplash', rotation: 0 },
          { type: 'backsplash', x: 11.92, y: 0, width: 0.08, height: 10, label: 'Tile Backsplash', rotation: 0 },

          // === ISLAND - 42" walkway all sides ===
          // Position: 3.5' from back cabinets (2' + 0.125 overhang + 3.5' walkway = 5.625)
          { type: 'base-cabinet', x: 2.5, y: 5.5, width: 5, height: 2, label: 'Island Base 60"', rotation: 180 },
          { type: 'countertop', x: 2.375, y: 5.375, width: 5.25, height: 3, label: 'Island w/ Seating', rotation: 0, waterfallSides: ['left', 'right'], overhangFront: 0.125, overhangBack: 0.875, overhangLeft: 0.125, overhangRight: 0.125 },
        ]
      },
      'kitchen-galley': {
        name: 'Galley Kitchen',
        roomType: 'kitchen',
        width: 12,
        depth: 8,
        elements: [
          // === BACK WALL (y=0) - faces into room (rotation: 0) ===
          // Design: Parallel counters with 48" (4') walkway - efficient for one cook
          // Sink side - windows often here for natural light while washing
          { type: 'base-cabinet', x: 0, y: 0, width: 2, height: 2, label: 'Base 24"', rotation: 0 },
          { type: 'dishwasher', x: 2, y: 0, width: 2, height: 2, label: 'Dishwasher 24"', rotation: 0 },
          { type: 'sink-base', x: 4, y: 0, width: 3, height: 2, label: 'Sink Base 36"', rotation: 0 },
          { type: 'base-cabinet', x: 7, y: 0, width: 2, height: 2, label: 'Base 24"', rotation: 0 },
          { type: 'base-cabinet', x: 9, y: 0, width: 3, height: 2, label: 'Base 36"', rotation: 0 },
          { type: 'countertop', x: -0.125, y: -0.04, width: 12.25, height: 2.165, label: 'Counter', rotation: 0, overhangFront: 0.125, overhangBack: 0, overhangLeft: 0.125, overhangRight: 0.125 },
          { type: 'sink', x: 4.5, y: 0.25, width: 2.5, height: 1.5, label: 'Sink', rotation: 0 },
          // Wall cabinets: 12" (1') deep
          { type: 'wall-cabinet', x: 0, y: 0, width: 4, height: 1, label: 'Upper 48"', rotation: 0 },
          { type: 'wall-cabinet', x: 4, y: 0, width: 3, height: 1, label: 'Upper 36"', rotation: 0 },
          { type: 'wall-cabinet', x: 7, y: 0, width: 5, height: 1, label: 'Upper 60"', rotation: 0 },

          // === FRONT WALL (y=6) - faces into room (rotation: 180) ===
          // Position: y = roomDepth - cabinetDepth = 8 - 2 = 6
          // Cooking side - range centered for efficient workflow
          { type: 'refrigerator', x: 0, y: 5.5, width: 3, height: 2.5, label: 'Refrigerator 36"', rotation: 180 },
          { type: 'base-cabinet', x: 3, y: 6, width: 2, height: 2, label: 'Base 24"', rotation: 180 },
          { type: 'range', x: 5, y: 5.75, width: 2.5, height: 2.25, label: 'Range 30"', rotation: 180 },
          { type: 'range-hood', x: 5.25, y: 7, width: 2.5, height: 1, label: 'Range Hood', rotation: 180 },
          { type: 'base-cabinet', x: 7.5, y: 6, width: 2, height: 2, label: 'Base 24"', rotation: 180 },
          { type: 'base-cabinet', x: 9.5, y: 6, width: 2.5, height: 2, label: 'Base 30"', rotation: 180 },
          { type: 'countertop', x: 2.875, y: 5.835, width: 9.25, height: 2.165, label: 'Counter', rotation: 0, overhangFront: 0.125, overhangBack: 0, overhangLeft: 0.125, overhangRight: 0.125 },
          // Wall cabinets: 12" (1') deep
          { type: 'wall-cabinet', x: 3, y: 7, width: 2, height: 1, label: 'Upper 24"', rotation: 180 },
          { type: 'wall-cabinet', x: 7.5, y: 7, width: 4.5, height: 1, label: 'Uppers 54"', rotation: 180 },
          // === BACKSPLASH ===
          { type: 'backsplash', x: 0, y: 0, width: 12, height: 0.08, label: 'Subway Tile', rotation: 0 },
          { type: 'backsplash', x: 3, y: 7.92, width: 9, height: 0.08, label: 'Subway Tile', rotation: 0 },
        ]
      },
      'kitchen-u': {
        name: 'U-Shaped Kitchen',
        roomType: 'kitchen',
        width: 14,
        depth: 12,
        elements: [
          // === BACK WALL (y=0) - faces into room (rotation: 0) ===
          // Sink centered under window
          { type: 'base-cabinet', x: 2, y: 0, width: 2, height: 2, label: 'Base 24"', rotation: 0 },
          { type: 'dishwasher', x: 4, y: 0, width: 2, height: 2, label: 'Dishwasher', rotation: 0 },
          { type: 'sink-base', x: 6, y: 0, width: 3, height: 2, label: 'Sink Base 36"', rotation: 0 },
          { type: 'base-cabinet', x: 9, y: 0, width: 3, height: 2, label: 'Base 36"', rotation: 0 },
          { type: 'countertop', x: 1.875, y: -0.04, width: 10.25, height: 2.165, label: 'Counter', rotation: 0, overhangFront: 0.125, overhangBack: 0, overhangLeft: 0.125, overhangRight: 0.125 },
          { type: 'sink', x: 6.5, y: 0.25, width: 2, height: 1.5, label: 'Sink', rotation: 0 },
          { type: 'wall-cabinet', x: 2, y: 0, width: 4, height: 1, label: 'Upper 48"', rotation: 0 },
          { type: 'wall-cabinet', x: 6, y: 0, width: 3, height: 1, label: 'Upper 36"', rotation: 0 },
          { type: 'wall-cabinet', x: 9, y: 0, width: 3, height: 1, label: 'Upper 36"', rotation: 0 },

          // === LEFT WALL (x=0) - faces into room (rotation: 270) ===
          // Fridge at corner, then pantry/storage
          { type: 'refrigerator', x: 0, y: 0, width: 2.5, height: 3, label: 'Fridge', rotation: 270 },
          { type: 'tall-cabinet', x: 0, y: 3, width: 2, height: 2, label: 'Pantry', rotation: 270 },
          { type: 'base-cabinet', x: 0, y: 5, width: 2, height: 2, label: 'Base 24"', rotation: 270 },
          { type: 'base-cabinet', x: 0, y: 7, width: 2, height: 2, label: 'Base 24"', rotation: 270 },
          { type: 'base-cabinet', x: 0, y: 9, width: 2, height: 3, label: 'Base 36"', rotation: 270 },
          { type: 'countertop', x: -0.04, y: 4.875, width: 2.165, height: 7.125, label: 'Counter', rotation: 0, overhangFront: 0.125, overhangBack: 0, overhangLeft: 0, overhangRight: 0.125 },
          { type: 'wall-cabinet', x: 0, y: 5, width: 1, height: 7, label: 'Uppers', rotation: 270 },

          // === RIGHT WALL (x=12) - faces into room (rotation: 90) ===
          // Position: x = roomWidth - cabinetDepth = 14 - 2 = 12
          // Range centered with cabinets on both sides
          { type: 'base-cabinet', x: 12, y: 0, width: 2, height: 2, label: 'Corner Base', rotation: 90 },
          { type: 'base-cabinet', x: 12, y: 2, width: 2, height: 2, label: 'Base 24"', rotation: 90 },
          { type: 'range', x: 11.83, y: 4, width: 2.17, height: 2.5, label: 'Range 30"', rotation: 90 },
          { type: 'range-hood', x: 13, y: 4.25, width: 1, height: 2, label: 'Hood', rotation: 90 },
          { type: 'base-cabinet', x: 12, y: 6.5, width: 2, height: 2, label: 'Base 24"', rotation: 90 },
          { type: 'base-cabinet', x: 12, y: 8.5, width: 2, height: 3.5, label: 'Base 42"', rotation: 90 },
          { type: 'countertop', x: 11.835, y: -0.04, width: 2.165, height: 4.165, label: 'Counter', rotation: 0, overhangFront: 0.125, overhangBack: 0, overhangLeft: 0.125, overhangRight: 0 },
          { type: 'countertop', x: 11.835, y: 6.375, width: 2.165, height: 5.625, label: 'Counter', rotation: 0, overhangFront: 0.125, overhangBack: 0, overhangLeft: 0.125, overhangRight: 0 },
          { type: 'wall-cabinet', x: 13, y: 0, width: 1, height: 4, label: 'Uppers', rotation: 90 },
          { type: 'wall-cabinet', x: 13, y: 6.5, width: 1, height: 5.5, label: 'Uppers', rotation: 90 },

          // === BACKSPLASH ===
          { type: 'backsplash', x: 2, y: 0, width: 10, height: 0.08, label: 'Backsplash', rotation: 0 },
          { type: 'backsplash', x: 0, y: 5, width: 0.08, height: 7, label: 'Backsplash', rotation: 0 },
          { type: 'backsplash', x: 13.92, y: 0, width: 0.08, height: 12, label: 'Backsplash', rotation: 0 },
        ]
      },
      'kitchen-single': {
        name: 'Single Wall Kitchen',
        roomType: 'kitchen',
        width: 14,
        depth: 8,
        elements: [
          // === SINGLE WALL (y=0) - compact kitchen on one wall ===
          // Layout: Fridge - Counter - Sink - Counter - Range - Counter
          { type: 'refrigerator', x: 0, y: 0, width: 3, height: 2.5, label: 'Fridge', rotation: 0 },
          { type: 'base-cabinet', x: 3, y: 0, width: 2, height: 2, label: 'Base 24"', rotation: 0 },
          { type: 'dishwasher', x: 5, y: 0, width: 2, height: 2, label: 'Dishwasher', rotation: 0 },
          { type: 'sink-base', x: 7, y: 0, width: 3, height: 2, label: 'Sink Base 36"', rotation: 0 },
          { type: 'base-cabinet', x: 10, y: 0, width: 1.5, height: 2, label: 'Base 18"', rotation: 0 },
          { type: 'range', x: 11.5, y: 0, width: 2.5, height: 2.17, label: 'Range 30"', rotation: 0 },
          { type: 'countertop', x: 2.875, y: -0.04, width: 8.75, height: 2.165, label: 'Counter', rotation: 0, overhangFront: 0.125, overhangBack: 0, overhangLeft: 0.125, overhangRight: 0.125 },
          { type: 'sink', x: 7.5, y: 0.25, width: 2, height: 1.5, label: 'Sink', rotation: 0 },
          { type: 'wall-cabinet', x: 3, y: 0, width: 4, height: 1, label: 'Upper 48"', rotation: 0 },
          { type: 'wall-cabinet', x: 7, y: 0, width: 3, height: 1, label: 'Upper 36"', rotation: 0 },
          { type: 'wall-cabinet', x: 10, y: 0, width: 1.5, height: 1, label: 'Upper 18"', rotation: 0 },
          { type: 'range-hood', x: 11.5, y: 0, width: 2.5, height: 1, label: 'Hood', rotation: 0 },
          // Backsplash
          { type: 'backsplash', x: 3, y: 0, width: 11, height: 0.08, label: 'Backsplash', rotation: 0 },

          // Optional island for extra prep space - centered with 42"+ walkways
          { type: 'base-cabinet', x: 4, y: 5, width: 6, height: 2, label: 'Island Base', rotation: 180 },
          { type: 'countertop', x: 3.875, y: 4.875, width: 6.25, height: 3, label: 'Island w/ Seating', rotation: 0, overhangFront: 0.125, overhangBack: 0.875, overhangLeft: 0.125, overhangRight: 0.125 },
        ]
      },
      'kitchen-peninsula': {
        name: 'Peninsula Kitchen',
        roomType: 'kitchen',
        width: 14,
        depth: 12,
        elements: [
          // === BACK WALL (y=0) - faces into room (rotation: 0) ===
          { type: 'refrigerator', x: 0, y: 0, width: 3, height: 2.5, label: 'Fridge', rotation: 0 },
          { type: 'base-cabinet', x: 3, y: 0, width: 2, height: 2, label: 'Base 24"', rotation: 0 },
          { type: 'dishwasher', x: 5, y: 0, width: 2, height: 2, label: 'Dishwasher', rotation: 0 },
          { type: 'sink-base', x: 7, y: 0, width: 3, height: 2, label: 'Sink Base 36"', rotation: 0 },
          { type: 'base-cabinet', x: 10, y: 0, width: 2, height: 2, label: 'Base 24"', rotation: 0 },
          { type: 'countertop', x: 2.875, y: -0.04, width: 9.25, height: 2.165, label: 'Counter', rotation: 0, overhangFront: 0.125, overhangBack: 0, overhangLeft: 0.125, overhangRight: 0.125 },
          { type: 'sink', x: 7.5, y: 0.25, width: 2, height: 1.5, label: 'Sink', rotation: 0 },
          { type: 'wall-cabinet', x: 3, y: 0, width: 4, height: 1, label: 'Upper 48"', rotation: 0 },
          { type: 'wall-cabinet', x: 7, y: 0, width: 3, height: 1, label: 'Upper 36"', rotation: 0 },
          { type: 'wall-cabinet', x: 10, y: 0, width: 2, height: 1, label: 'Uppers', rotation: 0 },

          // === RIGHT WALL (x=12) - faces into room (rotation: 90) ===
          // Position: x = roomWidth - cabinetDepth = 14 - 2 = 12
          { type: 'base-cabinet', x: 12, y: 0, width: 2, height: 2, label: 'Corner Base', rotation: 90 },
          { type: 'base-cabinet', x: 12, y: 2, width: 2, height: 2, label: 'Base 24"', rotation: 90 },
          { type: 'range', x: 11.83, y: 4, width: 2.17, height: 2.5, label: 'Range 30"', rotation: 90 },
          { type: 'range-hood', x: 13, y: 4.25, width: 1, height: 2, label: 'Hood', rotation: 90 },
          { type: 'base-cabinet', x: 12, y: 6.5, width: 2, height: 2, label: 'Base 24"', rotation: 90 },
          { type: 'countertop', x: 11.835, y: -0.04, width: 2.165, height: 4.165, label: 'Counter', rotation: 0, overhangFront: 0.125, overhangBack: 0, overhangLeft: 0.125, overhangRight: 0 },
          { type: 'countertop', x: 11.835, y: 6.375, width: 2.165, height: 2.25, label: 'Counter', rotation: 0, overhangFront: 0.125, overhangBack: 0, overhangLeft: 0.125, overhangRight: 0 },
          { type: 'wall-cabinet', x: 13, y: 0, width: 1, height: 4, label: 'Uppers', rotation: 90 },
          { type: 'wall-cabinet', x: 13, y: 6.5, width: 1, height: 2, label: 'Upper', rotation: 90 },

          // === PENINSULA - attached to right wall, extends into room ===
          // Waterfall on end, breakfast bar overhang on open side (facing into room)
          { type: 'base-cabinet', x: 12, y: 8.5, width: 2, height: 3.5, label: 'Peninsula Base', rotation: 90 },
          { type: 'base-cabinet', x: 8, y: 10, width: 4, height: 2, label: 'Peninsula Base', rotation: 180 },
          { type: 'countertop', x: 7.875, y: 8.375, width: 6.125, height: 3.75, label: 'Peninsula Top', rotation: 0, waterfallSides: ['left'], overhangFront: 0.125, overhangBack: 0.875, overhangLeft: 0.125, overhangRight: 0 },

          // === BACKSPLASH ===
          { type: 'backsplash', x: 3, y: 0, width: 9, height: 0.08, label: 'Backsplash', rotation: 0 },
          { type: 'backsplash', x: 13.92, y: 0, width: 0.08, height: 8.5, label: 'Backsplash', rotation: 0 },
        ]
      },
      'bathroom-master': {
        name: 'Master Bathroom',
        roomType: 'bathroom',
        width: 12,
        depth: 10,
        elements: [
          // === BACK WALL (y=0) - Double vanity ===
          { type: 'base-cabinet', x: 0, y: 0, width: 2, height: 1.75, label: 'Vanity', rotation: 0 },
          { type: 'base-cabinet', x: 2, y: 0, width: 2, height: 1.75, label: 'Vanity', rotation: 0 },
          { type: 'base-cabinet', x: 4, y: 0, width: 2, height: 1.75, label: 'Vanity', rotation: 0 },
          { type: 'countertop', x: -0.08, y: -0.04, width: 6.16, height: 1.915, color: '#d4a574', rotation: 0, overhangFront: 0.125, overhangBack: 0, overhangLeft: 0.08, overhangRight: 0.08 },
          { type: 'sink', x: 0.75, y: 0.2, width: 1.5, height: 1.2, label: 'Sink', rotation: 0 },
          { type: 'sink', x: 3.75, y: 0.2, width: 1.5, height: 1.2, label: 'Sink', rotation: 0 },
          { type: 'mirror', x: 0.25, y: 0, width: 2.5, height: 0.15, label: 'Mirror', rotation: 0 },
          { type: 'mirror', x: 3.25, y: 0, width: 2.5, height: 0.15, label: 'Mirror', rotation: 0 },
          // === RIGHT WALL (x=10.5) - Toilet faces left into room ===
          // Position: x = roomWidth - toiletDepth = 12 - 1.5 = 10.5
          // 15" clearance on each side of toilet centerline
          { type: 'toilet', x: 10.5, y: 4, width: 1.5, height: 2.3, label: 'Toilet', rotation: 90 },
          // === LEFT WALL (x=0) - Bathtub faces right into room ===
          { type: 'bathtub', x: 0, y: 5, width: 2.7, height: 5, label: 'Bathtub', rotation: 270 },
          // === RIGHT CORNER - Walk-in shower ===
          { type: 'shower-pan', x: 9, y: 0, width: 3, height: 3.5, label: 'Shower', rotation: 0 },
          { type: 'shower-wall', x: 9, y: 0, width: 0.25, height: 3.5, label: 'Glass', rotation: 0 },
          { type: 'shower-niche', x: 10.5, y: 0, width: 1.5, height: 0.5, label: 'Niche', rotation: 0 },
          // === BACK WALL - Linen closet ===
          { type: 'tall-cabinet', x: 6.5, y: 0, width: 2, height: 2, label: 'Linen', rotation: 0 },
        ]
      },
      'bathroom-half': {
        name: 'Half Bathroom',
        roomType: 'bathroom',
        width: 6,
        depth: 5,
        elements: [
          // === BACK WALL (y=0) - Vanity ===
          { type: 'base-cabinet', x: 0, y: 0, width: 2.5, height: 1.75, label: 'Vanity', rotation: 0 },
          { type: 'countertop', x: -0.08, y: -0.04, width: 2.66, height: 1.875, color: '#d4a574', rotation: 0, overhangFront: 0.125, overhangBack: 0, overhangLeft: 0.08, overhangRight: 0.08 },
          { type: 'sink', x: 0.3, y: 0.2, width: 1.9, height: 1.2, label: 'Sink', rotation: 0 },
          { type: 'mirror', x: 0.25, y: 0, width: 2, height: 0.15, label: 'Mirror', rotation: 0 },
          // === RIGHT SIDE - Toilet faces into room (rotation: 0) ===
          // 15" (1.25') clearance from right wall: x = 6 - 1.5 - 1.25 = 3.25
          { type: 'toilet', x: 3.25, y: 0.5, width: 1.5, height: 2.3, label: 'Toilet', rotation: 0 },
        ]
      },
      'shower-walkin': {
        name: 'Walk-in Shower',
        roomType: 'shower',
        width: 6,
        depth: 5,
        elements: [
          // Shower pan
          { type: 'shower-pan', x: 0, y: 0, width: 6, height: 5, label: 'Shower Pan' },
          // Shower walls with tile
          { type: 'shower-wall', x: 0, y: 0, width: 0.25, height: 5, label: 'Left Wall' },
          { type: 'shower-wall', x: 0, y: 0, width: 6, height: 0.25, label: 'Back Wall' },
          { type: 'shower-wall', x: 5.75, y: 0, width: 0.25, height: 5, label: 'Right Wall' },
          // Bench (corner seat)
          { type: 'shower-curb', x: 0.25, y: 3.5, width: 1.5, height: 1.25, label: 'Bench' },
          // Niches (recessed shelving)
          { type: 'shower-niche', x: 2, y: 0, width: 2, height: 0.5, label: 'Niche 1' },
          { type: 'shower-niche', x: 2, y: 1, width: 2, height: 0.5, label: 'Niche 2' },
          // Glass panel at entry (half-wall)
          { type: 'shower-wall', x: 3, y: 4.75, width: 3, height: 0.25, label: 'Glass Panel' },
        ]
      },
      'closet-walkin': {
        name: 'Walk-in Closet',
        roomType: 'closet',
        width: 10,
        depth: 8,
        elements: [
          // === LEFT WALL (x=0) - Double hang, faces right into room ===
          { type: 'tall-cabinet', x: 0, y: 0, width: 1.5, height: 3, label: 'Double Hang', rotation: 270 },
          { type: 'tall-cabinet', x: 0, y: 3, width: 1.5, height: 2.5, label: 'Double Hang', rotation: 270 },
          { type: 'tall-cabinet', x: 0, y: 5.5, width: 1.5, height: 2.5, label: 'Double Hang', rotation: 270 },
          // === FRONT WALL (y=6.5) - Shelving and drawers, faces back into room ===
          { type: 'tall-cabinet', x: 2, y: 6.5, width: 1.5, height: 2, label: 'Shelving', rotation: 180 },
          { type: 'drawer-base', x: 4, y: 6.5, width: 1.5, height: 2, label: 'Drawers', rotation: 180 },
          { type: 'tall-cabinet', x: 6, y: 6.5, width: 1.5, height: 2, label: 'Shelving', rotation: 180 },
          // === RIGHT WALL (x=8.5) - Long hang, faces left into room ===
          // Position: x = roomWidth - cabinetDepth = 10 - 1.5 = 8.5
          { type: 'tall-cabinet', x: 8.5, y: 0, width: 1.5, height: 4, label: 'Long Hang', rotation: 90 },
          { type: 'tall-cabinet', x: 8.5, y: 4, width: 1.5, height: 4, label: 'Long Hang', rotation: 90 },
          // === CENTER - Island/bench ===
          { type: 'island', x: 3.5, y: 2.5, width: 3, height: 2, label: 'Island Drawers', rotation: 0 },
          { type: 'countertop', x: 3.375, y: 2.375, width: 3.25, height: 2.25, color: '#8B4513', label: 'Bench Top', rotation: 0, overhangFront: 0.125, overhangBack: 0.125, overhangLeft: 0.125, overhangRight: 0.125 },
        ]
      },
      'laundry-room': {
        name: 'Laundry Room',
        roomType: 'laundry',
        width: 10,
        depth: 8,
        elements: [
          // === BACK WALL (y=0) - Washer, dryer, and utility sink ===
          { type: 'washer', x: 0, y: 0, width: 2.3, height: 2.3, label: 'Washer', rotation: 0 },
          { type: 'dryer', x: 2.5, y: 0, width: 2.3, height: 2.3, label: 'Dryer', rotation: 0 },
          // Upper cabinets above W/D
          { type: 'wall-cabinet', x: 0, y: 0, width: 2.5, height: 1, label: 'Upper', rotation: 0 },
          { type: 'wall-cabinet', x: 2.5, y: 0, width: 2.5, height: 1, label: 'Upper', rotation: 0 },
          // Utility sink area
          { type: 'base-cabinet', x: 5.5, y: 0, width: 2, height: 2, label: 'Base', rotation: 0 },
          { type: 'sink-base', x: 7.5, y: 0, width: 2.5, height: 2, label: 'Sink Base', rotation: 0 },
          { type: 'countertop', x: 5.375, y: -0.04, width: 4.625, height: 2.165, color: '#708090', rotation: 0, overhangFront: 0.125, overhangBack: 0, overhangLeft: 0.125, overhangRight: 0 },
          { type: 'sink', x: 7.75, y: 0.25, width: 2, height: 1.5, label: 'Utility Sink', rotation: 0 },
          // === FRONT WALL (y=6) - Folding counter, faces back into room ===
          // Position: y = roomDepth - cabinetDepth = 8 - 2 = 6
          { type: 'base-cabinet', x: 0, y: 6, width: 2, height: 2, label: 'Base', rotation: 180 },
          { type: 'base-cabinet', x: 2, y: 6, width: 2, height: 2, label: 'Base', rotation: 180 },
          { type: 'base-cabinet', x: 4, y: 6, width: 2, height: 2, label: 'Base', rotation: 180 },
          { type: 'countertop', x: -0.125, y: 5.835, width: 6.25, height: 2.165, color: '#708090', label: 'Folding Counter', rotation: 0, overhangFront: 0.125, overhangBack: 0, overhangLeft: 0.125, overhangRight: 0.125 },
          // Wall cabinets
          { type: 'wall-cabinet', x: 0, y: 7, width: 2, height: 1, label: 'Upper', rotation: 180 },
          { type: 'wall-cabinet', x: 2, y: 7, width: 2, height: 1, label: 'Upper', rotation: 180 },
          { type: 'wall-cabinet', x: 4, y: 7, width: 2, height: 1, label: 'Upper', rotation: 180 },
          // Tall storage
          { type: 'tall-cabinet', x: 8, y: 6, width: 2, height: 2, label: 'Tall Storage', rotation: 180 },
        ]
      },
      'bathroom-master-full': {
        name: 'Master Bath (Full Luxury)',
        roomType: 'bathroom',
        width: 14,
        depth: 12,
        elements: [
          // === His/Hers Vanity Wall (y=0) ===
          { type: 'vanity-hishers-108', x: 2.5, y: 0, width: 9, height: 1.75, label: 'Double Vanity 108"', rotation: 0 },
          { type: 'countertop', x: 2.375, y: -0.04, width: 9.25, height: 1.875, color: '#708090', rotation: 0, overhangFront: 0.125, overhangBack: 0, overhangLeft: 0.125, overhangRight: 0.125 },
          { type: 'sink', x: 3.5, y: 0.2, width: 1.5, height: 1.2, label: 'His Sink', rotation: 0 },
          { type: 'sink', x: 9, y: 0.2, width: 1.5, height: 1.2, label: 'Hers Sink', rotation: 0 },
          { type: 'mirror', x: 3, y: 0, width: 2.5, height: 0.15, label: 'Mirror', rotation: 0 },
          { type: 'mirror', x: 8.5, y: 0, width: 2.5, height: 0.15, label: 'Mirror', rotation: 0 },
          // === Linen closet (left wall) ===
          { type: 'linen-closet', x: 0, y: 0, width: 1.5, height: 2, label: 'Linen Closet', rotation: 270 },
          // === Toilet alcove (right wall) - faces into room ===
          // Position: x = roomWidth - toiletDepth = 14 - 1.5 = 12.5
          { type: 'toilet', x: 12.5, y: 0.5, width: 1.5, height: 2.3, label: 'Toilet', rotation: 90 },
          { type: 'toilet-paper', x: 12, y: 2.5, width: 0.5, height: 0.5, label: 'TP Holder', rotation: 90 },
          // === Freestanding tub (center) ===
          { type: 'bathtub-freestanding', x: 4.25, y: 5, width: 5.5, height: 2.5, label: 'Freestanding Tub', rotation: 0 },
          // === Walk-in shower (back right) ===
          { type: 'shower-base-60', x: 9, y: 9, width: 5, height: 3, label: 'Walk-in Shower', rotation: 0 },
          { type: 'shower-glass', x: 9, y: 9, width: 3, height: 0.15, label: 'Glass Door', rotation: 0 },
          { type: 'shower-bench', x: 12, y: 10, width: 2, height: 1.5, label: 'Bench', rotation: 90 },
          { type: 'shower-niche', x: 13.5, y: 9.5, width: 0.5, height: 1.5, label: 'Niche', rotation: 90 }
        ]
      },
      'bathroom-guest': {
        name: 'Guest Bathroom',
        roomType: 'bathroom',
        width: 8,
        depth: 6,
        elements: [
          // === Vanity (back wall) ===
          { type: 'vanity-36', x: 0.5, y: 0, width: 3, height: 1.75, label: 'Vanity 36"', rotation: 0 },
          { type: 'countertop', x: 0.375, y: -0.04, width: 3.25, height: 1.875, color: '#708090', rotation: 0, overhangFront: 0.125, overhangBack: 0, overhangLeft: 0.125, overhangRight: 0.125 },
          { type: 'sink', x: 1.1, y: 0.2, width: 1.8, height: 1.2, label: 'Sink', rotation: 0 },
          { type: 'mirror', x: 0.75, y: 0, width: 2.5, height: 0.15, label: 'Mirror', rotation: 0 },
          // === Toilet (right wall) - faces into room ===
          // Position: x = roomWidth - toiletDepth = 8 - 1.5 = 6.5
          { type: 'toilet', x: 6.5, y: 0.5, width: 1.5, height: 2.3, label: 'Toilet', rotation: 90 },
          // === Alcove tub/shower combo (front wall) ===
          { type: 'bathtub', x: 1.5, y: 3.3, width: 5, height: 2.7, label: 'Tub/Shower', rotation: 0 },
          // === Towel bar ===
          { type: 'towel-bar', x: 5, y: 0, width: 2, height: 0.15, label: 'Towel Bar', rotation: 0 }
        ]
      },
      'bathroom-powder': {
        name: 'Powder Room',
        roomType: 'bathroom',
        width: 5,
        depth: 4,
        elements: [
          // === Pedestal sink (back wall center) ===
          { type: 'pedestal-sink', x: 1.75, y: 0, width: 1.5, height: 1.5, label: 'Pedestal Sink', rotation: 0 },
          { type: 'mirror', x: 1.25, y: 0, width: 2.5, height: 0.15, label: 'Mirror', rotation: 0 },
          // === Toilet (right wall) - faces into room ===
          // Position: x = roomWidth - toiletDepth = 5 - 1.5 = 3.5
          { type: 'toilet', x: 3.5, y: 1.5, width: 1.5, height: 2.3, label: 'Toilet', rotation: 90 },
          // === Towel ring (left wall) ===
          { type: 'towel-bar', x: 0, y: 1.5, width: 1, height: 0.15, label: 'Towel Ring', rotation: 270 }
        ]
      },
      'bathroom-jack-jill': {
        name: 'Jack-and-Jill Bathroom',
        roomType: 'bathroom',
        width: 12,
        depth: 8,
        elements: [
          // === Vanity A (left wall) - faces right into room ===
          { type: 'vanity-36', x: 0, y: 0, width: 1.75, height: 3, label: 'Vanity A', rotation: 270 },
          { type: 'countertop', x: -0.04, y: -0.125, width: 1.875, height: 3.25, color: '#708090', rotation: 0, overhangFront: 0.125, overhangBack: 0, overhangLeft: 0, overhangRight: 0.125 },
          { type: 'sink', x: 0.2, y: 0.75, width: 1.3, height: 1.5, label: 'Sink A', rotation: 270 },
          { type: 'mirror', x: 0, y: 0.25, width: 0.15, height: 2.5, label: 'Mirror A', rotation: 270 },
          // === Vanity B (right wall) - faces left into room ===
          // Position: x = roomWidth - vanityDepth = 12 - 1.75 = 10.25
          { type: 'vanity-36', x: 10.25, y: 0, width: 1.75, height: 3, label: 'Vanity B', rotation: 90 },
          { type: 'countertop', x: 10.165, y: -0.125, width: 1.875, height: 3.25, color: '#708090', rotation: 0, overhangFront: 0.125, overhangBack: 0, overhangLeft: 0.125, overhangRight: 0 },
          { type: 'sink', x: 10.5, y: 0.75, width: 1.3, height: 1.5, label: 'Sink B', rotation: 90 },
          { type: 'mirror', x: 11.85, y: 0.25, width: 0.15, height: 2.5, label: 'Mirror B', rotation: 90 },
          // === Shared tub/shower (front wall) ===
          { type: 'bathtub', x: 3.5, y: 5.3, width: 5, height: 2.7, label: 'Tub/Shower', rotation: 0 },
          // === Toilet (center back wall) - faces into room ===
          { type: 'toilet', x: 5.25, y: 0.5, width: 1.5, height: 2.3, label: 'Toilet', rotation: 0 },
          // === Doors (Bedroom A left, Bedroom B right) ===
          { type: 'door', x: 0, y: 6, width: 0.5, height: 2, label: 'Door A', rotation: 270 },
          { type: 'door', x: 11.5, y: 6, width: 0.5, height: 2, label: 'Door B', rotation: 90 }
        ]
      },
      'concept-modern-kitchen-bath': {
        name: 'Modern Kitchen + Master Bath Concept',
        roomType: 'kitchen',
        width: 20,
        depth: 14,
        elements: [
          // === KITCHEN SECTION (left half, 0-10ft) ===
          // Refrigerator (back left corner)
          { type: 'refrigerator', x: 0, y: 0, width: 3, height: 2.5, rotation: 0 },
          // Base cabinets (back wall)
          { type: 'base-cabinet', x: 3, y: 0, width: 3, height: 2, rotation: 0 },
          { type: 'dishwasher', x: 6, y: 0, width: 2, height: 2, rotation: 0 },
          { type: 'sink-base', x: 8, y: 0, width: 3, height: 2, rotation: 0 },
          { type: 'countertop', x: 2.875, y: -0.04, width: 8.25, height: 2.165, color: '#708090', rotation: 0, overhangFront: 0.125, overhangBack: 0, overhangLeft: 0.125, overhangRight: 0.125 },
          { type: 'sink', x: 8.5, y: 0.25, width: 2, height: 1.5, rotation: 0 },
          // Island with waterfall
          { type: 'island', x: 3, y: 5, width: 6, height: 3, rotation: 0 },
          { type: 'countertop', x: 2.875, y: 4.875, width: 6.25, height: 3.25, color: '#708090', rotation: 0, overhangFront: 0.125, overhangBack: 0.125, overhangLeft: 0.125, overhangRight: 0.125 },
          // === BATH SECTION (right half, 12-20ft) ===
          // Double vanity 60" (right back wall)
          { type: 'vanity-double-60', x: 13, y: 0, width: 5, height: 1.75, rotation: 0 },
          { type: 'countertop', x: 12.875, y: -0.04, width: 5.25, height: 1.875, color: '#708090', rotation: 0, overhangFront: 0.125, overhangBack: 0, overhangLeft: 0.125, overhangRight: 0.125 },
          { type: 'sink', x: 14, y: 0.2, width: 1.5, height: 1.2, rotation: 0 },
          { type: 'sink', x: 16.5, y: 0.2, width: 1.5, height: 1.2, rotation: 0 },
          // Toilet
          { type: 'toilet', x: 18.5, y: 3, width: 1.5, height: 2.3, rotation: 90 },
          // Freestanding tub
          { type: 'bathtub-freestanding', x: 13.25, y: 5, width: 5.5, height: 2.5, rotation: 0 },
          // Divider wall between kitchen and bath
          { type: 'wall', x: 11.75, y: 0, width: 0.5, height: 14, rotation: 0 }
        ]
      },

      // ========== NEW TEMPLATES ==========

      'kitchen-compact': {
        name: 'Compact/Studio Kitchen',
        roomType: 'kitchen',
        width: 8,
        depth: 8,
        elements: [
          // === BACK WALL (y=0) - Small L-shape, no island ===
          // Compact layout for apartments/studios
          { type: 'refrigerator', x: 0, y: 0, width: 2.5, height: 2, label: 'Compact Fridge', rotation: 0 },
          { type: 'base-cabinet', x: 2.5, y: 0, width: 1.5, height: 2, label: 'Base 18"', rotation: 0 },
          { type: 'sink-base', x: 4, y: 0, width: 2.5, height: 2, label: 'Sink Base 30"', rotation: 0 },
          { type: 'countertop', x: 2.375, y: -0.04, width: 4.25, height: 2.165, label: 'Counter', rotation: 0, overhangFront: 0.125, overhangBack: 0, overhangLeft: 0.125, overhangRight: 0.125 },
          { type: 'sink', x: 4.25, y: 0.25, width: 2, height: 1.5, label: 'Sink', rotation: 0 },
          { type: 'wall-cabinet', x: 2.5, y: 0, width: 4, height: 1, label: 'Uppers', rotation: 0 },

          // === RIGHT WALL (x=6) - Range and storage ===
          { type: 'base-cabinet', x: 6, y: 0, width: 2, height: 1.5, label: 'Corner Base', rotation: 90 },
          { type: 'range', x: 5.83, y: 1.5, width: 2.17, height: 2, label: 'Range 24"', rotation: 90 },
          { type: 'range-hood', x: 7, y: 1.75, width: 1, height: 1.5, label: 'Hood', rotation: 90 },
          { type: 'base-cabinet', x: 6, y: 3.5, width: 2, height: 2, label: 'Base 24"', rotation: 90 },
          { type: 'countertop', x: 5.835, y: -0.04, width: 2.165, height: 1.665, label: 'Counter', rotation: 0, overhangFront: 0.125, overhangBack: 0, overhangLeft: 0.125, overhangRight: 0 },
          { type: 'countertop', x: 5.835, y: 3.375, width: 2.165, height: 2.25, label: 'Counter', rotation: 0, overhangFront: 0.125, overhangBack: 0, overhangLeft: 0.125, overhangRight: 0 },
          { type: 'wall-cabinet', x: 7, y: 3.5, width: 1, height: 2, label: 'Upper', rotation: 90 },

          // === BACKSPLASH ===
          { type: 'backsplash', x: 2.5, y: 0, width: 4, height: 0.08, label: 'Backsplash', rotation: 0 },
          { type: 'backsplash', x: 7.92, y: 0, width: 0.08, height: 5.5, label: 'Backsplash', rotation: 0 },
        ]
      },

      'outdoor-kitchen': {
        name: 'Outdoor Kitchen',
        roomType: 'kitchen',
        width: 12,
        depth: 6,
        elements: [
          // === BACK WALL (y=0) - Linear outdoor cooking station ===
          // Grill-centric with prep space on each side
          { type: 'base-cabinet', x: 0, y: 0, width: 2, height: 2, label: 'Storage', rotation: 0 },
          { type: 'refrigerator', x: 2, y: 0, width: 2, height: 2, label: 'Mini Fridge', rotation: 0 },
          { type: 'base-cabinet', x: 4, y: 0, width: 2, height: 2, label: 'Prep Station', rotation: 0 },
          { type: 'range', x: 6, y: 0, width: 3, height: 2.5, label: 'Built-in Grill', rotation: 0 },
          { type: 'sink-base', x: 9, y: 0, width: 2, height: 2, label: 'Sink Base', rotation: 0 },
          { type: 'base-cabinet', x: 11, y: 0, width: 1, height: 2, label: 'Storage', rotation: 0 },
          // Continuous countertop (weather-resistant material like granite)
          { type: 'countertop', x: -0.125, y: -0.04, width: 12.25, height: 2.665, label: 'Granite Counter', rotation: 0, overhangFront: 0.5, overhangBack: 0, overhangLeft: 0.125, overhangRight: 0.125 },
          { type: 'sink', x: 9.25, y: 0.25, width: 1.5, height: 1.5, label: 'Bar Sink', rotation: 0 },
          // Range hood / ventilation
          { type: 'range-hood', x: 6.25, y: 0, width: 2.5, height: 1, label: 'Vent Hood', rotation: 0 },
          // === BACKSPLASH ===
          { type: 'backsplash', x: 0, y: 0, width: 12, height: 0.08, label: 'Stone Backsplash', rotation: 0 },
        ]
      },

      'butler-pantry': {
        name: "Butler's Pantry",
        roomType: 'kitchen',
        width: 10,
        depth: 5,
        elements: [
          // === BACK WALL (y=0) - Pass-through service area ===
          // Wine storage, prep sink, glassware storage
          { type: 'tall-cabinet', x: 0, y: 0, width: 2, height: 2, label: 'Wine Storage', rotation: 0 },
          { type: 'base-cabinet', x: 2, y: 0, width: 2, height: 2, label: 'Base Cabinet', rotation: 0 },
          { type: 'sink-base', x: 4, y: 0, width: 2.5, height: 2, label: 'Prep Sink Base', rotation: 0 },
          { type: 'base-cabinet', x: 6.5, y: 0, width: 1.5, height: 2, label: 'Drawer Base', rotation: 0 },
          { type: 'refrigerator', x: 8, y: 0, width: 2, height: 2.5, label: 'Beverage Center', rotation: 0 },
          // Countertop
          { type: 'countertop', x: 1.875, y: -0.04, width: 6.25, height: 2.165, label: 'Counter', rotation: 0, overhangFront: 0.125, overhangBack: 0, overhangLeft: 0.125, overhangRight: 0.125 },
          { type: 'sink', x: 4.25, y: 0.25, width: 2, height: 1.5, label: 'Bar Sink', rotation: 0 },
          // Upper cabinets - glassware display
          { type: 'wall-cabinet', x: 0, y: 0, width: 2, height: 1, label: 'Wine Rack', rotation: 0 },
          { type: 'wall-cabinet', x: 2, y: 0, width: 3, height: 1, label: 'Glass Display', rotation: 0 },
          { type: 'wall-cabinet', x: 5, y: 0, width: 3, height: 1, label: 'Stemware', rotation: 0 },
          // === BACKSPLASH ===
          { type: 'backsplash', x: 2, y: 0, width: 6, height: 0.08, label: 'Backsplash', rotation: 0 },
        ]
      },

      'wet-bar': {
        name: 'Wet Bar',
        roomType: 'kitchen',
        width: 6,
        depth: 3,
        elements: [
          // === BACK WALL (y=0) - Compact bar with sink ===
          { type: 'base-cabinet', x: 0, y: 0, width: 1.5, height: 2, label: 'Bar Storage', rotation: 0 },
          { type: 'sink-base', x: 1.5, y: 0, width: 2, height: 2, label: 'Sink Base', rotation: 0 },
          { type: 'refrigerator', x: 3.5, y: 0, width: 1.5, height: 2, label: 'Mini Fridge', rotation: 0 },
          { type: 'base-cabinet', x: 5, y: 0, width: 1, height: 2, label: 'Storage', rotation: 0 },
          // Countertop with bar overhang
          { type: 'countertop', x: -0.125, y: -0.04, width: 6.25, height: 2.165, label: 'Bar Top', rotation: 0, overhangFront: 0.125, overhangBack: 0, overhangLeft: 0.125, overhangRight: 0.125 },
          { type: 'sink', x: 1.75, y: 0.25, width: 1.5, height: 1.5, label: 'Bar Sink', rotation: 0 },
          // Upper cabinets - bottle/glass storage
          { type: 'wall-cabinet', x: 0, y: 0, width: 1.5, height: 1, label: 'Bottles', rotation: 0 },
          { type: 'wall-cabinet', x: 1.5, y: 0, width: 2, height: 1, label: 'Glassware', rotation: 0 },
          { type: 'wall-cabinet', x: 5, y: 0, width: 1, height: 1, label: 'Storage', rotation: 0 },
          // === BACKSPLASH ===
          { type: 'backsplash', x: 0, y: 0, width: 6, height: 0.08, label: 'Backsplash', rotation: 0 },
        ]
      },

      'bathroom-ada': {
        name: 'ADA Accessible Bathroom',
        roomType: 'bathroom',
        width: 8,
        depth: 8,
        elements: [
          // === ADA Requirements ===
          // - 60" turning radius (5')
          // - 18" toilet height, 18" from side wall center
          // - 34" max counter height, knee clearance below
          // - Roll-in shower with bench, grab bars
          // - 36" min door width

          // === BACK WALL (y=0) - ADA Vanity ===
          // Open underneath for wheelchair access
          { type: 'base-cabinet', x: 0, y: 0, width: 3.5, height: 1.75, label: 'ADA Vanity', rotation: 0 },
          { type: 'countertop', x: -0.08, y: -0.04, width: 3.66, height: 1.875, color: '#708090', label: 'Counter (34" H)', rotation: 0, overhangFront: 0.125, overhangBack: 0, overhangLeft: 0.08, overhangRight: 0.08 },
          { type: 'sink', x: 0.5, y: 0.2, width: 2.5, height: 1.3, label: 'ADA Sink', rotation: 0 },
          { type: 'mirror', x: 0.25, y: 0, width: 3, height: 0.15, label: 'Tilted Mirror', rotation: 0 },

          // === LEFT WALL (x=0) - Roll-in Shower ===
          // 36" x 60" minimum for roll-in, bench inside
          { type: 'shower-pan', x: 0, y: 3, width: 3, height: 5, label: 'Roll-in Shower', rotation: 0 },
          { type: 'shower-curb', x: 0.25, y: 6.5, width: 1.5, height: 1.25, label: 'Shower Bench', rotation: 0 },
          { type: 'shower-niche', x: 0, y: 4, width: 0.5, height: 1.5, label: 'Grab Bar', rotation: 0 },
          { type: 'shower-niche', x: 2.5, y: 3, width: 0.5, height: 2, label: 'Grab Bar', rotation: 0 },

          // === RIGHT WALL - Toilet with grab bars ===
          // 18" from side wall to centerline, grab bars on both sides
          { type: 'toilet', x: 5, y: 0, width: 1.5, height: 2.5, label: 'ADA Toilet', rotation: 0 },
          { type: 'shower-niche', x: 6.5, y: 0.5, width: 0.5, height: 2, label: 'Side Grab Bar', rotation: 0 },
          { type: 'shower-niche', x: 5.75, y: 2.5, width: 1.5, height: 0.5, label: 'Rear Grab Bar', rotation: 0 },

          // === 60" TURNING RADIUS ===
          // Clear floor space in center of room
        ]
      },

      'bathroom-ensuite': {
        name: 'En-Suite Bathroom',
        roomType: 'bathroom',
        width: 6,
        depth: 8,
        elements: [
          // === BACK WALL (y=0) - Single Vanity ===
          { type: 'base-cabinet', x: 0, y: 0, width: 3, height: 1.75, label: 'Vanity 36"', rotation: 0 },
          { type: 'countertop', x: -0.08, y: -0.04, width: 3.16, height: 1.875, color: '#d4a574', rotation: 0, overhangFront: 0.125, overhangBack: 0, overhangLeft: 0.08, overhangRight: 0.08 },
          { type: 'sink', x: 0.5, y: 0.2, width: 2, height: 1.2, label: 'Sink', rotation: 0 },
          { type: 'mirror', x: 0.25, y: 0, width: 2.5, height: 0.15, label: 'Mirror', rotation: 0 },

          // === RIGHT WALL - Toilet ===
          { type: 'toilet', x: 4.5, y: 0.5, width: 1.5, height: 2.3, label: 'Toilet', rotation: 90 },

          // === FRONT WALL (y=5) - Walk-in Shower (no tub) ===
          { type: 'shower-pan', x: 0, y: 5, width: 6, height: 3, label: 'Shower', rotation: 0 },
          { type: 'shower-wall', x: 0, y: 5, width: 0.25, height: 3, label: 'Glass Panel', rotation: 0 },
          { type: 'shower-wall', x: 5.75, y: 5, width: 0.25, height: 3, label: 'Glass Panel', rotation: 0 },
          { type: 'shower-niche', x: 2, y: 7.5, width: 2, height: 0.5, label: 'Niche', rotation: 0 },

          // === LINEN STORAGE ===
          { type: 'tall-cabinet', x: 4, y: 0, width: 2, height: 1, label: 'Linen', rotation: 0 },
        ]
      },

      // ========== ADDITIONAL SPECIALTY TEMPLATES ==========

      'coffee-bar': {
        name: 'Coffee Bar / Espresso Station',
        roomType: 'kitchen',
        width: 8,
        depth: 4,
        elements: [
          // === BACK WALL (y=0) - Compact coffee station ===
          // Built-in espresso, sink for rinsing, storage for cups/beans
          { type: 'base-cabinet', x: 0, y: 0, width: 2, height: 2, label: 'Cup Storage', rotation: 0 },
          { type: 'coffee-system', x: 2, y: 0.25, width: 2, height: 1.5, label: 'Espresso Machine', rotation: 0 },
          { type: 'sink-base', x: 4, y: 0, width: 2, height: 2, label: 'Rinse Sink', rotation: 0 },
          { type: 'base-cabinet', x: 6, y: 0, width: 2, height: 2, label: 'Bean Storage', rotation: 0 },
          // Countertop
          { type: 'countertop', x: -0.125, y: -0.04, width: 8.25, height: 2.165, label: 'Counter', rotation: 0, overhangFront: 0.125, overhangBack: 0, overhangLeft: 0.125, overhangRight: 0.125 },
          { type: 'sink', x: 4.25, y: 0.25, width: 1.5, height: 1.5, label: 'Bar Sink', rotation: 0 },
          // Upper cabinets - mug display and storage
          { type: 'wall-cabinet', x: 0, y: 0, width: 2, height: 1, label: 'Mug Display', rotation: 0 },
          { type: 'wall-cabinet', x: 4, y: 0, width: 2, height: 1, label: 'Supplies', rotation: 0 },
          { type: 'wall-cabinet', x: 6, y: 0, width: 2, height: 1, label: 'Beans/Filters', rotation: 0 },
          // Backsplash
          { type: 'backsplash', x: 0, y: 0, width: 8, height: 0.08, label: 'Tile Backsplash', rotation: 0 },
        ]
      },

      'mudroom': {
        name: 'Mudroom / Entry',
        roomType: 'closet',
        width: 10,
        depth: 6,
        elements: [
          // === BACK WALL (y=0) - Lockers/cubbies with bench ===
          // Storage for coats, bags, shoes with seating
          { type: 'tall-cabinet', x: 0, y: 0, width: 1.5, height: 2, label: 'Locker 1', rotation: 0 },
          { type: 'tall-cabinet', x: 1.5, y: 0, width: 1.5, height: 2, label: 'Locker 2', rotation: 0 },
          { type: 'tall-cabinet', x: 3, y: 0, width: 1.5, height: 2, label: 'Locker 3', rotation: 0 },
          { type: 'tall-cabinet', x: 4.5, y: 0, width: 1.5, height: 2, label: 'Locker 4', rotation: 0 },
          // Bench with shoe storage below
          { type: 'base-cabinet', x: 6.5, y: 0, width: 3.5, height: 1.5, label: 'Bench Storage', rotation: 0 },
          { type: 'countertop', x: 6.375, y: -0.04, width: 3.75, height: 1.665, color: '#8B4513', label: 'Bench Seat', rotation: 0, overhangFront: 0.125, overhangBack: 0, overhangLeft: 0.125, overhangRight: 0.125 },
          // Hooks above bench (represented as wall accessory)
          { type: 'closet-rod', x: 6.5, y: 0, width: 3.5, height: 0.15, label: 'Coat Hooks', rotation: 0 },
          // Shoe cubbies below
          { type: 'shoe-rack', x: 0, y: 2.5, width: 6, height: 1.5, label: 'Shoe Cubbies', rotation: 0 },
          // Door entry
          { type: 'door', x: 4, y: 5.5, width: 3, height: 0.5, label: 'Entry Door', rotation: 0 },
        ]
      },

      'pool-house-bar': {
        name: 'Pool House Bar',
        roomType: 'kitchen',
        width: 14,
        depth: 6,
        elements: [
          // === BACK WALL (y=0) - Full outdoor entertaining setup ===
          // Grill, outdoor fridge, kegerator, sink, pizza oven
          { type: 'outdoor-fridge', x: 0, y: 0, width: 2, height: 2.5, label: 'Outdoor Fridge', rotation: 0 },
          { type: 'base-cabinet', x: 2, y: 0, width: 2, height: 2, label: 'Storage', rotation: 0 },
          { type: 'grill-builtin', x: 4, y: 0, width: 3, height: 2.5, label: 'Built-in Grill', rotation: 0 },
          { type: 'side-burner', x: 7, y: 0, width: 1, height: 2, label: 'Side Burner', rotation: 0 },
          { type: 'outdoor-sink', x: 8, y: 0, width: 2, height: 2, label: 'Sink', rotation: 0 },
          { type: 'kegerator', x: 10, y: 0, width: 2, height: 2.5, label: 'Kegerator', rotation: 0 },
          { type: 'outdoor-ice-maker', x: 12, y: 0, width: 1.25, height: 2, label: 'Ice Maker', rotation: 0 },
          { type: 'base-cabinet', x: 13.25, y: 0, width: 0.75, height: 2, label: 'Storage', rotation: 0 },
          // Continuous granite counter with bar seating overhang
          { type: 'countertop', x: -0.125, y: -0.04, width: 14.25, height: 2.915, label: 'Granite Bar Top', rotation: 0, overhangFront: 0.75, overhangBack: 0, overhangLeft: 0.125, overhangRight: 0.125 },
          { type: 'sink', x: 8.25, y: 0.25, width: 1.5, height: 1.5, label: 'Bar Sink', rotation: 0 },
          // Range hood over grill
          { type: 'range-hood', x: 4.25, y: 0, width: 2.5, height: 1, label: 'Vent Hood', rotation: 0 },
          // Backsplash
          { type: 'backsplash', x: 0, y: 0, width: 14, height: 0.08, label: 'Stone Backsplash', rotation: 0 },
        ]
      },

      'home-office': {
        name: 'Home Office with Built-ins',
        roomType: 'closet',
        width: 12,
        depth: 10,
        elements: [
          // === BACK WALL (y=0) - Desk with overhead shelving ===
          { type: 'base-cabinet', x: 0, y: 0, width: 2, height: 2, label: 'File Cabinet', rotation: 0 },
          { type: 'base-cabinet', x: 2, y: 0, width: 6, height: 2, label: 'Desk Base', rotation: 0 },
          { type: 'base-cabinet', x: 8, y: 0, width: 2, height: 2, label: 'Drawer Pedestal', rotation: 0 },
          // Desk surface
          { type: 'countertop', x: -0.125, y: -0.04, width: 10.25, height: 2.165, color: '#5D4037', label: 'Desk Surface', rotation: 0, overhangFront: 0.125, overhangBack: 0, overhangLeft: 0.125, overhangRight: 0.125 },
          // Upper shelving
          { type: 'wall-cabinet', x: 0, y: 0, width: 3, height: 1, label: 'Bookshelves', rotation: 0 },
          { type: 'wall-cabinet', x: 3, y: 0, width: 4, height: 1, label: 'Display Shelves', rotation: 0 },
          { type: 'wall-cabinet', x: 7, y: 0, width: 3, height: 1, label: 'Storage', rotation: 0 },
          // === RIGHT WALL (x=10) - Bookcase wall ===
          { type: 'tall-cabinet', x: 10, y: 0, width: 2, height: 3, label: 'Bookcase', rotation: 90 },
          { type: 'tall-cabinet', x: 10, y: 3, width: 2, height: 4, label: 'Bookcase', rotation: 90 },
          { type: 'tall-cabinet', x: 10, y: 7, width: 2, height: 3, label: 'Bookcase', rotation: 90 },
          // === Entry ===
          { type: 'door', x: 0, y: 9.5, width: 3, height: 0.5, label: 'Entry', rotation: 0 },
        ]
      },

      'commercial-prep-kitchen': {
        name: 'Commercial Prep Kitchen',
        roomType: 'kitchen',
        width: 20,
        depth: 16,
        elements: [
          // === BACK WALL (y=0) - Commercial cooking line ===
          // Walk-in cooler access, prep tables, commercial range
          { type: 'refrigerator', x: 0, y: 0, width: 4, height: 3, label: 'Walk-in Cooler', rotation: 0 },
          { type: 'base-cabinet', x: 4, y: 0, width: 4, height: 2.5, label: 'Prep Table', rotation: 0 },
          { type: 'range', x: 8, y: 0, width: 4, height: 3, label: 'Commercial Range', rotation: 0 },
          { type: 'range-hood', x: 8, y: 0, width: 4, height: 2, label: 'Hood System', rotation: 0 },
          { type: 'base-cabinet', x: 12, y: 0, width: 4, height: 2.5, label: 'Hot Holding', rotation: 0 },
          { type: 'refrigerator', x: 16, y: 0, width: 4, height: 3, label: 'Reach-in Freezer', rotation: 0 },
          // Countertops - stainless steel
          { type: 'countertop', x: 3.875, y: -0.04, width: 12.25, height: 2.665, color: '#C0C0C0', label: 'Stainless Prep', rotation: 0, overhangFront: 0.125, overhangBack: 0, overhangLeft: 0.125, overhangRight: 0.125 },

          // === LEFT WALL (x=0) - Dish station ===
          { type: 'sink-base', x: 0, y: 4, width: 3, height: 4, label: '3-Compartment Sink', rotation: 270 },
          { type: 'dishwasher', x: 0, y: 8, width: 3, height: 3, label: 'Commercial Dishwasher', rotation: 270 },
          { type: 'base-cabinet', x: 0, y: 11, width: 3, height: 3, label: 'Clean Dish Table', rotation: 270 },
          { type: 'countertop', x: -0.04, y: 3.875, width: 3.165, height: 10.25, color: '#C0C0C0', label: 'Dish Area', rotation: 0, overhangFront: 0, overhangBack: 0, overhangLeft: 0, overhangRight: 0.125 },

          // === CENTER - Prep island ===
          { type: 'island', x: 7, y: 6, width: 6, height: 4, label: 'Prep Island', rotation: 0 },
          { type: 'countertop', x: 6.875, y: 5.875, width: 6.25, height: 4.25, color: '#C0C0C0', label: 'Stainless Island', rotation: 0, overhangFront: 0.125, overhangBack: 0.125, overhangLeft: 0.125, overhangRight: 0.125 },

          // === RIGHT WALL (x=17) - Cold storage and plating ===
          { type: 'refrigerator', x: 17, y: 4, width: 3, height: 4, label: 'Reach-in Cooler', rotation: 90 },
          { type: 'base-cabinet', x: 17, y: 8, width: 3, height: 4, label: 'Plating Station', rotation: 90 },
          { type: 'base-cabinet', x: 17, y: 12, width: 3, height: 4, label: 'Expediting', rotation: 90 },
          { type: 'countertop', x: 16.835, y: 3.875, width: 3.165, height: 12.125, color: '#C0C0C0', label: 'Plating Counter', rotation: 0, overhangFront: 0.125, overhangBack: 0, overhangLeft: 0.125, overhangRight: 0 },

          // === FRONT WALL (y=14) - Pass window / service line ===
          { type: 'window', x: 6, y: 15.5, width: 8, height: 0.5, label: 'Pass Window', rotation: 0 },
        ]
      },

      'scullery': {
        name: 'Scullery / Prep Kitchen',
        roomType: 'kitchen',
        width: 8,
        depth: 8,
        elements: [
          // === BACK WALL (y=0) - Secondary sink and prep ===
          // Hidden prep area behind main kitchen
          { type: 'tall-cabinet', x: 0, y: 0, width: 2, height: 2, label: 'Pantry Storage', rotation: 0 },
          { type: 'base-cabinet', x: 2, y: 0, width: 2, height: 2, label: 'Prep Base', rotation: 0 },
          { type: 'sink-base', x: 4, y: 0, width: 2.5, height: 2, label: 'Prep Sink', rotation: 0 },
          { type: 'dishwasher', x: 6.5, y: 0, width: 1.5, height: 2, label: 'Dishwasher', rotation: 0 },
          { type: 'countertop', x: 1.875, y: -0.04, width: 6.125, height: 2.165, label: 'Prep Counter', rotation: 0, overhangFront: 0.125, overhangBack: 0, overhangLeft: 0.125, overhangRight: 0 },
          { type: 'sink', x: 4.25, y: 0.25, width: 2, height: 1.5, label: 'Prep Sink', rotation: 0 },
          // Wall cabinets
          { type: 'wall-cabinet', x: 2, y: 0, width: 2, height: 1, label: 'Upper', rotation: 0 },
          { type: 'wall-cabinet', x: 4, y: 0, width: 2.5, height: 1, label: 'Upper', rotation: 0 },

          // === LEFT WALL - Additional storage ===
          { type: 'tall-cabinet', x: 0, y: 2, width: 2, height: 3, label: 'Pantry', rotation: 270 },
          { type: 'tall-cabinet', x: 0, y: 5, width: 2, height: 3, label: 'Appliance Garage', rotation: 270 },

          // === FRONT WALL (y=6) - Extra counter ===
          { type: 'base-cabinet', x: 2.5, y: 6, width: 3, height: 2, label: 'Extra Storage', rotation: 180 },
          { type: 'countertop', x: 2.375, y: 5.835, width: 3.25, height: 2.165, label: 'Landing', rotation: 0, overhangFront: 0.125, overhangBack: 0, overhangLeft: 0.125, overhangRight: 0.125 },

          // Backsplash
          { type: 'backsplash', x: 2, y: 0, width: 6, height: 0.08, label: 'Backsplash', rotation: 0 },
        ]
      }
    };

    // Export current design as template code (for developers to copy)
    function exportAsTemplate() {
      const templateName = prompt('Enter a name for this template:', 'My Kitchen');
      if (!templateName) return;

      const templateId = templateName.toLowerCase().replace(/\s+/g, '-').replace(/[^a-z0-9-]/g, '');
      const roomType = document.getElementById('roomType')?.value || 'kitchen';

      // Convert elements to template format (positions in feet, not pixels)
      const templateElements = elements.map(el => {
        const elDef = {
          type: el.type,
          x: Math.round((el.x / pixelsPerFoot) * 100) / 100,
          y: Math.round((el.y / pixelsPerFoot) * 100) / 100,
          width: Math.round(el.width * 100) / 100,
          height: Math.round(el.height * 100) / 100
        };

        // Include optional properties if set
        if (el.label) elDef.label = el.label;
        if (el.rotation) elDef.rotation = el.rotation;
        if (el.color && el.color !== getDefaultColor(el.type)) elDef.color = el.color;
        if (el.waterfallSides && el.waterfallSides.length > 0) elDef.waterfallSides = el.waterfallSides;
        if (el.waterfallHeight) elDef.waterfallHeight = el.waterfallHeight;
        if (el.edgeProfile && el.edgeProfile !== 'eased') elDef.edgeProfile = el.edgeProfile;
        if (el.thickness && el.thickness !== '3cm') elDef.thickness = el.thickness;
        if (el.finishedEnds && el.finishedEnds.length > 0) elDef.finishedEnds = el.finishedEnds;

        return elDef;
      });

      // Generate template code
      const templateCode = `'${templateId}': {
  name: '${templateName}',
  roomType: '${roomType}',
  width: ${roomWidth},
  depth: ${roomDepth},
  elements: ${JSON.stringify(templateElements, null, 4).replace(/"([^"]+)":/g, '$1:')}
}`;

      // Show in a modal or copy to clipboard
      const modal = document.createElement('div');
      modal.style.cssText = 'position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.8);z-index:10000;display:flex;align-items:center;justify-content:center;';
      modal.innerHTML = `
        <div style="background:#1a1a2e;padding:24px;border-radius:12px;max-width:800px;max-height:80vh;overflow:auto;color:#fff;">
          <h3 style="margin:0 0 16px;">Template Code</h3>
          <p style="color:#888;margin-bottom:12px;">Copy this code and add it to ROOM_TEMPLATES in index.html:</p>
          <textarea id="templateCodeOutput" style="width:100%;height:400px;background:#0d0d15;color:#10b981;font-family:monospace;font-size:12px;padding:12px;border:1px solid #333;border-radius:8px;">${templateCode}</textarea>
          <div style="margin-top:16px;display:flex;gap:12px;">
            <button onclick="navigator.clipboard.writeText(document.getElementById('templateCodeOutput').value);this.textContent='Copied!'" style="padding:10px 20px;background:#6366f1;color:#fff;border:none;border-radius:6px;cursor:pointer;">Copy to Clipboard</button>
            <button onclick="this.closest('div').parentElement.remove()" style="padding:10px 20px;background:#333;color:#fff;border:none;border-radius:6px;cursor:pointer;">Close</button>
          </div>
        </div>
      `;
      document.body.appendChild(modal);
      document.getElementById('templateCodeOutput').select();

      console.log('Template exported:', templateCode);
    }

    async function loadRoomTemplate(templateId) {
      const template = ROOM_TEMPLATES[templateId];
      if (!template) {
        showToast('Template not found', 'error');
        return;
      }

      // Confirm before clearing
      if (elements.length > 0) {
        const confirmed = await showConfirmDialog({
          title: 'Load Template?',
          message: `Load "${template.name}" template?\n\nThis will replace your current design.`,
          confirmText: 'Load Template',
          cancelText: 'Cancel'
        });
        if (!confirmed) return;
      }

      // Clear current elements
      elements.length = 0;
      elementListDirty = true;
      selectedElement = null;

      // Set room dimensions FIRST
      roomWidth = template.width;
      roomDepth = template.depth;
      document.getElementById('roomWidth').value = roomWidth;
      document.getElementById('roomDepth').value = roomDepth;
      document.getElementById('roomType').value = template.roomType;

      // IMPORTANT: Fit to screen BEFORE adding elements
      // This sets pixelsPerFoot correctly for the new room size
      // Elements will use this scale when converting feet to pixels
      fitToScreen();

      // Add template elements (using the correct pixelsPerFoot set by fitToScreen)
      template.elements.forEach(elDef => {
        // Copy all properties from template, then override with converted/computed values
        // NOTE: width/height stay in FEET (same as normal element creation)
        // Only x/y are converted to pixels for canvas positioning
        const el = {
          ...elDef,  // Copy ALL template properties (waterfallSides, overhangs, finishedEnds, etc.)
          id: Date.now() + Math.random(),
          x: elDef.x * pixelsPerFoot,
          y: elDef.y * pixelsPerFoot,
          rotation: elDef.rotation || 0,
          color: elDef.color || getDefaultColor(elDef.type),
          category: getElementCategory(elDef.type),
          roomId: currentRoom
        };
        elements.push(el);
      });

      // Update everything (no need to call fitToScreen again)
      saveUndoState();
      updateProperties();
      updateElementList();
      updateItemPicker();
      draw();

      if (currentView === '3d') {
        init3D();
        render3D();
      }

      showToast(`Loaded "${template.name}" template`, 'success');
    }

    function getDefaultColor(type) {
      const colors = {
        'base-cabinet': '#8B7355',
        'wall-cabinet': '#8B7355',
        'tall-cabinet': '#8B7355',
        'fridge-cabinet': '#8B7355',
        'corner-cabinet': '#8B7355',
        'island': '#8B7355',
        'drawer-base': '#8B7355',
        'sink-base': '#8B7355',
        'countertop': '#708090',
        'backsplash': '#A0A0A0',
        'flooring': '#D2B48C',
        'tile': '#E8E8E8',
        'shower-pan': '#D0D0D0',
        'shower-wall': '#E0E0E0',
        'shower-curb': '#808080',
        'bathtub': '#F5F5F5',
        'toilet': '#FFFFFF',
        'sink': '#E8E8E8',
        'refrigerator': '#C0C0C0',
        'range': '#404040',
        'stove': '#404040',
        'dishwasher': '#C0C0C0',
        'range-hood': '#808080',
        'wall': '#E0D5C5',
        'window': '#87CEEB',
        'door': '#8B4513'
      };
      return colors[type] || '#808080';
    }

    function updateRoomHeight() {
      roomHeight = parseInt(document.getElementById('roomHeight').value) || 8;
      if (currentView === '3d') {
        init3D();
        render3D();
      }
    }

    // ===== CABINET SETTINGS =====
    function updateCabinetSettings() {
      // Get values from dropdowns
      cabinetSettings.construction = document.getElementById('cabinetConstruction').value;
      cabinetSettings.doorStyle = document.getElementById('doorStyle').value;
      cabinetSettings.doorOverlay = document.getElementById('doorOverlay').value;
      cabinetSettings.cabinetFinish = document.getElementById('cabinetFinish')?.value || 'wood-grain';

      // Cabinet types that use these settings
      const cabinetTypes = ['base-cabinet', 'wall-cabinet', 'tall-cabinet', 'corner-cabinet',
                           'drawer-base', 'sink-base', 'lazy-susan', 'blind-corner', 'island',
                           'microwave-cabinet', 'above-microwave-cabinet', 'fridge-cabinet',
                           'single-oven-cabinet', 'tall-oven', 'double-oven-cabinet', 'laundry-cabinet'];

      // Update any selected cabinet element with new settings
      if (selectedElement && cabinetTypes.includes(selectedElement.type)) {
        selectedElement.construction = cabinetSettings.construction;
        selectedElement.doorStyle = cabinetSettings.doorStyle;
        selectedElement.doorOverlay = cabinetSettings.doorOverlay;
        selectedElement.cabinetFinish = cabinetSettings.cabinetFinish;

        // Redraw - must reinitialize 3D to rebuild geometry
        if (currentView === '2d') {
          draw();
        } else {
          init3D(); // Rebuild 3D scene with new cabinet settings
        }
        saveUndoState();
      }

      // Show toast with current settings
      const constructionLabel = cabinetSettings.construction === 'frameless' ? 'Frameless (Euro)' : 'Framed (Face Frame)';
      const finishLabel = cabinetSettings.cabinetFinish === 'wood-grain' ? 'Wood Grain' :
                         cabinetSettings.cabinetFinish === 'painted' ? 'Painted' :
                         cabinetSettings.cabinetFinish === 'matte' ? 'Matte' : 'High Gloss';
      showToast(`Cabinet: ${cabinetSettings.doorStyle}, ${finishLabel}`);
    }

    function applySettingsToAllCabinets() {
      // Cabinet types that use these settings
      const cabinetTypes = ['base-cabinet', 'wall-cabinet', 'tall-cabinet', 'corner-cabinet',
                           'drawer-base', 'sink-base', 'lazy-susan', 'blind-corner', 'island',
                           'microwave-cabinet', 'above-microwave-cabinet', 'fridge-cabinet',
                           'single-oven-cabinet', 'tall-oven', 'double-oven-cabinet', 'laundry-cabinet'];

      let updatedCount = 0;
      elements.forEach(el => {
        if (cabinetTypes.includes(el.type)) {
          el.construction = cabinetSettings.construction;
          el.doorStyle = cabinetSettings.doorStyle;
          el.doorOverlay = cabinetSettings.doorOverlay;
          el.cabinetFinish = cabinetSettings.cabinetFinish;
          updatedCount++;
        }
      });

      if (updatedCount > 0) {
        // Redraw
        if (currentView === '2d') {
          draw();
        } else {
          init3D(); // Rebuild 3D scene with new cabinet settings
        }
        saveUndoState();

        const constructionLabel = cabinetSettings.construction === 'frameless' ? 'Frameless' : 'Framed';
        showToast(`Applied ${constructionLabel} ${cabinetSettings.doorStyle} style to ${updatedCount} cabinet(s)`, 'success');
      } else {
        showToast('No cabinets found to update', 'info');
      }
    }

    function updateFloorLevel() {
      const floorSelect = document.getElementById('floorLevel');
      const value = floorSelect.value;

      if (value === 'add') {
        // Add new floor
        const newFloorNum = cabinetSettings.floors.length + 1;
        const newFloor = {
          id: newFloorNum,
          name: `Floor ${newFloorNum}`,
          height: (newFloorNum - 1) * 10 // 10 feet per floor
        };
        cabinetSettings.floors.push(newFloor);

        // Add new option to dropdown
        const newOption = document.createElement('option');
        newOption.value = newFloorNum;
        newOption.textContent = `Floor ${newFloorNum}`;
        floorSelect.insertBefore(newOption, floorSelect.lastElementChild);

        // Select the new floor
        floorSelect.value = newFloorNum;
        cabinetSettings.currentFloor = newFloorNum;

        showToast(`Added Floor ${newFloorNum}`);
      } else {
        // Switch to selected floor
        cabinetSettings.currentFloor = parseInt(value);
        showToast(`Switched to Floor ${value}`);
      }

      // Filter elements to show only current floor
      updateFloorVisibility();

      if (currentView === '2d') {
        draw();
      } else {
        render3D();
      }
    }

    function updateTimeOfDay() {
      const timeSelect = document.getElementById('timeOfDay');
      sceneSettings.timeOfDay = timeSelect.value;

      // Lighting presets matching init3D - balanced for color accuracy
      const lightingPresets = {
        morning: {
          bg: 0xFFF8E7,
          ambient: { color: 0xFFF8F0, intensity: 0.35 },
          hemisphere: { sky: 0xFFE4C4, ground: 0x8B7355, intensity: 0.25 },
          sun: { color: 0xFFE4B5, intensity: 0.6, pos: [25, 12, 15] },
          fill: { intensity: 0.2 },
          exposure: 0.9
        },
        noon: {
          bg: 0xF5F8FA,
          ambient: { color: 0xFFFFFF, intensity: 0.4 },
          hemisphere: { sky: 0xE0F0FF, ground: 0x8B7355, intensity: 0.3 },
          sun: { color: 0xFFFFF8, intensity: 0.7, pos: [15, 25, 15] },
          fill: { intensity: 0.25 },
          exposure: 0.95
        },
        evening: {
          bg: 0xFFE8D6,
          ambient: { color: 0xFFE0C0, intensity: 0.3 },
          hemisphere: { sky: 0xFFA07A, ground: 0x6B4423, intensity: 0.2 },
          sun: { color: 0xFF8C00, intensity: 0.5, pos: [-20, 8, 10] },
          fill: { intensity: 0.25 },
          exposure: 0.85
        },
        night: {
          bg: 0x1E2A3A,
          ambient: { color: 0xC0C8D8, intensity: 0.25 },
          hemisphere: { sky: 0x4169E1, ground: 0x2F3F4F, intensity: 0.15 },
          sun: { color: 0xB0C4DE, intensity: 0.15, pos: [-15, 20, 10] },
          fill: { intensity: 0.35 }, // Interior lights
          exposure: 0.75
        },
        showroom: {
          bg: 0xFCFCFC,
          ambient: { color: 0xFFFFFF, intensity: 0.55 },
          hemisphere: { sky: 0xFFFFFF, ground: 0xF0F0F0, intensity: 0.35 },
          sun: { color: 0xFFFFFF, intensity: 0.85, pos: [10, 20, 10] },
          fill: { intensity: 0.4 },
          exposure: 1.1
        }
      };

      if (scene && renderer) {
        const preset = lightingPresets[sceneSettings.timeOfDay] || lightingPresets.noon;

        // Update renderer exposure
        renderer.toneMappingExposure = preset.exposure;

        // Update scene background
        scene.background = new THREE.Color(preset.bg);

        // Update lights by name
        scene.traverse(obj => {
          if (obj.name === 'ambientLight' && obj.isAmbientLight) {
            obj.color.setHex(preset.ambient.color);
            obj.intensity = preset.ambient.intensity;
          }
          if (obj.name === 'hemisphereLight' && obj.isHemisphereLight) {
            obj.color.setHex(preset.hemisphere.sky);
            obj.groundColor.setHex(preset.hemisphere.ground);
            obj.intensity = preset.hemisphere.intensity;
          }
          if (obj.name === 'sunLight' && obj.isDirectionalLight) {
            obj.position.set(...preset.sun.pos);
            obj.color.setHex(preset.sun.color);
            obj.intensity = preset.sun.intensity;
          }
          if (obj.name === 'fillLight' && obj.isDirectionalLight) {
            obj.intensity = preset.fill.intensity;
          }
          // Surface lights stay constant for texture visibility
        });

        // Re-render to show changes
        render3D();
      }

      const timeLabels = {
        morning: 'Morning (Golden Hour)',
        noon: 'Noon (Bright Daylight)',
        evening: 'Evening (Sunset)',
        night: 'Night (Interior Lights)'
      };
      showToast(`Time of day: ${timeLabels[sceneSettings.timeOfDay]}`);
    }

    function updateFloorVisibility() {
      // Mark elements with their floor level if not set
      elements.forEach(el => {
        if (!el.floorLevel) {
          el.floorLevel = 1; // Default to floor 1
        }
      });
    }

    function getElementsForCurrentFloor() {
      return elements.filter(el => !el.floorLevel || el.floorLevel === cabinetSettings.currentFloor);
    }

    // ===== FLOATING TOOLBAR =====
    function updateFloatingToolbar() {
      const toolbar = document.getElementById('floatingToolbar');
      const countEl = document.getElementById('selectionCount');
      const typeEl = document.getElementById('selectionType');

      if (!toolbar) return;

      if (selectedElement) {
        toolbar.classList.add('visible');
        countEl.textContent = '1';
        typeEl.textContent = selectedElement.label || 'Selected';
      } else {
        toolbar.classList.remove('visible');
      }
    }

    // ===== PROPERTIES =====
    function updateProperties() {
      const empty = document.getElementById('propertiesEmpty');
      const content = document.getElementById('propertiesContent');

      // Update floating toolbar visibility
      updateFloatingToolbar();

      if (selectedElement) {
        empty.style.display = 'none';
        content.style.display = 'block';

        document.getElementById('propType').textContent = selectedElement.label;
        // Show decimal value in input, formatted display beside it
        document.getElementById('propWidth').value = selectedElement.width.toFixed(4).replace(/\.?0+$/, '');
        // Depth (2D height / 3D depth)
        const depthInput = document.getElementById('propDepth');
        if (depthInput) depthInput.value = selectedElement.height.toFixed(4).replace(/\.?0+$/, '');
        // 3D Height (vertical dimension)
        const height3DInput = document.getElementById('prop3DHeight');
        if (height3DInput) {
          // Use custom actualHeight if set, otherwise get default from type
          const current3DHeight = selectedElement.actualHeight || get3DHeight(selectedElement);
          height3DInput.value = current3DHeight.toFixed(4).replace(/\.?0+$/, '');
        }
        // Show formatted feet-inches display
        const widthDisplay = document.getElementById('propWidthDisplay');
        const depthDisplay = document.getElementById('propDepthDisplay');
        const height3DDisplay = document.getElementById('prop3DHeightDisplay');
        if (widthDisplay) widthDisplay.textContent = formatDimension(selectedElement.width);
        if (depthDisplay) depthDisplay.textContent = formatDimension(selectedElement.height);
        if (height3DDisplay) {
          const h3d = selectedElement.actualHeight || get3DHeight(selectedElement);
          height3DDisplay.textContent = formatDimension(h3d);
        }

        document.getElementById('propColor').value = selectedElement.color;
        document.getElementById('propRotation').textContent = (selectedElement.rotation || 0) + '';

        // Area & perimeter calculations
        const elArea = selectedElement.width * selectedElement.height;
        const elPerimeter = 2 * (selectedElement.width + selectedElement.height);
        const areaEl = document.getElementById('propArea');
        const perimEl = document.getElementById('propPerimeter');
        if (areaEl) {
          const areaSqFt = elArea.toFixed(2);
          const areaSqIn = (elArea * 144).toFixed(0);
          areaEl.textContent = `${areaSqFt} sq ft (${areaSqIn} sq in)`;
        }
        if (perimEl) {
          const perimFt = elPerimeter.toFixed(2);
          const perimIn = (elPerimeter * 12).toFixed(0);
          perimEl.textContent = `${perimFt} ft (${perimIn}")`;
        }

        const texturePreview = document.getElementById('propTexture');
        if (selectedElement.texture) {
          texturePreview.style.background = `url(${selectedElement.texture}) center/cover`;
        } else {
          texturePreview.style.background = selectedElement.color;
        }

        // Show material name if assigned
        const materialNameRow = document.getElementById('materialNameRow');
        const materialNameEl = document.getElementById('propMaterialName');
        if (materialNameRow && materialNameEl) {
          if (selectedElement.materialName) {
            materialNameRow.style.display = 'flex';
            materialNameEl.textContent = selectedElement.materialName;
          } else {
            materialNameRow.style.display = 'none';
            materialNameEl.textContent = '-';
          }
        }

        // Surface finish picker
        const finishRow = document.getElementById('finishRow');
        const finishPicker = document.getElementById('finishPicker');
        if (finishRow && finishPicker) {
          const matCat = selectedElement.materialCategory;
          const finishGroup = matCat ? CATEGORY_FINISH_GROUP[matCat] : null;
          const finishOpts = finishGroup ? (FINISH_OPTIONS[finishGroup] || []) : [];
          if (finishOpts.length > 0) {
            finishRow.style.display = 'flex';
            const currentFinish = (selectedElement.finish || 'polished').toLowerCase();
            finishPicker.innerHTML = finishOpts.map(f => {
              const fId = f.toLowerCase();
              const isActive = fId === currentFinish;
              return `<button class="finish-option${isActive ? ' active' : ''}" onclick="applyFinishToElement('${fId}')">${f}</button>`;
            }).join('');
          } else {
            finishRow.style.display = 'none';
            finishPicker.innerHTML = '';
          }
        }

        // Populate standard sizes dropdown
        const standardSizeRow = document.getElementById('standardSizeRow');
        const standardSizeSelect = document.getElementById('propStandardSize');
        const standardSizes = getStandardSizesForType(selectedElement.type);

        if (standardSizes.length > 0) {
          standardSizeRow.style.display = 'flex';
          standardSizeSelect.innerHTML = '<option value="">Custom</option>' +
            standardSizes.map(s => `<option value="${s.width}x${s.height}">${s.label}</option>`).join('');
        } else {
          standardSizeRow.style.display = 'none';
        }

        // Countertop-specific properties (edge profile, backsplash, finished ends)
        const countertopTypes = ['countertop', 'countertop-corner', 'countertop-l', 'countertop-u', 'island'];
        const isCountertop = countertopTypes.includes(selectedElement.type);
        const edgeProfileRow = document.getElementById('edgeProfileRow');
        const backsplashRow = document.getElementById('backsplashRow');
        const finishedEndsRow = document.getElementById('finishedEndsRow');

        if (edgeProfileRow) {
          edgeProfileRow.style.display = isCountertop ? 'flex' : 'none';
          if (isCountertop) {
            const profile = selectedElement.edgeProfile || 'eased';
            document.getElementById('propEdgeProfile').value = profile;

            // Show edge profile durability info
            const edgeInfo = FABRICATION_STANDARDS?.edgeDurability?.[profile];
            const infoDiv = document.getElementById('edgeProfileInfo');
            const infoRow = document.getElementById('edgeProfileInfoRow');

            if (infoDiv && infoRow && edgeInfo) {
              const stars = ''.repeat(edgeInfo.rating) + ''.repeat(5 - edgeInfo.rating);
              infoDiv.innerHTML = `<strong>Durability:</strong> ${stars}<br><strong>Chip Resistance:</strong> ${edgeInfo.chipResistance}<br>${edgeInfo.notes}`;
              infoRow.style.display = 'block';
            }
          }
        }

        // Hide edge profile info when not a countertop
        const edgeProfileInfoRow = document.getElementById('edgeProfileInfoRow');
        if (edgeProfileInfoRow && !isCountertop) {
          edgeProfileInfoRow.style.display = 'none';
        }

        if (backsplashRow) {
          backsplashRow.style.display = isCountertop ? 'flex' : 'none';
          if (isCountertop) {
            const bs = selectedElement.backsplash;
            if (!bs) {
              document.getElementById('propBacksplash').value = 'none';
            } else if (bs.type === 'full') {
              document.getElementById('propBacksplash').value = 'full';
            } else {
              document.getElementById('propBacksplash').value = bs.height.toString();
            }
          }
        }

        if (finishedEndsRow) {
          finishedEndsRow.style.display = isCountertop ? 'flex' : 'none';
          if (isCountertop) {
            const ends = selectedElement.finishedEnds || [];
            document.getElementById('propFinishedLeft').checked = ends.includes('left');
            document.getElementById('propFinishedRight').checked = ends.includes('right');
          }
        }

        // Thickness row for countertops (2cm vs 3cm)
        const thicknessRow = document.getElementById('thicknessRow');
        const edgeStyleRow = document.getElementById('edgeStyleRow');
        if (thicknessRow) {
          thicknessRow.style.display = isCountertop ? 'flex' : 'none';
          if (isCountertop) {
            const thickness = selectedElement.thickness || '3cm';
            document.getElementById('propThickness').value = thickness;

            // Show edge style row only for 2cm
            if (edgeStyleRow) {
              edgeStyleRow.style.display = thickness === '2cm' ? 'flex' : 'none';
              if (thickness === '2cm') {
                document.getElementById('propEdgeStyle').value = selectedElement.edgeBuildStyle || 'laminated';
              }
            }
          }
        }

        // Waterfall section for countertops - ALWAYS visible for any countertop type
        const waterfallSectionRow = document.getElementById('waterfallSectionRow');
        const waterfallHeightRow = document.getElementById('waterfallHeightRow');

        if (waterfallSectionRow) {
          // Show waterfall section for ALL countertop types
          waterfallSectionRow.style.display = isCountertop ? 'block' : 'none';
          if (isCountertop) {
            // Populate waterfall side checkboxes
            const sides = selectedElement.waterfallSides || [];
            const leftCb = document.getElementById('propWaterfallLeft');
            const rightCb = document.getElementById('propWaterfallRight');
            const frontCb = document.getElementById('propWaterfallFront');
            const backCb = document.getElementById('propWaterfallBack');
            if (leftCb) leftCb.checked = sides.includes('left');
            if (rightCb) rightCb.checked = sides.includes('right');
            if (frontCb) frontCb.checked = sides.includes('front');
            if (backCb) backCb.checked = sides.includes('back');
          }
        }

        if (waterfallHeightRow) {
          const hasWaterfallSides = selectedElement.waterfallSides && selectedElement.waterfallSides.length > 0;
          waterfallHeightRow.style.display = (isCountertop && hasWaterfallSides) ? 'flex' : 'none';
          if (isCountertop && hasWaterfallSides) {
            const dropHeight = selectedElement.waterfallHeight || 2.9;
            const heightSelect = document.getElementById('propWaterfallHeight');
            if (heightSelect) {
              if (dropHeight === 'floor') {
                heightSelect.value = 'floor';
              } else if ([2.5, 2.9, 3].includes(dropHeight)) {
                heightSelect.value = dropHeight.toString();
              } else {
                heightSelect.value = 'custom';
              }
            }
          }
        }

        // Overhang section for countertops
        const overhangSectionRow = document.getElementById('overhangSectionRow');
        if (overhangSectionRow) {
          overhangSectionRow.style.display = isCountertop ? 'block' : 'none';
          if (isCountertop) {
            // Get overhang values (stored in feet, display in inches) - 2" front is standard
            const front = (selectedElement.overhangFront !== undefined ? selectedElement.overhangFront : 0.167) * 12;
            const back = (selectedElement.overhangBack !== undefined ? selectedElement.overhangBack : 0) * 12;
            const left = (selectedElement.overhangLeft !== undefined ? selectedElement.overhangLeft : 0.125) * 12;
            const right = (selectedElement.overhangRight !== undefined ? selectedElement.overhangRight : 0.125) * 12;

            document.getElementById('propOverhangFront').value = front;
            document.getElementById('propOverhangBack').value = back;
            document.getElementById('propOverhangLeft').value = left;
            document.getElementById('propOverhangRight').value = right;

            // Check if matches a preset (2" = standard front overhang to cover cabinet face)
            const presetSelect = document.getElementById('propOverhangPreset');
            if (presetSelect) {
              if (front === 2 && back === 0 && left === 1.5 && right === 1.5) {
                presetSelect.value = 'standard';
              } else if (front === 2 && back === 2 && left === 2 && right === 2) {
                presetSelect.value = 'island';
              } else if (front === 12 && back === 2 && left === 1.5 && right === 1.5) {
                presetSelect.value = 'bar';
              } else if (front === 15 && back === 2 && left === 1.5 && right === 1.5) {
                presetSelect.value = 'breakfast';
              } else {
                presetSelect.value = '';
              }
            }
          }
        }

        // Seams row for countertops
        const seamsRow = document.getElementById('seamsRow');
        if (seamsRow) {
          seamsRow.style.display = isCountertop ? 'flex' : 'none';
          if (isCountertop) {
            // Update the full seam UI (dimensions, seam list, pieces)
            updateSeamUI();

            // Reset seam placement mode button when switching elements
            seamPlacementMode = false;
            const seamPlaceBtn = document.getElementById('seamPlaceModeBtn');
            if (seamPlaceBtn) {
              seamPlaceBtn.style.background = 'rgba(139, 92, 246, 0.3)';
              seamPlaceBtn.textContent = ' Click to Place';
            }
          }
        }

        // Sink-specific properties (color, mount type)
        const isSink = selectedElement.type.startsWith('sink');
        const sinkColorRow = document.getElementById('sinkColorRow');
        const sinkMountRow = document.getElementById('sinkMountRow');

        if (sinkColorRow) {
          sinkColorRow.style.display = isSink ? 'flex' : 'none';
          if (isSink) {
            document.getElementById('propSinkColor').value = selectedElement.sinkColor || 'stainless';
          }
        }

        if (sinkMountRow) {
          sinkMountRow.style.display = isSink ? 'flex' : 'none';
          if (isSink) {
            // Default mount based on sink type
            let defaultMount = 'undermount';
            if (selectedElement.type === 'sink-farmhouse') defaultMount = 'farmhouse';
            document.getElementById('propSinkMount').value = selectedElement.mountType || defaultMount;
          }
        }

        // Window/Door sill height (height from floor)
        const windowDoorTypes = ['window', 'window-large', 'window-bay', 'bay-window', 'picture-window',
          'door', 'double-door', 'sliding-door', 'french-door', 'glass-door', 'entry-archway', 'garage-door'];
        const isWindowOrDoor = windowDoorTypes.includes(selectedElement.type);
        const sillHeightRow = document.getElementById('sillHeightRow');
        const customSillRow = document.getElementById('customSillRow');

        if (sillHeightRow) {
          sillHeightRow.style.display = isWindowOrDoor ? 'flex' : 'none';
          if (isWindowOrDoor) {
            const sillHeight = selectedElement.sillHeight !== undefined ? selectedElement.sillHeight : getDefaultSillHeight(selectedElement.type);
            const select = document.getElementById('propSillHeight');

            // Check if it matches a preset
            const presets = [0, 1.5, 2, 3, 3.5, 4, 5];
            const matchesPreset = presets.some(p => Math.abs(sillHeight - p) < 0.05);

            if (matchesPreset) {
              select.value = presets.find(p => Math.abs(sillHeight - p) < 0.05).toString();
              if (customSillRow) customSillRow.style.display = 'none';
            } else {
              select.value = 'custom';
              if (customSillRow) {
                customSillRow.style.display = 'flex';
                document.getElementById('propCustomSill').value = sillHeight.toFixed(2);
              }
            }
          }
        }
        if (customSillRow && !isWindowOrDoor) {
          customSillRow.style.display = 'none';
        }

        // Door/Archway height controls
        const doorTypes = ['door', 'double-door', 'sliding-door', 'french-door', 'glass-door', 'entry-archway', 'garage-door'];
        const isDoor = doorTypes.includes(selectedElement.type);
        const isArchway = selectedElement.type === 'entry-archway';
        const doorHeightRow = document.getElementById('doorHeightRow');
        const customDoorHeightRow = document.getElementById('customDoorHeightRow');
        const archwayStyleRow = document.getElementById('archwayStyleRow');

        if (doorHeightRow) {
          doorHeightRow.style.display = isDoor ? 'flex' : 'none';
          if (isDoor) {
            const doorHeight = selectedElement.height3D !== undefined ? selectedElement.height3D : 6.8;
            const select = document.getElementById('propDoorHeight');

            // Check if it matches a preset
            const presets = [6.67, 6.83, 7, 8, 9, 10];
            const matchesPreset = presets.some(p => Math.abs(doorHeight - p) < 0.05);

            if (matchesPreset) {
              select.value = presets.find(p => Math.abs(doorHeight - p) < 0.05).toString();
              if (customDoorHeightRow) customDoorHeightRow.style.display = 'none';
            } else {
              select.value = 'custom';
              if (customDoorHeightRow) {
                customDoorHeightRow.style.display = 'flex';
                document.getElementById('propCustomDoorHeight').value = doorHeight.toFixed(2);
                document.getElementById('propDoorHeightDisplay').textContent = formatDimension(doorHeight);
              }
            }
          }
        }
        if (customDoorHeightRow && !isDoor) {
          customDoorHeightRow.style.display = 'none';
        }

        // Archway style (only for archways)
        if (archwayStyleRow) {
          archwayStyleRow.style.display = isArchway ? 'flex' : 'none';
          if (isArchway) {
            document.getElementById('propArchwayStyle').value = selectedElement.archwayStyle || 'round';
          }
        }

        // Window style and mullion pattern (only for windows)
        const windowTypes = ['window', 'window-large', 'window-bay', 'bay-window', 'picture-window'];
        const isWindow = windowTypes.includes(selectedElement.type);
        const windowStyleRow = document.getElementById('windowStyleRow');
        const mullionPatternRow = document.getElementById('mullionPatternRow');

        if (windowStyleRow) {
          windowStyleRow.style.display = isWindow ? 'flex' : 'none';
          if (isWindow) {
            document.getElementById('propWindowStyle').value = selectedElement.windowStyle || 'double-hung';
          }
        }

        if (mullionPatternRow) {
          mullionPatternRow.style.display = isWindow ? 'flex' : 'none';
          if (isWindow) {
            document.getElementById('propMullionPattern').value = selectedElement.mullionPattern || 'standard';
          }
        }

        // Window opening height (3D height of the window)
        const windowHeightRow = document.getElementById('windowHeightRow');
        const customWindowHeightRow = document.getElementById('customWindowHeightRow');

        if (windowHeightRow) {
          windowHeightRow.style.display = isWindow ? 'flex' : 'none';
          if (isWindow) {
            const winHeight = selectedElement.windowHeight !== undefined
              ? selectedElement.windowHeight
              : get3DHeight(selectedElement);
            const select = document.getElementById('propWindowHeight');

            // Check if it matches a preset
            const winPresets = [2, 2.5, 3, 3.5, 4, 5, 6];
            const matchesWinPreset = winPresets.some(p => Math.abs(winHeight - p) < 0.05);

            if (matchesWinPreset) {
              select.value = winPresets.find(p => Math.abs(winHeight - p) < 0.05).toString();
              if (customWindowHeightRow) customWindowHeightRow.style.display = 'none';
            } else {
              select.value = 'custom';
              if (customWindowHeightRow) {
                customWindowHeightRow.style.display = 'flex';
                document.getElementById('propCustomWindowHeight').value = winHeight.toFixed(2);
                const display = document.getElementById('propWindowHeightDisplay');
                if (display) display.textContent = formatDimension(winHeight);
              }
            }
          }
        }
        if (customWindowHeightRow && !isWindow) {
          customWindowHeightRow.style.display = 'none';
        }

        // Pony wall / half wall height controls
        const ponyWallTypes = ['pony-wall', 'pony-wall-bar', 'knee-wall'];
        const isPonyWall = ponyWallTypes.includes(selectedElement.type);
        const wallHeightRow = document.getElementById('wallHeightRow');
        const customWallHeightRow = document.getElementById('customWallHeightRow');

        if (wallHeightRow) {
          wallHeightRow.style.display = isPonyWall ? 'flex' : 'none';
          if (isPonyWall) {
            const wallHeight = selectedElement.wallHeight !== undefined ? selectedElement.wallHeight : 3.5;
            const select = document.getElementById('propWallHeight');

            // Check if it matches a preset
            const presets = [2, 2.5, 3, 3.5, 4];
            const matchesPreset = presets.some(p => Math.abs(wallHeight - p) < 0.05);

            if (matchesPreset) {
              select.value = presets.find(p => Math.abs(wallHeight - p) < 0.05).toString();
              if (customWallHeightRow) customWallHeightRow.style.display = 'none';
            } else {
              select.value = 'custom';
              if (customWallHeightRow) {
                customWallHeightRow.style.display = 'flex';
                document.getElementById('propCustomWallHeight').value = wallHeight.toFixed(2);
                document.getElementById('propWallHeightDisplay').textContent = formatDimension(wallHeight);
              }
            }
          }
        }
        if (customWallHeightRow && !isPonyWall) {
          customWallHeightRow.style.display = 'none';
        }

        // Niche depth controls
        const nicheTypes = ['wall-niche', 'fireplace-niche', 'tv-niche', 'shower-niche'];
        const isNiche = nicheTypes.includes(selectedElement.type);
        const nicheDepthRow = document.getElementById('nicheDepthRow');
        const customNicheDepthRow = document.getElementById('customNicheDepthRow');

        if (nicheDepthRow) {
          nicheDepthRow.style.display = isNiche ? 'flex' : 'none';
          if (isNiche) {
            const nicheDepth = selectedElement.nicheDepth !== undefined ? selectedElement.nicheDepth : 0.33;
            const select = document.getElementById('propNicheDepth');

            // Check if it matches a preset
            const presets = [0.25, 0.33, 0.5, 0.67, 1, 1.5];
            const matchesPreset = presets.some(p => Math.abs(nicheDepth - p) < 0.05);

            if (matchesPreset) {
              select.value = presets.find(p => Math.abs(nicheDepth - p) < 0.05).toString();
              if (customNicheDepthRow) customNicheDepthRow.style.display = 'none';
            } else {
              select.value = 'custom';
              if (customNicheDepthRow) {
                customNicheDepthRow.style.display = 'flex';
                document.getElementById('propCustomNicheDepth').value = nicheDepth.toFixed(2);
                document.getElementById('propNicheDepthDisplay').textContent = formatDimension(nicheDepth);
              }
            }
          }
        }
        if (customNicheDepthRow && !isNiche) {
          customNicheDepthRow.style.display = 'none';
        }

        // Backsplash height controls
        const isBacksplash = selectedElement.type === 'backsplash';
        const backsplashHeightRow = document.getElementById('backsplashHeightRow');
        const customBacksplashHeightRow = document.getElementById('customBacksplashHeightRow');
        const tileTypeRow = document.getElementById('tileTypeRow');

        if (backsplashHeightRow) {
          backsplashHeightRow.style.display = isBacksplash ? 'flex' : 'none';
          if (isBacksplash) {
            const bsHeight = selectedElement.verticalHeight || 1.5;
            const select = document.getElementById('propBacksplashHeight');

            // Check if it matches a preset
            const presets = [0.333, 0.5, 1, 1.5];
            const matchesPreset = presets.some(p => Math.abs(bsHeight - p) < 0.05);

            if (matchesPreset) {
              select.value = presets.find(p => Math.abs(bsHeight - p) < 0.05).toString();
              if (customBacksplashHeightRow) customBacksplashHeightRow.style.display = 'none';
            } else {
              select.value = 'custom';
              if (customBacksplashHeightRow) {
                customBacksplashHeightRow.style.display = 'flex';
                document.getElementById('propCustomBacksplashHeight').value = Math.round(bsHeight * 12);
                document.getElementById('propBacksplashHeightDisplay').textContent = formatDimension(bsHeight);
              }
            }
          }
        }
        if (customBacksplashHeightRow && !isBacksplash) {
          customBacksplashHeightRow.style.display = 'none';
        }
        if (tileTypeRow) {
          tileTypeRow.style.display = isBacksplash ? 'flex' : 'none';
          if (isBacksplash) {
            const tileType = selectedElement.tileType || 'standard';
            document.getElementById('propTileType').value = tileType;
          }
        }

        // Stone surface thickness controls
        const stoneSurfaceTypes = ['wall-cap', 'bar-top', 'niche-surround', 'fireplace-surround', 'fireplace-hearth', 'mantel', 'window-sill', 'threshold'];
        const isStoneSurface = stoneSurfaceTypes.includes(selectedElement.type);
        const stoneThicknessRow = document.getElementById('stoneThicknessRow');

        if (stoneThicknessRow) {
          stoneThicknessRow.style.display = isStoneSurface ? 'flex' : 'none';
          if (isStoneSurface) {
            const thickness = selectedElement.stoneThickness !== undefined ? selectedElement.stoneThickness : 0.1;
            const select = document.getElementById('propStoneThickness');
            // Find closest preset
            const presets = [0.0625, 0.1, 0.125, 0.17, 0.25];
            const closestPreset = presets.reduce((prev, curr) =>
              Math.abs(curr - thickness) < Math.abs(prev - thickness) ? curr : prev
            );
            select.value = closestPreset.toString();
          }
        }

        // Cap height control for wall caps and bar tops
        const capTypes = ['wall-cap', 'bar-top'];
        const isCapElement = capTypes.includes(selectedElement.type);
        const capHeightRow = document.getElementById('capHeightRow');
        const customCapHeightRow = document.getElementById('customCapHeightRow');
        const edgePreviewBtnRow = document.getElementById('edgePreviewBtnRow');

        if (capHeightRow) {
          capHeightRow.style.display = isCapElement ? 'flex' : 'none';
          if (isCapElement) {
            const capHeight = selectedElement.capHeight !== undefined ? selectedElement.capHeight : 3.5;
            const select = document.getElementById('propCapHeight');
            const presets = [2, 2.5, 3, 3.5, 4];
            const matchesPreset = presets.some(p => Math.abs(capHeight - p) < 0.05);

            if (matchesPreset) {
              select.value = presets.find(p => Math.abs(capHeight - p) < 0.05).toString();
              if (customCapHeightRow) customCapHeightRow.style.display = 'none';
            } else {
              select.value = 'custom';
              if (customCapHeightRow) {
                customCapHeightRow.style.display = 'flex';
                document.getElementById('propCustomCapHeight').value = capHeight.toFixed(2);
                document.getElementById('propCapHeightDisplay').textContent = formatDimension(capHeight);
              }
            }
          }
        }
        if (customCapHeightRow && !isCapElement) customCapHeightRow.style.display = 'none';

        // Edge preview button for countertops and stone surfaces
        if (edgePreviewBtnRow) {
          const showEdgeBtn = selectedElement.type === 'countertop' || isStoneSurface;
          edgePreviewBtnRow.style.display = showEdgeBtn ? 'flex' : 'none';
        }

        // Flooring/tile grain direction controls
        const flooringTypes = ['flooring', 'tile', 'hardwood', 'laminate', 'vinyl', 'carpet'];
        const isFlooring = flooringTypes.includes(selectedElement.type);
        const grainDirectionRow = document.getElementById('grainDirectionRow');

        if (grainDirectionRow) {
          grainDirectionRow.style.display = isFlooring ? 'flex' : 'none';
          if (isFlooring) {
            const grainDir = selectedElement.grainDirection || 0;
            // Update button states
            document.querySelectorAll('.grain-btn').forEach(btn => {
              btn.classList.toggle('active', parseInt(btn.dataset.dir) === grainDir);
            });
          }
        }

        // Structural element controls (beams and columns)
        const beamTypes = ['steel-beam', 'wood-beam', 'concrete-beam', 'header', 'lvl-beam'];
        const columnTypes = ['steel-column', 'wood-post', 'concrete-column'];
        const isBeam = beamTypes.includes(selectedElement.type);
        const isColumn = columnTypes.includes(selectedElement.type);

        const beamDepthRow = document.getElementById('beamDepthRow');
        const customBeamDepthRow = document.getElementById('customBeamDepthRow');
        const beamElevationRow = document.getElementById('beamElevationRow');
        const customBeamElevationRow = document.getElementById('customBeamElevationRow');
        const columnHeightRow = document.getElementById('columnHeightRow');
        const customColumnHeightRow = document.getElementById('customColumnHeightRow');
        const columnSizeRow = document.getElementById('columnSizeRow');

        // Beam depth control
        if (beamDepthRow) {
          beamDepthRow.style.display = isBeam ? 'flex' : 'none';
          if (isBeam) {
            const beamDepth = selectedElement.beamDepth !== undefined ? selectedElement.beamDepth : getDefaultBeamDepth(selectedElement.type);
            const select = document.getElementById('propBeamDepth');
            const presets = [0.33, 0.5, 0.67, 0.83, 1, 1.17];
            const matchesPreset = presets.some(p => Math.abs(beamDepth - p) < 0.02);

            if (matchesPreset) {
              select.value = presets.find(p => Math.abs(beamDepth - p) < 0.02).toString();
              if (customBeamDepthRow) customBeamDepthRow.style.display = 'none';
            } else {
              select.value = 'custom';
              if (customBeamDepthRow) {
                customBeamDepthRow.style.display = 'flex';
                document.getElementById('propCustomBeamDepth').value = beamDepth.toFixed(2);
                document.getElementById('propBeamDepthDisplay').textContent = formatDimension(beamDepth);
              }
            }
          }
        }
        if (customBeamDepthRow && !isBeam) customBeamDepthRow.style.display = 'none';

        // Beam elevation control
        if (beamElevationRow) {
          beamElevationRow.style.display = isBeam ? 'flex' : 'none';
          if (isBeam) {
            const beamElevation = selectedElement.beamElevation;
            const select = document.getElementById('propBeamElevation');

            if (beamElevation === undefined) {
              select.value = 'ceiling';
              if (customBeamElevationRow) customBeamElevationRow.style.display = 'none';
            } else {
              const presets = [7, 7.5, 8, 9, 10];
              const matchesPreset = presets.some(p => Math.abs(beamElevation - p) < 0.05);

              if (matchesPreset) {
                select.value = presets.find(p => Math.abs(beamElevation - p) < 0.05).toString();
                if (customBeamElevationRow) customBeamElevationRow.style.display = 'none';
              } else {
                select.value = 'custom';
                if (customBeamElevationRow) {
                  customBeamElevationRow.style.display = 'flex';
                  document.getElementById('propCustomBeamElevation').value = beamElevation.toFixed(2);
                  document.getElementById('propBeamElevationDisplay').textContent = formatDimension(beamElevation);
                }
              }
            }
          }
        }
        if (customBeamElevationRow && !isBeam) customBeamElevationRow.style.display = 'none';

        // Column height control
        if (columnHeightRow) {
          columnHeightRow.style.display = isColumn ? 'flex' : 'none';
          if (isColumn) {
            const columnHeight = selectedElement.columnHeight;
            const select = document.getElementById('propColumnHeight');

            if (columnHeight === undefined) {
              select.value = 'ceiling';
              if (customColumnHeightRow) customColumnHeightRow.style.display = 'none';
            } else {
              const presets = [8, 9, 10, 12];
              const matchesPreset = presets.some(p => Math.abs(columnHeight - p) < 0.05);

              if (matchesPreset) {
                select.value = presets.find(p => Math.abs(columnHeight - p) < 0.05).toString();
                if (customColumnHeightRow) customColumnHeightRow.style.display = 'none';
              } else {
                select.value = 'custom';
                if (customColumnHeightRow) {
                  customColumnHeightRow.style.display = 'flex';
                  document.getElementById('propCustomColumnHeight').value = columnHeight.toFixed(2);
                  document.getElementById('propColumnHeightDisplay').textContent = formatDimension(columnHeight);
                }
              }
            }
          }
        }
        if (customColumnHeightRow && !isColumn) customColumnHeightRow.style.display = 'none';

        // Column size control
        if (columnSizeRow) {
          columnSizeRow.style.display = isColumn ? 'flex' : 'none';
          if (isColumn) {
            const colSize = selectedElement.width || 0.5;
            const select = document.getElementById('propColumnSize');
            const presets = [0.33, 0.5, 0.67, 1, 1.33];
            const matchesPreset = presets.some(p => Math.abs(colSize - p) < 0.02);

            if (matchesPreset) {
              select.value = presets.find(p => Math.abs(colSize - p) < 0.02).toString();
            } else {
              select.value = 'custom';
            }
          }
        }

        // Full-height wall controls (walls, masonry, concrete, etc.)
        const fullWallTypes = ['wall', 'wall-block', 'wall-concrete', 'wall-framed', 'wall-wood-2x4', 'wall-wood-2x6', 'wall-brick', 'wall-steel', 'wall-aluminum'];
        const isFullWall = fullWallTypes.includes(selectedElement.type);
        const fullWallHeightRow = document.getElementById('fullWallHeightRow');
        const customFullWallHeightRow = document.getElementById('customFullWallHeightRow');
        const wallThicknessRow = document.getElementById('wallThicknessRow');
        const customWallThicknessRow = document.getElementById('customWallThicknessRow');

        // Full wall height control
        if (fullWallHeightRow) {
          fullWallHeightRow.style.display = isFullWall ? 'flex' : 'none';
          if (isFullWall) {
            const wallHeight = selectedElement.wallHeight;
            const select = document.getElementById('propFullWallHeight');

            if (wallHeight === undefined) {
              select.value = 'ceiling';
              if (customFullWallHeightRow) customFullWallHeightRow.style.display = 'none';
            } else {
              const presets = [8, 9, 10, 12, 14, 16];
              const matchesPreset = presets.some(p => Math.abs(wallHeight - p) < 0.05);

              if (matchesPreset) {
                select.value = presets.find(p => Math.abs(wallHeight - p) < 0.05).toString();
                if (customFullWallHeightRow) customFullWallHeightRow.style.display = 'none';
              } else {
                select.value = 'custom';
                if (customFullWallHeightRow) {
                  customFullWallHeightRow.style.display = 'flex';
                  document.getElementById('propCustomFullWallHeight').value = wallHeight.toFixed(2);
                  document.getElementById('propFullWallHeightDisplay').textContent = formatDimension(wallHeight);
                }
              }
            }
          }
        }
        if (customFullWallHeightRow && !isFullWall) customFullWallHeightRow.style.display = 'none';

        // Wall thickness control
        if (wallThicknessRow) {
          wallThicknessRow.style.display = isFullWall ? 'flex' : 'none';
          if (isFullWall) {
            const thickness = selectedElement.height || 0.5; // In 2D, 'height' is the depth/thickness
            const select = document.getElementById('propWallThickness');
            const presets = [0.33, 0.5, 0.67, 0.83, 1, 1.33];
            const matchesPreset = presets.some(p => Math.abs(thickness - p) < 0.02);

            if (matchesPreset) {
              select.value = presets.find(p => Math.abs(thickness - p) < 0.02).toString();
              if (customWallThicknessRow) customWallThicknessRow.style.display = 'none';
            } else {
              select.value = 'custom';
              if (customWallThicknessRow) {
                customWallThicknessRow.style.display = 'flex';
                document.getElementById('propCustomWallThickness').value = thickness.toFixed(2);
                document.getElementById('propWallThicknessDisplay').textContent = formatDimension(thickness);
              }
            }
          }
        }
        if (customWallThicknessRow && !isFullWall) customWallThicknessRow.style.display = 'none';

        // Generic 3D height override for elements without specialized height controls
        const generic3DHeightRow = document.getElementById('generic3DHeightRow');
        const customGeneric3DHeightRow = document.getElementById('customGeneric3DHeightRow');
        const typesWithSpecializedHeight = new Set([
          'window', 'window-large', 'picture-window', 'window-bay', 'window-arch', 'window-circle',
          'door', 'door-double', 'door-sliding', 'door-french', 'door-bifold', 'door-pocket', 'glass-door',
          'wall', 'full-wall', 'pony-wall', 'half-wall', 'knee-wall',
          'beam', 'header', 'beam-decorative', 'column', 'column-round',
          'countertop', 'countertop-l', 'countertop-u', 'countertop-corner', 'island',
          'flooring', 'tile', 'floor-tile', 'hardwood', 'laminate',
          'wall-cap', 'bar-top', 'niche', 'niche-arched', 'niche-shelf'
        ]);
        const showGenericHeight = !typesWithSpecializedHeight.has(selectedElement.type);
        if (generic3DHeightRow) {
          generic3DHeightRow.style.display = showGenericHeight ? 'flex' : 'none';
          if (showGenericHeight) {
            const h3d = selectedElement.height3D;
            const select = document.getElementById('propGeneric3DHeight');
            if (h3d !== undefined && h3d !== null) {
              const presets = [0.5, 1, 1.5, 2, 2.5, 3, 3.5, 4, 5, 6, 7, 8];
              const matchPreset = presets.find(p => Math.abs(h3d - p) < 0.02);
              if (matchPreset !== undefined) {
                select.value = matchPreset.toString();
                if (customGeneric3DHeightRow) customGeneric3DHeightRow.style.display = 'none';
              } else {
                select.value = 'custom';
                if (customGeneric3DHeightRow) {
                  customGeneric3DHeightRow.style.display = 'flex';
                  document.getElementById('propCustomGeneric3DHeight').value = h3d.toFixed(2);
                }
              }
            } else {
              select.value = 'default';
              if (customGeneric3DHeightRow) customGeneric3DHeightRow.style.display = 'none';
            }
          }
        }
        if (customGeneric3DHeightRow && !showGenericHeight) customGeneric3DHeightRow.style.display = 'none';

        // Update pricing section
        const pricingSection = document.getElementById('pricingSection');
        if (pricingSection && checkPermission('canViewPrices')) {
          pricingSection.style.display = 'block';

          const priceInfo = getElementPrice(selectedElement);
          document.getElementById('propBasePrice').textContent = '$' + priceInfo.price.toFixed(2);
          document.getElementById('propPriceOverride').value = selectedElement.priceOverride || '';
          document.getElementById('propPriceUnit').value = selectedElement.priceUnit || 'sqft';
          document.getElementById('propMargin').value = selectedElement.marginPercent !== null ? selectedElement.marginPercent : '';

          // Calculate and show item total
          const margin = getElementMargin(selectedElement);
          let quantity = 1;
          if (['countertop', 'backsplash', 'flooring', 'tile'].includes(selectedElement.type)) {
            quantity = selectedElement.width * selectedElement.height;
          }
          const cost = priceInfo.price * quantity;
          const retail = cost * (1 + margin / 100);
          document.getElementById('propItemTotal').textContent = '$' + retail.toFixed(2);
        } else if (pricingSection) {
          pricingSection.style.display = 'none';
        }
      } else {
        empty.style.display = 'block';
        content.style.display = 'none';
      }
    }

    function updateSelectedElement() {
      if (!selectedElement || selectedElement.locked) return;

      // Parse dimension inputs (accepts feet-inches like 3'-6" or decimal 2.5)
      const widthInput = document.getElementById('propWidth').value;
      const depthInput = document.getElementById('propDepth');
      const height3DInput = document.getElementById('prop3DHeight');

      selectedElement.width = roundToSixteenth(parseDimension(widthInput)) || 1;
      if (depthInput) {
        selectedElement.height = roundToSixteenth(parseDimension(depthInput.value)) || 1;
      }
      // 3D Height (vertical dimension) - store as actualHeight
      if (height3DInput && height3DInput.value) {
        const parsed3DHeight = parseDimension(height3DInput.value);
        if (parsed3DHeight > 0) {
          selectedElement.actualHeight = roundToSixteenth(parsed3DHeight);
        }
      }
      selectedElement.color = document.getElementById('propColor').value;

      // Mark element as needing 3D update
      markElement3DDirty(selectedElement.id);

      // Update display with formatted dimensions
      updateProperties();
      draw();
    }

    // Set grain/tile direction for flooring
    function setGrainDirection(angle) {
      if (!selectedElement || selectedElement.locked) return;

      const isFlooringType = ['flooring', 'tile', 'hardwood', 'laminate', 'vinyl', 'carpet'].includes(selectedElement.type);
      if (!isFlooringType) return;

      selectedElement.grainDirection = angle;

      // Mark element as needing 3D update
      markElement3DDirty(selectedElement.id);

      // Update button states
      document.querySelectorAll('.grain-btn').forEach(btn => {
        btn.classList.toggle('active', parseInt(btn.dataset.dir) === angle);
      });

      saveUndoState();
      draw();
      update3DScene();

      const dirNames = { 0: 'Horizontal', 90: 'Vertical', 45: 'Diagonal ()', 135: 'Diagonal ()' };
      showSnapFeedback(`Grain direction: ${dirNames[angle] || angle + ''}`);
    }

    // Get default beam depth based on type
    function getDefaultBeamDepth(type) {
      switch(type) {
        case 'steel-beam': return 0.67;     // W8 beam - 8"
        case 'wood-beam': return 0.5;        // 6" timber
        case 'concrete-beam': return 0.83;   // 10" concrete beam
        case 'header': return 0.33;          // 4" header
        case 'lvl-beam': return 0.92;        // 11" LVL
        default: return 0.67;
      }
    }

    // Update beam depth from dropdown
    function updateBeamDepth() {
      if (!selectedElement || selectedElement.locked) return;

      const select = document.getElementById('propBeamDepth');
      const value = select.value;
      const customRow = document.getElementById('customBeamDepthRow');

      if (value === 'custom') {
        customRow.style.display = 'flex';
        const current = selectedElement.beamDepth || getDefaultBeamDepth(selectedElement.type);
        document.getElementById('propCustomBeamDepth').value = current.toFixed(2);
        document.getElementById('propBeamDepthDisplay').textContent = formatDimension(current);
        return;
      }

      customRow.style.display = 'none';
      const depth = parseFloat(value);
      selectedElement.beamDepth = depth;

      saveUndoState();
      draw();
      update3DScene();
      showSnapFeedback(`Beam depth: ${Math.round(depth * 12)}"`);
    }

    // Apply custom beam depth
    function applyCustomBeamDepth() {
      if (!selectedElement || selectedElement.locked) return;

      const input = document.getElementById('propCustomBeamDepth');
      const depth = parseDimension(input.value);
      if (depth && depth > 0 && depth <= 4) {
        selectedElement.beamDepth = depth;
        document.getElementById('propBeamDepthDisplay').textContent = formatDimension(depth);

        saveUndoState();
        draw();
        update3DScene();
        showSnapFeedback(`Beam depth: ${formatDimension(depth)}`);
      }
    }

    // Update beam elevation from dropdown
    function updateBeamElevation() {
      if (!selectedElement || selectedElement.locked) return;

      const select = document.getElementById('propBeamElevation');
      const value = select.value;
      const customRow = document.getElementById('customBeamElevationRow');

      if (value === 'custom') {
        customRow.style.display = 'flex';
        const current = selectedElement.beamElevation || roomHeight || 8;
        document.getElementById('propCustomBeamElevation').value = current.toFixed(2);
        document.getElementById('propBeamElevationDisplay').textContent = formatDimension(current);
        return;
      }

      customRow.style.display = 'none';

      if (value === 'ceiling') {
        delete selectedElement.beamElevation; // Use room height
        showSnapFeedback('Beam at ceiling level');
      } else {
        selectedElement.beamElevation = parseFloat(value);
        showSnapFeedback(`Beam elevation: ${formatDimension(parseFloat(value))}`);
      }

      saveUndoState();
      draw();
      update3DScene();
    }

    // Apply custom beam elevation
    function applyCustomBeamElevation() {
      if (!selectedElement || selectedElement.locked) return;

      const input = document.getElementById('propCustomBeamElevation');
      const elevation = parseDimension(input.value);
      if (elevation && elevation > 0 && elevation <= 20) {
        selectedElement.beamElevation = elevation;
        document.getElementById('propBeamElevationDisplay').textContent = formatDimension(elevation);

        saveUndoState();
        draw();
        update3DScene();
        showSnapFeedback(`Beam elevation: ${formatDimension(elevation)}`);
      }
    }

    // Update column height from dropdown
    function updateColumnHeight() {
      if (!selectedElement || selectedElement.locked) return;

      const select = document.getElementById('propColumnHeight');
      const value = select.value;
      const customRow = document.getElementById('customColumnHeightRow');

      if (value === 'custom') {
        customRow.style.display = 'flex';
        const current = selectedElement.columnHeight || roomHeight || 8;
        document.getElementById('propCustomColumnHeight').value = current.toFixed(2);
        document.getElementById('propColumnHeightDisplay').textContent = formatDimension(current);
        return;
      }

      customRow.style.display = 'none';

      if (value === 'ceiling') {
        delete selectedElement.columnHeight; // Use room height
        showSnapFeedback('Column: floor to ceiling');
      } else {
        selectedElement.columnHeight = parseFloat(value);
        showSnapFeedback(`Column height: ${formatDimension(parseFloat(value))}`);
      }

      saveUndoState();
      draw();
      update3DScene();
    }

    // Apply custom column height
    function applyCustomColumnHeight() {
      if (!selectedElement || selectedElement.locked) return;

      const input = document.getElementById('propCustomColumnHeight');
      const height = parseDimension(input.value);
      if (height && height > 0 && height <= 20) {
        selectedElement.columnHeight = height;
        document.getElementById('propColumnHeightDisplay').textContent = formatDimension(height);

        saveUndoState();
        draw();
        update3DScene();
        showSnapFeedback(`Column height: ${formatDimension(height)}`);
      }
    }

    // Update column size from dropdown
    function updateColumnSize() {
      if (!selectedElement || selectedElement.locked) return;

      const select = document.getElementById('propColumnSize');
      const value = select.value;

      if (value === 'custom') {
        // Custom sizes can be entered via width/height fields
        showSnapFeedback('Enter custom size in Width/Depth fields');
        return;
      }

      const size = parseFloat(value);
      selectedElement.width = size;
      selectedElement.height = size; // Square column

      updateProperties();
      saveUndoState();
      draw();
      update3DScene();
      showSnapFeedback(`Column size: ${Math.round(size * 12)}"${Math.round(size * 12)}"`);
    }

    // Generic 3D height override for elements without specialized height controls
    function updateGeneric3DHeight() {
      if (!selectedElement || selectedElement.locked) return;

      const select = document.getElementById('propGeneric3DHeight');
      const value = select.value;
      const customRow = document.getElementById('customGeneric3DHeightRow');

      if (value === 'custom') {
        customRow.style.display = 'flex';
        const current = selectedElement.height3D || 3;
        document.getElementById('propCustomGeneric3DHeight').value = current.toFixed(2);
        return;
      }

      customRow.style.display = 'none';

      if (value === 'default') {
        delete selectedElement.height3D;
      } else {
        selectedElement.height3D = parseFloat(value);
      }

      markElement3DDirty(selectedElement.id);
      saveUndoState();
      draw();
      update3DScene();
      const label = value === 'default' ? 'Default' : formatDimension(parseFloat(value));
      showSnapFeedback(`3D Height: ${label}`);
    }

    function applyCustomGeneric3DHeight() {
      if (!selectedElement || selectedElement.locked) return;

      const input = document.getElementById('propCustomGeneric3DHeight');
      const height = parseFloat(input.value);
      if (height && height >= 0.1 && height <= 20) {
        selectedElement.height3D = height;
        markElement3DDirty(selectedElement.id);
        saveUndoState();
        draw();
        update3DScene();
        showSnapFeedback(`3D Height: ${formatDimension(height)}`);
      }
    }

    // Update full wall height from dropdown
    function updateFullWallHeight() {
      if (!selectedElement || selectedElement.locked) return;

      const select = document.getElementById('propFullWallHeight');
      const value = select.value;
      const customRow = document.getElementById('customFullWallHeightRow');

      if (value === 'custom') {
        customRow.style.display = 'flex';
        const current = selectedElement.wallHeight || roomHeight || 8;
        document.getElementById('propCustomFullWallHeight').value = current.toFixed(2);
        document.getElementById('propFullWallHeightDisplay').textContent = formatDimension(current);
        return;
      }

      customRow.style.display = 'none';

      if (value === 'ceiling') {
        delete selectedElement.wallHeight; // Use room height
        showSnapFeedback('Wall: floor to ceiling');
      } else {
        selectedElement.wallHeight = parseFloat(value);
        showSnapFeedback(`Wall height: ${formatDimension(parseFloat(value))}`);
      }

      saveUndoState();
      draw();
      update3DScene();
    }

    // Apply custom full wall height
    function applyCustomFullWallHeight() {
      if (!selectedElement || selectedElement.locked) return;

      const input = document.getElementById('propCustomFullWallHeight');
      const height = parseDimension(input.value);
      if (height && height > 0 && height <= 30) {
        selectedElement.wallHeight = height;
        document.getElementById('propFullWallHeightDisplay').textContent = formatDimension(height);

        saveUndoState();
        draw();
        update3DScene();
        showSnapFeedback(`Wall height: ${formatDimension(height)}`);
      }
    }

    // Update wall thickness from dropdown
    function updateWallThickness() {
      if (!selectedElement || selectedElement.locked) return;

      const select = document.getElementById('propWallThickness');
      const value = select.value;
      const customRow = document.getElementById('customWallThicknessRow');

      if (value === 'custom') {
        customRow.style.display = 'flex';
        const current = selectedElement.height || 0.5;
        document.getElementById('propCustomWallThickness').value = current.toFixed(2);
        document.getElementById('propWallThicknessDisplay').textContent = formatDimension(current);
        return;
      }

      customRow.style.display = 'none';
      const thickness = parseFloat(value);
      selectedElement.height = thickness; // In 2D, height is depth/thickness

      updateProperties();
      saveUndoState();
      draw();
      update3DScene();
      showSnapFeedback(`Wall thickness: ${Math.round(thickness * 12)}"`);
    }

    // Apply custom wall thickness
    function applyCustomWallThickness() {
      if (!selectedElement || selectedElement.locked) return;

      const input = document.getElementById('propCustomWallThickness');
      const thickness = parseDimension(input.value);
      if (thickness && thickness > 0 && thickness <= 3) {
        selectedElement.height = thickness;
        document.getElementById('propWallThicknessDisplay').textContent = formatDimension(thickness);

        updateProperties();
        saveUndoState();
        draw();
        update3DScene();
        showSnapFeedback(`Wall thickness: ${formatDimension(thickness)}`);
      }
    }

    // Apply a standard size from dropdown
    function applyStandardSize() {
      if (!selectedElement || selectedElement.locked) return;

      const select = document.getElementById('propStandardSize');
      const value = select.value;
      if (!value) return;

      const [width, height] = value.split('x').map(parseFloat);
      if (width && height) {
        selectedElement.width = width;
        selectedElement.height = height;
        updateProperties();
        draw();
        showSnapFeedback(`Applied standard size: ${formatDimension(width)}  ${formatDimension(height)}`);
      }
    }

    // Get default sill height based on element type (building code compliant)
    function getDefaultSillHeight(type) {
      // Proper construction sill heights per IRC / industry standards
      switch(type) {
        case 'window':
          return 3;       // 36" - IRC standard residential window sill
        case 'window-large':
          return 2;       // 24" - picture windows sit lower for views
        case 'window-bay':
        case 'bay-window':
          return 3.5;     // 42" - above counter height (kitchen bay windows)
        case 'picture-window':
          return 1.5;     // 18" - near floor for panoramic views
        case 'door':
        case 'double-door':
        case 'sliding-door':
        case 'french-door':
        case 'glass-door':
        case 'entry-archway':
        case 'garage-door':
          return 0;       // Floor level for all doors
        default:
          return 3;       // 36" IRC default
      }
    }

    // Update sill height from dropdown
    function updateSillHeight() {
      if (!selectedElement) return;

      const select = document.getElementById('propSillHeight');
      const value = select.value;
      const customSillRow = document.getElementById('customSillRow');

      if (value === 'custom') {
        customSillRow.style.display = 'flex';
        document.getElementById('propCustomSill').value = selectedElement.sillHeight || getDefaultSillHeight(selectedElement.type);
        return;
      }

      customSillRow.style.display = 'none';
      const sillHeight = parseFloat(value);
      selectedElement.sillHeight = sillHeight;

      // Show building code info
      let codeInfo = '';
      if (sillHeight < 2) {
        codeInfo = ' (Note: Standard min is 24")';
      } else if (sillHeight > 3.67) {
        codeInfo = ' (Warning: May exceed egress max 44")';
      }

      markElement3DDirty(selectedElement.id);
      saveUndoState();
      draw();
      update3DScene();
      showSnapFeedback(`Sill height: ${Math.round(sillHeight * 12)}"${codeInfo}`);
    }

    // Apply custom sill height
    function applyCustomSillHeight() {
      if (!selectedElement) return;

      const input = document.getElementById('propCustomSill');
      const sillHeight = parseFloat(input.value) || 0;

      // Clamp to reasonable values
      selectedElement.sillHeight = Math.max(0, Math.min(8, sillHeight));

      // Building code warnings
      let warning = '';
      if (sillHeight < 2 && selectedElement.type === 'window') {
        warning = ' - Below 24" minimum for safety';
      } else if (sillHeight > 3.67 && selectedElement.type === 'window') {
        warning = ' - Above 44" egress maximum';
      }

      markElement3DDirty(selectedElement.id);
      saveUndoState();
      draw();
      update3DScene();
      showSnapFeedback(`Custom sill: ${Math.round(sillHeight * 12)}"${warning}`);
    }

    // Update window opening height (3D height of the window)
    function updateWindowOpeningHeight() {
      if (!selectedElement) return;

      const select = document.getElementById('propWindowHeight');
      const value = select.value;
      const customRow = document.getElementById('customWindowHeightRow');

      if (value === 'custom') {
        if (customRow) {
          customRow.style.display = 'flex';
          document.getElementById('propCustomWindowHeight').value =
            selectedElement.windowHeight || get3DHeight(selectedElement);
        }
        return;
      }

      if (customRow) customRow.style.display = 'none';
      const windowHeight = parseFloat(value);
      selectedElement.windowHeight = windowHeight;

      markElement3DDirty(selectedElement.id);
      saveUndoState();
      draw();
      update3DScene();
      showSnapFeedback(`Window height: ${Math.round(windowHeight * 12)}"`);
    }

    // Apply custom window opening height
    function applyCustomWindowOpeningHeight() {
      if (!selectedElement) return;

      const input = document.getElementById('propCustomWindowHeight');
      const windowHeight = Math.max(1, Math.min(10, parseFloat(input.value) || 3));
      selectedElement.windowHeight = windowHeight;

      const display = document.getElementById('propWindowHeightDisplay');
      if (display) display.textContent = formatDimension(windowHeight);

      markElement3DDirty(selectedElement.id);
      saveUndoState();
      draw();
      update3DScene();
      showSnapFeedback(`Window height: ${Math.round(windowHeight * 12)}"`);
    }

    // Update door/archway height
    function updateDoorHeight() {
      if (!selectedElement) return;

      const select = document.getElementById('propDoorHeight');
      const value = select.value;
      const customDoorHeightRow = document.getElementById('customDoorHeightRow');

      if (value === 'custom') {
        customDoorHeightRow.style.display = 'flex';
        const currentHeight = selectedElement.height3D || 6.8;
        document.getElementById('propCustomDoorHeight').value = currentHeight.toFixed(2);
        document.getElementById('propDoorHeightDisplay').textContent = formatDimension(currentHeight);
        return;
      }

      customDoorHeightRow.style.display = 'none';
      const doorHeight = parseFloat(value);
      selectedElement.height3D = doorHeight;

      saveUndoState();
      draw();
      update3DScene();
      showSnapFeedback(`Opening height: ${Math.round(doorHeight * 12)}" (${formatDimension(doorHeight)})`);
    }

    // Apply custom door height
    function applyCustomDoorHeight() {
      if (!selectedElement) return;

      const input = document.getElementById('propCustomDoorHeight');
      const doorHeight = parseFloat(input.value) || 6.8;

      // Clamp to reasonable values
      selectedElement.height3D = Math.max(5, Math.min(12, doorHeight));

      document.getElementById('propDoorHeightDisplay').textContent = formatDimension(selectedElement.height3D);

      saveUndoState();
      draw();
      update3DScene();
      showSnapFeedback(`Custom height: ${Math.round(selectedElement.height3D * 12)}"`);
    }

    // Update archway style
    function updateArchwayStyle() {
      if (!selectedElement) return;

      const style = document.getElementById('propArchwayStyle').value;
      selectedElement.archwayStyle = style;

      saveUndoState();
      draw();
      update3DScene();
      showSnapFeedback(`Archway style: ${style}`);
    }

    // Update window style (double-hung, casement, sliding, etc.)
    function updateWindowStyle() {
      if (!selectedElement) return;

      const style = document.getElementById('propWindowStyle').value;
      selectedElement.windowStyle = style;

      saveUndoState();
      draw();
      update3DScene();
      showSnapFeedback(`Window style: ${style.replace('-', ' ')}`);
    }

    // Update window mullion/grille pattern
    function updateMullionPattern() {
      if (!selectedElement) return;

      const pattern = document.getElementById('propMullionPattern').value;
      selectedElement.mullionPattern = pattern;

      saveUndoState();
      draw();
      update3DScene();
      showSnapFeedback(`Mullion pattern: ${pattern}`);
    }

    // Update wall height for pony walls/half walls
    function updateWallHeight() {
      if (!selectedElement) return;

      const select = document.getElementById('propWallHeight');
      const value = select.value;
      const customWallHeightRow = document.getElementById('customWallHeightRow');

      if (value === 'custom') {
        customWallHeightRow.style.display = 'flex';
        const currentHeight = selectedElement.wallHeight || 3.5;
        document.getElementById('propCustomWallHeight').value = currentHeight.toFixed(2);
        document.getElementById('propWallHeightDisplay').textContent = formatDimension(currentHeight);
        return;
      }

      customWallHeightRow.style.display = 'none';
      const wallHeight = parseFloat(value);
      selectedElement.wallHeight = wallHeight;

      // Update any wall-caps linked to this wall
      updateLinkedWallCaps(selectedElement, wallHeight);

      saveUndoState();
      draw();
      update3DScene();
      showSnapFeedback(`Wall height: ${Math.round(wallHeight * 12)}" (${formatDimension(wallHeight)})`);
    }

    // Update any wall-caps that are linked to or overlapping with this pony wall
    function updateLinkedWallCaps(wall, wallHeight) {
      const capTypes = ['wall-cap', 'bar-top'];
      const wallCenterX = wall.x / pixelsPerFoot + wall.width / 2;
      const wallCenterY = wall.y / pixelsPerFoot + wall.height / 2;

      elements.forEach(el => {
        if (!capTypes.includes(el.type)) return;

        // Check if linked by parentWallId
        if (el.parentWallId === wall.id) {
          el.capHeight = wallHeight;
          return;
        }

        // Check if overlapping (for manually placed caps)
        const capCenterX = el.x / pixelsPerFoot + el.width / 2;
        const capCenterY = el.y / pixelsPerFoot + el.height / 2;
        const distX = Math.abs(capCenterX - wallCenterX);
        const distY = Math.abs(capCenterY - wallCenterY);

        // If cap overlaps this wall, update its height
        if (distX < (el.width + wall.width) / 2 + 0.5 &&
            distY < (el.height + wall.height) / 2 + 0.5) {
          el.capHeight = wallHeight;
        }
      });
    }

    // Apply custom wall height
    function applyCustomWallHeight() {
      if (!selectedElement) return;

      const input = document.getElementById('propCustomWallHeight');
      const wallHeight = parseFloat(input.value) || 3.5;

      // Clamp to reasonable values (1ft to 8ft)
      selectedElement.wallHeight = Math.max(1, Math.min(8, wallHeight));

      // Update any wall-caps linked to this wall
      updateLinkedWallCaps(selectedElement, selectedElement.wallHeight);

      // Update display
      document.getElementById('propWallHeightDisplay').textContent = formatDimension(selectedElement.wallHeight);

      saveUndoState();
      draw();
      update3DScene();
      showSnapFeedback(`Wall height: ${Math.round(selectedElement.wallHeight * 12)}" (${formatDimension(selectedElement.wallHeight)})`);
    }

    // Update niche depth for recessed wall elements
    function updateNicheDepth() {
      if (!selectedElement) return;

      const select = document.getElementById('propNicheDepth');
      const value = select.value;
      const customNicheDepthRow = document.getElementById('customNicheDepthRow');

      if (value === 'custom') {
        customNicheDepthRow.style.display = 'flex';
        const currentDepth = selectedElement.nicheDepth || 0.33;
        document.getElementById('propCustomNicheDepth').value = currentDepth.toFixed(2);
        document.getElementById('propNicheDepthDisplay').textContent = formatDimension(currentDepth);
        return;
      }

      customNicheDepthRow.style.display = 'none';
      const nicheDepth = parseFloat(value);
      selectedElement.nicheDepth = nicheDepth;

      saveUndoState();
      draw();
      update3DScene();
      showSnapFeedback(`Niche depth: ${Math.round(nicheDepth * 12)}" (${formatDimension(nicheDepth)})`);
    }

    // Apply custom niche depth
    function applyCustomNicheDepth() {
      if (!selectedElement) return;

      const input = document.getElementById('propCustomNicheDepth');
      const nicheDepth = parseFloat(input.value) || 0.33;

      // Clamp to reasonable values (2" to 3ft)
      selectedElement.nicheDepth = Math.max(0.17, Math.min(3, nicheDepth));

      // Update display
      document.getElementById('propNicheDepthDisplay').textContent = formatDimension(selectedElement.nicheDepth);

      saveUndoState();
      draw();
      update3DScene();
      showSnapFeedback(`Niche depth: ${Math.round(selectedElement.nicheDepth * 12)}" (${formatDimension(selectedElement.nicheDepth)})`);
    }

    // Update backsplash vertical height
    function updateBacksplashHeight() {
      if (!selectedElement || selectedElement.type !== 'backsplash') return;

      const select = document.getElementById('propBacksplashHeight');
      const value = select.value;
      const customRow = document.getElementById('customBacksplashHeightRow');

      if (value === 'custom') {
        if (customRow) {
          customRow.style.display = 'flex';
          const currentHeight = selectedElement.verticalHeight || 1.5;
          document.getElementById('propCustomBacksplashHeight').value = Math.round(currentHeight * 12);
          document.getElementById('propBacksplashHeightDisplay').textContent = formatDimension(currentHeight);
        }
        return;
      }

      if (customRow) customRow.style.display = 'none';

      const heightFt = parseFloat(value);
      selectedElement.verticalHeight = heightFt;

      // Convert to inches for display
      const heightInches = Math.round(heightFt * 12);
      let heightLabel = heightInches + '"';
      if (heightInches === 4) heightLabel = '4" (Standard)';
      else if (heightInches === 6) heightLabel = '6" (Raised)';
      else if (heightInches === 12) heightLabel = '12" (Half Height)';
      else if (heightInches === 18) heightLabel = '18" (Full)';

      markElement3DDirty(selectedElement.id);
      saveUndoState();
      draw();
      update3DScene();
      showSnapFeedback(`Backsplash height: ${heightLabel}`);
    }

    // Apply custom backsplash height
    function applyCustomBacksplashHeight() {
      if (!selectedElement || selectedElement.type !== 'backsplash') return;

      const input = document.getElementById('propCustomBacksplashHeight');
      const heightInches = parseFloat(input.value) || 18;

      // Clamp to reasonable values (2" to 24")
      const clampedInches = Math.max(2, Math.min(24, heightInches));
      selectedElement.verticalHeight = clampedInches / 12;

      // Update display
      document.getElementById('propBacksplashHeightDisplay').textContent = formatDimension(selectedElement.verticalHeight);

      markElement3DDirty(selectedElement.id);
      saveUndoState();
      draw();
      update3DScene();
      showSnapFeedback(`Backsplash height: ${clampedInches}"`);
    }

    // Update tile type for backsplash
    function updateTileType() {
      if (!selectedElement || selectedElement.type !== 'backsplash') return;

      const select = document.getElementById('propTileType');
      selectedElement.tileType = select.value;

      const tileLabels = {
        'standard': 'Standard 4"4"',
        'subway': 'Subway 3"6"',
        'mosaic': 'Mosaic 1"1"',
        'herringbone': 'Herringbone',
        'chevron': 'Chevron',
        'hexagon': 'Hexagon'
      };

      markElement3DDirty(selectedElement.id);
      saveUndoState();
      draw();
      update3DScene();
      showSnapFeedback(`Tile pattern: ${tileLabels[selectedElement.tileType] || selectedElement.tileType}`);
    }

    // Update stone surface thickness
    function updateStoneThickness() {
      if (!selectedElement) return;

      const select = document.getElementById('propStoneThickness');
      const thickness = parseFloat(select.value);

      selectedElement.stoneThickness = thickness;

      // Convert to inches for display
      const thicknessInches = thickness * 12;
      let thicknessLabel = '';
      if (Math.abs(thicknessInches - 0.75) < 0.1) thicknessLabel = '3/4" (2cm)';
      else if (Math.abs(thicknessInches - 1.25) < 0.1) thicknessLabel = '1.25" (3cm)';
      else if (Math.abs(thicknessInches - 1.5) < 0.1) thicknessLabel = '1.5"';
      else if (Math.abs(thicknessInches - 2) < 0.2) thicknessLabel = '2"';
      else if (Math.abs(thicknessInches - 3) < 0.2) thicknessLabel = '3"';
      else thicknessLabel = thicknessInches.toFixed(1) + '"';

      saveUndoState();
      draw();
      update3DScene();
      showSnapFeedback(`Stone thickness: ${thicknessLabel}`);
    }

    // Update cap height for wall caps and bar tops
    function updateCapHeight() {
      if (!selectedElement) return;

      const select = document.getElementById('propCapHeight');
      const value = select.value;
      const customRow = document.getElementById('customCapHeightRow');

      if (value === 'custom') {
        if (customRow) {
          customRow.style.display = 'flex';
          const currentHeight = selectedElement.capHeight || 3.5;
          document.getElementById('propCustomCapHeight').value = currentHeight.toFixed(2);
          document.getElementById('propCapHeightDisplay').textContent = formatDimension(currentHeight);
        }
        return;
      }

      if (customRow) customRow.style.display = 'none';

      const capHeight = parseFloat(value);
      selectedElement.capHeight = capHeight;

      saveUndoState();
      draw();
      update3DScene();
      showSnapFeedback(`Cap height: ${formatDimension(capHeight)} (${Math.round(capHeight * 12)}")`);
    }

    // Apply custom cap height
    function applyCustomCapHeight() {
      if (!selectedElement) return;

      const input = document.getElementById('propCustomCapHeight');
      const capHeight = parseFloat(input.value) || 3;

      selectedElement.capHeight = Math.max(0.5, Math.min(8, capHeight));

      // Update display
      document.getElementById('propCapHeightDisplay').textContent = formatDimension(selectedElement.capHeight);

      saveUndoState();
      draw();
      update3DScene();
      showSnapFeedback(`Cap height: ${formatDimension(selectedElement.capHeight)} (${Math.round(selectedElement.capHeight * 12)}")`);
    }

    // Update edge profile for selected countertop (from properties panel)
    function updateSelectedEdgeProfile() {
      const countertopTypes = ['countertop', 'countertop-corner', 'countertop-l', 'countertop-u', 'island'];
      if (!selectedElement || !countertopTypes.includes(selectedElement.type)) return;

      const profile = document.getElementById('propEdgeProfile').value;
      selectedElement.edgeProfile = profile;

      // Show edge profile durability info
      const edgeInfo = FABRICATION_STANDARDS.edgeDurability[profile];
      const infoDiv = document.getElementById('edgeProfileInfo');
      const infoRow = document.getElementById('edgeProfileInfoRow');

      if (infoDiv && infoRow && edgeInfo) {
        const stars = ''.repeat(edgeInfo.rating) + ''.repeat(5 - edgeInfo.rating);
        infoDiv.innerHTML = `<strong>Durability:</strong> ${stars}<br><strong>Chip Resistance:</strong> ${edgeInfo.chipResistance}<br>${edgeInfo.notes}`;
        infoRow.style.display = 'block';
      } else if (infoRow) {
        infoRow.style.display = 'none';
      }

      // Waterfall sides are now independent of edge profile - don't clear them
      // Edge profile only affects the visible edge shape (bullnose, ogee, etc.)

      update3DScene();
      calculateQuote();
      showSnapFeedback(`Edge profile: ${profile}`);
    }

    // Update countertop thickness (2cm vs 3cm)
    function updateCountertopThickness() {
      const countertopTypes = ['countertop', 'countertop-corner', 'countertop-l', 'countertop-u', 'island'];
      if (!selectedElement || !countertopTypes.includes(selectedElement.type)) return;

      const thickness = document.getElementById('propThickness').value;
      const edgeStyle = document.getElementById('propEdgeStyle').value;

      selectedElement.thickness = thickness;
      selectedElement.edgeBuildStyle = thickness === '2cm' ? edgeStyle : null;

      // Show/hide edge style row based on thickness
      const edgeStyleRow = document.getElementById('edgeStyleRow');
      if (edgeStyleRow) {
        edgeStyleRow.style.display = thickness === '2cm' ? 'flex' : 'none';
      }

      update3DScene();
      calculateQuote();

      if (thickness === '2cm') {
        showSnapFeedback(`2cm thickness with ${edgeStyle} edge build`);
      } else {
        showSnapFeedback(`3cm thickness (standard)`);
      }
    }

    // Update backsplash height for countertops
    function updateBacksplash() {
      if (!selectedElement || selectedElement.type !== 'countertop') return;

      const value = document.getElementById('propBacksplash').value;
      if (value === 'none') {
        selectedElement.backsplash = null;
      } else if (value === 'full') {
        selectedElement.backsplash = { height: 18, type: 'full' }; // Full height to upper cabinets
      } else {
        selectedElement.backsplash = { height: parseInt(value), type: 'standard' };
      }
      update3DScene();
      calculateQuote();
      showSnapFeedback(`Backsplash: ${value === 'none' ? 'None' : value + '"'}`);
    }

    // Update finished ends for countertops
    function updateFinishedEnds() {
      if (!selectedElement || selectedElement.type !== 'countertop') return;

      const ends = [];
      if (document.getElementById('propFinishedLeft').checked) ends.push('left');
      if (document.getElementById('propFinishedRight').checked) ends.push('right');
      selectedElement.finishedEnds = ends.length > 0 ? ends : null;
      update3DScene();
      calculateQuote();
    }

    // Update waterfall sides (which sides get waterfall treatment)
    function updateWaterfallSides() {
      const countertopTypes = ['countertop', 'countertop-corner', 'countertop-l', 'countertop-u', 'island'];
      if (!selectedElement || !countertopTypes.includes(selectedElement.type)) return;

      const waterfallSides = [];
      if (document.getElementById('propWaterfallLeft')?.checked) waterfallSides.push('left');
      if (document.getElementById('propWaterfallRight')?.checked) waterfallSides.push('right');
      if (document.getElementById('propWaterfallFront')?.checked) waterfallSides.push('front');
      if (document.getElementById('propWaterfallBack')?.checked) waterfallSides.push('back');

      selectedElement.waterfallSides = waterfallSides.length > 0 ? waterfallSides : null;

      // If any waterfall sides are enabled, ensure waterfall height row is visible
      const waterfallHeightRow = document.getElementById('waterfallHeightRow');
      if (waterfallHeightRow) {
        waterfallHeightRow.style.display = waterfallSides.length > 0 ? 'flex' : 'none';
      }

      update3DScene();
      calculateQuote();

      if (waterfallSides.length > 0) {
        showSnapFeedback(`Waterfall sides: ${waterfallSides.join(', ')}`);
      }
    }

    // Update waterfall drop height
    function updateWaterfallHeight() {
      const countertopTypes = ['countertop', 'countertop-corner', 'countertop-l', 'countertop-u', 'island'];
      if (!selectedElement || !countertopTypes.includes(selectedElement.type)) return;

      const value = document.getElementById('propWaterfallHeight')?.value;

      if (value === 'floor') {
        // Calculate height to floor from counter
        selectedElement.waterfallHeight = 'floor';
        selectedElement.waterfallDropFeet = 3; // Default counter height
      } else if (value === 'custom') {
        const customHeight = prompt('Enter waterfall drop height in feet:', '3');
        if (customHeight && !isNaN(parseFloat(customHeight))) {
          selectedElement.waterfallHeight = parseFloat(customHeight);
          selectedElement.waterfallDropFeet = parseFloat(customHeight);
        }
      } else {
        selectedElement.waterfallHeight = parseFloat(value);
        selectedElement.waterfallDropFeet = parseFloat(value);
      }

      update3DScene();
      calculateQuote();
      showSnapFeedback(`Waterfall drop: ${selectedElement.waterfallHeight === 'floor' ? 'To floor' : selectedElement.waterfallHeight + "'"}`);
    }

    // Fabrication guidelines based on Marble Institute of America standards
    const FABRICATION_STANDARDS = {
      overhang: {
        // Maximum unsupported overhang by thickness
        '2cm': { maxUnsupported: 6, bracketRequired: 6, plywoodRequired: true },
        '3cm': { maxUnsupported: 10, bracketRequired: 12, plywoodRequired: false }
      },
      // Maximum unsupported span (side-to-side between supports)
      maxSpan: {
        '2cm': 24, // inches
        '3cm': 36  // inches
      },
      // Seating overhang standards
      seating: {
        bar: { depth: 12, description: 'Standard bar seating' },
        breakfast: { depth: 15, description: 'Comfortable breakfast bar' },
        ada: { depth: 19, minKneeHeight: 27, description: 'ADA accessible' }
      },
      // The 1/3 rule: overhang should not exceed 1/3 of total countertop depth
      maxOverhangRatio: 1/3,
      // Minimum support: 2/3 of countertop must be supported
      minSupportRatio: 2/3,
      // Edge profile durability ratings (1-5, 5 being most durable)
      edgeDurability: {
        'eased': { rating: 4, chipResistance: 'Good', notes: 'Versatile, good for all stone types' },
        'pencil': { rating: 4, chipResistance: 'Good', notes: 'Small radius, practical' },
        'quarter-round': { rating: 4, chipResistance: 'Good', notes: 'Larger radius than pencil' },
        'half-bullnose': { rating: 5, chipResistance: 'Excellent', notes: 'Most practical choice, extremely chip resistant' },
        'full-bullnose': { rating: 5, chipResistance: 'Excellent', notes: 'Nearly indestructible' },
        'quarter-bevel': { rating: 4, chipResistance: 'Good', notes: 'Resistant to wear' },
        'ogee': { rating: 2, chipResistance: 'Low', notes: 'Decorative but prone to chipping' },
        'double-ogee': { rating: 2, chipResistance: 'Low', notes: 'Very decorative, not for high-traffic' },
        'dupont': { rating: 3, chipResistance: 'Moderate', notes: 'Complex profile, moderate durability' },
        'cove': { rating: 3, chipResistance: 'Moderate', notes: 'Concave curve traps moisture' },
        'mitered': { rating: 4, chipResistance: 'Good', notes: 'Clean modern look' },
        'waterfall': { rating: 4, chipResistance: 'Good', notes: 'Mitered for waterfall applications' }
      },
      // Seam placement rules
      seams: {
        // Standard slab dimensions (in inches)
        maxSlabWidth: 120,  // 10 feet
        maxSlabDepth: 60,   // 5 feet
        // Jumbo slab dimensions
        jumboSlabWidth: 130,
        jumboSlabDepth: 68,
        // Minimum distances for seam placement
        minFromEdge: 6,     // Minimum 6" from countertop edge
        minFromSink: 4,     // Minimum 4" from sink/cooktop cutout
        minFromCorner: 6,   // Minimum 6" from inside corners
        // Seam visibility preference zones (percentage from edge)
        preferredZone: { min: 0.25, max: 0.75 }, // Middle 50% is preferred
        // Types of elements to avoid seaming over
        avoidOver: ['sink', 'sink-double', 'sink-farmhouse', 'cooktop', 'range']
      },
      // Standard slab sizes available
      slabSizes: {
        standard: { width: 120, depth: 60, name: 'Standard (120"60")' },
        jumbo: { width: 130, depth: 68, name: 'Jumbo (130"68")' },
        compact: { width: 96, depth: 48, name: 'Compact (96"48")' }
      },
      // Cut waste allowance
      wasteAllowance: 0.15, // 15% waste factor for cuts
      // Minimum usable remnant size (sq in)
      minRemnantSize: 144, // 12"x12" minimum
      // Edge profile labor times (minutes per linear foot)
      edgeProfileLabor: {
        'eased': 2,
        'pencil': 3,
        'quarter-round': 4,
        'half-bullnose': 5,
        'full-bullnose': 6,
        'quarter-bevel': 3,
        'ogee': 8,
        'double-ogee': 12,
        'dupont': 10,
        'cove': 6,
        'mitered': 15,
        'waterfall': 20
      }
    };

    // ===== FABRICATION TOOLS MODULE =====

    // Slab inventory for layout optimization
    const SLAB_INVENTORY = {
      slabs: [],
      selectedSlab: null
    };

    // Generate fabrication plan for all countertops
    function generateFabricationPlan() {
      const countertopTypes = ['countertop', 'countertop-corner', 'countertop-l', 'countertop-u', 'island'];
      const countertops = elements.filter(el => countertopTypes.includes(el.type));

      if (countertops.length === 0) {
        showToast('No countertops found in design', 'warning');
        return null;
      }

      const plan = {
        timestamp: new Date().toISOString(),
        projectName: document.getElementById('projectName')?.value || 'Untitled',
        countertops: [],
        cutList: [],
        totalSqFt: 0,
        totalEdgeLF: 0,
        totalCutouts: [],
        slabsRequired: 0,
        estimatedWaste: 0,
        estimatedLaborHours: 0
      };

      countertops.forEach((ctop, idx) => {
        const widthIn = ctop.width * 12;
        const depthIn = ctop.height * 12;
        const sqFt = (widthIn * depthIn) / 144;
        const edgeLF = calculateEdgeLinearFeet(ctop);

        const piece = {
          id: ctop.id,
          label: ctop.label || `Countertop ${idx + 1}`,
          type: ctop.type,
          dimensions: {
            width: widthIn,
            depth: depthIn,
            widthFt: ctop.width,
            depthFt: ctop.height
          },
          sqFt: sqFt,
          edgeLF: edgeLF,
          edgeProfile: ctop.edgeProfile || 'eased',
          material: ctop.texture || ctop.materialName || 'TBD',
          thickness: ctop.thickness || '3cm',
          seams: ctop.seams || [],
          cutouts: [],
          specialInstructions: []
        };

        // Find cutouts (sinks, cooktops) on this countertop
        const cutoutTypes = ['sink', 'sink-double', 'sink-farmhouse', 'cooktop', 'range'];
        elements.forEach(el => {
          if (!cutoutTypes.includes(el.type)) return;

          // Check if element is on this countertop
          const elCenterX = el.x + (el.width * pixelsPerFoot) / 2;
          const elCenterY = el.y + (el.height * pixelsPerFoot) / 2;
          const ctopLeft = ctop.x;
          const ctopRight = ctop.x + ctop.width * pixelsPerFoot;
          const ctopTop = ctop.y;
          const ctopBottom = ctop.y + ctop.height * pixelsPerFoot;

          if (elCenterX >= ctopLeft && elCenterX <= ctopRight &&
              elCenterY >= ctopTop && elCenterY <= ctopBottom) {
            const cutout = {
              type: el.type,
              label: el.label,
              width: el.width * 12,
              depth: el.height * 12,
              position: {
                fromLeft: ((el.x - ctop.x) / pixelsPerFoot) * 12,
                fromBack: ((el.y - ctop.y) / pixelsPerFoot) * 12
              },
              mountType: el.mountType || 'undermount',
              cornerRadius: el.type.includes('sink') ? 0.5 : 0.25
            };
            piece.cutouts.push(cutout);
            plan.totalCutouts.push(cutout);
          }
        });

        // Calculate pieces from seams
        if (piece.seams.length > 0) {
          let lastPos = 0;
          piece.seams.forEach((seam, sIdx) => {
            const pieceWidth = (seam.position - lastPos) * widthIn;
            plan.cutList.push({
              countertopId: ctop.id,
              countertopLabel: piece.label,
              pieceNumber: sIdx + 1,
              width: pieceWidth,
              depth: depthIn,
              sqFt: (pieceWidth * depthIn) / 144,
              seamLeft: sIdx > 0,
              seamRight: true,
              edgeProfile: piece.edgeProfile
            });
            lastPos = seam.position;
          });
          // Last piece
          const lastPieceWidth = (1 - lastPos) * widthIn;
          plan.cutList.push({
            countertopId: ctop.id,
            countertopLabel: piece.label,
            pieceNumber: piece.seams.length + 1,
            width: lastPieceWidth,
            depth: depthIn,
            sqFt: (lastPieceWidth * depthIn) / 144,
            seamLeft: true,
            seamRight: false,
            edgeProfile: piece.edgeProfile
          });
        } else {
          // Single piece
          plan.cutList.push({
            countertopId: ctop.id,
            countertopLabel: piece.label,
            pieceNumber: 1,
            width: widthIn,
            depth: depthIn,
            sqFt: sqFt,
            seamLeft: false,
            seamRight: false,
            edgeProfile: piece.edgeProfile
          });
        }

        plan.countertops.push(piece);
        plan.totalSqFt += sqFt;
        plan.totalEdgeLF += edgeLF;
      });

      // Calculate slabs required
      const slabSize = FABRICATION_STANDARDS.slabSizes.standard;
      const slabSqFt = (slabSize.width * slabSize.depth) / 144;
      const effectiveSqFt = plan.totalSqFt * (1 + FABRICATION_STANDARDS.wasteAllowance);
      plan.slabsRequired = Math.ceil(effectiveSqFt / slabSqFt);
      plan.estimatedWaste = effectiveSqFt - plan.totalSqFt;

      // Calculate labor hours
      plan.cutList.forEach(piece => {
        const edgeLabor = FABRICATION_STANDARDS.edgeProfileLabor[piece.edgeProfile] || 3;
        const edgeLF = (piece.width + piece.depth * 2) / 12; // Front + sides
        plan.estimatedLaborHours += (edgeLF * edgeLabor) / 60;
      });
      plan.totalCutouts.forEach(cutout => {
        plan.estimatedLaborHours += cutout.type.includes('sink') ? 0.75 : 0.5;
      });

      return plan;
    }

    // Calculate edge linear feet for a countertop
    function calculateEdgeLinearFeet(ctop) {
      const widthIn = ctop.width * 12;
      const depthIn = ctop.height * 12;

      // Default: front edge + both side edges
      let edgeLF = (widthIn + depthIn * 2) / 12;

      // Adjust for L-shaped
      if (ctop.type === 'countertop-l') {
        const armWidth = (ctop.armWidth || 2.17) * 12;
        edgeLF = (widthIn + depthIn + armWidth * 2) / 12;
      }

      return edgeLF;
    }

    // Generate slab layout visualization
    function generateSlabLayout(plan) {
      if (!plan) plan = generateFabricationPlan();
      if (!plan) return null;

      const slabSize = FABRICATION_STANDARDS.slabSizes.standard;
      const layouts = [];
      let currentSlab = {
        number: 1,
        pieces: [],
        usedArea: 0,
        remainingArea: slabSize.width * slabSize.depth
      };

      // Simple bin packing algorithm
      plan.cutList.forEach(piece => {
        const pieceArea = piece.width * piece.depth;

        // Check if piece fits in current slab
        if (pieceArea <= currentSlab.remainingArea) {
          currentSlab.pieces.push(piece);
          currentSlab.usedArea += pieceArea;
          currentSlab.remainingArea -= pieceArea;
        } else {
          // Start new slab
          layouts.push(currentSlab);
          currentSlab = {
            number: layouts.length + 2,
            pieces: [piece],
            usedArea: pieceArea,
            remainingArea: (slabSize.width * slabSize.depth) - pieceArea
          };
        }
      });

      // Add last slab
      if (currentSlab.pieces.length > 0) {
        layouts.push(currentSlab);
      }

      return {
        slabSize: slabSize,
        layouts: layouts,
        totalSlabs: layouts.length,
        avgUtilization: layouts.reduce((sum, s) => sum + (s.usedArea / (slabSize.width * slabSize.depth)), 0) / layouts.length
      };
    }

    // Show fabrication plan modal
    function showFabricationPlan() {
      const plan = generateFabricationPlan();
      if (!plan) return;

      const slabLayout = generateSlabLayout(plan);

      const modal = document.createElement('div');
      modal.className = 'fabrication-plan-modal';
      modal.innerHTML = `
        <div class="fabrication-plan-content">
          <div class="fabrication-plan-header">
            <h3>Fabrication Plan - ${plan.projectName}</h3>
            <button onclick="this.closest('.fabrication-plan-modal').remove()"></button>
          </div>
          <div class="fabrication-plan-body">
            <div class="fab-summary">
              <div class="fab-stat">
                <span class="fab-value">${plan.totalSqFt.toFixed(1)}</span>
                <span class="fab-label">Total Sq Ft</span>
              </div>
              <div class="fab-stat">
                <span class="fab-value">${plan.totalEdgeLF.toFixed(1)}</span>
                <span class="fab-label">Edge LF</span>
              </div>
              <div class="fab-stat">
                <span class="fab-value">${plan.slabsRequired}</span>
                <span class="fab-label">Slabs Required</span>
              </div>
              <div class="fab-stat">
                <span class="fab-value">${plan.totalCutouts.length}</span>
                <span class="fab-label">Cutouts</span>
              </div>
              <div class="fab-stat">
                <span class="fab-value">${plan.estimatedLaborHours.toFixed(1)}h</span>
                <span class="fab-label">Est. Labor</span>
              </div>
            </div>

            <div class="fab-section">
              <h4>Cut List</h4>
              <table class="fab-table">
                <thead>
                  <tr>
                    <th>Piece</th>
                    <th>Dimensions</th>
                    <th>Sq Ft</th>
                    <th>Seams</th>
                    <th>Edge</th>
                  </tr>
                </thead>
                <tbody>
                  ${plan.cutList.map(p => `
                    <tr>
                      <td>${p.countertopLabel} #${p.pieceNumber}</td>
                      <td>${p.width.toFixed(1)}"  ${p.depth.toFixed(1)}"</td>
                      <td>${p.sqFt.toFixed(2)}</td>
                      <td>${p.seamLeft ? 'L' : ''}${p.seamRight ? 'R' : ''}${!p.seamLeft && !p.seamRight ? '-' : ''}</td>
                      <td>${p.edgeProfile}</td>
                    </tr>
                  `).join('')}
                </tbody>
              </table>
            </div>

            ${plan.totalCutouts.length > 0 ? `
              <div class="fab-section">
                <h4>Cutouts</h4>
                <table class="fab-table">
                  <thead>
                    <tr>
                      <th>Type</th>
                      <th>Size</th>
                      <th>Position</th>
                      <th>Mount</th>
                    </tr>
                  </thead>
                  <tbody>
                    ${plan.totalCutouts.map(c => `
                      <tr>
                        <td>${c.label || c.type}</td>
                        <td>${c.width.toFixed(1)}"  ${c.depth.toFixed(1)}"</td>
                        <td>${c.position.fromLeft.toFixed(1)}" from left, ${c.position.fromBack.toFixed(1)}" from back</td>
                        <td>${c.mountType}</td>
                      </tr>
                    `).join('')}
                  </tbody>
                </table>
              </div>
            ` : ''}

            <div class="fab-section">
              <h4>Slab Layout (${slabLayout.totalSlabs} slab${slabLayout.totalSlabs > 1 ? 's' : ''})</h4>
              <div class="slab-layouts">
                ${slabLayout.layouts.map(slab => `
                  <div class="slab-preview">
                    <div class="slab-header">Slab #${slab.number} - ${((slab.usedArea / (slabLayout.slabSize.width * slabLayout.slabSize.depth)) * 100).toFixed(0)}% utilized</div>
                    <div class="slab-diagram" style="aspect-ratio: ${slabLayout.slabSize.width}/${slabLayout.slabSize.depth};">
                      ${slab.pieces.map((p, i) => `
                        <div class="slab-piece" style="width: ${(p.width / slabLayout.slabSize.width) * 100}%; height: ${(p.depth / slabLayout.slabSize.depth) * 100}%;" title="${p.countertopLabel} #${p.pieceNumber}">
                          <span>${p.pieceNumber}</span>
                        </div>
                      `).join('')}
                    </div>
                  </div>
                `).join('')}
              </div>
              <div class="fab-note">Avg utilization: ${(slabLayout.avgUtilization * 100).toFixed(0)}%</div>
            </div>
          </div>
          <div class="fabrication-plan-footer">
            <button onclick="exportFabricationPlan()" class="fab-export-btn">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="16" height="16">
                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                <polyline points="7 10 12 15 17 10"/>
                <line x1="12" y1="15" x2="12" y2="3"/>
              </svg>
              Export PDF
            </button>
            <button onclick="copyFabricationPlan()" class="fab-copy-btn">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="16" height="16">
                <rect x="9" y="9" width="13" height="13" rx="2" ry="2"/>
                <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/>
              </svg>
              Copy to Clipboard
            </button>
          </div>
        </div>
      `;

      document.body.appendChild(modal);
    }

    // Export fabrication plan as text
    function copyFabricationPlan() {
      const plan = generateFabricationPlan();
      if (!plan) return;

      let text = `FABRICATION PLAN - ${plan.projectName}\n`;
      text += `Generated: ${new Date().toLocaleString()}\n`;
      text += `${'='.repeat(50)}\n\n`;

      text += `SUMMARY\n`;
      text += `-`.repeat(30) + `\n`;
      text += `Total Square Feet: ${plan.totalSqFt.toFixed(2)} sq ft\n`;
      text += `Edge Linear Feet: ${plan.totalEdgeLF.toFixed(2)} LF\n`;
      text += `Slabs Required: ${plan.slabsRequired}\n`;
      text += `Total Cutouts: ${plan.totalCutouts.length}\n`;
      text += `Est. Labor Hours: ${plan.estimatedLaborHours.toFixed(1)}\n\n`;

      text += `CUT LIST\n`;
      text += `-`.repeat(30) + `\n`;
      plan.cutList.forEach(p => {
        text += `${p.countertopLabel} #${p.pieceNumber}: ${p.width.toFixed(1)}"  ${p.depth.toFixed(1)}" (${p.sqFt.toFixed(2)} sq ft)\n`;
        text += `  Edge: ${p.edgeProfile}, Seams: ${p.seamLeft ? 'Left ' : ''}${p.seamRight ? 'Right' : ''}${!p.seamLeft && !p.seamRight ? 'None' : ''}\n`;
      });

      if (plan.totalCutouts.length > 0) {
        text += `\nCUTOUTS\n`;
        text += `-`.repeat(30) + `\n`;
        plan.totalCutouts.forEach(c => {
          text += `${c.label || c.type}: ${c.width.toFixed(1)}"  ${c.depth.toFixed(1)}" (${c.mountType})\n`;
          text += `  Position: ${c.position.fromLeft.toFixed(1)}" from left, ${c.position.fromBack.toFixed(1)}" from back\n`;
        });
      }

      navigator.clipboard.writeText(text).then(() => {
        showToast('Fabrication plan copied to clipboard', 'success');
      });
    }

    // ===== INTERACTIVE SLAB LAYOUT MODAL =====
    // CounterGo-style slab layout interface for drag-and-drop piece arrangement
    function showSlabLayoutModal() {
      // Try to get countertops from design, but don't require them
      const plan = generateFabricationPlan();
      const hasDesignPieces = plan && plan.cutList && plan.cutList.length > 0;

      const slabSizes = FABRICATION_STANDARDS.slabSizes;
      let currentSlabSize = slabSizes.standard;
      let pieceCounter = 0;

      // Initialize pieces from design or start empty
      let pieces = hasDesignPieces ? plan.cutList.map((p, i) => ({
        ...p,
        id: `piece-${pieceCounter++}`,
        x: 10 + (i % 3) * 35,
        y: 10 + Math.floor(i / 3) * 25,
        rotation: 0,
        slabNumber: null
      })) : [];

      const modal = document.createElement('div');
      modal.className = 'fabrication-plan-modal';
      modal.style.cssText = 'position: fixed; inset: 0; background: rgba(0,0,0,0.9); z-index: 10000; display: flex; align-items: center; justify-content: center;';
      modal.innerHTML = `
        <div style="background: var(--dark-surface, #1a1a2e); border-radius: 12px; width: 95vw; max-width: 1400px; max-height: 90vh; display: flex; flex-direction: column; border: 1px solid rgba(255,255,255,0.1);">
          <div style="display: flex; justify-content: space-between; align-items: center; padding: 16px 20px; border-bottom: 1px solid rgba(255,255,255,0.1);">
            <div style="display: flex; align-items: center; gap: 20px;">
              <h3 style="margin: 0; font-size: 18px; color: #fff;">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align: middle; margin-right: 8px;">
                  <rect x="2" y="2" width="20" height="20" rx="1"/>
                  <rect x="4" y="4" width="7" height="5" rx="0.5" fill="currentColor" opacity="0.3"/>
                  <rect x="13" y="4" width="7" height="8" rx="0.5" fill="currentColor" opacity="0.3"/>
                  <rect x="4" y="11" width="7" height="9" rx="0.5" fill="currentColor" opacity="0.3"/>
                </svg>
                Slab Layout Tool
              </h3>
              <select id="slabSizeSelect" style="padding: 6px 12px; border-radius: 6px; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.2); color: #fff; font-size: 13px;">
                <option value="standard">${slabSizes.standard.name} (${slabSizes.standard.width}"${slabSizes.standard.depth}")</option>
                <option value="jumbo">${slabSizes.jumbo.name} (${slabSizes.jumbo.width}"${slabSizes.jumbo.depth}")</option>
                <option value="compact">${slabSizes.compact.name} (${slabSizes.compact.width}"${slabSizes.compact.depth}")</option>
              </select>
              <span id="slabUtilization" style="font-size: 12px; color: rgba(255,255,255,0.6); padding: 4px 10px; background: rgba(0,0,0,0.2); border-radius: 4px;">Utilization: 0%</span>
            </div>
            <button onclick="this.closest('.fabrication-plan-modal').remove()" style="width: 32px; height: 32px; border-radius: 6px; background: rgba(255,255,255,0.1); border: none; color: #fff; font-size: 20px; cursor: pointer; transition: background 0.2s;" onmouseover="this.style.background='rgba(239,68,68,0.5)'" onmouseout="this.style.background='rgba(255,255,255,0.1)'"></button>
          </div>

          <div style="display: flex; flex: 1; overflow: hidden;">
            <!-- Slab Canvas -->
            <div style="flex: 1; padding: 20px; overflow: auto; background: rgba(0,0,0,0.2);">
              <div style="display: flex; flex-direction: column; gap: 20px;">
                <div id="slabContainer" style="position: relative; background: linear-gradient(135deg, #4a4a4a 0%, #3a3a3a 100%); border: 3px solid rgba(255,255,255,0.3); border-radius: 4px; box-shadow: inset 0 0 30px rgba(0,0,0,0.4), 0 4px 20px rgba(0,0,0,0.3); margin: 30px;">
                  <!-- Slab pieces will be rendered here -->
                </div>
                <div style="display: flex; gap: 10px; justify-content: center; flex-wrap: wrap;">
                  <button onclick="slabAutoArrange()" style="padding: 8px 16px; border-radius: 6px; background: rgba(34,197,94,0.3); border: 1px solid rgba(34,197,94,0.5); color: #fff; cursor: pointer; font-size: 13px; transition: all 0.2s;" onmouseover="this.style.background='rgba(34,197,94,0.5)'" onmouseout="this.style.background='rgba(34,197,94,0.3)'">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align: middle; margin-right: 4px;"><path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"/></svg>
                    Auto-Arrange
                  </button>
                  <button onclick="slabOptimize()" style="padding: 8px 16px; border-radius: 6px; background: rgba(99,102,241,0.3); border: 1px solid rgba(99,102,241,0.5); color: #fff; cursor: pointer; font-size: 13px; transition: all 0.2s;" onmouseover="this.style.background='rgba(99,102,241,0.5)'" onmouseout="this.style.background='rgba(99,102,241,0.3)'">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align: middle; margin-right: 4px;"><path d="M12 2v4M12 18v4M4.93 4.93l2.83 2.83M16.24 16.24l2.83 2.83M2 12h4M18 12h4M4.93 19.07l2.83-2.83M16.24 7.76l2.83-2.83"/></svg>
                    Optimize
                  </button>
                  <button onclick="slabReset()" style="padding: 8px 16px; border-radius: 6px; background: rgba(239,68,68,0.2); border: 1px solid rgba(239,68,68,0.3); color: #fff; cursor: pointer; font-size: 13px; transition: all 0.2s;" onmouseover="this.style.background='rgba(239,68,68,0.4)'" onmouseout="this.style.background='rgba(239,68,68,0.2)'">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align: middle; margin-right: 4px;"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/></svg>
                    Reset
                  </button>
                  <button onclick="slabClearAll()" style="padding: 8px 16px; border-radius: 6px; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.2); color: #fff; cursor: pointer; font-size: 13px; transition: all 0.2s;" onmouseover="this.style.background='rgba(255,255,255,0.1)'" onmouseout="this.style.background='rgba(255,255,255,0.05)'">
                    Clear All
                  </button>
                </div>
              </div>
            </div>

            <!-- Piece Library Panel -->
            <div style="width: 320px; border-left: 1px solid rgba(255,255,255,0.1); display: flex; flex-direction: column; overflow: hidden;">
              <!-- Add Piece Form -->
              <div style="padding: 16px; border-bottom: 1px solid rgba(255,255,255,0.1); background: rgba(0,0,0,0.1);">
                <h4 style="margin: 0 0 12px; font-size: 14px; color: rgba(255,255,255,0.9); display: flex; align-items: center; gap: 8px;">
                  <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><path d="M12 8v8M8 12h8"/></svg>
                  Add New Piece
                </h4>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 10px;">
                  <div>
                    <label style="font-size: 11px; color: rgba(255,255,255,0.5); display: block; margin-bottom: 4px;">Width (inches)</label>
                    <input type="number" id="newPieceWidth" value="36" min="1" max="200" style="width: 100%; padding: 8px; border-radius: 6px; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.2); color: #fff; font-size: 14px;">
                  </div>
                  <div>
                    <label style="font-size: 11px; color: rgba(255,255,255,0.5); display: block; margin-bottom: 4px;">Depth (inches)</label>
                    <input type="number" id="newPieceDepth" value="26" min="1" max="200" style="width: 100%; padding: 8px; border-radius: 6px; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.2); color: #fff; font-size: 14px;">
                  </div>
                </div>
                <div style="margin-bottom: 10px;">
                  <label style="font-size: 11px; color: rgba(255,255,255,0.5); display: block; margin-bottom: 4px;">Label (optional)</label>
                  <input type="text" id="newPieceLabel" placeholder="e.g., Kitchen Island" style="width: 100%; padding: 8px; border-radius: 6px; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.2); color: #fff; font-size: 13px; box-sizing: border-box;">
                </div>
                <div style="display: flex; gap: 8px;">
                  <button onclick="slabAddPiece()" style="flex: 1; padding: 10px; border-radius: 6px; background: linear-gradient(135deg, #6366f1, #8b5cf6); border: none; color: #fff; font-weight: 500; cursor: pointer; font-size: 13px; transition: transform 0.1s;" onmousedown="this.style.transform='scale(0.98)'" onmouseup="this.style.transform='scale(1)'">
                    + Add Piece
                  </button>
                  <button onclick="slabImportFromDesign()" style="padding: 10px 14px; border-radius: 6px; background: rgba(245,158,11,0.3); border: 1px solid rgba(245,158,11,0.5); color: #fff; cursor: pointer; font-size: 13px;" title="Import countertops from room design">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>
                  </button>
                </div>
              </div>

              <!-- Piece List -->
              <div style="flex: 1; overflow-y: auto; padding: 16px;">
                <h4 style="margin: 0 0 12px; font-size: 14px; color: rgba(255,255,255,0.8); display: flex; justify-content: space-between; align-items: center;">
                  Cut Pieces
                  <span id="pieceCount" style="font-size: 12px; color: rgba(255,255,255,0.5); font-weight: normal;">0 pieces</span>
                </h4>
                <div id="pieceLibrary" style="display: flex; flex-direction: column; gap: 8px;">
                  <!-- Pieces will be rendered here -->
                </div>
                <div id="emptyPieceMessage" style="text-align: center; padding: 30px 20px; color: rgba(255,255,255,0.4); font-size: 13px; ${pieces.length > 0 ? 'display: none;' : ''}">
                  <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1" style="margin-bottom: 12px; opacity: 0.5;"><rect x="2" y="2" width="20" height="20" rx="2"/><path d="M12 8v8M8 12h8"/></svg>
                  <div>No pieces yet</div>
                  <div style="font-size: 11px; margin-top: 4px;">Add pieces manually or import from your design</div>
                </div>
              </div>

              <!-- Stats -->
              <div style="padding: 16px; border-top: 1px solid rgba(255,255,255,0.1); background: rgba(0,0,0,0.1);">
                <div id="layoutStats" style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; font-size: 12px;">
                  <div style="background: rgba(255,255,255,0.05); padding: 10px; border-radius: 6px; text-align: center;">
                    <div style="color: rgba(255,255,255,0.5); margin-bottom: 4px;">Total Sq Ft</div>
                    <div id="totalSqFt" style="color: #fff; font-size: 18px; font-weight: 600;">0</div>
                  </div>
                  <div style="background: rgba(255,255,255,0.05); padding: 10px; border-radius: 6px; text-align: center;">
                    <div style="color: rgba(255,255,255,0.5); margin-bottom: 4px;">Waste</div>
                    <div id="wastePercent" style="color: #fff; font-size: 18px; font-weight: 600;">0%</div>
                  </div>
                </div>
              </div>
            </div>
          </div>

          <div style="padding: 12px 20px; border-top: 1px solid rgba(255,255,255,0.1); display: flex; justify-content: space-between; align-items: center;">
            <div style="display: flex; gap: 16px; align-items: center;">
              <span style="font-size: 11px; color: rgba(255,255,255,0.5);">
                <strong>Drag</strong> pieces to position  <strong>Double-click</strong> to rotate  <strong>Right-click</strong> to delete
              </span>
            </div>
            <div style="display: flex; gap: 10px;">
              <button onclick="slabExportPDF()" style="padding: 8px 16px; border-radius: 6px; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); color: #fff; cursor: pointer; font-size: 13px;">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align: middle; margin-right: 4px;"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><polyline points="14 2 14 8 20 8"/></svg>
                Export
              </button>
              <button onclick="slabSaveLayout()" style="padding: 8px 20px; border-radius: 6px; background: linear-gradient(135deg, #22c55e, #16a34a); border: none; color: #fff; font-weight: 500; cursor: pointer; font-size: 13px;">
                Save Layout
              </button>
            </div>
          </div>
        </div>
      `;

      document.body.appendChild(modal);

      // Initialize the slab canvas
      const slabContainer = modal.querySelector('#slabContainer');
      const slabSelect = modal.querySelector('#slabSizeSelect');
      let scale = 5; // pixels per inch

      function renderPieceLibrary() {
        const library = modal.querySelector('#pieceLibrary');
        const emptyMsg = modal.querySelector('#emptyPieceMessage');
        const countEl = modal.querySelector('#pieceCount');

        countEl.textContent = pieces.length + ' piece' + (pieces.length !== 1 ? 's' : '');
        emptyMsg.style.display = pieces.length === 0 ? 'block' : 'none';

        library.innerHTML = pieces.map(p => `
          <div class="layout-piece-card" data-piece-id="${p.id}" draggable="true" style="padding: 10px; background: ${p.slabNumber ? 'rgba(34,197,94,0.15)' : 'rgba(255,255,255,0.05)'}; border: 1px solid ${p.slabNumber ? 'rgba(34,197,94,0.4)' : 'rgba(255,255,255,0.1)'}; border-radius: 6px; cursor: move; transition: all 0.2s;">
            <div style="display: flex; justify-content: space-between; align-items: start;">
              <div>
                <div style="font-weight: 500; font-size: 13px; color: #fff;">${p.label || p.countertopLabel || 'Piece'} #${p.pieceNumber || pieces.indexOf(p) + 1}</div>
                <div style="font-size: 12px; color: rgba(255,255,255,0.7); margin-top: 4px;">${p.width.toFixed(1)}"  ${p.depth.toFixed(1)}"</div>
                <div style="font-size: 11px; color: rgba(255,255,255,0.5); margin-top: 2px;">${((p.width * p.depth) / 144).toFixed(2)} sq ft</div>
              </div>
              <button onclick="slabRemovePiece('${p.id}')" style="width: 24px; height: 24px; border-radius: 4px; background: rgba(239,68,68,0.2); border: none; color: #ef4444; cursor: pointer; font-size: 14px;" title="Remove piece"></button>
            </div>
            ${p.slabNumber ? '<div style="font-size: 10px; color: #22c55e; margin-top: 6px;"> Placed on slab</div>' : '<div style="font-size: 10px; color: rgba(255,255,255,0.4); margin-top: 6px;">Drag to slab </div>'}
          </div>
        `).join('');

        // Re-attach drag handlers
        library.querySelectorAll('.layout-piece-card').forEach(card => {
          card.addEventListener('dragstart', (e) => {
            e.dataTransfer.setData('text/plain', card.dataset.pieceId);
            card.style.opacity = '0.5';
          });
          card.addEventListener('dragend', () => {
            card.style.opacity = '1';
          });
        });

        updateStats();
      }

      function renderSlab() {
        const size = slabSizes[slabSelect.value];
        currentSlabSize = size;
        const containerWidth = size.width * scale;
        const containerHeight = size.depth * scale;

        slabContainer.style.width = containerWidth + 'px';
        slabContainer.style.height = containerHeight + 'px';
        slabContainer.innerHTML = '';

        // Draw grid
        const gridSize = 12 * scale; // 12" grid
        for (let x = gridSize; x < containerWidth; x += gridSize) {
          const line = document.createElement('div');
          line.style.cssText = `position: absolute; width: 1px; height: 100%; background: rgba(255,255,255,${x % (24 * scale) === 0 ? '0.1' : '0.05'}); pointer-events: none;`;
          line.style.left = x + 'px';
          slabContainer.appendChild(line);
        }
        for (let y = gridSize; y < containerHeight; y += gridSize) {
          const line = document.createElement('div');
          line.style.cssText = `position: absolute; width: 100%; height: 1px; background: rgba(255,255,255,${y % (24 * scale) === 0 ? '0.1' : '0.05'}); pointer-events: none;`;
          line.style.top = y + 'px';
          slabContainer.appendChild(line);
        }

        // Render dimension labels
        const widthLabel = document.createElement('div');
        widthLabel.style.cssText = 'position: absolute; bottom: -25px; left: 50%; transform: translateX(-50%); font-size: 12px; color: rgba(255,255,255,0.6); font-weight: 500;';
        widthLabel.textContent = size.width + '"';
        slabContainer.appendChild(widthLabel);

        const heightLabel = document.createElement('div');
        heightLabel.style.cssText = 'position: absolute; right: -35px; top: 50%; transform: translateY(-50%) rotate(90deg); font-size: 12px; color: rgba(255,255,255,0.6); font-weight: 500;';
        heightLabel.textContent = size.depth + '"';
        slabContainer.appendChild(heightLabel);

        // Render placed pieces
        pieces.filter(p => p.slabNumber === 1).forEach(piece => {
          const pieceEl = createPieceElement(piece);
          slabContainer.appendChild(pieceEl);
        });

        updateStats();
      }

      function createPieceElement(piece) {
        const el = document.createElement('div');
        const w = piece.rotation % 180 === 0 ? piece.width : piece.depth;
        const h = piece.rotation % 180 === 0 ? piece.depth : piece.width;

        el.dataset.pieceId = piece.id;
        el.style.cssText = `
          position: absolute;
          left: ${piece.x}px;
          top: ${piece.y}px;
          width: ${w * scale}px;
          height: ${h * scale}px;
          background: linear-gradient(135deg, rgba(99, 102, 241, 0.7), rgba(139, 92, 246, 0.7));
          border: 2px solid #6366f1;
          border-radius: 3px;
          cursor: move;
          display: flex;
          align-items: center;
          justify-content: center;
          font-size: 10px;
          color: #fff;
          user-select: none;
          transition: box-shadow 0.2s, border-color 0.2s;
          box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        `;
        el.innerHTML = `<span style="text-shadow: 0 1px 3px rgba(0,0,0,0.7); text-align: center; line-height: 1.3;">${piece.label || 'Piece'}<br><strong>${w.toFixed(0)}${h.toFixed(0)}</strong></span>`;

        // Drag functionality
        let isDragging = false;
        let startX, startY, startPieceX, startPieceY;

        el.addEventListener('mousedown', (e) => {
          if (e.button === 2) return; // Right click
          isDragging = true;
          startX = e.clientX;
          startY = e.clientY;
          startPieceX = piece.x;
          startPieceY = piece.y;
          el.style.zIndex = '100';
          el.style.boxShadow = '0 8px 30px rgba(0,0,0,0.5)';
          el.style.transform = 'scale(1.02)';
        });

        const moveHandler = (e) => {
          if (!isDragging) return;
          const dx = e.clientX - startX;
          const dy = e.clientY - startY;
          piece.x = Math.max(0, Math.min(startPieceX + dx, currentSlabSize.width * scale - w * scale));
          piece.y = Math.max(0, Math.min(startPieceY + dy, currentSlabSize.depth * scale - h * scale));
          el.style.left = piece.x + 'px';
          el.style.top = piece.y + 'px';
          checkOverlap(el, piece);
        };

        const upHandler = () => {
          if (isDragging) {
            isDragging = false;
            el.style.zIndex = '';
            el.style.boxShadow = '0 2px 8px rgba(0,0,0,0.3)';
            el.style.transform = '';
            updateStats();
            document.removeEventListener('mousemove', moveHandler);
            document.removeEventListener('mouseup', upHandler);
          }
        };

        el.addEventListener('mousedown', () => {
          document.addEventListener('mousemove', moveHandler);
          document.addEventListener('mouseup', upHandler);
        });

        // Double-click to rotate
        el.addEventListener('dblclick', () => {
          piece.rotation = (piece.rotation + 90) % 360;
          renderSlab();
          renderPieceLibrary();
        });

        // Right-click to remove from slab
        el.addEventListener('contextmenu', (e) => {
          e.preventDefault();
          piece.slabNumber = null;
          piece.x = 10;
          piece.y = 10;
          renderSlab();
          renderPieceLibrary();
        });

        return el;
      }

      function checkOverlap(el, piece) {
        const w = piece.rotation % 180 === 0 ? piece.width : piece.depth;
        const h = piece.rotation % 180 === 0 ? piece.depth : piece.width;
        const rect1 = { x: piece.x, y: piece.y, w: w * scale, h: h * scale };

        let hasOverlap = false;
        pieces.filter(p => p.slabNumber === 1 && p.id !== piece.id).forEach(other => {
          const ow = other.rotation % 180 === 0 ? other.width : other.depth;
          const oh = other.rotation % 180 === 0 ? other.depth : other.width;
          const rect2 = { x: other.x, y: other.y, w: ow * scale, h: oh * scale };

          if (rect1.x < rect2.x + rect2.w && rect1.x + rect1.w > rect2.x &&
              rect1.y < rect2.y + rect2.h && rect1.y + rect1.h > rect2.y) {
            hasOverlap = true;
          }
        });

        el.style.background = hasOverlap
          ? 'linear-gradient(135deg, rgba(239, 68, 68, 0.7), rgba(220, 38, 38, 0.7))'
          : 'linear-gradient(135deg, rgba(34, 197, 94, 0.7), rgba(22, 163, 74, 0.7))';
        el.style.borderColor = hasOverlap ? '#ef4444' : '#22c55e';
      }

      function updateStats() {
        const slabArea = currentSlabSize.width * currentSlabSize.depth;
        const placedPieces = pieces.filter(p => p.slabNumber === 1);
        const usedArea = placedPieces.reduce((sum, p) => sum + p.width * p.depth, 0);
        const totalArea = pieces.reduce((sum, p) => sum + p.width * p.depth, 0);
        const utilization = slabArea > 0 ? ((usedArea / slabArea) * 100).toFixed(1) : 0;
        const waste = slabArea > 0 ? (100 - parseFloat(utilization)).toFixed(1) : 0;

        modal.querySelector('#slabUtilization').textContent = 'Utilization: ' + utilization + '%';
        modal.querySelector('#totalSqFt').textContent = (totalArea / 144).toFixed(1);
        modal.querySelector('#wastePercent').textContent = waste + '%';
      }

      // Drop zone for slab
      slabContainer.addEventListener('dragover', (e) => {
        e.preventDefault();
        slabContainer.style.borderColor = 'rgba(99,102,241,0.8)';
      });
      slabContainer.addEventListener('dragleave', () => {
        slabContainer.style.borderColor = 'rgba(255,255,255,0.3)';
      });
      slabContainer.addEventListener('drop', (e) => {
        e.preventDefault();
        slabContainer.style.borderColor = 'rgba(255,255,255,0.3)';
        const pieceId = e.dataTransfer.getData('text/plain');
        const piece = pieces.find(p => p.id === pieceId);
        if (piece && piece.slabNumber === null) {
          const rect = slabContainer.getBoundingClientRect();
          const w = piece.rotation % 180 === 0 ? piece.width : piece.depth;
          const h = piece.rotation % 180 === 0 ? piece.depth : piece.width;
          piece.x = Math.max(0, Math.min(e.clientX - rect.left - (w * scale / 2), currentSlabSize.width * scale - w * scale));
          piece.y = Math.max(0, Math.min(e.clientY - rect.top - (h * scale / 2), currentSlabSize.depth * scale - h * scale));
          piece.slabNumber = 1;
          renderSlab();
          renderPieceLibrary();
          showToast('Piece placed on slab', 'success');
        }
      });

      slabSelect.addEventListener('change', () => {
        renderSlab();
        renderPieceLibrary();
      });

      // Window functions for buttons
      window.slabAddPiece = () => {
        const width = parseFloat(modal.querySelector('#newPieceWidth').value) || 36;
        const depth = parseFloat(modal.querySelector('#newPieceDepth').value) || 26;
        const label = modal.querySelector('#newPieceLabel').value || `Piece ${pieces.length + 1}`;

        if (width < 1 || depth < 1 || width > 200 || depth > 200) {
          showToast('Invalid dimensions (1-200 inches)', 'error');
          return;
        }

        pieces.push({
          id: `piece-${pieceCounter++}`,
          width: width,
          depth: depth,
          label: label,
          pieceNumber: pieces.length + 1,
          x: 10,
          y: 10,
          rotation: 0,
          slabNumber: null,
          sqFt: (width * depth) / 144
        });

        modal.querySelector('#newPieceLabel').value = '';
        renderPieceLibrary();
        showToast(`Added ${label} (${width}"  ${depth}")`, 'success');
      };

      window.slabRemovePiece = (id) => {
        pieces = pieces.filter(p => p.id !== id);
        renderSlab();
        renderPieceLibrary();
      };

      window.slabImportFromDesign = () => {
        const plan = generateFabricationPlan();
        if (!plan || plan.cutList.length === 0) {
          showToast('No countertops in design to import', 'warning');
          return;
        }

        const newPieces = plan.cutList.map((p, i) => ({
          ...p,
          id: `piece-${pieceCounter++}`,
          label: p.countertopLabel || `Counter ${i + 1}`,
          x: 10,
          y: 10,
          rotation: 0,
          slabNumber: null
        }));

        pieces = [...pieces, ...newPieces];
        renderPieceLibrary();
        showToast(`Imported ${newPieces.length} pieces from design`, 'success');
      };

      window.slabAutoArrange = () => {
        if (pieces.length === 0) {
          showToast('Add pieces first', 'warning');
          return;
        }
        // Sort by area (largest first) for better packing
        const sortedPieces = [...pieces].sort((a, b) => (b.width * b.depth) - (a.width * a.depth));
        let x = 5, y = 5, rowHeight = 0;

        sortedPieces.forEach(p => {
          const w = p.width * scale;
          const h = p.depth * scale;
          if (x + w > currentSlabSize.width * scale - 5) {
            x = 5;
            y += rowHeight + 5;
            rowHeight = 0;
          }
          p.x = x;
          p.y = y;
          p.slabNumber = 1;
          p.rotation = 0;
          x += w + 5;
          rowHeight = Math.max(rowHeight, h);
        });

        renderSlab();
        renderPieceLibrary();
        showToast('Auto-arranged ' + pieces.length + ' pieces', 'success');
      };

      window.slabOptimize = () => {
        if (pieces.length === 0) {
          showToast('Add pieces first', 'warning');
          return;
        }
        // Try both orientations and pick better fit
        pieces.forEach(p => {
          const normalFit = p.width <= currentSlabSize.width && p.depth <= currentSlabSize.depth;
          const rotatedFit = p.depth <= currentSlabSize.width && p.width <= currentSlabSize.depth;

          if (!normalFit && rotatedFit) {
            p.rotation = 90;
          } else if (normalFit && rotatedFit) {
            // Choose orientation that wastes less
            const normalWaste = (currentSlabSize.width - p.width) + (currentSlabSize.depth - p.depth);
            const rotatedWaste = (currentSlabSize.width - p.depth) + (currentSlabSize.depth - p.width);
            p.rotation = rotatedWaste < normalWaste ? 90 : 0;
          }
        });

        window.slabAutoArrange();
        showToast('Optimized piece orientations', 'success');
      };

      window.slabReset = () => {
        pieces.forEach(p => {
          p.slabNumber = null;
          p.x = 10;
          p.y = 10;
          p.rotation = 0;
        });
        renderSlab();
        renderPieceLibrary();
        showToast('Layout reset', 'info');
      };

      window.slabClearAll = () => {
        if (pieces.length === 0) return;
        if (!confirm('Remove all pieces?')) return;
        pieces = [];
        pieceCounter = 0;
        renderSlab();
        renderPieceLibrary();
        showToast('All pieces cleared', 'info');
      };

      window.slabExportPDF = () => {
        showToast('Export feature coming soon!', 'info');
      };

      window.slabSaveLayout = () => {
        const placedCount = pieces.filter(p => p.slabNumber).length;
        showToast(`Layout saved! ${placedCount}/${pieces.length} pieces placed.`, 'success');
        modal.remove();
      };

      // Initial render
      renderSlab();
      renderPieceLibrary();
    }

    // Export fabrication plan as PDF (simplified - creates printable view)
    function exportFabricationPlan() {
      const plan = generateFabricationPlan();
      if (!plan) return;

      // Create printable window
      const printWindow = window.open('', '_blank');
      printWindow.document.write(`
        <!DOCTYPE html>
        <html>
        <head>
          <title>Fabrication Plan - ${plan.projectName}</title>
          <style>
            body { font-family: Arial, sans-serif; padding: 20px; max-width: 800px; margin: 0 auto; }
            h1 { font-size: 24px; border-bottom: 2px solid #333; padding-bottom: 10px; }
            h2 { font-size: 18px; color: #555; margin-top: 30px; }
            table { width: 100%; border-collapse: collapse; margin: 15px 0; }
            th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
            th { background: #f5f5f5; }
            .summary { display: flex; gap: 20px; flex-wrap: wrap; margin: 20px 0; }
            .stat { background: #f0f0f0; padding: 15px; border-radius: 8px; text-align: center; }
            .stat-value { font-size: 24px; font-weight: bold; color: #333; }
            .stat-label { font-size: 12px; color: #666; }
            @media print { body { padding: 0; } }
          </style>
        </head>
        <body>
          <h1>Fabrication Plan - ${plan.projectName}</h1>
          <p>Generated: ${new Date().toLocaleString()}</p>

          <div class="summary">
            <div class="stat"><div class="stat-value">${plan.totalSqFt.toFixed(1)}</div><div class="stat-label">Total Sq Ft</div></div>
            <div class="stat"><div class="stat-value">${plan.totalEdgeLF.toFixed(1)}</div><div class="stat-label">Edge LF</div></div>
            <div class="stat"><div class="stat-value">${plan.slabsRequired}</div><div class="stat-label">Slabs</div></div>
            <div class="stat"><div class="stat-value">${plan.totalCutouts.length}</div><div class="stat-label">Cutouts</div></div>
          </div>

          <h2>Cut List</h2>
          <table>
            <tr><th>Piece</th><th>Dimensions</th><th>Sq Ft</th><th>Seams</th><th>Edge Profile</th></tr>
            ${plan.cutList.map(p => `
              <tr>
                <td>${p.countertopLabel} #${p.pieceNumber}</td>
                <td>${p.width.toFixed(1)}"  ${p.depth.toFixed(1)}"</td>
                <td>${p.sqFt.toFixed(2)}</td>
                <td>${p.seamLeft ? 'L' : ''}${p.seamRight ? 'R' : ''}${!p.seamLeft && !p.seamRight ? '-' : ''}</td>
                <td>${p.edgeProfile}</td>
              </tr>
            `).join('')}
          </table>

          ${plan.totalCutouts.length > 0 ? `
            <h2>Cutouts</h2>
            <table>
              <tr><th>Type</th><th>Size</th><th>Position</th><th>Mount Type</th></tr>
              ${plan.totalCutouts.map(c => `
                <tr>
                  <td>${c.label || c.type}</td>
                  <td>${c.width.toFixed(1)}"  ${c.depth.toFixed(1)}"</td>
                  <td>${c.position.fromLeft.toFixed(1)}" left, ${c.position.fromBack.toFixed(1)}" back</td>
                  <td>${c.mountType}</td>
                </tr>
              `).join('')}
            </table>
          ` : ''}

          <script>window.print();<\/script>
        </body>
        </html>
      `);
    }

    // Check overhang and return warnings/requirements
    function validateOverhang(overhangInches, thickness = '3cm', countertopDepthInches = 25) {
      const standards = FABRICATION_STANDARDS.overhang[thickness] || FABRICATION_STANDARDS.overhang['3cm'];
      const warnings = [];
      const requirements = [];

      // Check max unsupported overhang
      if (overhangInches > standards.maxUnsupported) {
        requirements.push(`Support brackets required (>${standards.maxUnsupported}" for ${thickness})`);
      }

      // Check bracket requirement threshold
      if (overhangInches > standards.bracketRequired) {
        requirements.push(`Heavy-duty brackets needed every 18-24"`);
      }

      // Check 1/3 rule
      const maxByRule = countertopDepthInches * FABRICATION_STANDARDS.maxOverhangRatio;
      if (overhangInches > maxByRule) {
        warnings.push(`Exceeds 1/3 rule (max ${maxByRule.toFixed(1)}" for ${countertopDepthInches}" depth)`);
      }

      // 2cm specific requirements
      if (thickness === '2cm' && standards.plywoodRequired) {
        requirements.push('Plywood underlayment required for 2cm stone');
      }

      // Seating depth checks
      if (overhangInches >= 12) {
        requirements.push('Ensure support brackets extend within 4" of edge');
      }
      if (overhangInches >= 15) {
        warnings.push('Consider leg supports or corbels for stability');
      }

      return { warnings, requirements, needsSupport: overhangInches > standards.maxUnsupported };
    }

    // Update countertop overhang (front, back, left, right)
    function updateOverhang() {
      const countertopTypes = ['countertop', 'countertop-corner', 'countertop-l', 'countertop-u', 'island'];
      if (!selectedElement || !countertopTypes.includes(selectedElement.type)) return;

      // Get new values in inches
      const frontIn = parseFloat(document.getElementById('propOverhangFront')?.value || 1.5);
      const backIn = parseFloat(document.getElementById('propOverhangBack')?.value || 0);
      const leftIn = parseFloat(document.getElementById('propOverhangLeft')?.value || 1.5);
      const rightIn = parseFloat(document.getElementById('propOverhangRight')?.value || 1.5);

      // Convert to feet
      const frontFt = frontIn / 12;
      const backFt = backIn / 12;
      const leftFt = leftIn / 12;
      const rightFt = rightIn / 12;

      // Get old overhang values (default to 2" front = 0.167ft if not set)
      const oldFront = selectedElement.overhangFront !== undefined ? selectedElement.overhangFront : 0.167;
      const oldBack = selectedElement.overhangBack !== undefined ? selectedElement.overhangBack : 0;
      const oldLeft = selectedElement.overhangLeft !== undefined ? selectedElement.overhangLeft : 0.125;
      const oldRight = selectedElement.overhangRight !== undefined ? selectedElement.overhangRight : 0.125;

      // Calculate the change in overhang
      const deltaFront = frontFt - oldFront;
      const deltaBack = backFt - oldBack;
      const deltaLeft = leftFt - oldLeft;
      const deltaRight = rightFt - oldRight;

      // Update countertop dimensions based on overhang changes
      // Width changes by left + right delta
      // Height (depth) changes by front + back delta
      selectedElement.width += (deltaLeft + deltaRight);
      selectedElement.height += (deltaFront + deltaBack);

      // Update position - move to account for left and back overhang changes
      // Left overhang increases = move countertop left (decrease x)
      // Back overhang increases = move countertop up (decrease y)
      selectedElement.x -= deltaLeft * pixelsPerFoot;
      selectedElement.y -= deltaBack * pixelsPerFoot;

      // Store new overhang values
      selectedElement.overhangFront = frontFt;
      selectedElement.overhangBack = backFt;
      selectedElement.overhangLeft = leftFt;
      selectedElement.overhangRight = rightFt;

      // Update dimension display in properties panel
      document.getElementById('propWidth').value = selectedElement.width.toFixed(4).replace(/\.?0+$/, '');
      const depthEl = document.getElementById('propDepth');
      if (depthEl) depthEl.value = selectedElement.height.toFixed(4).replace(/\.?0+$/, '');

      // Validate against fabrication standards
      const thickness = selectedElement.thickness || '3cm';
      const depthInches = selectedElement.height * 12;

      // Check largest overhang
      const maxOverhang = Math.max(frontIn, backIn, leftIn, rightIn);
      const validation = validateOverhang(maxOverhang, thickness, depthInches);

      // Store validation results on element
      selectedElement.needsBrackets = validation.needsSupport;
      selectedElement.fabricationNotes = [...validation.warnings, ...validation.requirements];

      // Update warning display in UI
      updateOverhangWarningDisplay(validation);

      // Clear preset selection if manually editing
      const presetSelect = document.getElementById('propOverhangPreset');
      if (presetSelect) presetSelect.value = '';

      draw();
      update3DScene();
      calculateQuote();
      saveUndoState();
    }

    // Apply overhang preset (Standard, Island, Bar, Breakfast Bar, ADA)
    function applyOverhangPreset() {
      const countertopTypes = ['countertop', 'countertop-corner', 'countertop-l', 'countertop-u', 'island'];
      if (!selectedElement || !countertopTypes.includes(selectedElement.type)) return;

      const preset = document.getElementById('propOverhangPreset')?.value;
      if (!preset) return;

      let front = 2, back = 0, left = 1.5, right = 1.5; // Default in inches - 2" front covers cabinet face
      let presetName = preset;

      switch(preset) {
        case 'standard':
          front = 2; back = 0; left = 1.5; right = 1.5;
          presetName = 'Standard (2" front)';
          break;
        case 'island':
          front = 2; back = 2; left = 2; right = 2;
          presetName = 'Island (2" all sides)';
          break;
        case 'bar':
          front = 12; back = 2; left = 1.5; right = 1.5;
          presetName = 'Bar Seating (12" front)';
          break;
        case 'breakfast':
          front = 15; back = 2; left = 1.5; right = 1.5;
          presetName = 'Breakfast Bar (15" front)';
          break;
        case 'ada':
          front = 19; back = 2; left = 1.5; right = 1.5;
          presetName = 'ADA Accessible (19" knee clearance)';
          break;
      }

      // Update input fields
      document.getElementById('propOverhangFront').value = front;
      document.getElementById('propOverhangBack').value = back;
      document.getElementById('propOverhangLeft').value = left;
      document.getElementById('propOverhangRight').value = right;

      // Convert to feet
      const frontFt = front / 12;
      const backFt = back / 12;
      const leftFt = left / 12;
      const rightFt = right / 12;

      // Get old overhang values (default to 2" front = 0.167ft if not set)
      const oldFront = selectedElement.overhangFront !== undefined ? selectedElement.overhangFront : 0.167;
      const oldBack = selectedElement.overhangBack !== undefined ? selectedElement.overhangBack : 0;
      const oldLeft = selectedElement.overhangLeft !== undefined ? selectedElement.overhangLeft : 0.125;
      const oldRight = selectedElement.overhangRight !== undefined ? selectedElement.overhangRight : 0.125;

      // Calculate deltas
      const deltaFront = frontFt - oldFront;
      const deltaBack = backFt - oldBack;
      const deltaLeft = leftFt - oldLeft;
      const deltaRight = rightFt - oldRight;

      // Resize countertop
      selectedElement.width += (deltaLeft + deltaRight);
      selectedElement.height += (deltaFront + deltaBack);

      // Reposition
      selectedElement.x -= deltaLeft * pixelsPerFoot;
      selectedElement.y -= deltaBack * pixelsPerFoot;

      // Store new overhang values
      selectedElement.overhangFront = frontFt;
      selectedElement.overhangBack = backFt;
      selectedElement.overhangLeft = leftFt;
      selectedElement.overhangRight = rightFt;

      // Update dimension display
      document.getElementById('propWidth').value = selectedElement.width.toFixed(4).replace(/\.?0+$/, '');
      const depthEl2 = document.getElementById('propDepth');
      if (depthEl2) depthEl2.value = selectedElement.height.toFixed(4).replace(/\.?0+$/, '');

      // Validate and show warnings
      const thickness = selectedElement.thickness || '3cm';
      const depthInches = selectedElement.height * 12;
      const maxOverhang = Math.max(front, back, left, right);
      const validation = validateOverhang(maxOverhang, thickness, depthInches);

      // Store validation results
      selectedElement.needsBrackets = validation.needsSupport;
      selectedElement.fabricationNotes = [...validation.warnings, ...validation.requirements];

      // Update warning display
      updateOverhangWarningDisplay(validation);

      draw();
      update3DScene();
      calculateQuote();
      saveUndoState();
      showSnapFeedback(`Overhang: ${presetName}`);
    }

    // Update the overhang warning display in the UI
    function updateOverhangWarningDisplay(validation) {
      const warningDiv = document.getElementById('overhangWarning');
      const warningText = document.getElementById('overhangWarningText');

      if (!warningDiv || !warningText) return;

      const allMessages = [...validation.requirements, ...validation.warnings];

      if (allMessages.length > 0) {
        warningDiv.style.display = 'block';
        warningText.innerHTML = allMessages.map(msg => ` ${msg}`).join('<br>');
      } else {
        warningDiv.style.display = 'none';
      }
    }

    // Add countertop on top of selected cabinet
    function addCountertopToCabinet() {
      if (!selectedElement) return;

      // Check if selected element is a cabinet type
      const cabinetTypes = ['base-cabinet', 'corner-cabinet', 'lazy-susan', 'drawer-base', 'sink-base', 'island'];
      if (!cabinetTypes.includes(selectedElement.type) && !selectedElement.type.startsWith('base-')) return;

      const cabinet = selectedElement;
      const cabX = cabinet.x;
      const cabY = cabinet.y;
      const cabinetDepth = cabinet.height || cabinet.depth || 2; // Cabinet depth in feet

      // Proper overhang: 2" front (covers cabinet face), 1.5" sides, 0" back (against wall)
      // For islands, use 2" on all sides so cabinet faces are recessed
      const isIsland = cabinet.type === 'island' || cabinet.type === 'base-cabinet' && cabinet.y > roomDepth * pixelsPerFoot * 0.3;

      const frontOverhang = 0.167; // 2 inches in feet - covers cabinet door faces
      const backOverhang = isIsland ? 0.167 : 0; // Islands get overhang all around, wall cabinets don't need back
      const sideOverhang = 0.125; // 1.5 inches in feet

      // Calculate countertop dimensions with proper overhang
      // Depth: cabinet depth + front overhang + back overhang
      const countertopDepth = cabinetDepth + frontOverhang + backOverhang;

      // Create countertop element that fits the cabinet with proper overhang
      const countertop = {
        id: generateId(),
        type: 'countertop',
        name: 'Countertop',
        x: cabX - (sideOverhang * pixelsPerFoot),
        y: cabY - (backOverhang * pixelsPerFoot),
        width: cabinet.width + (sideOverhang * 2),  // Add 1.5" each side = 3" total
        height: countertopDepth, // 2" front + cabinet depth (+ 2" back for islands)
        rotation: cabinet.rotation || 0,
        color: '#a0a0a0',
        roomId: currentRoom,
        edgeProfile: 'eased',
        thickness: '3cm',
        overhangFront: frontOverhang,
        overhangBack: backOverhang,
        overhangLeft: sideOverhang,
        overhangRight: sideOverhang
      };

      elements.push(countertop);
      selectedElement = countertop;

      draw();
      update3DScene();
      calculateQuote();
      updateProperties();
      showSnapFeedback(`Countertop added (${Math.round(countertopDepth * 12)}" deep with ${Math.round(frontOverhang * 12)}" front overhang)`);
    }

    // Update sink properties (color, mount type)
    function updateSinkProperties() {
      if (!selectedElement || !selectedElement.type.startsWith('sink')) return;

      const sinkColor = document.getElementById('propSinkColor').value;
      const mountType = document.getElementById('propSinkMount').value;

      selectedElement.sinkColor = sinkColor;
      selectedElement.mountType = mountType;

      // Update the element color for 2D view based on sink finish
      const sinkColors = {
        stainless: '#C0C0C0',
        black: '#2A2A2A',
        white: '#F5F5F5',
        graphite: '#4A4A4A',
        bisque: '#F5E6D3',
        bronze: '#5C4033'
      };
      selectedElement.color = sinkColors[sinkColor] || '#C0C0C0';

      draw();
      update3DScene();
      calculateQuote();

      const colorNames = {
        stainless: 'Stainless Steel',
        black: 'Matte Black',
        white: 'White',
        graphite: 'Graphite',
        bisque: 'Bisque',
        bronze: 'Oil-Rubbed Bronze'
      };
      showSnapFeedback(`Sink: ${colorNames[sinkColor]} / ${mountType}`);
    }

    // Add a seam to the selected countertop
    function addSeamToCountertop() {
      const countertopTypes = ['countertop', 'countertop-corner', 'countertop-l', 'countertop-u', 'island'];
      if (!selectedElement || !countertopTypes.includes(selectedElement.type)) return;

      // Initialize seams array if needed
      if (!selectedElement.seams) {
        selectedElement.seams = [];
      }

      // Calculate seam requirements to suggest optimal placement
      const requirements = calculateSeamRequirements(selectedElement);
      const existingCount = selectedElement.seams.length;
      let newPosition;

      // Use suggested positions if available, otherwise calculate
      if (requirements.suggestedPositions.length > existingCount) {
        newPosition = requirements.suggestedPositions[existingCount];
      } else if (existingCount === 0) {
        newPosition = 0.5; // Center
      } else {
        // Add at positions that avoid existing seams
        const existingPositions = selectedElement.seams.map(s => s.position);
        const candidates = [0.33, 0.67, 0.25, 0.75, 0.4, 0.6];
        newPosition = candidates.find(pos => {
          return !existingPositions.some(existing => Math.abs(existing - pos) < 0.1);
        }) || 0.5;
      }

      // Validate the seam placement
      const validation = validateSeamPlacement(selectedElement, newPosition);

      // If there are errors, try to find a better position
      if (!validation.isValid) {
        // Try alternative positions
        const alternatives = [0.5, 0.45, 0.55, 0.4, 0.6, 0.35, 0.65];
        for (const altPos of alternatives) {
          const altValidation = validateSeamPlacement(selectedElement, altPos);
          if (altValidation.isValid) {
            newPosition = altPos;
            validation.warnings = altValidation.warnings;
            validation.errors = [];
            break;
          }
        }
      }

      // Add the seam
      selectedElement.seams.push({
        position: newPosition,
        id: Date.now(),
        validation: { warnings: validation.warnings, errors: validation.errors }
      });

      // Sort seams by position
      selectedElement.seams.sort((a, b) => a.position - b.position);

      updateProperties();
      updateSeamUI();
      draw();
      update3DScene();

      // Show feedback with any warnings
      const posPercent = Math.round(newPosition * 100);
      const posInches = Math.round(newPosition * selectedElement.width * 12);
      if (validation.errors.length > 0) {
        showToast(` Seam at ${posInches}" (${posPercent}%): ${validation.errors[0]}`, 'warning', 4000);
      } else if (validation.warnings.length > 0) {
        showToast(`Seam at ${posInches}" (${posPercent}%) - Note: ${validation.warnings[0]}`, 'info', 3000);
      } else {
        showSnapFeedback(`Seam added at ${posInches}" (${posPercent}%)`);
      }
    }

    // Clear all seams from countertop
    function clearSeams() {
      const countertopTypes = ['countertop', 'countertop-corner', 'countertop-l', 'countertop-u', 'island'];
      if (!selectedElement || !countertopTypes.includes(selectedElement.type)) return;

      selectedElement.seams = [];
      updateProperties();
      updateSeamUI();
      draw();
      update3DScene();
      showSnapFeedback('All seams removed');
    }

    // Remove a specific seam
    function removeSeam(seamId) {
      if (!selectedElement || !selectedElement.seams) return;

      selectedElement.seams = selectedElement.seams.filter(s => s.id !== seamId);
      updateProperties();
      updateSeamUI();
      draw();
      update3DScene();
      showSnapFeedback('Seam removed');
    }

    // Seam placement mode state
    let seamPlacementMode = false;

    // Toggle interactive seam placement mode
    function toggleSeamPlacementMode() {
      const countertopTypes = ['countertop', 'countertop-corner', 'countertop-l', 'countertop-u', 'island'];
      if (!selectedElement || !countertopTypes.includes(selectedElement.type)) {
        showToast('Select a countertop first', 'warning', 2000);
        return;
      }

      seamPlacementMode = !seamPlacementMode;
      const btn = document.getElementById('seamPlaceModeBtn');

      if (seamPlacementMode) {
        btn.style.background = 'rgba(139, 92, 246, 0.8)';
        btn.textContent = ' Click Countertop...';
        showSnapFeedback('Click on countertop to place seam');
      } else {
        btn.style.background = 'rgba(139, 92, 246, 0.3)';
        btn.textContent = ' Click to Place';
      }
    }

    // Handle seam placement click on canvas
    function handleSeamPlacementClick(e) {
      if (!seamPlacementMode || !selectedElement) return false;

      const countertopTypes = ['countertop', 'countertop-corner', 'countertop-l', 'countertop-u', 'island'];
      if (!countertopTypes.includes(selectedElement.type)) return false;

      const rect = canvas.getBoundingClientRect();
      const mouseX = (e.clientX - rect.left - panOffset.x) / zoomLevel;
      const mouseY = (e.clientY - rect.top - panOffset.y) / zoomLevel;

      // Get countertop bounds
      const elX = selectedElement.x;
      const elY = selectedElement.y;
      const elW = selectedElement.width * pixelsPerFoot;
      const elH = selectedElement.height * pixelsPerFoot;

      // Check if click is within countertop
      if (mouseX >= elX && mouseX <= elX + elW &&
          mouseY >= elY && mouseY <= elY + elH) {

        // Calculate seam position as percentage along width
        const seamPosition = (mouseX - elX) / elW;

        // Validate placement
        const validation = validateSeamPlacement(selectedElement, seamPosition);

        // Initialize seams array if needed
        if (!selectedElement.seams) {
          selectedElement.seams = [];
        }

        // Add the seam
        selectedElement.seams.push({
          position: seamPosition,
          id: Date.now(),
          validation: { warnings: validation.warnings, errors: validation.errors }
        });

        // Sort seams by position
        selectedElement.seams.sort((a, b) => a.position - b.position);

        updateProperties();
        updateSeamUI();
        draw();
        update3DScene();

        const posInches = Math.round(seamPosition * selectedElement.width * 12);
        const posPercent = Math.round(seamPosition * 100);

        if (validation.errors.length > 0) {
          showToast(` Seam at ${posInches}" (${posPercent}%): ${validation.errors[0]}`, 'warning', 4000);
        } else {
          showSnapFeedback(`Seam placed at ${posInches}" (${posPercent}%)`);
        }

        return true; // Consumed the click
      }

      return false;
    }

    // Update seam UI with list and piece dimensions
    function updateSeamUI() {
      const countertopTypes = ['countertop', 'countertop-corner', 'countertop-l', 'countertop-u', 'island'];
      if (!selectedElement || !countertopTypes.includes(selectedElement.type)) return;

      const widthInches = selectedElement.width * 12;
      const depthInches = selectedElement.height * 12;
      const standards = FABRICATION_STANDARDS.seams;

      // Update countertop dimensions display
      const dimDisplay = document.getElementById('ctopDimensions');
      const statusDisplay = document.getElementById('ctopSeamStatus');
      if (dimDisplay) {
        dimDisplay.innerHTML = `<strong>${widthInches.toFixed(0)}"  ${depthInches.toFixed(0)}"</strong> (${(widthInches/12).toFixed(1)}'  ${(depthInches/12).toFixed(1)}')`;
      }

      // Determine if seams are needed
      const needsSeam = widthInches > standards.maxSlabWidth;
      if (statusDisplay) {
        if (needsSeam) {
          const minSeams = Math.ceil(widthInches / standards.maxSlabWidth) - 1;
          const currentSeams = selectedElement.seams?.length || 0;
          if (currentSeams >= minSeams) {
            statusDisplay.innerHTML = ' OK';
            statusDisplay.style.background = 'rgba(16, 185, 129, 0.3)';
            statusDisplay.style.color = '#6ee7b7';
          } else {
            statusDisplay.innerHTML = ` Need ${minSeams} seam${minSeams > 1 ? 's' : ''}`;
            statusDisplay.style.background = 'rgba(239, 68, 68, 0.3)';
            statusDisplay.style.color = '#fca5a5';
          }
        } else {
          statusDisplay.innerHTML = ' Fits slab';
          statusDisplay.style.background = 'rgba(16, 185, 129, 0.3)';
          statusDisplay.style.color = '#6ee7b7';
        }
      }

      // Update seam count
      const seamCount = document.getElementById('seamCount');
      const seams = selectedElement.seams || [];
      if (seamCount) {
        seamCount.textContent = `${seams.length} seam${seams.length !== 1 ? 's' : ''}`;
      }

      // Show seam requirement warning if needed
      const reqInfo = document.getElementById('seamRequirementInfo');
      const reqText = document.getElementById('seamRequirementText');
      if (reqInfo && reqText) {
        if (needsSeam && seams.length < Math.ceil(widthInches / standards.maxSlabWidth) - 1) {
          reqInfo.style.display = 'block';
          reqText.innerHTML = ` Countertop exceeds ${standards.maxSlabWidth}" max slab width. Seams required.`;
        } else {
          reqInfo.style.display = 'none';
        }
      }

      // Build seam list
      const seamListContainer = document.getElementById('seamListContainer');
      const seamList = document.getElementById('seamList');
      if (seamListContainer && seamList) {
        if (seams.length > 0) {
          seamListContainer.style.display = 'block';
          seamList.innerHTML = seams.map((seam, idx) => {
            const posInches = Math.round(seam.position * widthInches);
            const posPercent = Math.round(seam.position * 100);
            const hasWarning = seam.validation?.warnings?.length > 0;
            const hasError = seam.validation?.errors?.length > 0;

            return `
              <div style="display: flex; align-items: center; gap: 6px; padding: 4px 6px; background: rgba(255,255,255,0.05); border-radius: 4px;">
                <span style="color: #9ca3af; font-size: 10px; width: 20px;">#${idx + 1}</span>
                <input type="number" value="${posInches}" min="6" max="${widthInches - 6}" step="1"
                  onchange="updateSeamPosition(${seam.id}, this.value / ${widthInches})"
                  style="width: 50px; padding: 2px 4px; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); border-radius: 3px; color: #fff; font-size: 11px;">
                <span style="color: #9ca3af; font-size: 10px;">" (${posPercent}%)</span>
                ${hasError ? '<span style="color: #f87171;" title="' + (seam.validation.errors[0] || '') + '"></span>' : ''}
                ${hasWarning && !hasError ? '<span style="color: #fbbf24;" title="' + (seam.validation.warnings[0] || '') + '"></span>' : ''}
                <button onclick="removeSeam(${seam.id})" style="margin-left: auto; padding: 2px 6px; background: rgba(239, 68, 68, 0.2); border: none; border-radius: 3px; color: #f87171; cursor: pointer; font-size: 10px;"></button>
              </div>
            `;
          }).join('');
        } else {
          seamListContainer.style.display = 'none';
        }
      }

      // Calculate and display piece dimensions
      const piecesInfo = document.getElementById('pieceDimensionsInfo');
      const piecesList = document.getElementById('piecesList');
      if (piecesInfo && piecesList) {
        if (seams.length > 0) {
          piecesInfo.style.display = 'block';

          // Calculate piece widths
          const sortedPositions = [0, ...seams.map(s => s.position), 1].sort((a, b) => a - b);
          const pieces = [];

          for (let i = 0; i < sortedPositions.length - 1; i++) {
            const pieceWidthInches = (sortedPositions[i + 1] - sortedPositions[i]) * widthInches;
            const fitsStandard = pieceWidthInches <= standards.maxSlabWidth && depthInches <= standards.maxSlabDepth;
            const fitsJumbo = pieceWidthInches <= standards.jumboSlabWidth && depthInches <= standards.jumboSlabDepth;

            pieces.push({
              width: pieceWidthInches,
              depth: depthInches,
              fitsStandard,
              fitsJumbo,
              slabType: fitsStandard ? 'Standard' : (fitsJumbo ? 'Jumbo' : 'OVERSIZE')
            });
          }

          piecesList.innerHTML = pieces.map((p, i) => {
            const icon = p.fitsStandard ? '' : (p.fitsJumbo ? '' : '');
            const color = p.fitsStandard ? '#6ee7b7' : (p.fitsJumbo ? '#93c5fd' : '#f87171');
            return `<div style="color: ${color};">${icon} Piece ${i + 1}: <strong>${p.width.toFixed(0)}"  ${p.depth.toFixed(0)}"</strong> (${p.slabType})</div>`;
          }).join('');
        } else {
          piecesInfo.style.display = 'none';
        }
      }
    }

    // Update a specific seam position
    function updateSeamPosition(seamId, newPosition) {
      if (!selectedElement || !selectedElement.seams) return;

      const seam = selectedElement.seams.find(s => s.id === seamId);
      if (!seam) return;

      // Clamp position between 0.05 and 0.95
      newPosition = Math.max(0.05, Math.min(0.95, newPosition));

      // Re-validate
      const validation = validateSeamPlacement(selectedElement, newPosition);
      seam.position = newPosition;
      seam.validation = { warnings: validation.warnings, errors: validation.errors };

      // Re-sort seams
      selectedElement.seams.sort((a, b) => a.position - b.position);

      updateSeamUI();
      draw();
      update3DScene();
    }

    // Validate seam placement against fabrication standards
    function validateSeamPlacement(countertop, seamPosition) {
      const warnings = [];
      const errors = [];
      const standards = FABRICATION_STANDARDS.seams;

      const widthInches = countertop.width * 12;
      const seamPosInches = widthInches * seamPosition;

      // Check minimum distance from edges
      const distFromLeft = seamPosInches;
      const distFromRight = widthInches - seamPosInches;

      if (distFromLeft < standards.minFromEdge) {
        errors.push(`Seam too close to left edge (${distFromLeft.toFixed(1)}" < ${standards.minFromEdge}" min)`);
      }
      if (distFromRight < standards.minFromEdge) {
        errors.push(`Seam too close to right edge (${distFromRight.toFixed(1)}" < ${standards.minFromEdge}" min)`);
      }

      // Check if seam is in preferred visibility zone
      if (seamPosition < standards.preferredZone.min || seamPosition > standards.preferredZone.max) {
        warnings.push('Seam placement outside preferred zone (middle 50% is optimal)');
      }

      // Check for elements placed on this countertop that the seam might cross
      const countertopBounds = {
        left: countertop.x / pixelsPerFoot,
        right: (countertop.x / pixelsPerFoot) + countertop.width,
        top: countertop.y / pixelsPerFoot,
        bottom: (countertop.y / pixelsPerFoot) + countertop.height
      };
      const seamXFeet = countertopBounds.left + (countertop.width * seamPosition);

      elements.forEach(el => {
        if (el === countertop) return;
        if (!standards.avoidOver.includes(el.type)) return;

        const elLeft = el.x / pixelsPerFoot;
        const elRight = elLeft + el.width;
        const elTop = el.y / pixelsPerFoot;
        const elBottom = elTop + el.height;

        // Check if element overlaps with countertop
        const overlapsCountertop = !(elRight < countertopBounds.left ||
                                     elLeft > countertopBounds.right ||
                                     elBottom < countertopBounds.top ||
                                     elTop > countertopBounds.bottom);

        if (overlapsCountertop) {
          // Check if seam passes through this element
          const seamBuffer = standards.minFromSink / 12; // Convert to feet
          if (seamXFeet >= (elLeft - seamBuffer) && seamXFeet <= (elRight + seamBuffer)) {
            errors.push(`Seam crosses over ${el.type.replace(/-/g, ' ')} - water infiltration risk`);
          }
        }
      });

      return {
        warnings,
        errors,
        isValid: errors.length === 0,
        seamPosition
      };
    }

    // Calculate if countertop needs seams based on slab dimensions
    function calculateSeamRequirements(countertop) {
      const standards = FABRICATION_STANDARDS.seams;
      const widthInches = countertop.width * 12;
      const depthInches = countertop.height * 12;

      const requirements = {
        needsSeam: false,
        reason: '',
        suggestedPositions: [],
        minSeams: 0
      };

      // Check if width exceeds max slab width
      if (widthInches > standards.maxSlabWidth) {
        requirements.needsSeam = true;
        requirements.reason = `Width (${widthInches.toFixed(0)}") exceeds max slab width (${standards.maxSlabWidth}")`;

        // Calculate minimum number of seams needed
        requirements.minSeams = Math.ceil(widthInches / standards.maxSlabWidth) - 1;

        // Suggest evenly distributed seam positions
        for (let i = 1; i <= requirements.minSeams; i++) {
          const pos = i / (requirements.minSeams + 1);
          requirements.suggestedPositions.push(pos);
        }
      }

      // Check if depth exceeds max slab depth (would need to reorient slab)
      if (depthInches > standards.maxSlabDepth && !requirements.needsSeam) {
        if (widthInches <= standards.maxSlabDepth) {
          // Can rotate slab - depth becomes width
          requirements.reason = 'Slab will be oriented lengthwise for depth';
        } else if (depthInches > standards.jumboSlabDepth) {
          requirements.needsSeam = true;
          requirements.reason = `Depth (${depthInches.toFixed(0)}") exceeds jumbo slab depth (${standards.jumboSlabDepth}")`;
        }
      }

      return requirements;
    }

    // Show seam requirement notification
    function showSeamRequirementCheck() {
      if (!selectedElement) return;

      const countertopTypes = ['countertop', 'countertop-corner', 'countertop-l', 'countertop-u', 'island'];
      if (!countertopTypes.includes(selectedElement.type)) return;

      const req = calculateSeamRequirements(selectedElement);
      const currentSeams = selectedElement.seams?.length || 0;

      if (req.needsSeam && currentSeams < req.minSeams) {
        showToast(` ${req.reason}. Need at least ${req.minSeams} seam${req.minSeams > 1 ? 's' : ''}.`, 'warning', 5000);
      } else if (!req.needsSeam && currentSeams === 0) {
        showToast(' Countertop fits within standard slab dimensions - no seam required', 'success', 3000);
      }
    }

    // Get standard sizes for element type
    function getStandardSizesForType(type) {
      const sizes = [];

      switch (type) {
        case 'door':
          sizes.push({ label: '2\'-8" (32")', width: 2.667, height: 0.5 });
          sizes.push({ label: '3\'-0" (36")', width: 3, height: 0.5 });
          sizes.push({ label: '2\'-6" (30")', width: 2.5, height: 0.5 });
          break;
        case 'double-door':
          sizes.push({ label: '5\'-0" (60")', width: 5, height: 0.5 });
          sizes.push({ label: '6\'-0" (72")', width: 6, height: 0.5 });
          break;
        case 'sliding-door':
          sizes.push({ label: '6\'-0" (72")', width: 6, height: 0.5 });
          sizes.push({ label: '8\'-0" (96")', width: 8, height: 0.5 });
          sizes.push({ label: '9\'-0" (108")', width: 9, height: 0.5 });
          break;
        case 'entry-archway':
          sizes.push({ label: '3\'-0" (36")', width: 3, height: 0.5 });
          sizes.push({ label: '4\'-0" (48")', width: 4, height: 0.5 });
          sizes.push({ label: '5\'-0" (60")', width: 5, height: 0.5 });
          break;
        case 'garage-door':
          sizes.push({ label: '8\' Single', width: 8, height: 0.5 });
          sizes.push({ label: '9\' Single', width: 9, height: 0.5 });
          sizes.push({ label: '16\' Double', width: 16, height: 0.5 });
          sizes.push({ label: '18\' Double', width: 18, height: 0.5 });
          break;
        case 'window':
          sizes.push({ label: '2\'-0"  3\'-0"', width: 2, height: 0.5 });
          sizes.push({ label: '3\'-0"  4\'-0"', width: 3, height: 0.5 });
          sizes.push({ label: '4\'-0"  5\'-0"', width: 4, height: 0.5 });
          sizes.push({ label: '6\'-0" Picture', width: 6, height: 0.5 });
          break;
        case 'base-cabinet':
          sizes.push({ label: '12" Base', width: 1, height: 2 });
          sizes.push({ label: '15" Base', width: 1.25, height: 2 });
          sizes.push({ label: '18" Base', width: 1.5, height: 2 });
          sizes.push({ label: '24" Base', width: 2, height: 2 });
          sizes.push({ label: '30" Base', width: 2.5, height: 2 });
          sizes.push({ label: '36" Base', width: 3, height: 2 });
          break;
        case 'drawer-base':
          sizes.push({ label: '12" Drawer', width: 1, height: 2 });
          sizes.push({ label: '15" Drawer', width: 1.25, height: 2 });
          sizes.push({ label: '18" Drawer', width: 1.5, height: 2 });
          sizes.push({ label: '24" Drawer', width: 2, height: 2 });
          sizes.push({ label: '30" Drawer', width: 2.5, height: 2 });
          sizes.push({ label: '36" Drawer', width: 3, height: 2 });
          break;
        case 'sink-base':
          sizes.push({ label: '30" Sink Base', width: 2.5, height: 2 });
          sizes.push({ label: '33" Sink Base', width: 2.75, height: 2 });
          sizes.push({ label: '36" Sink Base', width: 3, height: 2 });
          sizes.push({ label: '42" Sink Base', width: 3.5, height: 2 });
          break;
        case 'corner-cabinet':
        case 'lazy-susan':
        case 'blind-corner':
          sizes.push({ label: '33" Corner', width: 2.75, height: 2.75 });
          sizes.push({ label: '36" Corner', width: 3, height: 3 });
          sizes.push({ label: '39" Corner', width: 3.25, height: 3.25 });
          break;
        case 'wall-cabinet':
          sizes.push({ label: '12" Wall', width: 1, height: 1 });
          sizes.push({ label: '18" Wall', width: 1.5, height: 1 });
          sizes.push({ label: '24" Wall', width: 2, height: 1 });
          sizes.push({ label: '30" Wall', width: 2.5, height: 1 });
          sizes.push({ label: '36" Wall', width: 3, height: 1 });
          break;
        case 'tall-cabinet':
          sizes.push({ label: '18" Pantry', width: 1.5, height: 2 });
          sizes.push({ label: '24" Pantry', width: 2, height: 2 });
          sizes.push({ label: '36" Pantry', width: 3, height: 2 });
          break;
        case 'fridge-cabinet':
          sizes.push({ label: '30" Fridge Cabinet', width: 2.5, height: 7 });
          sizes.push({ label: '36" Fridge Cabinet', width: 3, height: 7 });
          sizes.push({ label: '42" Fridge Cabinet', width: 3.5, height: 7 });
          break;
        case 'island':
          sizes.push({ label: '4\'  2\' Small', width: 4, height: 2 });
          sizes.push({ label: '5\'  3\' Medium', width: 5, height: 3 });
          sizes.push({ label: '6\'  3\' Large', width: 6, height: 3 });
          sizes.push({ label: '8\'  4\' XL', width: 8, height: 4 });
          break;
        case 'countertop':
          sizes.push({ label: '25" Depth Std', width: 3, height: 2.083 });
          sizes.push({ label: '30" Depth Deep', width: 3, height: 2.5 });
          break;
        case 'sink':
          sizes.push({ label: '25" Single', width: 2.083, height: 1.83 });
          sizes.push({ label: '30" Single', width: 2.5, height: 1.83 });
          sizes.push({ label: '33" Single', width: 2.75, height: 1.83 });
          break;
        case 'sink-double':
          sizes.push({ label: '33" Double', width: 2.75, height: 1.83 });
          sizes.push({ label: '36" Double', width: 3, height: 1.83 });
          sizes.push({ label: '42" Double', width: 3.5, height: 1.83 });
          break;
        case 'sink-farmhouse':
          sizes.push({ label: '30" Farmhouse', width: 2.5, height: 1.75 });
          sizes.push({ label: '33" Farmhouse', width: 2.75, height: 1.75 });
          sizes.push({ label: '36" Farmhouse', width: 3, height: 1.75 });
          break;
        case 'stove':
        case 'range':
          sizes.push({ label: '30" Range', width: 2.5, height: 2.25 });
          sizes.push({ label: '36" Pro Range', width: 3, height: 2.25 });
          sizes.push({ label: '48" Pro Range', width: 4, height: 2.5 });
          break;
        case 'refrigerator':
          sizes.push({ label: '30" Standard', width: 2.5, height: 2.5 });
          sizes.push({ label: '36" Wide', width: 3, height: 2.75 });
          sizes.push({ label: '42" Built-in', width: 3.5, height: 2 });
          break;
        case 'dishwasher':
          sizes.push({ label: '24" Standard', width: 2, height: 2 });
          sizes.push({ label: '18" Compact', width: 1.5, height: 2 });
          break;
      }

      return sizes;
    }

    // ===== MATERIALS =====
    function openMaterialPicker() {
      if (!selectedElement) return;

      const modal = document.getElementById('materialModal');
      modal.style.display = ''; // Reset any inline display style
      modal.classList.add('active');
      renderMaterialCategories();
      renderModalMaterials('granite');
    }

    function renderMaterialCategories() {
      const container = document.getElementById('materialCategories');
      container.innerHTML = Object.keys(MATERIALS).map(cat => `
        <button class="material-category-btn ${cat === 'granite' ? 'active' : ''}"
                onclick="renderModalMaterials('${cat}', this)">
          ${cat.charAt(0).toUpperCase() + cat.slice(1)}
        </button>
      `).join('') + `
        <button class="material-category-btn" onclick="renderModalMaterials('custom', this)">
          My Uploads
        </button>
      `;
    }

    function renderModalMaterials(category, btn) {
      document.querySelectorAll('.material-category-btn').forEach(b => b.classList.remove('active'));
      if (btn) btn.classList.add('active');

      const container = document.getElementById('materialsGrid');

      if (category === 'custom') {
        container.innerHTML = `
          <div class="upload-material-btn" onclick="document.getElementById('materialUpload').click()">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
              <polyline points="17 8 12 3 7 8"/>
              <line x1="12" y1="3" x2="12" y2="15"/>
            </svg>
            <span>Upload</span>
          </div>
          ${customMaterials.map(m => `
            <div class="material-modal-item"
                 style="background: url(${m.url}) center/cover"
                 onclick="applyMaterial('${m.url}')">
              <div class="material-name">${m.name}</div>
            </div>
          `).join('')}
        `;
      } else {
        const materials = MATERIALS[category] || [];
        const canShowPrice = PRICING_ACCESS.canViewPricing;
        container.innerHTML = `
          <div class="upload-material-btn" onclick="document.getElementById('materialUpload').click()">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
              <polyline points="17 8 12 3 7 8"/>
              <line x1="12" y1="3" x2="12" y2="15"/>
            </svg>
            <span>Upload</span>
          </div>
          ${materials.map(m => {
            const priceTier = getMaterialPriceTier(m.price);
            const tierInfo = priceTier ? PRICE_TIERS[priceTier] : null;
            const bgUrl = m.url ? getProxiedUrl(m.url) : null;
            return `
            <div class="material-modal-item ${m.brand === 'Daltile' || m.brand?.includes('Daltile') ? 'daltile-material' : ''}"
                 style="background: ${bgUrl ? `url(${bgUrl})` : m.color} center/cover"
                 onclick="applyMaterial('${m.url || m.color}', '${m.color}')"
                 data-sku="${m.sku || ''}"
                 data-price="${canShowPrice && m.price ? m.price : ''}">
              ${canShowPrice && m.price ? `<div class="material-price" style="background: ${tierInfo?.color || '#666'}">$${m.price.toFixed(2)}/sf</div>` : ''}
              ${m.brand ? `<div class="material-brand">${m.brand}</div>` : ''}
              <div class="material-name">${m.name}</div>
            </div>
          `}).join('')}
        `;
      }
    }

    function applyMaterial(urlOrColor, fallbackColor) {
      if (!selectedElement) return;

      // Check if it's a URL (http, data:, or relative path like /images/)
      const isUrl = urlOrColor.startsWith('http') || urlOrColor.startsWith('data:') || urlOrColor.startsWith('/');
      if (isUrl) {
        selectedElement.texture = urlOrColor;
        const img = new Image();
        img.crossOrigin = 'anonymous';

        // Use proxied URL for MSI images to handle CORS
        const finalUrl = getProxiedUrl(urlOrColor);

        img.onload = () => {
          selectedElement.textureImg = img;
          draw();
          render3D(); // Update 3D view as well
          updateProperties();
        };
        img.onerror = () => {
          // Fall back to color
          console.log('Image failed to load:', urlOrColor);
          selectedElement.texture = null;
          selectedElement.color = fallbackColor || '#888';
          draw();
          render3D(); // Update 3D view as well
        };
        img.src = finalUrl;
      } else {
        selectedElement.texture = null;
        selectedElement.textureImg = null;
        selectedElement.color = urlOrColor;
        draw();
        render3D(); // Update 3D view as well
        updateProperties();
      }

      closeModal('materialModal');
    }

    // ===== IMAGE OPTIMIZATION UTILITIES =====

    /**
     * Optimize an image for texture use - resizes large images and compresses
     * @param {File|Blob|string} source - Image file, blob, or data URL
     * @param {Object} options - Optimization options
     * @returns {Promise<{url: string, width: number, height: number}>}
     */
    async function optimizeImageForTexture(source, options = {}) {
      const {
        maxWidth = 2048,
        maxHeight = 2048,
        quality = 0.85,
        format = 'image/jpeg' // jpeg for photos, png for graphics
      } = options;

      return new Promise((resolve, reject) => {
        const img = new Image();
        img.crossOrigin = 'anonymous';

        img.onload = () => {
          let { width, height } = img;
          let needsResize = false;

          // Calculate new dimensions if image is too large
          if (width > maxWidth || height > maxHeight) {
            const ratio = Math.min(maxWidth / width, maxHeight / height);
            width = Math.round(width * ratio);
            height = Math.round(height * ratio);
            needsResize = true;
          }

          // Check if we need to process (resize or compress)
          const shouldProcess = needsResize ||
            (typeof source === 'string' && source.startsWith('data:') && source.length > 500000);

          if (!shouldProcess && typeof source === 'string') {
            // Image is small enough, return as-is
            resolve({ url: source, width: img.width, height: img.height, optimized: false });
            return;
          }

          // Create canvas for resizing/compression
          const canvas = document.createElement('canvas');
          canvas.width = width;
          canvas.height = height;
          const ctx = canvas.getContext('2d');

          // Use high-quality image smoothing
          ctx.imageSmoothingEnabled = true;
          ctx.imageSmoothingQuality = 'high';

          // Draw image onto canvas
          ctx.drawImage(img, 0, 0, width, height);

          // Convert to optimized data URL
          const optimizedUrl = canvas.toDataURL(format, quality);

          resolve({
            url: optimizedUrl,
            width,
            height,
            optimized: true,
            originalSize: typeof source === 'string' ? source.length : 0,
            optimizedSize: optimizedUrl.length
          });
        };

        img.onerror = () => {
          reject(new Error('Failed to load image for optimization'));
        };

        // Load image from source
        if (source instanceof File || source instanceof Blob) {
          const reader = new FileReader();
          reader.onload = (e) => { img.src = e.target.result; };
          reader.onerror = () => reject(new Error('Failed to read image file'));
          reader.readAsDataURL(source);
        } else if (typeof source === 'string') {
          img.src = source;
        } else {
          reject(new Error('Invalid image source'));
        }
      });
    }

    /**
     * Optimize multiple images in parallel with progress callback
     */
    async function optimizeImages(files, options = {}, onProgress = null) {
      const results = [];
      let completed = 0;

      for (const file of files) {
        try {
          const result = await optimizeImageForTexture(file, options);
          results.push({ success: true, ...result, name: file.name });
        } catch (err) {
          results.push({ success: false, error: err.message, name: file.name });
        }
        completed++;
        if (onProgress) onProgress(completed, files.length);
      }

      return results;
    }

    // Quick upload texture directly from properties panel
    function quickUploadTexture() {
      if (!selectedElement) {
        showToast('Please select an element first', 'warning');
        return;
      }

      const input = document.createElement('input');
      input.type = 'file';
      input.accept = 'image/*';
      input.onchange = async (e) => {
        const file = e.target.files[0];
        if (!file) return;

        try {
          // Show loading indicator
          if (typeof showToast === 'function') {
            showToast('Optimizing image...', 'info');
          }

          // Optimize image before storing (resize if too large, compress)
          const result = await optimizeImageForTexture(file, {
            maxWidth: 2048,
            maxHeight: 2048,
            quality: 0.85,
            format: file.type === 'image/png' ? 'image/png' : 'image/jpeg'
          });

          const url = result.url;

          // Log optimization results for debugging
          if (result.optimized) {
            const savings = result.originalSize > 0 ?
              Math.round((1 - result.optimizedSize / result.originalSize) * 100) : 0;
            console.log(`Image optimized: ${result.width}x${result.height}, saved ${savings}%`);
          }

          // Save to custom materials
          customMaterials.push({
            id: Date.now(),
            name: file.name.split('.')[0],
            url: url
          });

          // Apply to selected element
          selectedElement.texture = url;
          selectedElement.materialName = file.name.split('.')[0];

          const img = new Image();
          img.onload = () => {
            selectedElement.textureImg = img;
            draw();
            updateProperties();
            if (typeof showToast === 'function') {
              showToast('Texture applied successfully', 'success');
            }
          };
          img.src = url;
        } catch (err) {
          console.error('Failed to optimize image:', err);
          if (typeof showToast === 'function') {
            showToast('Failed to load image', 'error');
          }
        }
      };
      input.click();
    }

    // Clear texture from selected element
    function clearTexture() {
      if (!selectedElement) return;

      selectedElement.texture = null;
      selectedElement.textureImg = null;
      selectedElement.materialName = null;
      selectedElement.materialId = null;
      draw();
      updateProperties();
    }

    async function handleMaterialUpload(e) {
      const file = e.target.files[0];
      if (!file) return;

      try {
        // Optimize the uploaded image
        const result = await optimizeImageForTexture(file, {
          maxWidth: 2048,
          maxHeight: 2048,
          quality: 0.85,
          format: file.type === 'image/png' ? 'image/png' : 'image/jpeg'
        });

        const url = result.url;
        const name = file.name.split('.')[0];

        customMaterials.push({ id: Date.now(), name, url });

        if (selectedElement) {
          applyMaterial(url);
        }
      } catch (err) {
        console.error('Failed to process material upload:', err);
        if (typeof showToast === 'function') {
          showToast('Failed to upload material', 'error');
        }
      }
      e.target.value = '';
    }

    function uploadElementTexture(type) {
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = 'image/*';
      input.onchange = async (e) => {
        const file = e.target.files[0];
        if (!file) return;

        try {
          // Optimize the uploaded image
          const result = await optimizeImageForTexture(file, {
            maxWidth: 1024, // Smaller for element textures in sidebar
            maxHeight: 1024,
            quality: 0.8,
            format: file.type === 'image/png' ? 'image/png' : 'image/jpeg'
          });

          elementTextures[type] = result.url;
          renderSidebar();
        } catch (err) {
          console.error('Failed to upload element texture:', err);
        }
      };
      input.click();
    }

    // ===== PRICING FUNCTIONS =====

    // Calculate total quote from all elements
    function calculateQuoteTotal() {
      // Use cached value if available and recent
      if (window.currentQuoteTotal !== undefined && window.currentQuoteTotal > 0) {
        return window.currentQuoteTotal;
      }

      let total = 0;
      elements.forEach(el => {
        const priceInfo = getElementPrice(el);
        const margin = getElementMargin(el) || 30;
        let cost = priceInfo?.price || 0;

        // Area-based items (countertops, flooring, etc.)
        if (['countertop', 'backsplash', 'flooring', 'tile'].includes(el.type)) {
          cost = (el.width || 1) * (el.height || 1) * cost;
        }

        // Add margin to get retail price
        total += cost * (1 + margin / 100);
      });

      window.currentQuoteTotal = total;
      return total;
    }

    // Get effective price for an element (priority: override -> catalog -> material -> custom -> default)
    function getElementPrice(element) {
      // 1) Manual override takes highest priority
      if (element.priceOverride !== null && element.priceOverride !== undefined) {
        return { price: element.priceOverride, source: 'override' };
      }

      // 1.5) Check vendor product pricing
      if (element.vendorProduct?.unit_price) {
        return { price: parseFloat(element.vendorProduct.unit_price), source: 'vendor' };
      }

      // 2) Check for cabinet catalog pricing (by SKU)
      if (element.sku && element.catalog) {
        const catalog = CABINET_CATALOGS[element.catalog];
        if (catalog) {
          for (const category of Object.values(catalog.cabinets)) {
            const cab = category.find(c => c.sku === element.sku);
            if (cab && cab.price) {
              return { price: cab.price, source: 'catalog' };
            }
          }
        }
      }

      // 3) Check for material-specific pricing
      if (element.materialId) {
        for (const category in MATERIALS) {
          const mat = MATERIALS[category].find(m => m.id === element.materialId);
          if (mat && mat.price) {
            return { price: mat.price, source: 'material' };
          }
        }
      }

      // 4) Check custom prices from Excel import
      if (element.materialId && PRICING_STATE.customPrices[element.materialId]) {
        return { price: PRICING_STATE.customPrices[element.materialId], source: 'pricelist' };
      }

      // 5) Fall back to default type pricing
      return { price: CONFIG.PRICING[element.type] || 0, source: 'default' };
    }

    // Get element category for margin lookup (pricing-specific categories)
    function getElementMarginCategory(type) {
      if (type.includes('cabinet') || type === 'island') return 'cabinet';
      if (['countertop', 'backsplash'].includes(type)) return 'countertop';
      if (['flooring', 'tile'].includes(type)) return 'flooring';
      if (['stove', 'refrigerator', 'dishwasher', 'microwave', 'oven', 'range-hood', 'sink'].includes(type)) return 'appliance';
      return 'other';
    }

    // Get effective margin for an element (priority: item -> category -> global)
    function getElementMargin(element) {
      // 1) Per-item margin override
      if (element.marginPercent !== null && element.marginPercent !== undefined) {
        return element.marginPercent;
      }

      // 2) Category-specific margin
      const category = getElementMarginCategory(element.type);
      if (PRICING_STATE.categoryMargins && PRICING_STATE.categoryMargins[category] !== undefined) {
        return PRICING_STATE.categoryMargins[category];
      }

      // 3) Global default margin
      return PRICING_STATE.globalMargin;
    }

    // Get material name from ID
    function getMaterialName(materialId) {
      if (!materialId) return null;
      for (const category in MATERIALS) {
        const mat = MATERIALS[category].find(m => m.id === materialId);
        if (mat) return mat.name;
      }
      return null;
    }

    // Update element price from properties panel
    function updateElementPrice() {
      if (!selectedElement) return;

      const overrideInput = document.getElementById('propPriceOverride');
      const unitSelect = document.getElementById('propPriceUnit');
      const marginInput = document.getElementById('propMargin');

      const override = overrideInput && overrideInput.value ? parseFloat(overrideInput.value) : null;
      const unit = unitSelect ? unitSelect.value : 'sqft';
      const margin = marginInput && marginInput.value ? parseFloat(marginInput.value) : null;

      selectedElement.priceOverride = override;
      selectedElement.priceUnit = unit;
      selectedElement.marginPercent = margin;

      calculateQuote();
      updatePricingDisplay();
    }

    // Update pricing display in properties panel
    function updatePricingDisplay() {
      if (!selectedElement) return;

      const priceInfo = getElementPrice(selectedElement);
      const margin = getElementMargin(selectedElement);

      document.getElementById('propBasePrice').textContent = '$' + priceInfo.price.toFixed(2);

      // Calculate item total
      let quantity = 1;
      if (['countertop', 'backsplash', 'flooring', 'tile'].includes(selectedElement.type)) {
        quantity = selectedElement.width * selectedElement.height;
      }

      const cost = priceInfo.price * quantity;
      const retail = cost * (1 + margin / 100);

      document.getElementById('propItemTotal').textContent = '$' + retail.toFixed(2);
    }

    // Check if action is allowed based on permissions
    function checkPermission(action) {
      // For pricing-related actions, also check subscription status
      if (action === 'canViewPrices' || action === 'canViewCosts') {
        // If user doesn't have subscription access to pricing, deny regardless of share permissions
        if (!PRICING_ACCESS.canViewPricing) return false;
      }

      // For shared views, check share permissions
      if (!SHARE_STATE.isSharedView) return true;
      // Deny by default if allowedActions not set (secure default)
      if (!SHARE_STATE.allowedActions) return false;
      return SHARE_STATE.allowedActions[action] === true;
    }

    // Toggle between cost and retail view
    function setQuoteView(view) {
      PRICING_STATE.showCostView = (view === 'cost');
      document.getElementById('retailViewBtn').classList.toggle('active', view === 'retail');
      document.getElementById('costViewBtn').classList.toggle('active', view === 'cost');
      calculateQuote();
    }

    // ===== CABINET RUN BREAKDOWN HELPER =====
    // Break down a cabinet run into individual standard-size cabinets + fillers
    function breakdownCabinetRun(widthFt, cabinetType, unitPrice) {
      const widthInches = widthFt * 12;
      const standards = TAKEOFF_STANDARDS.cabinet;
      const standardWidths = standards.standardWidths; // [9, 12, 15, 18, 21, 24, 27, 30, 33, 36]

      // Results
      const result = {
        cabinets: [],        // Array of { width, count, price }
        fillers: [],         // Array of { width, count, price }
        toeKick: { lengthLF: 0, price: 0 },
        scribe: { lengthLF: 0, price: 0 },
        totalCabinets: 0,
        totalFillers: 0,
        summary: ''
      };

      // Find optimal cabinet combination to fill the width
      let remaining = widthInches;
      const cabinetCounts = {};

      // Greedy algorithm: use largest cabinets first
      const sortedWidths = [...standardWidths].sort((a, b) => b - a);

      for (const cabWidth of sortedWidths) {
        if (remaining >= cabWidth) {
          const count = Math.floor(remaining / cabWidth);
          if (count > 0) {
            cabinetCounts[cabWidth] = count;
            remaining -= count * cabWidth;
          }
        }
      }

      // Handle remaining space
      if (remaining > 0) {
        if (remaining >= standards.filler.minWidth && remaining <= standards.filler.maxWidth) {
          // Small gap - use filler
          result.fillers.push({
            width: remaining,
            count: 1,
            price: (remaining / 12) * standards.filler.pricePerLF * (standards.baseHeight / 12)
          });
          result.totalFillers++;
        } else if (remaining > standards.filler.maxWidth) {
          // Larger gap - try to use smallest standard cabinet + filler
          const smallestCab = Math.min(...standardWidths);
          if (remaining >= smallestCab) {
            cabinetCounts[smallestCab] = (cabinetCounts[smallestCab] || 0) + 1;
            remaining -= smallestCab;
            if (remaining >= standards.filler.minWidth) {
              result.fillers.push({
                width: remaining,
                count: 1,
                price: (remaining / 12) * standards.filler.pricePerLF * (standards.baseHeight / 12)
              });
              result.totalFillers++;
            }
          }
        }
        // Very small remainder (< 1.5") - absorbed as acceptable gap
      }

      // Convert counts to result array with prices
      for (const [width, count] of Object.entries(cabinetCounts)) {
        const widthNum = parseInt(width);
        // Price scales roughly with width (using a simple scaling from unit price)
        const scaledPrice = unitPrice * (widthNum / 30); // 30" as baseline
        result.cabinets.push({
          width: widthNum,
          count: count,
          priceEach: scaledPrice,
          priceTotal: scaledPrice * count
        });
        result.totalCabinets += count;
      }

      // Calculate toe kick (runs full length of cabinet run)
      result.toeKick.lengthLF = widthFt;
      result.toeKick.price = widthFt * standards.toeKick.pricePerLF;

      // Build summary string
      const cabinetSummary = result.cabinets
        .sort((a, b) => b.width - a.width)
        .map(c => `${c.count}x ${c.width}"`)
        .join(' + ');
      const fillerSummary = result.fillers.length > 0
        ? ` + ${result.fillers.map(f => `${f.width.toFixed(1)}" filler`).join(', ')}`
        : '';
      result.summary = cabinetSummary + fillerSummary;

      return result;
    }

    // ===== SLAB CALCULATION HELPER =====
    // Calculate how many slabs needed for countertop area
    function calculateSlabRequirement(totalSqft) {
      const slabStandards = TAKEOFF_STANDARDS.slab;
      const grossSqft = totalSqft * (1 + slabStandards.wastePercent / 100);

      // Try standard slab first (most common)
      const standardSlab = slabStandards.standardSizes.find(s => s.name === 'Standard Slab');
      const slabSqft = standardSlab?.sqft || 45.8;

      const slabsNeeded = Math.ceil(grossSqft / slabSqft);

      return {
        netSqft: totalSqft,
        grossSqft: grossSqft,
        wastePercent: slabStandards.wastePercent,
        slabsNeeded: slabsNeeded,
        slabSize: standardSlab?.name || 'Standard Slab',
        slabSqft: slabSqft
      };
    }

    // ===== QUOTE (Enhanced with Full Element Support) =====
    function calculateQuote() {
      const items = {};
      let totalCost = 0;
      let totalRetail = 0;

      // Filler pricing (per linear foot)
      const FILLER_PRICE_PER_LF = 25;
      const MIN_FILLER_WIDTH = 0.125; // 1.5" minimum

      // All countertop types (sqft pricing)
      const COUNTERTOP_TYPES = ['countertop', 'countertop-corner', 'countertop-l', 'countertop-u', 'island'];
      const SQFT_TYPES = [...COUNTERTOP_TYPES, 'backsplash', 'flooring', 'tile'];

      // All cabinet types
      const CABINET_TYPES = [
        'base-cabinet', 'wall-cabinet', 'tall-cabinet', 'corner-cabinet',
        'sink-base', 'drawer-base', 'lazy-susan', 'fridge-cabinet',
        'pantry', 'blind-corner', 'microwave-cabinet',
        'linen-closet', 'linen-tower',
        'base-cabinet-12', 'base-cabinet-15', 'base-cabinet-18', 'base-cabinet-21',
        'base-cabinet-24', 'base-cabinet-27', 'base-cabinet-30', 'base-cabinet-33'
      ];

      // Helper to check if type is a cabinet
      function isCabinetType(type) {
        return CABINET_TYPES.some(ct => type.includes(ct) || type === ct);
      }

      // Process each element
      elements.forEach(el => {
        const priceInfo = getElementPrice(el);
        const margin = getElementMargin(el);

        let baseCost = 0;
        let quantity = 1;
        let unit = el.priceUnit || 'unit';
        let fillerCost = 0;
        let fillerWidth = 0;
        let boxCount = 1;
        let sqft = 0;

        // Determine pricing method based on element type
        const isCountertop = COUNTERTOP_TYPES.some(ct => el.type.includes(ct) || el.type === ct);
        const isSqftType = SQFT_TYPES.some(st => el.type.includes(st) || el.type === st);
        const isCabinet = isCabinetType(el.type);

        if (isCountertop || isSqftType) {
          // Square footage pricing for countertops and surfaces
          sqft = getElementSqft(el);
          baseCost = sqft * priceInfo.price;
          quantity = sqft;
          unit = 'sqft';

          // Add edge pricing for countertops
          if (isCountertop && el.edgeProfile && TAKEOFF_STANDARDS?.edgeProfiles) {
            const edgePrice = TAKEOFF_STANDARDS.edgeProfiles[el.edgeProfile]?.pricePerLF || 0;
            const hasBackWall = !el.overhangBack || el.overhangBack < 0.1;
            const perimeter = (el.width + el.height) * 2;
            const edgeLF = hasBackWall ? perimeter - el.width : perimeter;
            baseCost += edgeLF * edgePrice;
          }
        } else if (isCabinet) {
          // Cabinet pricing - use breakdown for larger runs
          const widthInches = el.width * 12;

          // If cabinet is wider than largest standard (36"), break it down
          if (widthInches > 36) {
            const breakdown = breakdownCabinetRun(el.width, el.type, priceInfo.price);

            // Calculate total cost from breakdown
            baseCost = breakdown.cabinets.reduce((sum, c) => sum + c.priceTotal, 0);
            baseCost += breakdown.fillers.reduce((sum, f) => sum + f.price, 0);
            baseCost += breakdown.toeKick.price;

            boxCount = breakdown.totalCabinets;
            fillerWidth = breakdown.fillers.reduce((sum, f) => sum + f.width, 0) / 12; // Convert to feet
            fillerCost = breakdown.fillers.reduce((sum, f) => sum + f.price, 0);

            quantity = boxCount;
            unit = 'cabinets';

            // Store breakdown details on element for display
            el.breakdown = breakdown;
            el.boxCount = boxCount;
            el.fillerWidth = fillerWidth;
            el.toeKickLF = breakdown.toeKick.lengthLF;
          } else if (el.skuWidth && el.sku) {
            // SKU-based pricing for catalog cabinets
            const actualWidth = el.width;
            const skuWidth = el.skuWidth;

            if (actualWidth > skuWidth * 1.1) {
              boxCount = Math.ceil(actualWidth / skuWidth);
              const remainder = actualWidth - ((boxCount - 1) * skuWidth);
              if (remainder < skuWidth * 0.5 && remainder >= MIN_FILLER_WIDTH) {
                boxCount--;
                fillerWidth = remainder;
                fillerCost = fillerWidth * FILLER_PRICE_PER_LF;
              }
              baseCost = priceInfo.price * boxCount;
              quantity = boxCount;
              unit = 'boxes';
            } else {
              baseCost = priceInfo.price;
              quantity = 1;
              unit = 'unit';
            }
            el.boxCount = boxCount;
            el.fillerWidth = fillerWidth;
          } else {
            // Standard single cabinet pricing
            baseCost = priceInfo.price;
            quantity = 1;
            unit = 'unit';
            el.boxCount = 1;
            el.fillerWidth = 0;

            // Add toe kick for single cabinets too
            const toeKickCost = el.width * TAKEOFF_STANDARDS.cabinet.toeKick.pricePerLF;
            baseCost += toeKickCost;
            el.toeKickLF = el.width;
          }
        } else {
          // Standard unit pricing for appliances, fixtures, etc.
          baseCost = priceInfo.price;
          quantity = 1;
          unit = 'unit';
        }

        const totalBaseCost = baseCost + fillerCost;
        const retailPrice = totalBaseCost * (1 + margin / 100);

        // Store calculated prices on element
        el.costPrice = totalBaseCost;
        el.retailPrice = retailPrice;

        // Create unique key for each item
        // Use element ID for individual tracking, but group by type+material for display
        const materialName = getMaterialName(el.materialId) || el.materialName;
        const widthInches = Math.round(el.width * 12);

        let itemKey, itemLabel;

        if (isCabinet) {
          // Group cabinets by type and width for cleaner display
          const cabinetType = el.type.replace('-cabinet', '').replace('sink-', 'Sink ').replace('drawer-', 'Drawer ');
          itemKey = `cabinet-${el.type}-${widthInches}`;
          itemLabel = el.label || `${cabinetType.charAt(0).toUpperCase() + cabinetType.slice(1)} ${widthInches}"`;
          if (el.sku) {
            itemKey = `cabinet-${el.sku}`;
            itemLabel = el.skuName || el.sku;
          }
        } else if (isCountertop) {
          // Group countertops by material
          itemKey = `countertop-${el.materialId || 'unspecified'}`;
          itemLabel = materialName ? `Countertop (${materialName})` : (el.label || 'Countertop');
        } else if (isSqftType) {
          itemKey = `${el.type}-${el.materialId || 'default'}`;
          itemLabel = materialName ? `${el.label || el.type} (${materialName})` : (el.label || el.type);
        } else {
          // Individual items (appliances, fixtures)
          itemKey = `${el.type}-${el.id}`;
          itemLabel = el.label || el.type;
        }

        if (!items[itemKey]) {
          items[itemKey] = {
            count: 0,
            costTotal: 0,
            retailTotal: 0,
            label: itemLabel,
            sqft: 0,
            linearFt: 0,
            boxCount: 0,
            fillerTotal: 0,
            margin: margin,
            priceSource: priceInfo.source,
            sku: el.sku || null,
            type: el.type,
            isCabinet: isCabinet,
            isCountertop: isCountertop
          };
        }

        items[itemKey].count++;
        items[itemKey].costTotal += totalBaseCost;
        items[itemKey].retailTotal += retailPrice;
        items[itemKey].boxCount += boxCount;
        items[itemKey].fillerTotal += fillerWidth;

        if (unit === 'sqft') {
          items[itemKey].sqft += sqft;
        }
        if (isCabinet) {
          items[itemKey].linearFt += el.width;
        }

        totalCost += totalBaseCost;
        totalRetail += retailPrice;
      });

      // Add filler strips as separate line item if any exist
      const totalFiller = Object.values(items).reduce((sum, item) => sum + item.fillerTotal, 0);
      if (totalFiller > MIN_FILLER_WIDTH) {
        const fillerMargin = 30;
        const fillerCost = totalFiller * FILLER_PRICE_PER_LF;
        const fillerRetail = fillerCost * (1 + fillerMargin / 100);
        items['filler-strips'] = {
          count: 1,
          costTotal: fillerCost,
          retailTotal: fillerRetail,
          label: `Filler Strips (${(totalFiller * 12).toFixed(1)}")`,
          sqft: 0,
          linearFt: totalFiller,
          boxCount: 0,
          fillerTotal: totalFiller,
          margin: fillerMargin,
          priceSource: 'standard',
          sku: 'FILLER',
          type: 'filler',
          isCabinet: false,
          isCountertop: false
        };
        totalCost += fillerCost;
        totalRetail += fillerRetail;
      }

      // Add toe kick as separate line item
      const totalToeKickLF = elements
        .filter(el => CABINET_TYPES.some(ct => el.type.includes(ct) || el.type === ct))
        .reduce((sum, el) => sum + (el.toeKickLF || el.width), 0);
      if (totalToeKickLF > 0) {
        const toeKickMargin = 25;
        const toeKickCost = totalToeKickLF * TAKEOFF_STANDARDS.cabinet.toeKick.pricePerLF;
        const toeKickRetail = toeKickCost * (1 + toeKickMargin / 100);
        items['toe-kick'] = {
          count: 1,
          costTotal: toeKickCost,
          retailTotal: toeKickRetail,
          label: `Toe Kick (${totalToeKickLF.toFixed(1)} LF)`,
          sqft: 0,
          linearFt: totalToeKickLF,
          boxCount: 0,
          fillerTotal: 0,
          margin: toeKickMargin,
          priceSource: 'standard',
          sku: 'TOEKICK',
          type: 'toekick',
          isCabinet: false,
          isCountertop: false
        };
        totalCost += toeKickCost;
        totalRetail += toeKickRetail;
      }

      // Add slab calculation for countertops
      const totalCountertopSqftForSlabs = elements
        .filter(el => COUNTERTOP_TYPES.some(ct => el.type.includes(ct) || el.type === ct))
        .reduce((sum, el) => sum + getElementSqft(el), 0);
      if (totalCountertopSqftForSlabs > 0) {
        const slabCalc = calculateSlabRequirement(totalCountertopSqftForSlabs);
        // Store slab info for display (not as cost item, just informational)
        items['slab-info'] = {
          count: slabCalc.slabsNeeded,
          costTotal: 0, // Material cost already included in countertop pricing
          retailTotal: 0,
          label: `Stone Slabs Needed`,
          sqft: slabCalc.grossSqft,
          linearFt: 0,
          boxCount: 0,
          fillerTotal: 0,
          margin: 0,
          priceSource: 'info',
          sku: 'SLAB-INFO',
          type: 'info',
          isCabinet: false,
          isCountertop: false,
          isInfo: true,
          slabDetails: `${slabCalc.slabsNeeded} ${slabCalc.slabSize}(s) @ ${slabCalc.slabSqft} sqft each (includes ${slabCalc.wastePercent}% waste)`
        };
      }

      // ===== LABOR COSTS CALCULATION =====
      // Calculate labor costs based on user labor rates and takeoffs
      const laborMargin = PRICING_STATE.categoryMargins.labor || PRICING_STATE.globalMargin || 20;
      let totalLaborCost = 0;
      let totalLaborRetail = 0;

      // Get totals from current items for labor calculations
      const totalCountertopSqft = Object.values(items)
        .filter(item => item.isCountertop)
        .reduce((sum, item) => sum + item.sqft, 0);

      const totalCabinetCount = Object.values(items)
        .filter(item => item.isCabinet)
        .reduce((sum, item) => sum + item.count, 0);

      // Stone fabrication labor (if countertops exist)
      if (totalCountertopSqft > 0 && userLaborRates.stone) {
        // Fabrication
        const fabRate = userLaborRates.stone.fabrication?.rate || 0;
        if (fabRate > 0) {
          const fabCost = totalCountertopSqft * fabRate;
          const fabRetail = fabCost * (1 + laborMargin / 100);
          items['labor-fabrication'] = {
            count: 1,
            costTotal: fabCost,
            retailTotal: fabRetail,
            label: `Fabrication (${totalCountertopSqft.toFixed(1)} sqft)`,
            sqft: totalCountertopSqft,
            linearFt: 0,
            boxCount: 0,
            fillerTotal: 0,
            margin: laborMargin,
            priceSource: 'labor',
            sku: 'LABOR-FAB',
            type: 'labor',
            isCabinet: false,
            isCountertop: false,
            isLabor: true
          };
          totalLaborCost += fabCost;
          totalLaborRetail += fabRetail;
        }

        // Installation
        const installRate = userLaborRates.stone.installation?.rate || 0;
        if (installRate > 0) {
          const installCost = totalCountertopSqft * installRate;
          const installRetail = installCost * (1 + laborMargin / 100);
          items['labor-ct-install'] = {
            count: 1,
            costTotal: installCost,
            retailTotal: installRetail,
            label: `Countertop Installation (${totalCountertopSqft.toFixed(1)} sqft)`,
            sqft: totalCountertopSqft,
            linearFt: 0,
            boxCount: 0,
            fillerTotal: 0,
            margin: laborMargin,
            priceSource: 'labor',
            sku: 'LABOR-INST',
            type: 'labor',
            isCabinet: false,
            isCountertop: false,
            isLabor: true
          };
          totalLaborCost += installCost;
          totalLaborRetail += installRetail;
        }

        // Template visit (flat fee if countertops exist)
        const templateRate = userLaborRates.stone.template?.rate || 0;
        if (templateRate > 0) {
          const templateRetail = templateRate * (1 + laborMargin / 100);
          items['labor-template'] = {
            count: 1,
            costTotal: templateRate,
            retailTotal: templateRetail,
            label: 'Template Visit',
            sqft: 0,
            linearFt: 0,
            boxCount: 0,
            fillerTotal: 0,
            margin: laborMargin,
            priceSource: 'labor',
            sku: 'LABOR-TEMP',
            type: 'labor',
            isCabinet: false,
            isCountertop: false,
            isLabor: true
          };
          totalLaborCost += templateRate;
          totalLaborRetail += templateRetail;
        }
      }

      // Cabinet installation labor (if cabinets exist)
      if (totalCabinetCount > 0 && userLaborRates.cabinet) {
        const cabInstallRate = userLaborRates.cabinet.installation?.rate || 0;
        if (cabInstallRate > 0) {
          const cabInstallCost = totalCabinetCount * cabInstallRate;
          const cabInstallRetail = cabInstallCost * (1 + laborMargin / 100);
          items['labor-cab-install'] = {
            count: totalCabinetCount,
            costTotal: cabInstallCost,
            retailTotal: cabInstallRetail,
            label: `Cabinet Installation (${totalCabinetCount} cabinets)`,
            sqft: 0,
            linearFt: 0,
            boxCount: totalCabinetCount,
            fillerTotal: 0,
            margin: laborMargin,
            priceSource: 'labor',
            sku: 'LABOR-CAB',
            type: 'labor',
            isCabinet: false,
            isCountertop: false,
            isLabor: true
          };
          totalLaborCost += cabInstallCost;
          totalLaborRetail += cabInstallRetail;
        }
      }

      // Check for sinks (plumbing labor)
      const sinkItems = elements.filter(el => el.type === 'sink' || el.type.includes('sink'));
      if (sinkItems.length > 0 && userLaborRates.plumbing) {
        const sinkRate = userLaborRates.plumbing.sinkInstall?.rate || 0;
        if (sinkRate > 0) {
          const sinkLaborCost = sinkItems.length * sinkRate;
          const sinkLaborRetail = sinkLaborCost * (1 + laborMargin / 100);
          items['labor-sink-install'] = {
            count: sinkItems.length,
            costTotal: sinkLaborCost,
            retailTotal: sinkLaborRetail,
            label: `Sink Installation (${sinkItems.length})`,
            sqft: 0,
            linearFt: 0,
            boxCount: 0,
            fillerTotal: 0,
            margin: laborMargin,
            priceSource: 'labor',
            sku: 'LABOR-SINK',
            type: 'labor',
            isCabinet: false,
            isCountertop: false,
            isLabor: true
          };
          totalLaborCost += sinkLaborCost;
          totalLaborRetail += sinkLaborRetail;
        }
      }

      // Check for faucets
      const faucetItems = elements.filter(el => el.type === 'faucet' || el.type.includes('faucet'));
      if (faucetItems.length > 0 && userLaborRates.plumbing) {
        const faucetRate = userLaborRates.plumbing.faucetInstall?.rate || 0;
        if (faucetRate > 0) {
          const faucetLaborCost = faucetItems.length * faucetRate;
          const faucetLaborRetail = faucetLaborCost * (1 + laborMargin / 100);
          items['labor-faucet-install'] = {
            count: faucetItems.length,
            costTotal: faucetLaborCost,
            retailTotal: faucetLaborRetail,
            label: `Faucet Installation (${faucetItems.length})`,
            sqft: 0,
            linearFt: 0,
            boxCount: 0,
            fillerTotal: 0,
            margin: laborMargin,
            priceSource: 'labor',
            sku: 'LABOR-FAUCET',
            type: 'labor',
            isCabinet: false,
            isCountertop: false,
            isLabor: true
          };
          totalLaborCost += faucetLaborCost;
          totalLaborRetail += faucetLaborRetail;
        }
      }

      // Add labor totals to grand total
      totalCost += totalLaborCost;
      totalRetail += totalLaborRetail;

      renderQuoteItems(items, totalCost, totalRetail);
    }

    // Throttled version for use in render loop (prevents excessive recalculations)
    const calculateQuoteThrottled = throttle(calculateQuote, 250);

    function renderQuoteItems(items, totalCost, totalRetail) {
      const quoteItems = domCache.quoteItems || document.getElementById('quoteItems');
      const showCost = PRICING_STATE.showCostView;
      const canViewPrices = checkPermission('canViewPrices');
      const canViewCosts = checkPermission('canViewCosts');

      if (Object.keys(items).length === 0) {
        quoteItems.innerHTML = `
          <div class="quote-item">
            <span class="quote-item-name">No items yet</span>
            <span class="quote-item-value">$0</span>
          </div>
        `;
      } else {
        // Sort items: countertops first, then cabinets, then others, then labor
        const sortedItems = Object.entries(items).sort(([, a], [, b]) => {
          // Labor items always last
          if (a.isLabor && !b.isLabor) return 1;
          if (!a.isLabor && b.isLabor) return -1;
          // Countertops first
          if (a.isCountertop && !b.isCountertop) return -1;
          if (!a.isCountertop && b.isCountertop) return 1;
          // Then cabinets
          if (a.isCabinet && !b.isCabinet) return -1;
          if (!a.isCabinet && b.isCabinet) return 1;
          return 0;
        });

        quoteItems.innerHTML = sortedItems.map(([key, data]) => {
          const displayPrice = showCost && canViewCosts ? data.costTotal : data.retailTotal;
          const marginBadge = canViewCosts ? `<span class="margin-badge">${data.margin}%</span>` : '';

          // Build quantity/detail info based on item type
          let quantityInfo = '';
          let detailInfo = '';

          if (data.isCountertop || data.sqft > 0) {
            // Countertops: show sqft
            quantityInfo = data.count > 1 ? `(${data.count} pcs)` : '';
            detailInfo = `<span style="color: #888; font-size: 11px;"> - ${data.sqft.toFixed(1)} sqft</span>`;
          } else if (data.isCabinet) {
            // Cabinets: show breakdown details
            const linearInches = Math.round(data.linearFt * 12);
            if (data.boxCount > 1) {
              // Show cabinet breakdown for runs
              quantityInfo = `(${data.boxCount} cabs)`;
              let breakdownDetail = `${linearInches}" run`;
              if (data.fillerTotal > 0) {
                breakdownDetail += ` + ${(data.fillerTotal * 12).toFixed(1)}" filler`;
              }
              detailInfo = `<span style="color: #888; font-size: 11px;"> - ${breakdownDetail}</span>`;
            } else if (data.count > 1) {
              quantityInfo = `(${data.count})`;
              detailInfo = linearInches > 0 ? `<span style="color: #888; font-size: 11px;"> - ${linearInches}" total</span>` : '';
            } else {
              quantityInfo = '';
              detailInfo = linearInches > 0 ? `<span style="color: #888; font-size: 11px;"> - ${linearInches}"</span>` : '';
            }
          } else {
            // Other items
            quantityInfo = data.count > 1 ? `(${data.count})` : '';
          }

          if (!canViewPrices) {
            return `
              <div class="quote-item">
                <span class="quote-item-name">${data.label} ${quantityInfo}${detailInfo}</span>
              </div>
            `;
          }

          // Determine styling based on item type
          let itemStyle = '';
          let itemPrefix = '';
          if (data.isCountertop) {
            itemStyle = 'background: rgba(249,203,0,0.05); border-left: 2px solid var(--gold-primary);';
          } else if (data.isLabor) {
            itemStyle = 'background: rgba(99,102,241,0.05); border-left: 2px solid var(--primary);';
            itemPrefix = '<span style="color: var(--primary); font-size: 10px; margin-right: 6px;"></span>';
          } else if (data.isInfo) {
            // Info-only items (like slab count)
            itemStyle = 'background: rgba(100,149,237,0.05); border-left: 2px solid cornflowerblue; font-style: italic;';
            return `
              <div class="quote-item" style="${itemStyle}">
                <span class="quote-item-name" style="font-size: 11px;">
                  <span style="color: cornflowerblue;"></span> ${data.label}: ${data.count}
                  <br><span style="color: #888; font-size: 10px;">${data.slabDetails || ''}</span>
                </span>
              </div>
            `;
          } else if (data.type === 'filler' || data.type === 'toekick') {
            itemStyle = 'background: rgba(139,69,19,0.05); border-left: 2px solid #8B4513;';
            itemPrefix = '<span style="color: #8B4513; font-size: 10px; margin-right: 6px;"></span>';
          }

          return `
            <div class="quote-item" style="${itemStyle}">
              <span class="quote-item-name">
                ${itemPrefix}${data.label} ${quantityInfo}${detailInfo}
                ${marginBadge}
              </span>
              <span class="quote-item-value">
                $${displayPrice.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2})}
              </span>
            </div>
          `;
        }).join('');
      }

      // Update totals
      const displayTotal = showCost && canViewCosts ? totalCost : totalRetail;
      const quoteTotalEl = document.getElementById('quoteTotal');
      if (quoteTotalEl) {
        quoteTotalEl.textContent = canViewPrices
          ? '$' + displayTotal.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2})
          : '---';
      }

      // Show/hide cost breakdown
      const costRow = document.getElementById('quoteCostRow');
      const marginRow = document.getElementById('quoteMarginRow');

      if (costRow && marginRow) {
        if (canViewCosts) {
          costRow.style.display = 'flex';
          marginRow.style.display = 'flex';
          document.getElementById('quoteCost').textContent = '$' + totalCost.toLocaleString(undefined, {minimumFractionDigits: 2});
          document.getElementById('quoteMargin').textContent = '$' + (totalRetail - totalCost).toLocaleString(undefined, {minimumFractionDigits: 2});
        } else {
          costRow.style.display = 'none';
          marginRow.style.display = 'none';
        }
      }

      // Store quote total for payment processing and show/hide checkout button
      window.currentQuoteTotal = totalRetail;
      window.currentQuoteCost = totalCost;
      const quoteActions = document.getElementById('quoteActions');
      if (quoteActions) {
        quoteActions.style.display = totalRetail > 0 ? 'block' : 'none';
      }

      // Update quick takeoff stats
      updateQuickTakeoffStats();
    }

    // Update the quick takeoff stats in the sidebar
    function updateQuickTakeoffStats() {
      const takeoffs = calculateTakeoffs();
      const statsDiv = document.getElementById('takeoffQuickStats');
      const slabCount = document.getElementById('quickSlabCount');
      const cabinetCount = document.getElementById('quickCabinetCount');

      if (statsDiv && slabCount && cabinetCount) {
        const hasElements = takeoffs.stone.slabsNeeded > 0 || takeoffs.cabinets.totalCount > 0;
        statsDiv.style.display = hasElements ? 'block' : 'none';
        slabCount.textContent = takeoffs.stone.slabsNeeded || 0;
        cabinetCount.textContent = takeoffs.cabinets.totalCount || 0;
      }
    }

    // ============ PAYMENT PROCESSING ============

    const STRIPE_PUBLIC_KEY = 'pk_live_51Smr3E3qDbNyHFmdPLN9iXM3rMQv6hKNtXEP5yVpZVRHBFZ5xk0jKvPy4kQMQ6yHVzXSzVBBZlP8rMGKK9TyZ7qJ00q0Y3nKpN';
    const API_BASE = 'https://surprise-granite-email-api.onrender.com';
    let selectedPaymentOption = 'deposit';
    let stripeInstance = null;

    function openPaymentModal() {
      const total = window.currentQuoteTotal || 0;
      if (total <= 0) {
        showToast('Add items to your design before checkout', 'error');
        return;
      }

      // Initialize Stripe if not already
      if (!stripeInstance && typeof Stripe !== 'undefined') {
        stripeInstance = Stripe(STRIPE_PUBLIC_KEY);
      }

      // Calculate payment amounts
      const depositAmount = Math.max(99, total * 0.1); // 10% or minimum $99
      const discountedFull = total * 0.95; // 5% discount for full payment

      // Update modal values
      document.getElementById('paymentDesignName').textContent = document.getElementById('projectName')?.value || 'Kitchen Design';

      // Find primary countertop material
      const countertop = elements.find(el => el.type === 'countertop' && el.materialName);
      document.getElementById('paymentMaterial').textContent = countertop?.materialName || 'Various materials';

      // Calculate total square footage of countertops (includes L and U shapes)
      const countertopSqft = elements
        .filter(el => el.type === 'countertop' || el.type === 'countertop-l' || el.type === 'countertop-u')
        .reduce((sum, el) => sum + getElementSqft(el), 0);
      document.getElementById('paymentSqft').textContent = countertopSqft > 0 ? `${countertopSqft.toFixed(1)} sq ft` : '-';

      document.getElementById('paymentTotal').textContent = '$' + total.toLocaleString(undefined, {minimumFractionDigits: 2});
      document.getElementById('depositAmount').textContent = '$' + depositAmount.toLocaleString(undefined, {minimumFractionDigits: 2});
      document.getElementById('fullAmount').textContent = '$' + discountedFull.toLocaleString(undefined, {minimumFractionDigits: 2});

      // Pre-fill email if user is logged in
      if (window.currentUser?.email) {
        document.getElementById('paymentEmail').value = window.currentUser.email;
      }

      // Reset selection to deposit
      selectPaymentOption('deposit');

      // Show modal
      document.getElementById('paymentModal').style.display = 'flex';
    }

    function closePaymentModal() {
      document.getElementById('paymentModal').style.display = 'none';
    }

    // Close modal when clicking outside
    document.addEventListener('click', (e) => {
      const modal = document.getElementById('paymentModal');
      if (e.target === modal) {
        closePaymentModal();
      }
    });

    function selectPaymentOption(option) {
      selectedPaymentOption = option;
      const total = window.currentQuoteTotal || 0;

      // Update UI
      document.querySelectorAll('.payment-option').forEach(el => el.classList.remove('selected'));
      document.getElementById('option' + option.charAt(0).toUpperCase() + option.slice(1))?.classList.add('selected');

      // Update button text
      const btnText = document.getElementById('paymentBtnText');
      switch(option) {
        case 'deposit':
          const depositAmt = Math.max(99, total * 0.1);
          btnText.textContent = `Pay $${depositAmt.toFixed(2)} Deposit`;
          break;
        case 'consultation':
          btnText.textContent = 'Pay $99 Consultation Fee';
          break;
        case 'full':
          const fullAmt = total * 0.95;
          btnText.textContent = `Pay $${fullAmt.toLocaleString(undefined, {minimumFractionDigits: 2})} (5% off)`;
          break;
      }
    }

    async function processPayment() {
      const email = document.getElementById('paymentEmail').value.trim();
      const phone = document.getElementById('paymentPhone').value.trim();

      if (!email || !email.includes('@')) {
        showToast('Please enter a valid email address', 'error');
        document.getElementById('paymentEmail').focus();
        return;
      }

      const btn = document.getElementById('paymentSubmitBtn');
      const btnText = document.getElementById('paymentBtnText');
      const originalText = btnText.textContent;

      btn.disabled = true;
      btnText.textContent = 'Processing...';

      try {
        const total = window.currentQuoteTotal || 0;
        let amount = 0;
        let itemName = '';
        let description = '';

        switch(selectedPaymentOption) {
          case 'deposit':
            amount = Math.max(99, total * 0.1);
            itemName = 'Design Deposit (10%)';
            description = `Deposit for project: ${document.getElementById('projectName')?.value || 'Kitchen Design'}`;
            break;
          case 'consultation':
            amount = 99;
            itemName = 'Design Consultation';
            description = 'In-home or virtual design consultation';
            break;
          case 'full':
            amount = total * 0.95;
            itemName = 'Full Project Payment (5% discount)';
            description = `Full payment for project: ${document.getElementById('projectName')?.value || 'Kitchen Design'}`;
            break;
        }

        // Save design to localStorage/Supabase before checkout
        const designData = {
          name: document.getElementById('projectName')?.value || 'Kitchen Design',
          roomWidth,
          roomDepth,
          roomHeight,
          elements: JSON.parse(JSON.stringify(elements)),
          quoteTotal: total,
          paymentOption: selectedPaymentOption,
          paymentAmount: amount,
          customerEmail: email,
          customerPhone: phone,
          createdAt: new Date().toISOString()
        };

        // Store design reference for after payment
        localStorage.setItem('sg_pending_design', JSON.stringify(designData));

        // Create checkout session
        const response = await fetch(`${API_BASE}/api/create-checkout-session`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            items: [{
              name: itemName,
              price: Math.round(amount * 100), // Convert to cents
              quantity: 1,
              image: ''
            }],
            customer_email: email,
            success_url: `${window.location.origin}/tools/room-designer/?payment=success&session_id={CHECKOUT_SESSION_ID}`,
            cancel_url: `${window.location.origin}/tools/room-designer/?payment=canceled`,
            metadata: {
              order_source: 'room_designer',
              payment_type: selectedPaymentOption,
              project_total: total.toString(),
              phone: phone
            }
          })
        });

        const data = await response.json();

        if (data.error) {
          throw new Error(data.error);
        }

        // Redirect to Stripe Checkout
        if (data.url) {
          window.location.href = data.url;
        } else if (data.sessionId && stripeInstance) {
          const result = await stripeInstance.redirectToCheckout({ sessionId: data.sessionId });
          if (result.error) {
            throw new Error(result.error.message);
          }
        }

      } catch (error) {
        console.error('Payment error:', error);
        showToast('Payment failed: ' + error.message, 'error');
        btn.disabled = false;
        btnText.textContent = originalText;
      }
    }

    // Approve and Pay - for quote_approval permission
    window.approveAndPay = async function() {
      const btn = document.querySelector('.approve-pay-btn');
      if (!btn) return;

      const originalContent = btn.innerHTML;
      btn.disabled = true;
      btn.innerHTML = `
        <svg class="spinner" viewBox="0 0 24 24" style="width:20px;height:20px;margin-right:8px;animation:spin 1s linear infinite;">
          <circle cx="12" cy="12" r="10" stroke="currentColor" stroke-width="3" fill="none" stroke-dasharray="32" stroke-linecap="round"/>
        </svg>
        Processing...
      `;

      try {
        // Calculate quote total
        const total = calculateQuoteTotal();
        const depositAmount = total * 0.5; // 50% deposit

        if (depositAmount < 1) {
          throw new Error('Quote total is too low for payment');
        }

        // Get project name and share info
        const projectName = document.querySelector('.review-title')?.textContent || 'Design Project';
        const shareId = SHARE_STATE.shareId || window.location.pathname.split('/').pop() || 'unknown';

        // Prompt for email if not already known
        let customerEmail = SHARE_STATE.customerEmail || '';
        if (!customerEmail) {
          customerEmail = prompt('Please enter your email address for order confirmation:');
          if (!customerEmail || !customerEmail.includes('@')) {
            throw new Error('Valid email required to proceed');
          }
        }

        // Create design data for record-keeping
        const approvalData = {
          shareId: shareId,
          projectName: projectName,
          roomWidth,
          roomDepth,
          roomHeight,
          elements: JSON.parse(JSON.stringify(elements)),
          quoteTotal: total,
          depositAmount: depositAmount,
          customerEmail: customerEmail,
          approvedAt: new Date().toISOString(),
          status: 'pending_payment'
        };

        // Store approval reference for after payment
        localStorage.setItem('sg_pending_approval', JSON.stringify(approvalData));

        // Create checkout session for deposit
        const response = await fetch(`${API_BASE}/api/create-checkout-session`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            items: [{
              name: `Design Approval Deposit - ${projectName}`,
              price: Math.round(depositAmount * 100), // Convert to cents
              quantity: 1,
              image: ''
            }],
            customer_email: customerEmail,
            success_url: `${window.location.origin}/tools/room-designer/?approval=success&share_id=${shareId}&session_id={CHECKOUT_SESSION_ID}`,
            cancel_url: `${window.location.href}`,
            metadata: {
              order_source: 'room_designer_approval',
              payment_type: 'quote_approval_deposit',
              share_id: shareId,
              project_name: projectName,
              project_total: total.toString(),
              deposit_amount: depositAmount.toString()
            }
          })
        });

        const data = await response.json();

        if (data.error) {
          throw new Error(data.error);
        }

        // Mark design as approved before redirect
        try {
          await updateShareStatus(shareId, 'approved_pending_payment');
        } catch (e) {
          console.log('Could not update share status:', e);
        }

        // Redirect to Stripe Checkout
        if (data.url) {
          window.location.href = data.url;
        } else if (data.sessionId && stripeInstance) {
          const result = await stripeInstance.redirectToCheckout({ sessionId: data.sessionId });
          if (result.error) {
            throw new Error(result.error.message);
          }
        }

      } catch (error) {
        console.error('Approval payment error:', error);
        showToast('Payment failed: ' + error.message, 'error');
        btn.disabled = false;
        btn.innerHTML = originalContent;
      }
    };

    // Update share status in Supabase
    async function updateShareStatus(shareId, status) {
      if (!shareId) return;

      try {
        const supabaseClient = getSupabaseClient();
        if (!supabaseClient) return;

        await supabaseClient
          .from('room_designer_shares')
          .update({
            status: status,
            approved_at: status.includes('approved') ? new Date().toISOString() : null
          })
          .eq('share_id', shareId);

        console.log('Share status updated to:', status);
      } catch (e) {
        console.error('Error updating share status:', e);
      }
    }

    // Check for approval success on page load
    function checkApprovalStatus() {
      const params = new URLSearchParams(window.location.search);
      const approvalStatus = params.get('approval');
      const shareId = params.get('share_id');
      const sessionId = params.get('session_id');

      if (approvalStatus === 'success' && shareId) {
        // Clear the URL params
        window.history.replaceState({}, document.title, window.location.pathname);

        // Load the pending approval data
        const pendingApproval = localStorage.getItem('sg_pending_approval');
        if (pendingApproval) {
          const approvalData = JSON.parse(pendingApproval);
          localStorage.removeItem('sg_pending_approval');

          // Update share status to fully approved
          updateShareStatus(shareId, 'approved_paid');

          // Show success message
          showToast('Design approved and deposit paid successfully!', 'success');

          // Show confirmation modal
          showApprovalConfirmation(approvalData);
        } else {
          showToast('Design approved! Thank you for your payment.', 'success');
        }
      }
    }

    // Show approval confirmation modal
    function showApprovalConfirmation(approvalData) {
      const modal = document.createElement('div');
      modal.className = 'approval-confirmation-modal';
      modal.innerHTML = `
        <div class="approval-confirmation-content">
          <div class="approval-success-icon">
            <svg viewBox="0 0 24 24" fill="none" stroke="#22c55e" stroke-width="2" style="width:64px;height:64px;">
              <path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/>
              <polyline points="22 4 12 14.01 9 11.01"/>
            </svg>
          </div>
          <h2>Design Approved!</h2>
          <p>Thank you for approving your design.</p>
          <div class="approval-details">
            <div class="approval-detail">
              <span class="label">Project:</span>
              <span class="value">${approvalData.projectName || 'Kitchen Design'}</span>
            </div>
            <div class="approval-detail">
              <span class="label">Deposit Paid:</span>
              <span class="value">$${(approvalData.depositAmount || 0).toFixed(2)}</span>
            </div>
            <div class="approval-detail">
              <span class="label">Remaining Balance:</span>
              <span class="value">$${((approvalData.quoteTotal || 0) - (approvalData.depositAmount || 0)).toFixed(2)}</span>
            </div>
          </div>
          <p class="approval-next-steps">Our team will contact you within 24 hours to schedule your project.</p>
          <button class="btn btn-primary" onclick="this.closest('.approval-confirmation-modal').remove()">Close</button>
        </div>
      `;
      document.body.appendChild(modal);

      // Add styles if not present
      if (!document.getElementById('approval-confirmation-styles')) {
        const style = document.createElement('style');
        style.id = 'approval-confirmation-styles';
        style.textContent = `
          .approval-confirmation-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.6);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
          }
          .approval-confirmation-content {
            background: white;
            border-radius: 16px;
            padding: 32px;
            max-width: 400px;
            text-align: center;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
          }
          .approval-success-icon {
            margin-bottom: 16px;
          }
          .approval-confirmation-content h2 {
            margin: 0 0 8px 0;
            color: #22c55e;
          }
          .approval-details {
            background: #f5f5f7;
            border-radius: 8px;
            padding: 16px;
            margin: 16px 0;
            text-align: left;
          }
          .approval-detail {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #e5e5e5;
          }
          .approval-detail:last-child {
            border-bottom: none;
          }
          .approval-detail .label {
            color: #666;
          }
          .approval-detail .value {
            font-weight: 600;
          }
          .approval-next-steps {
            color: #666;
            font-size: 13px;
            margin: 16px 0;
          }
        `;
        document.head.appendChild(style);
      }
    }

    // Check for payment success/cancel on page load
    function checkPaymentStatus() {
      const params = new URLSearchParams(window.location.search);
      const paymentStatus = params.get('payment');
      const sessionId = params.get('session_id');

      if (paymentStatus === 'success') {
        // Clear the URL params
        window.history.replaceState({}, document.title, window.location.pathname);

        // Load the pending design
        const pendingDesign = localStorage.getItem('sg_pending_design');
        if (pendingDesign) {
          try {
            const design = JSON.parse(pendingDesign);
            showToast(`Payment successful! Your ${design.paymentOption === 'deposit' ? 'deposit' : 'payment'} has been processed.`, 'success');

            // Save design to Supabase with payment reference
            if (window.supabaseClient) {
              saveDesignWithPayment(design, sessionId);
            }

            localStorage.removeItem('sg_pending_design');
          } catch (e) {
            showToast('Payment successful!', 'success');
          }
        } else {
          showToast('Payment successful! Thank you for your order.', 'success');
        }
      } else if (paymentStatus === 'canceled') {
        window.history.replaceState({}, document.title, window.location.pathname);
        showToast('Payment was canceled. Your design has been saved.', 'info');
      }
    }

    async function saveDesignWithPayment(design, sessionId) {
      try {
        const { data: { session } } = await window.supabaseClient.auth.getSession();

        const designRecord = {
          name: design.name,
          user_id: session?.user?.id || null,
          customer_email: design.customerEmail,
          customer_phone: design.customerPhone,
          room_data: {
            width: design.roomWidth,
            depth: design.roomDepth,
            height: design.roomHeight,
            elements: design.elements
          },
          quote_total: design.quoteTotal,
          payment_type: design.paymentOption,
          payment_amount: design.paymentAmount,
          stripe_session_id: sessionId,
          status: 'paid_deposit',
          created_at: design.createdAt
        };

        // Insert into designs table (if it exists)
        const { error } = await window.supabaseClient
          .from('room_designs')
          .insert([designRecord]);

        if (error) {
          console.log('Design save note:', error.message);
          // Table might not exist yet - that's okay
        } else {
          console.log('Design saved with payment reference');
        }
      } catch (e) {
        console.log('Design save skipped:', e.message);
      }
    }

    // Call on page load
    document.addEventListener('DOMContentLoaded', () => {
      checkPaymentStatus();
      checkApprovalStatus();
    });

    function generateQuote() {
      const projectName = document.getElementById('projectName').value;
      const roomType = document.getElementById('roomType').value;

      let text = `QUOTE: ${projectName}\nRoom: ${roomType} (${roomWidth}'  ${roomDepth}')\n${'='.repeat(30)}\n\n`;
      elements.forEach(el => {
        text += `${el.label}: ${el.width}'  ${el.height}'\n`;
      });
      text += `\n${'='.repeat(30)}\nTotal: ${document.getElementById('quoteTotal').textContent}`;

      alert(text);
    }

    // ===== MODALS =====
    function openShareModal() {
      const modal = document.getElementById('shareModal');
      modal.style.display = ''; // Reset inline display style
      modal.classList.add('active');
      // Load active shares if we have a design ID
      if (SHARE_STATE.designId) {
        loadActiveShares();
      }
    }

    // Track which element had focus before modal opened
    let previousFocusElement = null;

    function openModal(id) {
      const modal = document.getElementById(id);
      if (!modal) return;

      // Store the currently focused element
      previousFocusElement = document.activeElement;

      modal.style.display = ''; // Reset any inline display style
      modal.classList.add('active');

      // Focus the first focusable element in the modal
      requestAnimationFrame(() => {
        const focusable = modal.querySelector('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])');
        if (focusable) focusable.focus();
      });

      // Add escape key handler for this modal
      modal._escHandler = (e) => {
        if (e.key === 'Escape' && modal.classList.contains('active')) {
          closeModal(id);
        }
      };
      document.addEventListener('keydown', modal._escHandler);
    }

    function closeModal(id) {
      const modal = document.getElementById(id);
      if (!modal) return;
      // Don't allow closing if it's a required modal (for auth)
      if (modal.getAttribute('data-required') === 'true') {
        return;
      }
      modal.classList.remove('active');
      // Reset inline display style so CSS class controls visibility
      modal.style.display = '';

      // Remove escape handler
      if (modal._escHandler) {
        document.removeEventListener('keydown', modal._escHandler);
        modal._escHandler = null;
      }

      // Restore focus to previous element
      if (previousFocusElement && previousFocusElement.focus) {
        previousFocusElement.focus();
        previousFocusElement = null;
      }
    }

    // ===== EDGE PREVIEW MODAL =====
    let edgePreviewScene, edgePreviewCamera, edgePreviewRenderer, edgePreviewControls;
    let edgePreviewElement = null;
    let edgePreviewAnimationId = null;

    function showEdgePreviewModal(element) {
      edgePreviewElement = element;

      const modal = document.getElementById('edgePreviewModal');
      modal.classList.add('active');

      // Update UI with current element settings
      const profile = element.edgeProfile || 'eased';
      const thickness = element.thickness || '3cm';

      document.getElementById('edgeProfileName').textContent = getEdgeProfileLabel(profile);
      document.getElementById('edgeProfileSelect').value = profile;

      // Initialize thickness toggle button states
      const btn2cm = document.getElementById('thickness2cmBtn');
      const btn3cm = document.getElementById('thickness3cmBtn');
      if (thickness === '2cm') {
        btn2cm.style.background = 'var(--gold)';
        btn2cm.style.color = '#000';
        btn3cm.style.background = 'transparent';
        btn3cm.style.color = 'var(--text-muted)';
      } else {
        btn3cm.style.background = 'var(--gold)';
        btn3cm.style.color = '#000';
        btn2cm.style.background = 'transparent';
        btn2cm.style.color = 'var(--text-muted)';
      }

      // Initialize or update 3D preview
      setTimeout(() => initEdgePreview3D(element), 100);
    }

    function getEdgeProfileLabel(profile) {
      const labels = {
        'eased': 'Eased',
        'pencil': 'Pencil Round',
        'quarter-round': 'Quarter Round',
        'half-bullnose': 'Half Bullnose',
        'demi-bullnose': 'Half Bullnose',
        'full-bullnose': 'Full Bullnose',
        'bevel': 'Bevel',
        'quarter-bevel': 'Quarter Bevel',
        'ogee': 'Ogee',
        'double-ogee': 'Double Ogee',
        'cove': 'Cove',
        'dupont': 'Dupont',
        'mitered': 'Mitered',
        'waterfall': 'Waterfall',
        'flat-polish': 'Flat Polish',
        'square': 'Square Edge',
        'chiseled': 'Chiseled'
      };
      return labels[profile] || profile;
    }

    function initEdgePreview3D(element) {
      const container = document.getElementById('edgePreview3D');
      if (!container) return;

      // Clear existing
      if (edgePreviewRenderer) {
        container.innerHTML = '';
        if (edgePreviewAnimationId) {
          cancelAnimationFrame(edgePreviewAnimationId);
        }
      }

      // Scene setup
      edgePreviewScene = new THREE.Scene();
      edgePreviewScene.background = new THREE.Color(0x1a1a2e);

      // Camera - positioned to show the edge profile clearly from the front-right
      const aspect = container.clientWidth / container.clientHeight;
      edgePreviewCamera = new THREE.PerspectiveCamera(35, aspect, 0.01, 50);
      // Position camera to view the front edge profile - from front-right, slightly above
      // Looking at the front edge of the countertop to see the profile shape
      edgePreviewCamera.position.set(0.8, 0.4, 1.8);
      edgePreviewCamera.lookAt(0, 0.05, 0.3);

      // Renderer
      edgePreviewRenderer = new THREE.WebGLRenderer({ antialias: true });
      edgePreviewRenderer.setSize(container.clientWidth, container.clientHeight);
      edgePreviewRenderer.shadowMap.enabled = true;
      edgePreviewRenderer.toneMapping = THREE.ACESFilmicToneMapping;
      edgePreviewRenderer.toneMappingExposure = 1.2;
      container.appendChild(edgePreviewRenderer.domElement);

      // Controls - enable zoom and pan for exploring the edge
      edgePreviewControls = new THREE.OrbitControls(edgePreviewCamera, edgePreviewRenderer.domElement);
      edgePreviewControls.enableDamping = true;
      edgePreviewControls.dampingFactor = 0.05;
      // Target the front edge of the countertop
      edgePreviewControls.target.set(0, 0.05, 0.3);
      edgePreviewControls.enableZoom = true;
      edgePreviewControls.minDistance = 0.5;
      edgePreviewControls.maxDistance = 5.0;

      // Enhanced lighting for edge visibility
      const ambient = new THREE.AmbientLight(0xffffff, 0.6);
      edgePreviewScene.add(ambient);

      // Key light from front-right to illuminate the edge profile
      const keyLight = new THREE.DirectionalLight(0xffffff, 1.2);
      keyLight.position.set(2, 3, 4);
      keyLight.castShadow = true;
      edgePreviewScene.add(keyLight);

      // Fill light from opposite side
      const fillLight = new THREE.DirectionalLight(0xffffff, 0.5);
      fillLight.position.set(-3, 2, -2);
      edgePreviewScene.add(fillLight);

      // Rim light from behind to highlight the edge curve
      const rimLight = new THREE.DirectionalLight(0xffffff, 0.4);
      rimLight.position.set(0, 1, -3);
      edgePreviewScene.add(rimLight);

      // Create edge profile sample
      createEdgePreviewMesh(element);

      // Animation loop
      function animate() {
        edgePreviewAnimationId = requestAnimationFrame(animate);
        edgePreviewControls.update();
        edgePreviewRenderer.render(edgePreviewScene, edgePreviewCamera);
      }
      animate();
    }

    function createEdgePreviewMesh(element) {
      // Remove old meshes
      const oldMesh = edgePreviewScene.getObjectByName('edgeSample');
      if (oldMesh) edgePreviewScene.remove(oldMesh);
      const oldGroup = edgePreviewScene.getObjectByName('edgeGroup');
      if (oldGroup) edgePreviewScene.remove(oldGroup);

      const profile = element.edgeProfile || 'eased';
      const thickness = element.thickness || '3cm';
      const is2cm = thickness === '2cm';
      const color = parseInt(element.color?.replace('#', '') || '708090', 16);
      const textureUrl = element.texture || null;

      // Create material with nice stone-like appearance
      let material;
      if (textureUrl) {
        const textureLoader = new THREE.TextureLoader();
        const texture = textureLoader.load(textureUrl);
        texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
        texture.repeat.set(0.5, 0.5);
        material = new THREE.MeshStandardMaterial({
          map: texture,
          roughness: 0.25,
          metalness: 0.05
        });
      } else {
        material = new THREE.MeshStandardMaterial({
          color: color,
          roughness: 0.25,
          metalness: 0.05
        });
      }

      const group = new THREE.Group();
      group.name = 'edgeGroup';

      // Countertop slab dimensions
      const slabWidth = 2.0;   // Width (left to right)
      const slabDepth = 1.2;   // Depth (front to back)
      // Thickness: 3cm = ~1.2", 2cm = ~0.8" (scaled up for visibility)
      const slabThickness = is2cm ? 0.08 : 0.12;
      const t = slabThickness;
      const frontX = slabDepth * 0.3; // Front edge position

      // For waterfall, create special visualization
      if (profile === 'waterfall') {
        // MITERED WATERFALL - like mitered drop edge but turns 90 vertical
        // Pieces are JOINED together with 45 seam at corner

        const waterfallDrop = 0.7;

        // HORIZONTAL SLAB (same as mitered edge)
        const slabGeo = new THREE.BoxGeometry(slabWidth, t, slabDepth);
        const slab = new THREE.Mesh(slabGeo, material);
        slab.position.y = t / 2;
        slab.castShadow = true;
        group.add(slab);

        // VERTICAL WATERFALL - back touches slab front, top at y=t
        const wfGeo = new THREE.BoxGeometry(slabWidth, waterfallDrop, t);
        const wfPanel = new THREE.Mesh(wfGeo, material);
        wfPanel.position.set(0, t - waterfallDrop / 2, slabDepth / 2 + t / 2);
        wfPanel.castShadow = true;
        group.add(wfPanel);

        // 45 MITER SEAM at corner
        const seamMat = new THREE.MeshStandardMaterial({
          color: 0x444444, roughness: 0.6, transparent: true, opacity: 0.5
        });
        const seamDiag = t * Math.SQRT2;
        const seamGeo = new THREE.BoxGeometry(slabWidth + 0.01, 0.002, seamDiag);
        const seam = new THREE.Mesh(seamGeo, seamMat);
        seam.rotation.x = -Math.PI / 4;
        seam.position.set(0, t / 2, slabDepth / 2 + t / 2);
        group.add(seam);

        group.position.set(-slabWidth / 2, 0, -slabDepth / 2 + 0.15);
        edgePreviewScene.add(group);
        return;
      }

      // Create the main slab body
      const slabGeometry = new THREE.BoxGeometry(slabWidth, t, slabDepth);
      const slab = new THREE.Mesh(slabGeometry, material);
      slab.position.y = t / 2;
      slab.castShadow = true;
      slab.receiveShadow = true;
      group.add(slab);

      // Create the front edge profile using extrusion
      const edgeShape = new THREE.Shape();

      // Define edge profiles - cross-section viewed from the side
      // X = depth (into slab), Y = height (thickness)
      switch(profile) {
        case 'flat-polish':
        case 'square': {
          // Perfectly square edge with polished face - no rounding
          edgeShape.moveTo(0, 0);
          edgeShape.lineTo(frontX, 0);
          edgeShape.lineTo(frontX, t);
          edgeShape.lineTo(0, t);
          break;
        }
        case 'pencil': {
          // Very small radius on top corner only (~1/16")
          const r = t * 0.08;
          edgeShape.moveTo(0, 0);
          edgeShape.lineTo(frontX, 0);
          edgeShape.lineTo(frontX, t - r);
          edgeShape.quadraticCurveTo(frontX, t, frontX - r, t);
          edgeShape.lineTo(0, t);
          break;
        }
        case 'eased': {
          // Small rounded ease on top corner (~1/8" radius)
          const r = t * 0.12;
          edgeShape.moveTo(0, 0);
          edgeShape.lineTo(frontX, 0);
          edgeShape.lineTo(frontX, t - r);
          edgeShape.quadraticCurveTo(frontX, t, frontX - r, t);
          edgeShape.lineTo(0, t);
          break;
        }
        case 'quarter-round': {
          // Quarter-circle on top corner only
          const r = t * 0.3;
          edgeShape.moveTo(0, 0);
          edgeShape.lineTo(frontX, 0);
          edgeShape.lineTo(frontX, t - r);
          // Quarter arc from vertical to horizontal
          edgeShape.absarc(frontX - r, t - r, r, 0, Math.PI / 2, false);
          edgeShape.lineTo(0, t);
          break;
        }
        case 'half-bullnose':
        case 'demi-bullnose': {
          // Rounded top half, flat/square bottom
          // The front face curves from top surface, bottom edge is square
          const r = t * 0.5;
          edgeShape.moveTo(0, 0);
          edgeShape.lineTo(frontX, 0); // Flat bottom edge
          edgeShape.lineTo(frontX, t * 0.5); // Halfway up, still flat
          // Arc from halfway to top
          edgeShape.absarc(frontX - r, t * 0.5, r, 0, Math.PI / 2, false);
          edgeShape.lineTo(0, t);
          break;
        }
        case 'full-bullnose': {
          // Complete semicircle - both top and bottom rounded
          // The entire front edge is a half-cylinder
          const r = t * 0.5;
          const centerY = t / 2;
          edgeShape.moveTo(0, 0);
          edgeShape.lineTo(frontX - r, 0); // To arc start
          // Full semicircle from bottom to top
          edgeShape.absarc(frontX - r, centerY, r, -Math.PI / 2, Math.PI / 2, false);
          edgeShape.lineTo(0, t);
          break;
        }
        case 'ogee': {
          // Classic S-curve: concave cove at top, convex bullnose below
          edgeShape.moveTo(0, 0);
          edgeShape.lineTo(frontX, 0);
          // Lower convex curve (bullnose portion)
          edgeShape.bezierCurveTo(
            frontX + t * 0.15, t * 0.15,
            frontX + t * 0.15, t * 0.35,
            frontX, t * 0.5
          );
          // Upper concave curve (cove portion)
          edgeShape.bezierCurveTo(
            frontX - t * 0.1, t * 0.65,
            frontX - t * 0.1, t * 0.85,
            frontX - t * 0.05, t
          );
          edgeShape.lineTo(0, t);
          break;
        }
        case 'double-ogee': {
          // Two S-curves stacked
          edgeShape.moveTo(0, 0);
          edgeShape.lineTo(frontX, 0);
          // First ogee (lower)
          edgeShape.bezierCurveTo(
            frontX + t * 0.08, t * 0.08,
            frontX + t * 0.08, t * 0.17,
            frontX, t * 0.25
          );
          edgeShape.bezierCurveTo(
            frontX - t * 0.06, t * 0.32,
            frontX - t * 0.06, t * 0.42,
            frontX, t * 0.5
          );
          // Second ogee (upper)
          edgeShape.bezierCurveTo(
            frontX + t * 0.08, t * 0.58,
            frontX + t * 0.08, t * 0.67,
            frontX, t * 0.75
          );
          edgeShape.bezierCurveTo(
            frontX - t * 0.06, t * 0.82,
            frontX - t * 0.06, t * 0.92,
            frontX - t * 0.03, t
          );
          edgeShape.lineTo(0, t);
          break;
        }
        case 'bevel':
        case 'quarter-bevel': {
          // 45-degree chamfer on top corner
          const bevelSize = t * 0.25;
          edgeShape.moveTo(0, 0);
          edgeShape.lineTo(frontX, 0);
          edgeShape.lineTo(frontX, t - bevelSize);
          edgeShape.lineTo(frontX - bevelSize, t);
          edgeShape.lineTo(0, t);
          break;
        }
        case 'cove': {
          // Concave (inward) curve on front face
          edgeShape.moveTo(0, 0);
          edgeShape.lineTo(frontX, 0);
          edgeShape.lineTo(frontX, t * 0.3);
          edgeShape.quadraticCurveTo(frontX - t * 0.3, t * 0.5, frontX - t * 0.1, t);
          edgeShape.lineTo(0, t);
          break;
        }
        case 'dupont': {
          // Stepped profile with bullnose top
          edgeShape.moveTo(0, 0);
          edgeShape.lineTo(frontX, 0);
          // Lower step (flat)
          edgeShape.lineTo(frontX, t * 0.35);
          // Step back
          edgeShape.lineTo(frontX - t * 0.12, t * 0.35);
          edgeShape.lineTo(frontX - t * 0.12, t * 0.5);
          // Step forward
          edgeShape.lineTo(frontX, t * 0.5);
          // Bullnose top portion
          edgeShape.bezierCurveTo(
            frontX + t * 0.1, t * 0.65,
            frontX + t * 0.1, t * 0.85,
            frontX - t * 0.05, t
          );
          edgeShape.lineTo(0, t);
          break;
        }
        case 'chiseled': {
          // Rough-hewn textured edge appearance
          edgeShape.moveTo(0, 0);
          edgeShape.lineTo(frontX - t * 0.05, 0);
          // Irregular chiseled profile
          edgeShape.lineTo(frontX, t * 0.1);
          edgeShape.lineTo(frontX - t * 0.08, t * 0.25);
          edgeShape.lineTo(frontX + t * 0.02, t * 0.4);
          edgeShape.lineTo(frontX - t * 0.05, t * 0.55);
          edgeShape.lineTo(frontX + t * 0.03, t * 0.7);
          edgeShape.lineTo(frontX - t * 0.06, t * 0.85);
          edgeShape.lineTo(frontX - t * 0.02, t);
          edgeShape.lineTo(0, t);
          break;
        }
        default: // eased as fallback
          const easeR = t * 0.1;
          edgeShape.moveTo(0, 0);
          edgeShape.lineTo(frontX, 0);
          edgeShape.lineTo(frontX, t - easeR);
          edgeShape.quadraticCurveTo(frontX, t, frontX - easeR, t);
          edgeShape.lineTo(0, t);
      }
      edgeShape.closePath();

      // Extrude along the width of the slab
      const extrudeSettings = {
        steps: 2,
        depth: slabWidth,
        bevelEnabled: false
      };

      const edgeGeometry = new THREE.ExtrudeGeometry(edgeShape, extrudeSettings);
      const edgeMesh = new THREE.Mesh(edgeGeometry, material);
      edgeMesh.name = 'edgeSample';

      // Position the edge at the front of the slab
      edgeMesh.rotation.y = -Math.PI / 2;
      edgeMesh.position.set(slabWidth / 2, 0, slabDepth / 2);
      edgeMesh.castShadow = true;
      edgeMesh.receiveShadow = true;
      group.add(edgeMesh);

      // Position group for best viewing angle
      group.position.set(-slabWidth / 2, 0, -slabDepth / 2 + 0.15);

      edgePreviewScene.add(group);
    }

    function updateEdgeProfile(profile) {
      if (!edgePreviewElement) return;

      edgePreviewElement.edgeProfile = profile;
      document.getElementById('edgeProfileName').textContent = getEdgeProfileLabel(profile);

      // Update 3D preview
      createEdgePreviewMesh(edgePreviewElement);

      // Update main canvas and 3D view
      draw();
      render3D();
    }

    function updateEdgeThickness(thickness) {
      if (!edgePreviewElement) return;

      edgePreviewElement.thickness = thickness;

      // Update button states
      const btn2cm = document.getElementById('thickness2cmBtn');
      const btn3cm = document.getElementById('thickness3cmBtn');

      if (thickness === '2cm') {
        btn2cm.style.background = 'var(--gold)';
        btn2cm.style.color = '#000';
        btn3cm.style.background = 'transparent';
        btn3cm.style.color = 'var(--text-muted)';
      } else {
        btn3cm.style.background = 'var(--gold)';
        btn3cm.style.color = '#000';
        btn2cm.style.background = 'transparent';
        btn2cm.style.color = 'var(--text-muted)';
      }

      // Update 3D preview to show thickness difference
      createEdgePreviewMesh(edgePreviewElement);

      // Update main canvas and 3D view
      draw();
      render3D();
    }

    function rotateEdgePreview(direction) {
      if (!edgePreviewCamera || !edgePreviewControls) return;

      const target = edgePreviewControls.target;

      if (direction === 'reset') {
        // Reset to default view - front-right angle showing edge profile
        edgePreviewCamera.position.set(0.8, 0.4, 1.8);
        edgePreviewControls.target.set(0, 0.05, 0.3);
      } else if (direction === 'left') {
        // Rotate camera around the target
        const angle = 0.4;
        const dx = edgePreviewCamera.position.x - target.x;
        const dz = edgePreviewCamera.position.z - target.z;
        edgePreviewCamera.position.x = target.x + dx * Math.cos(angle) + dz * Math.sin(angle);
        edgePreviewCamera.position.z = target.z - dx * Math.sin(angle) + dz * Math.cos(angle);
      } else if (direction === 'right') {
        // Rotate camera around the target
        const angle = -0.4;
        const dx = edgePreviewCamera.position.x - target.x;
        const dz = edgePreviewCamera.position.z - target.z;
        edgePreviewCamera.position.x = target.x + dx * Math.cos(angle) + dz * Math.sin(angle);
        edgePreviewCamera.position.z = target.z - dx * Math.sin(angle) + dz * Math.cos(angle);
      }
      edgePreviewControls.update();
    }

    function closeEdgePreview() {
      const modal = document.getElementById('edgePreviewModal');
      modal.classList.remove('active');

      // Cleanup
      if (edgePreviewAnimationId) {
        cancelAnimationFrame(edgePreviewAnimationId);
        edgePreviewAnimationId = null;
      }
      if (edgePreviewRenderer) {
        edgePreviewRenderer.dispose();
      }
      edgePreviewElement = null;
    }

    function applyEdgeAndClose() {
      // Edge profile already applied via updateEdgeProfile
      closeEdgePreview();
      updateProperties();
      showSnapFeedback('Edge profile updated');
    }

    function copyShareLink() {
      const input = document.getElementById('shareLink');
      if (input.value) {
        navigator.clipboard.writeText(input.value).then(() => {
          const btn = document.getElementById('copyShareBtn');
          const originalText = btn.textContent;
          btn.textContent = 'Copied!';
          setTimeout(() => btn.textContent = originalText, 2000);
        }).catch(() => {
          input.select();
          document.execCommand('copy');
          showToast('Link copied!', 'success');
        });
      }
    }

    // Social sharing functionality
    async function shareToSocial(platform) {
      const shareUrl = document.getElementById('shareLink').value;
      const projectName = document.getElementById('projectName').value || 'My Room Design';
      const description = `Check out my ${document.getElementById('roomType').value || 'room'} design created with Surprise Granite Room Designer!`;

      if (!shareUrl && platform !== 'download') {
        showToast('Please generate a share link first', 'warning');
        return;
      }

      switch (platform) {
        case 'email':
          const emailSubject = encodeURIComponent(`${projectName} - Room Design`);
          const emailBody = encodeURIComponent(`${description}\n\nView design: ${shareUrl}`);
          window.open(`mailto:?subject=${emailSubject}&body=${emailBody}`, '_blank');
          break;

        case 'pinterest':
          // Pinterest requires an image URL - capture current view
          try {
            const imageUrl = await captureDesignImage();
            const pinUrl = `https://pinterest.com/pin/create/button/?url=${encodeURIComponent(shareUrl)}&media=${encodeURIComponent(imageUrl)}&description=${encodeURIComponent(description)}`;
            window.open(pinUrl, '_blank', 'width=750,height=550');
          } catch (err) {
            // Fallback without image
            const pinUrl = `https://pinterest.com/pin/create/button/?url=${encodeURIComponent(shareUrl)}&description=${encodeURIComponent(description)}`;
            window.open(pinUrl, '_blank', 'width=750,height=550');
          }
          break;

        case 'facebook':
          const fbUrl = `https://www.facebook.com/sharer/sharer.php?u=${encodeURIComponent(shareUrl)}&quote=${encodeURIComponent(description)}`;
          window.open(fbUrl, '_blank', 'width=600,height=400');
          break;

        case 'download':
          await downloadDesignImage();
          break;
      }
    }

    // Capture current design as image data URL
    async function captureDesignImage() {
      return new Promise((resolve, reject) => {
        try {
          let canvas;
          if (currentView === '3d' && renderer) {
            renderer.render(scene, camera);
            canvas = renderer.domElement;
          } else {
            canvas = document.getElementById('canvas');
          }

          const dataUrl = canvas.toDataURL('image/png');
          resolve(dataUrl);
        } catch (err) {
          reject(err);
        }
      });
    }

    // Download design as image
    async function downloadDesignImage() {
      try {
        const projectName = document.getElementById('projectName').value || 'room-design';
        const viewType = currentView === '3d' ? '3d' : '2d';

        let canvas;
        if (currentView === '3d' && renderer) {
          renderer.render(scene, camera);
          canvas = renderer.domElement;
        } else {
          canvas = document.getElementById('canvas');
        }

        const link = document.createElement('a');
        link.download = `${projectName.replace(/\s+/g, '-')}-${viewType}.png`;
        link.href = canvas.toDataURL('image/png');
        link.click();

        showToast('Image downloaded successfully', 'success');
      } catch (err) {
        console.error('Failed to download image:', err);
        showToast('Failed to download image', 'error');
      }
    }

    function setSharePermission(perm, btn) {
      document.querySelectorAll('#shareModal .permission-btn').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
    }

    // ===== INVITE RECIPIENTS SYSTEM =====

    const INVITE_STATE = {
      recipients: [],
      searchTimeout: null,
      lastQuery: ''
    };

    function addInviteRecipient(email, name, source) {
      if (!email) return;
      email = email.trim().toLowerCase();
      if (INVITE_STATE.recipients.some(r => r.email === email)) return;
      INVITE_STATE.recipients.push({ email, name: name || email.split('@')[0], source: source || 'manual' });
      renderInviteChips();
      const input = document.getElementById('inviteSearchInput');
      if (input) { input.value = ''; }
      const results = document.getElementById('inviteSearchResults');
      if (results) results.style.display = 'none';
      document.getElementById('inviteSendStatus').innerHTML = '';
    }

    function removeInviteRecipient(email) {
      INVITE_STATE.recipients = INVITE_STATE.recipients.filter(r => r.email !== email);
      renderInviteChips();
    }

    function renderInviteChips() {
      const container = document.getElementById('inviteChips');
      if (!container) return;
      container.innerHTML = INVITE_STATE.recipients.map(r => `
        <div class="invite-chip">
          <span class="invite-chip-name" title="${r.email}">${r.name}</span>
          <span class="invite-source-badge ${r.source}">${r.source}</span>
          <button class="invite-chip-remove" onclick="removeInviteRecipient('${r.email}')" title="Remove">&times;</button>
        </div>
      `).join('');
    }

    function handleInviteKeydown(e) {
      if (e.key === 'Enter' || e.key === ',') {
        const input = e.target;
        const rawVal = input.value;
        // Split by comma to support multiple emails
        const parts = rawVal.split(',').map(s => s.trim()).filter(Boolean);
        let added = false;
        parts.forEach(part => {
          if (part && part.includes('@') && part.includes('.')) {
            addInviteRecipient(part, null, 'manual');
            added = true;
          }
        });
        if (added) {
          e.preventDefault();
          input.value = '';
          document.getElementById('inviteSearchResults').style.display = 'none';
        } else if (e.key === ',') {
          // Let the comma go through if no valid emails yet
        }
      }
      if (e.key === 'Escape') {
        document.getElementById('inviteSearchResults').style.display = 'none';
      }
    }

    function handleInvitePaste(e) {
      setTimeout(() => {
        const input = e.target;
        const val = input.value;
        if (val.includes(',')) {
          const parts = val.split(',').map(s => s.trim()).filter(Boolean);
          let added = false;
          parts.forEach(part => {
            if (part && part.includes('@') && part.includes('.')) {
              addInviteRecipient(part, null, 'manual');
              added = true;
            }
          });
          if (added) {
            // Keep any remaining non-email text in the input
            const remaining = parts.filter(p => !(p.includes('@') && p.includes('.'))).join(', ');
            input.value = remaining;
            document.getElementById('inviteSearchResults').style.display = 'none';
          }
        }
      }, 0);
    }

    async function searchInviteRecipients(query) {
      query = (query || '').trim();
      if (INVITE_STATE.searchTimeout) clearTimeout(INVITE_STATE.searchTimeout);

      const resultsEl = document.getElementById('inviteSearchResults');
      if (!resultsEl) return;

      if (query.length < 2) {
        resultsEl.style.display = 'none';
        return;
      }

      INVITE_STATE.searchTimeout = setTimeout(async () => {
        try {
          const user = window.SgAuth?.getUser();
          if (!user) {
            renderSearchResults([], query);
            return;
          }

          const { url: SUPABASE_URL, anonKey: SUPABASE_ANON_KEY } = getSupabaseConfig();
          const session = await window.SgAuth?.getSession?.();
          const authToken = session?.access_token || SUPABASE_ANON_KEY;
          const headers = {
            'apikey': SUPABASE_ANON_KEY,
            'Authorization': `Bearer ${authToken}`,
            'Accept': 'application/json'
          };

          const results = [];

          // Helper: try a PostgREST query, return parsed array or []
          async function tryQuery(url) {
            try {
              const res = await fetch(url, { headers });
              if (res.ok) {
                const data = await res.json();
                return Array.isArray(data) ? data : [];
              }
            } catch (e) { /* column may not exist  silent */ }
            return [];
          }

          // Use individual column queries (not or()) to avoid PostgREST parsing issues
          // Auth token + RLS handles user filtering; no need for user_id/owner_id param
          const q = encodeURIComponent(query);

          // Run all searches in parallel for speed
          const [leadsByName, leadsByEmail, leadsByFullName, leadsByGenEmail, custsByName, custsByEmail] = await Promise.all([
            tryQuery(`${SUPABASE_URL}/rest/v1/leads?homeowner_name=ilike.*${q}*&select=id,homeowner_name,homeowner_email,status&limit=8`),
            tryQuery(`${SUPABASE_URL}/rest/v1/leads?homeowner_email=ilike.*${q}*&select=id,homeowner_name,homeowner_email,status&limit=8`),
            tryQuery(`${SUPABASE_URL}/rest/v1/leads?full_name=ilike.*${q}*&select=id,full_name,email,status&limit=8`),
            tryQuery(`${SUPABASE_URL}/rest/v1/leads?email=ilike.*${q}*&select=id,full_name,email,status&limit=8`),
            tryQuery(`${SUPABASE_URL}/rest/v1/customers?name=ilike.*${q}*&select=id,name,email,phone&limit=8`),
            tryQuery(`${SUPABASE_URL}/rest/v1/customers?email=ilike.*${q}*&select=id,name,email,phone&limit=8`)
          ]);

          // Merge lead results (homeowner_* columns)
          [...leadsByName, ...leadsByEmail].forEach(l => {
            const email = l.homeowner_email;
            const name = l.homeowner_name || (email ? email.split('@')[0] : '');
            if (email && !results.some(r => r.email === email)) {
              results.push({ email, name, source: 'lead', status: l.status });
            }
          });

          // Merge lead results (full_name/email columns)
          [...leadsByFullName, ...leadsByGenEmail].forEach(l => {
            const email = l.email;
            const name = l.full_name || (email ? email.split('@')[0] : '');
            if (email && !results.some(r => r.email === email)) {
              results.push({ email, name, source: 'lead', status: l.status });
            }
          });

          // Merge customer results
          [...custsByName, ...custsByEmail].forEach(c => {
            if (c.email && !results.some(r => r.email === c.email)) {
              results.push({ email: c.email, name: c.name || c.email.split('@')[0], source: 'customer' });
            }
          });

          // Filter out already-added recipients
          const filtered = results.filter(r => !INVITE_STATE.recipients.some(ir => ir.email === r.email));
          renderSearchResults(filtered, query);

        } catch (err) {
          console.error('Invite search error:', err);
          renderSearchResults([], query);
        }
      }, 300);
    }

    function renderSearchResults(results, query) {
      const container = document.getElementById('inviteSearchResults');
      if (!container) return;

      let html = '';
      const isEmail = query && query.includes('@') && query.includes('.');
      const alreadyAdded = INVITE_STATE.recipients.some(r => r.email === query.toLowerCase());

      // Manual email add option
      if (isEmail && !alreadyAdded && !results.some(r => r.email === query.toLowerCase())) {
        html += `
          <div class="invite-search-item" onclick="addInviteRecipient('${query}', null, 'manual')">
            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="#6366f1" stroke-width="2">
              <line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/>
            </svg>
            <div class="invite-search-item-info">
              <div class="invite-search-item-name">Add "${query}"</div>
              <div class="invite-search-item-email">Send invitation to this email</div>
            </div>
            <span class="invite-source-badge manual">New</span>
          </div>`;
      }

      if (results.length > 0) {
        results.forEach(r => {
          const escapedEmail = r.email.replace(/'/g, "\\'");
          const escapedName = (r.name || '').replace(/'/g, "\\'");
          html += `
            <div class="invite-search-item" onclick="addInviteRecipient('${escapedEmail}', '${escapedName}', '${r.source}')">
              <div style="width: 32px; height: 32px; border-radius: 50%; background: var(--dark-hover); display: flex; align-items: center; justify-content: center; font-size: 13px; font-weight: 600; color: var(--text-secondary); flex-shrink: 0;">
                ${(r.name || '?')[0].toUpperCase()}
              </div>
              <div class="invite-search-item-info">
                <div class="invite-search-item-name">${r.name || r.email}</div>
                <div class="invite-search-item-email">${r.email}${r.status ? ' &middot; ' + r.status : ''}</div>
              </div>
              <span class="invite-source-badge ${r.source}">${r.source}</span>
            </div>`;
        });
      } else if (!isEmail && query.length >= 2) {
        html += `<div class="invite-search-empty">No matches found. Type a full email to add manually.</div>`;
      }

      container.innerHTML = html;
      container.style.display = html ? 'block' : 'none';
    }

    // Close search results when clicking outside
    document.addEventListener('click', function(e) {
      const wrapper = document.querySelector('.invite-search-wrapper');
      const results = document.getElementById('inviteSearchResults');
      if (results && wrapper && !wrapper.contains(e.target)) {
        results.style.display = 'none';
      }
    });

    function buildInvitationEmailHTML(recipientName, shareUrl, projectName, permissionLevel, branding) {
      const permInfo = PERMISSION_LEVELS[permissionLevel] || PERMISSION_LEVELS.quote_approval;
      const actionText = permInfo.canApprove ? 'review and approve' :
                         permInfo.canEdit ? 'collaborate on' :
                         permInfo.canViewPrices ? 'view the quote for' : 'view';

      const co = branding.companyName || 'Surprise Granite';
      const senderName = branding.senderName || co;
      const phone = branding.phone || '';
      const email = branding.email || '';
      const logoUrl = branding.logoUrl || '';
      const permName = permInfo.name || 'View Only';
      const yr = new Date().getFullYear();

      // Permission description
      const permDesc = permInfo.canApprove ? 'You can review the design, see pricing details, and approve the project directly from the link.'
        : permInfo.canEdit ? 'You can make changes to the layout, swap materials, and collaborate in real time.'
        : permInfo.canViewPrices ? 'You can view the full design with itemized pricing and material details.'
        : permInfo.canComment ? 'You can view the design and leave feedback or comments.'
        : 'You can view the complete room design and material selections.';

      // Build logo block  image if available, otherwise styled text (use concatenation to avoid nested backticks)
      const logoBlock = logoUrl
        ? '<img src="' + logoUrl + '" alt="' + co + '" style="max-height:48px;max-width:200px;margin:0 auto 8px;display:block;" />'
        : '<div style="font-size:26px;font-weight:700;letter-spacing:-0.5px;color:#1a1a2e;margin-bottom:4px;">' + co + '</div>';

      // Footer logo (smaller)
      const footerLogo = logoUrl
        ? '<img src="' + logoUrl + '" alt="' + co + '" style="max-height:24px;max-width:120px;margin-bottom:8px;" />'
        : '<div style="font-size:13px;font-weight:700;color:#1a1a2e;margin-bottom:6px;">' + co + '</div>';

      // Contact line
      const contactParts = [];
      if (phone) contactParts.push(phone);
      if (email) contactParts.push('<a href="mailto:' + email + '" style="color:#555555;text-decoration:none;">' + email + '</a>');
      const footerContact = contactParts.length > 0
        ? '<div style="font-size:12px;color:#555555;margin-bottom:4px;">' + contactParts.join(' &nbsp;&middot;&nbsp; ') + '</div>'
        : '';

      return `<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1.0">
<title>Design Invitation from ${co}</title></head>
<body style="margin:0;padding:0;background-color:#f0f0f0;font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,'Helvetica Neue',Arial,sans-serif;">

<!-- Wrapper -->
<table role="presentation" width="100%" cellspacing="0" cellpadding="0" border="0" style="background-color:#f0f0f0;">
<tr><td align="center" style="padding:24px 16px;">

  <!-- Main card -->
  <table role="presentation" width="600" cellspacing="0" cellpadding="0" border="0" style="max-width:600px;width:100%;background-color:#ffffff;border-radius:12px;overflow:hidden;box-shadow:0 2px 12px rgba(0,0,0,0.1);">

    <!-- Header with logo/brand -->
    <tr><td style="background:#ffffff;padding:28px 32px 20px;text-align:center;border-bottom:3px solid #f9cb00;">
      ${logoBlock}
      <div style="font-size:13px;color:#b8963e;font-weight:600;letter-spacing:0.5px;text-transform:uppercase;">Room Design Invitation</div>
    </td></tr>

    <!-- Body -->
    <tr><td style="padding:24px 32px 20px;">

      <!-- Greeting -->
      <p style="margin:0 0 12px;font-size:17px;color:#1a1a2e;font-weight:600;">
        Hi ${recipientName},
      </p>

      <p style="margin:0 0 20px;font-size:15px;color:#333333;line-height:1.6;">
        <strong style="color:#1a1a2e;">${senderName}</strong> has invited you to ${actionText} a room design project:
      </p>

      <!-- Project card -->
      <table role="presentation" width="100%" cellspacing="0" cellpadding="0" border="0" style="margin-bottom:20px;">
      <tr><td style="background:#f9f9f9;border-radius:8px;padding:16px 20px;border-left:4px solid #f9cb00;border:1px solid #eeeeee;border-left:4px solid #f9cb00;">
        <div style="font-size:11px;text-transform:uppercase;letter-spacing:1.2px;color:#888888;margin-bottom:4px;font-weight:600;">Project</div>
        <div style="font-size:18px;color:#1a1a2e;font-weight:700;">${projectName}</div>
        <div style="margin-top:8px;">
          <span style="display:inline-block;background:rgba(249,203,0,0.15);color:#8a7000;font-size:12px;padding:3px 10px;border-radius:4px;font-weight:600;">${permName} Access</span>
        </div>
      </td></tr>
      </table>

      <!-- What you can do -->
      <p style="margin:0 0 24px;font-size:14px;color:#555555;line-height:1.65;">
        ${permDesc}
      </p>

      <!-- CTA Button -->
      <table role="presentation" width="100%" cellspacing="0" cellpadding="0" border="0">
      <tr><td align="center" style="padding:0 0 4px;">
        <a href="${shareUrl}" target="_blank" style="display:inline-block;padding:14px 44px;background:linear-gradient(135deg,#f9cb00,#e6b800);color:#1a1a2e;text-decoration:none;border-radius:8px;font-weight:700;font-size:16px;letter-spacing:0.3px;box-shadow:0 3px 10px rgba(249,203,0,0.35);">
          View Design &rarr;
        </a>
      </td></tr>
      </table>

      <!-- Secondary link -->
      <p style="margin:16px 0 0;font-size:12px;color:#888888;text-align:center;line-height:1.5;">
        Or copy this link:<br/>
        <a href="${shareUrl}" style="color:#b8963e;text-decoration:none;word-break:break-all;font-size:11px;">${shareUrl}</a>
      </p>

    </td></tr>

    <!-- Divider -->
    <tr><td style="padding:0 32px;">
      <div style="height:1px;background:#e5e5e5;"></div>
    </td></tr>

    <!-- Footer -->
    <tr><td style="padding:16px 32px 20px;text-align:center;background:#fafafa;">
      ${footerLogo}
      ${footerContact}
      <div style="font-size:11px;color:#888888;">
        Powered by Surprise Granite Room Designer
      </div>
      <div style="font-size:11px;color:#aaaaaa;margin-top:6px;">
        &copy; ${yr} ${co}. All rights reserved.
      </div>
    </td></tr>

  </table>

</td></tr>
</table>

</body></html>`;
    }

    async function sendDesignInvitation(recipient, shareUrl, projectName, permissionLevel, branding) {
      try {
        const emailHTML = buildInvitationEmailHTML(
          recipient.name, shareUrl, projectName, permissionLevel, branding
        );
        const response = await fetch('https://surprise-granite-email-api.onrender.com/api/email/notify', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            to: recipient.email,
            subject: `${branding.companyName} shared a design with you: ${projectName}`,
            message: emailHTML,
            type: 'info',
            rawHtml: true
          })
        });
        return response.ok;
      } catch (err) {
        console.error('Failed to send invitation to', recipient.email, err);
        return false;
      }
    }

    async function generateAndInvite() {
      const recipients = INVITE_STATE.recipients;
      if (recipients.length === 0) {
        showToast('Add at least one recipient to send invitations', 'warning');
        return;
      }

      // Generate the share link first
      const shareUrl = await generateShareLink();
      if (!shareUrl) {
        showToast('Failed to generate share link', 'error');
        return;
      }

      const projectName = document.getElementById('projectName').value || 'Untitled Design';
      const permissionBtn = document.querySelector('#shareModal .permission-btn.active');
      const permission = permissionBtn ? permissionBtn.dataset.permission : 'quote_approval';

      // Build branding object from profile
      const branding = {
        companyName: 'Surprise Granite Marble & Quartz',
        senderName: '',
        phone: '',
        email: '',
        logoUrl: ''
      };
      try {
        const profile = await window.SgAuth?.getProfile();
        const user = window.SgAuth?.getUser();
        if (profile?.company_name) branding.companyName = profile.company_name;
        else if (profile?.full_name) branding.companyName = profile.full_name;
        branding.senderName = profile?.full_name || profile?.company_name || branding.companyName;
        branding.phone = profile?.phone || '';
        branding.email = user?.email || profile?.email || '';
        branding.logoUrl = profile?.logo_url || profile?.company_logo || '';
      } catch (e) {}

      // Show sending status
      const statusEl = document.getElementById('inviteSendStatus');
      statusEl.innerHTML = recipients.map(r =>
        `<div class="status-item sending" id="invite-status-${r.email.replace(/[^a-z0-9]/gi, '_')}">
          &#8987; Sending to ${r.name}...
        </div>`
      ).join('');

      const btn = document.getElementById('shareInviteBtn');
      if (btn) { btn.disabled = true; btn.textContent = 'Sending...'; }

      // Send invitations in parallel
      const results = await Promise.all(recipients.map(async (r) => {
        const success = await sendDesignInvitation(r, shareUrl, projectName, permission, branding);
        const statusItem = document.getElementById(`invite-status-${r.email.replace(/[^a-z0-9]/gi, '_')}`);
        if (statusItem) {
          statusItem.className = `status-item ${success ? 'success' : 'failed'}`;
          statusItem.innerHTML = success
            ? `&#10003; Sent to ${r.name} (${r.email})`
            : `&#10007; Failed to send to ${r.name}`;
        }

        // Create/link lead for each recipient
        if (success) {
          await findOrCreateLeadForRecipient(r.email, projectName);
        }

        return { ...r, success };
      }));

      const sentCount = results.filter(r => r.success).length;
      if (btn) {
        btn.disabled = false;
        btn.innerHTML = `<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align: middle; margin-right: 4px;"><path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"/><polyline points="22,6 12,13 2,6"/></svg> Send Invitations`;
      }
      showToast(`Sent ${sentCount}/${recipients.length} invitation${recipients.length > 1 ? 's' : ''}`, sentCount === recipients.length ? 'success' : 'warning');
    }

    async function findOrCreateLeadForRecipient(email, projectName) {
      try {
        const user = window.SgAuth?.getUser();
        if (!user) return null;

        const { url: SUPABASE_URL, anonKey: SUPABASE_ANON_KEY } = getSupabaseConfig();
        const session = await window.SgAuth?.getSession?.();
        const authToken = session?.access_token || SUPABASE_ANON_KEY;
        const headers = {
          'apikey': SUPABASE_ANON_KEY,
          'Authorization': `Bearer ${authToken}`,
          'Accept': 'application/json',
          'Content-Type': 'application/json',
          'Prefer': 'return=representation'
        };

        // Check existing lead
        const checkRes = await fetch(
          `${SUPABASE_URL}/rest/v1/leads?email=eq.${encodeURIComponent(email)}&select=id&order=created_at.desc&limit=1`,
          { headers }
        );
        if (checkRes.ok) {
          const existing = await checkRes.json();
          if (Array.isArray(existing) && existing.length > 0) return existing[0].id;
        }

        // Also check homeowner_email
        const checkRes2 = await fetch(
          `${SUPABASE_URL}/rest/v1/leads?homeowner_email=eq.${encodeURIComponent(email)}&select=id&order=created_at.desc&limit=1`,
          { headers }
        );
        if (checkRes2.ok) {
          const existing2 = await checkRes2.json();
          if (Array.isArray(existing2) && existing2.length > 0) return existing2[0].id;
        }

        // Create new lead
        const roomType = document.getElementById('roomType')?.value || 'kitchen';
        const newRes = await fetch(`${SUPABASE_URL}/rest/v1/leads`, {
          method: 'POST',
          headers,
          body: JSON.stringify({
            email: email,
            full_name: email.split('@')[0],
            source: 'Design Share',
            project_type: roomType,
            owner_id: user.id,
            user_id: user.id,
            status: 'new',
            message: `Design project: ${projectName}`
          })
        });
        if (newRes.ok) {
          const newLeads = await newRes.json();
          if (Array.isArray(newLeads) && newLeads.length > 0) return newLeads[0].id;
        }
        return null;
      } catch (e) {
        console.warn('Could not create lead for', email, e);
        return null;
      }
    }

    // ===== PRICE LIST MODAL FUNCTIONS =====
    let pendingPriceData = null;

    // openPriceListModal is defined later (shows labor tab by default)

    function showPriceTab(tab) {
      document.querySelectorAll('.price-tab').forEach(t => t.style.display = 'none');
      document.querySelectorAll('.price-list-tabs .tab-btn').forEach(b => b.classList.remove('active'));

      document.getElementById('priceTab' + tab.charAt(0).toUpperCase() + tab.slice(1)).style.display = 'block';
      event.target.classList.add('active');
    }

    // Handle price list file upload
    async function handlePriceListUpload(event) {
      const file = event.target.files[0];
      if (!file) return;

      const extension = file.name.split('.').pop().toLowerCase();

      try {
        let data;
        if (extension === 'csv') {
          data = await parseCSVFile(file);
        } else if (['xlsx', 'xls'].includes(extension)) {
          data = await parseExcelFile(file);
        } else {
          throw new Error('Unsupported file format. Please use .xlsx, .xls, or .csv');
        }

        showColumnMapping(data);
      } catch (error) {
        showToast('Error parsing file: ' + error.message, 'error');
        console.error(error);
      }
    }

    // Parse Excel file using SheetJS
    async function parseExcelFile(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = (e) => {
          try {
            if (typeof XLSX === 'undefined') {
              throw new Error('Excel parser not loaded. Please refresh the page.');
            }
            const data = new Uint8Array(e.target.result);
            const workbook = XLSX.read(data, { type: 'array' });
            const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
            const jsonData = XLSX.utils.sheet_to_json(firstSheet, { header: 1 });

            resolve({
              headers: jsonData[0] || [],
              rows: jsonData.slice(1).filter(row => row.some(cell => cell !== null && cell !== '')),
              raw: jsonData
            });
          } catch (err) {
            reject(err);
          }
        };
        reader.onerror = () => reject(new Error('Failed to read file'));
        reader.readAsArrayBuffer(file);
      });
    }

    // Parse CSV file
    async function parseCSVFile(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = (e) => {
          try {
            const text = e.target.result;
            const lines = text.split(/\r?\n/).filter(line => line.trim());
            const rows = lines.map(line => {
              const matches = line.match(/("([^"]*)"|[^,]+)/g) || [];
              return matches.map(val => val.replace(/^"|"$/g, '').trim());
            });

            resolve({
              headers: rows[0] || [],
              rows: rows.slice(1),
              raw: rows
            });
          } catch (err) {
            reject(err);
          }
        };
        reader.onerror = () => reject(new Error('Failed to read file'));
        reader.readAsText(file);
      });
    }

    function showColumnMapping(data) {
      pendingPriceData = data;

      document.getElementById('priceListDropzone').style.display = 'none';
      document.getElementById('columnMapping').style.display = 'block';

      const headers = data.headers;
      const optionsHtml = '<option value="">-- Select --</option>' +
        headers.map((h, i) => `<option value="${i}">${h}</option>`).join('');

      document.getElementById('mapMaterialId').innerHTML = optionsHtml;
      document.getElementById('mapMaterialName').innerHTML = optionsHtml;
      document.getElementById('mapPrice').innerHTML = optionsHtml;
      document.getElementById('mapUnit').innerHTML = '<option value="">None</option>' +
        headers.map((h, i) => `<option value="${i}">${h}</option>`).join('');

      // Auto-detect columns by name
      headers.forEach((h, i) => {
        const lower = String(h).toLowerCase();
        if (lower.includes('sku') || lower.includes('id') || lower.includes('code') || lower.includes('item')) {
          document.getElementById('mapMaterialId').value = i;
        }
        if (lower.includes('name') || lower.includes('material') || lower.includes('product') || lower.includes('description')) {
          document.getElementById('mapMaterialName').value = i;
        }
        if (lower.includes('price') || lower.includes('cost') || lower.includes('rate') || lower.includes('amount')) {
          document.getElementById('mapPrice').value = i;
        }
        if (lower.includes('unit') || lower.includes('uom')) {
          document.getElementById('mapUnit').value = i;
        }
      });

      updateMappingPreview();
    }

    function updateMappingPreview() {
      if (!pendingPriceData) return;

      const idCol = parseInt(document.getElementById('mapMaterialId').value);
      const nameCol = parseInt(document.getElementById('mapMaterialName').value);
      const priceCol = parseInt(document.getElementById('mapPrice').value);

      const preview = document.getElementById('mappingPreview');
      const sampleRows = pendingPriceData.rows.slice(0, 5);

      preview.innerHTML = `
        <table class="preview-table">
          <thead>
            <tr>
              <th>SKU/ID</th>
              <th>Name</th>
              <th>Price</th>
            </tr>
          </thead>
          <tbody>
            ${sampleRows.map(row => `
              <tr>
                <td>${isNaN(idCol) ? '-' : (row[idCol] || '-')}</td>
                <td>${isNaN(nameCol) ? '-' : (row[nameCol] || '-')}</td>
                <td>${isNaN(priceCol) ? '-' : formatPriceValue(row[priceCol])}</td>
              </tr>
            `).join('')}
          </tbody>
        </table>
        <p class="preview-count" style="margin-top:8px;font-size:12px;color:var(--text-muted);">${pendingPriceData.rows.length} items found</p>
      `;
    }

    function formatPriceValue(value) {
      if (!value) return '-';
      const num = parseFloat(String(value).replace(/[$,]/g, ''));
      return isNaN(num) ? '-' : '$' + num.toFixed(2);
    }

    function applyPriceList() {
      if (!pendingPriceData) return;

      const idCol = parseInt(document.getElementById('mapMaterialId').value);
      const nameCol = parseInt(document.getElementById('mapMaterialName').value);
      const priceCol = parseInt(document.getElementById('mapPrice').value);

      if (isNaN(priceCol)) {
        showToast('Please select the Price column', 'warning');
        return;
      }

      let matched = 0;
      let updated = 0;

      pendingPriceData.rows.forEach(row => {
        const id = !isNaN(idCol) ? String(row[idCol] || '').trim() : null;
        const name = !isNaN(nameCol) ? String(row[nameCol] || '').trim() : null;
        const price = parseFloat(String(row[priceCol] || '').replace(/[$,]/g, ''));

        if (isNaN(price) || price <= 0) return;

        // Store by ID in custom prices
        if (id) {
          PRICING_STATE.customPrices[id] = price;
        }

        // Update MATERIALS object for SKU/name matches
        for (const category in MATERIALS) {
          MATERIALS[category].forEach(mat => {
            if ((mat.sku && mat.sku === id) ||
                (mat.id && mat.id === id) ||
                (mat.name && name && mat.name.toLowerCase() === name.toLowerCase())) {
              mat.price = price;
              matched++;
            }
          });
        }
        updated++;
      });

      PRICING_STATE.activePriceList = 'Custom Import (' + new Date().toLocaleDateString() + ')';

      alert(`Price list applied!\n${updated} prices imported\n${matched} materials updated`);

      closeModal('priceListModal');
      calculateQuote();
      resetPriceUpload();
    }

    function cancelPriceUpload() {
      resetPriceUpload();
    }

    function resetPriceUpload() {
      pendingPriceData = null;
      document.getElementById('priceListDropzone').style.display = 'block';
      document.getElementById('columnMapping').style.display = 'none';
      document.getElementById('priceListFile').value = '';
    }

    function renderCurrentPrices() {
      const list = document.getElementById('currentPricesList');
      if (!list) return;

      let html = '';
      for (const category in MATERIALS) {
        const materials = MATERIALS[category].filter(m => m.price);
        if (materials.length === 0) continue;

        html += `<div class="price-category-header">${category.charAt(0).toUpperCase() + category.slice(1)}</div>`;
        materials.forEach(m => {
          html += `
            <div class="current-price-item">
              <span class="price-item-name">${m.name}</span>
              <span class="price-item-sku">${m.sku || '-'}</span>
              <span class="price-item-value">$${m.price.toFixed(2)}</span>
            </div>
          `;
        });
      }

      list.innerHTML = html || '<p class="empty-state">No priced materials</p>';
    }

    function filterCurrentPrices() {
      const query = document.getElementById('priceSearchInput').value.toLowerCase();
      const items = document.querySelectorAll('.current-price-item');
      items.forEach(item => {
        const name = item.querySelector('.price-item-name').textContent.toLowerCase();
        item.style.display = name.includes(query) ? 'flex' : 'none';
      });
    }

    // ===== LABOR RATES MANAGEMENT =====
    // Store for user-modified labor rates (loaded from localStorage)
    let userLaborRates = JSON.parse(localStorage.getItem('sg_labor_rates') || 'null') || JSON.parse(JSON.stringify(LABOR_RATES));
    let userMaterialPricing = JSON.parse(localStorage.getItem('sg_material_pricing') || 'null') || JSON.parse(JSON.stringify(MATERIAL_PRICING));

    // Toggle labor category accordion
    function toggleLaborCategory(category) {
      const container = document.getElementById('laborItems' + category.charAt(0).toUpperCase() + category.slice(1));
      const parentCategory = container.closest('.labor-category');

      // Toggle expanded state
      parentCategory.classList.toggle('expanded');

      // Render items if expanding and empty
      if (parentCategory.classList.contains('expanded') && container.innerHTML === '') {
        renderLaborCategoryItems(category);
      }
    }

    // Render items for a specific labor category
    function renderLaborCategoryItems(category) {
      const container = document.getElementById('laborItems' + category.charAt(0).toUpperCase() + category.slice(1));
      if (!container) return;

      const items = userLaborRates[category];
      if (!items) return;

      let html = '';
      for (const [key, item] of Object.entries(items)) {
        const unitLabels = {
          'sqft': '/ sq ft',
          'lf': '/ lin ft',
          'cabinet': '/ cabinet',
          'each': '/ each',
          'hour': '/ hour',
          'visit': '/ visit',
          'trip': '/ trip',
          'permit': '/ permit',
          'piece': '/ piece',
          'location': '/ location',
          'load': '/ load',
          'percent': '%'
        };

        html += `
          <div class="labor-item">
            <span class="labor-item-label">${item.label}</span>
            <div class="labor-item-rate">
              <span style="color: var(--text-muted); font-size: 12px;">${item.unit === 'percent' ? '' : '$'}</span>
              <input type="number"
                     id="laborRate_${category}_${key}"
                     value="${item.rate}"
                     min="0"
                     step="${item.unit === 'percent' ? '1' : '0.01'}"
                     onchange="updateLaborRate('${category}', '${key}', this.value)">
              <span class="labor-item-unit">${unitLabels[item.unit] || item.unit}</span>
            </div>
          </div>
        `;
      }

      container.innerHTML = html;
    }

    // Update a specific labor rate
    function updateLaborRate(category, key, value) {
      const numValue = parseFloat(value) || 0;
      if (userLaborRates[category] && userLaborRates[category][key]) {
        userLaborRates[category][key].rate = numValue;
      }
    }

    // Save all labor rates to localStorage
    function saveLaborRates() {
      localStorage.setItem('sg_labor_rates', JSON.stringify(userLaborRates));
      showNotification('Labor rates saved successfully!', 'success');

      // Recalculate quote if open
      calculateQuote();
    }

    // Reset labor rates to defaults
    async function resetLaborRates() {
      const confirmed = await showConfirmDialog({
        title: 'Reset Labor Rates?',
        message: 'Reset all labor rates to their default values?\n\nYour custom rates will be lost.',
        confirmText: 'Reset to Defaults',
        cancelText: 'Keep Custom Rates'
      });
      if (!confirmed) return;

      userLaborRates = JSON.parse(JSON.stringify(LABOR_RATES));
      localStorage.removeItem('sg_labor_rates');

      // Re-render all expanded categories
      document.querySelectorAll('.labor-category.expanded').forEach(cat => {
        const itemsContainer = cat.querySelector('.labor-category-items');
        if (itemsContainer && itemsContainer.id) {
          const categoryName = itemsContainer.id.replace('laborItems', '').toLowerCase();
          renderLaborCategoryItems(categoryName);
        }
      });

      showNotification('Labor rates reset to defaults', 'info');
    }

    // Initialize labor rates tab when opening
    function initLaborRatesTab() {
      // Expand first category by default
      const firstCategory = document.querySelector('.labor-category');
      if (firstCategory && !firstCategory.classList.contains('expanded')) {
        firstCategory.classList.add('expanded');
        renderLaborCategoryItems('stone');
      }
    }

    // ===== MATERIAL PRICING MANAGEMENT =====
    // Render slab materials pricing
    function renderSlabMaterials() {
      const container = document.getElementById('slabMaterialsList');
      if (!container) return;

      let html = '';
      for (const [key, mat] of Object.entries(userMaterialPricing.slabMaterials)) {
        html += `
          <div class="material-price-row">
            <span class="material-price-label">${mat.label}</span>
            <div class="material-price-inputs">
              <span>$</span>
              <input type="number"
                     id="slabPrice_${key}"
                     value="${mat.slabPrice}"
                     min="0"
                     step="1"
                     placeholder="Slab price"
                     onchange="updateSlabPrice('${key}', this.value)">
              <span>/ slab (~${mat.slabSqft} sqft)</span>
            </div>
          </div>
        `;
      }

      container.innerHTML = html;
    }

    // Render sqft materials pricing
    function renderSqftMaterials() {
      const container = document.getElementById('sqftMaterialsList');
      if (!container) return;

      let html = '';
      for (const [key, mat] of Object.entries(userMaterialPricing.sqftMaterials)) {
        html += `
          <div class="material-price-row">
            <span class="material-price-label">${mat.label}</span>
            <div class="material-price-inputs">
              <span>$</span>
              <input type="number"
                     id="sqftPrice_${key}"
                     value="${mat.pricePerSqft}"
                     min="0"
                     step="0.01"
                     placeholder="Price / sqft"
                     onchange="updateSqftPrice('${key}', this.value)">
              <span>/ sq ft</span>
            </div>
          </div>
        `;
      }

      container.innerHTML = html;
    }

    // Update slab material price
    function updateSlabPrice(key, value) {
      const numValue = parseFloat(value) || 0;
      if (userMaterialPricing.slabMaterials[key]) {
        userMaterialPricing.slabMaterials[key].slabPrice = numValue;
      }
    }

    // Update sqft material price
    function updateSqftPrice(key, value) {
      const numValue = parseFloat(value) || 0;
      if (userMaterialPricing.sqftMaterials[key]) {
        userMaterialPricing.sqftMaterials[key].pricePerSqft = numValue;
      }
    }

    // Save material pricing
    function saveMaterialPricing() {
      localStorage.setItem('sg_material_pricing', JSON.stringify(userMaterialPricing));
      showNotification('Material pricing saved!', 'success');
      calculateQuote();
    }

    // Initialize materials tab
    function initMaterialsTab() {
      renderSlabMaterials();
      renderSqftMaterials();
    }

    // Override showPriceTab to initialize tabs
    const _originalShowPriceTab = showPriceTab;
    showPriceTab = function(tab) {
      // Hide all tabs
      document.querySelectorAll('.price-tab').forEach(t => t.style.display = 'none');
      document.querySelectorAll('.price-list-tabs .tab-btn').forEach(b => b.classList.remove('active'));

      // Show selected tab
      const tabId = 'priceTab' + tab.charAt(0).toUpperCase() + tab.slice(1);
      const tabEl = document.getElementById(tabId);
      if (tabEl) tabEl.style.display = 'block';

      // Find and activate the clicked button
      document.querySelectorAll('.price-list-tabs .tab-btn').forEach(b => {
        if (b.textContent.toLowerCase().includes(tab.toLowerCase().replace('upload', 'up').replace('saved', 'sav'))) {
          b.classList.add('active');
        }
      });

      // Initialize tab-specific content
      if (tab === 'labor') {
        initLaborRatesTab();
      } else if (tab === 'materials') {
        initMaterialsTab();
      }
    };

    // Override openPriceListModal to show labor tab by default
    function openPriceListModal() {
      document.getElementById('priceListModal').classList.add('active');
      showPriceTab('labor');
    }

    // ===== ROOM MANAGEMENT =====
    // Room colors for visual distinction
    const ROOM_COLORS = [
      '#6366f1', // Indigo
      '#10b981', // Emerald
      '#f59e0b', // Amber
      '#ef4444', // Red
      '#8b5cf6', // Purple
      '#06b6d4', // Cyan
      '#ec4899', // Pink
      '#84cc16'  // Lime
    ];

    // Rooms storage - loaded from localStorage
    let projectRooms = JSON.parse(localStorage.getItem('sg_project_rooms') || 'null') || [
      { id: 'default', name: 'Default Room', color: '#6366f1' }
    ];
    let currentRoom = 'default';

    // Initialize room selector
    function initRoomSelector() {
      const select = document.getElementById('currentRoomSelect');
      if (!select) return;

      select.innerHTML = projectRooms.map(room =>
        `<option value="${room.id}" ${room.id === currentRoom ? 'selected' : ''}>${room.name}</option>`
      ).join('');
    }

    // Switch active room
    function switchRoom(roomId) {
      currentRoom = roomId;
      localStorage.setItem('sg_current_room', currentRoom);

      // Update elements display (could filter by room)
      calculateQuote();
    }

    // Open room manager modal
    function openRoomManager() {
      renderRoomList();
      document.getElementById('roomManagerModal').classList.add('active');
    }

    // Render room list in manager
    function renderRoomList() {
      const list = document.getElementById('roomList');
      if (!list) return;

      if (projectRooms.length === 0) {
        list.innerHTML = '<p class="empty-state">No rooms created yet</p>';
        return;
      }

      // Count elements per room
      const roomCounts = {};
      elements.forEach(el => {
        const room = el.roomId || 'default';
        roomCounts[room] = (roomCounts[room] || 0) + 1;
      });

      list.innerHTML = projectRooms.map(room => `
        <div class="room-list-item" data-room-id="${room.id}">
          <div class="room-color" style="background: ${room.color};"></div>
          <div class="room-name">${room.name}</div>
          <div class="room-count">${roomCounts[room.id] || 0} items</div>
          <div class="room-actions">
            <button onclick="editRoom('${room.id}')" title="Edit">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:14px;height:14px;">
                <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/>
                <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/>
              </svg>
            </button>
            ${room.id !== 'default' ? `
              <button class="delete" onclick="deleteRoom('${room.id}')" title="Delete">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:14px;height:14px;">
                  <polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/>
                </svg>
              </button>
            ` : ''}
          </div>
        </div>
      `).join('');
    }

    // Add new room
    function addRoom() {
      const nameInput = document.getElementById('newRoomName');
      const name = nameInput.value.trim();

      if (!name) {
        showNotification('Please enter a room name', 'error');
        return;
      }

      // Check for duplicate
      if (projectRooms.some(r => r.name.toLowerCase() === name.toLowerCase())) {
        showNotification('A room with this name already exists', 'error');
        return;
      }

      const newRoom = {
        id: 'room_' + Date.now(),
        name: name,
        color: ROOM_COLORS[projectRooms.length % ROOM_COLORS.length]
      };

      projectRooms.push(newRoom);
      saveRooms();

      nameInput.value = '';
      renderRoomList();
      initRoomSelector();

      showNotification(`Room "${name}" created`, 'success');
    }

    // Edit room
    function editRoom(roomId) {
      const room = projectRooms.find(r => r.id === roomId);
      if (!room) return;

      const newName = prompt('Enter new room name:', room.name);
      if (newName && newName.trim()) {
        room.name = newName.trim();
        saveRooms();
        renderRoomList();
        initRoomSelector();
      }
    }

    // Delete room
    async function deleteRoom(roomId) {
      if (roomId === 'default') return;

      const room = projectRooms.find(r => r.id === roomId);
      if (!room) return;

      const confirmed = await showConfirmDialog({
        title: 'Delete Room?',
        message: `Delete room "${room.name}"?\n\nElements in this room will be moved to Default Room.`,
        confirmText: 'Delete Room',
        cancelText: 'Cancel',
        dangerous: true
      });
      if (!confirmed) return;

      // Move elements to default room
      elements.forEach(el => {
        if (el.roomId === roomId) {
          el.roomId = 'default';
        }
      });

      projectRooms = projectRooms.filter(r => r.id !== roomId);
      saveRooms();

      if (currentRoom === roomId) {
        currentRoom = 'default';
      }

      renderRoomList();
      initRoomSelector();
      calculateQuote();

      showNotification('Room deleted', 'info');
    }

    // Save rooms to localStorage
    function saveRooms() {
      localStorage.setItem('sg_project_rooms', JSON.stringify(projectRooms));
    }

    // Assign element to room
    function assignElementToRoom(elementId, roomId) {
      const el = elements.find(e => e.id === elementId);
      if (el) {
        el.roomId = roomId;
        calculateQuote();
      }
    }

    // ===== QUOTE PREVIEW MODAL =====
    let quotePreviewData = {};
    let quoteTaxRate = 0;

    function openQuotePreview() {
      // Build quote data with editable prices
      buildQuotePreviewData();

      // Populate room filter
      const roomFilter = document.getElementById('quoteRoomFilter');
      roomFilter.innerHTML = '<option value="all">All Rooms</option>' +
        projectRooms.map(r => `<option value="${r.id}">${r.name}</option>`).join('');

      // Render quote items
      renderQuotePreviewTable('all');

      // Update totals
      updateQuotePreviewTotals();

      // Pre-fill customer info - priority: lead info > saved customer > empty
      if (currentLeadInfo && currentLeadInfo.name) {
        // Use lead info (from account dashboard)
        document.getElementById('quoteCustomerName').value = currentLeadInfo.name || '';
        document.getElementById('quoteCustomerEmail').value = currentLeadInfo.email || '';
        document.getElementById('quoteCustomerPhone').value = currentLeadInfo.phone || '';
        document.getElementById('quoteProjectName').value = currentProjectName || `${currentLeadInfo.projectType || ''} Project`.trim();

        // Pre-fill notes with lead message if available
        if (currentLeadInfo.notes) {
          document.getElementById('quoteNotes').value = `Customer Request: ${currentLeadInfo.notes}`;
        }
      } else {
        // Load saved customer info if any
        const savedCustomer = JSON.parse(localStorage.getItem('sg_quote_customer') || '{}');
        document.getElementById('quoteCustomerName').value = savedCustomer.name || '';
        document.getElementById('quoteCustomerEmail').value = savedCustomer.email || '';
        document.getElementById('quoteCustomerPhone').value = savedCustomer.phone || '';
        document.getElementById('quoteProjectName').value = currentProjectName || '';
      }

      document.getElementById('quotePreviewModal').classList.add('active');
    }

    function buildQuotePreviewData() {
      quotePreviewData = { items: [], roomTotals: {} };

      // Process elements similar to calculateQuote but store editable data
      const COUNTERTOP_TYPES = ['countertop', 'countertop-corner', 'countertop-l', 'countertop-u', 'island'];
      const CABINET_TYPES = ['base-cabinet', 'wall-cabinet', 'tall-cabinet', 'corner-cabinet', 'sink-base', 'drawer-base', 'lazy-susan', 'fridge-cabinet', 'pantry', 'blind-corner'];

      elements.forEach(el => {
        const roomId = el.roomId || 'default';
        const priceInfo = getElementPrice(el);
        const margin = getElementMargin(el);

        const isCountertop = COUNTERTOP_TYPES.some(ct => el.type.includes(ct) || el.type === ct);
        const isCabinet = CABINET_TYPES.some(ct => el.type.includes(ct) || el.type === ct);

        let sqft = 0;
        let baseCost = 0;
        let qty = 1;
        let unit = 'unit';

        if (isCountertop || el.type.includes('backsplash') || el.type.includes('flooring')) {
          sqft = getElementSqft(el);
          baseCost = sqft * priceInfo.price;
          qty = sqft;
          unit = 'sqft';
        } else {
          baseCost = priceInfo.price;
        }

        // Use override prices if set, otherwise calculate
        const costPrice = el.overrideCost !== undefined ? el.overrideCost : baseCost;
        const retailPrice = el.overrideRetail !== undefined ? el.overrideRetail : baseCost * (1 + margin / 100);

        quotePreviewData.items.push({
          id: el.id,
          elementRef: el,
          roomId: roomId,
          label: el.label || el.type,
          type: el.type,
          isCountertop,
          isCabinet,
          isLabor: false,
          qty: qty,
          unit: unit,
          sqft: sqft,
          baseCost: baseCost,
          costPrice: costPrice,
          retailPrice: retailPrice,
          margin: margin,
          isOverridden: el.overrideCost !== undefined || el.overrideRetail !== undefined
        });

        // Track room totals
        if (!quotePreviewData.roomTotals[roomId]) {
          quotePreviewData.roomTotals[roomId] = { cost: 0, retail: 0 };
        }
        quotePreviewData.roomTotals[roomId].cost += costPrice;
        quotePreviewData.roomTotals[roomId].retail += retailPrice;
      });

      // Add labor items
      const totalCountertopSqft = quotePreviewData.items
        .filter(i => i.isCountertop)
        .reduce((sum, i) => sum + i.sqft, 0);

      const totalCabinetCount = quotePreviewData.items
        .filter(i => i.isCabinet)
        .length;

      if (totalCountertopSqft > 0 && userLaborRates.stone) {
        const fabRate = userLaborRates.stone.fabrication?.rate || 0;
        const installRate = userLaborRates.stone.installation?.rate || 0;
        const laborMargin = PRICING_STATE.categoryMargins.labor || 20;

        if (fabRate > 0) {
          const fabCost = totalCountertopSqft * fabRate;
          quotePreviewData.items.push({
            id: 'labor-fab',
            roomId: 'labor',
            label: `Stone Fabrication (${totalCountertopSqft.toFixed(1)} sqft)`,
            type: 'labor',
            isLabor: true,
            qty: totalCountertopSqft,
            unit: 'sqft',
            baseCost: fabCost,
            costPrice: fabCost,
            retailPrice: fabCost * (1 + laborMargin / 100),
            margin: laborMargin
          });
        }

        if (installRate > 0) {
          const installCost = totalCountertopSqft * installRate;
          quotePreviewData.items.push({
            id: 'labor-install',
            roomId: 'labor',
            label: `Countertop Installation (${totalCountertopSqft.toFixed(1)} sqft)`,
            type: 'labor',
            isLabor: true,
            qty: totalCountertopSqft,
            unit: 'sqft',
            baseCost: installCost,
            costPrice: installCost,
            retailPrice: installCost * (1 + laborMargin / 100),
            margin: laborMargin
          });
        }
      }

      if (totalCabinetCount > 0 && userLaborRates.cabinet) {
        const cabInstallRate = userLaborRates.cabinet.installation?.rate || 0;
        const laborMargin = PRICING_STATE.categoryMargins.labor || 20;

        if (cabInstallRate > 0) {
          const cabInstallCost = totalCabinetCount * cabInstallRate;
          quotePreviewData.items.push({
            id: 'labor-cab',
            roomId: 'labor',
            label: `Cabinet Installation (${totalCabinetCount} cabinets)`,
            type: 'labor',
            isLabor: true,
            qty: totalCabinetCount,
            unit: 'cabinet',
            baseCost: cabInstallCost,
            costPrice: cabInstallCost,
            retailPrice: cabInstallCost * (1 + laborMargin / 100),
            margin: laborMargin
          });
        }
      }
    }

    function renderQuotePreviewTable(filterRoom) {
      const tbody = document.getElementById('quotePreviewBody');
      if (!tbody) return;

      let html = '';
      let currentRoomId = null;

      // Sort items by room
      const sortedItems = [...quotePreviewData.items].sort((a, b) => {
        if (a.roomId === b.roomId) return 0;
        if (a.roomId === 'labor') return 1;
        if (b.roomId === 'labor') return -1;
        return a.roomId.localeCompare(b.roomId);
      });

      // Filter by room if needed
      const filteredItems = filterRoom === 'all'
        ? sortedItems
        : sortedItems.filter(i => i.roomId === filterRoom || i.roomId === 'labor');

      filteredItems.forEach((item, index) => {
        // Add room header if room changed
        if (item.roomId !== currentRoomId && filterRoom === 'all') {
          const room = item.roomId === 'labor'
            ? { name: 'Labor & Services', color: '#6366f1' }
            : projectRooms.find(r => r.id === item.roomId) || { name: 'Unknown', color: '#888' };

          html += `
            <tr class="room-header">
              <td colspan="6">
                <span style="display: inline-block; width: 12px; height: 12px; border-radius: 3px; background: ${room.color}; margin-right: 8px;"></span>
                ${room.name}
              </td>
            </tr>
          `;
          currentRoomId = item.roomId;
        }

        // Determine icon
        let iconClass = 'other';
        let iconSymbol = '';
        if (item.isCountertop) {
          iconClass = 'countertop';
          iconSymbol = '';
        } else if (item.isCabinet) {
          iconClass = 'cabinet';
          iconSymbol = '';
        } else if (item.isLabor) {
          iconClass = 'labor';
          iconSymbol = '';
        }

        // Calculate current margin
        const currentMargin = item.costPrice > 0 ? ((item.retailPrice / item.costPrice - 1) * 100).toFixed(0) : 0;
        const marginClass = currentMargin < 15 ? 'low' : 'high';

        html += `
          <tr data-item-id="${item.id}">
            <td><div class="quote-item-type-icon ${iconClass}">${iconSymbol}</div></td>
            <td>
              <div style="font-weight: 500;">${item.label}</div>
              ${item.sqft > 0 ? `<div style="font-size: 11px; color: var(--text-muted);">${item.sqft.toFixed(1)} sqft</div>` : ''}
            </td>
            <td style="text-align: center;">${item.qty > 1 ? (item.unit === 'sqft' ? item.qty.toFixed(1) : item.qty) : '1'}</td>
            <td>
              <input type="number"
                     class="quote-editable-input ${item.isOverridden ? 'modified' : ''}"
                     value="${item.costPrice.toFixed(2)}"
                     step="0.01"
                     min="0"
                     onchange="updateQuoteItemCost('${item.id}', this.value)"
                     ${item.isLabor ? 'readonly' : ''}>
            </td>
            <td>
              <input type="number"
                     class="quote-editable-input ${item.isOverridden ? 'modified' : ''}"
                     value="${item.retailPrice.toFixed(2)}"
                     step="0.01"
                     min="0"
                     onchange="updateQuoteItemRetail('${item.id}', this.value)">
            </td>
            <td><span class="quote-margin-badge ${marginClass}">${currentMargin}%</span></td>
          </tr>
        `;
      });

      tbody.innerHTML = html || '<tr><td colspan="6" style="text-align: center; padding: 40px; color: var(--text-muted);">No items in quote</td></tr>';
    }

    function updateQuoteItemCost(itemId, value) {
      const item = quotePreviewData.items.find(i => i.id === itemId);
      if (!item) return;

      const newCost = parseFloat(value) || 0;
      item.costPrice = newCost;
      item.isOverridden = true;

      // Update element if it's a design element
      if (item.elementRef) {
        item.elementRef.overrideCost = newCost;
      }

      updateQuotePreviewTotals();
    }

    function updateQuoteItemRetail(itemId, value) {
      const item = quotePreviewData.items.find(i => i.id === itemId);
      if (!item) return;

      const newRetail = parseFloat(value) || 0;
      item.retailPrice = newRetail;
      item.isOverridden = true;

      // Update element if it's a design element
      if (item.elementRef) {
        item.elementRef.overrideRetail = newRetail;
      }

      // Update margin badge
      const row = document.querySelector(`tr[data-item-id="${itemId}"]`);
      if (row) {
        const margin = item.costPrice > 0 ? ((newRetail / item.costPrice - 1) * 100).toFixed(0) : 0;
        const badge = row.querySelector('.quote-margin-badge');
        if (badge) {
          badge.textContent = margin + '%';
          badge.className = 'quote-margin-badge ' + (margin < 15 ? 'low' : 'high');
        }
      }

      updateQuotePreviewTotals();
    }

    function updateQuoteTax(value) {
      quoteTaxRate = parseFloat(value) || 0;
      updateQuotePreviewTotals();
    }

    function updateQuotePreviewTotals() {
      const subtotal = quotePreviewData.items.reduce((sum, i) => sum + i.retailPrice, 0);
      const tax = subtotal * (quoteTaxRate / 100);
      const total = subtotal + tax;

      document.getElementById('quotePreviewSubtotal').textContent = '$' + subtotal.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2});
      document.getElementById('quotePreviewTax').textContent = '$' + tax.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2});
      document.getElementById('quotePreviewTotal').textContent = '$' + total.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2});
      document.getElementById('quoteTaxRate').textContent = quoteTaxRate;
    }

    function filterQuoteByRoom(roomId) {
      renderQuotePreviewTable(roomId);
    }

    // ===== QUOTE SHARING =====
    async function shareQuoteLink() {
      document.getElementById('generatedLinkSection').style.display = 'none';
      document.getElementById('generateLinkBtn').textContent = 'Generate Link';
      document.getElementById('shareQuoteModal').classList.add('active');
    }

    async function generateQuoteShareLink() {
      const btn = document.getElementById('generateLinkBtn');
      btn.textContent = 'Generating...';
      btn.disabled = true;

      try {
        // Save design to Supabase for sharing
        const shareData = {
          projectName: currentProjectName || 'Untitled Design',
          customerEmail: document.getElementById('shareCustomerEmail').value || null,
          showPricing: document.getElementById('shareShowPricing').checked,
          allowDeposit: document.getElementById('shareAllowDeposit').checked,
          allowSchedule: document.getElementById('shareAllowSchedule').checked,
          expiryDays: parseInt(document.getElementById('shareLinkExpiry').value),
          rooms: projectRooms,
          elements: elements.map(el => ({
            ...el,
            // Strip out Three.js objects
            mesh: undefined,
            object3D: undefined
          })),
          quoteItems: quotePreviewData.items,
          totalRetail: quotePreviewData.items.reduce((sum, i) => sum + i.retailPrice, 0),
          createdAt: new Date().toISOString()
        };

        // Generate unique share ID
        const shareId = 'sq_' + Date.now().toString(36) + Math.random().toString(36).substr(2, 9);

        // Save to Supabase
        const { data, error } = await supabaseClient
          .from('shared_quotes')
          .insert({
            share_id: shareId,
            project_name: shareData.projectName,
            customer_email: shareData.customerEmail,
            show_pricing: shareData.showPricing,
            allow_deposit: shareData.allowDeposit,
            allow_schedule: shareData.allowSchedule,
            expires_at: shareData.expiryDays > 0 ? new Date(Date.now() + shareData.expiryDays * 24 * 60 * 60 * 1000).toISOString() : null,
            data: shareData,
            lead_id: currentLeadInfo?.id || window.currentLeadId || null,
            created_by: (await supabaseClient.auth.getUser()).data?.user?.id || null
          })
          .select()
          .single();

        // If linked to a lead, update lead status to "quoted"
        if (currentLeadInfo?.id || window.currentLeadId) {
          await supabaseClient
            .from('leads')
            .update({ status: 'quoted', updated_at: new Date().toISOString() })
            .eq('id', currentLeadInfo?.id || window.currentLeadId);
        }

        if (error) throw error;

        // Generate shareable URL
        const shareUrl = `${window.location.origin}/quote/view/?id=${shareId}`;

        document.getElementById('generatedShareLink').value = shareUrl;
        document.getElementById('generatedLinkSection').style.display = 'block';

        btn.textContent = 'Link Generated!';
        setTimeout(() => {
          btn.textContent = 'Generate New Link';
          btn.disabled = false;
        }, 2000);

        showNotification('Share link generated!', 'success');

      } catch (error) {
        console.error('Error generating share link:', error);

        // Fallback: create a local share link with encoded data
        const encodedData = btoa(JSON.stringify({
          name: currentProjectName,
          items: quotePreviewData.items.slice(0, 20), // Limit for URL length
          total: quotePreviewData.items.reduce((sum, i) => sum + i.retailPrice, 0)
        }));

        const fallbackUrl = `${window.location.origin}/tools/room-designer/share.html?data=${encodedData.substr(0, 1000)}`;
        document.getElementById('generatedShareLink').value = fallbackUrl;
        document.getElementById('generatedLinkSection').style.display = 'block';

        btn.textContent = 'Generate Link';
        btn.disabled = false;

        showNotification('Share link created (local only)', 'warning');
      }
    }

    function copyGeneratedLink() {
      const input = document.getElementById('generatedShareLink');
      input.select();
      document.execCommand('copy');
      showNotification('Link copied to clipboard!', 'success');
    }

    function copyQuoteLink() {
      // Quick copy current design link
      shareQuoteLink();
    }

    // Send quote via email
    async function sendQuoteEmail() {
      const customerEmail = document.getElementById('quoteCustomerEmail').value;
      const customerName = document.getElementById('quoteCustomerName').value;

      if (!customerEmail) {
        showNotification('Please enter customer email', 'error');
        return;
      }

      // Save customer info
      localStorage.setItem('sg_quote_customer', JSON.stringify({
        name: customerName,
        email: customerEmail,
        phone: document.getElementById('quoteCustomerPhone').value
      }));

      // For now, generate link and show email instructions
      await generateQuoteShareLink();

      const shareUrl = document.getElementById('generatedShareLink').value;
      const total = document.getElementById('quotePreviewTotal').textContent;

      // Open email client
      const subject = encodeURIComponent(`Quote for ${currentProjectName || 'Your Project'} - Surprise Granite`);
      const body = encodeURIComponent(
        `Hi ${customerName || 'Valued Customer'},\n\n` +
        `Thank you for your interest! Here is your quote for ${currentProjectName || 'your project'}:\n\n` +
        `Estimated Total: ${total}\n\n` +
        `View your full quote and design here:\n${shareUrl}\n\n` +
        `If you have any questions, please don't hesitate to reach out.\n\n` +
        `Best regards,\nSurprise Granite Team`
      );

      window.open(`mailto:${customerEmail}?subject=${subject}&body=${body}`, '_blank');

      showNotification('Email client opened', 'success');
    }

    // ===== ESTIMATE DATABASE FUNCTIONS =====
    let currentEstimateId = null;
    let currentEstimateNumber = null;

    async function saveEstimateToDatabase() {
      const btn = document.getElementById('saveEstimateBtn');
      const originalText = btn.innerHTML;

      // Get customer info
      const customerName = document.getElementById('quoteCustomerName').value.trim();
      const customerEmail = document.getElementById('quoteCustomerEmail').value.trim();
      const customerPhone = document.getElementById('quoteCustomerPhone').value.trim();
      const customerAddress = document.getElementById('quoteCustomerAddress').value.trim();
      const projectName = document.getElementById('quoteProjectName').value.trim() || currentProjectName || 'Untitled Project';
      const notes = document.getElementById('quoteNotes').value.trim();
      const taxRate = parseFloat(document.getElementById('quoteTaxInput').value) || 0;

      // Validate required fields
      if (!customerName) {
        showNotification('Customer name is required', 'error');
        document.getElementById('quoteCustomerName').focus();
        return;
      }
      if (!customerEmail) {
        showNotification('Customer email is required', 'error');
        document.getElementById('quoteCustomerEmail').focus();
        return;
      }

      // Check if user is logged in
      const user = window.SgAuth?.getUser();
      if (!user) {
        showLoginPrompt('Please log in to save estimates.');
        return;
      }

      btn.innerHTML = '<span class="spinner" style="width:14px;height:14px;border:2px solid transparent;border-top-color:currentColor;border-radius:50%;animation:spin 1s linear infinite;display:inline-block;margin-right:6px;"></span> Saving...';
      btn.disabled = true;

      try {
        const { url: SUPABASE_URL, anonKey: SUPABASE_ANON_KEY } = getSupabaseConfig();

        const session = await window.SgAuth?.getSession?.();
        const authToken = session?.access_token || SUPABASE_ANON_KEY;

        const headers = {
          'apikey': SUPABASE_ANON_KEY,
          'Authorization': `Bearer ${authToken}`,
          'Accept': 'application/json',
          'Content-Type': 'application/json',
          'Prefer': 'return=representation'
        };

        // Get next estimate number using RPC function
        let estimateNumber = 'EST-' + Date.now().toString().slice(-6); // Fallback
        try {
          const rpcResponse = await fetch(`${SUPABASE_URL}/rest/v1/rpc/get_next_estimate_number`, {
            method: 'POST',
            headers,
            body: JSON.stringify({ p_user_id: user.id })
          });
          if (rpcResponse.ok) {
            const rpcData = await rpcResponse.json();
            if (rpcData) estimateNumber = rpcData;
          }
        } catch (e) {
          console.log('Could not get estimate number from DB, using fallback:', e);
        }

        // Calculate totals from quote preview data
        buildQuotePreviewData();
        const subtotal = quotePreviewData.items.reduce((sum, i) => sum + i.retailPrice, 0);
        const taxAmount = subtotal * (taxRate / 100);
        const total = subtotal + taxAmount;

        // Parse address into components if possible
        const addressParts = customerAddress.split(',').map(s => s.trim());
        const city = addressParts[1] || '';
        const stateZip = addressParts[2] || '';
        const [state, zip] = stateZip.split(' ').filter(Boolean);

        // Create or find customer record  use pre-selected customer if available
        let customerId = window._selectedQuoteCustomerId || null;
        try {
          if (customerId) {
            console.log('Using pre-selected customer:', customerId);
          }
          // If not pre-selected, check if customer exists by email
          if (!customerId) {
          const customerLookup = await fetch(
            `${SUPABASE_URL}/rest/v1/customers?email=eq.${encodeURIComponent(customerEmail)}&select=id`,
            { method: 'GET', headers }
          );

          if (customerLookup.ok) {
            const existingCustomers = await customerLookup.json();
            if (existingCustomers && existingCustomers.length > 0) {
              customerId = existingCustomers[0].id;
              console.log('Found existing customer:', customerId);
            }
          }

          // If no customer exists, create one
          if (!customerId) {
            const customerData = {
              email: customerEmail,
              name: customerName,
              phone: customerPhone || null,
              address: addressParts[0] || customerAddress,
              city: city || null,
              state: state || null,
              zip: zip || null,
              source: 'room_designer',
              created_by: user.id
            };

            const createCustomerResponse = await fetch(`${SUPABASE_URL}/rest/v1/customers`, {
              method: 'POST',
              headers,
              body: JSON.stringify(customerData)
            });

            if (createCustomerResponse.ok) {
              const newCustomer = await createCustomerResponse.json();
              customerId = Array.isArray(newCustomer) ? newCustomer[0]?.id : newCustomer.id;
              console.log('Created new customer:', customerId);
            }
          }
          } // end if (!customerId)  skip lookup/create when pre-selected
        } catch (e) {
          console.log('Customer creation optional, continuing:', e);
        }

        // Create estimate record
        const estimateData = {
          user_id: user.id,
          customer_id: customerId || null,
          estimate_number: estimateNumber,
          customer_name: customerName,
          customer_email: customerEmail,
          customer_phone: customerPhone || null,
          customer_address: addressParts[0] || customerAddress,
          customer_city: city || null,
          customer_state: state || null,
          customer_zip: zip || null,
          project_name: projectName,
          project_description: `Room Designer Quote - ${rooms.length} room(s)`,
          estimate_date: new Date().toISOString().split('T')[0],
          valid_until: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString().split('T')[0], // 30 days
          subtotal: subtotal,
          tax_rate: taxRate,
          tax_amount: taxAmount,
          total: total,
          deposit_percent: 50,
          deposit_amount: total * 0.5,
          notes: notes || null,
          status: 'draft'
        };

        // Insert estimate
        const estimateResponse = await fetch(`${SUPABASE_URL}/rest/v1/estimates`, {
          method: 'POST',
          headers,
          body: JSON.stringify(estimateData)
        });

        if (!estimateResponse.ok) {
          const errorText = await estimateResponse.text();
          throw new Error(`Failed to create estimate: ${errorText}`);
        }

        const estimateResult = await estimateResponse.json();
        const estimateId = Array.isArray(estimateResult) ? estimateResult[0]?.id : estimateResult.id;

        if (!estimateId) {
          throw new Error('No estimate ID returned');
        }

        currentEstimateId = estimateId;
        currentEstimateNumber = estimateNumber;

        // Create estimate line items
        const lineItems = quotePreviewData.items.map((item, index) => ({
          estimate_id: estimateId,
          name: item.label,
          description: `${item.type} - ${item.unit === 'sqft' ? item.sqft.toFixed(1) + ' sqft' : item.qty + ' ' + item.unit}`,
          category: item.isLabor ? 'labor' : (item.isCountertop ? 'material' : (item.isCabinet ? 'cabinet' : 'other')),
          quantity: item.qty,
          unit_type: item.unit,
          unit_price: item.retailPrice / item.qty,
          total: item.retailPrice,
          cost: item.costPrice,
          sort_order: index,
          group_name: item.roomId === 'labor' ? 'Labor' : (rooms.find(r => r.id === item.roomId)?.name || 'Default Room')
        }));

        if (lineItems.length > 0) {
          const itemsResponse = await fetch(`${SUPABASE_URL}/rest/v1/estimate_items`, {
            method: 'POST',
            headers,
            body: JSON.stringify(lineItems)
          });

          if (!itemsResponse.ok) {
            console.error('Failed to create line items:', await itemsResponse.text());
          }
        }

        // Create access token for customer viewing
        const accessToken = generateToken(32);
        const tokenResponse = await fetch(`${SUPABASE_URL}/rest/v1/estimate_tokens`, {
          method: 'POST',
          headers,
          body: JSON.stringify({
            estimate_id: estimateId,
            token: accessToken,
            expires_at: new Date(Date.now() + 90 * 24 * 60 * 60 * 1000).toISOString() // 90 days
          })
        });

        // Generate customer view URL
        const viewUrl = `${window.location.origin}/estimate/view?token=${accessToken}`;

        // Update UI
        document.getElementById('estimateNumberBadge').textContent = estimateNumber;
        document.getElementById('estimateNumberBadge').style.display = 'block';
        document.getElementById('estimateStatusSection').style.display = 'block';
        document.getElementById('estimateStatusText').textContent = `Estimate ${estimateNumber} saved!`;
        document.getElementById('estimateViewLink').value = viewUrl;
        document.getElementById('estimateShareUrl').style.display = 'block';

        // Show Convert to Job button
        const jobBtn = document.getElementById('convertToJobBtn');
        if (jobBtn) {
          jobBtn.style.display = 'inline-flex';
          jobBtn.disabled = false;
          jobBtn.innerHTML = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align:middle;margin-right:4px;"><path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"/><polyline points="3.27 6.96 12 12.01 20.73 6.96"/><line x1="12" y1="22.08" x2="12" y2="12"/></svg> Create Job';
        }
        const jobBadge = document.getElementById('jobCreatedBadge');
        if (jobBadge) jobBadge.style.display = 'none';

        // Store estimate context for job conversion
        window._lastEstimateContext = {
          estimateId: estimateId,
          estimateNumber: estimateNumber,
          customerId: customerId,
          customerName: customerName,
          customerEmail: customerEmail,
          customerPhone: customerPhone,
          customerAddress: customerAddress,
          projectName: projectName,
          total: total,
          depositAmount: total * 0.5,
          roomType: document.getElementById('roomType')?.value || 'kitchen'
        };

        // Save to localStorage for persistence
        localStorage.setItem('sg_last_estimate', JSON.stringify({
          id: estimateId,
          number: estimateNumber,
          token: accessToken,
          customerEmail: customerEmail,
          total: total,
          createdAt: new Date().toISOString()
        }));

        showNotification(`Estimate ${estimateNumber} saved successfully!`, 'success');

      } catch (error) {
        console.error('Error saving estimate:', error);
        showNotification('Failed to save estimate: ' + error.message, 'error');
      } finally {
        btn.innerHTML = originalText;
        btn.disabled = false;
      }
    }

    function copyEstimateLink() {
      const linkInput = document.getElementById('estimateViewLink');
      linkInput.select();
      document.execCommand('copy');
      showNotification('Estimate link copied!', 'success');
    }

    // ===== CUSTOMER SEARCH IN QUOTE MODAL =====
    let _quoteSearchTimeout = null;
    window._selectedQuoteCustomerId = null;

    async function searchQuoteCustomers(query) {
      clearTimeout(_quoteSearchTimeout);
      const resultsDiv = document.getElementById('quoteCustomerResults');
      if (!resultsDiv) return;

      if (!query || query.trim().length < 2) {
        resultsDiv.style.display = 'none';
        resultsDiv.innerHTML = '';
        return;
      }

      _quoteSearchTimeout = setTimeout(async () => {
        try {
          const { url: SUPABASE_URL, anonKey: SUPABASE_ANON_KEY } = getSupabaseConfig();
          const session = await window.SgAuth?.getSession?.();
          const authToken = session?.access_token || SUPABASE_ANON_KEY;
          const headers = {
            'apikey': SUPABASE_ANON_KEY,
            'Authorization': 'Bearer ' + authToken,
            'Accept': 'application/json'
          };

          const q = encodeURIComponent(query.trim());
          const [byName, byEmail] = await Promise.all([
            fetch(SUPABASE_URL + '/rest/v1/customers?name=ilike.*' + q + '*&select=id,name,email,phone,address,total_jobs&limit=8', { headers }).then(r => r.ok ? r.json() : []).catch(() => []),
            fetch(SUPABASE_URL + '/rest/v1/customers?email=ilike.*' + q + '*&select=id,name,email,phone,address,total_jobs&limit=8', { headers }).then(r => r.ok ? r.json() : []).catch(() => [])
          ]);

          // Deduplicate by id
          const seen = new Set();
          const customers = [];
          [...byName, ...byEmail].forEach(c => {
            if (c && c.id && !seen.has(c.id)) {
              seen.add(c.id);
              customers.push(c);
            }
          });

          if (customers.length === 0) {
            resultsDiv.innerHTML = '<div style="padding:10px 12px;color:#94a3b8;font-size:13px;">No customers found</div>';
            resultsDiv.style.display = 'block';
            return;
          }

          resultsDiv.innerHTML = customers.map(c => {
            const initials = (c.name || '?').split(' ').map(w => w[0]).join('').substring(0, 2).toUpperCase();
            const jobsBadge = c.total_jobs ? '<span class="quote-cust-jobs-badge">' + c.total_jobs + ' job' + (c.total_jobs !== 1 ? 's' : '') + '</span>' : '';
            return '<div class="quote-cust-item" onclick=\'selectQuoteCustomer(' + JSON.stringify(c).replace(/'/g, "\\'") + ')\'>'
              + '<div class="quote-cust-avatar">' + initials + '</div>'
              + '<div class="quote-cust-info">'
              + '<div class="quote-cust-name">' + (c.name || 'Unknown') + ' ' + jobsBadge + '</div>'
              + '<div class="quote-cust-email">' + (c.email || '') + (c.phone ? ' &bull; ' + c.phone : '') + '</div>'
              + '</div></div>';
          }).join('');
          resultsDiv.style.display = 'block';
        } catch (err) {
          console.error('Customer search error:', err);
          resultsDiv.innerHTML = '<div style="padding:10px 12px;color:#f87171;font-size:13px;">Search error</div>';
          resultsDiv.style.display = 'block';
        }
      }, 300);
    }

    function selectQuoteCustomer(customer) {
      window._selectedQuoteCustomerId = customer.id;

      // Fill form fields
      const nameEl = document.getElementById('quoteCustomerName');
      const emailEl = document.getElementById('quoteCustomerEmail');
      const phoneEl = document.getElementById('quoteCustomerPhone');
      const addressEl = document.getElementById('quoteCustomerAddress');
      if (nameEl) nameEl.value = customer.name || '';
      if (emailEl) emailEl.value = customer.email || '';
      if (phoneEl) phoneEl.value = customer.phone || '';
      if (addressEl) addressEl.value = customer.address || '';

      // Show selected banner
      const banner = document.getElementById('quoteCustomerSelectedBanner');
      const selectedName = document.getElementById('quoteSelectedName');
      const selectedMeta = document.getElementById('quoteSelectedMeta');
      if (banner) {
        if (selectedName) selectedName.textContent = customer.name || 'Customer';
        if (selectedMeta) selectedMeta.textContent = (customer.email || '') + (customer.phone ? ' \u2022 ' + customer.phone : '');
        banner.style.display = 'flex';
      }

      // Hide search results and clear search input
      const resultsDiv = document.getElementById('quoteCustomerResults');
      if (resultsDiv) { resultsDiv.style.display = 'none'; resultsDiv.innerHTML = ''; }
      const searchInput = document.getElementById('quoteCustomerSearch');
      if (searchInput) searchInput.value = '';

      // Load existing jobs for this customer
      loadCustomerJobsCount(customer.id);
    }

    function clearQuoteCustomerSelection() {
      window._selectedQuoteCustomerId = null;
      const banner = document.getElementById('quoteCustomerSelectedBanner');
      if (banner) banner.style.display = 'none';

      // Clear form fields
      ['quoteCustomerName', 'quoteCustomerEmail', 'quoteCustomerPhone', 'quoteCustomerAddress'].forEach(id => {
        const el = document.getElementById(id);
        if (el) el.value = '';
      });

      // Remove jobs badge if present
      const jobsInfo = document.getElementById('quoteCustomerJobsInfo');
      if (jobsInfo) jobsInfo.remove();
    }

    async function loadCustomerJobsCount(customerId) {
      try {
        const { url: SUPABASE_URL, anonKey: SUPABASE_ANON_KEY } = getSupabaseConfig();
        const session = await window.SgAuth?.getSession?.();
        const authToken = session?.access_token || SUPABASE_ANON_KEY;
        const headers = {
          'apikey': SUPABASE_ANON_KEY,
          'Authorization': 'Bearer ' + authToken,
          'Accept': 'application/json'
        };

        const res = await fetch(
          SUPABASE_URL + '/rest/v1/jobs?customer_id=eq.' + customerId + '&select=id,job_number,status,contract_amount&order=created_at.desc&limit=5',
          { headers }
        );
        if (!res.ok) return;
        const jobs = await res.json();
        if (!Array.isArray(jobs) || jobs.length === 0) return;

        // Remove any existing jobs info
        const existing = document.getElementById('quoteCustomerJobsInfo');
        if (existing) existing.remove();

        // Insert jobs info after the selected banner
        const banner = document.getElementById('quoteCustomerSelectedBanner');
        if (!banner) return;

        const jobsList = jobs.map(j => {
          const statusColors = { new: '#3b82f6', in_progress: '#f59e0b', completed: '#10b981', cancelled: '#ef4444' };
          const color = statusColors[j.status] || '#94a3b8';
          const amount = j.contract_amount ? ' \u2022 $' + Number(j.contract_amount).toLocaleString() : '';
          return '<div style="display:flex;align-items:center;gap:6px;padding:3px 0;font-size:12px;">'
            + '<span style="width:8px;height:8px;border-radius:50%;background:' + color + ';flex-shrink:0;"></span>'
            + '<span style="color:#e2e8f0;">' + (j.job_number || 'Job') + '</span>'
            + '<span style="color:#94a3b8;">' + (j.status || '').replace(/_/g, ' ') + amount + '</span>'
            + '</div>';
        }).join('');

        const infoDiv = document.createElement('div');
        infoDiv.id = 'quoteCustomerJobsInfo';
        infoDiv.style.cssText = 'background:rgba(59,130,246,0.08);border:1px solid rgba(59,130,246,0.2);border-radius:8px;padding:8px 12px;margin-top:6px;margin-bottom:8px;';
        infoDiv.innerHTML = '<div style="font-size:12px;font-weight:600;color:#60a5fa;margin-bottom:4px;">'
          + jobs.length + ' existing job' + (jobs.length !== 1 ? 's' : '') + '</div>' + jobsList;
        banner.insertAdjacentElement('afterend', infoDiv);
      } catch (err) {
        console.error('Load customer jobs error:', err);
      }
    }

    // ===== CONVERT ESTIMATE TO JOB =====
    async function convertEstimateToJob() {
      const ctx = window._lastEstimateContext;
      if (!ctx || !ctx.estimateId) {
        showNotification('No estimate to convert. Please save an estimate first.', 'error');
        return;
      }

      const btn = document.getElementById('convertToJobBtn');
      if (btn) {
        btn.disabled = true;
        btn.innerHTML = '<span class="spinner" style="width:14px;height:14px;border:2px solid transparent;border-top-color:currentColor;border-radius:50%;animation:spin 1s linear infinite;display:inline-block;margin-right:6px;"></span> Creating...';
      }

      try {
        const { url: SUPABASE_URL, anonKey: SUPABASE_ANON_KEY } = getSupabaseConfig();
        const user = window.SgAuth?.getUser();
        if (!user) {
          showNotification('Please log in to create jobs.', 'error');
          return;
        }
        const session = await window.SgAuth?.getSession?.();
        const authToken = session?.access_token || SUPABASE_ANON_KEY;
        const headers = {
          'apikey': SUPABASE_ANON_KEY,
          'Authorization': 'Bearer ' + authToken,
          'Accept': 'application/json',
          'Content-Type': 'application/json',
          'Prefer': 'return=representation'
        };

        // Get next job number via RPC
        let jobNumber = 'JOB-' + Date.now();
        try {
          const rpcRes = await fetch(SUPABASE_URL + '/rest/v1/rpc/get_next_job_number', {
            method: 'POST',
            headers,
            body: JSON.stringify({})
          });
          if (rpcRes.ok) {
            const rpcData = await rpcRes.json();
            if (rpcData) jobNumber = typeof rpcData === 'string' ? rpcData : rpcData.job_number || jobNumber;
          }
        } catch (e) {
          console.warn('Could not get job number via RPC, using fallback:', e);
        }

        // Build job record
        const jobData = {
          user_id: user.id,
          customer_id: ctx.customerId || null,
          estimate_id: ctx.estimateId,
          job_number: jobNumber,
          customer_name: ctx.customerName || '',
          customer_email: ctx.customerEmail || '',
          customer_phone: ctx.customerPhone || '',
          customer_address: ctx.customerAddress || '',
          project_type: ctx.roomType || 'kitchen',
          project_description: ctx.projectName || 'Room Design Project',
          contract_amount: ctx.total || 0,
          deposit_amount: ctx.depositAmount || 0,
          status: 'new'
        };

        const res = await fetch(SUPABASE_URL + '/rest/v1/jobs', {
          method: 'POST',
          headers,
          body: JSON.stringify(jobData)
        });

        if (!res.ok) {
          const errText = await res.text();
          throw new Error('Failed to create job: ' + errText);
        }

        const created = await res.json();
        const createdJob = Array.isArray(created) ? created[0] : created;

        showNotification('Job ' + jobNumber + ' created successfully!', 'success');

        // Update button to show success
        if (btn) {
          btn.style.display = 'none';
        }
        const badge = document.getElementById('jobCreatedBadge');
        if (badge) {
          badge.textContent = '\u2705 Job Created: ' + jobNumber;
          badge.style.display = 'inline-flex';
        }

        // Update customer total_jobs count
        if (ctx.customerId) {
          try {
            const custRes = await fetch(SUPABASE_URL + '/rest/v1/customers?id=eq.' + ctx.customerId + '&select=total_jobs', { headers });
            if (custRes.ok) {
              const custData = await custRes.json();
              const currentCount = (custData[0]?.total_jobs || 0) + 1;
              await fetch(SUPABASE_URL + '/rest/v1/customers?id=eq.' + ctx.customerId, {
                method: 'PATCH',
                headers,
                body: JSON.stringify({ total_jobs: currentCount })
              });
            }
          } catch (e) {
            console.warn('Could not update customer job count:', e);
          }
        }

      } catch (err) {
        console.error('Convert to job error:', err);
        showNotification('Failed to create job: ' + err.message, 'error');
        if (btn) {
          btn.disabled = false;
          btn.innerHTML = '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="2" y="7" width="20" height="14" rx="2"/><path d="M16 7V5a4 4 0 0 0-8 0v2"/></svg> Create Job';
        }
      }
    }

    // Initialize rooms on load
    setTimeout(() => {
      initRoomSelector();
      currentRoom = localStorage.getItem('sg_current_room') || 'default';
    }, 100);

    // ===== MARGIN MODAL FUNCTIONS =====
    function openMarginModal() {
      document.getElementById('globalMarginInput').value = PRICING_STATE.globalMargin;

      // Populate category margins
      document.querySelectorAll('.category-margin-row input').forEach(input => {
        const category = input.dataset.category;
        const value = PRICING_STATE.categoryMargins[category];
        input.value = value !== undefined ? value : PRICING_STATE.globalMargin;
      });

      document.getElementById('marginModal').classList.add('active');
    }

    function applyMargins() {
      PRICING_STATE.globalMargin = parseInt(document.getElementById('globalMarginInput').value) || 30;

      document.querySelectorAll('.category-margin-row input').forEach(input => {
        const category = input.dataset.category;
        const value = parseInt(input.value);
        if (!isNaN(value)) {
          PRICING_STATE.categoryMargins[category] = value;
        }
      });

      closeModal('marginModal');
      calculateQuote();
    }

    // ===== SHARING FUNCTIONS (Supabase) =====

    // ===== PRELOADER FUNCTIONS =====
    // Preloader Steps for Blueprint CAD Animation
    // Minimal preloader
    let preloaderMinTime = 2000;
    let preloaderStartTime = 0;
    let preloaderReady = false;
    let preloaderProgress = 0;
    let preloaderInterval = null;

    function showPreloader(message, companyName) {
      const preloader = document.getElementById('cloudPreloader');
      const companyEl = document.getElementById('preloaderCompanyMain');
      const progressBar = document.getElementById('preloaderProgressBar');

      if (preloader) {
        preloader.classList.remove('loaded');
        preloaderStartTime = Date.now();
        preloaderReady = false;
        preloaderProgress = 0;

        // Set company name
        if (companyEl) {
          companyEl.textContent = companyName || 'Surprise Granite';
        }

        // Reset progress
        if (progressBar) progressBar.style.width = '0%';

        // Clear any existing interval
        if (preloaderInterval) clearInterval(preloaderInterval);

        // Animate progress bar
        preloaderInterval = setInterval(() => {
          preloaderProgress += 2;
          if (progressBar) progressBar.style.width = Math.min(preloaderProgress, 90) + '%';

          if (preloaderProgress >= 90 && preloaderReady) {
            if (progressBar) progressBar.style.width = '100%';
            clearInterval(preloaderInterval);
            setTimeout(hidePreloaderNow, 300);
          }
        }, 40);
      }
    }

    function hidePreloader() {
      preloaderReady = true;
      const elapsed = Date.now() - preloaderStartTime;

      if (elapsed >= preloaderMinTime && preloaderProgress >= 90) {
        const progressBar = document.getElementById('preloaderProgressBar');
        if (progressBar) progressBar.style.width = '100%';
        setTimeout(hidePreloaderNow, 300);
      }
    }

    function hidePreloaderNow() {
      const preloader = document.getElementById('cloudPreloader');
      if (preloaderInterval) {
        clearInterval(preloaderInterval);
        preloaderInterval = null;
      }
      if (preloader) {
        preloader.classList.add('loaded');
      }
    }

    // Get Supabase client - use global client only
    function getSupabaseClient() {
      // Use the global client from supabase-init.js
      return window._sgSupabaseClient || null;
    }

    // Get Supabase credentials from centralized config
    function getSupabaseConfig() {
      const config = window.SG_CONFIG || window._sgSupabaseConfig || {};
      return {
        url: config.SUPABASE_URL || config.url || 'https://ypeypgwsycxcagncgdur.supabase.co',
        anonKey: config.SUPABASE_ANON_KEY || 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InlwZXlwZ3dzeWN4Y2FnbmNnZHVyIiwicm9sZSI6ImFub24iLCJpYXQiOjE3Njc3NTQ4MjMsImV4cCI6MjA4MzMzMDgyM30.R13pNv2FDtGhfeu7gUcttYNrQAbNYitqR4FIq3O2-ME',
        storageKey: config.SUPABASE_STORAGE_KEY || config.storageKey || 'sg-auth-token'
      };
    }

    // Get current authenticated user
    function getCurrentUser() {
      // Try sg-auth first
      if (window.sgAuth && typeof window.sgAuth.getUser === 'function') {
        return window.sgAuth.getUser();
      }
      // Try getting from Supabase session
      const supabase = getSupabaseClient();
      if (supabase) {
        // Note: this is sync access to cached session
        const session = supabase.auth?.session;
        if (session?.user) return session.user;
      }
      // Check localStorage for cached user
      try {
        const stored = localStorage.getItem('sb-ypeypgwsycxcagncgdur-auth-token');
        if (stored) {
          const parsed = JSON.parse(stored);
          if (parsed?.user) return parsed.user;
        }
      } catch (e) {}
      return null;
    }

    // Generate cryptographically secure share token
    function generateToken(length = 16) {
      const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZabcdefghjkmnpqrstuvwxyz23456789';
      let token = '';

      // Use Web Crypto API for secure random values
      if (window.crypto && window.crypto.getRandomValues) {
        const randomValues = new Uint32Array(length);
        crypto.getRandomValues(randomValues);
        for (let i = 0; i < length; i++) {
          token += chars.charAt(randomValues[i] % chars.length);
        }
      } else {
        // Fallback for very old browsers - combine multiple entropy sources
        const timestamp = Date.now().toString(36);
        const random = Math.random().toString(36).substring(2);
        const combined = timestamp + random + performance.now().toString(36);
        for (let i = 0; i < length; i++) {
          const index = (combined.charCodeAt(i % combined.length) * (i + 1)) % chars.length;
          token += chars.charAt(index);
        }
        console.warn('Using fallback token generation - crypto API not available');
      }
      return token;
    }

    // ===== AUTHENTICATION FUNCTIONS =====

    // Show login prompt modal
    function showLoginPrompt(message) {
      document.getElementById('loginPromptMessage').textContent = message || 'Sign in to continue.';
      document.getElementById('loginFormContainer').style.display = 'block';
      document.getElementById('loginSuccessContainer').style.display = 'none';
      document.getElementById('loginError').style.display = 'none';
      document.getElementById('loginEmail').value = '';
      document.getElementById('loginPassword').value = '';
      document.getElementById('loginModal').classList.add('active');
      document.getElementById('loginModal').removeAttribute('data-required');
      resetSignInButton();
    }

    // Show required login prompt (non-dismissible, for initial access)
    function showLoginPromptRequired() {
      document.getElementById('loginPromptMessage').innerHTML =
        'Sign in to access the Room Designer.<br><span style="font-size: 12px; opacity: 0.7;">Create professional kitchen & bath layouts with instant quotes.</span>';
      document.getElementById('loginFormContainer').style.display = 'block';
      document.getElementById('loginSuccessContainer').style.display = 'none';
      document.getElementById('loginError').style.display = 'none';
      document.getElementById('loginEmail').value = '';
      document.getElementById('loginPassword').value = '';
      const modal = document.getElementById('loginModal');
      modal.classList.add('active');
      modal.setAttribute('data-required', 'true');
      resetSignInButton();
    }

    // Continue as guest without signing in
    function continueAsGuest() {
      pendingAuthInit = false;
      const loginModal = document.getElementById('loginModal');
      loginModal.removeAttribute('data-required');
      loginModal.classList.remove('active');

      // Set guest mode indicator
      PRICING_ACCESS.accountType = 'guest';
      PRICING_ACCESS.canViewPricing = false;

      // Show guest mode toast after workspace loads
      setTimeout(() => {
        showToast('You\'re using Guest Mode. Sign in to save designs to the cloud.', 'info');
        // Add guest mode indicator to header
        showGuestModeIndicator();
      }, 1500);

      initializeWorkspace();
    }

    // Show guest mode indicator in header
    function showGuestModeIndicator() {
      const userMenu = document.getElementById('userAccountMenu');
      if (!userMenu) return;

      // Check if indicator already exists
      if (document.getElementById('guestModeIndicator')) return;

      const indicator = document.createElement('div');
      indicator.id = 'guestModeIndicator';
      indicator.style.cssText = `
        display: flex;
        align-items: center;
        gap: 6px;
        padding: 6px 12px;
        background: rgba(255, 193, 7, 0.15);
        border: 1px solid rgba(255, 193, 7, 0.3);
        border-radius: 6px;
        font-size: 12px;
        color: #ffc107;
        cursor: pointer;
        margin-right: 8px;
      `;
      indicator.innerHTML = `
        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <circle cx="12" cy="12" r="10"/>
          <line x1="12" y1="16" x2="12" y2="12"/>
          <line x1="12" y1="8" x2="12.01" y2="8"/>
        </svg>
        <span>Guest Mode</span>
      `;
      indicator.title = 'Click to sign in and save to cloud';
      indicator.onclick = () => showLoginPrompt('Sign in to save your designs to the cloud and access them from any device.');

      userMenu.parentNode.insertBefore(indicator, userMenu);
    }

    // Remove guest mode indicator (when user signs in)
    function removeGuestModeIndicator() {
      const indicator = document.getElementById('guestModeIndicator');
      if (indicator) indicator.remove();
    }

    // Handle Google OAuth login
    async function handleGoogleLogin() {
      const googleBtn = document.querySelector('.google-signin-btn');
      const originalContent = googleBtn?.innerHTML;

      try {
        // Show loading state
        if (googleBtn) {
          googleBtn.disabled = true;
          googleBtn.innerHTML = `
            <svg class="spinner" viewBox="0 0 24 24" width="20" height="20" style="animation: spin 1s linear infinite;">
              <circle cx="12" cy="12" r="10" stroke="currentColor" stroke-width="2" fill="none" stroke-dasharray="31.4" stroke-dashoffset="10"/>
            </svg>
            Connecting to Google...
          `;
        }

        const supabase = getSupabaseClient();
        if (!supabase) {
          throw new Error('Authentication not available');
        }

        const { data, error } = await supabase.auth.signInWithOAuth({
          provider: 'google',
          options: {
            redirectTo: window.location.origin + '/tools/room-designer/'
          }
        });

        if (error) {
          document.getElementById('loginError').textContent = error.message;
          document.getElementById('loginError').style.display = 'block';
          // Reset button
          if (googleBtn && originalContent) {
            googleBtn.disabled = false;
            googleBtn.innerHTML = originalContent;
          }
        }
        // Note: If successful, page will redirect, so no need to reset button
      } catch (err) {
        console.error('Google login error:', err);
        document.getElementById('loginError').textContent = 'Failed to connect with Google. Please try again.';
        document.getElementById('loginError').style.display = 'block';
        // Reset button on error
        if (googleBtn && originalContent) {
          googleBtn.disabled = false;
          googleBtn.innerHTML = originalContent;
        }
      }
    }

    // Handle login form submission
    async function handleLogin() {
      const email = document.getElementById('loginEmail').value.trim();
      const password = document.getElementById('loginPassword').value;
      const errorEl = document.getElementById('loginError');
      const btn = document.getElementById('signInBtn');

      if (!email || !password) {
        errorEl.textContent = 'Please enter email and password.';
        errorEl.style.display = 'block';
        return;
      }

      try {
        errorEl.style.display = 'none';

        // Show loading state
        if (btn) {
          btn.classList.add('loading');
          btn.disabled = true;
        }

        if (!window.SgAuth) {
          throw new Error('Auth system not loaded. Please refresh the page.');
        }

        const result = await window.SgAuth.signIn(email, password);

        // Show success
        document.getElementById('loginFormContainer').style.display = 'none';
        document.getElementById('loginSuccessContainer').style.display = 'block';
        document.getElementById('loginWelcome').textContent = `Welcome back, ${result.profile?.full_name || email}!`;

        // Update header UI
        updateAuthUI();

        // If this was a required login to access the tool, continue initialization
        if (pendingAuthInit) {
          pendingAuthInit = false;
          setTimeout(() => {
            closeModal('loginModal');
            initializeWorkspace();
          }, 1000);
        }

      } catch (err) {
        console.error('Login error:', err);
        errorEl.textContent = err.message || 'Login failed. Please try again.';
        errorEl.style.display = 'block';

        // Reset button
        if (btn) {
          btn.classList.remove('loading');
          btn.disabled = false;
        }
      }
    }

    // Reset sign in button state
    function resetSignInButton() {
      const btn = document.getElementById('signInBtn');
      if (btn) {
        btn.classList.remove('loading');
        btn.disabled = false;
      }
    }

    // Update header to show logged-in state
    function updateAuthUI() {
      // In demo mode, always show guest/sign-in state (hide actual user info)
      const user = DEMO_MODE ? null : window.SgAuth?.getUser();
      const profile = DEMO_MODE ? null : window.SgAuth?.getProfile();

      // Update new user menu
      const userAvatarSmall = document.getElementById('userAvatarSmall');
      const userNameDisplay = document.getElementById('userNameDisplay');
      const loggedOutMenu = document.getElementById('loggedOutMenu');
      const loggedInMenu = document.getElementById('loggedInMenu');

      if (user) {
        // Remove guest mode indicator when signed in
        removeGuestModeIndicator();

        const name = profile?.full_name?.split(' ')[0] || user.email.split('@')[0];
        const initial = name.charAt(0).toUpperCase();

        if (userAvatarSmall) userAvatarSmall.textContent = initial;
        if (userNameDisplay) userNameDisplay.textContent = name;
        if (loggedOutMenu) loggedOutMenu.style.display = 'none';
        if (loggedInMenu) loggedInMenu.style.display = 'block';
      } else {
        if (userAvatarSmall) userAvatarSmall.textContent = '?';
        if (userNameDisplay) userNameDisplay.textContent = 'Sign In';
        if (loggedOutMenu) loggedOutMenu.style.display = 'block';
        if (loggedInMenu) loggedInMenu.style.display = 'none';
      }

      // Legacy accountBtn support
      const accountBtn = document.getElementById('accountBtn');
      if (accountBtn) {
        if (user) {
          const name = profile?.full_name?.split(' ')[0] || user.email.split('@')[0];
          accountBtn.innerHTML = `
            <span style="width:28px;height:28px;background:var(--gold);border-radius:50%;display:flex;align-items:center;justify-content:center;font-weight:600;color:var(--dark);font-size:12px;">${name.charAt(0).toUpperCase()}</span>
            <span>${name}</span>
          `;
          accountBtn.onclick = () => window.location.href = '/account/';
        } else {
          accountBtn.innerHTML = `
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:20px;height:20px;">
              <path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"/>
              <circle cx="12" cy="7" r="4"/>
            </svg>
            <span>Sign In</span>
          `;
          accountBtn.onclick = () => showLoginPrompt();
        }
      }
    }

    // Toggle user dropdown menu
    function toggleUserMenu() {
      const dropdown = document.getElementById('userDropdown');
      if (dropdown) {
        dropdown.classList.toggle('show');
      }
    }

    // Close user menu
    function closeUserMenu() {
      const dropdown = document.getElementById('userDropdown');
      if (dropdown) {
        dropdown.classList.remove('show');
      }
    }

    // Handle Google Sign In
    async function handleGoogleSignIn() {
      closeUserMenu();
      try {
        // Use SgAuth if available
        if (window.SgAuth && window.SgAuth.signInWithGoogle) {
          await window.SgAuth.signInWithGoogle(window.location.href);
        } else {
          // Fallback to direct Supabase call
          const client = getSupabaseClient();
          if (client) {
            const { error } = await client.auth.signInWithOAuth({
              provider: 'google',
              options: {
                redirectTo: window.location.href
              }
            });
            if (error) throw error;
          }
        }
      } catch (err) {
        console.error('Google sign in error:', err);
        showToast('Error connecting to Google');
      }
    }

    // Handle logout
    async function handleLogout() {
      closeUserMenu();
      try {
        if (window.SgAuth) {
          await window.SgAuth.signOut();
        }
        updateAuthUI();
        showToast('Signed out successfully');
      } catch (err) {
        console.error('Logout error:', err);
        showToast('Error signing out');
      }
    }

    // Close user menu when clicking outside
    document.addEventListener('click', function(e) {
      const menu = document.getElementById('userAccountMenu');
      const dropdown = document.getElementById('userDropdown');
      if (menu && dropdown && !menu.contains(e.target)) {
        dropdown.classList.remove('show');
      }
    });

    // Initialize auth state on load
    function initAuth() {
      if (window.SgAuth) {
        window.SgAuth.onAuthChange(async (event, data) => {
          console.log('Auth state changed:', event);
          updateAuthUI();

          // Check pricing access on any auth change (force refresh to get latest from DB)
          await checkPricingAccess(true);

          // Re-render cabinet catalog after pricing access is checked
          setTimeout(() => {
            if (typeof renderCabinetCatalog === 'function') {
              renderCabinetCatalog();
            }
          }, 100);

          // When user signs in, clear cached designs so they reload from server
          if (event === 'SIGNED_IN' || event === 'TOKEN_REFRESHED') {
            allDesigns = { my: [], shared: [], recent: [] };
            // If My Designs modal is open, refresh it
            const modal = document.getElementById('myDesignsModal');
            if (modal && modal.classList.contains('active')) {
              loadMyDesigns();
            }
          }
        });
      }

      // Also listen to Supabase auth changes directly
      const supabase = getSupabaseClient();
      if (supabase) {
        supabase.auth.onAuthStateChange((event, session) => {
          console.log('Supabase auth state changed:', event);
          if (event === 'SIGNED_IN' || event === 'TOKEN_REFRESHED') {
            // Clear cached designs to force reload
            allDesigns = { my: [], shared: [], recent: [] };
          }
        });
      }

      // Initial update
      setTimeout(updateAuthUI, 500);
    }

    // ===== CONFIRMATION DIALOG =====
    // Modern confirmation dialog to replace browser confirm()
    function showConfirmDialog(options) {
      return new Promise((resolve) => {
        const {
          title = 'Confirm',
          message = 'Are you sure?',
          confirmText = 'Confirm',
          cancelText = 'Cancel',
          confirmClass = 'primary',
          dangerous = false
        } = options;

        // Remove existing dialog
        const existing = document.getElementById('confirmDialog');
        if (existing) existing.remove();

        const dialog = document.createElement('div');
        dialog.id = 'confirmDialog';
        dialog.className = 'modal-overlay';
        dialog.style.cssText = 'display: flex; align-items: center; justify-content: center; z-index: 100001;';
        dialog.innerHTML = `
          <div class="modal" style="max-width: 400px; padding: 24px;">
            <h3 style="margin: 0 0 12px; font-size: 16px; font-weight: 600;">${title}</h3>
            <p style="margin: 0 0 20px; color: var(--text-secondary); font-size: 14px; line-height: 1.5;">${message}</p>
            <div style="display: flex; gap: 12px; justify-content: flex-end;">
              <button class="btn btn-secondary" id="confirmDialogCancel">${cancelText}</button>
              <button class="btn ${dangerous ? 'btn-danger' : 'btn-' + confirmClass}" id="confirmDialogConfirm" style="${dangerous ? 'background: #ef4444;' : ''}">${confirmText}</button>
            </div>
          </div>
        `;

        document.body.appendChild(dialog);

        // Animate in
        requestAnimationFrame(() => dialog.classList.add('active'));

        // Handle buttons
        const confirmBtn = document.getElementById('confirmDialogConfirm');
        const cancelBtn = document.getElementById('confirmDialogCancel');

        const cleanup = (result) => {
          dialog.classList.remove('active');
          setTimeout(() => dialog.remove(), 200);
          resolve(result);
        };

        confirmBtn.onclick = () => cleanup(true);
        cancelBtn.onclick = () => cleanup(false);

        // Click outside to cancel
        dialog.onclick = (e) => {
          if (e.target === dialog) cleanup(false);
        };

        // Escape key to cancel
        const escHandler = (e) => {
          if (e.key === 'Escape') {
            document.removeEventListener('keydown', escHandler);
            cleanup(false);
          }
        };
        document.addEventListener('keydown', escHandler);

        // Focus confirm button
        confirmBtn.focus();
      });
    }

    // ===== TOAST NOTIFICATIONS =====
    function showToast(message, type = 'info', duration = 3000) {
      let container = document.getElementById('toastContainer');
      if (!container) {
        container = document.createElement('div');
        container.id = 'toastContainer';
        container.className = 'toast-container';
        document.body.appendChild(container);
      }

      // Define icons for each type
      const icons = {
        success: `<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="#34A853" stroke-width="2" style="flex-shrink: 0;">
          <path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/>
          <polyline points="22 4 12 14.01 9 11.01"/>
        </svg>`,
        error: `<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="#EA4335" stroke-width="2" style="flex-shrink: 0;">
          <circle cx="12" cy="12" r="10"/>
          <line x1="15" y1="9" x2="9" y2="15"/>
          <line x1="9" y1="9" x2="15" y2="15"/>
        </svg>`,
        warning: `<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="#FBBC05" stroke-width="2" style="flex-shrink: 0;">
          <path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"/>
          <line x1="12" y1="9" x2="12" y2="13"/>
          <line x1="12" y1="17" x2="12.01" y2="17"/>
        </svg>`,
        info: `<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="#4285F4" stroke-width="2" style="flex-shrink: 0;">
          <circle cx="12" cy="12" r="10"/>
          <line x1="12" y1="16" x2="12" y2="12"/>
          <line x1="12" y1="8" x2="12.01" y2="8"/>
        </svg>`
      };

      const toast = document.createElement('div');
      toast.className = `toast ${type}`;
      toast.style.display = 'flex';
      toast.style.alignItems = 'center';
      toast.style.gap = '10px';
      toast.innerHTML = `${icons[type] || icons.info}<span>${message}</span>`;
      container.appendChild(toast);

      // Update animation duration based on custom duration
      if (duration !== 3000) {
        toast.style.animation = `toastIn 0.3s ease, toastOut 0.3s ease ${(duration - 300) / 1000}s forwards`;
      }

      // Remove toast after animation
      setTimeout(() => {
        toast.remove();
      }, duration);
    }

    // Generate share link and save to Supabase
    async function generateShareLink() {
      console.log('=== generateShareLink START ===');

      // Demo mode check
      if (DEMO_MODE) {
        if (showDemoUpgradeModal('share')) return;
      }

      // Check if user is logged in
      const user = window.SgAuth?.getUser();
      if (!user) {
        showLoginPrompt('Please log in to save and share your designs.');
        return;
      }

      // Show loading indicator
      showLoading('Generating share link...');

      // Get user profile for company name
      let companyName = 'Surprise Granite Marble & Quartz'; // default
      try {
        const profile = await window.SgAuth?.getProfile();
        if (profile && profile.company_name) {
          companyName = profile.company_name;
        } else if (profile && profile.full_name) {
          companyName = profile.full_name;
        }
      } catch (e) {
        console.log('Could not fetch profile:', e);
      }

      const permissionBtn = document.querySelector('#shareModal .permission-btn.active');
      const permission = permissionBtn ? permissionBtn.dataset.permission : 'quote_view';
      console.log('Permission selected:', permission);

      const projectName = document.getElementById('projectName').value || 'Untitled Design';
      const roomType = document.getElementById('roomType').value;

      console.log('Project:', projectName, 'Room:', roomType);
      console.log('Elements count:', elements.length);
      console.log('User:', user.email);
      console.log('Company:', companyName);

      // Calculate quote total
      let quoteTotal = 0;
      elements.forEach(el => {
        const priceInfo = getElementPrice(el);
        const margin = getElementMargin(el) || 30;
        let cost = priceInfo?.price || 0;
        if (['countertop', 'backsplash', 'flooring', 'tile'].includes(el.type)) {
          cost = (el.width || 1) * (el.height || 1) * cost;
        }
        quoteTotal += cost * (1 + margin / 100);
      });

      // Save current room state before creating share data
      saveCurrentRoomState();

      const designData = {
        user_id: user.id,
        name: projectName,
        room_type: roomType,
        room_width: roomWidth,
        room_depth: roomDepth,
        elements: elements.map(el => serializeElement(el)),
        settings: {
          walls: walls.map(w => serializeWall(w)),
          pricing_config: {
            globalMargin: PRICING_STATE.globalMargin,
            categoryMargins: PRICING_STATE.categoryMargins,
            customPrices: PRICING_STATE.customPrices
          },
          company_name: companyName,
          current_room_id: currentRoomId,
          pixelsPerFoot: pixelsPerFoot,
          // Multi-room support (stored in settings to avoid column mismatch)
          rooms: rooms.map(room => ({
            ...room,
            elements: (room.elements || []).map(el =>
              el.xFt !== undefined ? { ...el, textureImg: null } : serializeElement(el)
            ),
            walls: (room.walls || []).map(w =>
              w.x1Ft !== undefined ? { ...w } : serializeWall(w)
            )
          })),
          share_mode: permission === 'full_collab' ? 'edit' : 'view',
          is_public: document.getElementById('shareToGallery')?.checked || false
        },
        quote_total: quoteTotal
      };

      try {
        // Use centralized config
        const { url: SUPABASE_URL, anonKey: SUPABASE_ANON_KEY } = getSupabaseConfig();

        // Get auth token if logged in
        const session = await window.SgAuth?.getSession?.();
        const authToken = session?.access_token || SUPABASE_ANON_KEY;

        const headers = {
          'apikey': SUPABASE_ANON_KEY,
          'Authorization': `Bearer ${authToken}`,
          'Accept': 'application/json',
          'Content-Type': 'application/json',
          'Prefer': 'return=representation'
        };

        let designId = SHARE_STATE.designId;
        let designToken = SHARE_STATE.designToken;
        console.log('Current state - designId:', designId, 'designToken:', designToken);

        // If designId is a local ID (starts with "local-"), we need to create a new one in Supabase
        const isLocalDesign = designId && String(designId).startsWith('local-');
        if (isLocalDesign) {
          console.log('Local design detected, will create new Supabase design');
          designId = null;
          designToken = null;
        }

        // Create or update design in database
        if (!designId) {
          designToken = generateToken(16);
          console.log('Creating new design with token:', designToken);

          const insertData = {
            share_token: designToken,
            ...designData
          };

          const response = await fetch(`${SUPABASE_URL}/rest/v1/room_designs`, {
            method: 'POST',
            headers,
            body: JSON.stringify(insertData)
          });

          if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`Insert failed: ${response.status} - ${errorText}`);
          }

          const data = await response.json();
          console.log('Insert result:', data);

          designId = Array.isArray(data) ? data[0]?.id : data.id;
          SHARE_STATE.designId = designId;
          SHARE_STATE.designToken = designToken;
          console.log('Design created with ID:', designId);
        } else {
          // Update existing design
          const updateData = {
            ...designData,
            updated_at: new Date().toISOString()
          };

          const response = await fetch(`${SUPABASE_URL}/rest/v1/room_designs?id=eq.${designId}`, {
            method: 'PATCH',
            headers,
            body: JSON.stringify(updateData)
          });

          if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`Update failed: ${response.status} - ${errorText}`);
          }
        }

        // Check if customer email provided to link to a lead
        // Use first invite recipient, or fall back to legacy input
        const customerEmail = (INVITE_STATE.recipients.length > 0 ? INVITE_STATE.recipients[0].email : null)
          || document.getElementById('shareCustomerEmail')?.value?.trim();
        let leadId = null;

        if (customerEmail) {
          try {
            // First try to find existing lead by email
            const leadResponse = await fetch(
              `${SUPABASE_URL}/rest/v1/leads?email=eq.${encodeURIComponent(customerEmail)}&select=id&order=created_at.desc&limit=1`,
              { headers }
            );
            const leads = await leadResponse.json();

            if (leads && leads.length > 0) {
              leadId = leads[0].id;
              console.log('Found existing lead:', leadId);
            } else {
              // Create a new lead for this customer
              const newLeadResponse = await fetch(`${SUPABASE_URL}/rest/v1/leads`, {
                method: 'POST',
                headers,
                body: JSON.stringify({
                  email: customerEmail,
                  full_name: customerEmail.split('@')[0],
                  source: 'Design Share',
                  project_type: roomType,
                  owner_id: user.id,
                  status: 'new',
                  message: `Design project: ${projectName}`
                })
              });
              const newLeads = await newLeadResponse.json();
              if (newLeads && newLeads.length > 0) {
                leadId = newLeads[0].id;
                console.log('Created new lead:', leadId);
              }
            }
          } catch (leadErr) {
            console.warn('Could not link to lead:', leadErr);
          }
        }

        // Create share record with specific permission
        // Use designToken for the share URL so the fallback lookup on room_designs always works
        const shareData = {
          design_id: designId,
          share_token: designToken,
          permission_level: permission
        };

        if (leadId) {
          shareData.lead_id = leadId;
        }

        // Non-fatal: room_design_shares table may not exist yet
        try {
          const shareResponse = await fetch(`${SUPABASE_URL}/rest/v1/room_design_shares`, {
            method: 'POST',
            headers,
            body: JSON.stringify(shareData)
          });

          if (!shareResponse.ok) {
            console.warn('room_design_shares insert failed (table may not exist):', shareResponse.status);
          }
        } catch (shareInsertErr) {
          console.warn('Could not create share record:', shareInsertErr);
        }

        // Display share URL  uses designToken which is always on room_designs.share_token
        const shareUrl = `${window.location.origin}${window.location.pathname}?share=${designToken}`;
        document.getElementById('shareLink').value = shareUrl;
        document.getElementById('copyShareBtn').disabled = false;
        document.getElementById('shareStatusText').textContent = 'Design shared!';

        // Show social sharing options
        const socialSection = document.getElementById('socialShareSection');
        if (socialSection) socialSection.style.display = 'block';

        loadActiveShares();
        hideLoading();
        showToast('Share link created successfully', 'success');
        return shareUrl;

      } catch (err) {
        console.error('Share error:', err);
        // Fallback to localStorage for local testing
        const token = generateToken(16);

        // Save design to localStorage
        const localDesign = {
          id: token,
          share_token: token,
          name: projectName,
          room_type: roomType,
          room_width: roomWidth,
          room_depth: roomDepth,
          elements: elements.map(el => ({ ...el, textureImg: null })),
          settings: {
            walls: walls,
            pricing_config: {
              globalMargin: PRICING_STATE.globalMargin,
              categoryMargins: PRICING_STATE.categoryMargins,
              customPrices: PRICING_STATE.customPrices
            },
            company_name: companyName
          },
          quote_total: quoteTotal,
          share_mode: permission === 'full_collab' ? 'edit' : 'view',
          permission_level: permission,
          created_at: new Date().toISOString()
        };

        // Store in localStorage
        const localShares = JSON.parse(localStorage.getItem('roomDesignerLocalShares') || '{}');
        localShares[token] = localDesign;
        localStorage.setItem('roomDesignerLocalShares', JSON.stringify(localShares));

        const shareUrl = `${window.location.origin}${window.location.pathname}?share=${token}`;
        document.getElementById('shareLink').value = shareUrl;
        document.getElementById('copyShareBtn').disabled = false;
        document.getElementById('shareStatusText').textContent = 'Link generated (local mode - for testing)';

        // Show social sharing options
        const socialSection = document.getElementById('socialShareSection');
        if (socialSection) socialSection.style.display = 'block';

        hideLoading();
        showToast('Share link created (local storage mode)', 'info');
        return shareUrl;
      }
    }

    // Helper function to load design data into the canvas
    function loadDesignData(design, permission, shareData = null) {
      console.log('=== loadDesignData START ===');
      console.log('Design:', design);
      console.log('Permission:', permission);

      try {
        // Update preloader with company name
        let companyName = 'Surprise Granite Marble & Quartz';
        if (design.settings && design.settings.company_name) {
          companyName = design.settings.company_name;
        } else if (design.created_by) {
          companyName = design.created_by;
        } else if (design.company_name) {
          companyName = design.company_name;
        }
        const companyEl = document.getElementById('preloaderCompanyMain');
        if (companyEl) {
          companyEl.textContent = companyName;
        }

        // Set share state - mark as shared view if:
        // 1. URL has a share token parameter, OR
        // 2. Permission was explicitly provided
        // When designer loads their own design directly (no share param), it's not a shared view
        const urlHasShareToken = new URLSearchParams(window.location.search).has('share');
        const isActuallySharedView = urlHasShareToken || (permission !== undefined && permission !== null);
        SHARE_STATE.isSharedView = isActuallySharedView;
        // Default to 'quote_view' for shared views without explicit permission (safer)
        SHARE_STATE.permission = permission || (isActuallySharedView ? 'quote_view' : 'full_collab');
        SHARE_STATE.allowedActions = PERMISSION_LEVELS[permission] || PERMISSION_LEVELS.full_collab;
        SHARE_STATE.designId = design.id;
        SHARE_STATE.designToken = design.share_token;
        currentDesignId = design.id; // Set for unified messages system

        if (shareData) {
          SHARE_STATE.shareId = shareData.id;
          SHARE_STATE.shareToken = shareData.share_token;
          SHARE_STATE.leadId = shareData.lead_id;
          SHARE_STATE.customerName = shareData.customer_name || null;
          SHARE_STATE.comments = shareData.comments || [];

          // Load comments from customer_messages if lead_id exists
          if (shareData.lead_id) {
            loadCommentsFromMessages(shareData.lead_id, shareData.id);

            // Subscribe to realtime comment notifications (for designers only)
            if (!SHARE_STATE.isSharedView) {
              subscribeToCustomerComments(shareData.lead_id);

              // Fetch customer name if not already set
              if (!SHARE_STATE.customerName) {
                fetchCustomerName(shareData.lead_id);
              }
            }
          }
        }

        // Load design data into form fields (name field, with project_name fallback for legacy)
        document.getElementById('projectName').value = design.name || design.project_name || 'Untitled Design';
        document.getElementById('roomType').value = design.room_type || 'kitchen';
        roomWidth = parseFloat(design.room_width) || 12;
        roomDepth = parseFloat(design.room_depth) || 10;
        document.getElementById('roomWidth').value = roomWidth;
        document.getElementById('roomDepth').value = roomDepth;

        // Validate design has actual content before overwriting
        const designElements = design.elements || [];
        const designWalls = design.settings?.walls || design.walls || [];
        if (designElements.length === 0 && elements.length > 0) {
          console.warn('loadDesignData: design has no elements but current canvas has', elements.length, ' preserving current state');
          // Still load share state above, but don't clear canvas
          return;
        }

        // Load elements and walls
        elements = designElements;
        walls = designWalls;

        // Load multi-room data if available (check both top-level and settings)
        const designRooms = (design.rooms && design.rooms.length > 0) ? design.rooms
          : (design.settings?.rooms && design.settings.rooms.length > 0) ? design.settings.rooms
          : null;

        if (designRooms && designRooms.length > 0) {
          rooms = designRooms.map(room => ({
            ...room,
            elements: (room.elements || []).map(el => ({ ...el, roomId: room.id })),
            walls: room.walls || []
          }));
          currentRoomId = design.settings?.current_room_id || design.current_room_id || rooms[0].id;
          // Also sync the other room tracking variable
          currentRoom = currentRoomId;

          // Load current room data
          const activeRoom = getCurrentRoom();
          if (activeRoom) {
            elements = activeRoom.elements || [];
            walls = activeRoom.walls || [];
            roomWidth = activeRoom.width || roomWidth;
            roomDepth = activeRoom.depth || roomDepth;
          }

          console.log('Loaded multi-room layout with', rooms.length, 'rooms, currentRoomId:', currentRoomId);
          updateRoomList();
        } else {
          // Single room - initialize rooms array
          initializeRooms();
          currentRoom = currentRoomId || 'default';
          const firstRoom = getCurrentRoom();
          if (firstRoom) {
            firstRoom.elements = elements;
            firstRoom.walls = walls;
            firstRoom.width = roomWidth;
            firstRoom.depth = roomDepth;
          }
          updateRoomList();
        }

        console.log('Loaded elements:', elements.length);
        console.log('Loaded walls:', walls.length);

        // Normalize element positions if saved scale differs from current
        // This ensures 3D rendering is accurate regardless of viewport size
        const savedScale = design.settings?.pixelsPerFoot || 40;
        fitToScreen(); // Calculate current pixelsPerFoot based on viewport

        console.log('Saved scale:', savedScale, 'Current scale:', pixelsPerFoot);

        // Deserialize positions from feet-based format (or legacy pixel-based with scale conversion)
        elements = elements.map(el => deserializeElement({ ...el }, savedScale));
        walls = walls.map(w => deserializeWall({ ...w }, savedScale));

        // Deserialize room element and wall positions
        rooms.forEach(room => {
          if (room.elements) {
            room.elements = room.elements.map(el => deserializeElement({ ...el }, savedScale));
          }
          if (room.walls) {
            room.walls = room.walls.map(w => deserializeWall({ ...w }, savedScale));
          }
          room.pixelsPerFoot = pixelsPerFoot;
        });

        // Ensure elements have required properties
        elements = elements.map(el => ({
          ...el,
          textureImg: null,
          status: el.status || 'pending'
        }));

        // Load pricing config
        if (design.pricing_config) {
          PRICING_STATE.globalMargin = design.pricing_config.globalMargin || 30;
          PRICING_STATE.categoryMargins = design.pricing_config.categoryMargins || {};
          PRICING_STATE.customPrices = design.pricing_config.customPrices || {};
        }

        // Reload textures for elements
        elements.forEach(el => {
          if (el.materialId) {
            loadElementTexture(el);
          }
        });

        selectedElement = null;
        updateProperties();
        calculateQuote();
        draw();

        // Show Review Room UI ONLY for shared views with non-full-collab permission
        // (Designer loading their own design should NOT see review room)
        console.log('=== SHARE VIEW CHECK ===');
        console.log('SHARE_STATE.isSharedView:', SHARE_STATE.isSharedView);
        console.log('Permission:', permission);
        console.log('isFullCollaborator():', isFullCollaborator());
        console.log('SHARE_STATE.allowedActions:', SHARE_STATE.allowedActions);

        if (SHARE_STATE.isSharedView && !isFullCollaborator()) {
          console.log('-> Showing Review Room (shared view, not full collab)');
          showReviewRoom(design.project_name || design.name || 'Design Review', permission);
        } else {
          console.log('-> NOT showing Review Room');
          // Either designer's own design OR full collaborator - no review overlay
          document.body.classList.remove('review-readonly', 'view-only-mode');
          if (isFullCollaborator()) {
            showCollaboratorBadge();
          }
        }

        // Wait for textures to load, then initialize 3D view
        setTimeout(() => {
          console.log('Initializing 3D view with', elements.length, 'elements');
          console.log('Room dimensions:', roomWidth, 'x', roomDepth, ', currentRoomId:', currentRoomId, ', currentRoom:', currentRoom);
          console.log('Elements sample:', elements.slice(0, 3).map(e => ({ type: e.type, roomId: e.roomId, x: e.x, y: e.y })));

          // Switch to 3D view first
          setView('3d');
          // Force re-init 3D scene after a short delay
          setTimeout(() => {
            console.log('Forcing 3D re-init...');
            init3D();
            render3D();
            console.log('3D scene initialized, scene children:', scene?.children?.length || 0);
            // Hide preloader after 3D is ready
            hidePreloader();
            console.log('=== loadDesignData COMPLETE ===');
            // Log view activity
            logActivity('view');

            // Subscribe to realtime updates for live sync
            // Customers will see designer changes instantly
            if (SHARE_STATE.isSharedView && SHARE_STATE.designId) {
              subscribeToDesignUpdates(SHARE_STATE.designId);
              console.log('Realtime subscription initiated for design:', SHARE_STATE.designId);
            }

            // Initialize team chat for collaboration
            if (SHARE_STATE.designId && typeof initTeamChat === 'function') {
              initTeamChat(SHARE_STATE.designId);
            }

            // Initialize unified messages panel
            if (typeof initUnifiedMessages === 'function') {
              initUnifiedMessages();
            }
          }, 300);
        }, 800);

      } catch (err) {
        console.error('loadDesignData error:', err);
        showToast('Error loading design: ' + err.message, 'error');
        hidePreloader();
      }
    }

    // Load shared design from token
    async function loadSharedDesign(shareToken) {
      console.log('=== loadSharedDesign START ===');
      console.log('Token:', shareToken);

      // PROTECT user's own auto-saved design before loading shared content
      // Save to a protected key that auto-save will NEVER overwrite
      try {
        const ownSave = localStorage.getItem(AUTOSAVE_KEY);
        if (ownSave) {
          const ownData = JSON.parse(ownSave);
          if (ownData.elements && ownData.elements.length > 0) {
            localStorage.setItem(AUTOSAVE_KEY + '_protected', ownSave);
            console.log('Protected user design before shared load:', ownData.elements.length, 'elements');
          }
        }
      } catch (e) { /* ignore  protection is best-effort */ }

      // Show cloud preloader with Remodely AI branding
      showPreloader('Initializing 3D workspace');

      try {
        const supabase = getSupabaseClient();
        console.log('Supabase client:', supabase ? 'available' : 'NOT AVAILABLE');

        if (!supabase) {
          console.warn('Supabase not available for loading shared design, trying localStorage...');

          // Try localStorage fallback
          const localShares = JSON.parse(localStorage.getItem('roomDesignerLocalShares') || '{}');
          const localDesign = localShares[shareToken];

          if (localDesign) {
            console.log('Found design in localStorage:', localDesign.name);
            loadDesignData(localDesign, localDesign.permission_level || 'full_collab');
            showToast('Design loaded from local storage (offline mode)', 'info');
            return;
          }

          hidePreloader();
          showShareLinkError('Cannot load shared design - database connection unavailable. Please try again later.');
          return;
        }

        // Use centralized config
        const { url: SUPABASE_URL, anonKey: SUPABASE_ANON_KEY } = getSupabaseConfig();
        const headers = {
          'apikey': SUPABASE_ANON_KEY,
          'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
          'Accept': 'application/json',
          'Content-Type': 'application/json'
        };

        // First try to get the share record by share_token
        console.log('Querying room_design_shares for token:', shareToken);
        let shareData = null;
        let shareError = null;

        try {
          const shareRes = await fetch(
            `${SUPABASE_URL}/rest/v1/room_design_shares?share_token=eq.${shareToken}&select=*`,
            { headers }
          );
          if (shareRes.ok) {
            const shareResults = await shareRes.json();
            shareData = Array.isArray(shareResults) && shareResults.length > 0 ? shareResults[0] : null;
          } else {
            console.warn('room_design_shares query returned', shareRes.status, '(table may not exist)');
          }
          console.log('Share query result:', shareData);
        } catch (e) {
          shareError = e;
          console.error('Share query error:', e);
        }

        // If not found by share_token, try to find by design token directly
        if (!shareData) {
          console.log('Not found in shares, trying room_designs directly...');

          try {
            const designRes = await fetch(
              `${SUPABASE_URL}/rest/v1/room_designs?share_token=eq.${shareToken}&select=*`,
              { headers }
            );
            if (designRes.ok) {
              const designResults = await designRes.json();
              const directDesign = Array.isArray(designResults) && designResults.length > 0 ? designResults[0] : null;

              console.log('Direct design query result:', directDesign);

              if (directDesign) {
                // Found as a direct design link - need to find or create a share record for comments to work
                console.log('Direct design found, looking for existing share record...');

                // Try to find an existing share record for this design
                let existingShareData = null;
                try {
                  const existingShareRes = await fetch(
                    `${SUPABASE_URL}/rest/v1/room_design_shares?design_id=eq.${directDesign.id}&select=*&order=created_at.desc&limit=1`,
                    { headers }
                  );
                  if (existingShareRes.ok) {
                    const existingShares = await existingShareRes.json();
                    if (existingShares && existingShares.length > 0) {
                      existingShareData = existingShares[0];
                      console.log('Found existing share record:', existingShareData.id);
                    }
                  }
                } catch (e) {
                  console.warn('Could not check for existing share:', e);
                }

                // If no share record exists, create one so comments can be saved
                if (!existingShareData) {
                  console.log('No share record found, creating one for comment support...');
                  try {
                    const newShareRes = await fetch(
                      `${SUPABASE_URL}/rest/v1/room_design_shares`,
                      {
                        method: 'POST',
                        headers: { ...headers, 'Prefer': 'return=representation' },
                        body: JSON.stringify({
                          design_id: directDesign.id,
                          share_token: shareToken,
                          permission_level: directDesign.settings?.share_mode === 'edit' ? 'full_collab' : 'quote_view',
                          comments: [],
                          access_count: 1,
                          created_at: new Date().toISOString()
                        })
                      }
                    );
                    if (newShareRes.ok) {
                      const newShares = await newShareRes.json();
                      existingShareData = Array.isArray(newShares) ? newShares[0] : newShares;
                      console.log('Created new share record:', existingShareData?.id);
                    } else {
                      console.warn('Could not create share record:', newShareRes.status);
                    }
                  } catch (e) {
                    console.warn('Error creating share record:', e);
                  }
                }

                // Load design with share data (even if null, at least we tried)
                const permission = directDesign.settings?.share_mode === 'edit' ? 'full_collab' : 'quote_view';
                loadDesignData(directDesign, permission, existingShareData);
                return;
              }
            } else {
              console.error('Design query failed:', designRes.status);
            }
          } catch (e) {
            console.error('Design query error:', e);
          }

          // Try localStorage fallback for local testing
          console.log('Trying localStorage fallback...');
          const localShares = JSON.parse(localStorage.getItem('roomDesignerLocalShares') || '{}');
          const localDesign = localShares[shareToken];

          if (localDesign) {
            console.log('Found design in localStorage:', localDesign.name);
            loadDesignData(localDesign, localDesign.permission_level || 'full_collab');
            showToast('Design loaded from local storage', 'info');
            return;
          }

          console.error('Share error:', shareError);
          hidePreloader();
          showShareLinkError('Share link not found or expired. Please ask the designer for a new link.');
          return;
        }

        // Then get the associated design using direct fetch
        console.log('Loading design with id:', shareData.design_id);
        let design = null;
        try {
          const designRes = await fetch(
            `${SUPABASE_URL}/rest/v1/room_designs?id=eq.${shareData.design_id}&select=*`,
            { headers }
          );
          const designResults = await designRes.json();
          design = designResults.length > 0 ? designResults[0] : null;
        } catch (e) {
          console.error('Design fetch error:', e);
        }

        if (!design) {
          console.error('Design not found for id:', shareData.design_id);
          hidePreloader();
          showShareLinkError('Design not found or has been deleted.');
          return;
        }

        // Update access count (fire and forget, don't block on this)
        fetch(`${SUPABASE_URL}/rest/v1/room_design_shares?id=eq.${shareData.id}`, {
          method: 'PATCH',
          headers,
          body: JSON.stringify({
            access_count: (shareData.access_count || 0) + 1,
            last_accessed_at: new Date().toISOString()
          })
        }).catch(e => console.warn('Could not update access count:', e));

        const permission = shareData.permission_level;

        // Use the helper function to load the design
        loadDesignData(design, permission, shareData);

      } catch (err) {
        console.error('Load shared design error:', err);
        hidePreloader();
        showShareLinkError('Error loading shared design: ' + err.message);
      }
    }

    // Show error overlay when share link fails to load
    function showShareLinkError(message) {
      // Hide the main canvas area and show error instead
      const mainArea = document.querySelector('.main');
      if (mainArea) {
        mainArea.innerHTML = `
          <div class="share-error-overlay" style="
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: var(--bg);
            z-index: 1000;
            text-align: center;
            padding: 40px;
          ">
            <svg viewBox="0 0 24 24" fill="none" stroke="var(--text-muted)" stroke-width="1.5" style="width: 80px; height: 80px; margin-bottom: 24px; opacity: 0.5;">
              <circle cx="12" cy="12" r="10"/>
              <path d="M15 9l-6 6M9 9l6 6"/>
            </svg>
            <h2 style="color: var(--text); margin: 0 0 16px 0; font-size: 24px;">Link Unavailable</h2>
            <p style="color: var(--text-muted); margin: 0 0 32px 0; max-width: 400px; line-height: 1.6;">
              ${message}
            </p>
            <div style="display: flex; gap: 12px;">
              <a href="/tools/room-designer/" class="btn btn-primary" style="text-decoration: none;">
                Start New Design
              </a>
              <a href="/" class="btn btn-secondary" style="text-decoration: none;">
                Go to Homepage
              </a>
            </div>
          </div>
        `;
      }
    }

    // Show the Review Room overlay UI
    function showReviewRoom(projectName, permission) {
      // Ensure permission has a valid value
      const safePermission = permission || 'view_only';
      const permInfo = PERMISSION_LEVELS[safePermission];
      const permissionLabel = permInfo?.name || 'View Only';

      // Clean up editing UI elements that shouldn't be visible in review mode
      const mobileToolbar = document.getElementById('mobileToolbar');
      if (mobileToolbar) mobileToolbar.remove();

      // Add view-only classes to hide editing UI
      document.body.classList.add('view-only-mode');
      document.body.classList.add('review-readonly');

      // FORCE hide the left sidebar and all tool elements
      const leftSidebar = document.getElementById('leftSidebar');
      if (leftSidebar) leftSidebar.style.display = 'none';

      const toolsSection = document.getElementById('toolsSection');
      if (toolsSection) toolsSection.style.display = 'none';

      document.querySelectorAll('.tool-btn, .tool-grid').forEach(el => {
        el.style.display = 'none';
      });

      // Create review room overlay
      const reviewRoom = document.createElement('div');
      reviewRoom.id = 'reviewRoom';
      reviewRoom.className = 'review-room';
      reviewRoom.innerHTML = `
        <div class="review-header">
          <div class="review-header-left">
            <a href="/" class="review-back-btn" title="Back to Home">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:20px;height:20px;">
                <path stroke-linecap="round" stroke-linejoin="round" d="M10 19l-7-7m0 0l7-7m-7 7h18"/>
              </svg>
            </a>
            <h2 class="review-title">${projectName || 'Design Review'}</h2>
            <span class="review-permission-badge">${permissionLabel}</span>
            <div id="liveIndicator" class="live-indicator disconnected" title="Connecting to live updates...">
              <span class="live-dot"></span>
              <span>LIVE</span>
            </div>
          </div>
          <div class="review-header-right">
            <button class="btn btn-secondary" onclick="toggleReviewPanel()">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:16px;height:16px;">
                <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"/>
              </svg>
              <span class="btn-text">Review</span>
            </button>
            <button class="btn btn-secondary" id="toggle3DBtn" onclick="toggle3DView()">
              <span class="btn-text">2D View</span>
            </button>
            ${permission === 'full_collab' ? `
            <button class="btn btn-secondary" onclick="exitReviewMode()" title="Exit to Editor">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:16px;height:16px;">
                <path d="M11 19l-7-7 7-7m8 14l-7-7 7-7"/>
              </svg>
              <span class="btn-text">Edit</span>
            </button>
            ` : ''}
          </div>
        </div>

        <div class="review-panel" id="reviewPanel">
          <div class="review-panel-header">
            <h3>Design Elements</h3>
            <button class="review-panel-close" onclick="toggleReviewPanel()"></button>
          </div>

          <div class="review-summary">
            <div class="review-stat">
              <span class="stat-value" id="reviewTotal">$0</span>
              <span class="stat-label">Total Quote</span>
            </div>
            <div class="review-stat">
              <span class="stat-value" id="reviewItemCount">0</span>
              <span class="stat-label">Items</span>
            </div>
            <div class="review-stat">
              <span class="stat-value approved" id="reviewApproved">0</span>
              <span class="stat-label">Approved</span>
            </div>
          </div>

          <div class="review-elements" id="reviewElements">
            <!-- Populated by JS -->
          </div>

          <div class="review-chat-section">
            <div class="review-chat-header">
              <span> Chat with Designer</span>
              <span class="chat-status" id="chatConnectionStatus"> Live</span>
            </div>
            <div class="review-chat-messages" id="reviewComments">
              <!-- Populated by JS -->
            </div>
            <form class="review-chat-input" onsubmit="addReviewComment(); return false;" autocomplete="off">
              <input type="search" id="newCommentInput" placeholder="Type a message..." autocomplete="off">
              <button type="submit" class="chat-send-btn">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" width="18" height="18">
                  <path stroke-linecap="round" stroke-linejoin="round" d="M6 12L3 21l18-9L3 3l3 9m0 0h12"/>
                </svg>
              </button>
            </form>
          </div>

          ${permission === 'quote_approval' ? `
          <div class="review-actions quote-approval-actions">
            <div class="approval-summary">
              <p class="approval-note">Review the design above. When ready, approve and pay to confirm your order.</p>
            </div>
            <button class="btn btn-success btn-lg approve-pay-btn" onclick="approveAndPay()">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:20px;height:20px;margin-right:8px;">
                <path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/>
                <polyline points="22 4 12 14.01 9 11.01"/>
              </svg>
              Approve & Pay Deposit
            </button>
            <p class="approval-terms">By clicking above, you approve this design and authorize a 50% deposit charge.</p>
          </div>
          ` : permission === 'full_collab' || permission === 'quote_view' ? `
          <div class="review-actions">
            <button class="btn btn-success" onclick="approveAllElements()">Approve All</button>
            <button class="btn btn-primary" onclick="submitReview()">Submit Review</button>
          </div>
          ` : ''}
        </div>
      `;

      document.body.appendChild(reviewRoom);

      // Apply permission-based UI adjustments
      applyPermissionRestrictions();

      // Populate review elements list
      console.log('Populating review with elements:', elements.length);
      updateReviewElements();
      updateReviewComments();
      updateReviewStats();

      // Auto-open the review panel for quote_view, full_collab, and quote_approval
      if (permission === 'quote_view' || permission === 'full_collab' || permission === 'quote_approval') {
        const panel = document.getElementById('reviewPanel');
        if (panel) {
          panel.classList.add('open');
          console.log('Auto-opened review panel for permission:', permission);
        }
      }

      // Subscribe to real-time comment updates (so customer sees designer replies)
      subscribeToShareCommentsForCustomer();

      // Force canvas redraw after layout change (multiple attempts for layout settling)
      const redrawCanvas = () => {
        const wrapper = document.getElementById('canvasWrapper');
        if (wrapper && wrapper.clientWidth > 0 && wrapper.clientHeight > 0) {
          updateCanvasSize();
          console.log('Canvas redrawn after review room shown:', wrapper.clientWidth, 'x', wrapper.clientHeight);
        } else {
          console.log('Canvas wrapper not ready yet, will retry...');
        }
      };
      setTimeout(redrawCanvas, 100);
      setTimeout(redrawCanvas, 300);
      setTimeout(redrawCanvas, 600);
    }

    // Subscribe to share comment updates for customer view
    function subscribeToShareCommentsForCustomer() {
      const supabase = getSupabaseClient();
      if (!supabase || !SHARE_STATE.shareId) {
        console.log('Cannot subscribe to comments - no shareId');
        return;
      }

      console.log('Customer subscribing to comment updates for share:', SHARE_STATE.shareId);

      const channel = supabase
        .channel('customer-share-comments-' + SHARE_STATE.shareId)
        .on('postgres_changes', {
          event: 'UPDATE',
          schema: 'public',
          table: 'room_design_shares',
          filter: `id=eq.${SHARE_STATE.shareId}`
        }, (payload) => {
          console.log('=== CUSTOMER: Received share update ===', payload);

          // Update local comments and refresh UI
          if (payload.new.comments) {
            SHARE_STATE.comments = payload.new.comments;
            updateReviewComments();

            // Show toast for new designer messages
            const newComments = payload.new.comments;
            const lastComment = newComments[newComments.length - 1];
            if (lastComment && lastComment.direction === 'outbound') {
              showToast(` ${lastComment.author || 'Designer'}: ${lastComment.text.substring(0, 40)}...`, 'info');
            }
          }
        })
        .subscribe((status) => {
          console.log('Customer comment subscription status:', status);
          // Update connection status in chat header
          const statusEl = document.getElementById('chatConnectionStatus');
          if (statusEl) {
            if (status === 'SUBSCRIBED') {
              statusEl.textContent = ' Live';
              statusEl.classList.remove('disconnected');
            } else {
              statusEl.textContent = ' Connecting...';
              statusEl.classList.add('disconnected');
            }
          }
          // Also update the live indicator in review header
          const indicator = document.getElementById('liveIndicator');
          if (indicator) {
            if (status === 'SUBSCRIBED') {
              indicator.classList.remove('disconnected');
              indicator.classList.add('connected');
            } else {
              indicator.classList.remove('connected');
              indicator.classList.add('disconnected');
            }
          }
        });
    }

    // Toggle review panel visibility
    function toggleReviewPanel() {
      const panel = document.getElementById('reviewPanel');
      if (panel) {
        panel.classList.toggle('open');
      }
    }

    // Exit review mode and return to normal editor
    function exitReviewMode() {
      const reviewRoom = document.getElementById('reviewRoom');
      if (reviewRoom) {
        reviewRoom.remove();
      }

      // Reset share state  but preserve for full_collab so sync keeps working
      if (!isFullCollaborator()) {
        SHARE_STATE.isSharedView = false;
        SHARE_STATE.permission = 'full_collab';
        SHARE_STATE.allowedActions = PERMISSION_LEVELS.full_collab;
      }

      // Switch back to 2D view
      setView('2d');

      // Re-enable all UI elements
      document.querySelectorAll('[data-permission-hidden]').forEach(el => {
        el.style.display = '';
        el.removeAttribute('data-permission-hidden');
      });

      draw();
    }

    // Update review elements list
    function updateReviewElements() {
      console.log('updateReviewElements called');
      const container = document.getElementById('reviewElements');
      if (!container) {
        console.log('Review elements container not found');
        return;
      }

      const canApprove = PERMISSION_LEVELS[SHARE_STATE.permission]?.canApprove || false;
      const canViewPrices = checkPermission('canViewPrices');
      console.log('canApprove:', canApprove, 'canViewPrices:', canViewPrices);

      if (elements.length === 0) {
        container.innerHTML = '<p class="empty-state">No elements in this design</p>';
        return;
      }

      container.innerHTML = elements.map((el, index) => {
        const priceInfo = getElementPrice(el);
        const margin = getElementMargin(el) || 30;
        let cost = priceInfo?.price || 0;
        if (['countertop', 'backsplash', 'flooring', 'tile'].includes(el.type)) {
          cost = (el.width || 1) * (el.height || 1) * cost;
        }
        const retail = cost * (1 + margin / 100);
        const status = el.status || 'pending';
        const statusIcon = status === 'approved' ? '' : status === 'rejected' ? '' : '';
        const statusClass = status;

        return `
          <div class="review-element ${statusClass}" data-index="${index}" onclick="selectReviewElement(${index})">
            <div class="review-element-header">
              <span class="review-element-status ${statusClass}">${statusIcon}</span>
              <span class="review-element-name">${el.label}</span>
              ${canViewPrices ? `<span class="review-element-price">$${(retail || 0).toFixed(2)}</span>` : ''}
            </div>
            <div class="review-element-details">
              <span>${formatDimension(el.width)}  ${formatDimension(el.height)}</span>
              ${el.material ? `<span class="review-element-material">${el.material}</span>` : ''}
            </div>
            ${canApprove ? `
            <div class="review-element-actions">
              <button class="btn-approve" onclick="event.stopPropagation(); setElementStatus(${index}, 'approved')" title="Approve"></button>
              <button class="btn-reject" onclick="event.stopPropagation(); setElementStatus(${index}, 'rejected')" title="Reject"></button>
              <button class="btn-comment" onclick="event.stopPropagation(); commentOnElement(${index})" title="Comment"></button>
            </div>
            ` : ''}
          </div>
        `;
      }).join('');
    }

    // Select an element from the review panel
    function selectReviewElement(index) {
      if (elements[index]) {
        selectedElement = elements[index];
        updateProperties();
        draw();

        // Highlight in 3D if available
        if (is3DMode) {
          // Could add 3D highlighting here
        }
      }
    }

    // Set element approval status
    async function setElementStatus(index, status) {
      if (elements[index]) {
        elements[index].status = status;
        updateReviewElements();
        updateReviewStats();
        draw();

        // Log activity
        const activityType = status === 'approved' ? 'approve' : 'reject';
        logActivity(activityType, index, elements[index].label);

        // Save status to database
        await saveReviewState();
      }
    }

    // Approve all elements
    async function approveAllElements() {
      elements.forEach(el => el.status = 'approved');
      updateReviewElements();
      updateReviewStats();
      draw();
      await saveReviewState();
    }

    // Comment on specific element
    function commentOnElement(index) {
      const comment = prompt(`Add comment for "${elements[index]?.label}":`);
      if (comment && comment.trim()) {
        const newComment = {
          elementIndex: index,
          elementLabel: elements[index]?.label,
          text: comment.trim(),
          timestamp: new Date().toISOString(),
          author: 'Reviewer'
        };
        SHARE_STATE.comments = SHARE_STATE.comments || [];
        SHARE_STATE.comments.push(newComment);
        updateReviewComments();
        saveReviewState();
      }
    }

    // Add general review comment
    async function addReviewComment() {
      const input = document.getElementById('newCommentInput');
      const text = input?.value?.trim();
      if (!text) return;

      const newComment = {
        text: text,
        timestamp: new Date().toISOString(),
        author: 'Customer',
        direction: 'inbound'
      };

      SHARE_STATE.comments = SHARE_STATE.comments || [];
      SHARE_STATE.comments.push(newComment);
      input.value = '';
      updateReviewComments();

      // Log comment activity
      logActivity('comment', null, null, text);

      // Save to customer_messages for unified communication
      if (SHARE_STATE.leadId) {
        try {
          // Direct Supabase insert for reliability
          const supabase = getSupabaseClient();
          if (supabase) {
            const { data, error } = await supabase
              .from('customer_messages')
              .insert({
                customer_id: SHARE_STATE.leadId,
                message: text,
                direction: 'inbound',
                channel: 'design_share',
                metadata: {
                  share_id: SHARE_STATE.shareId,
                  design_id: SHARE_STATE.designId,
                  author: 'Customer'
                }
              })
              .select()
              .single();

            if (error) {
              console.warn('Supabase insert error:', error);
            } else {
              console.log('Comment saved to customer_messages:', data);
            }
          }
        } catch (err) {
          console.warn('Could not save comment to messages:', err);
        }
      }

      await saveReviewState();
    }

    // Load comments from customer_messages table
    async function loadCommentsFromMessages(leadId, shareId) {
      try {
        const supabase = getSupabaseClient();
        if (!supabase) return;

        const { data: messages, error } = await supabase
          .from('customer_messages')
          .select('*')
          .eq('customer_id', leadId)
          .eq('channel', 'design_share')
          .order('created_at', { ascending: true });

        if (error) {
          console.warn('Could not load messages:', error);
          return;
        }

        if (messages && messages.length > 0) {
          // Convert messages to comment format and merge with existing
          const messageComments = messages
            .filter(m => !m.metadata?.share_id || m.metadata?.share_id === shareId)
            .map(m => ({
              text: m.message,
              timestamp: m.created_at,
              author: m.direction === 'outbound' ? (m.metadata?.author || 'Surprise Granite') : 'Customer',
              direction: m.direction,
              messageId: m.id
            }));

          // Merge with any existing JSONB comments, avoiding duplicates
          const existingTexts = new Set(SHARE_STATE.comments.map(c => c.text + c.timestamp));
          const newComments = messageComments.filter(c => !existingTexts.has(c.text + c.timestamp));

          SHARE_STATE.comments = [...SHARE_STATE.comments, ...newComments]
            .sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

          updateReviewComments();
        }
      } catch (err) {
        console.warn('Error loading comments from messages:', err);
      }
    }

    // Update comments display
    function updateReviewComments() {
      const container = document.getElementById('reviewComments');
      if (!container) return;

      const comments = SHARE_STATE.comments || [];

      if (comments.length === 0) {
        container.innerHTML = `
          <div class="chat-empty">
            <div class="chat-empty-icon"></div>
            <div>No messages yet</div>
            <div style="font-size: 11px; margin-top: 4px;">Send a message to start the conversation</div>
          </div>
        `;
        return;
      }

      container.innerHTML = comments.map(c => {
        // Designer messages are 'outbound', customer messages are 'inbound'
        const isDesigner = c.direction === 'outbound';
        const direction = isDesigner ? 'inbound' : 'outbound'; // Flip for customer view
        const authorName = c.author || (isDesigner ? 'Designer' : 'You');
        const initial = authorName[0].toUpperCase();
        const time = new Date(c.timestamp).toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' });

        return `
          <div class="chat-message-row ${direction}">
            <div class="chat-avatar">${initial}</div>
            <div class="chat-bubble-wrap">
              <div class="chat-bubble">${escapeHtml(c.text)}</div>
              <div class="chat-meta">${escapeHtml(authorName)}  ${time}</div>
            </div>
          </div>
        `;
      }).join('');

      container.scrollTop = container.scrollHeight;
    }

    // Escape HTML to prevent XSS in comments
    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    // Update review stats
    function updateReviewStats() {
      console.log('updateReviewStats called, elements:', elements.length);
      console.log('Can view prices:', checkPermission('canViewPrices'));

      const totalEl = document.getElementById('reviewTotal');
      const countEl = document.getElementById('reviewItemCount');
      const approvedEl = document.getElementById('reviewApproved');

      if (totalEl && checkPermission('canViewPrices')) {
        let total = 0;
        elements.forEach(el => {
          if (el.retailPrice) {
            total += el.retailPrice;
          } else {
            const priceInfo = getElementPrice(el);
            const margin = getElementMargin(el);
            let cost = priceInfo?.price || 0;
            if (['countertop', 'backsplash', 'flooring', 'tile'].includes(el.type)) {
              cost = (el.width || 1) * (el.height || 1) * cost;
            }
            total += cost * (1 + (margin || 30) / 100);
          }
        });
        console.log('Calculated total:', total);
        totalEl.textContent = '$' + total.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2});
      } else if (totalEl) {
        totalEl.textContent = '--';
      }

      if (countEl) countEl.textContent = elements.length;

      if (approvedEl) {
        const approved = elements.filter(el => el.status === 'approved').length;
        approvedEl.textContent = approved;
      }
    }

    // Save review state to database
    async function saveReviewState() {
      if (!SHARE_STATE.shareId) return;

      try {
        const supabase = getSupabaseClient();
        if (!supabase) return;

        // Save element statuses to the design
        await supabase
          .from('room_designs')
          .update({
            elements: elements.map(el => ({
              ...el,
              textureImg: null
            }))
          })
          .eq('id', SHARE_STATE.designId);

        // Save comments to the share record
        await supabase
          .from('room_design_shares')
          .update({
            comments: SHARE_STATE.comments
          })
          .eq('id', SHARE_STATE.shareId);

      } catch (err) {
        console.error('Error saving review state:', err);
      }
    }

    // Submit final review
    async function submitReview() {
      const approved = elements.filter(el => el.status === 'approved').length;
      const rejected = elements.filter(el => el.status === 'rejected').length;
      const pending = elements.filter(el => el.status === 'pending').length;

      const confirmed = await showConfirmDialog({
        title: 'Submit Review',
        message: `Review Summary:\n\n Approved: ${approved}\n Rejected: ${rejected}\n Pending: ${pending}`,
        confirmText: 'Submit Review',
        cancelText: 'Continue Reviewing'
      });

      if (confirmed) {
        await saveReviewState();
        showToast('Review submitted! The design owner will be notified.', 'success');
      }
    }

    // Reload texture for an element
    function loadElementTexture(el) {
      if (!el.materialId) return;

      for (const category in MATERIALS) {
        const mat = MATERIALS[category].find(m => m.id === el.materialId);
        if (mat && mat.url) {
          const img = new Image();
          img.crossOrigin = 'anonymous';
          img.onload = () => {
            el.textureImg = img;
            draw();
          };
          img.src = mat.url;
          break;
        }
      }
    }

    // Apply UI restrictions based on permission level
    function applyPermissionRestrictions() {
      // Default to restrictive permissions if not set (safer for shared views)
      const perms = SHARE_STATE.allowedActions || { canEdit: false, canComment: true, canApprove: false };

      console.log('Applying permission restrictions:', SHARE_STATE.permission, perms);

      // Hide/disable editing controls for non-edit permissions
      if (!perms.canEdit) {
        document.body.classList.add('review-readonly');
        document.body.classList.add('view-only-mode');

        // Remove mobile toolbar if it exists
        const mobileToolbar = document.getElementById('mobileToolbar');
        if (mobileToolbar) mobileToolbar.remove();

        // Hide the entire left sidebar (tools, cabinets, floor plans, etc.)
        const sidebar = document.querySelector('.sidebar');
        if (sidebar) sidebar.style.display = 'none';

        const leftSidebar = document.getElementById('leftSidebar');
        if (leftSidebar) leftSidebar.style.display = 'none';

        const toolsSection = document.getElementById('toolsSection');
        if (toolsSection) toolsSection.style.display = 'none';

        // Hide all tool buttons via direct DOM
        document.querySelectorAll('.tool-btn, .tool-grid').forEach(el => {
          el.style.display = 'none';
        });

        // Hide the top toolbar action buttons (save, export, etc.) except view controls
        const topToolbar = document.querySelector('.top-toolbar');
        if (topToolbar) {
          // Hide editing buttons but keep view/zoom controls
          topToolbar.querySelectorAll('button, .btn').forEach(btn => {
            const id = btn.id || '';
            const text = btn.textContent?.toLowerCase() || '';
            // Keep: 2D/3D toggle, zoom, view controls
            const keepVisible = id.includes('view') || id.includes('zoom') ||
                               id.includes('2d') || id.includes('3d') ||
                               text.includes('2d') || text.includes('3d') ||
                               btn.classList.contains('view-btn');
            if (!keepVisible) {
              btn.style.display = 'none';
            }
          });
        }

        // Hide the save button
        const saveBtn = document.getElementById('saveDesignBtn');
        if (saveBtn) saveBtn.style.display = 'none';

        // Hide the share button (viewers shouldn't reshare)
        const shareBtn = document.getElementById('shareDesignBtn');
        if (shareBtn) shareBtn.style.display = 'none';

        // Hide item picker / element picker
        const itemPicker = document.getElementById('itemPicker');
        if (itemPicker) itemPicker.style.display = 'none';

        // Hide element selector dropdown
        const elementSelector = document.getElementById('elementSelector');
        if (elementSelector) elementSelector.style.display = 'none';

        // Disable all tool buttons
        document.querySelectorAll('.tool-btn').forEach(btn => {
          btn.disabled = true;
          btn.style.opacity = '0.5';
          btn.style.pointerEvents = 'none';
        });

        // Disable element buttons
        document.querySelectorAll('.element-btn, .toolbar-btn').forEach(btn => {
          btn.disabled = true;
          btn.style.opacity = '0.5';
          btn.style.pointerEvents = 'none';
        });

        // Disable properties panel inputs
        const propsContent = document.getElementById('propertiesContent');
        if (propsContent) {
          propsContent.querySelectorAll('input, select, button').forEach(el => {
            el.disabled = true;
          });
        }

        // Hide the floating action buttons
        const floatingActions = document.querySelector('.floating-actions');
        if (floatingActions) floatingActions.style.display = 'none';

        // Hide quick actions
        const quickActions = document.querySelector('.quick-actions');
        if (quickActions) quickActions.style.display = 'none';

        // Hide the delete/duplicate buttons in context
        document.querySelectorAll('[onclick*="delete"], [onclick*="duplicate"], [onclick*="Delete"], [onclick*="Duplicate"]').forEach(el => {
          el.style.display = 'none';
        });

        // Expand the canvas area since sidebar is hidden
        const workspace = document.querySelector('.workspace');
        if (workspace) {
          workspace.style.gridTemplateColumns = '1fr';
        }

        // Show a viewer badge
        showViewerModeBadge(perms);
      }

      // Hide pricing elements in main panel (shown in review panel instead)
      if (!perms.canViewPrices) {
        const quotePanel = document.getElementById('quotePanel');
        if (quotePanel) quotePanel.style.display = 'none';

        // Hide price-related elements
        document.querySelectorAll('.price-display, .quote-total, .element-price').forEach(el => {
          el.style.display = 'none';
        });
      }

      // Hide cost view toggle
      if (!perms.canViewCosts) {
        const costBtn = document.getElementById('costViewBtn');
        if (costBtn) costBtn.style.display = 'none';
      }

      // Show presentation mode for presentation permission
      if (SHARE_STATE.permission === 'presentation') {
        document.body.classList.add('presentation-mode');
      }

      // Material view hides most UI
      if (SHARE_STATE.permission === 'material_view') {
        document.body.classList.add('material-view-mode');
      }

      // Auto-open review panel after a delay
      setTimeout(() => {
        const panel = document.getElementById('reviewPanel');
        if (panel) panel.classList.add('open');
      }, 1000);
    }

    // Show a badge indicating viewer mode
    function showViewerModeBadge(perms) {
      // Remove any existing badge
      const existing = document.getElementById('viewerModeBadge');
      if (existing) existing.remove();

      const badge = document.createElement('div');
      badge.id = 'viewerModeBadge';
      badge.className = 'viewer-mode-badge';

      const permName = PERMISSION_LEVELS[SHARE_STATE.permission]?.name || 'View Only';
      const icon = perms.canApprove ? '' : '';

      badge.innerHTML = `
        <span class="badge-icon">${icon}</span>
        <span class="badge-text">${permName}</span>
        ${perms.canApprove ? '<span class="badge-action">Review & Approve</span>' : ''}
      `;

      document.body.appendChild(badge);
    }

    function showCollaboratorBadge() {
      const existing = document.getElementById('viewerModeBadge');
      if (existing) existing.remove();
      const badge = document.createElement('div');
      badge.id = 'viewerModeBadge';
      badge.style.cssText = 'position:fixed;top:12px;right:12px;z-index:10000;background:rgba(16,185,129,0.95);color:#fff;padding:8px 16px;border-radius:8px;font-size:13px;font-weight:600;display:flex;align-items:center;gap:6px;box-shadow:0 2px 8px rgba(0,0,0,0.3);pointer-events:none;';
      badge.innerHTML = '<span style="font-size:16px;">&#9998;</span> Collaborating <span style="font-size:9px;opacity:0.7;margin-left:4px;">LIVE</span>';
      document.body.appendChild(badge);
      // Auto-fade after 5 seconds
      setTimeout(() => { if (badge.parentNode) badge.style.opacity = '0.5'; }, 5000);
    }

    function showPermissionNotice(permission) {
      const permInfo = PERMISSION_LEVELS[permission];
      if (!permInfo) return;

      const notice = document.createElement('div');
      notice.className = 'permission-notice';
      notice.innerHTML = `
        <div class="notice-content">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:18px;height:18px;">
            <circle cx="12" cy="12" r="10"/>
            <path d="M12 16v-4"/>
            <path d="M12 8h.01"/>
          </svg>
          <span>Viewing as: <strong>${permInfo.name}</strong></span>
          <button onclick="this.parentElement.parentElement.remove()" style="background:none;border:none;color:inherit;cursor:pointer;font-size:16px;"></button>
        </div>
      `;
      document.body.appendChild(notice);

      setTimeout(() => notice.remove(), 8000);
    }

    // Load active shares for current design
    async function loadActiveShares() {
      if (!SHARE_STATE.designId) return;

      try {
        const supabase = getSupabaseClient();
        if (!supabase) return;

        const { data, error } = await supabase
          .from('room_design_shares')
          .select('*')
          .eq('design_id', SHARE_STATE.designId)
          .order('created_at', { ascending: false });

        if (error) throw error;

        renderActiveShares(data || []);

        // Also load recent activity
        loadRecentActivity();
      } catch (err) {
        console.error('Load shares error:', err);
      }
    }

    function renderActiveShares(shares) {
      const container = document.getElementById('activeShares');
      const list = document.getElementById('sharesList');
      if (!container || !list) return;

      if (shares.length === 0) {
        container.style.display = 'none';
        return;
      }

      container.style.display = 'block';
      list.innerHTML = shares.map(share => `
        <div class="share-item">
          <div class="share-info">
            <span class="share-permission">${PERMISSION_LEVELS[share.permission_level]?.name || share.permission_level}</span>
            <span class="share-stats">${share.access_count || 0} views</span>
          </div>
          <div class="share-actions">
            <button class="btn btn-sm" onclick="copyToClipboard('${window.location.origin}${window.location.pathname}?share=${share.share_token}')">Copy</button>
            <button class="btn btn-sm btn-danger" onclick="revokeShare('${share.id}')">Revoke</button>
          </div>
        </div>
      `).join('');
    }

    function copyToClipboard(text) {
      navigator.clipboard.writeText(text).then(() => {
        showToast('Copied to clipboard!', 'success');
      }).catch(() => {
        const temp = document.createElement('textarea');
        temp.value = text;
        document.body.appendChild(temp);
        temp.select();
        document.execCommand('copy');
        document.body.removeChild(temp);
        showToast('Copied to clipboard!', 'success');
      });
    }

    async function revokeShare(shareId) {
      const confirmed = await showConfirmDialog({
        title: 'Revoke Share Link?',
        message: 'Revoke this share link?\n\nAnyone with this link will no longer be able to access.',
        confirmText: 'Revoke Access',
        cancelText: 'Keep Shared',
        dangerous: true
      });
      if (!confirmed) return;

      try {
        const supabase = getSupabaseClient();
        if (!supabase) return;

        const { error } = await supabase
          .from('room_design_shares')
          .delete()
          .eq('id', shareId);

        if (error) throw error;

        loadActiveShares();
        showToast('Share link revoked', 'success');
      } catch (err) {
        showToast('Error revoking share: ' + err.message, 'error');
      }
    }

    // Log activity for notifications
    async function logActivity(type, elementIndex = null, elementName = null, commentText = null) {
      if (!SHARE_STATE.designId) return;

      try {
        const supabase = getSupabaseClient();
        if (!supabase) return;

        await supabase.from('design_activity').insert({
          design_id: SHARE_STATE.designId,
          share_id: SHARE_STATE.shareId,
          activity_type: type,
          element_index: elementIndex,
          element_name: elementName,
          comment_text: commentText
        });
      } catch (err) {
        console.error('Error logging activity:', err);
      }
    }

    // Load recent activity for a design
    async function loadRecentActivity() {
      if (!SHARE_STATE.designId) return;

      try {
        const supabase = getSupabaseClient();
        if (!supabase) return;

        const { data, error } = await supabase
          .from('design_activity')
          .select('*')
          .eq('design_id', SHARE_STATE.designId)
          .order('created_at', { ascending: false })
          .limit(20);

        if (error) throw error;

        renderActivityList(data || []);
      } catch (err) {
        console.error('Error loading activity:', err);
      }
    }

    // Render the activity list
    function renderActivityList(activities) {
      const container = document.getElementById('recentActivity');
      const list = document.getElementById('activityList');
      if (!container || !list) return;

      if (activities.length === 0) {
        container.style.display = 'none';
        return;
      }

      container.style.display = 'block';

      const icons = {
        view: '',
        comment: '',
        approve: '',
        reject: ''
      };

      const formatTime = (timestamp) => {
        const date = new Date(timestamp);
        const now = new Date();
        const diffMs = now - date;
        const diffMins = Math.floor(diffMs / 60000);
        const diffHours = Math.floor(diffMs / 3600000);
        const diffDays = Math.floor(diffMs / 86400000);

        if (diffMins < 1) return 'Just now';
        if (diffMins < 60) return `${diffMins}m ago`;
        if (diffHours < 24) return `${diffHours}h ago`;
        if (diffDays < 7) return `${diffDays}d ago`;
        return date.toLocaleDateString();
      };

      const getActivityText = (activity) => {
        switch (activity.activity_type) {
          case 'view':
            return 'Someone viewed the design';
          case 'comment':
            return `Comment: "${activity.comment_text?.substring(0, 50)}${activity.comment_text?.length > 50 ? '...' : ''}"`;
          case 'approve':
            return `Approved: ${activity.element_name || 'an element'}`;
          case 'reject':
            return `Rejected: ${activity.element_name || 'an element'}`;
          default:
            return 'Activity';
        }
      };

      list.innerHTML = activities.map(activity => `
        <div class="activity-item">
          <div class="activity-icon ${activity.activity_type}">${icons[activity.activity_type] || ''}</div>
          <div class="activity-content">
            <div class="activity-text">${getActivityText(activity)}</div>
            <div class="activity-time">${formatTime(activity.created_at)}</div>
          </div>
        </div>
      `).join('');
    }

    // Check URL for shared design token on page load
    function checkSharedDesignUrl() {
      const urlParams = new URLSearchParams(window.location.search);
      // Check for both 'share' and 'p' parameters
      const shareToken = urlParams.get('share') || urlParams.get('p');

      console.log('Checking shared design URL:', window.location.search);
      console.log('Share token found:', shareToken);

      if (shareToken) {
        console.log('Loading shared design with token:', shareToken);
        loadSharedDesign(shareToken);
      }
    }

    // Check for lead info passed from account page
    // Global lead info storage for quote integration
    let currentLeadInfo = null;

    function checkLeadInfo() {
      const urlParams = new URLSearchParams(window.location.search);
      const fromLead = urlParams.get('from_lead');

      if (!fromLead) return;

      try {
        const leadInfoJson = sessionStorage.getItem('sg_lead_for_design');
        if (!leadInfoJson) return;

        const leadInfo = JSON.parse(leadInfoJson);
        console.log('Loading design from lead:', leadInfo);

        // Store lead info globally for use in quotes and estimates
        currentLeadInfo = {
          id: leadInfo.id,
          name: leadInfo.full_name || '',
          email: leadInfo.email || '',
          phone: leadInfo.phone || '',
          address: leadInfo.address || '',
          projectType: leadInfo.project_type || '',
          notes: leadInfo.message || ''
        };

        // Pre-fill project name with customer name and project type
        const projectNameField = document.getElementById('projectName');
        if (projectNameField) {
          const projectType = leadInfo.project_type ? `${leadInfo.project_type.charAt(0).toUpperCase() + leadInfo.project_type.slice(1)} ` : '';
          projectNameField.value = `${leadInfo.full_name} - ${projectType}Design`;
          currentProjectName = projectNameField.value;
        }

        // Set room type based on project type
        const roomTypeField = document.getElementById('roomType');
        if (roomTypeField && leadInfo.project_type) {
          const typeMap = {
            'kitchen': 'kitchen',
            'bathroom': 'bathroom',
            'flooring': 'living-room',
            'fireplace': 'living-room',
            'outdoor': 'outdoor-kitchen',
            'commercial': 'commercial'
          };
          const roomType = typeMap[leadInfo.project_type.toLowerCase()] || 'kitchen';
          roomTypeField.value = roomType;
          changeRoomType();
        }

        // Store lead ID for later association
        window.currentLeadId = leadInfo.id;

        // Also save to localStorage for persistence if page refreshes
        localStorage.setItem('sg_current_lead_info', JSON.stringify(currentLeadInfo));

        // Clear sessionStorage to prevent reuse on new tabs
        sessionStorage.removeItem('sg_lead_for_design');

        // Clean up URL
        history.replaceState(null, '', window.location.pathname);

        // Show lead context banner
        showLeadContextBanner(leadInfo.full_name);

        showNotification(`Design started for ${leadInfo.full_name}`, 'success');
      } catch (e) {
        console.error('Error loading lead info:', e);
      }
    }

    // Show a banner indicating this design is linked to a lead
    function showLeadContextBanner(customerName) {
      // Check if banner already exists
      if (document.getElementById('leadContextBanner')) return;

      const banner = document.createElement('div');
      banner.id = 'leadContextBanner';
      banner.style.cssText = `
        position: fixed;
        top: 56px;
        left: 50%;
        transform: translateX(-50%);
        background: linear-gradient(135deg, rgba(99, 102, 241, 0.9) 0%, rgba(139, 92, 246, 0.9) 100%);
        backdrop-filter: blur(10px);
        padding: 8px 20px;
        border-radius: 0 0 12px 12px;
        font-size: 12px;
        font-weight: 500;
        color: white;
        z-index: 200;
        display: flex;
        align-items: center;
        gap: 10px;
        box-shadow: 0 4px 20px rgba(99, 102, 241, 0.3);
      `;
      banner.innerHTML = `
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:14px;height:14px;">
          <path d="M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"/>
          <circle cx="8.5" cy="7" r="4"/>
          <line x1="20" y1="8" x2="20" y2="14"/><line x1="23" y1="11" x2="17" y2="11"/>
        </svg>
        <span>Designing for: <strong>${customerName}</strong></span>
        <button onclick="clearLeadContext()" style="background:rgba(255,255,255,0.2);border:none;color:white;padding:2px 8px;border-radius:4px;cursor:pointer;font-size:10px;margin-left:8px;">
          Clear
        </button>
      `;
      document.body.appendChild(banner);
    }

    // Clear lead context
    function clearLeadContext() {
      currentLeadInfo = null;
      window.currentLeadId = null;
      localStorage.removeItem('sg_current_lead_info');

      const banner = document.getElementById('leadContextBanner');
      if (banner) banner.remove();

      showNotification('Lead context cleared', 'info');
    }

    // Restore lead info from localStorage on page load
    function restoreLeadInfo() {
      try {
        const savedLead = localStorage.getItem('sg_current_lead_info');
        if (savedLead) {
          currentLeadInfo = JSON.parse(savedLead);
          window.currentLeadId = currentLeadInfo.id;
          showLeadContextBanner(currentLeadInfo.name);
        }
      } catch (e) {
        console.error('Error restoring lead info:', e);
      }
    }

    async function clearCanvas() {
      const confirmed = await showConfirmDialog({
        title: 'Clear Canvas?',
        message: 'This will remove all elements from the canvas.\n\nRoom settings will be preserved and your progress will still be auto-saved.',
        confirmText: 'Clear Canvas',
        cancelText: 'Keep Elements'
      });
      if (!confirmed) return;

      elements = [];
      elementListDirty = true;
      walls = walls.filter(w => w.type === 'area');
      selectedElement = null;

      updateProperties();
      updateElementSelector();
      updateItemPicker();
      calculateQuote();
      saveUndoState(); // This also triggers auto-save
      draw();
      render3D();

      showToast('Canvas cleared', 'info');
    }

    // Create a completely fresh new design - stays in designer, just clears canvas
    async function createNewDesign() {
      // Check if there are unsaved changes
      const hasContent = elements.length > 0 || walls.length > 0;

      if (hasContent) {
        const confirmed = await showConfirmDialog({
          title: 'Start New Design?',
          message: 'Your current work will be saved before clearing.\n\nYou can access it later from "My Designs".',
          confirmText: 'Save & Start New',
          cancelText: 'Cancel'
        });
        if (!confirmed) return;

        // Save current work silently (don't redirect or show project creation dialogs)
        try {
          await saveDesignToCloud(true); // true = silent mode, no popups
        } catch (err) {
          console.log('Save before new failed, continuing anyway');
          saveDesignLocally(); // At least save locally
        }
      }

      // Clear all shared/viewing state
      if (typeof SHARE_STATE !== 'undefined') {
        SHARE_STATE.isSharedView = false;
        SHARE_STATE.designId = null;
        SHARE_STATE.designToken = null;
        SHARE_STATE.ownerEmail = null;
        SHARE_STATE.allowedActions = {};
      }

      // Reset current design ID (will get new ID on next save)
      currentDesignId = null;

      // Clear all elements and walls
      elements = [];
      elementListDirty = true;
      walls = [];
      selectedElement = null;
      selectedElements = [];
      undoStack = [];
      redoStack = [];

      // Reset room to defaults
      roomWidth = 12;
      roomDepth = 10;
      roomHeight = 8;
      const widthInput = document.getElementById('roomWidth');
      const depthInput = document.getElementById('roomDepth');
      const typeInput = document.getElementById('roomType');
      if (widthInput) widthInput.value = 12;
      if (depthInput) depthInput.value = 10;
      if (typeInput) typeInput.value = 'kitchen';

      // Reset project name
      const projectNameInput = document.getElementById('projectName');
      if (projectNameInput) {
        projectNameInput.value = 'New Design';
      }

      // Clear URL parameters (in case viewing shared design)
      history.replaceState({}, '', window.location.pathname);

      // Remove any viewer mode badges or approval banners
      document.getElementById('viewerModeBadge')?.remove();
      document.getElementById('approvalBanner')?.remove();
      document.getElementById('approvalRoomSelector')?.remove();
      document.body.classList.remove('approval-review-mode');

      // Clear autosave for fresh start
      try {
        localStorage.removeItem('room_designer_autosave');
      } catch (e) {}

      // Reset multi-room state
      if (typeof rooms !== 'undefined') {
        rooms.length = 0;
        currentRoomIndex = 0;
      }

      // Update UI - stay in the designer
      fitToScreen();
      if (typeof updateProperties === 'function') updateProperties();
      if (typeof updateElementSelector === 'function') updateElementSelector();
      if (typeof updateItemPicker === 'function') updateItemPicker();
      if (typeof calculateQuote === 'function') calculateQuote();
      if (typeof draw === 'function') draw();
      if (typeof updateRoomList === 'function') updateRoomList();

      // Reset 3D if in 3D view
      if (currentView === '3d' && typeof init3D === 'function') {
        init3D();
      }

      showToast('Ready for new design', 'success');
    }

    // ===== EXPORT FUNCTIONALITY =====
    function toggleExportMenu() {
      const menu = document.getElementById('exportMenu');
      menu.classList.toggle('show');

      // Close when clicking outside
      const closeHandler = (e) => {
        if (!e.target.closest('.export-dropdown')) {
          menu.classList.remove('show');
          document.removeEventListener('click', closeHandler);
        }
      };

      setTimeout(() => {
        document.addEventListener('click', closeHandler);
      }, 0);
    }

    // ===== PRO TOOLS MENU =====
    function toggleProToolsMenu() {
      const menu = document.getElementById('proToolsMenu');
      menu.classList.toggle('show');

      // Close when clicking outside
      const closeHandler = (e) => {
        if (!e.target.closest('.pro-tools-dropdown')) {
          menu.classList.remove('show');
          document.removeEventListener('click', closeHandler);
        }
      };

      setTimeout(() => {
        document.addEventListener('click', closeHandler);
      }, 0);
    }

    function closeProToolsMenu() {
      document.getElementById('proToolsMenu').classList.remove('show');
    }

    // =============================================
    // PRO TOOLS - Cabinet Library with Custom Upload
    // UNIFIED CABINET SYSTEM - Single Source of Truth
    // =============================================

    // Master cabinet specifications - ALL cabinet data flows from here
    // Dimensions: width/height in FEET for 2D canvas, actualHeight in INCHES for 3D
    const MASTER_CABINET_SPECS = {
      // Base Cabinets: 24" deep, 34.5" tall
      base: {
        depth: 2,        // 24" in feet (shown as 'height' in 2D top-down view)
        actualHeight: 34.5,  // Physical height in inches
        color: '#8B7355',
        icon: '',
        sizes: [9, 12, 15, 18, 21, 24, 27, 30, 33, 36, 42, 48]
      },
      // Wall Cabinets: 12" deep, 30-42" tall (we use 30" default)
      wall: {
        depth: 1,        // 12" in feet
        actualHeight: 30,
        color: '#9B8465',
        icon: '',
        sizes: [9, 12, 15, 18, 21, 24, 27, 30, 33, 36, 42]
      },
      // Tall/Pantry: 24" deep, 84-96" tall
      tall: {
        depth: 2,        // 24" in feet
        actualHeight: 84,
        color: '#8B7355',
        icon: '',
        sizes: [18, 24, 30, 36]
      },
      // Corner: 36"x36" footprint
      corner: {
        depth: 3,        // 36" in feet (square)
        actualHeight: 34.5,
        color: '#7B6545',
        icon: ''
      },
      // Island: variable, default 72"x36"
      island: {
        depth: 3,        // 36" in feet
        actualHeight: 36,
        color: '#6B5545',
        icon: ''
      }
    };

    // Generate cabinet from specs
    function generateCabinetDef(type, widthInches, specs, label) {
      return {
        type: type,
        label: label || `${type.replace(/-/g, ' ').replace(/\b\w/g, c => c.toUpperCase())} ${widthInches}"`,
        width: widthInches / 12,  // Convert to feet
        height: specs.depth,       // 2D "height" = physical depth
        actualHeight: specs.actualHeight,
        color: specs.color,
        icon: specs.icon,
        dims: `${widthInches}"  ${specs.depth * 12}"${specs.actualHeight > 36 ? `  ${specs.actualHeight}"` : ''}`
      };
    }

    function showCabinetLibrary() {
      // Remove existing modal if any
      const existing = document.getElementById('cabinetLibraryModal');
      if (existing) existing.remove();

      // Load custom cabinets from localStorage
      const customCabinets = JSON.parse(localStorage.getItem('customCabinetLibrary') || '[]');

      // Get ProCraft and MSI catalogs
      const procraftCabinets = CABINET_CATALOGS?.procraft?.cabinets || {};
      const msiCabinets = CABINET_CATALOGS?.msi?.cabinets || {};

      // UNIFIED Cabinet Library - generated from MASTER_CABINET_SPECS
      const CABINET_LIBRARY = {
        base: [
          // Standard sizes from master specs
          ...MASTER_CABINET_SPECS.base.sizes.filter(s => [12, 15, 18, 24, 30, 36].includes(s)).map(size =>
            generateCabinetDef('base-cabinet', size, MASTER_CABINET_SPECS.base, `Base ${size}"`)
          ),
          // Specialty base cabinets
          { type: 'drawer-base', label: 'Drawer Base 18"', width: 1.5, height: 2, actualHeight: 34.5, icon: '', dims: '18"  24"', color: '#8B7355' },
          { type: 'drawer-base', label: 'Drawer Base 24"', width: 2, height: 2, actualHeight: 34.5, icon: '', dims: '24"  24"', color: '#8B7355' },
          { type: 'drawer-base', label: 'Drawer Base 36"', width: 3, height: 2, actualHeight: 34.5, icon: '', dims: '36"  24"', color: '#8B7355' },
          { type: 'sink-base', label: 'Sink Base 30"', width: 2.5, height: 2, actualHeight: 34.5, icon: '', dims: '30"  24"', color: '#8B7355' },
          { type: 'sink-base', label: 'Sink Base 36"', width: 3, height: 2, actualHeight: 34.5, icon: '', dims: '36"  24"', color: '#8B7355' },
          { type: 'corner-cabinet', label: 'Corner Base', width: 3, height: 3, actualHeight: 34.5, icon: '', dims: '36"  36"', color: '#7B6545' },
          { type: 'lazy-susan', label: 'Lazy Susan', width: 3, height: 3, actualHeight: 34.5, icon: '', dims: '36"  36"', color: '#7B6545' },
          { type: 'blind-corner', label: 'Blind Corner 42"', width: 3.5, height: 2, actualHeight: 34.5, icon: '', dims: '42"  24"', color: '#7B6545' },
          { type: 'blind-corner', label: 'Blind Corner 48"', width: 4, height: 2, actualHeight: 34.5, icon: '', dims: '48"  24"', color: '#7B6545' }
        ],
        wall: [
          // Standard wall cabinet sizes
          ...MASTER_CABINET_SPECS.wall.sizes.filter(s => [12, 15, 18, 24, 30, 36, 42].includes(s)).map(size =>
            generateCabinetDef('wall-cabinet', size, MASTER_CABINET_SPECS.wall, `Wall ${size}"`)
          ),
          // Specialty wall cabinets
          { type: 'microwave-cabinet', label: 'Microwave Cab 30"', width: 2.5, height: 1.5, actualHeight: 18, icon: '', dims: '30"  18"', color: '#8B7355' },
          { type: 'above-microwave-cabinet', label: 'Above Microwave', width: 2.5, height: 1, actualHeight: 12, icon: '', dims: '30"  12"', color: '#9B8465' }
        ],
        tall: [
          // Pantry cabinets
          { type: 'tall-cabinet', label: 'Pantry 18"', width: 1.5, height: 2, actualHeight: 84, icon: '', dims: '18"  24"  84"', color: '#8B7355' },
          { type: 'tall-cabinet', label: 'Pantry 24"', width: 2, height: 2, actualHeight: 84, icon: '', dims: '24"  24"  84"', color: '#8B7355' },
          { type: 'tall-cabinet', label: 'Pantry 36"', width: 3, height: 2, actualHeight: 84, icon: '', dims: '36"  24"  84"', color: '#8B7355' },
          // Oven cabinets
          { type: 'single-oven-cabinet', label: 'Single Oven 30"', width: 2.5, height: 2, actualHeight: 84, icon: '', dims: '30"  24"  84"', color: '#8B7355' },
          { type: 'tall-oven', label: 'Tall Oven 30"', width: 2.5, height: 2, actualHeight: 84, icon: '', dims: '30"  24"  84"', color: '#8B7355' },
          { type: 'double-oven-cabinet', label: 'Double Oven 30"', width: 2.5, height: 2, actualHeight: 84, icon: '', dims: '30"  24"  84"', color: '#8B7355' },
          // Fridge cabinet
          { type: 'fridge-cabinet', label: 'Fridge Cabinet 36"', width: 3, height: 2, actualHeight: 84, icon: '', dims: '36"  24"  84"', color: '#8B7355' }
        ],
        specialty: [
          { type: 'island', label: 'Island 48"36"', width: 4, height: 3, actualHeight: 36, icon: '', dims: '48"  36"', color: '#6B5545' },
          { type: 'island', label: 'Island 60"36"', width: 5, height: 3, actualHeight: 36, icon: '', dims: '60"  36"', color: '#6B5545' },
          { type: 'island', label: 'Island 72"36"', width: 6, height: 3, actualHeight: 36, icon: '', dims: '72"  36"', color: '#6B5545' },
          { type: 'island', label: 'Island 96"42"', width: 8, height: 3.5, actualHeight: 36, icon: '', dims: '96"  42"', color: '#6B5545' },
          { type: 'linen-closet', label: 'Linen Closet 18"', width: 1.5, height: 2, actualHeight: 84, icon: '', dims: '18"  24"  84"', color: '#8B7355' },
          { type: 'linen-tower', label: 'Linen Tower 24"', width: 2, height: 1.75, actualHeight: 84, icon: '', dims: '24"  21"  84"', color: '#8B7355' }
        ],
        // ProCraft manufacturer catalog
        procraft: Object.values(procraftCabinets).flat().map(cab => ({
          type: cab.type,
          label: `${cab.name}`,
          width: cab.width,
          height: cab.height || cab.depth || 2,
          actualHeight: cab.type.includes('tall') || cab.type.includes('pantry') ? 84 : cab.type.includes('wall') ? 30 : 34.5,
          icon: cab.type.includes('wall') ? '' : cab.type.includes('tall') || cab.type.includes('pantry') ? '' : '',
          dims: `${Math.round(cab.width * 12)}"  ${Math.round((cab.depth || 2) * 12)}"`,
          sku: cab.sku,
          price: cab.price,
          color: '#8B7355',
          catalog: 'procraft'
        })),
        // MSI manufacturer catalog
        msi: Object.values(msiCabinets).flat().map(cab => ({
          type: cab.type,
          label: `${cab.name}`,
          width: cab.width,
          height: cab.height || cab.depth || 2,
          actualHeight: cab.type.includes('tall') || cab.type.includes('pantry') ? 84 : cab.type.includes('wall') ? 30 : 34.5,
          icon: cab.type.includes('wall') ? '' : cab.type.includes('tall') || cab.type.includes('pantry') ? '' : '',
          dims: `${Math.round(cab.width * 12)}"  ${Math.round((cab.depth || 2) * 12)}"`,
          sku: cab.sku,
          price: cab.price,
          color: '#8B7355',
          catalog: 'msi'
        })),
        // User's custom uploaded cabinets
        custom: customCabinets
      };

      let currentCategory = 'base';
      let searchTerm = '';

      const customCount = customCabinets.length;

      const modal = document.createElement('div');
      modal.id = 'cabinetLibraryModal';
      modal.className = 'cabinet-library-modal';
      modal.innerHTML = `
        <div class="cabinet-library-content">
          <div class="cabinet-library-header">
            <h3> Cabinet Library</h3>
            <div class="cabinet-library-tabs" style="flex-wrap: wrap; gap: 4px;">
              <button class="cab-tab active" data-cat="base">Base</button>
              <button class="cab-tab" data-cat="wall">Wall</button>
              <button class="cab-tab" data-cat="tall">Tall</button>
              <button class="cab-tab" data-cat="specialty">Specialty</button>
              <button class="cab-tab" data-cat="procraft" style="background: linear-gradient(135deg, #8B5A2B, #6B3A1B);" title="ProCraft Cabinetry">
                 ProCraft
              </button>
              <button class="cab-tab" data-cat="msi" style="background: linear-gradient(135deg, #1e3a5f, #0d1f33);" title="MSI Cabinetry">
                 MSI
              </button>
              <button class="cab-tab" data-cat="custom" style="background: linear-gradient(135deg, #10b981, #059669);">
                 My Library ${customCount > 0 ? `(${customCount})` : ''}
              </button>
            </div>
            <button onclick="document.getElementById('cabinetLibraryModal').remove()">&times;</button>
          </div>
          <div class="cabinet-library-body">
            <div class="cabinet-search" style="display: flex; gap: 8px; align-items: center;">
              <input type="text" id="cabinetSearchInput" placeholder="Search cabinets..." style="flex: 1;" />
              <button onclick="showCabinetUploadPanel()" class="btn btn-secondary" style="padding: 10px 16px; white-space: nowrap;">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="margin-right: 6px;">
                  <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                  <polyline points="17 8 12 3 7 8"/>
                  <line x1="12" y1="3" x2="12" y2="15"/>
                </svg>
                Import Catalog
              </button>
            </div>
            <div id="cabinetUploadPanel" style="display: none; margin-bottom: 16px; padding: 16px; background: rgba(16, 185, 129, 0.1); border: 1px solid rgba(16, 185, 129, 0.3); border-radius: 10px;">
              <h4 style="margin: 0 0 12px; font-size: 14px; color: #10b981;"> Import Cabinet Catalog</h4>
              <p style="font-size: 12px; color: var(--text-muted); margin: 0 0 12px;">
                Upload a CSV or JSON file with your cabinet catalog. Required columns: name/label, width, depth, height (in inches).
              </p>
              <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                <input type="file" id="cabinetCatalogFile" accept=".csv,.json" style="display: none;" onchange="handleCabinetCatalogUpload(event)" />
                <button onclick="document.getElementById('cabinetCatalogFile').click()" class="btn btn-primary" style="flex: 1;">
                  Select File (CSV/JSON)
                </button>
                <button onclick="downloadCabinetTemplate()" class="btn btn-secondary" style="flex: 1;">
                  Download Template
                </button>
              </div>
              <div id="catalogUploadStatus" style="margin-top: 12px; display: none;"></div>
            </div>
            <div class="cabinet-library-grid" id="cabinetLibraryGrid"></div>
          </div>
          <div class="cabinet-library-footer">
            <div class="custom-cabinet-form">
              <h4>Custom Size Cabinet</h4>
              <div class="custom-cab-inputs">
                <input type="number" id="customCabWidth" placeholder="W" min="6" max="60" value="36" /> 
                <input type="number" id="customCabDepth" placeholder="D" min="6" max="36" value="24" /> 
                <input type="number" id="customCabHeight" placeholder="H" min="12" max="96" value="34" />
                <span style="color: var(--text-muted); font-size: 12px;">inches</span>
                <button class="btn btn-primary" onclick="addCustomCabinet()">Add Custom</button>
              </div>
            </div>
          </div>
        </div>
      `;

      document.body.appendChild(modal);

      // Render cabinet grid
      function renderCabinetGrid() {
        const grid = document.getElementById('cabinetLibraryGrid');

        // Reload custom cabinets from localStorage in case they were updated
        if (currentCategory === 'custom') {
          CABINET_LIBRARY.custom = JSON.parse(localStorage.getItem('customCabinetLibrary') || '[]');
        }

        const cabinets = CABINET_LIBRARY[currentCategory] || [];
        const filtered = searchTerm
          ? cabinets.filter(c => (c.label || c.name || '').toLowerCase().includes(searchTerm.toLowerCase()))
          : cabinets;

        // Show empty state for custom category if no cabinets
        if (currentCategory === 'custom' && filtered.length === 0) {
          grid.innerHTML = `
            <div style="grid-column: 1/-1; text-align: center; padding: 40px 20px;">
              <div style="font-size: 48px; margin-bottom: 16px; opacity: 0.5;"></div>
              <h4 style="margin: 0 0 8px; color: var(--text);">No Custom Cabinets Yet</h4>
              <p style="margin: 0 0 16px; color: var(--text-muted); font-size: 13px;">
                Import your manufacturer's cabinet catalog using the "Import Catalog" button above.
              </p>
              <button onclick="showCabinetUploadPanel()" class="btn btn-primary">
                Import Catalog
              </button>
            </div>
          `;
          return;
        }

        grid.innerHTML = filtered.map((cab, idx) => `
          <div class="cabinet-lib-item" data-idx="${idx}" data-type="${cab.type}" data-width="${cab.customWidth || cab.width}" data-custom="${currentCategory === 'custom' ? 'true' : 'false'}">
            ${currentCategory === 'custom' ? `<button class="delete-custom-cab" data-idx="${idx}" style="position:absolute; top:4px; right:4px; background:#ef4444; border:none; color:white; width:18px; height:18px; border-radius:50%; font-size:10px; cursor:pointer; line-height:1;"></button>` : ''}
            <div class="cab-lib-icon">${cab.icon}</div>
            <div class="cab-lib-name">${cab.label || cab.name}</div>
            <div class="cab-lib-dims">${cab.dims}</div>
            ${cab.sku ? `<div style="font-size:10px; color:var(--text-muted); margin-top:4px;">${cab.sku}</div>` : ''}
            ${cab.price ? `<div style="font-size:11px; color:#10b981; margin-top:2px;">$${cab.price}</div>` : ''}
          </div>
        `).join('');

        // Add click handlers
        grid.querySelectorAll('.cabinet-lib-item').forEach((item, idx) => {
          item.onclick = (e) => {
            // Ignore if clicking delete button
            if (e.target.classList.contains('delete-custom-cab')) return;

            const cabinetData = filtered[idx];
            const type = cabinetData.type;
            const customWidth = cabinetData.customWidth || cabinetData.width;

            if (currentCategory === 'custom') {
              // For custom cabinets, use the full cabinet data
              addCustomCabinetFromLibrary(cabinetData);
            } else {
              // Pass full cabinet data for proper 3D height, color, price
              addCabinetFromLibrary(type, customWidth, cabinetData);
            }
          };
        });

        // Add delete handlers for custom cabinets
        grid.querySelectorAll('.delete-custom-cab').forEach(btn => {
          btn.onclick = (e) => {
            e.stopPropagation();
            const idx = parseInt(btn.dataset.idx);
            deleteCustomCabinet(idx);
          };
        });
      }

      // Delete a single custom cabinet
      function deleteCustomCabinet(idx) {
        const cabinets = JSON.parse(localStorage.getItem('customCabinetLibrary') || '[]');
        cabinets.splice(idx, 1);
        localStorage.setItem('customCabinetLibrary', JSON.stringify(cabinets));
        renderCabinetGrid();
        showToast('Cabinet removed from library', 'success');
      }

      // Tab switching
      modal.querySelectorAll('.cab-tab').forEach(tab => {
        tab.onclick = () => {
          modal.querySelectorAll('.cab-tab').forEach(t => t.classList.remove('active'));
          tab.classList.add('active');
          currentCategory = tab.dataset.cat;
          renderCabinetGrid();
        };
      });

      // Search
      document.getElementById('cabinetSearchInput').oninput = (e) => {
        searchTerm = e.target.value;
        renderCabinetGrid();
      };

      // Close on backdrop click
      modal.onclick = (e) => {
        if (e.target === modal) modal.remove();
      };

      // Prevent keyboard events from affecting canvas
      modal.onkeydown = (e) => e.stopPropagation();
      modal.onkeyup = (e) => e.stopPropagation();

      renderCabinetGrid();
    }

    // Add cabinet from library to canvas
    function addCabinetFromLibrary(type, customWidth, cabinetData) {
      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;
      createElement(type, centerX, centerY);

      // Apply cabinet data from library
      if (selectedElement) {
        if (customWidth) {
          selectedElement.width = customWidth;
        }
        if (cabinetData) {
          // Apply depth (2D height)
          if (cabinetData.height) {
            selectedElement.height = cabinetData.height;
          }
          // Apply 3D height (convert inches to feet for get3DHeight compatibility)
          if (cabinetData.actualHeight) {
            selectedElement.height3D = cabinetData.actualHeight / 12;
          }
          // Apply color
          if (cabinetData.color) {
            selectedElement.color = cabinetData.color;
          }
          // Apply label
          if (cabinetData.label) {
            selectedElement.label = cabinetData.label;
          }
          // Apply SKU and price for manufacturer cabinets
          if (cabinetData.sku) {
            selectedElement.sku = cabinetData.sku;
          }
          if (cabinetData.price) {
            selectedElement.price = cabinetData.price;
          }
          if (cabinetData.catalog) {
            selectedElement.catalog = cabinetData.catalog;
          }
        }
        draw();
        updateProperties();
      }

      document.getElementById('cabinetLibraryModal')?.remove();
      showToast('Cabinet added to canvas', 'success');
    }

    // Add custom cabinet with user-specified dimensions
    function addCustomCabinet() {
      const widthIn = parseFloat(document.getElementById('customCabWidth').value) || 36;
      const depthIn = parseFloat(document.getElementById('customCabDepth').value) || 24;
      const heightIn = parseFloat(document.getElementById('customCabHeight').value) || 34;

      const widthFt = widthIn / 12;
      const depthFt = depthIn / 12;

      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;

      createElement('base-cabinet', centerX, centerY);

      if (selectedElement) {
        selectedElement.width = widthFt;
        selectedElement.height = depthFt;
        selectedElement.label = `Custom ${widthIn}"${depthIn}"${heightIn}"`;
        selectedElement.height3D = heightIn / 12; // Store 3D height in feet for get3DHeight compatibility
        draw();
        updateProperties();
      }

      document.getElementById('cabinetLibraryModal')?.remove();
      showToast(`Added custom cabinet ${widthIn}"  ${depthIn}"  ${heightIn}"`, 'success');
    }

    // =============================================
    // Custom Cabinet Library Upload Functions
    // =============================================

    // Show/hide the upload panel
    function showCabinetUploadPanel() {
      const panel = document.getElementById('cabinetUploadPanel');
      if (panel) {
        panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
      }
    }

    // Download template CSV for cabinet catalog
    function downloadCabinetTemplate() {
      const template = `name,sku,type,width,depth,height,price
Base Cabinet 36,B36,base-cabinet,36,24,34.5,250
Wall Cabinet 30,W3030,wall-cabinet,30,12,30,180
Drawer Base 24,DB24,drawer-base,24,24,34.5,320
Sink Base 36,SB36,sink-base,36,24,34.5,280
Tall Pantry 24,TP2496,tall-cabinet,24,24,96,450
Corner Base,BCR36,corner-cabinet,36,36,34.5,380
Lazy Susan,BLS33,lazy-susan,33,33,34.5,420`;

      const blob = new Blob([template], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'cabinet-catalog-template.csv';
      a.click();
      URL.revokeObjectURL(url);

      showToast('Template downloaded! Fill in your cabinets and re-upload.', 'success');
    }

    // Handle cabinet catalog file upload
    async function handleCabinetCatalogUpload(event) {
      const file = event.target.files[0];
      if (!file) return;

      const statusEl = document.getElementById('catalogUploadStatus');
      statusEl.style.display = 'block';
      statusEl.innerHTML = '<span style="color: var(--primary);">Processing file...</span>';

      try {
        const text = await file.text();
        let cabinets = [];

        if (file.name.endsWith('.json')) {
          // Parse JSON
          const data = JSON.parse(text);
          cabinets = Array.isArray(data) ? data : (data.cabinets || data.items || []);
        } else {
          // Parse CSV
          cabinets = parseCSVCabinets(text);
        }

        if (cabinets.length === 0) {
          throw new Error('No valid cabinets found in file');
        }

        // Normalize and validate cabinet data
        const normalizedCabinets = cabinets.map((cab, idx) => {
          const widthIn = parseFloat(cab.width) || 36;
          const depthIn = parseFloat(cab.depth) || 24;
          const heightIn = parseFloat(cab.height) || 34.5;

          // Determine cabinet type from name or type field
          let type = cab.type || 'base-cabinet';
          const name = (cab.name || cab.label || cab.sku || `Cabinet ${idx + 1}`).toLowerCase();

          if (name.includes('wall') || name.startsWith('w')) type = 'wall-cabinet';
          else if (name.includes('tall') || name.includes('pantry') || name.startsWith('t')) type = 'tall-cabinet';
          else if (name.includes('sink') || name.startsWith('sb')) type = 'sink-base';
          else if (name.includes('drawer') || name.startsWith('db')) type = 'drawer-base';
          else if (name.includes('corner') || name.includes('bcr')) type = 'corner-cabinet';
          else if (name.includes('lazy') || name.includes('susan')) type = 'lazy-susan';
          else if (name.includes('island')) type = 'island';

          // Determine icon based on type
          const icons = {
            'base-cabinet': '',
            'wall-cabinet': '',
            'tall-cabinet': '',
            'sink-base': '',
            'drawer-base': '',
            'corner-cabinet': '',
            'lazy-susan': '',
            'island': ''
          };

          return {
            id: `custom-${Date.now()}-${idx}`,
            label: cab.name || cab.label || cab.sku || `Cabinet ${idx + 1}`,
            sku: cab.sku || cab.code || '',
            type: type,
            width: widthIn / 12,  // Convert to feet for canvas
            height: depthIn / 12, // Depth in feet (used as height in 2D)
            actualHeight: heightIn,
            icon: icons[type] || '',
            dims: `${widthIn}"  ${depthIn}"  ${heightIn}"`,
            price: parseFloat(cab.price) || null,
            customWidth: widthIn / 12
          };
        });

        // Save to localStorage
        const existing = JSON.parse(localStorage.getItem('customCabinetLibrary') || '[]');
        const merged = [...existing, ...normalizedCabinets];
        localStorage.setItem('customCabinetLibrary', JSON.stringify(merged));

        statusEl.innerHTML = `
          <span style="color: #10b981;"> Imported ${normalizedCabinets.length} cabinets!</span>
          <button onclick="clearCustomCabinetLibrary()" style="margin-left: 12px; padding: 4px 8px; font-size: 11px;" class="btn btn-secondary">
            Clear Library
          </button>
        `;

        // Refresh the modal to show new cabinets
        showToast(`Imported ${normalizedCabinets.length} cabinets to your library!`, 'success');

        // Switch to custom tab
        document.querySelector('.cab-tab[data-cat="custom"]')?.click();

      } catch (err) {
        console.error('Cabinet catalog upload error:', err);
        statusEl.innerHTML = `<span style="color: #ef4444;">Error: ${err.message}</span>`;
        showToast('Failed to import catalog: ' + err.message, 'error');
      }

      // Reset file input
      event.target.value = '';
    }

    // Parse CSV into cabinet objects
    function parseCSVCabinets(csvText) {
      const lines = csvText.trim().split('\n');
      if (lines.length < 2) return [];

      // Parse header
      const headers = lines[0].split(',').map(h => h.trim().toLowerCase());

      // Find column indices
      const nameIdx = headers.findIndex(h => ['name', 'label', 'description', 'sku', 'code'].includes(h));
      const skuIdx = headers.findIndex(h => ['sku', 'code', 'part', 'item'].includes(h));
      const typeIdx = headers.findIndex(h => ['type', 'category', 'kind'].includes(h));
      const widthIdx = headers.findIndex(h => ['width', 'w'].includes(h));
      const depthIdx = headers.findIndex(h => ['depth', 'd'].includes(h));
      const heightIdx = headers.findIndex(h => ['height', 'h'].includes(h));
      const priceIdx = headers.findIndex(h => ['price', 'cost', 'msrp'].includes(h));

      // Parse data rows
      const cabinets = [];
      for (let i = 1; i < lines.length; i++) {
        const values = lines[i].split(',').map(v => v.trim());
        if (values.length < 3) continue; // Skip invalid rows

        cabinets.push({
          name: nameIdx >= 0 ? values[nameIdx] : values[0],
          sku: skuIdx >= 0 ? values[skuIdx] : '',
          type: typeIdx >= 0 ? values[typeIdx] : '',
          width: widthIdx >= 0 ? values[widthIdx] : values[1] || '36',
          depth: depthIdx >= 0 ? values[depthIdx] : values[2] || '24',
          height: heightIdx >= 0 ? values[heightIdx] : values[3] || '34.5',
          price: priceIdx >= 0 ? values[priceIdx] : ''
        });
      }

      return cabinets;
    }

    // Clear custom cabinet library
    function clearCustomCabinetLibrary() {
      if (confirm('Are you sure you want to clear your custom cabinet library?')) {
        localStorage.removeItem('customCabinetLibrary');
        showToast('Custom cabinet library cleared', 'success');

        // Refresh modal
        document.getElementById('cabinetLibraryModal')?.remove();
        showCabinetLibrary();
      }
    }

    // Add custom cabinet from library (with full dimensions)
    function addCustomCabinetFromLibrary(cabinet) {
      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;

      createElement(cabinet.type || 'base-cabinet', centerX, centerY);

      if (selectedElement) {
        selectedElement.width = cabinet.width || cabinet.customWidth || 3;
        selectedElement.height = cabinet.height || 2;
        selectedElement.label = cabinet.label || cabinet.name;
        selectedElement.actualHeight = cabinet.actualHeight || 34.5;
        if (cabinet.price) selectedElement.priceOverride = cabinet.price;
        draw();
        updateProperties();
      }

      document.getElementById('cabinetLibraryModal')?.remove();
      showToast(`Added ${cabinet.label} to canvas`, 'success');
    }

    // =============================================
    // PRO TOOLS - Commercial Project Manager
    // =============================================
    // Full implementation is in designer-pro-features.js (window.showCommercialProjectManager)

    // =============================================
    // PRO TOOLS - Approval Workflow
    // =============================================
    function showApprovalWorkflow() {
      // Check if design is saved first
      if (!currentDesignId) {
        showToast('Please save your design first before sending for approval', 'warning');
        return;
      }

      const existing = document.getElementById('approvalWorkflowModal');
      if (existing) existing.remove();

      const modal = document.createElement('div');
      modal.id = 'approvalWorkflowModal';
      modal.className = 'cabinet-library-modal';
      modal.innerHTML = `
        <div class="cabinet-library-content" style="max-width: 500px;">
          <div class="cabinet-library-header">
            <h3> Send for Approval</h3>
            <button onclick="this.closest('.cabinet-library-modal').remove()">&times;</button>
          </div>
          <div class="cabinet-library-body">
            <div style="margin-bottom: 20px;">
              <label style="display: block; margin-bottom: 8px; font-weight: 500;">Recipient Email</label>
              <input type="email" id="approvalEmail" placeholder="customer@example.com"
                style="width: 100%; padding: 12px; border: 1px solid var(--border); border-radius: 8px; background: var(--dark-elevated); color: var(--text);" />
            </div>
            <div style="margin-bottom: 20px;">
              <label style="display: block; margin-bottom: 8px; font-weight: 500;">Message (optional)</label>
              <textarea id="approvalMessage" rows="3" placeholder="Please review this design and let me know your thoughts..."
                style="width: 100%; padding: 12px; border: 1px solid var(--border); border-radius: 8px; background: var(--dark-elevated); color: var(--text); resize: vertical;"></textarea>
            </div>
            <div style="display: flex; gap: 12px;">
              <button class="btn btn-secondary" onclick="this.closest('.cabinet-library-modal').remove()" style="flex: 1;">Cancel</button>
              <button class="btn btn-primary" onclick="sendForApproval()" style="flex: 1;">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="margin-right: 8px;">
                  <line x1="22" y1="2" x2="11" y2="13"/>
                  <polygon points="22 2 15 22 11 13 2 9 22 2"/>
                </svg>
                Send
              </button>
            </div>
          </div>
        </div>
      `;
      document.body.appendChild(modal);
      modal.onclick = (e) => { if (e.target === modal) modal.remove(); };
      modal.onkeydown = (e) => e.stopPropagation();

      // Focus email input
      setTimeout(() => document.getElementById('approvalEmail')?.focus(), 100);
    }

    async function sendForApproval() {
      const email = document.getElementById('approvalEmail')?.value?.trim();
      const message = document.getElementById('approvalMessage')?.value?.trim();

      if (!email) {
        showToast('Please enter an email address', 'warning');
        return;
      }

      // Basic email validation
      if (!email.includes('@') || !email.includes('.')) {
        showToast('Please enter a valid email address', 'warning');
        return;
      }

      try {
        // Generate share link if not already shared
        let shareUrl = window.location.origin + '/tools/room-designer/share/?token=' + currentDesignId;

        // Send approval request email via API
        const response = await fetch('/api/email/send-approval-request', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            to: email,
            designId: currentDesignId,
            shareUrl: shareUrl,
            message: message,
            projectName: document.getElementById('projectName')?.value || 'Room Design'
          })
        });

        if (response.ok) {
          showToast('Approval request sent successfully!', 'success');
          document.getElementById('approvalWorkflowModal')?.remove();
        } else {
          throw new Error('Failed to send email');
        }
      } catch (err) {
        console.error('Approval send error:', err);
        showToast('Failed to send approval request. Please try again.', 'error');
      }
    }

    function exportToPDF() {
      document.getElementById('exportMenu').classList.remove('show');

      // Demo mode check
      if (DEMO_MODE) {
        if (showDemoUpgradeModal('export')) return;
      }

      const { jsPDF } = window.jspdf;
      const doc = new jsPDF('p', 'mm', 'letter');

      const projectName = document.getElementById('projectName').value || 'Room Design';
      const roomType = document.getElementById('roomType').value;
      const quoteTotal = document.getElementById('quoteTotal').textContent;

      // Header
      doc.setFillColor(184, 154, 91); // Gold color
      doc.rect(0, 0, 216, 35, 'F');

      doc.setTextColor(0, 0, 0);
      doc.setFontSize(24);
      doc.setFont('helvetica', 'bold');
      doc.text('Surprise Granite', 15, 20);

      doc.setFontSize(10);
      doc.setFont('helvetica', 'normal');
      doc.text('Room Design Proposal', 15, 28);

      // Project info
      doc.setTextColor(51, 51, 51);
      doc.setFontSize(16);
      doc.setFont('helvetica', 'bold');
      doc.text(projectName, 15, 50);

      doc.setFontSize(11);
      doc.setFont('helvetica', 'normal');
      doc.setTextColor(102, 102, 102);
      doc.text(`Room Type: ${roomType.charAt(0).toUpperCase() + roomType.slice(1)}`, 15, 58);
      doc.text(`Dimensions: ${roomWidth}'  ${roomDepth}'`, 15, 65);
      doc.text(`Date: ${new Date().toLocaleDateString()}`, 15, 72);

      // Canvas image - 2D floor plan
      const canvas2D = document.getElementById('canvas');
      const imgData2D = canvas2D.toDataURL('image/png');
      doc.text('2D Floor Plan', 15, 85);
      doc.addImage(imgData2D, 'PNG', 15, 88, 85, 65);

      // 3D view if available
      if (renderer) {
        renderer.render(scene, camera);
        const imgData3D = renderer.domElement.toDataURL('image/png');
        doc.text('3D Visualization', 110, 85);
        doc.addImage(imgData3D, 'PNG', 110, 88, 85, 65);
      }

      // Elements list
      let yPos = 165;
      doc.setFontSize(14);
      doc.setFont('helvetica', 'bold');
      doc.setTextColor(51, 51, 51);
      doc.text('Design Elements', 15, yPos);
      yPos += 8;

      doc.setFontSize(10);
      doc.setFont('helvetica', 'normal');

      // Table header
      doc.setFillColor(240, 240, 240);
      doc.rect(15, yPos, 180, 8, 'F');
      doc.setTextColor(51, 51, 51);
      doc.text('Item', 18, yPos + 5.5);
      doc.text('Type', 75, yPos + 5.5);
      doc.text('Dimensions', 120, yPos + 5.5);
      doc.text('Material', 155, yPos + 5.5);
      yPos += 10;

      elements.forEach((el, index) => {
        if (yPos > 250) {
          doc.addPage();
          yPos = 20;
        }

        const bgColor = index % 2 === 0 ? [255, 255, 255] : [248, 248, 248];
        doc.setFillColor(...bgColor);
        doc.rect(15, yPos - 4, 180, 8, 'F');

        doc.setTextColor(51, 51, 51);
        doc.text(el.label || 'Element', 18, yPos + 1);
        doc.text(el.type.replace(/-/g, ' '), 75, yPos + 1);
        doc.text(`${el.width}'  ${el.height}'`, 120, yPos + 1);
        doc.text(el.material || '-', 155, yPos + 1);
        yPos += 8;
      });

      // Quote total
      yPos += 10;
      doc.setFillColor(184, 154, 91);
      doc.rect(15, yPos, 180, 15, 'F');
      doc.setTextColor(0, 0, 0);
      doc.setFontSize(14);
      doc.setFont('helvetica', 'bold');
      doc.text('Estimated Total:', 20, yPos + 10);
      doc.text(quoteTotal, 155, yPos + 10);

      // Footer
      doc.setFontSize(8);
      doc.setTextColor(128, 128, 128);
      doc.text('This is an estimate only. Final pricing may vary based on material selection and installation requirements.', 15, 270);
      doc.text('Surprise Granite  surprisegranite.com  (623) 466-4177', 15, 276);

      doc.save(`${projectName.replace(/\s+/g, '-')}-proposal.pdf`);
    }

    function exportToJSON() {
      document.getElementById('exportMenu').classList.remove('show');

      const projectName = document.getElementById('projectName').value || 'Room Design';

      const designData = {
        version: '1.0',
        projectName: projectName,
        roomType: document.getElementById('roomType').value,
        roomWidth: roomWidth,
        roomDepth: roomDepth,
        elements: elements.map(el => ({
          id: el.id,
          type: el.type,
          label: el.label,
          x: el.x,
          y: el.y,
          width: el.width,
          height: el.height,
          rotation: el.rotation,
          color: el.color,
          material: el.material,
          materialId: el.materialId,
          category: el.category,
          catalogSku: el.catalogSku
        })),
        walls: walls,
        createdAt: new Date().toISOString()
      };

      const jsonStr = JSON.stringify(designData, null, 2);
      const blob = new Blob([jsonStr], { type: 'application/json' });
      const url = URL.createObjectURL(blob);

      const a = document.createElement('a');
      a.href = url;
      a.download = `${projectName.replace(/\s+/g, '-')}-design.json`;
      a.click();

      URL.revokeObjectURL(url);
    }

    function importFromJSON() {
      document.getElementById('exportMenu').classList.remove('show');

      const input = document.createElement('input');
      input.type = 'file';
      input.accept = '.json';

      input.onchange = (e) => {
        const file = e.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = (event) => {
          try {
            const data = JSON.parse(event.target.result);

            if (!data.version || !data.elements) {
              throw new Error('Invalid design file format');
            }

            // Restore design
            document.getElementById('projectName').value = data.projectName || 'Imported Design';
            document.getElementById('roomType').value = data.roomType || 'kitchen';
            roomWidth = data.roomWidth || 12;
            roomDepth = data.roomDepth || 10;
            document.getElementById('roomWidth').value = roomWidth;
            document.getElementById('roomDepth').value = roomDepth;

            // Restore elements
            elements = data.elements.map(el => ({
              ...el,
              textureImg: null // Will reload texture if needed
            }));

            // Restore nextGroupId from locked elements
            let maxGroupNum = 0;
            elements.forEach(el => {
              if (el.groupId) {
                const match = el.groupId.match(/group-(\d+)/);
                if (match) {
                  maxGroupNum = Math.max(maxGroupNum, parseInt(match[1]));
                }
              }
            });
            nextGroupId = maxGroupNum + 1;

            // Reload textures for elements
            elements.forEach(el => {
              if (el.materialId) {
                const category = Object.keys(MATERIALS).find(cat =>
                  MATERIALS[cat].some(m => m.id === el.materialId)
                );
                if (category) {
                  const material = MATERIALS[category].find(m => m.id === el.materialId);
                  if (material && material.url) {
                    const img = new Image();
                    img.crossOrigin = 'anonymous';
                    img.onload = () => {
                      el.textureImg = img;
                      draw();
                    };
                    img.src = material.url;
                  }
                }
              }
            });

            walls = data.walls || walls;

            selectedElement = null;
            updateProperties();
            calculateQuote();
            saveUndoState();
            draw();
            update3DScene();

            showToast('Design loaded successfully!', 'success');
          } catch (err) {
            showToast('Error loading design: ' + err.message, 'error');
          }
        };
        reader.readAsText(file);
      };

      input.click();
    }

    function exportToPNG() {
      document.getElementById('exportMenu').classList.remove('show');

      const projectName = document.getElementById('projectName').value || 'Room Design';
      const currentView = document.querySelector('.view-btn.active').id;

      let canvas;
      if (currentView === 'view3D' && renderer) {
        renderer.render(scene, camera);
        canvas = renderer.domElement;
      } else {
        canvas = document.getElementById('canvas');
      }

      const link = document.createElement('a');
      link.download = `${projectName.replace(/\s+/g, '-')}-${currentView === 'view3D' ? '3d' : '2d'}.png`;
      link.href = canvas.toDataURL('image/png');
      link.click();
    }

    function exportToCSV() {
      document.getElementById('exportMenu').classList.remove('show');

      const projectName = document.getElementById('projectName').value || 'Room Design';

      let csv = 'Item,Type,Category,Width (ft),Height (ft),Material,SKU,Notes\n';

      elements.forEach(el => {
        const row = [
          `"${el.label || 'Element'}"`,
          `"${el.type.replace(/-/g, ' ')}"`,
          `"${el.category || ''}"`,
          el.width,
          el.height,
          `"${el.material || ''}"`,
          `"${el.catalogSku || ''}"`,
          `""`
        ];
        csv += row.join(',') + '\n';
      });

      // Summary section
      csv += '\n';
      csv += 'Summary\n';
      csv += `Project,${projectName}\n`;
      csv += `Room Type,${document.getElementById('roomType').value}\n`;
      csv += `Room Dimensions,${roomWidth}' x ${roomDepth}'\n`;
      csv += `Total Elements,${elements.length}\n`;
      csv += `Estimated Total,${document.getElementById('quoteTotal').textContent}\n`;
      csv += `Generated,${new Date().toLocaleString()}\n`;

      const blob = new Blob([csv], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);

      const a = document.createElement('a');
      a.href = url;
      a.download = `${projectName.replace(/\s+/g, '-')}-parts-list.csv`;
      a.click();

      URL.revokeObjectURL(url);
    }

    // ===== MY DESIGNS MODAL =====
    let currentDesignsTab = 'my';
    let allDesigns = { my: [], shared: [], recent: [] };

    function openMyDesignsModal() {
      document.getElementById('myDesignsModal').classList.add('active');
      loadMyDesigns();
    }

    // Save current design to local storage
    function saveDesignLocally() {
      const projectName = document.getElementById('projectName').value || 'Untitled Design';
      const roomType = document.getElementById('roomType').value || 'kitchen';

      const design = {
        id: 'local-' + Date.now(),
        name: projectName,
        room_type: roomType,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString(),
        room_width: roomWidth,
        room_depth: roomDepth,
        elements: elements.map(el => serializeElement(el)),
        walls: walls.map(w => serializeWall(w)),
        rooms: rooms.map(r => ({
          ...r,
          elements: (r.elements || []).map(el =>
            el.xFt !== undefined ? { ...el, textureImg: null } : serializeElement(el)
          ),
          walls: (r.walls || []).map(w =>
            w.x1Ft !== undefined ? { ...w } : serializeWall(w)
          )
        })),
        settings: {
          pixelsPerFoot: pixelsPerFoot
        }
      };

      // Get existing designs
      let designs = [];
      try {
        designs = JSON.parse(localStorage.getItem('room_designs') || '[]');
      } catch (e) {}

      // Add new design at the beginning
      designs.unshift(design);

      // Keep only last 10 designs to avoid quota issues
      designs = designs.slice(0, 10);

      try {
        localStorage.setItem('room_designs', JSON.stringify(designs));
      } catch (quotaErr) {
        // Quota exceeded  aggressively trim and retry
        console.warn('Local save quota exceeded, trimming designs...');
        try {
          designs = designs.slice(0, 3);
          localStorage.removeItem(AUTOSAVE_KEY + '_backup');
          localStorage.setItem('room_designs', JSON.stringify(designs));
        } catch (retryErr) {
          // Last resort: clear old designs, keep only current
          try {
            localStorage.setItem('room_designs', JSON.stringify([design]));
          } catch (finalErr) {
            console.error('Cannot save locally  storage completely full');
            return design;
          }
        }
      }
      showSnapFeedback('Design saved locally');
      return design;
    }

    // NOTE: createNewDesign() is defined earlier in the file (around line 62047)
    // Do not duplicate it here

    // Save design to cloud (Supabase) or locally
    // silentMode = true means no popups/redirects (used when saving before creating new design)
    async function saveDesignToCloud(silentMode = false) {
      // Demo mode check
      if (DEMO_MODE) {
        if (showDemoUpgradeModal('save')) return;
      }

      console.log('saveDesignToCloud called, silentMode:', silentMode);
      const saveBtn = document.getElementById('saveDesignBtn');
      const saveText = document.getElementById('saveDesignText');

      // Show saving state
      if (saveBtn) saveBtn.disabled = true;
      if (saveText) saveText.textContent = 'Saving...';

      try {
        // Check if user is logged in
        const user = window.SgAuth?.getUser();
        console.log('Save - user:', user?.id);

        if (!user) {
          // Save locally if not logged in
          saveDesignLocally();
          showToast('Design saved locally. Sign in to save to cloud.', 'info');
          return;
        }

        const projectName = document.getElementById('projectName').value || 'Untitled Design';
        const roomType = document.getElementById('roomType').value || 'kitchen';

        // Save current room state
        saveCurrentRoomState();

        // Calculate quote total
        let quoteTotal = 0;
        elements.forEach(el => {
          const priceInfo = getElementPrice(el);
          const margin = getElementMargin(el) || 30;
          let cost = priceInfo?.price || 0;
          if (['countertop', 'backsplash', 'flooring', 'tile'].includes(el.type)) {
            cost = (el.width || 1) * (el.height || 1) * cost;
          }
          quoteTotal += cost * (1 + margin / 100);
        });

        // Get company name from profile
        let companyName = 'My Design';
        try {
          const profile = await window.SgAuth?.getProfile();
          if (profile?.company_name) {
            companyName = profile.company_name;
          } else if (profile?.full_name) {
            companyName = profile.full_name;
          }
        } catch (e) {
          console.log('Could not fetch profile:', e);
        }

        const designData = {
          user_id: user.id,
          name: projectName,
          room_type: roomType,
          room_width: roomWidth,
          room_depth: roomDepth,
          elements: elements.map(el => serializeElement(el)),
          settings: {
            walls: walls.map(w => serializeWall(w)),
            pricing_config: {
              globalMargin: PRICING_STATE.globalMargin,
              categoryMargins: PRICING_STATE.categoryMargins,
              customPrices: PRICING_STATE.customPrices
            },
            company_name: companyName,
            current_room_id: currentRoomId,
            pixelsPerFoot: pixelsPerFoot,
            // Multi-room support (stored in settings to avoid column mismatch)
            rooms: rooms.map(room => ({
              ...room,
              elements: (room.elements || []).map(el =>
                el.xFt !== undefined ? { ...el, textureImg: null } : serializeElement(el)
              ),
              walls: (room.walls || []).map(w =>
                w.x1Ft !== undefined ? { ...w } : serializeWall(w)
              )
            }))
          },
          quote_total: quoteTotal
        };

        const { url: SUPABASE_URL, anonKey: SUPABASE_ANON_KEY } = getSupabaseConfig();

        const session = await window.SgAuth?.getSession?.();
        const authToken = session?.access_token || SUPABASE_ANON_KEY;

        const headers = {
          'apikey': SUPABASE_ANON_KEY,
          'Authorization': `Bearer ${authToken}`,
          'Accept': 'application/json',
          'Content-Type': 'application/json',
          'Prefer': 'return=representation'
        };

        let designId = SHARE_STATE.designId;

        // If it's a local design ID, we need to create a new one in Supabase
        const isLocalDesign = designId && String(designId).startsWith('local-');
        if (isLocalDesign) {
          designId = null;
        }

        if (!designId) {
          // Create new design
          const designToken = generateToken(16);
          const insertData = {
            share_token: designToken,
            ...designData
          };

          const response = await fetch(`${SUPABASE_URL}/rest/v1/room_designs`, {
            method: 'POST',
            headers,
            body: JSON.stringify(insertData)
          });

          if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`Save failed: ${response.status} - ${errorText}`);
          }

          const data = await response.json();
          designId = Array.isArray(data) ? data[0]?.id : data.id;
          SHARE_STATE.designId = designId;
          SHARE_STATE.designToken = designToken;

          // Check for customer shares to enable messaging
          await setupDesignerCommentNotifications(designId);

          if (!silentMode) {
            showToast('Design saved to cloud!', 'success');

            // Offer to create a project from this design (only if not in silent mode)
            if (user && designId) {
              const createProj = await showConfirmDialog({
                title: 'Create Project?',
                message: 'Design saved! Would you like to create a project from this design?',
                confirmText: 'Create Project',
                cancelText: 'Not Now'
              });
              if (createProj) {
                sessionStorage.setItem('sg_design_for_project', JSON.stringify({
                  design_id: designId,
                  name: projectName || 'Room Design',
                  room_type: roomType || '',
                  quote_total: quoteTotal || 0
                }));
                window.location.href = '/account/#projects&from_design=1';
              }
            }
          }
        } else {
          // Update existing design
          const updateData = {
            ...designData,
            updated_at: new Date().toISOString()
          };

          const response = await fetch(`${SUPABASE_URL}/rest/v1/room_designs?id=eq.${designId}`, {
            method: 'PATCH',
            headers,
            body: JSON.stringify(updateData)
          });

          if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`Update failed: ${response.status} - ${errorText}`);
          }

          // Check for customer shares to enable messaging (in case it wasn't set up yet)
          await setupDesignerCommentNotifications(designId);

          showToast('Design updated!', 'success');
        }

        // Also save locally as backup
        saveDesignLocally();

      } catch (err) {
        console.error('Error saving design:', err);
        // Fall back to local save
        saveDesignLocally();
        showToast('Saved locally. Cloud sync failed: ' + err.message, 'warning');
      } finally {
        // Reset button state
        if (saveBtn) saveBtn.disabled = false;
        if (saveText) saveText.textContent = 'Save';
      }
    }

    function switchDesignsTab(tab, btn) {
      currentDesignsTab = tab;
      document.querySelectorAll('.designs-tab').forEach(t => t.classList.remove('active'));
      btn.classList.add('active');
      renderDesignsGrid();
    }

    async function loadMyDesigns() {
      const grid = document.getElementById('designsGrid');
      const empty = document.getElementById('designsEmpty');
      if (!grid) {
        console.warn('designsGrid not found');
        return;
      }
      grid.innerHTML = '<div class="designs-loading">Loading designs...</div>';
      if (empty) empty.style.display = 'none';

      try {
        const supabase = getSupabaseClient();
        let user = getCurrentUser();

        console.log('loadMyDesigns: supabase=', !!supabase, 'user=', user?.id);

        // If no user but supabase exists, wait a moment for auth to restore
        if (!user && supabase) {
          try {
            const { data: { session }, error: sessionErr } = await supabase.auth.getSession();
            if (sessionErr) {
              console.warn('Session error:', sessionErr);
            } else if (session?.user) {
              user = session.user;
              console.log('Got user from session:', user.id);
            }
          } catch (authErr) {
            console.warn('Auth check in loadMyDesigns failed:', authErr);
          }
        }

        if (!supabase || !user) {
          // Load from localStorage
          const localDesigns = JSON.parse(localStorage.getItem('room_designs') || '[]');
          allDesigns.my = localDesigns.map((d, i) => ({
            id: d.id || `local-${i}`,  // Preserve original design ID
            name: d.name || 'Untitled Design',
            room_type: d.room_type || 'kitchen',
            room_width: d.room_width || 12,
            room_depth: d.room_depth || 10,
            created_at: d.created_at || new Date().toISOString(),
            updated_at: d.updated_at || d.created_at,
            elements_count: d.elements?.length || 0,
            comments_count: 0,
            preview: d.preview || null,
            isLocal: true,
            originalIndex: i  // Keep index for fallback lookup
          }));
          allDesigns.shared = [];
          allDesigns.recent = JSON.parse(localStorage.getItem('recent_designs') || '[]');
          renderDesignsGrid();
          return;
        }

        // Load user's own designs
        const { data: myDesigns, error: myError } = await supabase
          .from('room_designs')
          .select('*')
          .eq('user_id', user.id)
          .order('updated_at', { ascending: false });

        if (myError) throw myError;

        // Load share info with customer/lead data for each design
        let designSharesMap = {};
        if (myDesigns && myDesigns.length > 0) {
          const designIds = myDesigns.map(d => d.id);
          try {
            const { data: shares } = await supabase
              .from('room_design_shares')
              .select('design_id, lead_id, customer_name, customer_email')
              .in('design_id', designIds);

            (shares || []).forEach(share => {
              if (!designSharesMap[share.design_id]) {
                designSharesMap[share.design_id] = share;
              }
            });
          } catch (e) {
            console.warn('Could not load design shares:', e);
          }
        }

        // Load designs shared with user (try multiple possible column names)
        let sharedDesigns = [];
        try {
          // Try to get shares where user is the recipient
          const { data, error } = await supabase
            .from('room_design_shares')
            .select('*, room_designs(*)')
            .order('created_at', { ascending: false })
            .limit(50);

          if (!error && data) {
            // Filter to only show designs not owned by current user
            sharedDesigns = data.filter(s => s.room_designs?.user_id !== user.id);
          }
        } catch (shareErr) {
          console.warn('Could not load shared designs:', shareErr);
        }

        // Process designs with all available data including customer info
        allDesigns.my = (myDesigns || []).map(d => {
          const shareInfo = designSharesMap[d.id];
          return {
            id: d.id,
            name: d.name || d.design_data?.name || 'Untitled Design',
            room_type: d.room_type || d.design_data?.room_type || 'kitchen',
            room_width: d.room_width || d.design_data?.room_width || 12,
            room_depth: d.room_depth || d.design_data?.room_depth || 10,
            created_at: d.created_at,
            updated_at: d.updated_at,
            elements_count: d.design_data?.elements?.length || d.elements?.length || 0,
            comments_count: d.comments_count || 0,
            preview: d.thumbnail_url || d.preview_url,
            share_token: d.share_token,
            isLocal: false,
            design_data: d.design_data,
            customer_name: shareInfo?.customer_name || shareInfo?.customer_email || null,
            lead_id: shareInfo?.lead_id || null
          };
        });

        allDesigns.shared = (sharedDesigns || []).filter(s => s.room_designs).map(s => ({
          id: s.design_id,
          name: s.room_designs?.name || 'Shared Design',
          room_type: s.room_designs?.room_type || 'kitchen',
          room_width: s.room_designs?.room_width || 12,
          room_depth: s.room_designs?.room_depth || 10,
          created_at: s.share_date || s.created_at,
          shared_by: s.shared_by_name || 'Someone',
          permission: s.permission_level,
          share_token: s.share_token,
          elements_count: s.room_designs?.design_data?.elements?.length || 0,
          comments_count: s.comments_count || 0,
          isLocal: false
        }));

        // Load recent from localStorage
        allDesigns.recent = JSON.parse(localStorage.getItem('recent_designs') || '[]');

        renderDesignsGrid();

      } catch (err) {
        console.error('Error loading designs:', err);
        // Show local designs as fallback
        const localDesigns = JSON.parse(localStorage.getItem('room_designs') || '[]');
        if (localDesigns.length > 0) {
          allDesigns.my = localDesigns.map((d, i) => ({
            id: d.id || `local-${i}`,
            name: d.name || 'Untitled Design',
            room_type: d.room_type || 'kitchen',
            room_width: d.room_width || 12,
            room_depth: d.room_depth || 10,
            created_at: d.created_at || new Date().toISOString(),
            updated_at: d.updated_at || d.created_at,
            elements_count: d.elements?.length || 0,
            comments_count: 0,
            preview: d.preview || null,
            isLocal: true,
            originalIndex: i
          }));
          renderDesignsGrid();
          showToast('Showing local designs. Cloud sync failed.', 'warning');
        } else {
          grid.innerHTML = '<div class="designs-loading">Error loading designs. Try refreshing.</div>';
        }
      }
    }

    // Debug: manually trigger My Designs - call from console: testMyDesigns()
    window.testMyDesigns = function() {
      console.log('Testing My Designs modal...');
      openMyDesignsModal();
    };

    // Debug: test save functionality - call from console: testSave()
    window.testSave = async function() {
      console.log('=== TESTING SAVE ===');
      const user = window.SgAuth?.getUser();
      console.log('User:', user);

      if (!user) {
        console.log('Not logged in - will save locally');
      }

      await saveDesignToCloud();
      console.log('Save complete. SHARE_STATE:', SHARE_STATE);
    };

    // Debug: manually add a test message - call from console: addTestMessage()
    window.addTestMessage = async function(message = 'Test message from console') {
      console.log('=== ADDING TEST MESSAGE ===');

      if (!SHARE_STATE.leadId) {
        console.log('No leadId. Looking for one...');
        // Try to find a lead from any share
        if (SHARE_STATE.designId) {
          const supabase = getSupabaseClient();
          if (supabase) {
            const { data: shares } = await supabase
              .from('room_design_shares')
              .select('lead_id')
              .eq('design_id', SHARE_STATE.designId)
              .not('lead_id', 'is', null)
              .limit(1);
            if (shares && shares[0]) {
              SHARE_STATE.leadId = shares[0].lead_id;
              console.log('Found leadId:', SHARE_STATE.leadId);
            }
          }
        }
      }

      if (!SHARE_STATE.leadId) {
        console.log('Still no leadId. Cannot add message.');
        console.log('You need to share this design with a customer first.');
        return;
      }

      const supabase = getSupabaseClient();
      if (!supabase) {
        console.log('No Supabase client');
        return;
      }

      const { data, error } = await supabase
        .from('customer_messages')
        .insert({
          customer_id: SHARE_STATE.leadId,
          message: message,
          direction: 'inbound',
          channel: 'design_share',
          metadata: {
            share_id: SHARE_STATE.shareId,
            design_id: SHARE_STATE.designId,
            author: 'Test Customer'
          }
        })
        .select()
        .single();

      if (error) {
        console.error('Error adding message:', error);
      } else {
        console.log('Message added:', data);
        // Reload messages
        await loadDesignerMessages(SHARE_STATE.leadId);
      }
    };

    // Debug: check all tables - call from console: debugTables()
    window.debugTables = async function() {
      console.log('=== DEBUG TABLES ===');
      const supabase = getSupabaseClient();
      if (!supabase) {
        console.log('No Supabase client');
        return;
      }

      const user = window.SgAuth?.getUser();
      console.log('Current user:', user?.id);

      // Check room_designs
      const { data: designs, error: designErr } = await supabase
        .from('room_designs')
        .select('id, name, share_token, created_at')
        .eq('user_id', user?.id)
        .limit(5);
      console.log('Your designs:', designs);
      if (designErr) console.error('Design error:', designErr);

      // Check room_design_shares
      if (designs && designs[0]) {
        const { data: shares, error: shareErr } = await supabase
          .from('room_design_shares')
          .select('*')
          .eq('design_id', designs[0].id);
        console.log('Shares for first design:', shares);
        if (shareErr) console.error('Share error:', shareErr);
      }

      // Check customer_messages
      const { data: messages, error: msgErr } = await supabase
        .from('customer_messages')
        .select('*')
        .eq('channel', 'design_share')
        .limit(10);
      console.log('Recent design_share messages:', messages);
      if (msgErr) console.error('Message error:', msgErr);
    };

    function renderDesignsGrid() {
      const grid = document.getElementById('designsGrid');
      const empty = document.getElementById('designsEmpty');

      const designs = allDesigns[currentDesignsTab] || [];

      if (designs.length === 0) {
        grid.innerHTML = '';
        empty.style.display = 'block';
        return;
      }

      empty.style.display = 'none';

      const formatDate = (date) => {
        const d = new Date(date);
        const now = new Date();
        const diffDays = Math.floor((now - d) / 86400000);
        if (diffDays === 0) return 'Today';
        if (diffDays === 1) return 'Yesterday';
        if (diffDays < 7) return `${diffDays} days ago`;
        return d.toLocaleDateString();
      };

      // Room type icons
      const roomTypeIcons = {
        kitchen: '<path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"/><polyline points="9 22 9 12 15 12 15 22"/>',
        bathroom: '<path d="M4 12h16M4 12v8a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-8M4 12V6a2 2 0 0 1 2-2h2"/><circle cx="8" cy="5" r="1"/>',
        laundry: '<rect x="4" y="4" width="16" height="16" rx="2"/><circle cx="12" cy="12" r="4"/><circle cx="12" cy="12" r="1"/>',
        outdoor: '<circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/>',
        default: '<rect x="3" y="3" width="18" height="18" rx="2"/><path d="M3 9h18M9 21V9"/>'
      };

      grid.innerHTML = designs.map((design, idx) => {
        const roomType = design.room_type || 'kitchen';
        const roomIcon = roomTypeIcons[roomType] || roomTypeIcons.default;
        const elemCount = design.elements_count || design.design_data?.elements?.length || 0;
        const roomW = design.room_width || design.design_data?.room_width || 12;
        const roomD = design.room_depth || design.design_data?.room_depth || 10;
        const isCloud = !design.isLocal;

        return `
        <div class="design-card" onclick="loadDesignFromList('${design.id}', '${design.share_token || ''}', ${design.isLocal || false}, ${design.originalIndex !== undefined ? design.originalIndex : idx})">
          <div class="design-card-preview">
            ${design.preview
              ? `<img src="${design.preview}" alt="${design.name}">`
              : `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                  ${roomIcon}
                </svg>`
            }
            ${currentDesignsTab === 'shared'
              ? `<span class="design-card-badge">${design.permission || 'View'}</span>`
              : design.share_token
                ? '<span class="design-card-badge shared">Shared</span>'
                : design.isLocal
                  ? '<span class="design-card-badge local">Local</span>'
                  : '<span class="design-card-badge cloud">Cloud</span>'
            }
            <button class="design-card-delete" onclick="event.stopPropagation(); deleteDesign('${design.id}', ${design.isLocal || false}, ${design.originalIndex !== undefined ? design.originalIndex : idx})" title="Delete design">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M3 6h18M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6M8 6V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/>
                <line x1="10" y1="11" x2="10" y2="17"/><line x1="14" y1="11" x2="14" y2="17"/>
              </svg>
            </button>
          </div>
          <div class="design-card-info">
            <div class="design-card-name" title="${design.name || 'Untitled'}">${design.name || 'Untitled Design'}</div>
            ${design.customer_name ? `
              <div class="design-card-customer">
                <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"/><circle cx="12" cy="7" r="4"/>
                </svg>
                ${design.customer_name}
              </div>
            ` : ''}
            <div class="design-card-details">
              <span class="design-card-room-type" title="${roomType}">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">${roomIcon}</svg>
                ${roomType.charAt(0).toUpperCase() + roomType.slice(1)}
              </span>
              <span class="design-card-dims">${roomW}'${roomD}'</span>
              ${elemCount > 0 ? `<span class="design-card-elements">${elemCount} items</span>` : ''}
            </div>
            <div class="design-card-meta">
              <span class="design-card-date">
                <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <circle cx="12" cy="12" r="10"/><path d="M12 6v6l4 2"/>
                </svg>
                ${formatDate(design.created_at || design.updated_at)}
              </span>
              ${design.comments_count > 0 ? `
                <span class="design-card-comments">
                  <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"/>
                  </svg>
                  ${design.comments_count}
                </span>
              ` : ''}
            </div>
          </div>
        </div>
      `}).join('');
    }

    // Delete a design from local storage or cloud
    async function deleteDesign(designId, isLocal, originalIndex) {
      const design = (allDesigns[currentDesignsTab] || []).find(d => d.id === designId);
      const designName = design?.name || 'this design';

      const confirmed = await showConfirmDialog({
        title: 'Delete Design?',
        message: `Are you sure you want to delete "${designName}"?\n\nThis action cannot be undone.`,
        confirmText: 'Delete Design',
        cancelText: 'Keep Design',
        dangerous: true
      });
      if (!confirmed) return;

      try {
        if (isLocal) {
          // Delete from localStorage (key is 'room_designs')
          const localDesigns = JSON.parse(localStorage.getItem('room_designs') || '[]');
          const updatedDesigns = localDesigns.filter((d, idx) => {
            // Match by index if originalIndex provided, otherwise by id
            if (originalIndex !== undefined) {
              return idx !== originalIndex;
            }
            return d.id !== designId;
          });
          localStorage.setItem('room_designs', JSON.stringify(updatedDesigns));
          showToast('Design deleted', 'success');
        } else {
          // Delete from Supabase
          const supabase = getSupabaseClient();
          if (!supabase) {
            showToast('Cannot connect to cloud', 'error');
            return;
          }

          const { error } = await supabase
            .from('room_designs')
            .delete()
            .eq('id', designId);

          if (error) {
            console.error('Delete error:', error);
            showToast('Failed to delete design: ' + error.message, 'error');
            return;
          }

          showToast('Design deleted from cloud', 'success');
        }

        // Refresh the designs list
        await loadMyDesigns();
      } catch (err) {
        console.error('Delete design error:', err);
        showToast('Failed to delete design', 'error');
      }
    }

    function filterDesigns(query) {
      const designs = allDesigns[currentDesignsTab] || [];
      const filtered = designs.filter(d =>
        d.name.toLowerCase().includes(query.toLowerCase())
      );

      const grid = document.getElementById('designsGrid');
      const empty = document.getElementById('designsEmpty');

      if (filtered.length === 0 && query) {
        grid.innerHTML = '';
        empty.style.display = 'block';
        return;
      }

      // Temporarily override for rendering
      const original = allDesigns[currentDesignsTab];
      allDesigns[currentDesignsTab] = filtered;
      renderDesignsGrid();
      allDesigns[currentDesignsTab] = original;
    }

    // ===== HISTORY STATE MANAGEMENT =====
    // Stores the previous design state when navigating between designs
    let previousDesignState = null;

    function saveCurrentDesignToHistory() {
      // Save current design state so we can restore it on back navigation
      previousDesignState = {
        elements: JSON.parse(JSON.stringify(elements)),
        walls: JSON.parse(JSON.stringify(walls)),
        roomWidth: roomWidth,
        roomDepth: roomDepth,
        projectName: document.getElementById('projectName').value,
        roomType: document.getElementById('roomType').value,
        designId: SHARE_STATE.designId
      };
      // Store in sessionStorage for persistence across page reloads
      sessionStorage.setItem('sg_previous_design', JSON.stringify(previousDesignState));
    }

    function restorePreviousDesign() {
      // Try to get from memory first, then sessionStorage
      let state = previousDesignState;
      if (!state) {
        const stored = sessionStorage.getItem('sg_previous_design');
        if (stored) {
          state = JSON.parse(stored);
        }
      }

      if (state) {
        elements = state.elements || [];
        walls = state.walls || [];
        roomWidth = state.roomWidth || 12;
        roomDepth = state.roomDepth || 14;
        document.getElementById('projectName').value = state.projectName || 'New Design';
        document.getElementById('roomType').value = state.roomType || 'kitchen';
        document.getElementById('roomWidth').value = roomWidth;
        document.getElementById('roomDepth').value = roomDepth;
        SHARE_STATE.designId = state.designId;

        // Reload textures
        elements.forEach(el => {
          if (el.texture) {
            const img = new Image();
            img.crossOrigin = 'anonymous';
            img.onload = () => {
              el.textureImg = img;
              draw();
            };
            img.src = el.texture;
          }
        });

        calculateQuote();
        draw();
        update3DScene();
        showSnapFeedback('Returned to previous design');
        return true;
      }
      return false;
    }

    // Handle browser back/forward navigation
    window.addEventListener('popstate', function(event) {
      console.log('Popstate event:', event.state);

      // Check if we have a previous design to restore
      if (event.state === null || !event.state.shareToken) {
        // Going back to the main page (no share token)
        if (restorePreviousDesign()) {
          // Clear the URL if it has a share token
          if (window.location.search.includes('share=')) {
            history.replaceState({}, '', window.location.pathname);
          }
        }
      } else if (event.state.shareToken) {
        // Navigating to a shared design
        loadSharedDesign(event.state.shareToken);
      } else if (event.state.designId && event.state.isLocal) {
        // Navigating to a local design
        const localDesigns = JSON.parse(localStorage.getItem('room_designs') || '[]');
        const design = localDesigns.find(d => d.id === event.state.designId);
        if (design) {
          loadLocalDesign(design);
        }
      }
    });

    // Seamlessly load a design directly into the workspace canvas (no page reload)
    function loadDesignToWorkspace(design, options = {}) {
      const { showPreloaderUI = false, updateURL = true, isShared = false } = options;

      try {
        // Set share state
        SHARE_STATE.isSharedView = isShared;
        SHARE_STATE.designId = design.id;
        SHARE_STATE.designToken = design.share_token;

        // Extract design data
        const designElements = design.elements || [];
        const designWalls = design.settings?.walls || design.walls || [];

        // Load directly into workspace
        elements = designElements.map(el => ({
          ...el,
          id: el.id || Date.now() + Math.random(),
          color: el.color || getDefaultColor(el.type),
          category: getElementCategory(el.type)
        }));
        walls = designWalls;

        // Load room dimensions
        roomWidth = design.room_width || design.settings?.room_width || 12;
        roomDepth = design.room_depth || design.settings?.room_depth || 10;

        // Update UI inputs
        const widthInput = document.getElementById('roomWidth');
        const depthInput = document.getElementById('roomDepth');
        const typeInput = document.getElementById('roomType');
        const nameInput = document.getElementById('projectName');

        if (widthInput) widthInput.value = roomWidth;
        if (depthInput) depthInput.value = roomDepth;
        if (typeInput) typeInput.value = design.room_type || design.settings?.room_type || 'kitchen';
        if (nameInput) nameInput.value = design.name || 'Untitled';

        // Fit to screen and redraw
        fitToScreen();
        saveUndoState();
        draw();

        // Update 3D view if active
        if (currentView === '3d') {
          init3D();
          render3D();
        }

        // Update URL without reload
        if (updateURL && design.share_token) {
          const newUrl = `${window.location.pathname}?share=${design.share_token}`;
          history.pushState({ shareToken: design.share_token }, '', newUrl);
        } else if (updateURL) {
          history.pushState({ designId: design.id }, '', window.location.pathname);
        }

        console.log('Design loaded seamlessly:', design.name, 'with', elements.length, 'elements');
        return true;
      } catch (err) {
        console.error('Error loading design to workspace:', err);
        return false;
      }
    }

    // Return to user's own workspace (from viewing a shared design)
    function returnToMyWorkspace() {
      // Try to restore from protected auto-save first
      const protectedSave = localStorage.getItem(AUTOSAVE_KEY + '_protected');
      const regularSave = localStorage.getItem(AUTOSAVE_KEY);

      let savedDesign = null;
      if (protectedSave) {
        try {
          savedDesign = JSON.parse(protectedSave);
          console.log('Restoring from protected save:', savedDesign.elements?.length, 'elements');
        } catch (e) { /* ignore */ }
      }

      if (!savedDesign && regularSave) {
        try {
          savedDesign = JSON.parse(regularSave);
          console.log('Restoring from regular save:', savedDesign.elements?.length, 'elements');
        } catch (e) { /* ignore */ }
      }

      if (savedDesign && savedDesign.elements) {
        // Clear share state
        SHARE_STATE.isSharedView = false;
        SHARE_STATE.designId = null;
        SHARE_STATE.designToken = null;

        // Load the design seamlessly
        loadDesignToWorkspace(savedDesign, { showPreloaderUI: false, updateURL: true });

        // Clear URL parameters
        history.pushState({}, '', window.location.pathname);

        showToast('Returned to your workspace', 'success');
      } else {
        // Start fresh workspace
        elements.length = 0;
        walls.length = 0;
        roomWidth = 12;
        roomDepth = 10;

        SHARE_STATE.isSharedView = false;
        SHARE_STATE.designId = null;
        SHARE_STATE.designToken = null;

        // Clear URL parameters
        history.pushState({}, '', window.location.pathname);

        fitToScreen();
        draw();
        showToast('Started new workspace', 'info');
      }
    }

    // Quick switch between designs without page reload
    async function quickSwitchDesign(designId, isShared = false) {
      try {
        const supabase = getSupabaseClient();
        if (!supabase) {
          showToast('Cannot load design - offline', 'error');
          return;
        }

        const { data, error } = await supabase
          .from('room_designs')
          .select('*')
          .eq('id', designId)
          .single();

        if (error) throw error;

        if (data) {
          const designObj = data.design_data || {
            id: data.id,
            name: data.name || 'Untitled',
            room_type: data.room_type || 'kitchen',
            room_width: data.room_width || 12,
            room_depth: data.room_depth || 10,
            elements: data.elements || [],
            walls: data.settings?.walls || data.walls || [],
            settings: data.settings || {},
            share_token: data.share_token
          };

          // Merge ID and token if using design_data
          if (data.design_data) {
            designObj.id = data.id;
            designObj.share_token = data.share_token;
            designObj.name = data.name;
          }

          loadDesignToWorkspace(designObj, { showPreloaderUI: false, updateURL: true, isShared });
          showToast(`Loaded: ${data.name || 'Design'}`, 'success');
        }
      } catch (err) {
        console.error('Quick switch error:', err);
        showToast('Error loading design', 'error');
      }
    }

    async function loadDesignFromList(id, shareToken, isLocal, originalIndex) {
      console.log('loadDesignFromList called:', { id, shareToken, isLocal, originalIndex });
      closeModal('myDesignsModal');

      if (isLocal) {
        try {
          const localDesigns = JSON.parse(localStorage.getItem('room_designs') || '[]');
          console.log('Local designs found:', localDesigns.length);

          // Find design by ID first, then by index as fallback
          let design = localDesigns.find(d => d.id === id);
          if (!design && originalIndex !== undefined && localDesigns[originalIndex]) {
            design = localDesigns[originalIndex];
            console.log('Found design by index:', originalIndex);
          }

          if (design) {
            console.log('Loading local design:', design.name, 'with', design.elements?.length, 'elements');
            // Save current state to history before loading new design
            saveCurrentDesignToHistory();
            // Load seamlessly without preloader
            if (loadDesignToWorkspace(design, { showPreloaderUI: false, updateURL: true })) {
              showToast(`Loaded: ${design.name || 'Untitled Design'}`, 'success');
            } else {
              loadLocalDesign(design); // Fallback to original method
              showToast(`Loaded: ${design.name || 'Untitled Design'}`, 'success');
            }
          } else {
            console.error('Design not found in localStorage. ID:', id, 'Index:', originalIndex);
            showToast('Design not found in local storage', 'error');
          }
        } catch (err) {
          console.error('Error loading local design:', err);
          showToast('Error loading local design: ' + err.message, 'error');
        }
        return;
      }

      // Designer loading their own design from cloud
      try {
        const supabase = getSupabaseClient();
        if (!supabase) {
          showToast('Cannot connect to cloud. Try again later.', 'error');
          return;
        }

        console.log('Fetching design from cloud:', id);
        const { data, error } = await supabase
          .from('room_designs')
          .select('*')
          .eq('id', id)
          .single();

        if (error) {
          console.error('Supabase error:', error);
          throw error;
        }

        console.log('Cloud design data:', data);
        console.log('Record fields:', Object.keys(data || {}));

        // Check if we have design data - it might be in design_data field OR directly on the record
        // Note: elements might be an empty array, so check for existence not truthiness
        const hasDesignData = data?.design_data ||
                              data?.elements !== undefined ||
                              data?.room_width !== undefined;

        if (data && hasDesignData) {
          // Designer loading their own design - NOT a shared view
          // Save current state before loading
          saveCurrentDesignToHistory();

          // Build design object from record
          const designObj = data.design_data
            ? { ...data.design_data, id: data.id, share_token: data.share_token, name: data.name }
            : {
                id: data.id,
                name: data.name || 'Untitled',
                room_type: data.room_type || 'kitchen',
                room_width: data.room_width || 12,
                room_depth: data.room_depth || 10,
                elements: data.elements || [],
                walls: data.settings?.walls || data.walls || [],
                rooms: data.rooms || [],
                settings: data.settings || { pixelsPerFoot: 40 },
                share_token: data.share_token
              };

          console.log('Built design object from record:', {
            name: designObj.name,
            room_width: designObj.room_width,
            room_depth: designObj.room_depth,
            elements_count: (designObj.elements || []).length
          });

          // Try seamless loading first, fallback to full loadDesignData if needed
          if (loadDesignToWorkspace(designObj, { showPreloaderUI: false, updateURL: true, isShared: false })) {
            showToast(`Loaded: ${data.name || 'Design'}`, 'success');
          } else {
            loadDesignData(designObj);
          }

          // Set up realtime sync for this design
          subscribeToDesignUpdates(id);

          // Check for any shares with leads and subscribe to comment notifications
          setupDesignerCommentNotifications(id);

          showToast(`Loaded: ${data.name || 'Design'}`, 'success');
        } else {
          console.error('No design data found in record:', data);
          console.log('Record keys:', Object.keys(data || {}));
          showToast('Design data is empty or corrupted', 'error');
        }
      } catch (err) {
        console.error('Error loading cloud design:', err);
        showToast('Error loading design: ' + (err.message || 'Unknown error'), 'error');
      }
    }

    // Set up comment notifications for designers when they load their own design
    async function setupDesignerCommentNotifications(designId) {
      if (!designId) return;
      console.log('=== setupDesignerCommentNotifications START ===', designId);

      try {
        const supabase = getSupabaseClient();
        if (!supabase) return;

        // Find ANY share for this design (not just ones with lead_id)
        let shares, error;
        try {
          const result = await supabase
            .from('room_design_shares')
            .select('id, lead_id, customer_name, comments')
            .eq('design_id', designId)
            .order('created_at', { ascending: false })
            .limit(1);
          shares = result.data;
          error = result.error;
          console.log('Share query result:', shares, 'Error:', error);
        } catch (queryErr) {
          // Table may not exist yet  non-critical feature
          console.log('room_design_shares query failed (table may not exist):', queryErr.message);
          return;
        }

        if (error || !shares || shares.length === 0) {
          console.log('No shares found for this design');
          return;
        }

        const share = shares[0];
        SHARE_STATE.leadId = share.lead_id;
        SHARE_STATE.customerName = share.customer_name || null;
        SHARE_STATE.shareId = share.id;
        SHARE_STATE.comments = share.comments || [];

        console.log('Share loaded - ID:', share.id, 'Comments:', SHARE_STATE.comments?.length || 0);

        // Fetch customer name if we have a lead
        if (share.lead_id && !SHARE_STATE.customerName) {
          await fetchCustomerName(share.lead_id);
        }

        // Subscribe to realtime comment notifications on the share
        subscribeToShareComments();

        // If we have a lead, also subscribe to customer_messages
        if (share.lead_id) {
          subscribeToCustomerComments(share.lead_id);
        }

        // Load messages into the unified panel
        await loadUnifiedMessages();

        console.log('Designer comment notifications set up. ShareId:', SHARE_STATE.shareId);
      } catch (err) {
        console.warn('Could not set up comment notifications:', err);
      }
    }

    // Toggle any panel section collapse/expand
    function togglePanelSection(sectionId) {
      const section = document.getElementById(sectionId);
      if (section) {
        const wasCollapsed = section.classList.contains('collapsed');
        section.classList.toggle('collapsed');

        // Clear team chat unread and refresh messages when expanded
        if (sectionId === 'teamChatSection' && wasCollapsed) {
          onTeamChatSectionExpanded();
          // Auto-refresh messages when panel is opened
          refreshMessages();
        }
      }
    }

    // Toggle messages panel collapse/expand
    function toggleMessagesPanel() {
      const content = document.getElementById('messagesContent');
      if (content) {
        if (content.style.display === 'none') {
          content.style.display = 'block';
        } else {
          content.style.display = 'none';
        }
      }
    }

    // Show the designer messages panel with customer linked
    function showDesignerMessagesPanel() {
      const content = document.getElementById('messagesContent');
      const inputArea = document.getElementById('messageInputArea');
      const noCustomerMsg = document.getElementById('noCustomerMessage');
      const section = document.getElementById('messagesSection');

      // Make sure panel is expanded when customer is linked
      if (content) {
        content.style.display = 'block';
      }
      if (section) {
        section.style.display = 'block';
      }

      // Show the reply input and hide the "no customer" message
      if (inputArea) {
        inputArea.style.display = 'flex';
      }
      if (noCustomerMsg) {
        noCustomerMsg.style.display = 'none';
      }

      // Update panel header to show customer name if available
      const panelTitle = document.querySelector('#messagesSection .panel-title span:first-child');
      if (panelTitle && SHARE_STATE.customerName) {
        panelTitle.textContent = ` ${SHARE_STATE.customerName}`;
      }
    }

    // Load messages for designer view
    async function loadDesignerMessages(leadId) {
      console.log('loadDesignerMessages called with leadId:', leadId);
      if (!leadId) {
        console.log('No leadId provided');
        return;
      }

      const container = document.getElementById('customerMessagesList');
      if (!container) {
        console.log('customerMessagesList container not found');
        return;
      }

      try {
        const supabase = getSupabaseClient();
        if (!supabase) {
          console.log('No Supabase client');
          return;
        }

        console.log('Querying customer_messages for customer_id:', leadId);
        const { data: messages, error } = await supabase
          .from('customer_messages')
          .select('*')
          .eq('customer_id', leadId)
          .eq('channel', 'design_share')
          .order('created_at', { ascending: true });

        console.log('Messages query result:', { messages, error });

        if (error) {
          console.warn('Error loading messages:', error);
          return;
        }

        if (!messages || messages.length === 0) {
          container.innerHTML = '<div class="no-messages">No messages yet.<br><span style="font-size: 10px; color: var(--text-muted);">Customer comments will appear here</span></div>';
          updateMessageBadge(0);
          return;
        }

        // Hide the "no customer" message since we have messages
        const noCustomerMsg = document.getElementById('noCustomerMessage');
        if (noCustomerMsg) noCustomerMsg.style.display = 'none';

        // Render messages
        container.innerHTML = messages.map(msg => `
          <div class="customer-message ${msg.direction}">
            <div class="customer-message-header">
              <span class="customer-message-author">${msg.direction === 'inbound' ? (SHARE_STATE.customerName || 'Customer') : 'You'}</span>
              <span class="customer-message-time">${formatMessageTime(msg.created_at)}</span>
            </div>
            <div class="customer-message-text">${escapeHtml(msg.message)}</div>
          </div>
        `).join('');

        // Scroll to bottom
        container.scrollTop = container.scrollHeight;

        // Update badge with unread count (inbound messages)
        const unreadCount = messages.filter(m => m.direction === 'inbound' && !m.read_at).length;
        updateMessageBadge(unreadCount);

      } catch (err) {
        console.warn('Error loading designer messages:', err);
      }
    }

    function formatMessageTime(timestamp) {
      const date = new Date(timestamp);
      const now = new Date();
      const diffMs = now - date;
      const diffMins = Math.floor(diffMs / 60000);
      const diffHours = Math.floor(diffMs / 3600000);
      const diffDays = Math.floor(diffMs / 86400000);

      if (diffMins < 1) return 'Just now';
      if (diffMins < 60) return `${diffMins}m ago`;
      if (diffHours < 24) return `${diffHours}h ago`;
      if (diffDays < 7) return `${diffDays}d ago`;
      return date.toLocaleDateString();
    }

    // Note: escapeHtml is defined earlier (around line 49675)

    // Debug function - call from console: debugMessages()
    window.debugMessages = async function() {
      console.log('=== MESSAGE DEBUG ===');
      console.log('SHARE_STATE:', SHARE_STATE);
      console.log('leadId:', SHARE_STATE.leadId);
      console.log('designId:', SHARE_STATE.designId);

      const supabase = getSupabaseClient();
      if (!supabase) {
        console.log('No Supabase client');
        return;
      }

      // Check shares for this design
      if (SHARE_STATE.designId) {
        console.log('--- Checking shares for design ---');
        const { data: shares, error: shareErr } = await supabase
          .from('room_design_shares')
          .select('*')
          .eq('design_id', SHARE_STATE.designId);
        console.log('Shares for this design:', shares);
        console.log('Share error:', shareErr);

        // If we found a share with lead_id, use it
        if (shares && shares.length > 0) {
          const shareWithLead = shares.find(s => s.lead_id);
          if (shareWithLead) {
            console.log('Found share with lead_id:', shareWithLead.lead_id);
            SHARE_STATE.leadId = shareWithLead.lead_id;
            SHARE_STATE.shareId = shareWithLead.id;
          }
        }
      }

      if (SHARE_STATE.leadId) {
        console.log('--- Checking messages for lead ---');
        const { data, error } = await supabase
          .from('customer_messages')
          .select('*')
          .eq('customer_id', SHARE_STATE.leadId);
        console.log('All messages for this customer:', data);
        console.log('Error:', error);

        // Try loading with the function
        await loadDesignerMessages(SHARE_STATE.leadId);
      } else {
        console.log('No leadId found in any shares for this design.');
        console.log('To link a customer: share the design with a customer from the Connections page.');
      }
    };

    // Force refresh messages - call from console: refreshMessages()
    window.refreshMessages = function() {
      if (SHARE_STATE.leadId) {
        loadDesignerMessages(SHARE_STATE.leadId);
      } else {
        console.log('No leadId - load a shared design first');
      }
    };

    function updateMessageBadge(count) {
      const badge = document.getElementById('messageBadge');
      if (badge) {
        badge.textContent = count;
        if (count > 0) {
          badge.classList.add('has-messages');
        } else {
          badge.classList.remove('has-messages');
        }
      }
    }

    // Send designer reply
    async function sendDesignerReply() {
      // Only designers (non-shared view) can send replies
      if (SHARE_STATE.isSharedView) {
        showToast('Only designers can send replies', 'error');
        return;
      }

      // Verify user is authenticated
      const user = window.SgAuth?.getUser();
      if (!user) {
        showToast('Please log in to send messages', 'error');
        return;
      }

      const input = document.getElementById('designerReplyInput');
      const message = input?.value?.trim();
      if (!message || !SHARE_STATE.leadId) return;

      try {
        const supabase = getSupabaseClient();
        if (!supabase) {
          showToast('Unable to send message', 'error');
          return;
        }

        const { error } = await supabase
          .from('customer_messages')
          .insert({
            customer_id: SHARE_STATE.leadId,
            message: message,
            direction: 'outbound',
            channel: 'design_share',
            metadata: {
              share_id: SHARE_STATE.shareId,
              design_id: SHARE_STATE.designId,
              author: 'Designer'
            }
          });

        if (error) {
          console.error('Error sending reply:', error);
          showToast('Failed to send message', 'error');
          return;
        }

        // Clear input and reload messages
        input.value = '';
        showToast('Message sent', 'success');
        await loadDesignerMessages(SHARE_STATE.leadId);

      } catch (err) {
        console.error('Error sending designer reply:', err);
        showToast('Failed to send message', 'error');
      }
    }

    // ============================================================
    // DESIGN NOTIFICATIONS - Comments from all shared designs
    // ============================================================

    // ========================================
    // GAMING-STYLE NOTIFICATION HUB
    // Unified notification center like game HUDs
    // ========================================

    const NOTIFICATION_HUB = {
      notifications: [],
      filter: 'all',  // 'all', 'chat', 'team'
      isOpen: false,
      subscription: null,
      designMap: {},
      teamSubscription: null
    };

    // Toggle notification hub dropdown
    function toggleNotificationHub() {
      const dropdown = document.getElementById('notificationDropdown');
      const btn = document.getElementById('notifHubBtn');
      NOTIFICATION_HUB.isOpen = !NOTIFICATION_HUB.isOpen;

      if (NOTIFICATION_HUB.isOpen) {
        dropdown.classList.add('show');
        btn.style.background = 'var(--dark-hover)';
      } else {
        dropdown.classList.remove('show');
        btn.style.background = '';
      }
    }

    // Close hub when clicking outside
    document.addEventListener('click', (e) => {
      const hub = document.getElementById('notificationHub');
      if (hub && !hub.contains(e.target) && NOTIFICATION_HUB.isOpen) {
        toggleNotificationHub();
      }
    });

    // Filter notifications by type
    function filterNotifications(filter) {
      NOTIFICATION_HUB.filter = filter;

      // Update active tab
      document.querySelectorAll('.notification-tab').forEach(tab => {
        tab.classList.toggle('active', tab.dataset.filter === filter);
      });

      renderNotificationHub();
    }

    // Initialize notification hub
    async function initNotificationHub() {
      const supabase = getSupabaseClient();
      const user = window.SgAuth?.getUser();
      if (!supabase || !user) return;

      console.log('=== initNotificationHub START ===');

      try {
        // Get all designs owned by this user
        const { data: userDesigns } = await supabase
          .from('room_designs')
          .select('id, name, share_token')
          .eq('user_id', user.id);

        console.log('User designs:', userDesigns?.length || 0);

        if (userDesigns?.length) {
          userDesigns.forEach(d => { NOTIFICATION_HUB.designMap[d.id] = d; });
          const designIds = userDesigns.map(d => d.id);

          // Load client messages from customer_messages
          const { data: clientMessages } = await supabase
            .from('customer_messages')
            .select('*')
            .eq('channel', 'design_share')
            .eq('direction', 'inbound')
            .order('created_at', { ascending: false })
            .limit(20);

          if (clientMessages) {
            // Get list of cleared/dismissed notification IDs from localStorage
            const clearedNotifications = JSON.parse(localStorage.getItem('clearedNotificationIds') || '[]');

            const filtered = clientMessages.filter(m => {
              const designId = m.metadata?.design_id;
              // Skip if this notification was cleared/dismissed by user
              if (clearedNotifications.includes(m.id)) return false;
              return designId && designIds.includes(designId);
            });

            filtered.forEach(m => {
              const design = NOTIFICATION_HUB.designMap[m.metadata?.design_id];
              NOTIFICATION_HUB.notifications.push({
                id: m.id,
                type: 'chat',
                source: design?.name || 'Untitled Design',
                message: m.message,
                author: m.metadata?.author || 'Customer',
                time: m.created_at,
                read: m.read_at != null,
                designId: m.metadata?.design_id,
                shareToken: design?.share_token
              });
            });
          }

          // ALSO load comments from room_design_shares.comments JSONB
          const { data: shares } = await supabase
            .from('room_design_shares')
            .select('id, design_id, share_token, comments')
            .in('design_id', designIds);

          console.log('Shares with comments:', shares?.length || 0);

          if (shares) {
            // Get list of cleared/read share comment IDs from localStorage
            const clearedShareComments = JSON.parse(localStorage.getItem('clearedShareComments') || '[]');

            shares.forEach(share => {
              const design = NOTIFICATION_HUB.designMap[share.design_id];
              const comments = share.comments || [];

              comments.forEach((c, idx) => {
                // Skip outbound (designer) messages
                if (c.direction === 'outbound') return;

                const commentId = `share-comment-${share.id}-${idx}`;

                // Check for duplicates
                const isDupe = NOTIFICATION_HUB.notifications.some(n =>
                  n.message === c.text && n.time === c.timestamp
                );
                if (isDupe) return;

                // Check if this comment was previously cleared/read
                const wasCleared = clearedShareComments.includes(commentId);

                NOTIFICATION_HUB.notifications.push({
                  id: commentId,
                  type: 'chat',
                  source: design?.name || 'Untitled Design',
                  message: c.text,
                  author: c.author || 'Customer',
                  time: c.timestamp,
                  read: wasCleared,  // Respect cleared status from localStorage
                  designId: share.design_id,
                  shareToken: design?.share_token || share.share_token,
                  shareId: share.id
                });
              });
            });
          }

          // Subscribe to real-time client messages
          subscribeToClientMessages(designIds);

          // Subscribe to real-time share comment updates for ALL user's designs
          subscribeToAllShareComments(designIds);
        }

        // Load team chat messages
        await loadTeamChatNotifications();
        subscribeToTeamChat();

        // Sort notifications by time (newest first)
        NOTIFICATION_HUB.notifications.sort((a, b) => new Date(b.time) - new Date(a.time));

        renderNotificationHub();
        updateHubBadge();

        console.log('Notification hub initialized with', NOTIFICATION_HUB.notifications.length, 'notifications');

      } catch (err) {
        console.log('Notification hub init:', err.message);
      }
    }

    // Subscribe to share comments for ALL of user's designs (global notifications)
    function subscribeToAllShareComments(designIds) {
      const supabase = getSupabaseClient();
      if (!supabase || !designIds?.length) return;

      console.log('Subscribing to share comments for', designIds.length, 'designs');

      // Subscribe to changes on room_design_shares for any of the user's designs
      const channel = supabase
        .channel('global-share-comments')
        .on('postgres_changes', {
          event: 'UPDATE',
          schema: 'public',
          table: 'room_design_shares'
        }, (payload) => {
          // Check if this share belongs to one of the user's designs
          if (!designIds.includes(payload.new.design_id)) return;

          console.log('=== GLOBAL SHARE UPDATE ===', payload.new.design_id);

          const design = NOTIFICATION_HUB.designMap[payload.new.design_id];
          const newComments = payload.new.comments || [];

          // Find new comments that aren't already in notifications
          // Also check cleared localStorage to avoid re-adding cleared notifications
          const clearedShareComments = JSON.parse(localStorage.getItem('clearedShareComments') || '[]');

          newComments.forEach((c, idx) => {
            if (c.direction === 'outbound') return;

            // Check if this comment was previously cleared
            const commentIdBase = `share-comment-${payload.new.id}-${idx}`;
            const wasCleared = clearedShareComments.some(id => id.startsWith(commentIdBase));
            if (wasCleared) {
              console.log('Skipping cleared notification:', commentIdBase);
              return;
            }

            const isDupe = NOTIFICATION_HUB.notifications.some(n =>
              n.message === c.text && n.time === c.timestamp
            );

            if (!isDupe) {
              const notification = {
                id: `share-comment-${payload.new.id}-${idx}-${Date.now()}`,
                type: 'chat',
                source: design?.name || 'Untitled Design',
                message: c.text,
                author: c.author || 'Customer',
                time: c.timestamp,
                read: false,
                designId: payload.new.design_id,
                shareToken: design?.share_token || payload.new.share_token,
                shareId: payload.new.id
              };

              // Add to beginning of notifications
              NOTIFICATION_HUB.notifications.unshift(notification);

              // Show toast notification
              showToast(` New comment on "${design?.name || 'Design'}": ${c.text.substring(0, 30)}...`, 'info');

              // Update the hub
              renderNotificationHub();
              updateHubBadge();

              // Flash the notification button
              const btn = document.getElementById('notifHubBtn');
              if (btn) {
                btn.classList.add('has-notifications');
                btn.style.animation = 'pulse 0.5s ease-in-out 3';
                setTimeout(() => btn.style.animation = '', 1500);
              }
            }
          });
        })
        .subscribe((status) => {
          console.log('Global share comments subscription:', status);
        });
    }

    // Load team chat notifications
    async function loadTeamChatNotifications() {
      const supabase = getSupabaseClient();
      if (!supabase || !currentDesignId) return;

      try {
        const { data: teamMessages } = await supabase
          .from('design_chat_messages')
          .select('*')
          .eq('design_id', currentDesignId)
          .order('created_at', { ascending: false })
          .limit(10);

        if (teamMessages) {
          teamMessages.forEach(m => {
            // Don't add own messages as notifications
            const user = window.SgAuth?.getUser();
            if (m.user_id === user?.id) return;

            NOTIFICATION_HUB.notifications.push({
              id: m.id,
              type: 'team',
              source: m.user_name || 'Team Member',
              message: m.message,
              author: m.user_name,
              time: m.created_at,
              read: true,  // Team messages already seen
              designId: m.design_id
            });
          });
        }
      } catch (err) {
        console.log('Team chat load:', err.message);
      }
    }

    // Subscribe to client messages
    function subscribeToClientMessages(designIds) {
      const supabase = getSupabaseClient();
      if (!supabase || !designIds?.length) return;

      if (NOTIFICATION_HUB.subscription) {
        supabase.removeChannel(NOTIFICATION_HUB.subscription);
      }

      const channel = supabase
        .channel('hub-client-messages')
        .on('postgres_changes', {
          event: 'INSERT',
          schema: 'public',
          table: 'customer_messages',
          filter: `channel=eq.design_share`
        }, (payload) => {
          const designId = payload.new.metadata?.design_id;
          if (designId && designIds.includes(designId) && payload.new.direction === 'inbound') {
            // Check if this notification was previously cleared
            const clearedNotifications = JSON.parse(localStorage.getItem('clearedNotificationIds') || '[]');
            if (clearedNotifications.includes(payload.new.id)) {
              console.log('Skipping cleared notification:', payload.new.id);
              return;
            }

            const design = NOTIFICATION_HUB.designMap[designId];
            const notif = {
              id: payload.new.id,
              type: 'chat',
              source: design?.name || 'Untitled Design',
              message: payload.new.message,
              author: payload.new.metadata?.author || 'Customer',
              time: payload.new.created_at,
              read: false,
              designId: designId,
              shareToken: design?.share_token
            };
            NOTIFICATION_HUB.notifications.unshift(notif);
            renderNotificationHub();
            updateHubBadge();
            showNotificationToast(notif);
            playNotificationSound();
          }
        })
        .subscribe();

      NOTIFICATION_HUB.subscription = channel;
    }

    // Subscribe to team chat
    function subscribeToTeamChat() {
      const supabase = getSupabaseClient();
      if (!supabase || !currentDesignId) return;

      if (NOTIFICATION_HUB.teamSubscription) {
        supabase.removeChannel(NOTIFICATION_HUB.teamSubscription);
      }

      const channel = supabase
        .channel('hub-team-chat')
        .on('postgres_changes', {
          event: 'INSERT',
          schema: 'public',
          table: 'design_chat_messages',
          filter: `design_id=eq.${currentDesignId}`
        }, (payload) => {
          const user = window.SgAuth?.getUser();
          if (payload.new.user_id === user?.id) return;

          const notif = {
            id: payload.new.id,
            type: 'team',
            source: payload.new.user_name || 'Team Member',
            message: payload.new.message,
            author: payload.new.user_name,
            time: payload.new.created_at,
            read: false,
            designId: payload.new.design_id
          };
          NOTIFICATION_HUB.notifications.unshift(notif);
          renderNotificationHub();
          updateHubBadge();
          showNotificationToast(notif);
        })
        .subscribe();

      NOTIFICATION_HUB.teamSubscription = channel;
    }

    // Show toast notification
    function showNotificationToast(notif) {
      const icon = notif.type === 'chat' ? '' : '';
      showToast(`${icon} ${notif.author}: "${notif.message.substring(0, 50)}..."`, 'info');
    }

    // Notification preferences
    const NOTIFICATION_PREFS = {
      soundEnabled: localStorage.getItem('notifSound') !== 'false',
      desktopEnabled: localStorage.getItem('notifDesktop') !== 'false',
      soundVolume: parseFloat(localStorage.getItem('notifVolume') || '0.3')
    };

    // Play notification sound
    function playNotificationSound() {
      if (!NOTIFICATION_PREFS.soundEnabled) return;
      try {
        const audio = new Audio('data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2teleU47XZyUZC');
        audio.volume = NOTIFICATION_PREFS.soundVolume;
        audio.play().catch(() => {});
      } catch (e) {}
    }

    // Request desktop notification permission
    async function requestNotificationPermission() {
      if (!('Notification' in window)) {
        showToast('Desktop notifications not supported', 'warning');
        return false;
      }
      if (Notification.permission === 'granted') return true;
      if (Notification.permission === 'denied') {
        showToast('Notifications blocked - check browser settings', 'warning');
        return false;
      }
      const permission = await Notification.requestPermission();
      return permission === 'granted';
    }

    // Show desktop notification
    async function showDesktopNotification(title, body, icon = '') {
      if (!NOTIFICATION_PREFS.desktopEnabled) return;
      if (!('Notification' in window) || Notification.permission !== 'granted') return;

      try {
        const notif = new Notification(title, {
          body: body,
          icon: '/favicon.ico',
          badge: '/favicon.ico',
          tag: 'room-designer-' + Date.now(),
          requireInteraction: false,
          silent: false
        });

        notif.onclick = () => {
          window.focus();
          toggleNotificationHub();
          notif.close();
        };

        setTimeout(() => notif.close(), 8000);
      } catch (e) {
        console.log('Desktop notification error:', e);
      }
    }

    // Toggle notification preferences
    function toggleNotificationPref(pref) {
      if (pref === 'sound') {
        NOTIFICATION_PREFS.soundEnabled = !NOTIFICATION_PREFS.soundEnabled;
        localStorage.setItem('notifSound', NOTIFICATION_PREFS.soundEnabled);
        showToast(`Sound notifications ${NOTIFICATION_PREFS.soundEnabled ? 'enabled' : 'disabled'}`, 'info');
      } else if (pref === 'desktop') {
        if (!NOTIFICATION_PREFS.desktopEnabled) {
          requestNotificationPermission().then(granted => {
            if (granted) {
              NOTIFICATION_PREFS.desktopEnabled = true;
              localStorage.setItem('notifDesktop', 'true');
              showToast('Desktop notifications enabled', 'success');
              showDesktopNotification('Notifications Enabled', 'You will now receive desktop notifications');
            }
          });
        } else {
          NOTIFICATION_PREFS.desktopEnabled = false;
          localStorage.setItem('notifDesktop', 'false');
          showToast('Desktop notifications disabled', 'info');
        }
      }
      updateNotificationPrefsUI();
    }

    // Update notification prefs UI
    function updateNotificationPrefsUI() {
      const soundBtn = document.getElementById('toggleSoundNotif');
      const desktopBtn = document.getElementById('toggleDesktopNotif');
      if (soundBtn) soundBtn.classList.toggle('active', NOTIFICATION_PREFS.soundEnabled);
      if (desktopBtn) desktopBtn.classList.toggle('active', NOTIFICATION_PREFS.desktopEnabled);
    }

    // Message templates for quick replies
    const MESSAGE_TEMPLATES = [
      { id: 'thanks', label: 'Thank You', text: 'Thank you for your feedback! I\'ll review your comments and update the design.' },
      { id: 'received', label: 'Received', text: 'I\'ve received your message and will get back to you shortly.' },
      { id: 'revision', label: 'Revision Ready', text: 'I\'ve updated the design based on your feedback. Please review the changes and let me know your thoughts.' },
      { id: 'question', label: 'Question', text: 'I have a few questions about your requirements. Could you please clarify:' },
      { id: 'quote', label: 'Quote Ready', text: 'I\'ve prepared a quote for your project. The estimated cost is shown in the design summary.' },
      { id: 'schedule', label: 'Schedule', text: 'I\'d like to schedule a time to discuss your project further. What times work best for you?' },
      { id: 'materials', label: 'Materials', text: 'I\'ve selected materials that match your style preferences. Click on any element to see the material details and pricing.' },
      { id: 'approval', label: 'Approval Needed', text: 'Please review the design and let me know if you approve this layout, or if you\'d like any changes.' }
    ];

    // Insert message template
    function insertMessageTemplate(templateId, inputId = 'chatMessageInput') {
      const template = MESSAGE_TEMPLATES.find(t => t.id === templateId);
      const input = document.getElementById(inputId);
      if (template && input) {
        input.value = template.text;
        input.focus();
        // Position cursor at end
        input.setSelectionRange(input.value.length, input.value.length);
      }
    }

    // Render message templates dropdown
    function renderMessageTemplates(containerId = 'messageTemplatesDropdown') {
      const container = document.getElementById(containerId);
      if (!container) return;

      container.innerHTML = MESSAGE_TEMPLATES.map(t => `
        <div class="template-item" onclick="insertMessageTemplate('${t.id}')">
          <span class="template-label">${t.label}</span>
          <span class="template-preview">${t.text.substring(0, 40)}...</span>
        </div>
      `).join('');
    }

    // Attach design snapshot to message
    async function attachDesignSnapshot(inputId = 'chatMessageInput') {
      const input = document.getElementById(inputId);
      if (!input) return;

      // Capture canvas as image
      const canvas = document.getElementById('canvas');
      if (!canvas) {
        showToast('No design to capture', 'warning');
        return;
      }

      try {
        // Get current design state
        const snapshot = {
          timestamp: new Date().toISOString(),
          roomSize: `${roomWidth}'${roomDepth}'`,
          elementCount: elements.length,
          thumbnail: canvas.toDataURL('image/jpeg', 0.5)
        };

        // Add snapshot reference to message
        const currentText = input.value;
        const snapshotRef = `\n\n Design Snapshot (${snapshot.roomSize}, ${snapshot.elementCount} elements)`;
        input.value = currentText + snapshotRef;

        // Store snapshot for sending
        input.dataset.snapshot = JSON.stringify(snapshot);

        showToast('Design snapshot attached', 'success');
      } catch (e) {
        console.log('Snapshot error:', e);
        showToast('Could not attach snapshot', 'warning');
      }
    }

    // Enhanced notification with desktop + sound
    function triggerNotification(notif) {
      // Play sound
      playNotificationSound();

      // Show desktop notification
      showDesktopNotification(
        `${notif.type === 'chat' ? '' : ''} ${notif.source}`,
        `${notif.author}: ${notif.message}`
      );

      // Show in-app toast
      showNotificationToast(notif);
    }

    // Render notification hub list
    function renderNotificationHub() {
      const container = document.getElementById('notificationList');
      if (!container) return;

      // Sort by time (newest first)
      const sorted = [...NOTIFICATION_HUB.notifications].sort((a, b) =>
        new Date(b.time) - new Date(a.time)
      );

      // Filter by type
      const filtered = NOTIFICATION_HUB.filter === 'all'
        ? sorted
        : sorted.filter(n => n.type === NOTIFICATION_HUB.filter);

      // Update tab counts
      const allCount = sorted.filter(n => !n.read).length;
      const chatCount = sorted.filter(n => n.type === 'chat' && !n.read).length;
      const teamCount = sorted.filter(n => n.type === 'team' && !n.read).length;

      document.getElementById('tabCountAll').textContent = allCount;
      document.getElementById('tabCountChat').textContent = chatCount;
      document.getElementById('tabCountTeam').textContent = teamCount;

      if (!filtered.length) {
        container.innerHTML = `
          <div class="notification-empty">
            <div class="notification-empty-icon"></div>
            <div class="notification-empty-text">No notifications</div>
            <div class="notification-empty-subtext">Messages from clients and team appear here</div>
          </div>
        `;
        return;
      }

      container.innerHTML = filtered.slice(0, 15).map(n => {
        const timeAgo = getTimeAgo(n.time);
        const iconClass = n.type === 'chat' ? 'chat' : 'team';
        const icon = n.type === 'chat' ? '' : '';

        return `
          <div class="notification-item ${n.read ? '' : 'unread'}"
               onclick="handleNotificationClick('${n.id}', '${n.type}', '${n.shareToken || ''}', '${n.designId || ''}')">
            <div class="notif-icon ${iconClass}">${icon}</div>
            <div class="notif-content">
              <div class="notif-header">
                <div class="notif-source">${escapeHtml(n.source)}</div>
                <div class="notif-time">${timeAgo}</div>
              </div>
              <div class="notif-message">${escapeHtml(n.message)}</div>
              <div class="notif-context">
                <span>${escapeHtml(n.author)}</span>
                ${n.type === 'chat' ? '<span class="design-link"> Open Design</span>' : ''}
              </div>
            </div>
          </div>
        `;
      }).join('');
    }

    // Handle notification click
    async function handleNotificationClick(notifId, type, shareToken, designId) {
      // Mark as read
      const notif = NOTIFICATION_HUB.notifications.find(n => n.id === notifId);
      if (notif) notif.read = true;

      renderNotificationHub();
      updateHubBadge();

      // Navigate to design if it's a client message
      if (type === 'chat' && shareToken) {
        toggleNotificationHub();
        await loadDesignByShareToken(shareToken);
      }

      // For team messages, scroll to chat section
      if (type === 'team') {
        toggleNotificationHub();
        const chatSection = document.getElementById('teamChatSection');
        if (chatSection) {
          chatSection.scrollIntoView({ behavior: 'smooth' });
        }
      }
    }

    // Load design by share token
    async function loadDesignByShareToken(shareToken) {
      const supabase = getSupabaseClient();
      if (!supabase || !shareToken) return;

      try {
        const { data: design } = await supabase
          .from('room_designs')
          .select('*')
          .eq('share_token', shareToken)
          .single();

        if (design) {
          currentDesignId = design.id;
          SHARE_STATE.designId = design.id;
          SHARE_STATE.designToken = design.share_token;
          document.getElementById('projectName').value = design.name || 'Untitled';

          // Load design data
          if (design.design_data) {
            const data = typeof design.design_data === 'string'
              ? JSON.parse(design.design_data)
              : design.design_data;
            loadDesignData({ ...data, id: design.id, share_token: design.share_token });
          } else if (design.elements) {
            loadDesignData(design);
          }

          // Load share data and comments
          await setupDesignerCommentNotifications(design.id);

          // Scroll to messages panel
          setTimeout(() => {
            const chatSection = document.getElementById('teamChatSection');
            if (chatSection) {
              chatSection.classList.remove('collapsed');
              chatSection.scrollIntoView({ behavior: 'smooth' });
            }
          }, 500);

          showToast('Design loaded', 'success');
        }
      } catch (err) {
        console.log('Load design error:', err.message);
      }
    }

    // Update hub badge
    function updateHubBadge() {
      const badge = document.getElementById('hubBadge');
      const btn = document.getElementById('notifHubBtn');
      const unreadCount = NOTIFICATION_HUB.notifications.filter(n => !n.read).length;

      if (unreadCount > 0) {
        badge.textContent = unreadCount > 99 ? '99+' : unreadCount;
        badge.classList.remove('hidden');
        btn.classList.add('has-notifications');
      } else {
        badge.classList.add('hidden');
        btn.classList.remove('has-notifications');
      }
    }

    // Mark all as read - updates memory, database, AND localStorage for share comments
    async function markAllNotificationsRead() {
      // Separate database IDs from share comment IDs
      const dbIds = NOTIFICATION_HUB.notifications
        .filter(n => !n.read && n.id && !String(n.id).startsWith('share-comment-'))
        .map(n => n.id);

      const shareCommentIds = NOTIFICATION_HUB.notifications
        .filter(n => !n.read && n.id && String(n.id).startsWith('share-comment-'))
        .map(n => n.id);

      // Update memory immediately for responsive UI
      NOTIFICATION_HUB.notifications.forEach(n => n.read = true);
      renderNotificationHub();
      updateHubBadge();

      // Persist share comment read status to localStorage
      if (shareCommentIds.length > 0) {
        const cleared = JSON.parse(localStorage.getItem('clearedShareComments') || '[]');
        const updated = [...new Set([...cleared, ...shareCommentIds])];
        localStorage.setItem('clearedShareComments', JSON.stringify(updated));
        console.log('Saved', shareCommentIds.length, 'share comments as read to localStorage');
      }

      // Persist database notifications to database
      if (dbIds.length > 0 && typeof supabase !== 'undefined') {
        try {
          const now = new Date().toISOString();
          const supabaseClient = getSupabaseClient();
          if (supabaseClient) {
            await supabaseClient
              .from('customer_messages')
              .update({ read_at: now })
              .in('id', dbIds);
            console.log('Marked', dbIds.length, 'notifications as read in database');
          }
        } catch (err) {
          console.error('Failed to persist read status:', err);
        }
      }

      showToast('All notifications marked as read', 'success');
    }

    // Clear all notifications - updates memory, database, AND localStorage
    async function clearAllNotifications() {
      // Separate database IDs from share comment IDs
      const dbIds = NOTIFICATION_HUB.notifications
        .filter(n => n.id && !String(n.id).startsWith('share-comment-'))
        .map(n => n.id);

      const shareCommentIds = NOTIFICATION_HUB.notifications
        .filter(n => n.id && String(n.id).startsWith('share-comment-'))
        .map(n => n.id);

      // Clear memory immediately
      NOTIFICATION_HUB.notifications = [];
      renderNotificationHub();
      updateHubBadge();

      // Save ALL cleared notification IDs to localStorage so they don't reload
      if (dbIds.length > 0) {
        const clearedDbIds = JSON.parse(localStorage.getItem('clearedNotificationIds') || '[]');
        const updatedDbIds = [...new Set([...clearedDbIds, ...dbIds])];
        localStorage.setItem('clearedNotificationIds', JSON.stringify(updatedDbIds));
        console.log('Saved', dbIds.length, 'notification IDs as cleared to localStorage');
      }

      // Persist share comment cleared status to localStorage
      if (shareCommentIds.length > 0) {
        const cleared = JSON.parse(localStorage.getItem('clearedShareComments') || '[]');
        const updated = [...new Set([...cleared, ...shareCommentIds])];
        localStorage.setItem('clearedShareComments', JSON.stringify(updated));
        console.log('Saved', shareCommentIds.length, 'share comments as cleared to localStorage');
      }

      // Also mark as read in database
      if (dbIds.length > 0 && typeof supabase !== 'undefined') {
        try {
          const now = new Date().toISOString();
          const supabaseClient = getSupabaseClient();
          if (supabaseClient) {
            await supabaseClient
              .from('customer_messages')
              .update({ read_at: now })
              .in('id', dbIds);
            console.log('Cleared', dbIds.length, 'notifications in database');
          }
        } catch (err) {
          console.error('Failed to persist clear status:', err);
        }
      }

      showToast('All notifications cleared', 'success');
    }

    // Clear a single notification
    function clearNotification(notificationId) {
      // Save to appropriate localStorage based on ID type
      if (String(notificationId).startsWith('share-comment-')) {
        const cleared = JSON.parse(localStorage.getItem('clearedShareComments') || '[]');
        if (!cleared.includes(notificationId)) {
          cleared.push(notificationId);
          localStorage.setItem('clearedShareComments', JSON.stringify(cleared));
        }
      } else {
        // Database notification - save ID to cleared list
        const clearedDbIds = JSON.parse(localStorage.getItem('clearedNotificationIds') || '[]');
        if (!clearedDbIds.includes(notificationId)) {
          clearedDbIds.push(notificationId);
          localStorage.setItem('clearedNotificationIds', JSON.stringify(clearedDbIds));
        }
      }

      NOTIFICATION_HUB.notifications = NOTIFICATION_HUB.notifications.filter(n => n.id !== notificationId);
      renderNotificationHub();
      updateHubBadge();
    }

    // Open full inbox (redirect to account CRM messages page)
    function openFullInbox() {
      window.location.href = '/account/?page=messages';
    }

    // Legacy compatibility
    function initDesignNotifications() {
      initNotificationHub();
    }

    function updateNotificationBadge() {
      updateHubBadge();
    }

    // Open design from notification
    async function openDesignFromNotification(shareToken, notificationId) {
      if (!shareToken) {
        showToast('Unable to open design', 'error');
        return;
      }

      // Mark notification as read
      const notification = DESIGN_NOTIFICATIONS.notifications.find(n => n.id === notificationId);
      if (notification && !notification.read) {
        notification.read = true;
        DESIGN_NOTIFICATIONS.unreadCount = Math.max(0, DESIGN_NOTIFICATIONS.unreadCount - 1);
        updateNotificationBadge();
        renderDesignNotifications();

        // Update in database (customer_messages table)
        const supabase = getSupabaseClient();
        if (supabase) {
          supabase
            .from('customer_messages')
            .update({ read_at: new Date().toISOString() })
            .eq('id', notificationId)
            .then(() => {})
            .catch(() => {});
        }
      }

      // Navigate to design with share token
      window.location.href = `/tools/room-designer/?share=${shareToken}`;
    }

    // Helper: Get time ago string
    function getTimeAgo(dateString) {
      const date = new Date(dateString);
      const now = new Date();
      const diffMs = now - date;
      const diffMins = Math.floor(diffMs / 60000);
      const diffHours = Math.floor(diffMs / 3600000);
      const diffDays = Math.floor(diffMs / 86400000);

      if (diffMins < 1) return 'just now';
      if (diffMins < 60) return `${diffMins}m ago`;
      if (diffHours < 24) return `${diffHours}h ago`;
      if (diffDays < 7) return `${diffDays}d ago`;
      return date.toLocaleDateString();
    }

    // Initialize notifications on page load
    document.addEventListener('DOMContentLoaded', () => {
      setTimeout(() => {
        if (window.SgAuth?.getUser()) {
          initDesignNotifications();
        }
      }, 2000);
    });

    // ============================================================
    // TEAM COLLABORATION CHAT
    // Real-time chat between designers, fabricators, contractors
    // ============================================================

    const TEAM_CHAT = {
      channel: null,
      messages: [],
      activeUsers: new Map(),
      myUserId: null,
      myUserName: null,
      designId: null,
      unreadCount: 0
    };

    // Show/update team chat badge
    function updateTeamChatBadge() {
      const section = document.getElementById('teamChatSection');
      const badge = document.getElementById('teamChatBadge');
      if (!section || !badge) return;

      const isCollapsed = section.classList.contains('collapsed');

      if (TEAM_CHAT.unreadCount > 0 && isCollapsed) {
        badge.textContent = TEAM_CHAT.unreadCount > 9 ? '9+' : TEAM_CHAT.unreadCount;
        badge.style.display = 'inline-flex';
      } else if (badge) {
        badge.style.display = 'none';
      }
    }

    // Clear unread count when section is expanded
    function onTeamChatSectionExpanded() {
      TEAM_CHAT.unreadCount = 0;
      updateTeamChatBadge();
    }

    // Initialize team chat when a design is loaded
    async function initTeamChat(designId) {
      if (!designId) return;

      const supabase = getSupabaseClient();
      if (!supabase) return;

      // Get current user info
      const user = window.SgAuth?.getUser();
      if (!user) return;

      TEAM_CHAT.myUserId = user.id;
      TEAM_CHAT.myUserName = user.user_metadata?.full_name || user.email?.split('@')[0] || 'Anonymous';
      TEAM_CHAT.designId = designId;

      // Clean up existing channel
      if (TEAM_CHAT.channel) {
        supabase.removeChannel(TEAM_CHAT.channel);
      }

      // Create broadcast channel for real-time chat
      const channel = supabase.channel(`design-chat-${designId}`, {
        config: { presence: { key: TEAM_CHAT.myUserId } }
      });

      // Handle presence (who's online)
      channel
        .on('presence', { event: 'sync' }, () => {
          const state = channel.presenceState();
          TEAM_CHAT.activeUsers.clear();
          Object.entries(state).forEach(([key, presences]) => {
            if (presences[0]) {
              TEAM_CHAT.activeUsers.set(key, presences[0]);
            }
          });
          updateActiveCollaborators();
        })
        .on('presence', { event: 'join' }, ({ key, newPresences }) => {
          if (newPresences[0] && key !== TEAM_CHAT.myUserId) {
            TEAM_CHAT.activeUsers.set(key, newPresences[0]);
            updateActiveCollaborators();
            addSystemMessage(`${newPresences[0].name || 'Someone'} joined the design`);
          }
        })
        .on('presence', { event: 'leave' }, ({ key, leftPresences }) => {
          if (leftPresences[0] && key !== TEAM_CHAT.myUserId) {
            addSystemMessage(`${leftPresences[0].name || 'Someone'} left the design`);
          }
          TEAM_CHAT.activeUsers.delete(key);
          updateActiveCollaborators();
        });

      // Handle broadcast messages (chat)
      channel.on('broadcast', { event: 'chat' }, ({ payload }) => {
        if (payload.userId !== TEAM_CHAT.myUserId) {
          addChatMessage(payload.userName, payload.message, payload.userId, payload.timestamp);
        }
      });

      // Subscribe and track presence
      await channel.subscribe(async (status) => {
        if (status === 'SUBSCRIBED') {
          await channel.track({
            name: TEAM_CHAT.myUserName,
            joinedAt: new Date().toISOString(),
            userId: TEAM_CHAT.myUserId
          });
          console.log('Team chat connected for design:', designId);
        }
      });

      TEAM_CHAT.channel = channel;

      // Load recent messages from database
      await loadRecentTeamMessages(designId);
    }

    // Load recent messages from database
    async function loadRecentTeamMessages(designId) {
      const supabase = getSupabaseClient();
      if (!supabase || !designId) return;

      try {
        // Check if design_chat_messages table exists by attempting query
        const { data: messages, error } = await supabase
          .from('design_chat_messages')
          .select('*')
          .eq('design_id', designId)
          .order('created_at', { ascending: true })
          .limit(50);

        if (!error && messages) {
          const container = document.getElementById('teamChatMessages');
          if (container) {
            container.innerHTML = '';
            messages.forEach(msg => {
              addChatMessage(msg.user_name, msg.message, msg.user_id, msg.created_at, false);
            });
            container.scrollTop = container.scrollHeight;
          }
        }
      } catch (err) {
        // Table might not exist yet - that's ok, just use broadcast
        console.log('Team chat history not available:', err.message);
      }
    }

    // Update the active collaborators display
    function updateActiveCollaborators() {
      const container = document.getElementById('activeCollaborators');
      const countEl = document.getElementById('teamOnlineCount');
      if (!container) return;

      const users = Array.from(TEAM_CHAT.activeUsers.values());
      const count = users.length;

      if (countEl) {
        countEl.textContent = `${count} online`;
        countEl.style.background = count > 0 ? 'rgba(16,185,129,0.2)' : 'rgba(255,255,255,0.1)';
        countEl.style.color = count > 0 ? '#10b981' : 'var(--text-muted)';
      }

      if (count === 0) {
        container.innerHTML = '<span style="color: var(--text-muted); font-size: 11px; padding: 4px;">No collaborators online</span>';
        return;
      }

      const colors = ['#10b981', '#3b82f6', '#8b5cf6', '#f59e0b', '#ec4899', '#06b6d4'];
      container.innerHTML = users.map((user, i) => {
        const initial = (user.name || 'U')[0].toUpperCase();
        const color = colors[i % colors.length];
        const isMe = user.userId === TEAM_CHAT.myUserId;
        const displayName = user.name || 'User';
        return `
          <div class="collaborator-chip ${isMe ? 'is-you' : ''}" title="${displayName}${isMe ? ' (you)' : ''}">
            <span class="avatar-small" style="background: ${color};">${initial}</span>
            <span style="max-width: 70px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${displayName}${isMe ? ' (you)' : ''}</span>
          </div>
        `;
      }).join('');
    }

    // Add a chat message to the UI
    function addChatMessage(userName, message, userId, timestamp, scroll = true) {
      const container = document.getElementById('teamChatMessages');
      if (!container) return;

      // Clear empty state placeholder
      const emptyState = container.querySelector('.chat-empty-state');
      if (emptyState) {
        container.innerHTML = '';
      }

      const isMe = userId === TEAM_CHAT.myUserId;
      const time = new Date(timestamp || Date.now()).toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' });
      const initial = (userName || 'U')[0].toUpperCase();
      const avatarColor = isMe ? '#f9cb00' : '#6366f1';
      const avatarTextColor = isMe ? '#1a1a2e' : 'white';

      const msgEl = document.createElement('div');
      msgEl.className = `chat-message ${isMe ? 'own-message' : ''}`;
      msgEl.innerHTML = `
        <div class="avatar" style="background: ${avatarColor}; color: ${avatarTextColor};">${initial}</div>
        <div style="flex: 1; max-width: 80%;">
          <div class="meta">${userName}  ${time}</div>
          <div class="bubble">${escapeHtml(message)}</div>
        </div>
      `;

      container.appendChild(msgEl);
      if (scroll) container.scrollTop = container.scrollHeight;

      // Store message
      TEAM_CHAT.messages.push({ userName, message, userId, timestamp });

      // Update unread badge if section is collapsed and message is from someone else
      const section = document.getElementById('teamChatSection');
      if (!isMe && section?.classList.contains('collapsed')) {
        TEAM_CHAT.unreadCount++;
        updateTeamChatBadge();
        // Play notification sound (optional)
        try {
          const audio = new Audio('data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2teleU47XZyUZC');
          audio.volume = 0.2;
          audio.play().catch(() => {});
        } catch (e) {}
      }
    }

    // Add system message (join/leave notifications)
    function addSystemMessage(text) {
      const container = document.getElementById('teamChatMessages');
      if (!container) return;

      // Clear empty state
      const emptyState = container.querySelector('.chat-empty-state');
      if (emptyState) {
        container.innerHTML = '';
      }

      const msgEl = document.createElement('div');
      msgEl.className = 'chat-system-message';
      msgEl.textContent = text;
      container.appendChild(msgEl);
      container.scrollTop = container.scrollHeight;
    }

    // Send a chat message
    async function sendTeamChat() {
      const input = document.getElementById('teamChatInput');
      const message = input?.value?.trim();
      if (!message || !TEAM_CHAT.channel || !TEAM_CHAT.designId) return;

      const timestamp = new Date().toISOString();

      // Broadcast to other users
      await TEAM_CHAT.channel.send({
        type: 'broadcast',
        event: 'chat',
        payload: {
          userId: TEAM_CHAT.myUserId,
          userName: TEAM_CHAT.myUserName,
          message,
          timestamp
        }
      });

      // Add to our own UI
      addChatMessage(TEAM_CHAT.myUserName, message, TEAM_CHAT.myUserId, timestamp);

      // Clear input
      input.value = '';

      // Persist to database (fire and forget)
      const supabase = getSupabaseClient();
      if (supabase) {
        supabase
          .from('design_chat_messages')
          .insert({
            design_id: TEAM_CHAT.designId,
            user_id: TEAM_CHAT.myUserId,
            user_name: TEAM_CHAT.myUserName,
            message
          })
          .then(() => {})
          .catch(err => console.log('Chat message persist failed:', err.message));
      }
    }

    // Clean up team chat when leaving
    function cleanupTeamChat() {
      if (TEAM_CHAT.channel) {
        const supabase = getSupabaseClient();
        if (supabase) {
          supabase.removeChannel(TEAM_CHAT.channel);
        }
        TEAM_CHAT.channel = null;
      }
      TEAM_CHAT.messages = [];
      TEAM_CHAT.activeUsers.clear();
    }

    // Listen for page unload to cleanup
    window.addEventListener('beforeunload', cleanupTeamChat);

    // ============================================================
    // UNIFIED MESSAGE SYSTEM
    // Combines customer messages and team chat into one panel
    // ============================================================

    const UNIFIED_MESSAGES = {
      allMessages: [],
      clientMessages: [],
      teamMessages: [],
      currentTab: 'all',
      clientSubscription: null,
      shareCommentsSubscription: null
    };

    // Manual refresh messages (reload from database)
    async function refreshMessages() {
      console.log('=== refreshMessages START ===');
      const supabase = getSupabaseClient();
      if (!supabase) {
        showToast('Not connected', 'error');
        return;
      }

      const designId = currentDesignId || SHARE_STATE.designId;
      if (!designId) {
        showToast('Save or load a design first to see messages', 'info');
        return;
      }

      showToast('Refreshing...', 'info');

      try {
        // Reload share data
        const { data: shares, error } = await supabase
          .from('room_design_shares')
          .select('*')
          .eq('design_id', designId)
          .order('created_at', { ascending: false })
          .limit(1);

        console.log('Refresh - Share query:', shares, 'Error:', error);

        if (shares && shares.length > 0) {
          const share = shares[0];
          SHARE_STATE.shareId = share.id;
          SHARE_STATE.shareToken = share.share_token;
          SHARE_STATE.leadId = share.lead_id;
          SHARE_STATE.comments = share.comments || [];
          console.log('Refresh - Loaded', SHARE_STATE.comments?.length || 0, 'comments');
        }

        // Reload messages
        await loadUnifiedMessages();
        showToast(`Found ${SHARE_STATE.comments?.length || 0} customer comments`, 'success');
      } catch (err) {
        console.error('Refresh error:', err);
        showToast('Refresh failed: ' + err.message, 'error');
      }
    }

    // Switch message tab
    function switchMessageTab(tab) {
      UNIFIED_MESSAGES.currentTab = tab;

      // Update tab UI
      document.querySelectorAll('.message-tab').forEach(t => {
        t.classList.toggle('active', t.id === `tab${tab.charAt(0).toUpperCase() + tab.slice(1)}Messages`);
      });

      // Re-render messages
      renderUnifiedMessages();
    }

    // Load all messages for current design
    async function loadUnifiedMessages() {
      const supabase = getSupabaseClient();
      if (!supabase || !currentDesignId) return;

      UNIFIED_MESSAGES.allMessages = [];
      UNIFIED_MESSAGES.clientMessages = [];
      UNIFIED_MESSAGES.teamMessages = [];

      try {
        // Load team chat messages
        const { data: teamMsgs } = await supabase
          .from('design_chat_messages')
          .select('*')
          .eq('design_id', currentDesignId)
          .order('created_at', { ascending: true })
          .limit(50);

        if (teamMsgs) {
          teamMsgs.forEach(m => {
            const msg = {
              id: m.id,
              type: 'team',
              author: m.user_name,
              userId: m.user_id,
              message: m.message,
              time: m.created_at
            };
            UNIFIED_MESSAGES.teamMessages.push(msg);
            UNIFIED_MESSAGES.allMessages.push(msg);
          });
        }

        // Load customer messages from multiple sources

        // Source 1: customer_messages table (if lead linked)
        if (SHARE_STATE.leadId) {
          const { data: clientMsgs } = await supabase
            .from('customer_messages')
            .select('*')
            .eq('customer_id', SHARE_STATE.leadId)
            .eq('channel', 'design_share')
            .order('created_at', { ascending: true })
            .limit(50);

          if (clientMsgs) {
            clientMsgs.forEach(m => {
              const msg = {
                id: m.id,
                type: 'client',
                author: m.direction === 'inbound' ? (m.metadata?.author || SHARE_STATE.customerName || 'Customer') : 'You',
                direction: m.direction,
                message: m.message,
                time: m.created_at,
                read: m.read_at != null
              };
              UNIFIED_MESSAGES.clientMessages.push(msg);
              UNIFIED_MESSAGES.allMessages.push(msg);
            });
          }

          subscribeToClientMessages();
        }

        // Source 2: SHARE_STATE.comments (JSONB from room_design_shares)
        if (SHARE_STATE.comments && SHARE_STATE.comments.length > 0) {
          SHARE_STATE.comments.forEach((c, idx) => {
            // Avoid duplicates if already loaded from customer_messages
            const isDupe = UNIFIED_MESSAGES.clientMessages.some(m =>
              m.message === c.text && m.time === c.timestamp
            );
            if (!isDupe) {
              const msg = {
                id: `comment-${idx}`,
                type: 'client',
                author: c.author || 'Customer',
                direction: c.direction || 'inbound',
                message: c.text,
                time: c.timestamp,
                read: true
              };
              UNIFIED_MESSAGES.clientMessages.push(msg);
              UNIFIED_MESSAGES.allMessages.push(msg);
            }
          });
        }

        // Source 3: Subscribe to real-time updates on room_design_shares
        subscribeToShareComments();

        // Sort all messages by time
        UNIFIED_MESSAGES.allMessages.sort((a, b) => new Date(a.time) - new Date(b.time));

        renderUnifiedMessages();
        updateMessageBadges();

      } catch (err) {
        console.log('Load messages error:', err.message);
      }
    }

    // Subscribe to real-time customer messages
    function subscribeToClientMessages() {
      const supabase = getSupabaseClient();
      if (!supabase || !SHARE_STATE.leadId) return;

      if (UNIFIED_MESSAGES.clientSubscription) {
        supabase.removeChannel(UNIFIED_MESSAGES.clientSubscription);
      }

      const channel = supabase
        .channel('unified-client-messages')
        .on('postgres_changes', {
          event: 'INSERT',
          schema: 'public',
          table: 'customer_messages',
          filter: `customer_id=eq.${SHARE_STATE.leadId}`
        }, (payload) => {
          if (payload.new.channel === 'design_share') {
            const msg = {
              id: payload.new.id,
              type: 'client',
              author: payload.new.direction === 'inbound' ? (payload.new.metadata?.author || SHARE_STATE.customerName || 'Customer') : 'You',
              direction: payload.new.direction,
              message: payload.new.message,
              time: payload.new.created_at,
              read: false
            };

            UNIFIED_MESSAGES.clientMessages.push(msg);
            UNIFIED_MESSAGES.allMessages.push(msg);
            UNIFIED_MESSAGES.allMessages.sort((a, b) => new Date(a.time) - new Date(b.time));

            renderUnifiedMessages();
            updateMessageBadges();

            // Show toast for inbound messages
            if (payload.new.direction === 'inbound') {
              showToast(` ${msg.author}: "${msg.message.substring(0, 40)}..."`, 'info');
            }
          }
        })
        .subscribe();

      UNIFIED_MESSAGES.clientSubscription = channel;
    }

    // Subscribe to share comments updates (room_design_shares.comments JSONB)
    function subscribeToShareComments() {
      console.log('=== subscribeToShareComments START ===');
      console.log('SHARE_STATE.shareId:', SHARE_STATE.shareId);

      const supabase = getSupabaseClient();
      if (!supabase || !SHARE_STATE.shareId) {
        console.log('Cannot subscribe - supabase:', !!supabase, 'shareId:', SHARE_STATE.shareId);
        return;
      }

      // Clean up existing subscription to avoid duplicates
      if (UNIFIED_MESSAGES.shareCommentsSubscription) {
        console.log('Removing existing subscription');
        supabase.removeChannel(UNIFIED_MESSAGES.shareCommentsSubscription);
      }

      console.log('Creating realtime subscription for share:', SHARE_STATE.shareId);

      const channel = supabase
        .channel('share-comments-updates-' + SHARE_STATE.shareId)
        .on('postgres_changes', {
          event: 'UPDATE',
          schema: 'public',
          table: 'room_design_shares',
          filter: `id=eq.${SHARE_STATE.shareId}`
        }, (payload) => {
          console.log('=== REALTIME UPDATE RECEIVED ===', payload);
          // Reload comments from updated share
          if (payload.new.comments) {
            const newComments = payload.new.comments;
            console.log('New comments array:', newComments);
            newComments.forEach((c, idx) => {
              const isDupe = UNIFIED_MESSAGES.clientMessages.some(m =>
                m.message === c.text && m.time === c.timestamp
              );
              if (!isDupe) {
                console.log('Adding new comment:', c.text);
                const msg = {
                  id: `comment-new-${idx}-${Date.now()}`,
                  type: 'client',
                  author: c.author || 'Customer',
                  direction: c.direction || 'inbound',
                  message: c.text,
                  time: c.timestamp,
                  read: false
                };
                UNIFIED_MESSAGES.clientMessages.push(msg);
                UNIFIED_MESSAGES.allMessages.push(msg);
                UNIFIED_MESSAGES.allMessages.sort((a, b) => new Date(a.time) - new Date(b.time));

                if (c.direction !== 'outbound') {
                  showToast(` ${msg.author}: "${msg.message.substring(0, 40)}..."`, 'info');
                }
              }
            });
            renderUnifiedMessages();
            updateMessageBadges();
          }
        })
        .subscribe((status) => {
          console.log('Realtime subscription status:', status);
        });

      UNIFIED_MESSAGES.shareCommentsSubscription = channel;
      console.log('Subscription created');
    }

    // Render messages based on current tab
    function renderUnifiedMessages() {
      const container = document.getElementById('teamChatMessages');
      if (!container) return;

      let messages;
      switch (UNIFIED_MESSAGES.currentTab) {
        case 'client':
          messages = UNIFIED_MESSAGES.clientMessages;
          break;
        case 'team':
          messages = UNIFIED_MESSAGES.teamMessages;
          break;
        default:
          messages = UNIFIED_MESSAGES.allMessages;
      }

      if (!messages.length) {
        const emptyText = UNIFIED_MESSAGES.currentTab === 'client'
          ? 'No customer messages yet'
          : UNIFIED_MESSAGES.currentTab === 'team'
            ? 'No team messages yet'
            : 'No messages yet';

        container.innerHTML = `
          <div class="chat-empty-state" style="color: var(--text-muted); font-size: 11px; text-align: center; padding: 30px 12px;">
            <div style="font-size: 24px; margin-bottom: 8px; opacity: 0.4;"></div>
            <div style="font-weight: 500; margin-bottom: 4px;">${emptyText}</div>
            <div style="font-size: 10px; opacity: 0.6;">Messages will appear here</div>
          </div>
        `;
        return;
      }

      container.innerHTML = messages.map(m => {
        const isMe = m.userId === TEAM_CHAT.myUserId || m.direction === 'outbound';
        const time = new Date(m.time).toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' });
        const initial = (m.author || 'U')[0].toUpperCase();

        // Color coding by type
        let avatarColor, avatarText;
        if (m.type === 'client') {
          avatarColor = m.direction === 'inbound' ? '#8b5cf6' : '#10b981';
          avatarText = 'white';
        } else {
          avatarColor = isMe ? '#f9cb00' : '#6366f1';
          avatarText = isMe ? '#1a1a2e' : 'white';
        }

        // Type indicator
        const typeIcon = m.type === 'client' ? '' : '';

        return `
          <div class="chat-message ${isMe ? 'own-message' : ''}">
            <div class="avatar" style="background: ${avatarColor}; color: ${avatarText};">${initial}</div>
            <div style="flex: 1; max-width: 80%;">
              <div class="meta">${typeIcon} ${escapeHtml(m.author)}  ${time}</div>
              <div class="bubble">${escapeHtml(m.message)}</div>
            </div>
          </div>
        `;
      }).join('');

      container.scrollTop = container.scrollHeight;
    }

    // Update badge counts
    function updateMessageBadges() {
      const unreadClient = UNIFIED_MESSAGES.clientMessages.filter(m => !m.read && m.direction === 'inbound').length;
      const unreadTeam = UNIFIED_MESSAGES.teamMessages.filter(m => !m.read).length;
      const unreadAll = unreadClient + unreadTeam;

      updateBadge('badgeAll', unreadAll);
      updateBadge('badgeClient', unreadClient);
      updateBadge('badgeTeam', unreadTeam);
    }

    function updateBadge(id, count) {
      const badge = document.getElementById(id);
      if (!badge) return;
      if (count > 0) {
        badge.textContent = count > 9 ? '9+' : count;
        badge.classList.remove('hidden');
      } else {
        badge.classList.add('hidden');
      }
    }

    // Send unified message (to team chat or as reply to customer)
    async function sendUnifiedMessage() {
      const input = document.getElementById('teamChatInput');
      const message = input?.value?.trim();
      if (!message) return;

      const supabase = getSupabaseClient();
      if (!supabase) {
        showToast('Not connected', 'error');
        return;
      }

      // Check if we have a design loaded
      const designId = currentDesignId || SHARE_STATE.designId;
      if (!designId) {
        showToast('Save your design first to enable messaging', 'info');
        return;
      }

      // Determine where to send based on current tab or context
      const tab = UNIFIED_MESSAGES.currentTab;

      if (tab === 'client' || (SHARE_STATE.shareId && tab === 'all')) {
        // Send as reply to customer - save to BOTH customer_messages AND room_design_shares.comments
        const timestamp = new Date().toISOString();
        const authorName = TEAM_CHAT.myUserName || window.SgAuth?.getUser()?.email?.split('@')[0] || 'Designer';

        try {
          // 1. Save to customer_messages if we have a lead
          if (SHARE_STATE.leadId) {
            await supabase.from('customer_messages').insert({
              customer_id: SHARE_STATE.leadId,
              channel: 'design_share',
              direction: 'outbound',
              message: message,
              metadata: {
                design_id: currentDesignId,
                share_id: SHARE_STATE.shareId,
                author: authorName
              }
            });
          }

          // 2. ALSO save to room_design_shares.comments so customer can see the reply
          if (SHARE_STATE.shareId) {
            // First get current comments
            const { data: shareData } = await supabase
              .from('room_design_shares')
              .select('comments')
              .eq('id', SHARE_STATE.shareId)
              .single();

            const currentComments = shareData?.comments || [];
            const newComment = {
              text: message,
              timestamp: timestamp,
              author: authorName,
              direction: 'outbound'
            };

            // Update with new comment appended
            await supabase
              .from('room_design_shares')
              .update({ comments: [...currentComments, newComment] })
              .eq('id', SHARE_STATE.shareId);

            // Update local state
            SHARE_STATE.comments = [...currentComments, newComment];
          }

          // Add to local list
          const msg = {
            id: Date.now().toString(),
            type: 'client',
            author: 'You',
            direction: 'outbound',
            message: message,
            time: timestamp,
            read: true
          };
          UNIFIED_MESSAGES.clientMessages.push(msg);
          UNIFIED_MESSAGES.allMessages.push(msg);
          UNIFIED_MESSAGES.allMessages.sort((a, b) => new Date(a.time) - new Date(b.time));

          renderUnifiedMessages();
          input.value = '';
          showToast('Reply sent', 'success');

        } catch (err) {
          console.error('Send reply error:', err);
          showToast('Failed to send message', 'error');
        }

      } else {
        // Send as team chat message
        if (!TEAM_CHAT.channel || !TEAM_CHAT.designId) {
          // Fallback: save directly to database if not connected to realtime
          const user = window.SgAuth?.getUser();
          if (!user) {
            showToast('Please log in to send messages', 'error');
            return;
          }

          try {
            const designId = currentDesignId || SHARE_STATE.designId;
            if (!designId) {
              showToast('No design loaded', 'error');
              return;
            }

            await supabase.from('design_chat_messages').insert({
              design_id: designId,
              user_id: user.id,
              user_name: user.user_metadata?.full_name || user.email?.split('@')[0] || 'Designer',
              message: message
            });

            // Add to local list
            const msg = {
              id: Date.now().toString(),
              type: 'team',
              author: user.user_metadata?.full_name || user.email?.split('@')[0] || 'You',
              userId: user.id,
              message: message,
              time: new Date().toISOString()
            };
            UNIFIED_MESSAGES.teamMessages.push(msg);
            UNIFIED_MESSAGES.allMessages.push(msg);
            UNIFIED_MESSAGES.allMessages.sort((a, b) => new Date(a.time) - new Date(b.time));

            renderUnifiedMessages();
            input.value = '';
            return;
          } catch (err) {
            console.error('Fallback message send failed:', err);
            showToast('Failed to send message', 'error');
            return;
          }
        }

        const timestamp = new Date().toISOString();

        // Broadcast to other users
        await TEAM_CHAT.channel.send({
          type: 'broadcast',
          event: 'chat',
          payload: {
            userId: TEAM_CHAT.myUserId,
            userName: TEAM_CHAT.myUserName,
            message,
            timestamp
          }
        });

        // Add to local list
        const msg = {
          id: Date.now().toString(),
          type: 'team',
          author: TEAM_CHAT.myUserName,
          userId: TEAM_CHAT.myUserId,
          message: message,
          time: timestamp
        };
        UNIFIED_MESSAGES.teamMessages.push(msg);
        UNIFIED_MESSAGES.allMessages.push(msg);
        UNIFIED_MESSAGES.allMessages.sort((a, b) => new Date(a.time) - new Date(b.time));

        renderUnifiedMessages();
        input.value = '';

        // Persist to database
        supabase
          .from('design_chat_messages')
          .insert({
            design_id: TEAM_CHAT.designId,
            user_id: TEAM_CHAT.myUserId,
            user_name: TEAM_CHAT.myUserName,
            message
          })
          .catch(err => console.log('Save failed:', err.message));
      }
    }

    // Initialize unified messages when design loads
    async function initUnifiedMessages() {
      console.log('=== initUnifiedMessages START ===');
      console.log('currentDesignId:', currentDesignId);
      console.log('SHARE_STATE.shareId:', SHARE_STATE.shareId);

      if (!currentDesignId) {
        console.log('No currentDesignId, returning early');
        return;
      }

      const supabase = getSupabaseClient();
      if (!supabase) {
        console.log('No supabase client, returning early');
        return;
      }

      // If we don't have share data yet, try to load it for this design
      if (!SHARE_STATE.shareId && currentDesignId) {
        console.log('Loading share data for design:', currentDesignId);
        try {
          // Try to find a share for this design
          const { data: shares, error } = await supabase
            .from('room_design_shares')
            .select('*')
            .eq('design_id', currentDesignId)
            .order('created_at', { ascending: false })
            .limit(1);

          console.log('Share query result:', shares, 'Error:', error);

          if (shares && shares.length > 0) {
            const share = shares[0];
            SHARE_STATE.shareId = share.id;
            SHARE_STATE.shareToken = share.share_token;
            SHARE_STATE.leadId = share.lead_id;
            SHARE_STATE.comments = share.comments || [];
            console.log('Loaded share data for messages:', share.id, 'Comments:', SHARE_STATE.comments?.length || 0);
          } else {
            console.log('No share found for this design');
          }
        } catch (err) {
          console.log('Could not load share data:', err.message);
        }
      }

      console.log('Calling loadUnifiedMessages with shareId:', SHARE_STATE.shareId);
      loadUnifiedMessages();
    }

    // Load a locally saved design
    function loadLocalDesign(design) {
      console.log('loadLocalDesign called with:', design.name, design.elements?.length, 'elements');

      // Restore room dimensions
      roomWidth = design.room_width || 12;
      roomDepth = design.room_depth || 10;

      // Clear and restore elements
      elements.length = 0;
      if (design.elements && design.elements.length > 0) {
        design.elements.forEach(el => {
          elements.push({
            ...el,
            textureImg: null
          });
        });

        // Reload textures
        elements.forEach(el => {
          if (el.texture) {
            const img = new Image();
            img.crossOrigin = 'anonymous';
            img.onload = () => {
              el.textureImg = img;
              draw();
              if (currentView === '3d') update3DScene();
            };
            img.onerror = () => console.warn('Failed to load texture:', el.texture);
            img.src = el.texture;
          }
        });
      }

      // Clear and restore walls
      walls.length = 0;
      if (design.walls && design.walls.length > 0) {
        design.walls.forEach(w => walls.push(w));
      }

      // Restore multi-room data if present
      if (design.rooms && design.rooms.length > 0) {
        rooms.length = 0;
        design.rooms.forEach(room => {
          rooms.push({
            ...room,
            elements: room.elements || [],
            walls: room.walls || []
          });
        });
        currentRoomId = design.currentRoomId || rooms[0]?.id;
        updateRoomList();
      } else {
        // Single room - sync with room system
        initializeRooms();
        const currentRoomObj = getCurrentRoom();
        if (currentRoomObj) {
          currentRoomObj.elements = [...elements];
          currentRoomObj.walls = [...walls];
          currentRoomObj.width = roomWidth;
          currentRoomObj.depth = roomDepth;
        }
      }

      // Update project name
      const projectNameEl = document.getElementById('projectName');
      if (projectNameEl) {
        projectNameEl.value = design.name || 'Untitled Design';
      }

      // Update room type
      const roomTypeEl = document.getElementById('roomType');
      if (roomTypeEl && design.room_type) {
        roomTypeEl.value = design.room_type;
      }

      // Update UI dimensions
      const roomWidthEl = document.getElementById('roomWidth');
      const roomDepthEl = document.getElementById('roomDepth');
      if (roomWidthEl) roomWidthEl.value = roomWidth;
      if (roomDepthEl) roomDepthEl.value = roomDepth;

      // Set local design ID
      SHARE_STATE.designId = design.id;
      SHARE_STATE.isSharedView = false;

      // Fit to screen and normalize positions
      fitToScreen();
      const savedScale = design.settings?.pixelsPerFoot || 40;
      if (savedScale !== pixelsPerFoot && savedScale > 0) {
        const scaleRatio = pixelsPerFoot / savedScale;
        console.log('Normalizing local design positions with ratio:', scaleRatio);
        elements.forEach(el => {
          el.x = (el.x || 0) * scaleRatio;
          el.y = (el.y || 0) * scaleRatio;
        });
        walls.forEach(wall => {
          if (wall.x1 !== undefined) wall.x1 *= scaleRatio;
          if (wall.y1 !== undefined) wall.y1 *= scaleRatio;
          if (wall.x2 !== undefined) wall.x2 *= scaleRatio;
          if (wall.y2 !== undefined) wall.y2 *= scaleRatio;
        });
      }

      // Redraw everything
      draw();
      if (currentView === '3d') {
        update3DScene();
      }
      calculateQuote();
      updateProperties();
      updateElementSelector();

      console.log('Local design loaded successfully with', elements.length, 'elements');
    }

    // Add recent design tracking
    function trackRecentDesign(design) {
      let recent = JSON.parse(localStorage.getItem('recent_designs') || '[]');
      // Remove if already exists
      recent = recent.filter(r => r.id !== design.id);
      // Add to front
      recent.unshift({
        id: design.id,
        name: design.name,
        share_token: design.share_token,
        created_at: new Date().toISOString()
      });
      // Keep only last 10
      recent = recent.slice(0, 10);
      localStorage.setItem('recent_designs', JSON.stringify(recent));
    }

    // ===== NOTIFICATIONS =====
    function requestNotificationPermission() {
      if ('Notification' in window && Notification.permission === 'default') {
        Notification.requestPermission();
      }
    }

    function showNotification(title, body) {
      // In-app toast
      const toast = document.getElementById('notificationToast');
      document.getElementById('notificationTitle').textContent = title;
      document.getElementById('notificationBody').textContent = body;
      toast.classList.add('show');

      setTimeout(() => {
        toast.classList.remove('show');
      }, 5000);

      // Browser notification
      if ('Notification' in window && Notification.permission === 'granted') {
        new Notification(title, {
          body: body,
          icon: '/images/logo.png',
          badge: '/images/logo.png'
        });
      }
    }

    function hideNotification() {
      document.getElementById('notificationToast').classList.remove('show');
    }

    // Note: playNotificationSound() is defined earlier in the notification hub section

    // Helper function for consistent color from string
    function stringToColor(str) {
      let hash = 0;
      for (let i = 0; i < str.length; i++) {
        hash = str.charCodeAt(i) + ((hash << 5) - hash);
      }
      const hue = hash % 360;
      return `hsl(${hue}, 65%, 45%)`;
    }

    // Note: escapeHtml is defined earlier (around line 49675)

    // ===== LOADING OVERLAY =====
    function showLoading(message = 'Loading...') {
      let overlay = document.getElementById('loadingOverlay');
      if (!overlay) {
        overlay = document.createElement('div');
        overlay.id = 'loadingOverlay';
        overlay.className = 'loading-overlay';
        overlay.innerHTML = `
          <div style="text-align: center;">
            <div class="loading-spinner"></div>
            <div class="loading-text" id="loadingText">${message}</div>
          </div>
        `;
        document.body.appendChild(overlay);
      } else {
        document.getElementById('loadingText').textContent = message;
      }
      // Use setTimeout to ensure CSS transition works
      setTimeout(() => overlay.classList.add('active'), 10);
    }

    function hideLoading() {
      const overlay = document.getElementById('loadingOverlay');
      if (overlay) {
        overlay.classList.remove('active');
      }
    }

    // ===== AUTO-SAVE INDICATOR =====
    let autoSaveIndicatorTimeout = null;
    let saveStatusResetTimeout = null;

    // Track last save time
    let lastSaveTime = null;

    // Format time as relative string (e.g., "just now", "2m ago")
    function formatRelativeTime(date) {
      const now = new Date();
      const diffMs = now - date;
      const diffSec = Math.floor(diffMs / 1000);
      const diffMin = Math.floor(diffSec / 60);
      const diffHour = Math.floor(diffMin / 60);

      if (diffSec < 10) return 'just now';
      if (diffSec < 60) return `${diffSec}s ago`;
      if (diffMin < 60) return `${diffMin}m ago`;
      if (diffHour < 24) return `${diffHour}h ago`;
      return date.toLocaleDateString();
    }

    // Update the save status indicator in the toolbar
    function updateSaveStatus(status, text = null) {
      const statusEl = document.getElementById('saveStatus');
      if (!statusEl) return;

      const textEl = statusEl.querySelector('.save-text');
      const timeEl = statusEl.querySelector('.save-time') || document.getElementById('saveTime');

      // Remove all status classes
      statusEl.classList.remove('saved', 'saving', 'unsaved', 'error');

      // Add new status class and update text
      statusEl.classList.add(status);

      const statusTexts = {
        saved: 'Saved',
        saving: 'Saving...',
        unsaved: 'Unsaved',
        error: 'Error'
      };

      if (textEl) {
        textEl.textContent = text || statusTexts[status] || status;
      }

      // Update timestamp on save
      if (status === 'saved') {
        lastSaveTime = new Date();
        if (timeEl) {
          timeEl.textContent = formatRelativeTime(lastSaveTime);
          // Update tooltip with full timestamp
          statusEl.title = `Last saved: ${lastSaveTime.toLocaleString()}`;
        }
      } else if (status === 'saving' && timeEl) {
        timeEl.textContent = '';
      } else if (timeEl && lastSaveTime) {
        timeEl.textContent = formatRelativeTime(lastSaveTime);
      }

      // Reset to "saved" after showing error
      if (status === 'error') {
        if (saveStatusResetTimeout) clearTimeout(saveStatusResetTimeout);
        saveStatusResetTimeout = setTimeout(() => {
          updateSaveStatus('unsaved');
        }, 3000);
      }
    }

    // Periodically update the relative time display
    setInterval(() => {
      if (lastSaveTime) {
        const timeEl = document.getElementById('saveTime');
        if (timeEl) {
          timeEl.textContent = formatRelativeTime(lastSaveTime);
        }
      }
    }, 60000); // Update every minute

    // ===== ONLINE/OFFLINE DETECTION =====
    let isOnline = navigator.onLine;

    function updateConnectionStatus(online) {
      isOnline = online;
      if (online) {
        showToast('Back online - changes will sync', 'success');
        // Attempt to sync any pending changes
        if (typeof saveToCloud === 'function') {
          setTimeout(() => saveToCloud(), 1000);
        }
      } else {
        showToast('You are offline - changes saved locally', 'warning', 5000);
        updateSaveStatus('unsaved', 'Offline');
      }
    }

    // Listen for online/offline events
    window.addEventListener('online', () => updateConnectionStatus(true));
    window.addEventListener('offline', () => updateConnectionStatus(false));

    function showAutoSaveIndicator() {
      // Update toolbar save status
      updateSaveStatus('saved');

      // Create floating indicator if it doesn't exist
      let indicator = document.getElementById('autosaveIndicator');
      if (!indicator) {
        indicator = document.createElement('div');
        indicator.id = 'autosaveIndicator';
        indicator.className = 'autosave-indicator';
        indicator.innerHTML = `
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5">
            <polyline points="20 6 9 17 4 12"/>
          </svg>
          <span>Saved</span>
        `;
        document.body.appendChild(indicator);
      }

      // Clear any existing timeout
      if (autoSaveIndicatorTimeout) {
        clearTimeout(autoSaveIndicatorTimeout);
      }

      // Show indicator
      requestAnimationFrame(() => {
        indicator.classList.add('show');
      });

      // Hide after 1.5 seconds
      autoSaveIndicatorTimeout = setTimeout(() => {
        indicator.classList.remove('show');
      }, 1500);
    }

    // ===== MOBILE TOOLBAR INITIALIZATION =====
    function initMobileToolbar() {
      // Only create if not already exists and on mobile
      if (document.getElementById('mobileToolbar') || window.innerWidth > 900) return;

      // Don't create mobile toolbar in shared/review mode
      // Also check URL for share parameter (catches early init)
      const urlHasShare = new URLSearchParams(window.location.search).has('share');
      if (urlHasShare ||
          document.body.classList.contains('view-only-mode') ||
          document.body.classList.contains('review-readonly') ||
          document.getElementById('reviewRoom')) {
        return;
      }

      const toolbar = document.createElement('div');
      toolbar.id = 'mobileToolbar';
      toolbar.className = 'mobile-toolbar';
      toolbar.innerHTML = `
        <button class="tool-btn" onclick="setTool('select')" title="Select">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M3 3l7.07 16.97 2.51-7.39 7.39-2.51L3 3z"/>
          </svg>
        </button>
        <button class="tool-btn" onclick="setTool('pan')" title="Pan">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M5 9l-3 3 3 3M9 5l3-3 3 3M15 19l-3 3-3-3M19 9l3 3-3 3"/>
          </svg>
        </button>
        <button class="tool-btn" onclick="toggleMobileMenu()" title="Menu">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <line x1="3" y1="12" x2="21" y2="12"/>
            <line x1="3" y1="6" x2="21" y2="6"/>
            <line x1="3" y1="18" x2="21" y2="18"/>
          </svg>
        </button>
        <button class="tool-btn" onclick="undo()" title="Undo">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M3 7v6h6"/>
            <path d="M21 17a9 9 0 0 0-9-9 9 9 0 0 0-6 2.3L3 13"/>
          </svg>
        </button>
        <button class="tool-btn" onclick="openModal('shareModal')" title="Share">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <circle cx="18" cy="5" r="3"/>
            <circle cx="6" cy="12" r="3"/>
            <circle cx="18" cy="19" r="3"/>
            <line x1="8.59" y1="13.51" x2="15.42" y2="17.49"/>
            <line x1="15.41" y1="6.51" x2="8.59" y2="10.49"/>
          </svg>
        </button>
      `;
      document.body.appendChild(toolbar);
    }

    function toggleMobileMenu() {
      // Show a simple menu for mobile users
      const menu = document.getElementById('mobileMenuOverlay');
      if (menu) {
        menu.classList.toggle('active');
      } else {
        const menuOverlay = document.createElement('div');
        menuOverlay.id = 'mobileMenuOverlay';
        menuOverlay.className = 'modal-overlay active';
        menuOverlay.innerHTML = `
          <div class="modal" style="max-width: 300px;">
            <div class="modal-header">
              <h3 class="modal-title">Menu</h3>
              <button class="modal-close" onclick="document.getElementById('mobileMenuOverlay').classList.remove('active')"></button>
            </div>
            <div style="display: flex; flex-direction: column; gap: 8px; padding: 16px;">
              <button class="btn btn-primary" onclick="createNewDesign(); document.getElementById('mobileMenuOverlay').classList.remove('active');" style="background: #22c55e;">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="margin-right: 6px;">
                  <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
                  <polyline points="14 2 14 8 20 8"/>
                  <line x1="12" y1="18" x2="12" y2="12"/>
                  <line x1="9" y1="15" x2="15" y2="15"/>
                </svg>
                New Design
              </button>
              <button class="btn btn-secondary" onclick="openModal('templateModal'); document.getElementById('mobileMenuOverlay').classList.remove('active');">Load Template</button>
              <button class="btn btn-secondary" onclick="openModal('myDesignsModal'); document.getElementById('mobileMenuOverlay').classList.remove('active');">My Designs</button>
              <button class="btn btn-secondary" onclick="setView(currentView === '2d' ? '3d' : '2d'); document.getElementById('mobileMenuOverlay').classList.remove('active');">Toggle 2D/3D</button>
              <button class="btn btn-secondary" onclick="exportDesign(); document.getElementById('mobileMenuOverlay').classList.remove('active');">Save Design</button>
              <button class="btn btn-secondary" onclick="resetZoom(); document.getElementById('mobileMenuOverlay').classList.remove('active');">Reset Zoom</button>
            </div>
          </div>
        `;
        document.body.appendChild(menuOverlay);
        menuOverlay.addEventListener('click', (e) => {
          if (e.target === menuOverlay) menuOverlay.classList.remove('active');
        });
      }
    }

    // Initialize mobile toolbar on load
    if (window.innerWidth <= 900) {
      document.addEventListener('DOMContentLoaded', initMobileToolbar);
    }
    window.addEventListener('resize', () => {
      if (window.innerWidth <= 900) {
        initMobileToolbar();
      } else {
        const toolbar = document.getElementById('mobileToolbar');
        if (toolbar) toolbar.remove();
      }
    });

  </script>

  <!-- Slab Layout Module -->
  <script src="slab-layout.js"></script>
  <script>
    // Initialize Slab Layout when DOM is ready
    document.addEventListener('DOMContentLoaded', function() {
      if (window.SlabLayout) {
        window.SlabLayout.init();
        console.log('SlabLayout: Module initialized');
      }
    });

    // Add keyboard shortcut for Slab Layout (S key)
    document.addEventListener('keydown', function(e) {
      if (e.key === 's' && !e.ctrlKey && !e.metaKey && !e.altKey) {
        const target = e.target;
        const isInput = target.tagName === 'INPUT' || target.tagName === 'TEXTAREA' || target.isContentEditable;
        if (!isInput && window.SlabLayout) {
          e.preventDefault();
          window.SlabLayout.toggle();
        }
      }
    });
  </script>

  <!-- Messaging Panel Overlay -->
  <div class="messaging-panel-overlay" id="msgPanelOverlay" onclick="closeMessagingPanel()"></div>

  <!-- Messaging Panel -->
  <div class="messaging-panel" id="msgPanel">
    <div class="msg-panel-header">
      <div class="msg-panel-title">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"/>
        </svg>
        Messages
      </div>
      <button class="msg-panel-close" onclick="closeMessagingPanel()">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M18 6L6 18M6 6l12 12"/>
        </svg>
      </button>
    </div>
    <div class="msg-conversations">
      <div class="msg-search">
        <input type="text" class="msg-search-input" id="msgSearchInput" placeholder="Search messages..." oninput="filterMessages(this.value)">
      </div>
      <button class="msg-new-chat-btn" onclick="openNewChatModal()">
        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 5v14M5 12h14"/></svg>
        New Message
      </button>
      <div class="msg-conversation-list" id="msgConversationList">
        <div class="msg-empty-state" id="msgEmptyState">
          <div class="msg-empty-icon"></div>
          <div class="msg-empty-text">No messages yet</div>
          <div class="msg-empty-subtext">Start a conversation with your collaborators or clients</div>
        </div>
      </div>
    </div>
    <!-- Chat View -->
    <div class="msg-chat-view" id="msgChatView">
      <div class="msg-chat-header">
        <button class="msg-chat-back" onclick="closeChatView()">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M19 12H5M12 19l-7-7 7-7"/></svg>
        </button>
        <div class="msg-chat-recipient">
          <div class="msg-chat-recipient-name" id="msgChatRecipientName">Recipient</div>
          <div class="msg-chat-recipient-status" id="msgChatRecipientStatus">Last seen recently</div>
        </div>
      </div>
      <div class="msg-chat-messages" id="msgChatMessages"></div>
      <div class="msg-chat-input-area">
        <div class="msg-chat-input-wrapper">
          <textarea class="msg-chat-input" id="msgChatInput" placeholder="Type a message..." rows="1" onkeydown="handleMsgKeydown(event)"></textarea>
          <button class="msg-send-btn" onclick="sendDirectMessage()">
            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M22 2L11 13M22 2l-7 20-4-9-9-4 20-7z"/></svg>
          </button>
        </div>
      </div>
    </div>
    <!-- New Chat Modal -->
    <div class="msg-new-chat-modal" id="msgNewChatModal">
      <div class="msg-chat-header">
        <button class="msg-chat-back" onclick="closeNewChatModal()">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M19 12H5M12 19l-7-7 7-7"/></svg>
        </button>
        <div class="msg-chat-recipient">
          <div class="msg-chat-recipient-name">New Message</div>
          <div class="msg-chat-recipient-status">Select a recipient</div>
        </div>
      </div>
      <div class="msg-add-recipient">
        <label>Send to email address</label>
        <div class="msg-email-input-wrapper">
          <input type="email" class="msg-email-input" id="msgNewEmailInput" placeholder="email@example.com">
          <button class="msg-add-email-btn" onclick="startChatWithEmail()">Start Chat</button>
        </div>
      </div>
      <div class="msg-collaborators-section">
        <div class="msg-collaborators-title"><span></span> Or select from your network</div>
        <div class="msg-collaborator-list" id="msgCollaboratorList"></div>
      </div>
    </div>
  </div>

  <script>
    // ========== UNIFIED MESSAGING SYSTEM ==========
    // Connects: Notification Hub, CRM (customer_messages), Team Chat (design_chat_messages)
    // Features: Real-time sync, read receipts, email/collaborator chats, CRM integration
    let msgPanelOpen = false;
    let currentConversation = null;
    let conversations = [];
    let typingTimeout = null;
    let unreadMsgCount = 0;
    let msgSyncInterval = null;
    let msgSubscriptions = [];

    function toggleMessagingPanel() {
      msgPanelOpen ? closeMessagingPanel() : openMessagingPanel();
    }

    function openMessagingPanel() {
      msgPanelOpen = true;
      document.getElementById('msgPanel').classList.add('open');
      document.getElementById('msgPanelOverlay').classList.add('open');
      loadConversations();
      // Start periodic sync when panel is open
      if (!msgSyncInterval) {
        msgSyncInterval = setInterval(syncMessages, 30000);
      }
    }

    function closeMessagingPanel() {
      msgPanelOpen = false;
      document.getElementById('msgPanel').classList.remove('open');
      document.getElementById('msgPanelOverlay').classList.remove('open');
      closeChatView();
      closeNewChatModal();
      if (msgSyncInterval) {
        clearInterval(msgSyncInterval);
        msgSyncInterval = null;
      }
    }

    // Periodic sync for real-time feel
    async function syncMessages() {
      if (!msgPanelOpen || !currentUser) return;
      await loadConversations();
      if (currentConversation) {
        await loadMessages(currentConversation);
      }
    }

    // Sync with notification hub for unified badge counts
    function syncWithNotificationHub() {
      if (typeof NOTIFICATION_HUB !== 'undefined' && typeof updateHubBadge === 'function') {
        updateHubBadge();
      }
    }

    // Unified conversation loader - pulls from design_chat_messages AND customer_messages
    async function loadConversations() {
      if (!currentUser) { showMsgEmptyState('Sign in to view messages'); return; }
      try {
        const supabase = window._sgSupabaseClient;
        if (!supabase) return;
        conversations = [];

        // 1. Load design chat messages (team/collaborator chats)
        const { data: designChats } = await supabase.from('design_chat_messages').select('*').order('created_at', { ascending: false }).limit(100);
        if (designChats?.length > 0) {
          const groups = {};
          designChats.forEach(msg => { if (!groups[msg.design_id]) groups[msg.design_id] = []; groups[msg.design_id].push(msg); });
          Object.entries(groups).forEach(([designId, msgs]) => {
            const latest = msgs[0];
            const other = msgs.find(m => m.user_id !== currentUser.id);
            const unreadCount = msgs.filter(m => m.user_id !== currentUser.id && !m.read_at).length;
            conversations.push({
              id: `design_${designId}`,
              type: 'design',
              designId,
              name: other?.user_name || 'Design Chat',
              avatar: (other?.user_name || 'D').charAt(0).toUpperCase(),
              avatarType: 'collaborator',
              lastMessage: latest.message,
              lastMessageTime: latest.created_at,
              unread: unreadCount > 0,
              unreadCount,
              participants: [...new Set(msgs.map(m => m.user_name).filter(Boolean))]
            });
          });
        }

        // 2. Load customer messages (CRM/client chats)
        const { data: customerChats } = await supabase
          .from('customer_messages')
          .select('*')
          .or(`customer_id.eq.${currentUser.id},metadata->>designer_id.eq.${currentUser.id}`)
          .order('created_at', { ascending: false })
          .limit(100);

        if (customerChats?.length > 0) {
          const crmGroups = {};
          customerChats.forEach(msg => {
            const key = msg.thread_id || msg.customer_id || msg.metadata?.customer_email || msg.id;
            if (!crmGroups[key]) crmGroups[key] = [];
            crmGroups[key].push(msg);
          });
          Object.entries(crmGroups).forEach(([threadId, msgs]) => {
            const latest = msgs[0];
            const customerName = latest.metadata?.customer_name || latest.metadata?.author || 'Client';
            const customerEmail = latest.customer_email || latest.metadata?.customer_email;
            const unreadCount = msgs.filter(m => m.direction === 'inbound' && !m.read_at).length;
            if (conversations.find(c => c.email === customerEmail && c.type === 'customer')) return;
            conversations.push({
              id: `customer_${threadId}`,
              type: 'customer',
              threadId,
              customerId: latest.customer_id,
              email: customerEmail,
              name: customerName,
              avatar: customerName.charAt(0).toUpperCase(),
              avatarType: 'customer',
              lastMessage: latest.message,
              lastMessageTime: latest.created_at,
              unread: unreadCount > 0,
              unreadCount,
              channel: latest.channel || 'direct'
            });
          });
        }

        // Sort by most recent and calculate total unread
        conversations.sort((a, b) => new Date(b.lastMessageTime) - new Date(a.lastMessageTime));
        unreadMsgCount = conversations.reduce((sum, c) => sum + (c.unreadCount || 0), 0);
        renderConversations();
        updateMsgBadge();
        syncWithNotificationHub();
      } catch (err) { console.error('Error loading conversations:', err); showMsgEmptyState('Error loading messages'); }
    }

    function renderConversations() {
      const container = document.getElementById('msgConversationList');
      const empty = document.getElementById('msgEmptyState');
      if (conversations.length === 0) { empty.style.display = 'flex'; return; }
      empty.style.display = 'none';
      container.innerHTML = conversations.map(c => `
        <div class="msg-conversation-item ${c.unread ? 'unread' : ''}" onclick="openConversation('${c.id}')">
          <div class="msg-conv-avatar ${c.avatarType}">${c.avatar}</div>
          <div class="msg-conv-info">
            <div class="msg-conv-name">${escapeHtml(c.name)}<span class="role-tag">${c.type === 'customer' ? 'Client' : c.type === 'design' ? 'Team' : 'Contact'}</span></div>
            <div class="msg-conv-preview">${truncateText(c.lastMessage, 40)}</div>
          </div>
          <div class="msg-conv-meta">
            <div class="msg-conv-time">${formatMsgTime(c.lastMessageTime)}</div>
            ${c.unreadCount > 0 ? `<div class="msg-conv-unread-badge">${c.unreadCount > 9 ? '9+' : c.unreadCount}</div>` : ''}
          </div>
        </div>`).join('');
    }

    function showMsgEmptyState(text) { const el = document.getElementById('msgEmptyState'); el.innerHTML = `<div class="msg-empty-icon"></div><div class="msg-empty-text">${text}</div>`; el.style.display = 'flex'; }

    async function openConversation(convId) {
      currentConversation = conversations.find(c => c.id === convId);
      if (!currentConversation) return;
      document.getElementById('msgChatRecipientName').textContent = currentConversation.name;
      document.getElementById('msgChatRecipientStatus').textContent = currentConversation.email || 'Active';
      document.getElementById('msgChatView').classList.add('open');
      await loadMessages(currentConversation);
    }

    function closeChatView() { document.getElementById('msgChatView').classList.remove('open'); currentConversation = null; }

    async function loadMessages(conv) {
      const container = document.getElementById('msgChatMessages');
      container.innerHTML = '<div style="text-align:center;padding:20px;color:var(--text-muted)">Loading...</div>';
      try {
        const supabase = window._sgSupabaseClient;
        if (!supabase) return;
        let messages = [];

        if (conv.type === 'design') {
          const { data } = await supabase.from('design_chat_messages').select('*').eq('design_id', conv.designId).order('created_at', { ascending: true });
          messages = (data || []).map(m => ({
            id: m.id,
            text: m.message,
            time: m.created_at,
            isOutbound: m.user_id === currentUser?.id,
            senderName: m.user_name,
            read: !!m.read_at
          }));
        } else if (conv.type === 'customer') {
          const { data } = await supabase
            .from('customer_messages')
            .select('*')
            .or(`thread_id.eq.${conv.threadId},customer_id.eq.${conv.customerId}`)
            .order('created_at', { ascending: true });
          messages = (data || []).map(m => ({
            id: m.id,
            text: m.message,
            time: m.created_at,
            isOutbound: m.direction === 'outbound',
            senderName: m.direction === 'outbound' ? 'You' : (m.metadata?.author || 'Client'),
            read: !!m.read_at
          }));
        } else if (conv.type === 'email' || conv.type === 'collaborator') {
          // For new email/collaborator chats, check localStorage for cached messages
          const threadKey = `msg_thread_${conv.id}`;
          const stored = localStorage.getItem(threadKey);
          if (stored) {
            messages = JSON.parse(stored);
          }
        }

        renderMessages(messages);
        // Mark messages as read when conversation is opened
        markConversationRead(conv);
      } catch (err) { container.innerHTML = '<div style="text-align:center;padding:20px">Error loading messages</div>'; }
    }

    // Mark conversation as read
    async function markConversationRead(conv) {
      try {
        const supabase = window._sgSupabaseClient;
        if (!supabase || !conv) return;
        const now = new Date().toISOString();

        if (conv.type === 'design') {
          await supabase.from('design_chat_messages').update({ read_at: now }).eq('design_id', conv.designId).neq('user_id', currentUser?.id).is('read_at', null);
        } else if (conv.type === 'customer') {
          await supabase.from('customer_messages').update({ read_at: now }).eq('direction', 'inbound').or(`thread_id.eq.${conv.threadId},customer_id.eq.${conv.customerId}`).is('read_at', null);
        }

        // Update local state
        conv.unread = false;
        conv.unreadCount = 0;
        unreadMsgCount = conversations.reduce((sum, c) => sum + (c.unreadCount || 0), 0);
        updateMsgBadge();
        syncWithNotificationHub();
      } catch (err) { console.log('Mark read error:', err.message); }
    }

    function renderMessages(messages) {
      const container = document.getElementById('msgChatMessages');
      if (messages.length === 0) {
        container.innerHTML = '<div style="text-align:center;padding:40px;color:var(--text-muted)"><div style="font-size:32px;margin-bottom:12px"></div>Start the conversation!</div>';
        return;
      }
      const showSenderNames = messages.filter(x => !x.isOutbound).length > 1;
      container.innerHTML = messages.map(m => `
        <div class="msg-message-row ${m.isOutbound ? 'outbound' : 'inbound'}">
          <div class="msg-message-bubble">
            ${!m.isOutbound && showSenderNames && m.senderName ? `<div class="msg-sender-name">${escapeHtml(m.senderName)}</div>` : ''}
            ${escapeHtml(m.text)}
            <div class="msg-message-meta">
              <span class="msg-message-time">${formatMsgTime(m.time)}</span>
              ${m.isOutbound ? `<span class="msg-read-receipt">${m.read ? '' : ''}</span>` : ''}
            </div>
          </div>
        </div>`).join('');
      container.scrollTop = container.scrollHeight;
    }

    async function sendDirectMessage() {
      const input = document.getElementById('msgChatInput');
      const message = input.value.trim();
      if (!message || !currentConversation || !currentUser) return;
      input.value = '';

      const senderName = currentUser.user_metadata?.full_name || currentUser.email?.split('@')[0] || 'You';

      try {
        const supabase = window._sgSupabaseClient;

        if (currentConversation.type === 'design' && supabase) {
          await supabase.from('design_chat_messages').insert({
            design_id: currentConversation.designId,
            user_id: currentUser.id,
            user_name: senderName,
            message
          });
          await loadMessages(currentConversation);

        } else if (currentConversation.type === 'customer' && supabase) {
          await supabase.from('customer_messages').insert({
            customer_id: currentConversation.customerId,
            thread_id: currentConversation.threadId,
            customer_email: currentConversation.email,
            channel: 'direct',
            direction: 'outbound',
            message,
            metadata: { designer_id: currentUser.id, designer_name: senderName }
          });
          await loadMessages(currentConversation);

        } else if (currentConversation.type === 'email' || currentConversation.type === 'collaborator') {
          // Save to customer_messages for persistence
          if (supabase) {
            const { data: inserted } = await supabase.from('customer_messages').insert({
              customer_email: currentConversation.email,
              channel: 'direct',
              direction: 'outbound',
              message,
              metadata: { designer_id: currentUser.id, designer_name: senderName, customer_name: currentConversation.name, source: 'room_designer' }
            }).select().single();
            if (inserted) {
              currentConversation.type = 'customer';
              currentConversation.threadId = inserted.id;
            }
          }
          // Cache locally for immediate display
          const threadKey = `msg_thread_${currentConversation.id}`;
          let stored = JSON.parse(localStorage.getItem(threadKey) || '[]');
          stored.push({ id: Date.now(), text: message, time: new Date().toISOString(), isOutbound: true, senderName });
          localStorage.setItem(threadKey, JSON.stringify(stored));
          await loadMessages(currentConversation);
        }

        // Send email notification to recipient
        notifyRecipient(currentConversation, message);
        // Push to notification hub
        pushToNotificationHub(currentConversation, message, 'outbound');

      } catch (err) { console.error('Send error:', err); showToast('Failed to send message', 'error'); }
    }

    // Push message to notification hub for unified tracking
    function pushToNotificationHub(conv, message, direction) {
      if (typeof NOTIFICATION_HUB !== 'undefined' && direction === 'inbound') {
        NOTIFICATION_HUB.notifications.unshift({
          id: `msg_${Date.now()}`,
          type: conv.type === 'customer' ? 'chat' : 'team',
          source: conv.name,
          message: message,
          author: conv.name,
          time: new Date().toISOString(),
          read: false
        });
        if (typeof renderNotificationHub === 'function') renderNotificationHub();
        if (typeof updateHubBadge === 'function') updateHubBadge();
      }
    }

    async function notifyRecipient(conv, message) {
      try {
        const API_BASE = window.SG_CONFIG?.API_BASE || 'https://surprise-granite-email-api.onrender.com';
        await fetch(`${API_BASE}/api/email/notify`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ type: 'new_message', recipientEmail: conv.email, senderName: currentUser?.user_metadata?.full_name || 'Designer', message, link: window.location.href }) });
      } catch (e) { console.log('Notify skipped'); }
    }

    function handleMsgKeydown(e) { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); sendDirectMessage(); } }

    function openNewChatModal() { document.getElementById('msgNewChatModal').classList.add('open'); loadCollaboratorsForChat(); }
    function closeNewChatModal() { document.getElementById('msgNewChatModal').classList.remove('open'); }

    async function loadCollaboratorsForChat() {
      const container = document.getElementById('msgCollaboratorList');
      container.innerHTML = '<div style="text-align:center;padding:20px;color:var(--text-muted)">Loading...</div>';
      try {
        const API_BASE = window.SG_CONFIG?.API_BASE || 'https://surprise-granite-email-api.onrender.com';
        const token = await getAccessToken();
        const res = await fetch(`${API_BASE}/api/collaboration/my-collaborators`, { headers: { 'Authorization': token ? `Bearer ${token}` : '' } });
        const data = await res.json();
        const collabs = data.collaborators || [];
        if (collabs.length === 0) { container.innerHTML = '<div style="text-align:center;padding:20px;color:var(--text-muted)">No collaborators yet</div>'; return; }
        container.innerHTML = collabs.map(c => `<div class="msg-collaborator-item" onclick="startChatWithCollaborator('${c.id}','${escapeHtml(c.name || c.email)}','${c.email}')"><div class="msg-conv-avatar collaborator">${(c.name || c.email || '?').charAt(0).toUpperCase()}</div><div class="msg-conv-info"><div class="msg-conv-name">${c.name || c.email}</div><div class="msg-conv-preview">${c.role || 'Collaborator'}</div></div></div>`).join('');
      } catch (err) { container.innerHTML = '<div style="text-align:center;padding:20px">Error loading</div>'; }
    }

    function startChatWithEmail() {
      const email = document.getElementById('msgNewEmailInput').value.trim();
      if (!email || !email.includes('@')) { showToast('Enter a valid email', 'error'); return; }
      const conv = { id: `email_${Date.now()}`, type: 'email', email, name: email.split('@')[0], avatar: email.charAt(0).toUpperCase(), avatarType: 'collaborator', lastMessage: '', lastMessageTime: new Date().toISOString(), unread: false };
      conversations.unshift(conv);
      closeNewChatModal();
      openConversation(conv.id);
    }

    function startChatWithCollaborator(id, name, email) {
      const conv = { id: `collaborator_${id}`, type: 'collaborator', collaboratorId: id, email, name, avatar: name.charAt(0).toUpperCase(), avatarType: 'collaborator', lastMessage: '', lastMessageTime: new Date().toISOString(), unread: false };
      if (!conversations.find(c => c.id === conv.id)) conversations.unshift(conv);
      closeNewChatModal();
      openConversation(conv.id);
    }

    function updateMsgBadge() {
      const count = unreadMsgCount || conversations.filter(c => c.unread).length;
      const badge = document.getElementById('msgBadge');
      const btn = document.getElementById('msgHubBtn');
      if (count > 0) {
        badge.textContent = count > 9 ? '9+' : count;
        badge.classList.remove('hidden');
        btn.classList.add('has-messages');
      } else {
        badge.classList.add('hidden');
        btn.classList.remove('has-messages');
      }
    }

    function filterMessages(q) {
      const filtered = conversations.filter(c => c.name.toLowerCase().includes(q.toLowerCase()) || c.lastMessage.toLowerCase().includes(q.toLowerCase()));
      const container = document.getElementById('msgConversationList');
      if (filtered.length === 0) { container.innerHTML = '<div class="msg-empty-state" style="display:flex"><div class="msg-empty-icon"></div><div class="msg-empty-text">No matches</div></div>'; return; }
      container.innerHTML = filtered.map(c => `<div class="msg-conversation-item" onclick="openConversation('${c.id}')"><div class="msg-conv-avatar ${c.avatarType}">${c.avatar}</div><div class="msg-conv-info"><div class="msg-conv-name">${c.name}</div><div class="msg-conv-preview">${truncateText(c.lastMessage, 40)}</div></div></div>`).join('');
    }

    function formatMsgTime(d) { if (!d) return ''; const diff = Date.now() - new Date(d); const m = Math.floor(diff/60000); if (m < 1) return 'now'; if (m < 60) return m+'m'; const h = Math.floor(diff/3600000); if (h < 24) return h+'h'; return Math.floor(diff/86400000)+'d'; }
    function truncateText(t, l) { return t?.length > l ? t.substring(0, l) + '...' : t || ''; }
    function escapeHtml(t) { const d = document.createElement('div'); d.textContent = t || ''; return d.innerHTML; }
    async function getAccessToken() { try { const s = window._sgSupabaseClient; if (!s) return null; const { data: { session } } = await s.auth.getSession(); return session?.access_token; } catch { return null; } }

    // Real-time listeners for both message tables
    document.addEventListener('DOMContentLoaded', function() {
      const supabase = window._sgSupabaseClient;
      if (!supabase) return;

      // Listen to design_chat_messages
      const designChannel = supabase.channel('msg-design-updates')
        .on('postgres_changes', { event: 'INSERT', schema: 'public', table: 'design_chat_messages' }, (payload) => {
          handleNewMessage(payload.new, 'design');
        })
        .subscribe();
      msgSubscriptions.push(designChannel);

      // Listen to customer_messages
      const customerChannel = supabase.channel('msg-customer-updates')
        .on('postgres_changes', { event: 'INSERT', schema: 'public', table: 'customer_messages' }, (payload) => {
          if (payload.new.direction === 'inbound') {
            handleNewMessage(payload.new, 'customer');
          }
        })
        .subscribe();
      msgSubscriptions.push(customerChannel);
    });

    function handleNewMessage(msg, type) {
      // Reload conversations if panel is open
      if (msgPanelOpen) {
        loadConversations();
        // Reload current chat if it matches
        if (currentConversation) {
          if (type === 'design' && currentConversation.designId === msg.design_id) {
            loadMessages(currentConversation);
          } else if (type === 'customer' && (currentConversation.threadId === msg.thread_id || currentConversation.customerId === msg.customer_id)) {
            loadMessages(currentConversation);
          }
        }
      }

      // Update unread count
      unreadMsgCount++;
      updateMsgBadge();

      // Show toast for incoming messages (not from current user)
      const isFromMe = type === 'design' ? msg.user_id === currentUser?.id : msg.direction === 'outbound';
      if (!isFromMe) {
        showMsgToast(msg, type);
        pushToNotificationHub({ name: msg.user_name || msg.metadata?.author || 'Someone' }, msg.message, 'inbound');
      }
    }

    function showMsgToast(msg, type) {
      const senderName = type === 'design' ? (msg.user_name || 'Team Member') : (msg.metadata?.author || 'Client');
      const messageText = msg.message || '';

      const t = document.createElement('div');
      t.className = 'comment-notification-toast';
      t.innerHTML = `
        <div class="comment-notification-icon"></div>
        <div class="comment-notification-content">
          <div class="comment-notification-title">${escapeHtml(senderName)}</div>
          <div class="comment-notification-message">${truncateText(messageText, 50)}</div>
        </div>
        <button class="comment-notification-action" onclick="this.parentElement.remove();openMessagingPanel();">View</button>
      `;
      document.body.appendChild(t);
      setTimeout(() => t.classList.add('show'), 100);
      setTimeout(() => {
        t.classList.add('fade-out');
        setTimeout(() => t.remove(), 500);
      }, 5000);
    }

    // Initialize messaging unread count on page load
    window.addEventListener('load', function() {
      const user = window.SgAuth?.getUser();
      if (user) {
        loadConversations().then(() => {
          updateMsgBadge();
        }).catch(() => {});
      }
    });
  </script>

<script defer src="/js/designer-pro-features.js?v=20260129d"></script>
<script defer src="/js/remodely-hub.js?v=20260118"></script>
</body>
</html>
