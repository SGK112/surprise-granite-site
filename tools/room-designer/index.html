<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Room Designer Pro | Powered by Remodely.ai | Surprise Granite</title>
  <link rel="icon" href="https://cdn.prod.website-files.com/6456ce4476abb25581fbad0c/6456ce4476abb269c6fbb176_Surprise-Granite-favicon-32x32px.png">
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">

  <!-- Three.js for 3D -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

  <!-- Supabase -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

  <style>
    :root {
      --primary: #6366f1;
      --primary-dark: #4f46e5;
      --gold: #f9cb00;
      --gold-dark: #d4ab00;
      --dark: #0f0f1a;
      --dark-surface: #1a1a2e;
      --dark-elevated: #252540;
      --dark-hover: #2d2d4a;
      --text: #ffffff;
      --text-secondary: rgba(255,255,255,0.7);
      --text-muted: rgba(255,255,255,0.5);
      --border: rgba(255,255,255,0.1);
      --success: #10b981;
      --warning: #f59e0b;
      --error: #ef4444;
      --remodely-gradient: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    }

    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      font-family: 'Inter', -apple-system, sans-serif;
      background: var(--dark);
      color: var(--text);
      min-height: 100vh;
      overflow: hidden;
    }

    .app {
      height: 100vh;
      display: flex;
      flex-direction: column;
    }

    /* Header */
    .header {
      background: var(--dark-surface);
      border-bottom: 1px solid var(--border);
      padding: 0 20px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      height: 56px;
      flex-shrink: 0;
    }

    .header-left {
      display: flex;
      align-items: center;
      gap: 20px;
    }

    .logo-group {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .logo {
      display: flex;
      align-items: center;
      gap: 8px;
      text-decoration: none;
    }

    .logo img {
      height: 28px;
    }

    .logo-divider {
      width: 1px;
      height: 24px;
      background: var(--border);
    }

    .powered-by {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 11px;
      color: var(--text-muted);
    }

    .powered-by .remodely-badge {
      background: var(--remodely-gradient);
      padding: 3px 8px;
      border-radius: 4px;
      font-weight: 600;
      font-size: 10px;
      color: white;
    }

    .project-input {
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 6px 12px;
      color: var(--text);
      font-size: 14px;
      font-weight: 500;
      min-width: 200px;
    }

    .project-input:focus {
      outline: none;
      border-color: var(--primary);
    }

    .header-center {
      display: flex;
      gap: 4px;
      background: var(--dark-elevated);
      padding: 4px;
      border-radius: 8px;
    }

    .view-btn {
      padding: 8px 16px;
      background: transparent;
      border: none;
      color: var(--text-muted);
      font-size: 13px;
      font-weight: 500;
      cursor: pointer;
      border-radius: 6px;
      transition: all 0.2s;
    }

    .view-btn:hover {
      color: var(--text);
    }

    .view-btn.active {
      background: var(--primary);
      color: white;
    }

    .header-right {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .btn {
      padding: 8px 16px;
      border-radius: 6px;
      font-size: 13px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      gap: 6px;
      border: none;
    }

    .btn-secondary {
      background: var(--dark-elevated);
      color: var(--text);
      border: 1px solid var(--border);
    }

    .btn-secondary:hover {
      background: var(--dark-hover);
    }

    .btn-primary {
      background: var(--gold);
      color: #000;
    }

    .btn-primary:hover {
      background: var(--gold-dark);
    }

    .btn-sm {
      padding: 6px 10px;
      font-size: 11px;
    }

    /* Main Layout */
    .main {
      flex: 1;
      display: flex;
      overflow: hidden;
    }

    /* Sidebar */
    .sidebar {
      width: 220px;
      background: var(--dark-surface);
      border-right: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      flex-shrink: 0;
      overflow-y: auto;
    }

    .sidebar-section {
      border-bottom: 1px solid var(--border);
    }

    .sidebar-header {
      padding: 12px 16px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      cursor: pointer;
    }

    .sidebar-header:hover {
      background: var(--dark-hover);
    }

    .sidebar-title {
      font-size: 11px;
      font-weight: 600;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .sidebar-toggle {
      color: var(--text-muted);
      font-size: 10px;
    }

    .sidebar-content {
      padding: 0 12px 12px;
    }

    .sidebar-content.collapsed {
      display: none;
    }

    /* Floor Plans Grid */
    .floorplan-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 8px;
    }

    .floorplan-item {
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 10px;
      cursor: pointer;
      transition: all 0.2s;
      text-align: center;
    }

    .floorplan-item:hover {
      background: var(--dark-hover);
      border-color: var(--primary);
    }

    .floorplan-item.active {
      border-color: var(--primary);
      background: rgba(99, 102, 241, 0.15);
    }

    .floorplan-preview {
      width: 100%;
      height: 40px;
      margin-bottom: 6px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .floorplan-preview svg {
      width: 100%;
      height: 100%;
    }

    .floorplan-name {
      font-size: 10px;
      color: var(--text-secondary);
    }

    /* Tool Grid */
    .tool-grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 4px;
    }

    .tool-btn {
      aspect-ratio: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: var(--dark-elevated);
      border: 1px solid transparent;
      border-radius: 6px;
      color: var(--text-muted);
      cursor: pointer;
      transition: all 0.2s;
      padding: 6px;
    }

    .tool-btn:hover {
      background: var(--dark-hover);
      color: var(--text);
    }

    .tool-btn.active {
      background: var(--primary);
      color: white;
      border-color: var(--primary);
    }

    .tool-btn svg {
      width: 18px;
      height: 18px;
      margin-bottom: 2px;
    }

    .tool-btn span {
      font-size: 8px;
      font-weight: 500;
    }

    /* Element Grid */
    .element-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 6px;
    }

    .element-item {
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 8px;
      cursor: grab;
      transition: all 0.2s;
      text-align: center;
      position: relative;
    }

    .element-item:hover {
      background: var(--dark-hover);
      border-color: var(--primary);
    }

    .element-item:active {
      cursor: grabbing;
    }

    .element-item.has-texture {
      border-color: var(--success);
    }

    .element-icon {
      width: 32px;
      height: 32px;
      margin: 0 auto 4px;
      border-radius: 4px;
      background-size: cover;
      background-position: center;
    }

    .element-name {
      font-size: 9px;
      font-weight: 500;
      color: var(--text-secondary);
    }

    .element-upload-btn {
      position: absolute;
      top: 4px;
      right: 4px;
      width: 16px;
      height: 16px;
      background: var(--dark-surface);
      border: 1px solid var(--border);
      border-radius: 3px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      opacity: 0;
      transition: all 0.2s;
    }

    .element-item:hover .element-upload-btn {
      opacity: 1;
    }

    .element-upload-btn:hover {
      background: var(--primary);
      border-color: var(--primary);
    }

    .element-upload-btn svg {
      width: 10px;
      height: 10px;
      color: var(--text);
    }

    /* Materials Library */
    .materials-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 6px;
    }

    .material-item {
      aspect-ratio: 1;
      border-radius: 6px;
      cursor: pointer;
      border: 2px solid transparent;
      transition: all 0.2s;
      background-size: cover;
      background-position: center;
      position: relative;
    }

    .material-item:hover {
      border-color: var(--primary);
      transform: scale(1.05);
    }

    .material-item.selected {
      border-color: var(--gold);
    }

    .material-item::after {
      content: attr(data-name);
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      padding: 2px 4px;
      font-size: 8px;
      text-align: center;
      border-radius: 0 0 4px 4px;
    }

    /* Canvas Area */
    .canvas-area {
      flex: 1;
      display: flex;
      flex-direction: column;
      background: #12121f;
      position: relative;
      overflow: hidden;
    }

    .canvas-toolbar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 16px;
      background: var(--dark-surface);
      border-bottom: 1px solid var(--border);
      flex-shrink: 0;
    }

    .toolbar-group {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .zoom-controls {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .zoom-btn {
      width: 28px;
      height: 28px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      border-radius: 4px;
      color: var(--text);
      cursor: pointer;
      font-size: 14px;
    }

    .zoom-btn:hover {
      background: var(--dark-hover);
    }

    .zoom-level {
      font-size: 12px;
      color: var(--text-secondary);
      min-width: 40px;
      text-align: center;
    }

    .canvas-info {
      display: flex;
      gap: 16px;
      font-size: 11px;
      color: var(--text-muted);
    }

    .canvas-wrapper {
      flex: 1;
      position: relative;
      overflow: hidden;
      cursor: crosshair;
    }

    #canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }

    /* 3D View */
    #three-container {
      position: absolute;
      inset: 0;
      display: none;
    }

    #three-container.active {
      display: block;
    }

    /* Right Panel */
    .right-panel {
      width: 260px;
      background: var(--dark-surface);
      border-left: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      flex-shrink: 0;
      overflow-y: auto;
    }

    .panel-section {
      padding: 12px 16px;
      border-bottom: 1px solid var(--border);
    }

    .panel-title {
      font-size: 11px;
      font-weight: 600;
      color: var(--text-muted);
      text-transform: uppercase;
      margin-bottom: 10px;
    }

    .room-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 8px;
    }

    .input-group {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .input-label {
      font-size: 10px;
      color: var(--text-muted);
    }

    .input-field {
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      border-radius: 4px;
      padding: 6px 8px;
      color: var(--text);
      font-size: 12px;
    }

    .input-field:focus {
      outline: none;
      border-color: var(--primary);
    }

    select.input-field {
      cursor: pointer;
    }

    /* Properties Panel */
    .properties-empty {
      text-align: center;
      padding: 20px;
      color: var(--text-muted);
      font-size: 12px;
    }

    .property-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }

    .property-label {
      font-size: 11px;
      color: var(--text-secondary);
    }

    .property-input {
      width: 70px;
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      border-radius: 4px;
      padding: 5px 6px;
      color: var(--text);
      font-size: 11px;
      text-align: right;
    }

    .property-input:focus {
      outline: none;
      border-color: var(--primary);
    }

    .color-picker {
      width: 70px;
      height: 26px;
      border: 1px solid var(--border);
      border-radius: 4px;
      cursor: pointer;
      padding: 0;
    }

    .texture-preview {
      width: 70px;
      height: 40px;
      border-radius: 4px;
      background-size: cover;
      background-position: center;
      border: 1px solid var(--border);
      cursor: pointer;
    }

    .texture-preview:hover {
      border-color: var(--primary);
    }

    /* Quote Panel */
    .quote-section {
      flex: 1;
      display: flex;
      flex-direction: column;
      min-height: 0;
    }

    .quote-items {
      flex: 1;
      overflow-y: auto;
      padding: 0 16px;
    }

    .quote-item {
      display: flex;
      justify-content: space-between;
      padding: 8px 0;
      border-bottom: 1px solid var(--border);
      font-size: 11px;
    }

    .quote-item-name {
      color: var(--text-secondary);
    }

    .quote-item-value {
      color: var(--text);
      font-weight: 500;
    }

    .quote-total {
      padding: 12px 16px;
      background: var(--dark-elevated);
      border-top: 1px solid var(--border);
    }

    .quote-total-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .quote-total-label {
      font-size: 12px;
      font-weight: 600;
      color: var(--text);
    }

    .quote-total-value {
      font-size: 18px;
      font-weight: 700;
      color: var(--gold);
    }

    /* Context Menu */
    .context-menu {
      position: fixed;
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 6px 0;
      min-width: 160px;
      z-index: 1000;
      box-shadow: 0 8px 32px rgba(0,0,0,0.4);
    }

    .context-menu-item {
      padding: 8px 14px;
      font-size: 12px;
      color: var(--text-secondary);
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .context-menu-item:hover {
      background: var(--dark-hover);
      color: var(--text);
    }

    .context-menu-item.danger {
      color: var(--error);
    }

    .context-menu-item svg {
      width: 14px;
      height: 14px;
    }

    .context-menu-divider {
      height: 1px;
      background: var(--border);
      margin: 4px 0;
    }

    .context-menu-label {
      padding: 6px 14px;
      font-size: 10px;
      color: var(--text-muted);
      text-transform: uppercase;
      font-weight: 600;
    }

    /* Modals */
    .modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.7);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1001;
    }

    .modal-overlay.active {
      display: flex;
    }

    .modal {
      background: var(--dark-surface);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 20px;
      width: 100%;
      max-width: 500px;
      max-height: 80vh;
      overflow-y: auto;
    }

    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 16px;
    }

    .modal-title {
      font-size: 16px;
      font-weight: 600;
    }

    .modal-close {
      width: 28px;
      height: 28px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: var(--dark-elevated);
      border: none;
      border-radius: 4px;
      color: var(--text-muted);
      cursor: pointer;
      font-size: 18px;
    }

    .modal-close:hover {
      background: var(--dark-hover);
      color: var(--text);
    }

    /* Material Picker Modal */
    .material-categories {
      display: flex;
      gap: 8px;
      margin-bottom: 16px;
      flex-wrap: wrap;
    }

    .material-category-btn {
      padding: 6px 12px;
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      border-radius: 4px;
      color: var(--text-secondary);
      font-size: 11px;
      cursor: pointer;
    }

    .material-category-btn:hover {
      border-color: var(--primary);
    }

    .material-category-btn.active {
      background: var(--primary);
      border-color: var(--primary);
      color: white;
    }

    .materials-modal-grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 10px;
    }

    .material-modal-item {
      aspect-ratio: 1;
      border-radius: 8px;
      cursor: pointer;
      border: 2px solid transparent;
      background-size: cover;
      background-position: center;
      position: relative;
      overflow: hidden;
    }

    .material-modal-item:hover {
      border-color: var(--primary);
    }

    .material-modal-item.selected {
      border-color: var(--gold);
    }

    .material-modal-item .material-name {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.8);
      padding: 4px 6px;
      font-size: 9px;
      text-align: center;
    }

    .upload-material-btn {
      aspect-ratio: 1;
      border-radius: 8px;
      border: 2px dashed var(--border);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      color: var(--text-muted);
      gap: 4px;
    }

    .upload-material-btn:hover {
      border-color: var(--primary);
      color: var(--primary);
    }

    .upload-material-btn svg {
      width: 24px;
      height: 24px;
    }

    .upload-material-btn span {
      font-size: 9px;
    }

    /* Share Modal */
    .share-link-box {
      display: flex;
      gap: 8px;
      margin-bottom: 16px;
    }

    .share-link-input {
      flex: 1;
      background: var(--dark-elevated);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 10px 12px;
      color: var(--text);
      font-size: 12px;
    }

    .permission-options {
      display: flex;
      gap: 8px;
      margin-bottom: 16px;
    }

    .permission-btn {
      flex: 1;
      padding: 10px;
      background: var(--dark-elevated);
      border: 2px solid var(--border);
      border-radius: 6px;
      color: var(--text-secondary);
      cursor: pointer;
      text-align: center;
    }

    .permission-btn:hover {
      border-color: var(--primary);
    }

    .permission-btn.active {
      border-color: var(--primary);
      background: rgba(99, 102, 241, 0.1);
      color: var(--text);
    }

    .permission-btn-title {
      font-size: 12px;
      font-weight: 600;
      margin-bottom: 2px;
    }

    .permission-btn-desc {
      font-size: 10px;
      color: var(--text-muted);
    }

    /* Keyboard Shortcuts */
    .shortcuts-hint {
      position: fixed;
      bottom: 12px;
      right: 12px;
      background: var(--dark-surface);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 8px 12px;
      font-size: 9px;
      color: var(--text-muted);
      display: flex;
      gap: 12px;
    }

    .shortcut {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .shortcut kbd {
      background: var(--dark-elevated);
      padding: 2px 4px;
      border-radius: 3px;
      font-family: inherit;
      font-size: 9px;
    }

    /* Responsive */
    @media (max-width: 1200px) {
      .sidebar { width: 180px; }
      .right-panel { width: 220px; }
    }

    @media (max-width: 900px) {
      .sidebar, .right-panel { display: none; }
    }
  </style>
</head>
<body>
  <div class="app">
    <!-- Header -->
    <header class="header">
      <div class="header-left">
        <div class="logo-group">
          <a href="/" class="logo">
            <img src="https://cdn.prod.website-files.com/6456ce4476abb25581fbad0c/6456ce4476abb269c6fbb176_Surprise-Granite-favicon-32x32px.png" alt="Surprise Granite">
          </a>
          <div class="logo-divider"></div>
          <div class="powered-by">
            <span>Powered by</span>
            <span class="remodely-badge">Remodely.ai</span>
          </div>
        </div>
        <input type="text" class="project-input" id="projectName" value="Untitled Project" placeholder="Project name">
      </div>

      <div class="header-center">
        <button class="view-btn active" id="view2D" onclick="setView('2d')">2D Plan</button>
        <button class="view-btn" id="view3D" onclick="setView('3d')">3D View</button>
      </div>

      <div class="header-right">
        <button class="btn btn-secondary" onclick="openShareModal()">
          <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M4 12v8a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-8"/>
            <polyline points="16,6 12,2 8,6"/>
            <line x1="12" y1="2" x2="12" y2="15"/>
          </svg>
          Share
        </button>
        <button class="btn btn-primary" onclick="generateQuote()">
          <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
            <polyline points="14,2 14,8 20,8"/>
          </svg>
          Get Quote
        </button>
      </div>
    </header>

    <!-- Main Content -->
    <main class="main">
      <!-- Left Sidebar -->
      <aside class="sidebar">
        <!-- Floor Plans -->
        <div class="sidebar-section">
          <div class="sidebar-header" onclick="toggleSection(this)">
            <span class="sidebar-title">Floor Plans</span>
            <span class="sidebar-toggle">▼</span>
          </div>
          <div class="sidebar-content">
            <div class="floorplan-grid" id="floorplanGrid">
              <!-- Floor plans will be rendered here -->
            </div>
          </div>
        </div>

        <!-- Tools -->
        <div class="sidebar-section">
          <div class="sidebar-header" onclick="toggleSection(this)">
            <span class="sidebar-title">Tools</span>
            <span class="sidebar-toggle">▼</span>
          </div>
          <div class="sidebar-content">
            <div class="tool-grid">
              <button class="tool-btn active" id="toolSelect" onclick="setTool('select')" title="Select (V)">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M3 3l7.07 16.97 2.51-7.39 7.39-2.51L3 3z"/>
                </svg>
                <span>Select</span>
              </button>
              <button class="tool-btn" id="toolWall" onclick="setTool('wall')" title="Draw Wall (W)">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <rect x="3" y="3" width="18" height="18" rx="2"/>
                </svg>
                <span>Wall</span>
              </button>
              <button class="tool-btn" id="toolPan" onclick="setTool('pan')" title="Pan (H)">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M18 11V6a2 2 0 0 0-2-2a2 2 0 0 0-2 2"/>
                  <path d="M14 10V4a2 2 0 0 0-2-2a2 2 0 0 0-2 2v2"/>
                  <path d="M10 10.5V6a2 2 0 0 0-2-2a2 2 0 0 0-2 2v8"/>
                  <path d="M18 8a2 2 0 1 1 4 0v6a8 8 0 0 1-8 8h-2c-2.8 0-4.5-.86-5.99-2.34l-3.6-3.6a2 2 0 0 1 2.83-2.82L7 15"/>
                </svg>
                <span>Pan</span>
              </button>
              <button class="tool-btn" id="toolMeasure" onclick="setTool('measure')" title="Measure (M)">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M21.3 8.7 8.7 21.3c-1 1-2.5 1-3.4 0l-2.6-2.6c-1-1-1-2.5 0-3.4L15.3 2.7c1-1 2.5-1 3.4 0l2.6 2.6c1 1 1 2.5 0 3.4Z"/>
                </svg>
                <span>Measure</span>
              </button>
            </div>
          </div>
        </div>

        <!-- Cabinets -->
        <div class="sidebar-section">
          <div class="sidebar-header" onclick="toggleSection(this)">
            <span class="sidebar-title">Cabinets</span>
            <span class="sidebar-toggle">▼</span>
          </div>
          <div class="sidebar-content">
            <div class="element-grid" id="cabinetsGrid">
              <!-- Elements rendered by JS -->
            </div>
          </div>
        </div>

        <!-- Surfaces -->
        <div class="sidebar-section">
          <div class="sidebar-header" onclick="toggleSection(this)">
            <span class="sidebar-title">Surfaces</span>
            <span class="sidebar-toggle">▼</span>
          </div>
          <div class="sidebar-content">
            <div class="element-grid" id="surfacesGrid">
              <!-- Elements rendered by JS -->
            </div>
          </div>
        </div>

        <!-- Appliances -->
        <div class="sidebar-section">
          <div class="sidebar-header" onclick="toggleSection(this)">
            <span class="sidebar-title">Appliances</span>
            <span class="sidebar-toggle">▼</span>
          </div>
          <div class="sidebar-content">
            <div class="element-grid" id="appliancesGrid">
              <!-- Elements rendered by JS -->
            </div>
          </div>
        </div>

        <!-- Structure -->
        <div class="sidebar-section">
          <div class="sidebar-header" onclick="toggleSection(this)">
            <span class="sidebar-title">Structure</span>
            <span class="sidebar-toggle">▼</span>
          </div>
          <div class="sidebar-content">
            <div class="element-grid" id="structureGrid">
              <!-- Elements rendered by JS -->
            </div>
          </div>
        </div>
      </aside>

      <!-- Canvas Area -->
      <div class="canvas-area">
        <div class="canvas-toolbar">
          <div class="toolbar-group">
            <div class="zoom-controls">
              <button class="zoom-btn" onclick="zoomOut()">−</button>
              <span class="zoom-level" id="zoomLevel">100%</span>
              <button class="zoom-btn" onclick="zoomIn()">+</button>
              <button class="zoom-btn" onclick="fitToScreen()" title="Fit to screen">⊡</button>
            </div>
            <button class="btn btn-sm btn-secondary" onclick="clearCanvas()">Clear</button>
          </div>
          <div class="canvas-info">
            <span id="canvasSize">12' × 10'</span>
            <span id="elementCount">0 elements</span>
          </div>
        </div>
        <div class="canvas-wrapper" id="canvasWrapper">
          <canvas id="canvas"></canvas>
        </div>
        <div id="three-container"></div>
      </div>

      <!-- Right Panel -->
      <aside class="right-panel">
        <div class="panel-section">
          <div class="panel-title">Room Settings</div>
          <div class="room-grid">
            <div class="input-group">
              <label class="input-label">Room Type</label>
              <select class="input-field" id="roomType" onchange="updateRoom()">
                <option value="kitchen">Kitchen</option>
                <option value="bathroom">Bathroom</option>
                <option value="laundry">Laundry</option>
                <option value="bedroom">Bedroom</option>
                <option value="living">Living Room</option>
                <option value="office">Office</option>
                <option value="commercial">Commercial</option>
              </select>
            </div>
            <div class="input-group">
              <label class="input-label">Width (ft)</label>
              <input type="number" class="input-field" id="roomWidth" value="20" min="8" max="100" onchange="updateRoom()">
            </div>
            <div class="input-group">
              <label class="input-label">Depth (ft)</label>
              <input type="number" class="input-field" id="roomDepth" value="16" min="8" max="100" onchange="updateRoom()">
            </div>
            <div class="input-group">
              <label class="input-label">Scale</label>
              <select class="input-field" id="scaleMode" onchange="updateScale()">
                <option value="fit">Fit to Screen</option>
                <option value="40">40 px/ft</option>
                <option value="50">50 px/ft</option>
                <option value="60">60 px/ft</option>
              </select>
            </div>
          </div>
        </div>

        <div class="panel-section" id="propertiesPanel">
          <div class="panel-title">Properties</div>
          <div class="properties-empty" id="propertiesEmpty">
            Select an element to edit
          </div>
          <div id="propertiesContent" style="display: none;">
            <div class="property-row">
              <span class="property-label">Type</span>
              <span class="property-value" id="propType">-</span>
            </div>
            <div class="property-row">
              <span class="property-label">Width (ft)</span>
              <input type="number" class="property-input" id="propWidth" step="0.5" min="0.5" max="30" onchange="updateSelectedElement()">
            </div>
            <div class="property-row">
              <span class="property-label">Depth (ft)</span>
              <input type="number" class="property-input" id="propHeight" step="0.5" min="0.5" max="30" onchange="updateSelectedElement()">
            </div>
            <div class="property-row">
              <span class="property-label">Color</span>
              <input type="color" class="color-picker" id="propColor" onchange="updateSelectedElement()">
            </div>
            <div class="property-row">
              <span class="property-label">Texture</span>
              <div class="texture-preview" id="propTexture" onclick="openMaterialPicker()" title="Click to change texture"></div>
            </div>
            <div class="property-row">
              <span class="property-label">Rotation</span>
              <span class="property-value" id="propRotation">0°</span>
            </div>
          </div>
        </div>

        <div class="quote-section">
          <div class="panel-section">
            <div class="panel-title">Quote Summary</div>
          </div>
          <div class="quote-items" id="quoteItems">
            <div class="quote-item">
              <span class="quote-item-name">No items yet</span>
              <span class="quote-item-value">$0</span>
            </div>
          </div>
          <div class="quote-total">
            <div class="quote-total-row">
              <span class="quote-total-label">Estimated Total</span>
              <span class="quote-total-value" id="quoteTotal">$0</span>
            </div>
          </div>
        </div>
      </aside>
    </main>
  </div>

  <!-- Context Menu -->
  <div class="context-menu" id="contextMenu" style="display: none;">
    <div class="context-menu-label" id="contextMenuLabel">Element</div>
    <div class="context-menu-item" onclick="contextAction('rotate')">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <path d="M21 2v6h-6"/><path d="M3 12a9 9 0 0 1 15-6.7L21 8"/>
      </svg>
      Rotate 90°
    </div>
    <div class="context-menu-item" onclick="contextAction('duplicate')">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <rect x="9" y="9" width="13" height="13" rx="2"/><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/>
      </svg>
      Duplicate
    </div>
    <div class="context-menu-item" onclick="contextAction('texture')">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <rect x="3" y="3" width="18" height="18" rx="2"/><circle cx="8.5" cy="8.5" r="1.5"/><path d="M21 15l-5-5L5 21"/>
      </svg>
      Change Texture
    </div>
    <div class="context-menu-item" onclick="contextAction('lock')">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <rect x="3" y="11" width="18" height="11" rx="2"/><path d="M7 11V7a5 5 0 0 1 10 0v4"/>
      </svg>
      <span id="lockText">Lock</span>
    </div>
    <div class="context-menu-divider"></div>
    <div class="context-menu-item" onclick="contextAction('front')">Bring to Front</div>
    <div class="context-menu-item" onclick="contextAction('back')">Send to Back</div>
    <div class="context-menu-divider"></div>
    <div class="context-menu-item danger" onclick="contextAction('delete')">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/>
      </svg>
      Delete
    </div>
  </div>

  <!-- Share Modal -->
  <div class="modal-overlay" id="shareModal">
    <div class="modal">
      <div class="modal-header">
        <h3 class="modal-title">Share Project</h3>
        <button class="modal-close" onclick="closeModal('shareModal')">×</button>
      </div>
      <div class="share-link-box">
        <input type="text" class="share-link-input" id="shareLink" readonly>
        <button class="btn btn-primary" onclick="copyShareLink()">Copy</button>
      </div>
      <div class="permission-options">
        <div class="permission-btn active" onclick="setSharePermission('view', this)">
          <div class="permission-btn-title">View Only</div>
          <div class="permission-btn-desc">Can view but not edit</div>
        </div>
        <div class="permission-btn" onclick="setSharePermission('edit', this)">
          <div class="permission-btn-title">Can Edit</div>
          <div class="permission-btn-desc">Full editing access</div>
        </div>
      </div>
    </div>
  </div>

  <!-- Material Picker Modal -->
  <div class="modal-overlay" id="materialModal">
    <div class="modal" style="max-width: 600px;">
      <div class="modal-header">
        <h3 class="modal-title">Choose Material</h3>
        <button class="modal-close" onclick="closeModal('materialModal')">×</button>
      </div>
      <div class="material-categories" id="materialCategories">
        <!-- Categories rendered by JS -->
      </div>
      <div class="materials-modal-grid" id="materialsGrid">
        <!-- Materials rendered by JS -->
      </div>
    </div>
  </div>

  <!-- Hidden file input -->
  <input type="file" id="materialUpload" accept="image/*" style="display: none" onchange="handleMaterialUpload(event)">

  <!-- Keyboard Shortcuts -->
  <div class="shortcuts-hint">
    <div class="shortcut"><kbd>V</kbd> Select</div>
    <div class="shortcut"><kbd>W</kbd> Wall</div>
    <div class="shortcut"><kbd>Del</kbd> Delete</div>
    <div class="shortcut"><kbd>R</kbd> Rotate</div>
    <div class="shortcut"><kbd>Ctrl+D</kbd> Duplicate</div>
  </div>

  <script>
    // ===== CONFIGURATION =====
    const CONFIG = {
      MIN_PIXELS_PER_FOOT: 20,
      DEFAULT_PIXELS_PER_FOOT: 40,
      GRID_SUBDIVISIONS: 2,
      WALL_THICKNESS: 6,
      PRICING: {
        'base-cabinet': 150,
        'wall-cabinet': 120,
        'tall-cabinet': 300,
        'corner-cabinet': 200,
        'island': 400,
        'countertop': 65,
        'backsplash': 25,
        'flooring': 8,
        'tile': 15,
        'sink': 350,
        'stove': 800,
        'refrigerator': 1200,
        'dishwasher': 600,
        'door': 200,
        'window': 300,
        'wall': 0
      }
    };

    const ELEMENT_TYPES = {
      cabinets: [
        { type: 'base-cabinet', width: 3, height: 2, color: '#8B4513', label: 'Base Cabinet' },
        { type: 'wall-cabinet', width: 3, height: 1.5, color: '#A0522D', label: 'Wall Cabinet' },
        { type: 'tall-cabinet', width: 2, height: 7, color: '#8B4513', label: 'Tall Cabinet' },
        { type: 'island', width: 6, height: 3, color: '#654321', label: 'Island' }
      ],
      surfaces: [
        { type: 'countertop', width: 8, height: 2, color: '#708090', label: 'Countertop' },
        { type: 'backsplash', width: 6, height: 1.5, color: '#B8860B', label: 'Backsplash' },
        { type: 'flooring', width: 5, height: 5, color: '#D2691E', label: 'Flooring' },
        { type: 'tile', width: 4, height: 4, color: '#CCC', label: 'Tile Area' }
      ],
      appliances: [
        { type: 'sink', width: 2.5, height: 2, color: '#C0C0C0', label: 'Sink' },
        { type: 'stove', width: 2.5, height: 2.5, color: '#2F2F2F', label: 'Stove/Range' },
        { type: 'refrigerator', width: 3, height: 3, color: '#A9A9A9', label: 'Refrigerator' },
        { type: 'dishwasher', width: 2, height: 2, color: '#808080', label: 'Dishwasher' }
      ],
      structure: [
        { type: 'door', width: 3, height: 0.5, color: '#DEB887', label: 'Door' },
        { type: 'window', width: 4, height: 0.5, color: '#87CEEB', label: 'Window' },
        { type: 'wall', width: 0.5, height: 8, color: '#555', label: 'Wall' }
      ]
    };

    const FLOOR_PLANS = [
      { id: 'empty', name: 'Empty', walls: [] },
      { id: 'square', name: 'Square', walls: [
        { x: 0, y: 0, w: 1, h: 1, type: 'full' }
      ]},
      { id: 'l-shape', name: 'L-Shape', walls: [
        { x: 0, y: 0, w: 0.6, h: 1, type: 'rect' },
        { x: 0, y: 0, w: 1, h: 0.5, type: 'rect' }
      ]},
      { id: 'u-shape', name: 'U-Shape', walls: [
        { x: 0, y: 0, w: 0.3, h: 1, type: 'rect' },
        { x: 0.7, y: 0, w: 0.3, h: 1, type: 'rect' },
        { x: 0, y: 0.7, w: 1, h: 0.3, type: 'rect' }
      ]},
      { id: 'galley', name: 'Galley', walls: [
        { x: 0, y: 0, w: 0.2, h: 1, type: 'rect' },
        { x: 0.8, y: 0, w: 0.2, h: 1, type: 'rect' }
      ]},
      { id: 'open', name: 'Open Plan', walls: [
        { x: 0, y: 0.7, w: 0.4, h: 0.3, type: 'rect' }
      ]}
    ];

    // Sample materials library
    const MATERIALS = {
      granite: [
        { id: 'granite-black', name: 'Black Galaxy', color: '#1a1a1a', url: 'https://images.unsplash.com/photo-1558618666-fcd25c85cd64?w=200' },
        { id: 'granite-white', name: 'White Ice', color: '#f5f5f5', url: 'https://images.unsplash.com/photo-1615971677499-5467cbab01c0?w=200' },
        { id: 'granite-gold', name: 'Santa Cecilia', color: '#d4a574', url: 'https://images.unsplash.com/photo-1600585152220-90363fe7e115?w=200' }
      ],
      quartz: [
        { id: 'quartz-white', name: 'Pure White', color: '#ffffff', url: '' },
        { id: 'quartz-grey', name: 'Grey Expo', color: '#888888', url: '' },
        { id: 'quartz-calc', name: 'Calacatta', color: '#f8f6f0', url: '' }
      ],
      wood: [
        { id: 'wood-oak', name: 'Oak', color: '#b8860b', url: '' },
        { id: 'wood-walnut', name: 'Walnut', color: '#5d4037', url: '' },
        { id: 'wood-maple', name: 'Maple', color: '#deb887', url: '' },
        { id: 'wood-cherry', name: 'Cherry', color: '#8b4513', url: '' }
      ],
      tile: [
        { id: 'tile-white', name: 'White Subway', color: '#ffffff', url: '' },
        { id: 'tile-marble', name: 'Marble Look', color: '#e8e8e8', url: '' },
        { id: 'tile-slate', name: 'Slate Grey', color: '#708090', url: '' }
      ],
      flooring: [
        { id: 'floor-lvp', name: 'LVP Oak', color: '#c4a76c', url: '' },
        { id: 'floor-tile', name: 'Porcelain', color: '#d4c4b0', url: '' },
        { id: 'floor-hard', name: 'Hardwood', color: '#8b6914', url: '' }
      ]
    };

    // ===== STATE =====
    let canvas, ctx;
    let currentTool = 'select';
    let currentView = '2d';
    let zoom = 1;
    let pixelsPerFoot = 40;
    let elements = [];
    let walls = [];
    let selectedElement = null;
    let isDragging = false;
    let dragOffset = { x: 0, y: 0 };
    let roomWidth = 20;
    let roomDepth = 16;
    let currentFloorPlan = 'empty';
    let contextMenuElement = null;
    let elementTextures = {}; // Store custom textures for element types
    let customMaterials = []; // User uploaded materials

    // Pan offset (for infinite canvas navigation)
    let panX = 0;
    let panY = 0;
    let isPanning = false;
    let panStart = { x: 0, y: 0 };

    // Wall drawing
    let isDrawingWall = false;
    let wallStart = null;

    // Three.js
    let scene, camera, renderer, controls;

    // ===== INITIALIZATION =====
    document.addEventListener('DOMContentLoaded', init);

    function init() {
      canvas = document.getElementById('canvas');
      ctx = canvas.getContext('2d');

      renderSidebar();
      renderFloorPlans();
      setupEventListeners();
      setupDragDrop();
      fitToScreen();
    }

    function renderSidebar() {
      // Render element grids
      ['cabinets', 'surfaces', 'appliances', 'structure'].forEach(category => {
        const grid = document.getElementById(category + 'Grid');
        if (!grid) return;

        grid.innerHTML = ELEMENT_TYPES[category].map(el => `
          <div class="element-item ${elementTextures[el.type] ? 'has-texture' : ''}"
               draggable="true"
               data-type="${el.type}"
               data-category="${category}">
            <div class="element-icon" style="background: ${elementTextures[el.type] ? `url(${elementTextures[el.type]})` : el.color}; background-size: cover;"></div>
            <div class="element-name">${el.label}</div>
            <div class="element-upload-btn" onclick="event.stopPropagation(); uploadElementTexture('${el.type}')" title="Upload texture">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                <polyline points="17 8 12 3 7 8"/>
                <line x1="12" y1="3" x2="12" y2="15"/>
              </svg>
            </div>
          </div>
        `).join('');
      });
    }

    function renderFloorPlans() {
      const grid = document.getElementById('floorplanGrid');
      grid.innerHTML = FLOOR_PLANS.map(fp => `
        <div class="floorplan-item ${currentFloorPlan === fp.id ? 'active' : ''}"
             onclick="selectFloorPlan('${fp.id}')">
          <div class="floorplan-preview">
            ${getFloorPlanSVG(fp)}
          </div>
          <div class="floorplan-name">${fp.name}</div>
        </div>
      `).join('');
    }

    function getFloorPlanSVG(fp) {
      if (fp.id === 'empty') {
        return `<svg viewBox="0 0 40 30"><rect x="2" y="2" width="36" height="26" fill="none" stroke="#666" stroke-width="1" stroke-dasharray="2"/></svg>`;
      }
      if (fp.id === 'square') {
        return `<svg viewBox="0 0 40 30"><rect x="2" y="2" width="36" height="26" fill="#333" stroke="#666" stroke-width="1"/></svg>`;
      }
      if (fp.id === 'l-shape') {
        return `<svg viewBox="0 0 40 30"><path d="M2 2 H26 V15 H15 V28 H2 Z" fill="#333" stroke="#666" stroke-width="1"/></svg>`;
      }
      if (fp.id === 'u-shape') {
        return `<svg viewBox="0 0 40 30"><path d="M2 2 H12 V20 H28 V2 H38 V28 H2 Z" fill="#333" stroke="#666" stroke-width="1"/></svg>`;
      }
      if (fp.id === 'galley') {
        return `<svg viewBox="0 0 40 30"><rect x="2" y="2" width="8" height="26" fill="#333" stroke="#666"/><rect x="30" y="2" width="8" height="26" fill="#333" stroke="#666"/></svg>`;
      }
      if (fp.id === 'open') {
        return `<svg viewBox="0 0 40 30"><rect x="2" y="2" width="36" height="26" fill="none" stroke="#666" stroke-dasharray="2"/><rect x="2" y="18" width="16" height="10" fill="#333" stroke="#666"/></svg>`;
      }
      return `<svg viewBox="0 0 40 30"><rect x="2" y="2" width="36" height="26" fill="none" stroke="#666"/></svg>`;
    }

    function selectFloorPlan(id) {
      currentFloorPlan = id;
      const plan = FLOOR_PLANS.find(p => p.id === id);

      // Clear existing walls
      walls = [];

      // Add walls based on floor plan
      if (plan && plan.walls) {
        plan.walls.forEach(w => {
          if (w.type === 'full') {
            // Full room walls
            addWall(0, 0, roomWidth * pixelsPerFoot, CONFIG.WALL_THICKNESS);
            addWall(0, 0, CONFIG.WALL_THICKNESS, roomDepth * pixelsPerFoot);
            addWall(0, roomDepth * pixelsPerFoot - CONFIG.WALL_THICKNESS, roomWidth * pixelsPerFoot, CONFIG.WALL_THICKNESS);
            addWall(roomWidth * pixelsPerFoot - CONFIG.WALL_THICKNESS, 0, CONFIG.WALL_THICKNESS, roomDepth * pixelsPerFoot);
          } else if (w.type === 'rect') {
            const x = w.x * roomWidth * pixelsPerFoot;
            const y = w.y * roomDepth * pixelsPerFoot;
            const width = w.w * roomWidth * pixelsPerFoot;
            const height = w.h * roomDepth * pixelsPerFoot;
            // Add as a filled area indicator
            walls.push({ x, y, width, height, type: 'area' });
          }
        });
      }

      renderFloorPlans();
      draw();
    }

    function addWall(x, y, width, height) {
      walls.push({
        id: Date.now() + Math.random(),
        x, y, width, height,
        type: 'wall',
        color: '#444'
      });
    }

    function fitToScreen() {
      const wrapper = document.getElementById('canvasWrapper');
      const padding = 80;
      const availableWidth = wrapper.clientWidth - padding;
      const availableHeight = wrapper.clientHeight - padding;

      const scaleX = availableWidth / roomWidth;
      const scaleY = availableHeight / roomDepth;

      pixelsPerFoot = Math.min(scaleX, scaleY, 80);
      pixelsPerFoot = Math.max(pixelsPerFoot, CONFIG.MIN_PIXELS_PER_FOOT);

      // Center the room in the canvas
      panX = (wrapper.clientWidth - roomWidth * pixelsPerFoot) / 2;
      panY = (wrapper.clientHeight - roomDepth * pixelsPerFoot) / 2;

      document.getElementById('scaleMode').value = 'fit';
      updateCanvasSize();
    }

    function updateScale() {
      const mode = document.getElementById('scaleMode').value;
      if (mode === 'fit') {
        fitToScreen();
      } else {
        pixelsPerFoot = parseInt(mode);
        // Re-center when changing scale
        const wrapper = document.getElementById('canvasWrapper');
        panX = (wrapper.clientWidth - roomWidth * pixelsPerFoot) / 2;
        panY = (wrapper.clientHeight - roomDepth * pixelsPerFoot) / 2;
        updateCanvasSize();
      }
    }

    function updateCanvasSize() {
      const wrapper = document.getElementById('canvasWrapper');

      // Canvas fills entire workspace
      canvas.width = wrapper.clientWidth;
      canvas.height = wrapper.clientHeight;

      document.getElementById('canvasSize').textContent = `${roomWidth}' × ${roomDepth}'`;

      draw();
    }

    function setupEventListeners() {
      canvas.addEventListener('mousedown', onMouseDown);
      canvas.addEventListener('mousemove', onMouseMove);
      canvas.addEventListener('mouseup', onMouseUp);
      canvas.addEventListener('mouseleave', onMouseUp);
      canvas.addEventListener('contextmenu', onContextMenu);
      canvas.addEventListener('dblclick', onDoubleClick);
      canvas.addEventListener('wheel', onWheel, { passive: false });

      document.addEventListener('keydown', onKeyDown);
      document.addEventListener('keyup', onKeyUp);

      document.addEventListener('click', (e) => {
        if (!e.target.closest('.context-menu')) {
          hideContextMenu();
        }
      });

      window.addEventListener('resize', () => {
        updateCanvasSize();
        if (document.getElementById('scaleMode').value === 'fit') {
          fitToScreen();
        }
      });
    }

    function setupDragDrop() {
      document.addEventListener('dragstart', (e) => {
        if (e.target.classList.contains('element-item')) {
          e.dataTransfer.setData('element-type', e.target.dataset.type);
          e.target.style.opacity = '0.5';
        }
      });

      document.addEventListener('dragend', (e) => {
        if (e.target.classList.contains('element-item')) {
          e.target.style.opacity = '1';
        }
      });

      canvas.addEventListener('dragover', (e) => e.preventDefault());
      canvas.addEventListener('drop', onDrop);
    }

    // ===== DRAWING =====
    function draw() {
      if (!ctx) return;

      // Clear entire canvas with dark background
      ctx.fillStyle = '#0d0d15';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Apply pan transformation
      ctx.save();
      ctx.translate(panX, panY);

      // Draw infinite grid
      drawGrid();

      // Draw room boundary (the actual room shape)
      drawRoomBoundary();

      // Draw floor plan areas
      drawFloorPlanAreas();

      // Draw walls
      drawWalls();

      // Draw elements
      drawElements();

      ctx.restore();

      document.getElementById('elementCount').textContent = `${elements.length} element${elements.length !== 1 ? 's' : ''}`;
      calculateQuote();
    }

    function drawGrid() {
      const gridSize = pixelsPerFoot / CONFIG.GRID_SUBDIVISIONS;
      const roomW = roomWidth * pixelsPerFoot;
      const roomH = roomDepth * pixelsPerFoot;

      // Calculate visible area for grid
      const startX = -panX - pixelsPerFoot;
      const startY = -panY - pixelsPerFoot;
      const endX = canvas.width - panX + pixelsPerFoot;
      const endY = canvas.height - panY + pixelsPerFoot;

      // Sub-grid (faint lines)
      ctx.strokeStyle = 'rgba(255,255,255,0.02)';
      ctx.lineWidth = 1;

      const gridStartX = Math.floor(startX / gridSize) * gridSize;
      const gridStartY = Math.floor(startY / gridSize) * gridSize;

      for (let x = gridStartX; x < endX; x += gridSize) {
        ctx.beginPath();
        ctx.moveTo(x, startY);
        ctx.lineTo(x, endY);
        ctx.stroke();
      }
      for (let y = gridStartY; y < endY; y += gridSize) {
        ctx.beginPath();
        ctx.moveTo(startX, y);
        ctx.lineTo(endX, y);
        ctx.stroke();
      }

      // Main grid (1ft lines)
      ctx.strokeStyle = 'rgba(255,255,255,0.06)';
      const mainStartX = Math.floor(startX / pixelsPerFoot) * pixelsPerFoot;
      const mainStartY = Math.floor(startY / pixelsPerFoot) * pixelsPerFoot;

      for (let x = mainStartX; x < endX; x += pixelsPerFoot) {
        ctx.beginPath();
        ctx.moveTo(x, startY);
        ctx.lineTo(x, endY);
        ctx.stroke();
      }
      for (let y = mainStartY; y < endY; y += pixelsPerFoot) {
        ctx.beginPath();
        ctx.moveTo(startX, y);
        ctx.lineTo(endX, y);
        ctx.stroke();
      }
    }

    function drawRoomBoundary() {
      const roomW = roomWidth * pixelsPerFoot;
      const roomH = roomDepth * pixelsPerFoot;

      // Room floor (lighter area)
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, roomW, roomH);

      // Room border with measurements
      ctx.strokeStyle = '#4a4a6a';
      ctx.lineWidth = 3;
      ctx.strokeRect(0, 0, roomW, roomH);

      // Corner markers
      const markerSize = 12;
      ctx.fillStyle = '#6366f1';
      ctx.fillRect(-markerSize/2, -markerSize/2, markerSize, markerSize);
      ctx.fillRect(roomW - markerSize/2, -markerSize/2, markerSize, markerSize);
      ctx.fillRect(-markerSize/2, roomH - markerSize/2, markerSize, markerSize);
      ctx.fillRect(roomW - markerSize/2, roomH - markerSize/2, markerSize, markerSize);

      // Dimension labels along edges
      ctx.fillStyle = 'rgba(255,255,255,0.6)';
      ctx.font = `bold ${Math.max(12, pixelsPerFoot / 3)}px Inter`;
      ctx.textAlign = 'center';

      // Top dimension
      ctx.fillText(`${roomWidth}'`, roomW / 2, -10);
      // Left dimension
      ctx.save();
      ctx.translate(-10, roomH / 2);
      ctx.rotate(-Math.PI / 2);
      ctx.fillText(`${roomDepth}'`, 0, 0);
      ctx.restore();

      // Foot markers along room edges
      ctx.fillStyle = 'rgba(255,255,255,0.4)';
      ctx.font = `${Math.max(9, pixelsPerFoot / 5)}px Inter`;
      for (let x = pixelsPerFoot; x < roomW; x += pixelsPerFoot) {
        ctx.fillText(`${Math.round(x / pixelsPerFoot)}'`, x, -25);
        // Tick mark
        ctx.strokeStyle = 'rgba(255,255,255,0.3)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, -6);
        ctx.stroke();
      }
      for (let y = pixelsPerFoot; y < roomH; y += pixelsPerFoot) {
        ctx.save();
        ctx.translate(-25, y);
        ctx.rotate(-Math.PI / 2);
        ctx.fillText(`${Math.round(y / pixelsPerFoot)}'`, 0, 0);
        ctx.restore();
        // Tick mark
        ctx.strokeStyle = 'rgba(255,255,255,0.3)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(-6, y);
        ctx.stroke();
      }
    }

    function drawFloorPlanAreas() {
      walls.filter(w => w.type === 'area').forEach(area => {
        ctx.fillStyle = 'rgba(60, 60, 80, 0.6)';
        ctx.fillRect(area.x, area.y, area.width, area.height);
        ctx.strokeStyle = '#666';
        ctx.lineWidth = 2;
        ctx.strokeRect(area.x, area.y, area.width, area.height);
      });
    }

    function drawWalls() {
      walls.filter(w => w.type === 'wall').forEach(wall => {
        ctx.fillStyle = wall.color;
        ctx.fillRect(wall.x, wall.y, wall.width, wall.height);
      });
    }

    function drawElements() {
      elements.forEach(el => {
        drawElement(el, el === selectedElement);
      });
    }

    function drawElement(el, isSelected) {
      const x = el.x;
      const y = el.y;
      const w = el.width * pixelsPerFoot;
      const h = el.height * pixelsPerFoot;

      ctx.save();
      ctx.translate(x + w/2, y + h/2);
      ctx.rotate((el.rotation || 0) * Math.PI / 180);
      ctx.translate(-(x + w/2), -(y + h/2));

      // Background with slight shadow
      ctx.shadowColor = 'rgba(0,0,0,0.3)';
      ctx.shadowBlur = 8;
      ctx.shadowOffsetX = 2;
      ctx.shadowOffsetY = 2;

      if (el.textureImg) {
        ctx.drawImage(el.textureImg, x, y, w, h);
      } else {
        ctx.fillStyle = el.color;
        ctx.fillRect(x, y, w, h);
      }

      // Reset shadow for borders/text
      ctx.shadowColor = 'transparent';
      ctx.shadowBlur = 0;
      ctx.shadowOffsetX = 0;
      ctx.shadowOffsetY = 0;

      // Border
      ctx.strokeStyle = isSelected ? '#6366f1' : 'rgba(255,255,255,0.25)';
      ctx.lineWidth = isSelected ? 3 : 1;
      ctx.strokeRect(x, y, w, h);

      // Label background for readability
      const labelFontSize = Math.max(10, pixelsPerFoot / 3);
      ctx.font = `${labelFontSize}px Inter`;
      const labelWidth = ctx.measureText(el.label).width + 10;
      ctx.fillStyle = 'rgba(0,0,0,0.5)';
      ctx.fillRect(x + w/2 - labelWidth/2, y + h/2 - labelFontSize/2 - 2, labelWidth, labelFontSize + 4);

      // Label text
      ctx.fillStyle = 'rgba(255,255,255,0.95)';
      ctx.textAlign = 'center';
      ctx.fillText(el.label, x + w/2, y + h/2 + 4);

      // Dimensions
      ctx.fillStyle = 'rgba(255,255,255,0.6)';
      ctx.font = `${Math.max(8, pixelsPerFoot / 4)}px Inter`;
      ctx.fillText(`${el.width}' × ${el.height}'`, x + w/2, y + h/2 + 18);

      // Selection handles
      if (isSelected) {
        const hs = 10;
        ctx.fillStyle = '#6366f1';
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        [[x, y], [x + w, y], [x, y + h], [x + w, y + h]].forEach(([hx, hy]) => {
          ctx.fillRect(hx - hs/2, hy - hs/2, hs, hs);
          ctx.strokeRect(hx - hs/2, hy - hs/2, hs, hs);
        });

        if (el.locked) {
          ctx.fillStyle = 'rgba(239, 68, 68, 0.9)';
          ctx.font = '14px Inter';
          ctx.fillText('🔒', x + w - 12, y + 16);
        }
      }

      ctx.restore();
    }

    // ===== MOUSE EVENTS =====
    // Convert screen coordinates to world coordinates (accounting for pan)
    function screenToWorld(screenX, screenY) {
      return {
        x: screenX - panX,
        y: screenY - panY
      };
    }

    function onMouseDown(e) {
      const rect = canvas.getBoundingClientRect();
      const screenX = e.clientX - rect.left;
      const screenY = e.clientY - rect.top;
      const { x, y } = screenToWorld(screenX, screenY);

      // Pan tool or middle mouse button
      if (currentTool === 'pan' || e.button === 1) {
        isPanning = true;
        panStart = { x: screenX - panX, y: screenY - panY };
        canvas.style.cursor = 'grabbing';
        return;
      }

      // Space + drag to pan
      if (e.spaceKey) {
        isPanning = true;
        panStart = { x: screenX - panX, y: screenY - panY };
        return;
      }

      if (currentTool === 'wall') {
        isDrawingWall = true;
        wallStart = { x, y };
        return;
      }

      if (currentTool !== 'select') return;

      const clicked = [...elements].reverse().find(el => isPointInElement(x, y, el));

      if (clicked) {
        selectedElement = clicked;
        if (!clicked.locked) {
          isDragging = true;
          dragOffset = { x: x - clicked.x, y: y - clicked.y };
        }
        updateProperties();
      } else {
        selectedElement = null;
        updateProperties();
      }

      draw();
    }

    function onMouseMove(e) {
      const rect = canvas.getBoundingClientRect();
      const screenX = e.clientX - rect.left;
      const screenY = e.clientY - rect.top;
      const { x, y } = screenToWorld(screenX, screenY);

      // Handle panning
      if (isPanning) {
        panX = screenX - panStart.x;
        panY = screenY - panStart.y;
        draw();
        return;
      }

      if (isDrawingWall && wallStart) {
        // Preview wall while drawing
        draw();
        ctx.save();
        ctx.translate(panX, panY);
        ctx.fillStyle = 'rgba(100, 100, 100, 0.5)';
        const wx = Math.min(wallStart.x, x);
        const wy = Math.min(wallStart.y, y);
        const ww = Math.abs(x - wallStart.x) || CONFIG.WALL_THICKNESS;
        const wh = Math.abs(y - wallStart.y) || CONFIG.WALL_THICKNESS;
        ctx.fillRect(wx, wy, ww, wh);
        ctx.restore();
        return;
      }

      if (!isDragging || !selectedElement || selectedElement.locked) return;

      const gridSnap = pixelsPerFoot / CONFIG.GRID_SUBDIVISIONS;
      const snapX = Math.round((x - dragOffset.x) / gridSnap) * gridSnap;
      const snapY = Math.round((y - dragOffset.y) / gridSnap) * gridSnap;

      // Allow elements to be placed anywhere (no canvas boundary restriction)
      selectedElement.x = snapX;
      selectedElement.y = snapY;

      draw();
    }

    function onMouseUp(e) {
      if (isPanning) {
        isPanning = false;
        canvas.style.cursor = currentTool === 'pan' ? 'grab' : (currentTool === 'wall' ? 'crosshair' : 'default');
        return;
      }

      if (isDrawingWall && wallStart) {
        const rect = canvas.getBoundingClientRect();
        const screenX = e.clientX - rect.left;
        const screenY = e.clientY - rect.top;
        const { x, y } = screenToWorld(screenX, screenY);

        const wx = Math.min(wallStart.x, x);
        const wy = Math.min(wallStart.y, y);
        let ww = Math.abs(x - wallStart.x);
        let wh = Math.abs(y - wallStart.y);

        // Make it a proper wall (thin in one dimension)
        if (ww < wh) {
          ww = CONFIG.WALL_THICKNESS;
        } else {
          wh = CONFIG.WALL_THICKNESS;
        }

        if (ww > 10 || wh > 10) {
          addWall(wx, wy, ww, wh);
        }

        isDrawingWall = false;
        wallStart = null;
        draw();
        return;
      }

      isDragging = false;
    }

    function onContextMenu(e) {
      e.preventDefault();
      const rect = canvas.getBoundingClientRect();
      const screenX = e.clientX - rect.left;
      const screenY = e.clientY - rect.top;
      const { x, y } = screenToWorld(screenX, screenY);

      const clicked = [...elements].reverse().find(el => isPointInElement(x, y, el));

      if (clicked) {
        selectedElement = clicked;
        contextMenuElement = clicked;
        showContextMenu(e.clientX, e.clientY, clicked);
        draw();
      }
    }

    function onDoubleClick(e) {
      const rect = canvas.getBoundingClientRect();
      const screenX = e.clientX - rect.left;
      const screenY = e.clientY - rect.top;
      const { x, y } = screenToWorld(screenX, screenY);

      const clicked = [...elements].reverse().find(el => isPointInElement(x, y, el));

      if (clicked) {
        const newLabel = prompt('Enter label:', clicked.label);
        if (newLabel) {
          clicked.label = newLabel;
          draw();
        }
      }
    }

    function isPointInElement(px, py, el) {
      const w = el.width * pixelsPerFoot;
      const h = el.height * pixelsPerFoot;
      return px >= el.x && px <= el.x + w && py >= el.y && py <= el.y + h;
    }

    // ===== KEYBOARD EVENTS =====
    let spacePressed = false;

    function onKeyDown(e) {
      if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') return;

      // Space to pan
      if (e.code === 'Space' && !spacePressed) {
        spacePressed = true;
        canvas.style.cursor = 'grab';
        e.preventDefault();
        return;
      }

      switch(e.key.toLowerCase()) {
        case 'v': setTool('select'); break;
        case 'w': setTool('wall'); break;
        case 'h': setTool('pan'); break;
        case 'f': fitToScreen(); break; // F to fit
        case 'delete':
        case 'backspace':
          if (selectedElement && !selectedElement.locked) {
            elements = elements.filter(el => el !== selectedElement);
            selectedElement = null;
            updateProperties();
            draw();
          }
          break;
        case 'r':
          if (selectedElement && !selectedElement.locked) {
            selectedElement.rotation = ((selectedElement.rotation || 0) + 90) % 360;
            updateProperties();
            draw();
          }
          break;
        case 'd':
          if ((e.ctrlKey || e.metaKey) && selectedElement) {
            e.preventDefault();
            duplicateElement(selectedElement);
          }
          break;
        case 'escape':
          selectedElement = null;
          hideContextMenu();
          updateProperties();
          draw();
          break;
        case '=':
        case '+':
          if (e.ctrlKey || e.metaKey) {
            e.preventDefault();
            zoomIn();
          }
          break;
        case '-':
          if (e.ctrlKey || e.metaKey) {
            e.preventDefault();
            zoomOut();
          }
          break;
        case '0':
          if (e.ctrlKey || e.metaKey) {
            e.preventDefault();
            fitToScreen();
          }
          break;
      }
    }

    function onKeyUp(e) {
      if (e.code === 'Space') {
        spacePressed = false;
        canvas.style.cursor = currentTool === 'pan' ? 'grab' : (currentTool === 'wall' ? 'crosshair' : 'default');
      }
    }

    // Mouse wheel zoom
    function onWheel(e) {
      e.preventDefault();

      const rect = canvas.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;

      // Get world position before zoom
      const worldX = (mouseX - panX) / pixelsPerFoot;
      const worldY = (mouseY - panY) / pixelsPerFoot;

      // Adjust pixels per foot
      const zoomFactor = e.deltaY < 0 ? 1.1 : 0.9;
      const newPixelsPerFoot = Math.max(15, Math.min(100, pixelsPerFoot * zoomFactor));

      // Adjust pan to zoom toward mouse position
      panX = mouseX - worldX * newPixelsPerFoot;
      panY = mouseY - worldY * newPixelsPerFoot;

      pixelsPerFoot = newPixelsPerFoot;

      document.getElementById('scaleMode').value = 'fit'; // Reset dropdown
      document.getElementById('zoomLevel').textContent = Math.round(pixelsPerFoot / 40 * 100) + '%';

      draw();
    }

    // ===== DRAG & DROP =====
    function onDrop(e) {
      e.preventDefault();
      const type = e.dataTransfer.getData('element-type');
      if (!type) return;

      const rect = canvas.getBoundingClientRect();
      const screenX = e.clientX - rect.left;
      const screenY = e.clientY - rect.top;
      const { x, y } = screenToWorld(screenX, screenY);

      createElement(type, x, y);
    }

    function createElement(type, x, y) {
      let defaults = null;
      Object.values(ELEMENT_TYPES).forEach(cat => {
        const found = cat.find(el => el.type === type);
        if (found) defaults = found;
      });

      if (!defaults) return;

      const gridSnap = pixelsPerFoot / CONFIG.GRID_SUBDIVISIONS;
      const element = {
        id: Date.now() + Math.random(),
        type: type,
        x: Math.round(x / gridSnap) * gridSnap,
        y: Math.round(y / gridSnap) * gridSnap,
        width: defaults.width,
        height: defaults.height,
        color: defaults.color,
        label: defaults.label,
        rotation: 0,
        locked: false,
        texture: elementTextures[type] || null,
        textureImg: null
      };

      // Load texture if exists
      if (element.texture) {
        const img = new Image();
        img.onload = () => {
          element.textureImg = img;
          draw();
        };
        img.src = element.texture;
      }

      elements.push(element);
      selectedElement = element;
      updateProperties();
      draw();
    }

    function duplicateElement(el) {
      const gridSnap = pixelsPerFoot / CONFIG.GRID_SUBDIVISIONS;
      const newEl = {
        ...el,
        id: Date.now() + Math.random(),
        x: el.x + gridSnap * 2,
        y: el.y + gridSnap * 2,
        locked: false
      };
      elements.push(newEl);
      selectedElement = newEl;
      updateProperties();
      draw();
    }

    // ===== CONTEXT MENU =====
    function showContextMenu(x, y, element) {
      const menu = document.getElementById('contextMenu');
      menu.style.display = 'block';
      menu.style.left = x + 'px';
      menu.style.top = y + 'px';

      document.getElementById('contextMenuLabel').textContent = element.label;
      document.getElementById('lockText').textContent = element.locked ? 'Unlock' : 'Lock';
    }

    function hideContextMenu() {
      document.getElementById('contextMenu').style.display = 'none';
      contextMenuElement = null;
    }

    function contextAction(action) {
      if (!contextMenuElement) return;

      switch(action) {
        case 'rotate':
          if (!contextMenuElement.locked) {
            contextMenuElement.rotation = ((contextMenuElement.rotation || 0) + 90) % 360;
          }
          break;
        case 'duplicate':
          duplicateElement(contextMenuElement);
          break;
        case 'texture':
          selectedElement = contextMenuElement;
          openMaterialPicker();
          break;
        case 'lock':
          contextMenuElement.locked = !contextMenuElement.locked;
          break;
        case 'front':
          elements = elements.filter(el => el !== contextMenuElement);
          elements.push(contextMenuElement);
          break;
        case 'back':
          elements = elements.filter(el => el !== contextMenuElement);
          elements.unshift(contextMenuElement);
          break;
        case 'delete':
          if (!contextMenuElement.locked) {
            elements = elements.filter(el => el !== contextMenuElement);
            if (selectedElement === contextMenuElement) {
              selectedElement = null;
              updateProperties();
            }
          }
          break;
      }

      hideContextMenu();
      draw();
    }

    // ===== TOOLS =====
    function setTool(tool) {
      currentTool = tool;
      document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('active'));
      const btn = document.getElementById('tool' + tool.charAt(0).toUpperCase() + tool.slice(1));
      if (btn) btn.classList.add('active');

      canvas.style.cursor = tool === 'wall' ? 'crosshair' : (tool === 'pan' ? 'grab' : 'default');
    }

    function toggleSection(header) {
      const content = header.nextElementSibling;
      const toggle = header.querySelector('.sidebar-toggle');
      content.classList.toggle('collapsed');
      toggle.textContent = content.classList.contains('collapsed') ? '▶' : '▼';
    }

    // ===== VIEW =====
    function setView(view) {
      currentView = view;
      document.getElementById('view2D').classList.toggle('active', view === '2d');
      document.getElementById('view3D').classList.toggle('active', view === '3d');

      const canvasWrapper = document.getElementById('canvasWrapper');
      const threeContainer = document.getElementById('three-container');

      if (view === '3d') {
        canvasWrapper.style.display = 'none';
        threeContainer.classList.add('active');
        init3D();
        render3D();
      } else {
        canvasWrapper.style.display = 'block';
        threeContainer.classList.remove('active');
      }
    }

    // ===== 3D VIEW =====
    function init3D() {
      if (scene) return;

      const container = document.getElementById('three-container');
      const width = container.clientWidth;
      const height = container.clientHeight;

      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x1a1a2e);

      camera = new THREE.PerspectiveCamera(60, width / height, 0.1, 1000);
      camera.position.set(roomWidth * 0.7, roomDepth * 0.7, roomWidth * 0.7);
      camera.lookAt(0, 0, 0);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(width, height);
      renderer.shadowMap.enabled = true;
      container.appendChild(renderer.domElement);

      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;

      const ambient = new THREE.AmbientLight(0xffffff, 0.5);
      scene.add(ambient);

      const directional = new THREE.DirectionalLight(0xffffff, 0.8);
      directional.position.set(10, 20, 10);
      directional.castShadow = true;
      scene.add(directional);

      window.addEventListener('resize', () => {
        const w = container.clientWidth;
        const h = container.clientHeight;
        camera.aspect = w / h;
        camera.updateProjectionMatrix();
        renderer.setSize(w, h);
      });
    }

    function render3D() {
      if (!scene || currentView !== '3d') return;

      // Clear non-lights
      scene.children = scene.children.filter(c => c.type.includes('Light'));

      // Floor
      const floor = new THREE.Mesh(
        new THREE.PlaneGeometry(roomWidth, roomDepth),
        new THREE.MeshStandardMaterial({ color: 0x2a2a3a, side: THREE.DoubleSide })
      );
      floor.rotation.x = -Math.PI / 2;
      floor.receiveShadow = true;
      scene.add(floor);

      // Grid
      scene.add(new THREE.GridHelper(Math.max(roomWidth, roomDepth), Math.max(roomWidth, roomDepth), 0x444, 0x333));

      // Elements
      elements.forEach(el => {
        const w = el.width;
        const d = el.height;
        const h = el.type.includes('cabinet') ? (el.type === 'tall-cabinet' ? 7 : 3) : 1;

        const mesh = new THREE.Mesh(
          new THREE.BoxGeometry(w, h, d),
          new THREE.MeshStandardMaterial({ color: el.color })
        );

        mesh.position.set(
          (el.x / pixelsPerFoot) - roomWidth/2 + w/2,
          h/2,
          (el.y / pixelsPerFoot) - roomDepth/2 + d/2
        );
        mesh.rotation.y = (el.rotation || 0) * Math.PI / 180;
        mesh.castShadow = true;
        scene.add(mesh);
      });

      function animate() {
        if (currentView !== '3d') return;
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
      }
      animate();
    }

    // ===== ZOOM =====
    function zoomIn() {
      const wrapper = document.getElementById('canvasWrapper');
      const centerX = wrapper.clientWidth / 2;
      const centerY = wrapper.clientHeight / 2;

      const worldX = (centerX - panX) / pixelsPerFoot;
      const worldY = (centerY - panY) / pixelsPerFoot;

      pixelsPerFoot = Math.min(pixelsPerFoot * 1.2, 100);

      panX = centerX - worldX * pixelsPerFoot;
      panY = centerY - worldY * pixelsPerFoot;

      updateZoomDisplay();
      draw();
    }

    function zoomOut() {
      const wrapper = document.getElementById('canvasWrapper');
      const centerX = wrapper.clientWidth / 2;
      const centerY = wrapper.clientHeight / 2;

      const worldX = (centerX - panX) / pixelsPerFoot;
      const worldY = (centerY - panY) / pixelsPerFoot;

      pixelsPerFoot = Math.max(pixelsPerFoot / 1.2, 15);

      panX = centerX - worldX * pixelsPerFoot;
      panY = centerY - worldY * pixelsPerFoot;

      updateZoomDisplay();
      draw();
    }

    function updateZoomDisplay() {
      const zoomPercent = Math.round(pixelsPerFoot / 40 * 100);
      document.getElementById('zoomLevel').textContent = zoomPercent + '%';
    }

    // ===== ROOM =====
    function updateRoom() {
      roomWidth = parseInt(document.getElementById('roomWidth').value) || 20;
      roomDepth = parseInt(document.getElementById('roomDepth').value) || 16;

      if (document.getElementById('scaleMode').value === 'fit') {
        fitToScreen();
      } else {
        updateCanvasSize();
      }

      if (currentView === '3d') {
        scene = null;
        document.getElementById('three-container').innerHTML = '';
        init3D();
        render3D();
      }
    }

    // ===== PROPERTIES =====
    function updateProperties() {
      const empty = document.getElementById('propertiesEmpty');
      const content = document.getElementById('propertiesContent');

      if (selectedElement) {
        empty.style.display = 'none';
        content.style.display = 'block';

        document.getElementById('propType').textContent = selectedElement.label;
        document.getElementById('propWidth').value = selectedElement.width;
        document.getElementById('propHeight').value = selectedElement.height;
        document.getElementById('propColor').value = selectedElement.color;
        document.getElementById('propRotation').textContent = (selectedElement.rotation || 0) + '°';

        const texturePreview = document.getElementById('propTexture');
        if (selectedElement.texture) {
          texturePreview.style.background = `url(${selectedElement.texture}) center/cover`;
        } else {
          texturePreview.style.background = selectedElement.color;
        }
      } else {
        empty.style.display = 'block';
        content.style.display = 'none';
      }
    }

    function updateSelectedElement() {
      if (!selectedElement || selectedElement.locked) return;

      selectedElement.width = parseFloat(document.getElementById('propWidth').value) || 1;
      selectedElement.height = parseFloat(document.getElementById('propHeight').value) || 1;
      selectedElement.color = document.getElementById('propColor').value;

      draw();
    }

    // ===== MATERIALS =====
    function openMaterialPicker() {
      if (!selectedElement) return;

      document.getElementById('materialModal').classList.add('active');
      renderMaterialCategories();
      renderMaterials('granite');
    }

    function renderMaterialCategories() {
      const container = document.getElementById('materialCategories');
      container.innerHTML = Object.keys(MATERIALS).map(cat => `
        <button class="material-category-btn ${cat === 'granite' ? 'active' : ''}"
                onclick="renderMaterials('${cat}', this)">
          ${cat.charAt(0).toUpperCase() + cat.slice(1)}
        </button>
      `).join('') + `
        <button class="material-category-btn" onclick="renderMaterials('custom', this)">
          My Uploads
        </button>
      `;
    }

    function renderMaterials(category, btn) {
      document.querySelectorAll('.material-category-btn').forEach(b => b.classList.remove('active'));
      if (btn) btn.classList.add('active');

      const container = document.getElementById('materialsGrid');

      if (category === 'custom') {
        container.innerHTML = `
          <div class="upload-material-btn" onclick="document.getElementById('materialUpload').click()">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
              <polyline points="17 8 12 3 7 8"/>
              <line x1="12" y1="3" x2="12" y2="15"/>
            </svg>
            <span>Upload</span>
          </div>
          ${customMaterials.map(m => `
            <div class="material-modal-item"
                 style="background: url(${m.url}) center/cover"
                 onclick="applyMaterial('${m.url}')">
              <div class="material-name">${m.name}</div>
            </div>
          `).join('')}
        `;
      } else {
        const materials = MATERIALS[category] || [];
        container.innerHTML = `
          <div class="upload-material-btn" onclick="document.getElementById('materialUpload').click()">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
              <polyline points="17 8 12 3 7 8"/>
              <line x1="12" y1="3" x2="12" y2="15"/>
            </svg>
            <span>Upload</span>
          </div>
          ${materials.map(m => `
            <div class="material-modal-item"
                 style="background: ${m.url ? `url(${m.url})` : m.color} center/cover"
                 onclick="applyMaterial('${m.url || m.color}', '${m.color}')">
              <div class="material-name">${m.name}</div>
            </div>
          `).join('')}
        `;
      }
    }

    function applyMaterial(urlOrColor, fallbackColor) {
      if (!selectedElement) return;

      if (urlOrColor.startsWith('http') || urlOrColor.startsWith('data:')) {
        selectedElement.texture = urlOrColor;
        const img = new Image();
        img.crossOrigin = 'anonymous';
        img.onload = () => {
          selectedElement.textureImg = img;
          draw();
          updateProperties();
        };
        img.onerror = () => {
          selectedElement.color = fallbackColor || '#888';
          draw();
        };
        img.src = urlOrColor;
      } else {
        selectedElement.texture = null;
        selectedElement.textureImg = null;
        selectedElement.color = urlOrColor;
        draw();
        updateProperties();
      }

      closeModal('materialModal');
    }

    function handleMaterialUpload(e) {
      const file = e.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = (event) => {
        const url = event.target.result;
        const name = file.name.split('.')[0];

        customMaterials.push({ id: Date.now(), name, url });

        if (selectedElement) {
          applyMaterial(url);
        }
      };
      reader.readAsDataURL(file);
      e.target.value = '';
    }

    function uploadElementTexture(type) {
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = 'image/*';
      input.onchange = (e) => {
        const file = e.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = (event) => {
          elementTextures[type] = event.target.result;
          renderSidebar();
        };
        reader.readAsDataURL(file);
      };
      input.click();
    }

    // ===== QUOTE =====
    function calculateQuote() {
      const items = {};
      let total = 0;

      elements.forEach(el => {
        const price = CONFIG.PRICING[el.type] || 0;
        let cost = ['countertop', 'backsplash', 'flooring', 'tile'].includes(el.type)
          ? el.width * el.height * price
          : price;

        if (!items[el.type]) {
          items[el.type] = { count: 0, total: 0, label: el.label };
        }
        items[el.type].count++;
        items[el.type].total += cost;
        total += cost;
      });

      const quoteItems = document.getElementById('quoteItems');
      quoteItems.innerHTML = Object.keys(items).length === 0
        ? '<div class="quote-item"><span class="quote-item-name">No items yet</span><span class="quote-item-value">$0</span></div>'
        : Object.entries(items).map(([t, d]) => `
            <div class="quote-item">
              <span class="quote-item-name">${d.label} (${d.count})</span>
              <span class="quote-item-value">$${d.total.toLocaleString()}</span>
            </div>
          `).join('');

      document.getElementById('quoteTotal').textContent = '$' + total.toLocaleString();
    }

    function generateQuote() {
      const projectName = document.getElementById('projectName').value;
      const roomType = document.getElementById('roomType').value;

      let text = `QUOTE: ${projectName}\nRoom: ${roomType} (${roomWidth}' × ${roomDepth}')\n${'='.repeat(30)}\n\n`;
      elements.forEach(el => {
        text += `${el.label}: ${el.width}' × ${el.height}'\n`;
      });
      text += `\n${'='.repeat(30)}\nTotal: ${document.getElementById('quoteTotal').textContent}`;

      alert(text);
    }

    // ===== MODALS =====
    function openShareModal() {
      const token = Math.random().toString(36).substring(2, 14);
      document.getElementById('shareLink').value = `https://surprisegranite.com/tools/room-designer?p=${token}`;
      document.getElementById('shareModal').classList.add('active');
    }

    function closeModal(id) {
      document.getElementById(id).classList.remove('active');
    }

    function copyShareLink() {
      const input = document.getElementById('shareLink');
      input.select();
      document.execCommand('copy');
      alert('Link copied!');
    }

    function setSharePermission(perm, btn) {
      document.querySelectorAll('.permission-btn').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
    }

    function clearCanvas() {
      if (confirm('Clear all elements?')) {
        elements = [];
        walls = walls.filter(w => w.type === 'area');
        selectedElement = null;
        updateProperties();
        draw();
      }
    }
  </script>
</body>
</html>
